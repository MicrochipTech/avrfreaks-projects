
MaxReadWrite.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005c0  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000044  00800100  00800100  00000634  2**0
                  ALLOC
  2 .debug_aranges 00000040  00000000  00000000  00000634  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 000000b3  00000000  00000000  00000674  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000007a5  00000000  00000000  00000727  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 000002bb  00000000  00000000  00000ecc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000641  00000000  00000000  00001187  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000080  00000000  00000000  000017c8  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    000002ec  00000000  00000000  00001848  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000524  00000000  00000000  00001b34  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000018  00000000  00000000  00002058  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 c0 00 	jmp	0x180	; 0x180 <__ctors_end>
   4:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
   8:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
   c:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  10:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  14:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  18:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  1c:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  20:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  24:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  28:	0c 94 68 01 	jmp	0x2d0	; 0x2d0 <__vector_10>
  2c:	0c 94 99 01 	jmp	0x332	; 0x332 <__vector_11>
  30:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  34:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  38:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  3c:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  40:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  44:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  48:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  4c:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  50:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  54:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  58:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  5c:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  60:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  64:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  68:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  6c:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  70:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  74:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  78:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  7c:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  80:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  84:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  88:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  8c:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  90:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  94:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  98:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  9c:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  a0:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  a4:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
  a8:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>

000000ac <descriptor_list>:
  ac:	00 01 00 00 e5 00 12 00 02 00 00 f7 00 29 00 22     .............)."
  bc:	00 00 20 01 1c 00 21 00 00 09 01 09 00 03 00 00     .. ...!.........
  cc:	3c 01 04 01 03 09 04 40 01 12 02 03 09 04 54 01     <......@......T.
  dc:	2a                                                  *

000000dd <endpoint_config_table>:
  dd:	01 c1 32 01 c0 32 00 00                             ..2..2..

000000e5 <device_descriptor>:
  e5:	12 01 00 02 00 00 00 40 c0 16 80 04 00 01 01 02     .......@........
  f5:	00 01                                               ..

000000f7 <config1_descriptor>:
  f7:	09 02 29 00 01 01 00 c0 32 09 04 00 00 02 03 00     ..).....2.......
 107:	00 00 09 21 11 01 00 01 22 1c 00 07 05 81 03 40     ...!...."......@
 117:	00 02 07 05 02 03 40 00 08                          ......@..

00000120 <rawhid_hid_report_desc>:
 120:	06 ab ff 0a 00 02 a1 01 15 00 26 ff 00 75 08 95     ..........&..u..
 130:	40 09 00 91 02 09 01 95 40 81 02 c0                 @.......@...

0000013c <string0>:
 13c:	04 03 09 04                                         ....

00000140 <string1>:
 140:	12 03 50 00 4a 00 52 00 43 00 2e 00 43 00 4f 00     ..P.J.R.C...C.O.
 150:	4d 00 00 00                                         M...

00000154 <string2>:
 154:	2a 03 48 00 49 00 44 00 20 00 6d 00 61 00 78 00     *.H.I.D. .m.a.x.
 164:	20 00 73 00 65 00 6e 00 64 00 20 00 72 00 65 00      .s.e.n.d. .r.e.
 174:	63 00 65 00 69 00 76 00 65 00 00 00                 c.e.i.v.e...

00000180 <__ctors_end>:
 180:	11 24       	eor	r1, r1
 182:	1f be       	out	0x3f, r1	; 63
 184:	cf ef       	ldi	r28, 0xFF	; 255
 186:	da e0       	ldi	r29, 0x0A	; 10
 188:	de bf       	out	0x3e, r29	; 62
 18a:	cd bf       	out	0x3d, r28	; 61

0000018c <__do_clear_bss>:
 18c:	11 e0       	ldi	r17, 0x01	; 1
 18e:	a0 e0       	ldi	r26, 0x00	; 0
 190:	b1 e0       	ldi	r27, 0x01	; 1
 192:	01 c0       	rjmp	.+2      	; 0x196 <.do_clear_bss_start>

00000194 <.do_clear_bss_loop>:
 194:	1d 92       	st	X+, r1

00000196 <.do_clear_bss_start>:
 196:	a4 34       	cpi	r26, 0x44	; 68
 198:	b1 07       	cpc	r27, r17
 19a:	e1 f7       	brne	.-8      	; 0x194 <.do_clear_bss_loop>
 19c:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <main>
 1a0:	0c 94 de 02 	jmp	0x5bc	; 0x5bc <_exit>

000001a4 <__bad_interrupt>:
 1a4:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001a8 <main>:
int main(void)
{
uint8_t temp ;


	sbi(PORTF,1);	// pull up for PORT F pin 1 - ARUINO Leonardo board A4 pin
 1a8:	89 9a       	sbi	0x11, 1	; 17

	// UART setting for serial port debug if received data are same

	UCSR1A = 0;                         // importantly U2X1 = 0
 1aa:	10 92 c8 00 	sts	0x00C8, r1
	UCSR1B = (1 << TXEN1);                         // interrupts enabled in here if you like
 1ae:	88 e0       	ldi	r24, 0x08	; 8
 1b0:	80 93 c9 00 	sts	0x00C9, r24
	UCSR1C = _BV(UCSZ11) | _BV(UCSZ10); // no parity, 8 data bits, 1 stop bit
 1b4:	86 e0       	ldi	r24, 0x06	; 6
 1b6:	80 93 ca 00 	sts	0x00CA, r24
	UBRR1  = 51;                       // 9600 baud @ 8MHz XTAL with U2X1 = 0    
 1ba:	83 e3       	ldi	r24, 0x33	; 51
 1bc:	90 e0       	ldi	r25, 0x00	; 0
 1be:	90 93 cd 00 	sts	0x00CD, r25
 1c2:	80 93 cc 00 	sts	0x00CC, r24
	SU = 0;
 1c6:	10 92 43 01 	sts	0x0143, r1

	// set for 8 MHz clock
	CPU_PRESCALE(0);
 1ca:	80 e8       	ldi	r24, 0x80	; 128
 1cc:	80 93 61 00 	sts	0x0061, r24
 1d0:	10 92 61 00 	sts	0x0061, r1
	// Initialize the USB, and then wait for the host to set configuration.
	// If the Teensy is powered without a PC connected to the USB port,
	// this will wait forever.
	usb_init();
 1d4:	0e 94 20 01 	call	0x240	; 0x240 <usb_init>
	while (!usb_configured()) /* wait */ ;
 1d8:	0e 94 37 01 	call	0x26e	; 0x26e <usb_configured>
 1dc:	88 23       	and	r24, r24
 1de:	e1 f3       	breq	.-8      	; 0x1d8 <main+0x30>
 1e0:	80 e1       	ldi	r24, 0x10	; 16
 1e2:	97 e2       	ldi	r25, 0x27	; 39
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 1e4:	28 ec       	ldi	r18, 0xC8	; 200
 1e6:	30 e0       	ldi	r19, 0x00	; 0
 1e8:	f9 01       	movw	r30, r18
 1ea:	31 97       	sbiw	r30, 0x01	; 1
 1ec:	f1 f7       	brne	.-4      	; 0x1ea <main+0x42>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 1ee:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 1f0:	d9 f7       	brne	.-10     	; 0x1e8 <main+0x40>
	// and do whatever it does to actually be ready for input
	_delay_ms(1000);

	while (1) 
		{
		if (!(PINF & (1<<1)))
 1f2:	79 99       	sbic	0x0f, 1	; 15
 1f4:	0e c0       	rjmp	.+28     	; 0x212 <main+0x6a>
			{
			while (!(PINF & (1<<1)));
 1f6:	79 9b       	sbis	0x0f, 1	; 15
 1f8:	fe cf       	rjmp	.-4      	; 0x1f6 <main+0x4e>
 1fa:	e3 e0       	ldi	r30, 0x03	; 3
 1fc:	f1 e0       	ldi	r31, 0x01	; 1
 1fe:	8e e7       	ldi	r24, 0x7E	; 126
			//temp = 0;
			for (temp=0;temp < (RAWHID_TX_SIZE ); temp++) {buffer[temp]=126-temp;} // fill buffer for send .. with 40,3F,3E..2,1 (in hex)
 200:	81 93       	st	Z+, r24
 202:	81 50       	subi	r24, 0x01	; 1
 204:	8e 33       	cpi	r24, 0x3E	; 62
 206:	e1 f7       	brne	.-8      	; 0x200 <main+0x58>
			usb_rawhid_send(buffer,8); // send buffer 8 - timeout..
 208:	83 e0       	ldi	r24, 0x03	; 3
 20a:	91 e0       	ldi	r25, 0x01	; 1
 20c:	68 e0       	ldi	r22, 0x08	; 8
 20e:	0e 94 3a 01 	call	0x274	; 0x274 <usb_rawhid_send>
			}

		if (SU)
 212:	80 91 43 01 	lds	r24, 0x0143
 216:	88 23       	and	r24, r24
 218:	61 f3       	breq	.-40     	; 0x1f2 <main+0x4a>
			{
			SU = 0;
 21a:	10 92 43 01 	sts	0x0143, r1
 21e:	e3 e0       	ldi	r30, 0x03	; 3
 220:	f1 e0       	ldi	r31, 0x01	; 1
			 for (temp=0;temp < (RAWHID_TX_SIZE + 1); temp++)
				{
				while(!(UCSR1A & (1 << UDRE1)));   //wait until tx register is empty
 222:	80 91 c8 00 	lds	r24, 0x00C8
 226:	85 ff       	sbrs	r24, 5
 228:	fc cf       	rjmp	.-8      	; 0x222 <main+0x7a>
				if (buffer[temp]) outb(UDR1,buffer[temp]);
 22a:	80 81       	ld	r24, Z
 22c:	88 23       	and	r24, r24
 22e:	11 f0       	breq	.+4      	; 0x234 <main+0x8c>
 230:	80 93 ce 00 	sts	0x00CE, r24
 234:	31 96       	adiw	r30, 0x01	; 1
			}

		if (SU)
			{
			SU = 0;
			 for (temp=0;temp < (RAWHID_TX_SIZE + 1); temp++)
 236:	81 e0       	ldi	r24, 0x01	; 1
 238:	e4 34       	cpi	r30, 0x44	; 68
 23a:	f8 07       	cpc	r31, r24
 23c:	91 f7       	brne	.-28     	; 0x222 <main+0x7a>
 23e:	d9 cf       	rjmp	.-78     	; 0x1f2 <main+0x4a>

00000240 <usb_init>:


// initialize USB
void usb_init(void)
{
	HW_CONFIG();
 240:	81 e0       	ldi	r24, 0x01	; 1
 242:	80 93 d7 00 	sts	0x00D7, r24
	USB_FREEZE();				// enable USB
 246:	80 ea       	ldi	r24, 0xA0	; 160
 248:	80 93 d8 00 	sts	0x00D8, r24
	PLL_CONFIG();				// config PLL
 24c:	82 e0       	ldi	r24, 0x02	; 2
 24e:	89 bd       	out	0x29, r24	; 41
        while (!(PLLCSR & (1<<PLOCK))) ;	// wait for PLL lock
 250:	09 b4       	in	r0, 0x29	; 41
 252:	00 fe       	sbrs	r0, 0
 254:	fd cf       	rjmp	.-6      	; 0x250 <usb_init+0x10>
        USB_CONFIG();				// start USB clock
 256:	80 e9       	ldi	r24, 0x90	; 144
 258:	80 93 d8 00 	sts	0x00D8, r24
        UDCON = 0;				// enable attach resistor
 25c:	10 92 e0 00 	sts	0x00E0, r1
	usb_configuration = 0;
 260:	10 92 01 01 	sts	0x0101, r1
    UDIEN = (1<<EORSTE)|(1<<SOFE);
 264:	8c e0       	ldi	r24, 0x0C	; 12
 266:	80 93 e2 00 	sts	0x00E2, r24
	sei();
 26a:	78 94       	sei
}
 26c:	08 95       	ret

0000026e <usb_configured>:

// return 0 if the USB is not configured, or the configuration
// number selected by the HOST
uint8_t usb_configured(void)
{
	return usb_configuration;
 26e:	80 91 01 01 	lds	r24, 0x0101
}
 272:	08 95       	ret

00000274 <usb_rawhid_send>:

// send a packet, with timeout
int8_t usb_rawhid_send(const uint8_t *buffer, uint8_t timeout)
{
 274:	fc 01       	movw	r30, r24
	uint8_t intr_state;
	uint8_t Data_cnt;

	// if we're not online (enumerated and configured), error
	if (!usb_configuration) return -1;
 276:	80 91 01 01 	lds	r24, 0x0101
 27a:	88 23       	and	r24, r24
 27c:	39 f1       	breq	.+78     	; 0x2cc <usb_rawhid_send+0x58>
	intr_state = SREG;
 27e:	2f b7       	in	r18, 0x3f	; 63
	cli();
 280:	f8 94       	cli
	tx_timeout_count = timeout;
 282:	60 93 02 01 	sts	0x0102, r22
	UENUM = RAWHID_TX_ENDPOINT;
 286:	81 e0       	ldi	r24, 0x01	; 1
 288:	80 93 e9 00 	sts	0x00E9, r24
		SREG = intr_state;
		if (tx_timeout_count == 0) return 0;
		if (!usb_configuration) return -1;
		intr_state = SREG;
		cli();
		UENUM = RAWHID_TX_ENDPOINT;
 28c:	91 e0       	ldi	r25, 0x01	; 1
	cli();
	tx_timeout_count = timeout;
	UENUM = RAWHID_TX_ENDPOINT;
	// wait for the FIFO to be ready to accept data
	while (1) {
		if (UEINTX & (1<<RWAL)) break;
 28e:	80 91 e8 00 	lds	r24, 0x00E8
 292:	85 ff       	sbrs	r24, 5
 294:	02 c0       	rjmp	.+4      	; 0x29a <usb_rawhid_send+0x26>
 296:	91 e4       	ldi	r25, 0x41	; 65
 298:	11 c0       	rjmp	.+34     	; 0x2bc <usb_rawhid_send+0x48>
		SREG = intr_state;
 29a:	2f bf       	out	0x3f, r18	; 63
		if (tx_timeout_count == 0) return 0;
 29c:	80 91 02 01 	lds	r24, 0x0102
 2a0:	88 23       	and	r24, r24
 2a2:	a9 f0       	breq	.+42     	; 0x2ce <usb_rawhid_send+0x5a>
		if (!usb_configuration) return -1;
 2a4:	80 91 01 01 	lds	r24, 0x0101
 2a8:	88 23       	and	r24, r24
 2aa:	81 f0       	breq	.+32     	; 0x2cc <usb_rawhid_send+0x58>
		intr_state = SREG;
 2ac:	2f b7       	in	r18, 0x3f	; 63
		cli();
 2ae:	f8 94       	cli
		UENUM = RAWHID_TX_ENDPOINT;
 2b0:	90 93 e9 00 	sts	0x00E9, r25
 2b4:	ec cf       	rjmp	.-40     	; 0x28e <usb_rawhid_send+0x1a>
	}
	// write bytes from the FIFO
	Data_cnt = RAWHID_TX_SIZE + 1;	// size of buffer
	while (Data_cnt--) {UEDATX = *buffer++;}	// Transfer data from UEDATX to buffer..
 2b6:	81 91       	ld	r24, Z+
 2b8:	80 93 f1 00 	sts	0x00F1, r24
 2bc:	91 50       	subi	r25, 0x01	; 1
 2be:	d8 f7       	brcc	.-10     	; 0x2b6 <usb_rawhid_send+0x42>
	// transmit it now
	UEINTX = 0x3A;
 2c0:	8a e3       	ldi	r24, 0x3A	; 58
 2c2:	80 93 e8 00 	sts	0x00E8, r24
	SREG = intr_state;
 2c6:	2f bf       	out	0x3f, r18	; 63
 2c8:	80 e4       	ldi	r24, 0x40	; 64
 2ca:	08 95       	ret
	return RAWHID_TX_SIZE;
 2cc:	8f ef       	ldi	r24, 0xFF	; 255
}
 2ce:	08 95       	ret

000002d0 <__vector_10>:

// USB Device Interrupt - handle all device-level events
// the transmit buffer flushing is triggered by the start of frame
//
ISR(USB_GEN_vect)
{
 2d0:	1f 92       	push	r1
 2d2:	0f 92       	push	r0
 2d4:	0f b6       	in	r0, 0x3f	; 63
 2d6:	0f 92       	push	r0
 2d8:	11 24       	eor	r1, r1
 2da:	8f 93       	push	r24
 2dc:	9f 93       	push	r25
uint8_t intbits, t;
intbits = UDINT;
 2de:	80 91 e1 00 	lds	r24, 0x00E1
UDINT = 0;
 2e2:	10 92 e1 00 	sts	0x00E1, r1
if (intbits & (1<<EORSTI)) 
 2e6:	98 2f       	mov	r25, r24
 2e8:	93 ff       	sbrs	r25, 3
 2ea:	0f c0       	rjmp	.+30     	; 0x30a <__vector_10+0x3a>
	{
	UENUM = 0;
 2ec:	10 92 e9 00 	sts	0x00E9, r1
	UECONX = 1;
 2f0:	81 e0       	ldi	r24, 0x01	; 1
 2f2:	80 93 eb 00 	sts	0x00EB, r24
	UECFG0X = EP_TYPE_CONTROL;
 2f6:	10 92 ec 00 	sts	0x00EC, r1
	UECFG1X = EP_SIZE(ENDPOINT0_SIZE) | EP_SINGLE_BUFFER;
 2fa:	82 e3       	ldi	r24, 0x32	; 50
 2fc:	80 93 ed 00 	sts	0x00ED, r24
	UEIENX = (1<<RXSTPE);
 300:	88 e0       	ldi	r24, 0x08	; 8
 302:	80 93 f0 00 	sts	0x00F0, r24
	usb_configuration = 0;
 306:	10 92 01 01 	sts	0x0101, r1
    }
if ((intbits & (1<<SOFI)) && usb_configuration) 
 30a:	92 ff       	sbrs	r25, 2
 30c:	0b c0       	rjmp	.+22     	; 0x324 <__vector_10+0x54>
 30e:	80 91 01 01 	lds	r24, 0x0101
 312:	88 23       	and	r24, r24
 314:	39 f0       	breq	.+14     	; 0x324 <__vector_10+0x54>
	{
	t = tx_timeout_count;
 316:	80 91 02 01 	lds	r24, 0x0102
	if (t) tx_timeout_count = --t;
 31a:	88 23       	and	r24, r24
 31c:	19 f0       	breq	.+6      	; 0x324 <__vector_10+0x54>
 31e:	81 50       	subi	r24, 0x01	; 1
 320:	80 93 02 01 	sts	0x0102, r24
	}
}
 324:	9f 91       	pop	r25
 326:	8f 91       	pop	r24
 328:	0f 90       	pop	r0
 32a:	0f be       	out	0x3f, r0	; 63
 32c:	0f 90       	pop	r0
 32e:	1f 90       	pop	r1
 330:	18 95       	reti

00000332 <__vector_11>:
// USB Endpoint Interrupt - endpoint 0 is handled here.  The
// other endpoints are manipulated by the user-callable
// functions, and the start-of-frame interrupt.
//
ISR(USB_COM_vect)
{
 332:	1f 92       	push	r1
 334:	0f 92       	push	r0
 336:	0f b6       	in	r0, 0x3f	; 63
 338:	0f 92       	push	r0
 33a:	11 24       	eor	r1, r1
 33c:	0f 93       	push	r16
 33e:	1f 93       	push	r17
 340:	2f 93       	push	r18
 342:	3f 93       	push	r19
 344:	4f 93       	push	r20
 346:	5f 93       	push	r21
 348:	6f 93       	push	r22
 34a:	7f 93       	push	r23
 34c:	8f 93       	push	r24
 34e:	9f 93       	push	r25
 350:	af 93       	push	r26
 352:	bf 93       	push	r27
 354:	ef 93       	push	r30
 356:	ff 93       	push	r31
uint16_t wLength;
uint16_t desc_val;
const uint8_t *desc_addr;
uint8_t	desc_length;

UENUM = 0;
 358:	10 92 e9 00 	sts	0x00E9, r1
intbits = UEINTX;
 35c:	80 91 e8 00 	lds	r24, 0x00E8
if (intbits & (1<<RXSTPI)) 
 360:	83 ff       	sbrs	r24, 3
 362:	16 c1       	rjmp	.+556    	; 0x590 <__vector_11+0x25e>
	{
    bmRequestType = UEDATX;
 364:	40 91 f1 00 	lds	r20, 0x00F1
    bRequest = UEDATX;
 368:	30 91 f1 00 	lds	r19, 0x00F1
    wValue = UEDATX;
 36c:	80 91 f1 00 	lds	r24, 0x00F1
 370:	a8 2f       	mov	r26, r24
 372:	b0 e0       	ldi	r27, 0x00	; 0
    wValue |= (UEDATX << 8);
 374:	20 91 f1 00 	lds	r18, 0x00F1
 378:	92 2f       	mov	r25, r18
 37a:	80 e0       	ldi	r24, 0x00	; 0
 37c:	a8 2b       	or	r26, r24
 37e:	b9 2b       	or	r27, r25
    wIndex = UEDATX;
 380:	80 91 f1 00 	lds	r24, 0x00F1
 384:	68 2f       	mov	r22, r24
 386:	70 e0       	ldi	r23, 0x00	; 0
    wIndex |= (UEDATX << 8);
 388:	20 91 f1 00 	lds	r18, 0x00F1
 38c:	92 2f       	mov	r25, r18
 38e:	80 e0       	ldi	r24, 0x00	; 0
 390:	68 2b       	or	r22, r24
 392:	79 2b       	or	r23, r25
    wLength = UEDATX;
 394:	10 91 f1 00 	lds	r17, 0x00F1
    wLength |= (UEDATX << 8);
 398:	00 91 f1 00 	lds	r16, 0x00F1
    UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
 39c:	82 ef       	ldi	r24, 0xF2	; 242
 39e:	80 93 e8 00 	sts	0x00E8, r24

// ******** GET Descriptor *******************
    if (bRequest == GET_DESCRIPTOR) 
 3a2:	36 30       	cpi	r19, 0x06	; 6
 3a4:	09 f0       	breq	.+2      	; 0x3a8 <__vector_11+0x76>
 3a6:	5a c0       	rjmp	.+180    	; 0x45c <__vector_11+0x12a>
 3a8:	23 eb       	ldi	r18, 0xB3	; 179
 3aa:	30 e0       	ldi	r19, 0x00	; 0
 3ac:	a9 01       	movw	r20, r18
 3ae:	45 50       	subi	r20, 0x05	; 5
 3b0:	50 40       	sbci	r21, 0x00	; 0
		for (i=0; ; i++) 
			{
			if (i >= NUM_DESC_LIST) 
				{
				UECONX = (1<<STALLRQ)|(1<<EPEN);  //stall
				return;
 3b2:	f9 01       	movw	r30, r18
 3b4:	37 97       	sbiw	r30, 0x07	; 7
				}
			desc_val = pgm_read_word(list);
 3b6:	85 91       	lpm	r24, Z+
 3b8:	94 91       	lpm	r25, Z+
			if (desc_val != wValue) 
 3ba:	8a 17       	cp	r24, r26
 3bc:	9b 07       	cpc	r25, r27
 3be:	01 f5       	brne	.+64     	; 0x400 <__vector_11+0xce>
				{
				list += sizeof(struct descriptor_list_struct);
				continue;
				}
			list += 2;
			desc_val = pgm_read_word(list);
 3c0:	fa 01       	movw	r30, r20
 3c2:	85 91       	lpm	r24, Z+
 3c4:	94 91       	lpm	r25, Z+
			if (desc_val != wIndex) 
 3c6:	86 17       	cp	r24, r22
 3c8:	97 07       	cpc	r25, r23
 3ca:	d1 f4       	brne	.+52     	; 0x400 <__vector_11+0xce>
				{
				list += sizeof(struct descriptor_list_struct)-2;
				continue;
				}
			list += 2;
 3cc:	9a 01       	movw	r18, r20
 3ce:	2e 5f       	subi	r18, 0xFE	; 254
 3d0:	3f 4f       	sbci	r19, 0xFF	; 255
			desc_addr = (const uint8_t *)pgm_read_word(list);
 3d2:	f9 01       	movw	r30, r18
 3d4:	65 91       	lpm	r22, Z+
 3d6:	74 91       	lpm	r23, Z+
			list += 2;
			desc_length = pgm_read_byte(list);
 3d8:	2e 5f       	subi	r18, 0xFE	; 254
 3da:	3f 4f       	sbci	r19, 0xFF	; 255
 3dc:	f9 01       	movw	r30, r18
 3de:	44 91       	lpm	r20, Z+
    bRequest = UEDATX;
    wValue = UEDATX;
    wValue |= (UEDATX << 8);
    wIndex = UEDATX;
    wIndex |= (UEDATX << 8);
    wLength = UEDATX;
 3e0:	21 2f       	mov	r18, r17
 3e2:	30 e0       	ldi	r19, 0x00	; 0
			desc_addr = (const uint8_t *)pgm_read_word(list);
			list += 2;
			desc_length = pgm_read_byte(list);
			break;
			}
		len = (wLength < 256) ? wLength : 255;
 3e4:	90 2f       	mov	r25, r16
 3e6:	80 e0       	ldi	r24, 0x00	; 0
 3e8:	28 2b       	or	r18, r24
 3ea:	39 2b       	or	r19, r25
 3ec:	2f 3f       	cpi	r18, 0xFF	; 255
 3ee:	31 05       	cpc	r19, r1
 3f0:	19 f0       	breq	.+6      	; 0x3f8 <__vector_11+0xc6>
 3f2:	10 f0       	brcs	.+4      	; 0x3f8 <__vector_11+0xc6>
 3f4:	2f ef       	ldi	r18, 0xFF	; 255
 3f6:	30 e0       	ldi	r19, 0x00	; 0
 3f8:	24 17       	cp	r18, r20
 3fa:	58 f4       	brcc	.+22     	; 0x412 <__vector_11+0xe0>
 3fc:	42 2f       	mov	r20, r18
 3fe:	09 c0       	rjmp	.+18     	; 0x412 <__vector_11+0xe0>
 400:	29 5f       	subi	r18, 0xF9	; 249
 402:	3f 4f       	sbci	r19, 0xFF	; 255
 404:	49 5f       	subi	r20, 0xF9	; 249
 406:	5f 4f       	sbci	r21, 0xFF	; 255
    if (bRequest == GET_DESCRIPTOR) 
		{
		list = (const uint8_t *)descriptor_list;
		for (i=0; ; i++) 
			{
			if (i >= NUM_DESC_LIST) 
 408:	f0 e0       	ldi	r31, 0x00	; 0
 40a:	24 3e       	cpi	r18, 0xE4	; 228
 40c:	3f 07       	cpc	r19, r31
 40e:	89 f6       	brne	.-94     	; 0x3b2 <__vector_11+0x80>
 410:	bf c0       	rjmp	.+382    	; 0x590 <__vector_11+0x25e>



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
 412:	5e ef       	ldi	r21, 0xFE	; 254
		do 
			{
			// wait for host ready for IN packet
			do 
				{
				i = UEINTX;
 414:	80 91 e8 00 	lds	r24, 0x00E8
				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
 418:	28 2f       	mov	r18, r24
 41a:	30 e0       	ldi	r19, 0x00	; 0
 41c:	c9 01       	movw	r24, r18
 41e:	85 70       	andi	r24, 0x05	; 5
 420:	90 70       	andi	r25, 0x00	; 0
 422:	89 2b       	or	r24, r25
 424:	b9 f3       	breq	.-18     	; 0x414 <__vector_11+0xe2>
			if (i & (1<<RXOUTI)) return;	// abort
 426:	22 fd       	sbrc	r18, 2
 428:	b6 c0       	rjmp	.+364    	; 0x596 <__vector_11+0x264>
			// send IN packet
			n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
 42a:	34 2f       	mov	r19, r20
 42c:	41 34       	cpi	r20, 0x41	; 65
 42e:	08 f0       	brcs	.+2      	; 0x432 <__vector_11+0x100>
 430:	30 e4       	ldi	r19, 0x40	; 64
 432:	23 2f       	mov	r18, r19
 434:	cb 01       	movw	r24, r22
 436:	06 c0       	rjmp	.+12     	; 0x444 <__vector_11+0x112>
			for (i = n; i; i--) 
 438:	fc 01       	movw	r30, r24
				{
				UEDATX = pgm_read_byte(desc_addr++);
 43a:	01 96       	adiw	r24, 0x01	; 1
 43c:	e4 91       	lpm	r30, Z+
 43e:	e0 93 f1 00 	sts	0x00F1, r30
				i = UEINTX;
				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
			if (i & (1<<RXOUTI)) return;	// abort
			// send IN packet
			n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
			for (i = n; i; i--) 
 442:	21 50       	subi	r18, 0x01	; 1
 444:	22 23       	and	r18, r18
 446:	c1 f7       	brne	.-16     	; 0x438 <__vector_11+0x106>
 448:	63 0f       	add	r22, r19
 44a:	71 1d       	adc	r23, r1
				{
				UEDATX = pgm_read_byte(desc_addr++);
				}
			len -= n;
 44c:	43 1b       	sub	r20, r19



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
 44e:	50 93 e8 00 	sts	0x00E8, r21
				{
				UEDATX = pgm_read_byte(desc_addr++);
				}
			len -= n;
			usb_send_in();
			} while (len || n == ENDPOINT0_SIZE);
 452:	44 23       	and	r20, r20
 454:	f9 f6       	brne	.-66     	; 0x414 <__vector_11+0xe2>
 456:	30 34       	cpi	r19, 0x40	; 64
 458:	e9 f2       	breq	.-70     	; 0x414 <__vector_11+0xe2>
 45a:	9d c0       	rjmp	.+314    	; 0x596 <__vector_11+0x264>
		return;
        }


	// ******** Set ADDRESS **********************		
	if (bRequest == SET_ADDRESS) 
 45c:	35 30       	cpi	r19, 0x05	; 5
 45e:	61 f4       	brne	.+24     	; 0x478 <__vector_11+0x146>



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
 460:	8e ef       	ldi	r24, 0xFE	; 254
 462:	80 93 e8 00 	sts	0x00E8, r24
}



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
 466:	80 91 e8 00 	lds	r24, 0x00E8
 46a:	80 ff       	sbrs	r24, 0
 46c:	fc cf       	rjmp	.-8      	; 0x466 <__vector_11+0x134>
	// ******** Set ADDRESS **********************		
	if (bRequest == SET_ADDRESS) 
		{
		usb_send_in();
		usb_wait_in_ready();
		UDADDR = wValue | (1<<ADDEN);
 46e:	8a 2f       	mov	r24, r26
 470:	80 68       	ori	r24, 0x80	; 128
 472:	80 93 e3 00 	sts	0x00E3, r24
 476:	8f c0       	rjmp	.+286    	; 0x596 <__vector_11+0x264>
		return;
		}

	// ******** Set Configuration **********************		
	if (bRequest == SET_CONFIGURATION && bmRequestType == 0) 
 478:	39 30       	cpi	r19, 0x09	; 9
 47a:	51 f5       	brne	.+84     	; 0x4d0 <__vector_11+0x19e>
 47c:	44 23       	and	r20, r20
 47e:	09 f0       	breq	.+2      	; 0x482 <__vector_11+0x150>
 480:	50 c0       	rjmp	.+160    	; 0x522 <__vector_11+0x1f0>
		{
		usb_configuration = wValue;
 482:	a0 93 01 01 	sts	0x0101, r26



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
 486:	8e ef       	ldi	r24, 0xFE	; 254
 488:	80 93 e8 00 	sts	0x00E8, r24
 48c:	8d ed       	ldi	r24, 0xDD	; 221
 48e:	90 e0       	ldi	r25, 0x00	; 0
 490:	21 e0       	ldi	r18, 0x01	; 1
		usb_configuration = wValue;
		usb_send_in();
		cfg = endpoint_config_table;
		for (i=1; i<5; i++) 
			{
			UENUM = i;
 492:	20 93 e9 00 	sts	0x00E9, r18
			en = pgm_read_byte(cfg++);
 496:	fc 01       	movw	r30, r24
 498:	01 96       	adiw	r24, 0x01	; 1
 49a:	e4 91       	lpm	r30, Z+
			UECONX = en;
 49c:	e0 93 eb 00 	sts	0x00EB, r30
			if (en) 
 4a0:	ee 23       	and	r30, r30
 4a2:	69 f0       	breq	.+26     	; 0x4be <__vector_11+0x18c>
				{
				UECFG0X = pgm_read_byte(cfg++);
 4a4:	ac 01       	movw	r20, r24
 4a6:	4f 5f       	subi	r20, 0xFF	; 255
 4a8:	5f 4f       	sbci	r21, 0xFF	; 255
 4aa:	fc 01       	movw	r30, r24
 4ac:	84 91       	lpm	r24, Z+
 4ae:	80 93 ec 00 	sts	0x00EC, r24
				UECFG1X = pgm_read_byte(cfg++);
 4b2:	ca 01       	movw	r24, r20
 4b4:	01 96       	adiw	r24, 0x01	; 1
 4b6:	fa 01       	movw	r30, r20
 4b8:	34 91       	lpm	r19, Z+
 4ba:	30 93 ed 00 	sts	0x00ED, r19
	if (bRequest == SET_CONFIGURATION && bmRequestType == 0) 
		{
		usb_configuration = wValue;
		usb_send_in();
		cfg = endpoint_config_table;
		for (i=1; i<5; i++) 
 4be:	2f 5f       	subi	r18, 0xFF	; 255
 4c0:	25 30       	cpi	r18, 0x05	; 5
 4c2:	39 f7       	brne	.-50     	; 0x492 <__vector_11+0x160>
				{
				UECFG0X = pgm_read_byte(cfg++);
				UECFG1X = pgm_read_byte(cfg++);
				}
			}
		UERST = 0x1E;
 4c4:	8e e1       	ldi	r24, 0x1E	; 30
 4c6:	80 93 ea 00 	sts	0x00EA, r24
		UERST = 0;
 4ca:	10 92 ea 00 	sts	0x00EA, r1
 4ce:	63 c0       	rjmp	.+198    	; 0x596 <__vector_11+0x264>
		return;
		}
	
	// ******** Get Configuratioin **********************		
	if (bRequest == GET_CONFIGURATION && bmRequestType == 0x80) 
 4d0:	38 30       	cpi	r19, 0x08	; 8
 4d2:	59 f4       	brne	.+22     	; 0x4ea <__vector_11+0x1b8>
 4d4:	40 38       	cpi	r20, 0x80	; 128
 4d6:	29 f5       	brne	.+74     	; 0x522 <__vector_11+0x1f0>
}



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
 4d8:	80 91 e8 00 	lds	r24, 0x00E8
 4dc:	80 ff       	sbrs	r24, 0
 4de:	fc cf       	rjmp	.-8      	; 0x4d8 <__vector_11+0x1a6>
	
	// ******** Get Configuratioin **********************		
	if (bRequest == GET_CONFIGURATION && bmRequestType == 0x80) 
		{
		usb_wait_in_ready();
		UEDATX = usb_configuration;
 4e0:	80 91 01 01 	lds	r24, 0x0101
 4e4:	80 93 f1 00 	sts	0x00F1, r24
 4e8:	4f c0       	rjmp	.+158    	; 0x588 <__vector_11+0x256>
		usb_send_in();
		return;
		}

	// ******** GET Status **********************		
	if (bRequest == GET_STATUS) 
 4ea:	33 23       	and	r19, r19
 4ec:	d1 f4       	brne	.+52     	; 0x522 <__vector_11+0x1f0>
}



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
 4ee:	80 91 e8 00 	lds	r24, 0x00E8
 4f2:	80 ff       	sbrs	r24, 0
 4f4:	fc cf       	rjmp	.-8      	; 0x4ee <__vector_11+0x1bc>
	// ******** GET Status **********************		
	if (bRequest == GET_STATUS) 
		{
		usb_wait_in_ready();
		i = 0;
		if (bmRequestType == 0x82) 
 4f6:	42 38       	cpi	r20, 0x82	; 130
 4f8:	11 f0       	breq	.+4      	; 0x4fe <__vector_11+0x1cc>
 4fa:	80 e0       	ldi	r24, 0x00	; 0
 4fc:	0d c0       	rjmp	.+26     	; 0x518 <__vector_11+0x1e6>
			{
			UENUM = wIndex;
 4fe:	60 93 e9 00 	sts	0x00E9, r22
			if (UECONX & (1<<STALLRQ)) i = 1;
 502:	80 91 eb 00 	lds	r24, 0x00EB
 506:	90 e0       	ldi	r25, 0x00	; 0
 508:	25 e0       	ldi	r18, 0x05	; 5
 50a:	96 95       	lsr	r25
 50c:	87 95       	ror	r24
 50e:	2a 95       	dec	r18
 510:	e1 f7       	brne	.-8      	; 0x50a <__vector_11+0x1d8>
 512:	81 70       	andi	r24, 0x01	; 1
			UENUM = 0;
 514:	10 92 e9 00 	sts	0x00E9, r1
			}
		UEDATX = i;
 518:	80 93 f1 00 	sts	0x00F1, r24
		UEDATX = 0;
 51c:	10 92 f1 00 	sts	0x00F1, r1
 520:	33 c0       	rjmp	.+102    	; 0x588 <__vector_11+0x256>
			}
		}
*/
	// ******** RAW Interface **********************		

	if (wIndex == RAWHID_INTERFACE) 
 522:	67 2b       	or	r22, r23
 524:	a9 f5       	brne	.+106    	; 0x590 <__vector_11+0x25e>
		{
		// ****** GET REPORT ***********************
	
		if (bmRequestType == 0xA1 && bRequest == HID_GET_REPORT) 
 526:	41 3a       	cpi	r20, 0xA1	; 161
 528:	a1 f4       	brne	.+40     	; 0x552 <__vector_11+0x220>
 52a:	31 30       	cpi	r19, 0x01	; 1
 52c:	89 f5       	brne	.+98     	; 0x590 <__vector_11+0x25e>
			{
			// wait for host ready for IN packet
			do 
				{
				i = UEINTX;
 52e:	80 91 e8 00 	lds	r24, 0x00E8
				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
 532:	28 2f       	mov	r18, r24
 534:	30 e0       	ldi	r19, 0x00	; 0
 536:	c9 01       	movw	r24, r18
 538:	85 70       	andi	r24, 0x05	; 5
 53a:	90 70       	andi	r25, 0x00	; 0
 53c:	89 2b       	or	r24, r25
 53e:	b9 f3       	breq	.-18     	; 0x52e <__vector_11+0x1fc>
			if (i & (1<<RXOUTI)) return;	// abort
 540:	22 fd       	sbrc	r18, 2
 542:	29 c0       	rjmp	.+82     	; 0x596 <__vector_11+0x264>
 544:	81 e2       	ldi	r24, 0x21	; 33
			// send IN packet
			for (len=0;len < (RAWHID_TX_SIZE ); len++) UEDATX=len+33; // fill buffer for send .. with 1,2,3,4,5,6,7,8..40 (in hex)
 546:	80 93 f1 00 	sts	0x00F1, r24
 54a:	8f 5f       	subi	r24, 0xFF	; 255
 54c:	81 36       	cpi	r24, 0x61	; 97
 54e:	d9 f7       	brne	.-10     	; 0x546 <__vector_11+0x214>
 550:	1b c0       	rjmp	.+54     	; 0x588 <__vector_11+0x256>
			return;
			}
	
		// ****** GET REPORT ***********************

		if (bmRequestType == 0x21 && bRequest == HID_SET_REPORT) 
 552:	41 32       	cpi	r20, 0x21	; 33
 554:	e9 f4       	brne	.+58     	; 0x590 <__vector_11+0x25e>
 556:	39 30       	cpi	r19, 0x09	; 9
 558:	d9 f4       	brne	.+54     	; 0x590 <__vector_11+0x25e>


// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
static inline void usb_wait_receive_out(void){while (!(UEINTX & (1<<RXOUTI))) ;}
 55a:	80 91 e8 00 	lds	r24, 0x00E8
 55e:	82 ff       	sbrs	r24, 2
 560:	fc cf       	rjmp	.-8      	; 0x55a <__vector_11+0x228>
 562:	e3 e0       	ldi	r30, 0x03	; 3
 564:	f1 e0       	ldi	r31, 0x01	; 1
		// ****** GET REPORT ***********************

		if (bmRequestType == 0x21 && bRequest == HID_SET_REPORT) 
			{
			usb_wait_receive_out();
			for (len=0;len < (RAWHID_RX_SIZE );len++) buffer[len] = UEDATX; // read data from PC to buffer in size 64 bytes..
 566:	80 91 f1 00 	lds	r24, 0x00F1
 56a:	81 93       	st	Z+, r24
 56c:	81 e0       	ldi	r24, 0x01	; 1
 56e:	e3 34       	cpi	r30, 0x43	; 67
 570:	f8 07       	cpc	r31, r24
 572:	c9 f7       	brne	.-14     	; 0x566 <__vector_11+0x234>
			SU = 1;
 574:	81 e0       	ldi	r24, 0x01	; 1
 576:	80 93 43 01 	sts	0x0143, r24

// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
static inline void usb_wait_receive_out(void){while (!(UEINTX & (1<<RXOUTI))) ;}
static inline void usb_ack_out(void){	UEINTX = ~(1<<RXOUTI);}
 57a:	8b ef       	ldi	r24, 0xFB	; 251
 57c:	80 93 e8 00 	sts	0x00E8, r24
}



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
 580:	80 91 e8 00 	lds	r24, 0x00E8
 584:	80 ff       	sbrs	r24, 0
 586:	fc cf       	rjmp	.-8      	; 0x580 <__vector_11+0x24e>
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
 588:	8e ef       	ldi	r24, 0xFE	; 254
 58a:	80 93 e8 00 	sts	0x00E8, r24
 58e:	03 c0       	rjmp	.+6      	; 0x596 <__vector_11+0x264>
			}

		}

	}
UECONX = (1<<STALLRQ) | (1<<EPEN);	// stall
 590:	81 e2       	ldi	r24, 0x21	; 33
 592:	80 93 eb 00 	sts	0x00EB, r24
}
 596:	ff 91       	pop	r31
 598:	ef 91       	pop	r30
 59a:	bf 91       	pop	r27
 59c:	af 91       	pop	r26
 59e:	9f 91       	pop	r25
 5a0:	8f 91       	pop	r24
 5a2:	7f 91       	pop	r23
 5a4:	6f 91       	pop	r22
 5a6:	5f 91       	pop	r21
 5a8:	4f 91       	pop	r20
 5aa:	3f 91       	pop	r19
 5ac:	2f 91       	pop	r18
 5ae:	1f 91       	pop	r17
 5b0:	0f 91       	pop	r16
 5b2:	0f 90       	pop	r0
 5b4:	0f be       	out	0x3f, r0	; 63
 5b6:	0f 90       	pop	r0
 5b8:	1f 90       	pop	r1
 5ba:	18 95       	reti

000005bc <_exit>:
 5bc:	f8 94       	cli

000005be <__stop_program>:
 5be:	ff cf       	rjmp	.-2      	; 0x5be <__stop_program>
