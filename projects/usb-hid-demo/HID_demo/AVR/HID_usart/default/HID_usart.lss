
HID_usart.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000061a  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000044  00800100  00800100  0000068e  2**0
                  ALLOC
  2 .debug_aranges 00000040  00000000  00000000  0000068e  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 000000b3  00000000  00000000  000006ce  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000007c2  00000000  00000000  00000781  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 000002d9  00000000  00000000  00000f43  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   000006b9  00000000  00000000  0000121c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000080  00000000  00000000  000018d8  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    000002f0  00000000  00000000  00001958  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000054d  00000000  00000000  00001c48  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000018  00000000  00000000  00002195  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__ctors_end>
   4:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
   8:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
   c:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  10:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  14:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  18:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  1c:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  20:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  24:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  28:	0c 94 95 01 	jmp	0x32a	; 0x32a <__vector_10>
  2c:	0c 94 c6 01 	jmp	0x38c	; 0x38c <__vector_11>
  30:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  34:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  38:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  3c:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  40:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  44:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  48:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  4c:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  50:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  54:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  58:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  5c:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  60:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  64:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  68:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  6c:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  70:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  74:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  78:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  7c:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  80:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  84:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  88:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  8c:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  90:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  94:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  98:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  9c:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  a0:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  a4:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>
  a8:	0c 94 c7 00 	jmp	0x18e	; 0x18e <__bad_interrupt>

000000ac <descriptor_list>:
  ac:	00 01 00 00 e5 00 12 00 02 00 00 f7 00 29 00 22     .............)."
  bc:	00 00 20 01 1c 00 21 00 00 09 01 09 00 03 00 00     .. ...!.........
  cc:	3c 01 04 01 03 09 04 40 01 12 02 03 09 04 54 01     <......@......T.
  dc:	14                                                  .

000000dd <endpoint_config_table>:
  dd:	01 c1 32 01 c0 32 00 00                             ..2..2..

000000e5 <device_descriptor>:
  e5:	12 01 00 02 00 00 00 40 c0 16 80 04 00 01 01 02     .......@........
  f5:	00 01                                               ..

000000f7 <config1_descriptor>:
  f7:	09 02 29 00 01 01 00 c0 32 09 04 00 00 02 03 00     ..).....2.......
 107:	00 00 09 21 11 01 00 01 22 1c 00 07 05 81 03 40     ...!...."......@
 117:	00 02 07 05 02 03 40 00 08                          ......@..

00000120 <rawhid_hid_report_desc>:
 120:	06 ab ff 0a 00 02 a1 01 15 00 26 ff 00 75 08 95     ..........&..u..
 130:	40 09 00 91 02 09 01 95 40 81 02 c0                 @.......@...

0000013c <string0>:
 13c:	04 03 09 04                                         ....

00000140 <string1>:
 140:	12 03 50 00 4a 00 52 00 43 00 2e 00 43 00 4f 00     ..P.J.R.C...C.O.
 150:	4d 00 00 00                                         M...

00000154 <string2>:
 154:	14 03 48 00 49 00 44 00 20 00 55 00 53 00 41 00     ..H.I.D. .U.S.A.
 164:	52 00 54 00 00 00                                   R.T...

0000016a <__ctors_end>:
 16a:	11 24       	eor	r1, r1
 16c:	1f be       	out	0x3f, r1	; 63
 16e:	cf ef       	ldi	r28, 0xFF	; 255
 170:	da e0       	ldi	r29, 0x0A	; 10
 172:	de bf       	out	0x3e, r29	; 62
 174:	cd bf       	out	0x3d, r28	; 61

00000176 <__do_clear_bss>:
 176:	11 e0       	ldi	r17, 0x01	; 1
 178:	a0 e0       	ldi	r26, 0x00	; 0
 17a:	b1 e0       	ldi	r27, 0x01	; 1
 17c:	01 c0       	rjmp	.+2      	; 0x180 <.do_clear_bss_start>

0000017e <.do_clear_bss_loop>:
 17e:	1d 92       	st	X+, r1

00000180 <.do_clear_bss_start>:
 180:	a4 34       	cpi	r26, 0x44	; 68
 182:	b1 07       	cpc	r27, r17
 184:	e1 f7       	brne	.-8      	; 0x17e <.do_clear_bss_loop>
 186:	0e 94 c9 00 	call	0x192	; 0x192 <main>
 18a:	0c 94 0b 03 	jmp	0x616	; 0x616 <_exit>

0000018e <__bad_interrupt>:
 18e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000192 <main>:

volatile uint8_t do_output=0;


int main(void)
{
 192:	ff 92       	push	r15
 194:	0f 93       	push	r16
 196:	1f 93       	push	r17
 198:	df 93       	push	r29
 19a:	cf 93       	push	r28
 19c:	cd b7       	in	r28, 0x3d	; 61
 19e:	de b7       	in	r29, 0x3e	; 62
 1a0:	c0 54       	subi	r28, 0x40	; 64
 1a2:	d0 40       	sbci	r29, 0x00	; 0
 1a4:	0f b6       	in	r0, 0x3f	; 63
 1a6:	f8 94       	cli
 1a8:	de bf       	out	0x3e, r29	; 62
 1aa:	0f be       	out	0x3f, r0	; 63
 1ac:	cd bf       	out	0x3d, r28	; 61
uint8_t	Rxbuff[RAWHID_TX_SIZE];


	// UART setting for serial port debug if received data are same

	UCSR1A = 0;                         // importantly U2X1 = 0
 1ae:	10 92 c8 00 	sts	0x00C8, r1
	UCSR1B = (1 << RXEN1) | (1 << TXEN1); // enable RX,TX , no interupt..
 1b2:	88 e1       	ldi	r24, 0x18	; 24
 1b4:	80 93 c9 00 	sts	0x00C9, r24
	UCSR1C = _BV(UCSZ11) | _BV(UCSZ10); // no parity, 8 data bits, 1 stop bit
 1b8:	86 e0       	ldi	r24, 0x06	; 6
 1ba:	80 93 ca 00 	sts	0x00CA, r24
	UBRR1  = 51;                       // 9600 baud @ 8MHz XTAL with U2X1 = 0    
 1be:	83 e3       	ldi	r24, 0x33	; 51
 1c0:	90 e0       	ldi	r25, 0x00	; 0
 1c2:	90 93 cd 00 	sts	0x00CD, r25
 1c6:	80 93 cc 00 	sts	0x00CC, r24

	// status setting
	SU = 0;
 1ca:	10 92 43 01 	sts	0x0143, r1
	rxcount = 0;
	memset(&Rxbuff,0,sizeof(Rxbuff));
 1ce:	fe 01       	movw	r30, r28
 1d0:	31 96       	adiw	r30, 0x01	; 1
 1d2:	80 e4       	ldi	r24, 0x40	; 64
 1d4:	df 01       	movw	r26, r30
 1d6:	1d 92       	st	X+, r1
 1d8:	8a 95       	dec	r24
 1da:	e9 f7       	brne	.-6      	; 0x1d6 <main+0x44>

	// timer 0 for timeout receive data from usart
    TCCR0A = 0x00;
 1dc:	14 bc       	out	0x24, r1	; 36
    TCCR0B = 0x05;	// prescaler 1024
 1de:	85 e0       	ldi	r24, 0x05	; 5
 1e0:	85 bd       	out	0x25, r24	; 37
	 

	// set for 8 MHz clock
	CPU_PRESCALE(0);
 1e2:	80 e8       	ldi	r24, 0x80	; 128
 1e4:	80 93 61 00 	sts	0x0061, r24
 1e8:	10 92 61 00 	sts	0x0061, r1
	// Initialize the USB, and then wait for the host to set configuration.
	// If the Teensy is powered without a PC connected to the USB port,
	// this will wait forever.
	usb_init();
 1ec:	0e 94 4d 01 	call	0x29a	; 0x29a <usb_init>
	while (!usb_configured()) /* wait */ ;
 1f0:	0e 94 64 01 	call	0x2c8	; 0x2c8 <usb_configured>
 1f4:	88 23       	and	r24, r24
 1f6:	e1 f3       	breq	.-8      	; 0x1f0 <main+0x5e>
 1f8:	80 e1       	ldi	r24, 0x10	; 16
 1fa:	97 e2       	ldi	r25, 0x27	; 39
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 1fc:	28 ec       	ldi	r18, 0xC8	; 200
 1fe:	30 e0       	ldi	r19, 0x00	; 0
 200:	f9 01       	movw	r30, r18
 202:	31 97       	sbiw	r30, 0x01	; 1
 204:	f1 f7       	brne	.-4      	; 0x202 <main+0x70>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 206:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 208:	d9 f7       	brne	.-10     	; 0x200 <main+0x6e>

	// Wait an extra second for the PC's operating system to load drivers
	// and do whatever it does to actually be ready for input
	_delay_ms(1000);

	TCNT0 =0;			// clear counter.
 20a:	16 bc       	out	0x26, r1	; 38
	sbi(TIFR0,TOV0);	// clear bit if set..
 20c:	a8 9a       	sbi	0x15, 0	; 21
 20e:	90 e0       	ldi	r25, 0x00	; 0
			{
			TCNT0 =0;			// clear counter.
			sbi(TIFR0,TOV0);	// clear bit if set..
			if (rxcount)
				{
				usb_rawhid_send(Rxbuff,8); // send buffer 8 - timeout..
 210:	8e 01       	movw	r16, r28
 212:	0f 5f       	subi	r16, 0xFF	; 255
 214:	1f 4f       	sbci	r17, 0xFF	; 255
				rxcount = 0;				// clear counter
				memset(&Rxbuff,0,sizeof(Rxbuff));	// clear buffer
 216:	80 e4       	ldi	r24, 0x40	; 64
 218:	f8 2e       	mov	r15, r24

	while (1) 
		{

		// timeout every 32ms
		if (bit_is_set(TIFR0,TOV0))
 21a:	a8 9b       	sbis	0x15, 0	; 21
 21c:	0e c0       	rjmp	.+28     	; 0x23a <main+0xa8>
			{
			TCNT0 =0;			// clear counter.
 21e:	16 bc       	out	0x26, r1	; 38
			sbi(TIFR0,TOV0);	// clear bit if set..
 220:	a8 9a       	sbi	0x15, 0	; 21
			if (rxcount)
 222:	99 23       	and	r25, r25
 224:	51 f0       	breq	.+20     	; 0x23a <main+0xa8>
				{
				usb_rawhid_send(Rxbuff,8); // send buffer 8 - timeout..
 226:	c8 01       	movw	r24, r16
 228:	68 e0       	ldi	r22, 0x08	; 8
 22a:	0e 94 67 01 	call	0x2ce	; 0x2ce <usb_rawhid_send>
				rxcount = 0;				// clear counter
				memset(&Rxbuff,0,sizeof(Rxbuff));	// clear buffer
 22e:	f8 01       	movw	r30, r16
 230:	8f 2d       	mov	r24, r15
 232:	11 92       	st	Z+, r1
 234:	8a 95       	dec	r24
 236:	e9 f7       	brne	.-6      	; 0x232 <main+0xa0>
 238:	90 e0       	ldi	r25, 0x00	; 0
				}
			}
		
		// check if are some data
		if (UCSR1A & (1<<RXC1))
 23a:	80 91 c8 00 	lds	r24, 0x00C8
 23e:	87 ff       	sbrs	r24, 7
 240:	15 c0       	rjmp	.+42     	; 0x26c <main+0xda>
			{
			TCNT0 =0;			// clear counter.
 242:	16 bc       	out	0x26, r1	; 38
			sbi(TIFR0,TOV0);	// clear bit if set..
 244:	a8 9a       	sbi	0x15, 0	; 21
			Rxbuff[rxcount++] = UDR1;	// store data to buffer
 246:	80 91 ce 00 	lds	r24, 0x00CE
 24a:	f8 01       	movw	r30, r16
 24c:	e9 0f       	add	r30, r25
 24e:	f1 1d       	adc	r31, r1
 250:	80 83       	st	Z, r24
 252:	9f 5f       	subi	r25, 0xFF	; 255
			if (rxcount>63)				// if buffer is full then send to USB
 254:	90 34       	cpi	r25, 0x40	; 64
 256:	50 f0       	brcs	.+20     	; 0x26c <main+0xda>
				{
				usb_rawhid_send(Rxbuff,8); // send buffer 8 - timeout..
 258:	c8 01       	movw	r24, r16
 25a:	68 e0       	ldi	r22, 0x08	; 8
 25c:	0e 94 67 01 	call	0x2ce	; 0x2ce <usb_rawhid_send>
				rxcount = 0;				// clear counter
				memset(&Rxbuff,0,sizeof(Rxbuff));	// clear buffer
 260:	d8 01       	movw	r26, r16
 262:	ef 2d       	mov	r30, r15
 264:	1d 92       	st	X+, r1
 266:	ea 95       	dec	r30
 268:	e9 f7       	brne	.-6      	; 0x264 <main+0xd2>
 26a:	90 e0       	ldi	r25, 0x00	; 0
				}
			}	

		// data are received send to usart..
		if (SU)
 26c:	80 91 43 01 	lds	r24, 0x0143
 270:	88 23       	and	r24, r24
 272:	99 f2       	breq	.-90     	; 0x21a <main+0x88>
			{
			SU = 0;
 274:	10 92 43 01 	sts	0x0143, r1
 278:	e3 e0       	ldi	r30, 0x03	; 3
 27a:	f1 e0       	ldi	r31, 0x01	; 1
			 for (temp=0;temp < (RAWHID_TX_SIZE + 1); temp++)
				{
				while(!(UCSR1A & (1 << UDRE1)));   //wait until tx register is empty
 27c:	80 91 c8 00 	lds	r24, 0x00C8
 280:	85 ff       	sbrs	r24, 5
 282:	fc cf       	rjmp	.-8      	; 0x27c <main+0xea>
				if (buffer[temp]) outb(UDR1,buffer[temp]);
 284:	80 81       	ld	r24, Z
 286:	88 23       	and	r24, r24
 288:	11 f0       	breq	.+4      	; 0x28e <main+0xfc>
 28a:	80 93 ce 00 	sts	0x00CE, r24
 28e:	31 96       	adiw	r30, 0x01	; 1

		// data are received send to usart..
		if (SU)
			{
			SU = 0;
			 for (temp=0;temp < (RAWHID_TX_SIZE + 1); temp++)
 290:	81 e0       	ldi	r24, 0x01	; 1
 292:	e4 34       	cpi	r30, 0x44	; 68
 294:	f8 07       	cpc	r31, r24
 296:	91 f7       	brne	.-28     	; 0x27c <main+0xea>
 298:	c0 cf       	rjmp	.-128    	; 0x21a <main+0x88>

0000029a <usb_init>:


// initialize USB
void usb_init(void)
{
	HW_CONFIG();
 29a:	81 e0       	ldi	r24, 0x01	; 1
 29c:	80 93 d7 00 	sts	0x00D7, r24
	USB_FREEZE();				// enable USB
 2a0:	80 ea       	ldi	r24, 0xA0	; 160
 2a2:	80 93 d8 00 	sts	0x00D8, r24
	PLL_CONFIG();				// config PLL
 2a6:	82 e0       	ldi	r24, 0x02	; 2
 2a8:	89 bd       	out	0x29, r24	; 41
        while (!(PLLCSR & (1<<PLOCK))) ;	// wait for PLL lock
 2aa:	09 b4       	in	r0, 0x29	; 41
 2ac:	00 fe       	sbrs	r0, 0
 2ae:	fd cf       	rjmp	.-6      	; 0x2aa <usb_init+0x10>
        USB_CONFIG();				// start USB clock
 2b0:	80 e9       	ldi	r24, 0x90	; 144
 2b2:	80 93 d8 00 	sts	0x00D8, r24
        UDCON = 0;				// enable attach resistor
 2b6:	10 92 e0 00 	sts	0x00E0, r1
	usb_configuration = 0;
 2ba:	10 92 01 01 	sts	0x0101, r1
    UDIEN = (1<<EORSTE)|(1<<SOFE);
 2be:	8c e0       	ldi	r24, 0x0C	; 12
 2c0:	80 93 e2 00 	sts	0x00E2, r24
	sei();
 2c4:	78 94       	sei
}
 2c6:	08 95       	ret

000002c8 <usb_configured>:

// return 0 if the USB is not configured, or the configuration
// number selected by the HOST
uint8_t usb_configured(void)
{
	return usb_configuration;
 2c8:	80 91 01 01 	lds	r24, 0x0101
}
 2cc:	08 95       	ret

000002ce <usb_rawhid_send>:

// send a packet, with timeout
int8_t usb_rawhid_send(const uint8_t *buffer, uint8_t timeout)
{
 2ce:	fc 01       	movw	r30, r24
	uint8_t intr_state;
	uint8_t Data_cnt;

	// if we're not online (enumerated and configured), error
	if (!usb_configuration) return -1;
 2d0:	80 91 01 01 	lds	r24, 0x0101
 2d4:	88 23       	and	r24, r24
 2d6:	39 f1       	breq	.+78     	; 0x326 <usb_rawhid_send+0x58>
	intr_state = SREG;
 2d8:	2f b7       	in	r18, 0x3f	; 63
	cli();
 2da:	f8 94       	cli
	tx_timeout_count = timeout;
 2dc:	60 93 02 01 	sts	0x0102, r22
	UENUM = RAWHID_TX_ENDPOINT;
 2e0:	81 e0       	ldi	r24, 0x01	; 1
 2e2:	80 93 e9 00 	sts	0x00E9, r24
		SREG = intr_state;
		if (tx_timeout_count == 0) return 0;
		if (!usb_configuration) return -1;
		intr_state = SREG;
		cli();
		UENUM = RAWHID_TX_ENDPOINT;
 2e6:	91 e0       	ldi	r25, 0x01	; 1
	cli();
	tx_timeout_count = timeout;
	UENUM = RAWHID_TX_ENDPOINT;
	// wait for the FIFO to be ready to accept data
	while (1) {
		if (UEINTX & (1<<RWAL)) break;
 2e8:	80 91 e8 00 	lds	r24, 0x00E8
 2ec:	85 ff       	sbrs	r24, 5
 2ee:	02 c0       	rjmp	.+4      	; 0x2f4 <usb_rawhid_send+0x26>
 2f0:	91 e4       	ldi	r25, 0x41	; 65
 2f2:	11 c0       	rjmp	.+34     	; 0x316 <usb_rawhid_send+0x48>
		SREG = intr_state;
 2f4:	2f bf       	out	0x3f, r18	; 63
		if (tx_timeout_count == 0) return 0;
 2f6:	80 91 02 01 	lds	r24, 0x0102
 2fa:	88 23       	and	r24, r24
 2fc:	a9 f0       	breq	.+42     	; 0x328 <usb_rawhid_send+0x5a>
		if (!usb_configuration) return -1;
 2fe:	80 91 01 01 	lds	r24, 0x0101
 302:	88 23       	and	r24, r24
 304:	81 f0       	breq	.+32     	; 0x326 <usb_rawhid_send+0x58>
		intr_state = SREG;
 306:	2f b7       	in	r18, 0x3f	; 63
		cli();
 308:	f8 94       	cli
		UENUM = RAWHID_TX_ENDPOINT;
 30a:	90 93 e9 00 	sts	0x00E9, r25
 30e:	ec cf       	rjmp	.-40     	; 0x2e8 <usb_rawhid_send+0x1a>
	}
	// write bytes from the FIFO
	Data_cnt = RAWHID_TX_SIZE + 1;	// size of buffer
	while (Data_cnt--) {UEDATX = *buffer++;}	// Transfer data from UEDATX to buffer..
 310:	81 91       	ld	r24, Z+
 312:	80 93 f1 00 	sts	0x00F1, r24
 316:	91 50       	subi	r25, 0x01	; 1
 318:	d8 f7       	brcc	.-10     	; 0x310 <usb_rawhid_send+0x42>
	// transmit it now
	UEINTX = 0x3A;
 31a:	8a e3       	ldi	r24, 0x3A	; 58
 31c:	80 93 e8 00 	sts	0x00E8, r24
	SREG = intr_state;
 320:	2f bf       	out	0x3f, r18	; 63
 322:	80 e4       	ldi	r24, 0x40	; 64
 324:	08 95       	ret
	return RAWHID_TX_SIZE;
 326:	8f ef       	ldi	r24, 0xFF	; 255
}
 328:	08 95       	ret

0000032a <__vector_10>:

// USB Device Interrupt - handle all device-level events
// the transmit buffer flushing is triggered by the start of frame
//
ISR(USB_GEN_vect)
{
 32a:	1f 92       	push	r1
 32c:	0f 92       	push	r0
 32e:	0f b6       	in	r0, 0x3f	; 63
 330:	0f 92       	push	r0
 332:	11 24       	eor	r1, r1
 334:	8f 93       	push	r24
 336:	9f 93       	push	r25
uint8_t intbits, t;
intbits = UDINT;
 338:	80 91 e1 00 	lds	r24, 0x00E1
UDINT = 0;
 33c:	10 92 e1 00 	sts	0x00E1, r1
if (intbits & (1<<EORSTI)) 
 340:	98 2f       	mov	r25, r24
 342:	93 ff       	sbrs	r25, 3
 344:	0f c0       	rjmp	.+30     	; 0x364 <__vector_10+0x3a>
	{
	UENUM = 0;
 346:	10 92 e9 00 	sts	0x00E9, r1
	UECONX = 1;
 34a:	81 e0       	ldi	r24, 0x01	; 1
 34c:	80 93 eb 00 	sts	0x00EB, r24
	UECFG0X = EP_TYPE_CONTROL;
 350:	10 92 ec 00 	sts	0x00EC, r1
	UECFG1X = EP_SIZE(ENDPOINT0_SIZE) | EP_SINGLE_BUFFER;
 354:	82 e3       	ldi	r24, 0x32	; 50
 356:	80 93 ed 00 	sts	0x00ED, r24
	UEIENX = (1<<RXSTPE);
 35a:	88 e0       	ldi	r24, 0x08	; 8
 35c:	80 93 f0 00 	sts	0x00F0, r24
	usb_configuration = 0;
 360:	10 92 01 01 	sts	0x0101, r1
    }
if ((intbits & (1<<SOFI)) && usb_configuration) 
 364:	92 ff       	sbrs	r25, 2
 366:	0b c0       	rjmp	.+22     	; 0x37e <__vector_10+0x54>
 368:	80 91 01 01 	lds	r24, 0x0101
 36c:	88 23       	and	r24, r24
 36e:	39 f0       	breq	.+14     	; 0x37e <__vector_10+0x54>
	{
	t = tx_timeout_count;
 370:	80 91 02 01 	lds	r24, 0x0102
	if (t) tx_timeout_count = --t;
 374:	88 23       	and	r24, r24
 376:	19 f0       	breq	.+6      	; 0x37e <__vector_10+0x54>
 378:	81 50       	subi	r24, 0x01	; 1
 37a:	80 93 02 01 	sts	0x0102, r24
	}
}
 37e:	9f 91       	pop	r25
 380:	8f 91       	pop	r24
 382:	0f 90       	pop	r0
 384:	0f be       	out	0x3f, r0	; 63
 386:	0f 90       	pop	r0
 388:	1f 90       	pop	r1
 38a:	18 95       	reti

0000038c <__vector_11>:
// USB Endpoint Interrupt - endpoint 0 is handled here.  The
// other endpoints are manipulated by the user-callable
// functions, and the start-of-frame interrupt.
//
ISR(USB_COM_vect)
{
 38c:	1f 92       	push	r1
 38e:	0f 92       	push	r0
 390:	0f b6       	in	r0, 0x3f	; 63
 392:	0f 92       	push	r0
 394:	11 24       	eor	r1, r1
 396:	0f 93       	push	r16
 398:	1f 93       	push	r17
 39a:	2f 93       	push	r18
 39c:	3f 93       	push	r19
 39e:	4f 93       	push	r20
 3a0:	5f 93       	push	r21
 3a2:	6f 93       	push	r22
 3a4:	7f 93       	push	r23
 3a6:	8f 93       	push	r24
 3a8:	9f 93       	push	r25
 3aa:	af 93       	push	r26
 3ac:	bf 93       	push	r27
 3ae:	ef 93       	push	r30
 3b0:	ff 93       	push	r31
uint16_t wLength;
uint16_t desc_val;
const uint8_t *desc_addr;
uint8_t	desc_length;

UENUM = 0;
 3b2:	10 92 e9 00 	sts	0x00E9, r1
intbits = UEINTX;
 3b6:	80 91 e8 00 	lds	r24, 0x00E8
if (intbits & (1<<RXSTPI)) 
 3ba:	83 ff       	sbrs	r24, 3
 3bc:	16 c1       	rjmp	.+556    	; 0x5ea <__vector_11+0x25e>
	{
    bmRequestType = UEDATX;
 3be:	40 91 f1 00 	lds	r20, 0x00F1
    bRequest = UEDATX;
 3c2:	30 91 f1 00 	lds	r19, 0x00F1
    wValue = UEDATX;
 3c6:	80 91 f1 00 	lds	r24, 0x00F1
 3ca:	a8 2f       	mov	r26, r24
 3cc:	b0 e0       	ldi	r27, 0x00	; 0
    wValue |= (UEDATX << 8);
 3ce:	20 91 f1 00 	lds	r18, 0x00F1
 3d2:	92 2f       	mov	r25, r18
 3d4:	80 e0       	ldi	r24, 0x00	; 0
 3d6:	a8 2b       	or	r26, r24
 3d8:	b9 2b       	or	r27, r25
    wIndex = UEDATX;
 3da:	80 91 f1 00 	lds	r24, 0x00F1
 3de:	68 2f       	mov	r22, r24
 3e0:	70 e0       	ldi	r23, 0x00	; 0
    wIndex |= (UEDATX << 8);
 3e2:	20 91 f1 00 	lds	r18, 0x00F1
 3e6:	92 2f       	mov	r25, r18
 3e8:	80 e0       	ldi	r24, 0x00	; 0
 3ea:	68 2b       	or	r22, r24
 3ec:	79 2b       	or	r23, r25
    wLength = UEDATX;
 3ee:	10 91 f1 00 	lds	r17, 0x00F1
    wLength |= (UEDATX << 8);
 3f2:	00 91 f1 00 	lds	r16, 0x00F1
    UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
 3f6:	82 ef       	ldi	r24, 0xF2	; 242
 3f8:	80 93 e8 00 	sts	0x00E8, r24

// ******** GET Descriptor *******************
    if (bRequest == GET_DESCRIPTOR) 
 3fc:	36 30       	cpi	r19, 0x06	; 6
 3fe:	09 f0       	breq	.+2      	; 0x402 <__vector_11+0x76>
 400:	5a c0       	rjmp	.+180    	; 0x4b6 <__vector_11+0x12a>
 402:	23 eb       	ldi	r18, 0xB3	; 179
 404:	30 e0       	ldi	r19, 0x00	; 0
 406:	a9 01       	movw	r20, r18
 408:	45 50       	subi	r20, 0x05	; 5
 40a:	50 40       	sbci	r21, 0x00	; 0
		for (i=0; ; i++) 
			{
			if (i >= NUM_DESC_LIST) 
				{
				UECONX = (1<<STALLRQ)|(1<<EPEN);  //stall
				return;
 40c:	f9 01       	movw	r30, r18
 40e:	37 97       	sbiw	r30, 0x07	; 7
				}
			desc_val = pgm_read_word(list);
 410:	85 91       	lpm	r24, Z+
 412:	94 91       	lpm	r25, Z+
			if (desc_val != wValue) 
 414:	8a 17       	cp	r24, r26
 416:	9b 07       	cpc	r25, r27
 418:	01 f5       	brne	.+64     	; 0x45a <__vector_11+0xce>
				{
				list += sizeof(struct descriptor_list_struct);
				continue;
				}
			list += 2;
			desc_val = pgm_read_word(list);
 41a:	fa 01       	movw	r30, r20
 41c:	85 91       	lpm	r24, Z+
 41e:	94 91       	lpm	r25, Z+
			if (desc_val != wIndex) 
 420:	86 17       	cp	r24, r22
 422:	97 07       	cpc	r25, r23
 424:	d1 f4       	brne	.+52     	; 0x45a <__vector_11+0xce>
				{
				list += sizeof(struct descriptor_list_struct)-2;
				continue;
				}
			list += 2;
 426:	9a 01       	movw	r18, r20
 428:	2e 5f       	subi	r18, 0xFE	; 254
 42a:	3f 4f       	sbci	r19, 0xFF	; 255
			desc_addr = (const uint8_t *)pgm_read_word(list);
 42c:	f9 01       	movw	r30, r18
 42e:	65 91       	lpm	r22, Z+
 430:	74 91       	lpm	r23, Z+
			list += 2;
			desc_length = pgm_read_byte(list);
 432:	2e 5f       	subi	r18, 0xFE	; 254
 434:	3f 4f       	sbci	r19, 0xFF	; 255
 436:	f9 01       	movw	r30, r18
 438:	44 91       	lpm	r20, Z+
    bRequest = UEDATX;
    wValue = UEDATX;
    wValue |= (UEDATX << 8);
    wIndex = UEDATX;
    wIndex |= (UEDATX << 8);
    wLength = UEDATX;
 43a:	21 2f       	mov	r18, r17
 43c:	30 e0       	ldi	r19, 0x00	; 0
			desc_addr = (const uint8_t *)pgm_read_word(list);
			list += 2;
			desc_length = pgm_read_byte(list);
			break;
			}
		len = (wLength < 256) ? wLength : 255;
 43e:	90 2f       	mov	r25, r16
 440:	80 e0       	ldi	r24, 0x00	; 0
 442:	28 2b       	or	r18, r24
 444:	39 2b       	or	r19, r25
 446:	2f 3f       	cpi	r18, 0xFF	; 255
 448:	31 05       	cpc	r19, r1
 44a:	19 f0       	breq	.+6      	; 0x452 <__vector_11+0xc6>
 44c:	10 f0       	brcs	.+4      	; 0x452 <__vector_11+0xc6>
 44e:	2f ef       	ldi	r18, 0xFF	; 255
 450:	30 e0       	ldi	r19, 0x00	; 0
 452:	24 17       	cp	r18, r20
 454:	58 f4       	brcc	.+22     	; 0x46c <__vector_11+0xe0>
 456:	42 2f       	mov	r20, r18
 458:	09 c0       	rjmp	.+18     	; 0x46c <__vector_11+0xe0>
 45a:	29 5f       	subi	r18, 0xF9	; 249
 45c:	3f 4f       	sbci	r19, 0xFF	; 255
 45e:	49 5f       	subi	r20, 0xF9	; 249
 460:	5f 4f       	sbci	r21, 0xFF	; 255
    if (bRequest == GET_DESCRIPTOR) 
		{
		list = (const uint8_t *)descriptor_list;
		for (i=0; ; i++) 
			{
			if (i >= NUM_DESC_LIST) 
 462:	f0 e0       	ldi	r31, 0x00	; 0
 464:	24 3e       	cpi	r18, 0xE4	; 228
 466:	3f 07       	cpc	r19, r31
 468:	89 f6       	brne	.-94     	; 0x40c <__vector_11+0x80>
 46a:	bf c0       	rjmp	.+382    	; 0x5ea <__vector_11+0x25e>



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
 46c:	5e ef       	ldi	r21, 0xFE	; 254
		do 
			{
			// wait for host ready for IN packet
			do 
				{
				i = UEINTX;
 46e:	80 91 e8 00 	lds	r24, 0x00E8
				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
 472:	28 2f       	mov	r18, r24
 474:	30 e0       	ldi	r19, 0x00	; 0
 476:	c9 01       	movw	r24, r18
 478:	85 70       	andi	r24, 0x05	; 5
 47a:	90 70       	andi	r25, 0x00	; 0
 47c:	89 2b       	or	r24, r25
 47e:	b9 f3       	breq	.-18     	; 0x46e <__vector_11+0xe2>
			if (i & (1<<RXOUTI)) return;	// abort
 480:	22 fd       	sbrc	r18, 2
 482:	b6 c0       	rjmp	.+364    	; 0x5f0 <__vector_11+0x264>
			// send IN packet
			n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
 484:	34 2f       	mov	r19, r20
 486:	41 34       	cpi	r20, 0x41	; 65
 488:	08 f0       	brcs	.+2      	; 0x48c <__vector_11+0x100>
 48a:	30 e4       	ldi	r19, 0x40	; 64
 48c:	23 2f       	mov	r18, r19
 48e:	cb 01       	movw	r24, r22
 490:	06 c0       	rjmp	.+12     	; 0x49e <__vector_11+0x112>
			for (i = n; i; i--) 
 492:	fc 01       	movw	r30, r24
				{
				UEDATX = pgm_read_byte(desc_addr++);
 494:	01 96       	adiw	r24, 0x01	; 1
 496:	e4 91       	lpm	r30, Z+
 498:	e0 93 f1 00 	sts	0x00F1, r30
				i = UEINTX;
				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
			if (i & (1<<RXOUTI)) return;	// abort
			// send IN packet
			n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
			for (i = n; i; i--) 
 49c:	21 50       	subi	r18, 0x01	; 1
 49e:	22 23       	and	r18, r18
 4a0:	c1 f7       	brne	.-16     	; 0x492 <__vector_11+0x106>
 4a2:	63 0f       	add	r22, r19
 4a4:	71 1d       	adc	r23, r1
				{
				UEDATX = pgm_read_byte(desc_addr++);
				}
			len -= n;
 4a6:	43 1b       	sub	r20, r19



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
 4a8:	50 93 e8 00 	sts	0x00E8, r21
				{
				UEDATX = pgm_read_byte(desc_addr++);
				}
			len -= n;
			usb_send_in();
			} while (len || n == ENDPOINT0_SIZE);
 4ac:	44 23       	and	r20, r20
 4ae:	f9 f6       	brne	.-66     	; 0x46e <__vector_11+0xe2>
 4b0:	30 34       	cpi	r19, 0x40	; 64
 4b2:	e9 f2       	breq	.-70     	; 0x46e <__vector_11+0xe2>
 4b4:	9d c0       	rjmp	.+314    	; 0x5f0 <__vector_11+0x264>
		return;
        }


	// ******** Set ADDRESS **********************		
	if (bRequest == SET_ADDRESS) 
 4b6:	35 30       	cpi	r19, 0x05	; 5
 4b8:	61 f4       	brne	.+24     	; 0x4d2 <__vector_11+0x146>



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
 4ba:	8e ef       	ldi	r24, 0xFE	; 254
 4bc:	80 93 e8 00 	sts	0x00E8, r24
}



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
 4c0:	80 91 e8 00 	lds	r24, 0x00E8
 4c4:	80 ff       	sbrs	r24, 0
 4c6:	fc cf       	rjmp	.-8      	; 0x4c0 <__vector_11+0x134>
	// ******** Set ADDRESS **********************		
	if (bRequest == SET_ADDRESS) 
		{
		usb_send_in();
		usb_wait_in_ready();
		UDADDR = wValue | (1<<ADDEN);
 4c8:	8a 2f       	mov	r24, r26
 4ca:	80 68       	ori	r24, 0x80	; 128
 4cc:	80 93 e3 00 	sts	0x00E3, r24
 4d0:	8f c0       	rjmp	.+286    	; 0x5f0 <__vector_11+0x264>
		return;
		}

	// ******** Set Configuration **********************		
	if (bRequest == SET_CONFIGURATION && bmRequestType == 0) 
 4d2:	39 30       	cpi	r19, 0x09	; 9
 4d4:	51 f5       	brne	.+84     	; 0x52a <__vector_11+0x19e>
 4d6:	44 23       	and	r20, r20
 4d8:	09 f0       	breq	.+2      	; 0x4dc <__vector_11+0x150>
 4da:	50 c0       	rjmp	.+160    	; 0x57c <__vector_11+0x1f0>
		{
		usb_configuration = wValue;
 4dc:	a0 93 01 01 	sts	0x0101, r26



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
 4e0:	8e ef       	ldi	r24, 0xFE	; 254
 4e2:	80 93 e8 00 	sts	0x00E8, r24
 4e6:	8d ed       	ldi	r24, 0xDD	; 221
 4e8:	90 e0       	ldi	r25, 0x00	; 0
 4ea:	21 e0       	ldi	r18, 0x01	; 1
		usb_configuration = wValue;
		usb_send_in();
		cfg = endpoint_config_table;
		for (i=1; i<5; i++) 
			{
			UENUM = i;
 4ec:	20 93 e9 00 	sts	0x00E9, r18
			en = pgm_read_byte(cfg++);
 4f0:	fc 01       	movw	r30, r24
 4f2:	01 96       	adiw	r24, 0x01	; 1
 4f4:	e4 91       	lpm	r30, Z+
			UECONX = en;
 4f6:	e0 93 eb 00 	sts	0x00EB, r30
			if (en) 
 4fa:	ee 23       	and	r30, r30
 4fc:	69 f0       	breq	.+26     	; 0x518 <__vector_11+0x18c>
				{
				UECFG0X = pgm_read_byte(cfg++);
 4fe:	ac 01       	movw	r20, r24
 500:	4f 5f       	subi	r20, 0xFF	; 255
 502:	5f 4f       	sbci	r21, 0xFF	; 255
 504:	fc 01       	movw	r30, r24
 506:	84 91       	lpm	r24, Z+
 508:	80 93 ec 00 	sts	0x00EC, r24
				UECFG1X = pgm_read_byte(cfg++);
 50c:	ca 01       	movw	r24, r20
 50e:	01 96       	adiw	r24, 0x01	; 1
 510:	fa 01       	movw	r30, r20
 512:	34 91       	lpm	r19, Z+
 514:	30 93 ed 00 	sts	0x00ED, r19
	if (bRequest == SET_CONFIGURATION && bmRequestType == 0) 
		{
		usb_configuration = wValue;
		usb_send_in();
		cfg = endpoint_config_table;
		for (i=1; i<5; i++) 
 518:	2f 5f       	subi	r18, 0xFF	; 255
 51a:	25 30       	cpi	r18, 0x05	; 5
 51c:	39 f7       	brne	.-50     	; 0x4ec <__vector_11+0x160>
				{
				UECFG0X = pgm_read_byte(cfg++);
				UECFG1X = pgm_read_byte(cfg++);
				}
			}
		UERST = 0x1E;
 51e:	8e e1       	ldi	r24, 0x1E	; 30
 520:	80 93 ea 00 	sts	0x00EA, r24
		UERST = 0;
 524:	10 92 ea 00 	sts	0x00EA, r1
 528:	63 c0       	rjmp	.+198    	; 0x5f0 <__vector_11+0x264>
		return;
		}
	
	// ******** Get Configuratioin **********************		
	if (bRequest == GET_CONFIGURATION && bmRequestType == 0x80) 
 52a:	38 30       	cpi	r19, 0x08	; 8
 52c:	59 f4       	brne	.+22     	; 0x544 <__vector_11+0x1b8>
 52e:	40 38       	cpi	r20, 0x80	; 128
 530:	29 f5       	brne	.+74     	; 0x57c <__vector_11+0x1f0>
}



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
 532:	80 91 e8 00 	lds	r24, 0x00E8
 536:	80 ff       	sbrs	r24, 0
 538:	fc cf       	rjmp	.-8      	; 0x532 <__vector_11+0x1a6>
	
	// ******** Get Configuratioin **********************		
	if (bRequest == GET_CONFIGURATION && bmRequestType == 0x80) 
		{
		usb_wait_in_ready();
		UEDATX = usb_configuration;
 53a:	80 91 01 01 	lds	r24, 0x0101
 53e:	80 93 f1 00 	sts	0x00F1, r24
 542:	4f c0       	rjmp	.+158    	; 0x5e2 <__vector_11+0x256>
		usb_send_in();
		return;
		}

	// ******** GET Status **********************		
	if (bRequest == GET_STATUS) 
 544:	33 23       	and	r19, r19
 546:	d1 f4       	brne	.+52     	; 0x57c <__vector_11+0x1f0>
}



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
 548:	80 91 e8 00 	lds	r24, 0x00E8
 54c:	80 ff       	sbrs	r24, 0
 54e:	fc cf       	rjmp	.-8      	; 0x548 <__vector_11+0x1bc>
	// ******** GET Status **********************		
	if (bRequest == GET_STATUS) 
		{
		usb_wait_in_ready();
		i = 0;
		if (bmRequestType == 0x82) 
 550:	42 38       	cpi	r20, 0x82	; 130
 552:	11 f0       	breq	.+4      	; 0x558 <__vector_11+0x1cc>
 554:	80 e0       	ldi	r24, 0x00	; 0
 556:	0d c0       	rjmp	.+26     	; 0x572 <__vector_11+0x1e6>
			{
			UENUM = wIndex;
 558:	60 93 e9 00 	sts	0x00E9, r22
			if (UECONX & (1<<STALLRQ)) i = 1;
 55c:	80 91 eb 00 	lds	r24, 0x00EB
 560:	90 e0       	ldi	r25, 0x00	; 0
 562:	25 e0       	ldi	r18, 0x05	; 5
 564:	96 95       	lsr	r25
 566:	87 95       	ror	r24
 568:	2a 95       	dec	r18
 56a:	e1 f7       	brne	.-8      	; 0x564 <__vector_11+0x1d8>
 56c:	81 70       	andi	r24, 0x01	; 1
			UENUM = 0;
 56e:	10 92 e9 00 	sts	0x00E9, r1
			}
		UEDATX = i;
 572:	80 93 f1 00 	sts	0x00F1, r24
		UEDATX = 0;
 576:	10 92 f1 00 	sts	0x00F1, r1
 57a:	33 c0       	rjmp	.+102    	; 0x5e2 <__vector_11+0x256>
			}
		}
*/
	// ******** RAW Interface **********************		

	if (wIndex == RAWHID_INTERFACE) 
 57c:	67 2b       	or	r22, r23
 57e:	a9 f5       	brne	.+106    	; 0x5ea <__vector_11+0x25e>
		{
		// ****** GET REPORT ***********************
		if (bmRequestType == 0xA1 && bRequest == HID_GET_REPORT) 
 580:	41 3a       	cpi	r20, 0xA1	; 161
 582:	a1 f4       	brne	.+40     	; 0x5ac <__vector_11+0x220>
 584:	31 30       	cpi	r19, 0x01	; 1
 586:	89 f5       	brne	.+98     	; 0x5ea <__vector_11+0x25e>
			{
			// wait for host ready for IN packet
			do 
				{
				i = UEINTX;
 588:	80 91 e8 00 	lds	r24, 0x00E8
				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
 58c:	28 2f       	mov	r18, r24
 58e:	30 e0       	ldi	r19, 0x00	; 0
 590:	c9 01       	movw	r24, r18
 592:	85 70       	andi	r24, 0x05	; 5
 594:	90 70       	andi	r25, 0x00	; 0
 596:	89 2b       	or	r24, r25
 598:	b9 f3       	breq	.-18     	; 0x588 <__vector_11+0x1fc>
			if (i & (1<<RXOUTI)) return;	// abort
 59a:	22 fd       	sbrc	r18, 2
 59c:	29 c0       	rjmp	.+82     	; 0x5f0 <__vector_11+0x264>
 59e:	81 e2       	ldi	r24, 0x21	; 33
			// send IN packet
			for (len=0;len < (RAWHID_TX_SIZE ); len++) UEDATX=len+33; // fill buffer for send .. with 1,2,3,4,5,6,7,8..40 (in hex)
 5a0:	80 93 f1 00 	sts	0x00F1, r24
 5a4:	8f 5f       	subi	r24, 0xFF	; 255
 5a6:	81 36       	cpi	r24, 0x61	; 97
 5a8:	d9 f7       	brne	.-10     	; 0x5a0 <__vector_11+0x214>
 5aa:	1b c0       	rjmp	.+54     	; 0x5e2 <__vector_11+0x256>
			usb_send_in();
			return;
			}
	
		// ****** GET REPORT ***********************
		if (bmRequestType == 0x21 && bRequest == HID_SET_REPORT) 
 5ac:	41 32       	cpi	r20, 0x21	; 33
 5ae:	e9 f4       	brne	.+58     	; 0x5ea <__vector_11+0x25e>
 5b0:	39 30       	cpi	r19, 0x09	; 9
 5b2:	d9 f4       	brne	.+54     	; 0x5ea <__vector_11+0x25e>


// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
static inline void usb_wait_receive_out(void){while (!(UEINTX & (1<<RXOUTI))) ;}
 5b4:	80 91 e8 00 	lds	r24, 0x00E8
 5b8:	82 ff       	sbrs	r24, 2
 5ba:	fc cf       	rjmp	.-8      	; 0x5b4 <__vector_11+0x228>
 5bc:	e3 e0       	ldi	r30, 0x03	; 3
 5be:	f1 e0       	ldi	r31, 0x01	; 1
	
		// ****** GET REPORT ***********************
		if (bmRequestType == 0x21 && bRequest == HID_SET_REPORT) 
			{
			usb_wait_receive_out();
			for (len=0;len < (RAWHID_RX_SIZE );len++) buffer[len] = UEDATX; // read data from PC to buffer in size 64 bytes..
 5c0:	80 91 f1 00 	lds	r24, 0x00F1
 5c4:	81 93       	st	Z+, r24
 5c6:	81 e0       	ldi	r24, 0x01	; 1
 5c8:	e3 34       	cpi	r30, 0x43	; 67
 5ca:	f8 07       	cpc	r31, r24
 5cc:	c9 f7       	brne	.-14     	; 0x5c0 <__vector_11+0x234>
			SU = 1;
 5ce:	81 e0       	ldi	r24, 0x01	; 1
 5d0:	80 93 43 01 	sts	0x0143, r24

// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
static inline void usb_wait_receive_out(void){while (!(UEINTX & (1<<RXOUTI))) ;}
static inline void usb_ack_out(void){	UEINTX = ~(1<<RXOUTI);}
 5d4:	8b ef       	ldi	r24, 0xFB	; 251
 5d6:	80 93 e8 00 	sts	0x00E8, r24
}



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
 5da:	80 91 e8 00 	lds	r24, 0x00E8
 5de:	80 ff       	sbrs	r24, 0
 5e0:	fc cf       	rjmp	.-8      	; 0x5da <__vector_11+0x24e>
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
 5e2:	8e ef       	ldi	r24, 0xFE	; 254
 5e4:	80 93 e8 00 	sts	0x00E8, r24
 5e8:	03 c0       	rjmp	.+6      	; 0x5f0 <__vector_11+0x264>
			}

		}

	}
UECONX = (1<<STALLRQ) | (1<<EPEN);	// stall
 5ea:	81 e2       	ldi	r24, 0x21	; 33
 5ec:	80 93 eb 00 	sts	0x00EB, r24
}
 5f0:	ff 91       	pop	r31
 5f2:	ef 91       	pop	r30
 5f4:	bf 91       	pop	r27
 5f6:	af 91       	pop	r26
 5f8:	9f 91       	pop	r25
 5fa:	8f 91       	pop	r24
 5fc:	7f 91       	pop	r23
 5fe:	6f 91       	pop	r22
 600:	5f 91       	pop	r21
 602:	4f 91       	pop	r20
 604:	3f 91       	pop	r19
 606:	2f 91       	pop	r18
 608:	1f 91       	pop	r17
 60a:	0f 91       	pop	r16
 60c:	0f 90       	pop	r0
 60e:	0f be       	out	0x3f, r0	; 63
 610:	0f 90       	pop	r0
 612:	1f 90       	pop	r1
 614:	18 95       	reti

00000616 <_exit>:
 616:	f8 94       	cli

00000618 <__stop_program>:
 618:	ff cf       	rjmp	.-2      	; 0x618 <__stop_program>
