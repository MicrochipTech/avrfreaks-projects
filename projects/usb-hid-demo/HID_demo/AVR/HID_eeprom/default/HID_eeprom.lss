
HID_eeprom.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000054c  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000042  00800100  00800100  000005c0  2**0
                  ALLOC
  2 .debug_aranges 00000040  00000000  00000000  000005c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 00000091  00000000  00000000  00000600  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000006f3  00000000  00000000  00000691  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00000262  00000000  00000000  00000d84  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000535  00000000  00000000  00000fe6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000070  00000000  00000000  0000151c  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    000002a0  00000000  00000000  0000158c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000539  00000000  00000000  0000182c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000018  00000000  00000000  00001d65  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__ctors_end>
   4:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
   8:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
   c:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  10:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  14:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  18:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  1c:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  20:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  24:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  28:	0c 94 fa 00 	jmp	0x1f4	; 0x1f4 <__vector_10>
  2c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__vector_11>
  30:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  34:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  38:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  3c:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  40:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  44:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  48:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  4c:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  50:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  54:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  58:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  5c:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  60:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  64:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  68:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  6c:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  70:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  74:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  78:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  7c:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  80:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  84:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  88:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  8c:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  90:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  94:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  98:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  9c:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  a0:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  a4:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
  a8:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>

000000ac <descriptor_list>:
  ac:	00 01 00 00 e5 00 12 00 02 00 00 f7 00 29 00 22     .............)."
  bc:	00 00 20 01 1c 00 21 00 00 09 01 09 00 03 00 00     .. ...!.........
  cc:	3c 01 04 01 03 09 04 40 01 12 02 03 09 04 54 01     <......@......T.
  dc:	16                                                  .

000000dd <endpoint_config_table>:
  dd:	01 c1 32 01 c0 32 00 00                             ..2..2..

000000e5 <device_descriptor>:
  e5:	12 01 00 02 00 00 00 40 c0 16 80 04 00 01 01 02     .......@........
  f5:	00 01                                               ..

000000f7 <config1_descriptor>:
  f7:	09 02 29 00 01 01 00 c0 32 09 04 00 00 02 03 00     ..).....2.......
 107:	00 00 09 21 11 01 00 01 22 1c 00 07 05 81 03 40     ...!...."......@
 117:	00 02 07 05 02 03 40 00 08                          ......@..

00000120 <rawhid_hid_report_desc>:
 120:	06 ab ff 0a 00 02 a1 01 15 00 26 ff 00 75 08 95     ..........&..u..
 130:	40 09 00 91 02 09 01 95 40 81 02 c0                 @.......@...

0000013c <string0>:
 13c:	04 03 09 04                                         ....

00000140 <string1>:
 140:	12 03 50 00 4a 00 52 00 43 00 2e 00 43 00 4f 00     ..P.J.R.C...C.O.
 150:	4d 00 00 00                                         M...

00000154 <string2>:
 154:	16 03 48 00 49 00 44 00 20 00 65 00 65 00 70 00     ..H.I.D. .e.e.p.
 164:	72 00 6f 00 6d 00 00 00                             r.o.m...

0000016c <__ctors_end>:
 16c:	11 24       	eor	r1, r1
 16e:	1f be       	out	0x3f, r1	; 63
 170:	cf ef       	ldi	r28, 0xFF	; 255
 172:	da e0       	ldi	r29, 0x0A	; 10
 174:	de bf       	out	0x3e, r29	; 62
 176:	cd bf       	out	0x3d, r28	; 61

00000178 <__do_clear_bss>:
 178:	11 e0       	ldi	r17, 0x01	; 1
 17a:	a0 e0       	ldi	r26, 0x00	; 0
 17c:	b1 e0       	ldi	r27, 0x01	; 1
 17e:	01 c0       	rjmp	.+2      	; 0x182 <.do_clear_bss_start>

00000180 <.do_clear_bss_loop>:
 180:	1d 92       	st	X+, r1

00000182 <.do_clear_bss_start>:
 182:	a2 34       	cpi	r26, 0x42	; 66
 184:	b1 07       	cpc	r27, r17
 186:	e1 f7       	brne	.-8      	; 0x180 <.do_clear_bss_loop>
 188:	0e 94 ca 00 	call	0x194	; 0x194 <main>
 18c:	0c 94 a4 02 	jmp	0x548	; 0x548 <_exit>

00000190 <__bad_interrupt>:
 190:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000194 <main>:
volatile uint8_t do_output=0;


int main(void)
{
	sbi(PORTF,1);	// pull up for PORT F pin 1 - ARUINO Leonardo board A4 pin
 194:	89 9a       	sbi	0x11, 1	; 17
	// set for 8 MHz clock
	CPU_PRESCALE(0);
 196:	80 e8       	ldi	r24, 0x80	; 128
 198:	80 93 61 00 	sts	0x0061, r24
 19c:	10 92 61 00 	sts	0x0061, r1
	// Initialize the USB, and then wait for the host to set configuration.
	// If the Teensy is powered without a PC connected to the USB port,
	// this will wait forever.
	usb_init();
 1a0:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <usb_init>
	while (!usb_configured()) /* wait */ ;
 1a4:	0e 94 f7 00 	call	0x1ee	; 0x1ee <usb_configured>
 1a8:	88 23       	and	r24, r24
 1aa:	e1 f3       	breq	.-8      	; 0x1a4 <main+0x10>
 1ac:	80 e1       	ldi	r24, 0x10	; 16
 1ae:	97 e2       	ldi	r25, 0x27	; 39
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 1b0:	28 ec       	ldi	r18, 0xC8	; 200
 1b2:	30 e0       	ldi	r19, 0x00	; 0
 1b4:	f9 01       	movw	r30, r18
 1b6:	31 97       	sbiw	r30, 0x01	; 1
 1b8:	f1 f7       	brne	.-4      	; 0x1b6 <main+0x22>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 1ba:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 1bc:	d9 f7       	brne	.-10     	; 0x1b4 <main+0x20>
 1be:	ff cf       	rjmp	.-2      	; 0x1be <main+0x2a>

000001c0 <usb_init>:


// initialize USB
void usb_init(void)
{
	HW_CONFIG();
 1c0:	81 e0       	ldi	r24, 0x01	; 1
 1c2:	80 93 d7 00 	sts	0x00D7, r24
	USB_FREEZE();				// enable USB
 1c6:	80 ea       	ldi	r24, 0xA0	; 160
 1c8:	80 93 d8 00 	sts	0x00D8, r24
	PLL_CONFIG();				// config PLL
 1cc:	82 e0       	ldi	r24, 0x02	; 2
 1ce:	89 bd       	out	0x29, r24	; 41
        while (!(PLLCSR & (1<<PLOCK))) ;	// wait for PLL lock
 1d0:	09 b4       	in	r0, 0x29	; 41
 1d2:	00 fe       	sbrs	r0, 0
 1d4:	fd cf       	rjmp	.-6      	; 0x1d0 <usb_init+0x10>
        USB_CONFIG();				// start USB clock
 1d6:	80 e9       	ldi	r24, 0x90	; 144
 1d8:	80 93 d8 00 	sts	0x00D8, r24
        UDCON = 0;				// enable attach resistor
 1dc:	10 92 e0 00 	sts	0x00E0, r1
	usb_configuration = 0;
 1e0:	10 92 01 01 	sts	0x0101, r1
    UDIEN = (1<<EORSTE)|(1<<SOFE);
 1e4:	8c e0       	ldi	r24, 0x0C	; 12
 1e6:	80 93 e2 00 	sts	0x00E2, r24
	sei();
 1ea:	78 94       	sei
}
 1ec:	08 95       	ret

000001ee <usb_configured>:

// return 0 if the USB is not configured, or the configuration
// number selected by the HOST
uint8_t usb_configured(void)
{
	return usb_configuration;
 1ee:	80 91 01 01 	lds	r24, 0x0101
}
 1f2:	08 95       	ret

000001f4 <__vector_10>:

// USB Device Interrupt - handle all device-level events
// the transmit buffer flushing is triggered by the start of frame
//
ISR(USB_GEN_vect)
{
 1f4:	1f 92       	push	r1
 1f6:	0f 92       	push	r0
 1f8:	0f b6       	in	r0, 0x3f	; 63
 1fa:	0f 92       	push	r0
 1fc:	11 24       	eor	r1, r1
 1fe:	8f 93       	push	r24
uint8_t intbits;
intbits = UDINT;
 200:	80 91 e1 00 	lds	r24, 0x00E1
UDINT = 0;
 204:	10 92 e1 00 	sts	0x00E1, r1
if (intbits & (1<<EORSTI)) 
 208:	83 ff       	sbrs	r24, 3
 20a:	0f c0       	rjmp	.+30     	; 0x22a <__vector_10+0x36>
	{
	UENUM = 0;
 20c:	10 92 e9 00 	sts	0x00E9, r1
	UECONX = 1;
 210:	81 e0       	ldi	r24, 0x01	; 1
 212:	80 93 eb 00 	sts	0x00EB, r24
	UECFG0X = EP_TYPE_CONTROL;
 216:	10 92 ec 00 	sts	0x00EC, r1
	UECFG1X = EP_SIZE(ENDPOINT0_SIZE) | EP_SINGLE_BUFFER;
 21a:	82 e3       	ldi	r24, 0x32	; 50
 21c:	80 93 ed 00 	sts	0x00ED, r24
	UEIENX = (1<<RXSTPE);
 220:	88 e0       	ldi	r24, 0x08	; 8
 222:	80 93 f0 00 	sts	0x00F0, r24
	usb_configuration = 0;
 226:	10 92 01 01 	sts	0x0101, r1
    }
}
 22a:	8f 91       	pop	r24
 22c:	0f 90       	pop	r0
 22e:	0f be       	out	0x3f, r0	; 63
 230:	0f 90       	pop	r0
 232:	1f 90       	pop	r1
 234:	18 95       	reti

00000236 <__vector_11>:
// USB Endpoint Interrupt - endpoint 0 is handled here.  The
// other endpoints are manipulated by the user-callable
// functions, and the start-of-frame interrupt.
//
ISR(USB_COM_vect)
{
 236:	1f 92       	push	r1
 238:	0f 92       	push	r0
 23a:	0f b6       	in	r0, 0x3f	; 63
 23c:	0f 92       	push	r0
 23e:	11 24       	eor	r1, r1
 240:	0f 93       	push	r16
 242:	1f 93       	push	r17
 244:	2f 93       	push	r18
 246:	3f 93       	push	r19
 248:	4f 93       	push	r20
 24a:	5f 93       	push	r21
 24c:	6f 93       	push	r22
 24e:	7f 93       	push	r23
 250:	8f 93       	push	r24
 252:	9f 93       	push	r25
 254:	af 93       	push	r26
 256:	bf 93       	push	r27
 258:	ef 93       	push	r30
 25a:	ff 93       	push	r31
uint16_t wLength;
uint16_t desc_val;
const uint8_t *desc_addr;
uint8_t	desc_length;

UENUM = 0;
 25c:	10 92 e9 00 	sts	0x00E9, r1
intbits = UEINTX;
 260:	80 91 e8 00 	lds	r24, 0x00E8
if (intbits & (1<<RXSTPI)) 
 264:	83 ff       	sbrs	r24, 3
 266:	32 c1       	rjmp	.+612    	; 0x4cc <__vector_11+0x296>
	{
    bmRequestType = UEDATX;
 268:	40 91 f1 00 	lds	r20, 0x00F1
    bRequest = UEDATX;
 26c:	30 91 f1 00 	lds	r19, 0x00F1
    wValue = UEDATX;
 270:	80 91 f1 00 	lds	r24, 0x00F1
 274:	a8 2f       	mov	r26, r24
 276:	b0 e0       	ldi	r27, 0x00	; 0
    wValue |= (UEDATX << 8);
 278:	20 91 f1 00 	lds	r18, 0x00F1
 27c:	92 2f       	mov	r25, r18
 27e:	80 e0       	ldi	r24, 0x00	; 0
 280:	a8 2b       	or	r26, r24
 282:	b9 2b       	or	r27, r25
    wIndex = UEDATX;
 284:	80 91 f1 00 	lds	r24, 0x00F1
 288:	68 2f       	mov	r22, r24
 28a:	70 e0       	ldi	r23, 0x00	; 0
    wIndex |= (UEDATX << 8);
 28c:	20 91 f1 00 	lds	r18, 0x00F1
 290:	92 2f       	mov	r25, r18
 292:	80 e0       	ldi	r24, 0x00	; 0
 294:	68 2b       	or	r22, r24
 296:	79 2b       	or	r23, r25
    wLength = UEDATX;
 298:	10 91 f1 00 	lds	r17, 0x00F1
    wLength |= (UEDATX << 8);
 29c:	00 91 f1 00 	lds	r16, 0x00F1
    UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
 2a0:	82 ef       	ldi	r24, 0xF2	; 242
 2a2:	80 93 e8 00 	sts	0x00E8, r24

// ******** GET Descriptor *******************
    if (bRequest == GET_DESCRIPTOR) 
 2a6:	36 30       	cpi	r19, 0x06	; 6
 2a8:	09 f0       	breq	.+2      	; 0x2ac <__vector_11+0x76>
 2aa:	5a c0       	rjmp	.+180    	; 0x360 <__vector_11+0x12a>
 2ac:	23 eb       	ldi	r18, 0xB3	; 179
 2ae:	30 e0       	ldi	r19, 0x00	; 0
 2b0:	a9 01       	movw	r20, r18
 2b2:	45 50       	subi	r20, 0x05	; 5
 2b4:	50 40       	sbci	r21, 0x00	; 0
		for (i=0; ; i++) 
			{
			if (i >= NUM_DESC_LIST) 
				{
				UECONX = (1<<STALLRQ)|(1<<EPEN);  //stall
				return;
 2b6:	f9 01       	movw	r30, r18
 2b8:	37 97       	sbiw	r30, 0x07	; 7
				}
			desc_val = pgm_read_word(list);
 2ba:	85 91       	lpm	r24, Z+
 2bc:	94 91       	lpm	r25, Z+
			if (desc_val != wValue) 
 2be:	8a 17       	cp	r24, r26
 2c0:	9b 07       	cpc	r25, r27
 2c2:	01 f5       	brne	.+64     	; 0x304 <__vector_11+0xce>
				{
				list += sizeof(struct descriptor_list_struct);
				continue;
				}
			list += 2;
			desc_val = pgm_read_word(list);
 2c4:	fa 01       	movw	r30, r20
 2c6:	85 91       	lpm	r24, Z+
 2c8:	94 91       	lpm	r25, Z+
			if (desc_val != wIndex) 
 2ca:	86 17       	cp	r24, r22
 2cc:	97 07       	cpc	r25, r23
 2ce:	d1 f4       	brne	.+52     	; 0x304 <__vector_11+0xce>
				{
				list += sizeof(struct descriptor_list_struct)-2;
				continue;
				}
			list += 2;
 2d0:	9a 01       	movw	r18, r20
 2d2:	2e 5f       	subi	r18, 0xFE	; 254
 2d4:	3f 4f       	sbci	r19, 0xFF	; 255
			desc_addr = (const uint8_t *)pgm_read_word(list);
 2d6:	f9 01       	movw	r30, r18
 2d8:	65 91       	lpm	r22, Z+
 2da:	74 91       	lpm	r23, Z+
			list += 2;
			desc_length = pgm_read_byte(list);
 2dc:	2e 5f       	subi	r18, 0xFE	; 254
 2de:	3f 4f       	sbci	r19, 0xFF	; 255
 2e0:	f9 01       	movw	r30, r18
 2e2:	44 91       	lpm	r20, Z+
    bRequest = UEDATX;
    wValue = UEDATX;
    wValue |= (UEDATX << 8);
    wIndex = UEDATX;
    wIndex |= (UEDATX << 8);
    wLength = UEDATX;
 2e4:	21 2f       	mov	r18, r17
 2e6:	30 e0       	ldi	r19, 0x00	; 0
			desc_addr = (const uint8_t *)pgm_read_word(list);
			list += 2;
			desc_length = pgm_read_byte(list);
			break;
			}
		len = (wLength < 256) ? wLength : 255;
 2e8:	90 2f       	mov	r25, r16
 2ea:	80 e0       	ldi	r24, 0x00	; 0
 2ec:	28 2b       	or	r18, r24
 2ee:	39 2b       	or	r19, r25
 2f0:	2f 3f       	cpi	r18, 0xFF	; 255
 2f2:	31 05       	cpc	r19, r1
 2f4:	19 f0       	breq	.+6      	; 0x2fc <__vector_11+0xc6>
 2f6:	10 f0       	brcs	.+4      	; 0x2fc <__vector_11+0xc6>
 2f8:	2f ef       	ldi	r18, 0xFF	; 255
 2fa:	30 e0       	ldi	r19, 0x00	; 0
 2fc:	24 17       	cp	r18, r20
 2fe:	58 f4       	brcc	.+22     	; 0x316 <__vector_11+0xe0>
 300:	42 2f       	mov	r20, r18
 302:	09 c0       	rjmp	.+18     	; 0x316 <__vector_11+0xe0>
 304:	29 5f       	subi	r18, 0xF9	; 249
 306:	3f 4f       	sbci	r19, 0xFF	; 255
 308:	49 5f       	subi	r20, 0xF9	; 249
 30a:	5f 4f       	sbci	r21, 0xFF	; 255
    if (bRequest == GET_DESCRIPTOR) 
		{
		list = (const uint8_t *)descriptor_list;
		for (i=0; ; i++) 
			{
			if (i >= NUM_DESC_LIST) 
 30c:	f0 e0       	ldi	r31, 0x00	; 0
 30e:	24 3e       	cpi	r18, 0xE4	; 228
 310:	3f 07       	cpc	r19, r31
 312:	89 f6       	brne	.-94     	; 0x2b6 <__vector_11+0x80>
 314:	db c0       	rjmp	.+438    	; 0x4cc <__vector_11+0x296>



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
 316:	5e ef       	ldi	r21, 0xFE	; 254
		do 
			{
			// wait for host ready for IN packet
			do 
				{
				i = UEINTX;
 318:	80 91 e8 00 	lds	r24, 0x00E8
				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
 31c:	28 2f       	mov	r18, r24
 31e:	30 e0       	ldi	r19, 0x00	; 0
 320:	c9 01       	movw	r24, r18
 322:	85 70       	andi	r24, 0x05	; 5
 324:	90 70       	andi	r25, 0x00	; 0
 326:	89 2b       	or	r24, r25
 328:	b9 f3       	breq	.-18     	; 0x318 <__vector_11+0xe2>
			if (i & (1<<RXOUTI)) return;	// abort
 32a:	22 fd       	sbrc	r18, 2
 32c:	d2 c0       	rjmp	.+420    	; 0x4d2 <__vector_11+0x29c>
			// send IN packet
			n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
 32e:	34 2f       	mov	r19, r20
 330:	41 34       	cpi	r20, 0x41	; 65
 332:	08 f0       	brcs	.+2      	; 0x336 <__vector_11+0x100>
 334:	30 e4       	ldi	r19, 0x40	; 64
 336:	23 2f       	mov	r18, r19
 338:	cb 01       	movw	r24, r22
 33a:	06 c0       	rjmp	.+12     	; 0x348 <__vector_11+0x112>
			for (i = n; i; i--) 
 33c:	fc 01       	movw	r30, r24
				{
				UEDATX = pgm_read_byte(desc_addr++);
 33e:	01 96       	adiw	r24, 0x01	; 1
 340:	e4 91       	lpm	r30, Z+
 342:	e0 93 f1 00 	sts	0x00F1, r30
				i = UEINTX;
				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
			if (i & (1<<RXOUTI)) return;	// abort
			// send IN packet
			n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
			for (i = n; i; i--) 
 346:	21 50       	subi	r18, 0x01	; 1
 348:	22 23       	and	r18, r18
 34a:	c1 f7       	brne	.-16     	; 0x33c <__vector_11+0x106>
 34c:	63 0f       	add	r22, r19
 34e:	71 1d       	adc	r23, r1
				{
				UEDATX = pgm_read_byte(desc_addr++);
				}
			len -= n;
 350:	43 1b       	sub	r20, r19



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
 352:	50 93 e8 00 	sts	0x00E8, r21
				{
				UEDATX = pgm_read_byte(desc_addr++);
				}
			len -= n;
			usb_send_in();
			} while (len || n == ENDPOINT0_SIZE);
 356:	44 23       	and	r20, r20
 358:	f9 f6       	brne	.-66     	; 0x318 <__vector_11+0xe2>
 35a:	30 34       	cpi	r19, 0x40	; 64
 35c:	e9 f2       	breq	.-70     	; 0x318 <__vector_11+0xe2>
 35e:	b9 c0       	rjmp	.+370    	; 0x4d2 <__vector_11+0x29c>
		return;
        }


	// ******** Set ADDRESS **********************		
	if (bRequest == SET_ADDRESS) 
 360:	35 30       	cpi	r19, 0x05	; 5
 362:	61 f4       	brne	.+24     	; 0x37c <__vector_11+0x146>



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
 364:	8e ef       	ldi	r24, 0xFE	; 254
 366:	80 93 e8 00 	sts	0x00E8, r24
}



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
 36a:	80 91 e8 00 	lds	r24, 0x00E8
 36e:	80 ff       	sbrs	r24, 0
 370:	fc cf       	rjmp	.-8      	; 0x36a <__vector_11+0x134>
	// ******** Set ADDRESS **********************		
	if (bRequest == SET_ADDRESS) 
		{
		usb_send_in();
		usb_wait_in_ready();
		UDADDR = wValue | (1<<ADDEN);
 372:	8a 2f       	mov	r24, r26
 374:	80 68       	ori	r24, 0x80	; 128
 376:	80 93 e3 00 	sts	0x00E3, r24
 37a:	ab c0       	rjmp	.+342    	; 0x4d2 <__vector_11+0x29c>
		return;
		}

	// ******** Set Configuration **********************		
	if (bRequest == SET_CONFIGURATION && bmRequestType == 0) 
 37c:	39 30       	cpi	r19, 0x09	; 9
 37e:	51 f5       	brne	.+84     	; 0x3d4 <__vector_11+0x19e>
 380:	44 23       	and	r20, r20
 382:	09 f0       	breq	.+2      	; 0x386 <__vector_11+0x150>
 384:	50 c0       	rjmp	.+160    	; 0x426 <__vector_11+0x1f0>
		{
		usb_configuration = wValue;
 386:	a0 93 01 01 	sts	0x0101, r26



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
 38a:	8e ef       	ldi	r24, 0xFE	; 254
 38c:	80 93 e8 00 	sts	0x00E8, r24
 390:	8d ed       	ldi	r24, 0xDD	; 221
 392:	90 e0       	ldi	r25, 0x00	; 0
 394:	21 e0       	ldi	r18, 0x01	; 1
		usb_configuration = wValue;
		usb_send_in();
		cfg = endpoint_config_table;
		for (i=1; i<5; i++) 
			{
			UENUM = i;
 396:	20 93 e9 00 	sts	0x00E9, r18
			en = pgm_read_byte(cfg++);
 39a:	fc 01       	movw	r30, r24
 39c:	01 96       	adiw	r24, 0x01	; 1
 39e:	e4 91       	lpm	r30, Z+
			UECONX = en;
 3a0:	e0 93 eb 00 	sts	0x00EB, r30
			if (en) 
 3a4:	ee 23       	and	r30, r30
 3a6:	69 f0       	breq	.+26     	; 0x3c2 <__vector_11+0x18c>
				{
				UECFG0X = pgm_read_byte(cfg++);
 3a8:	ac 01       	movw	r20, r24
 3aa:	4f 5f       	subi	r20, 0xFF	; 255
 3ac:	5f 4f       	sbci	r21, 0xFF	; 255
 3ae:	fc 01       	movw	r30, r24
 3b0:	84 91       	lpm	r24, Z+
 3b2:	80 93 ec 00 	sts	0x00EC, r24
				UECFG1X = pgm_read_byte(cfg++);
 3b6:	ca 01       	movw	r24, r20
 3b8:	01 96       	adiw	r24, 0x01	; 1
 3ba:	fa 01       	movw	r30, r20
 3bc:	34 91       	lpm	r19, Z+
 3be:	30 93 ed 00 	sts	0x00ED, r19
	if (bRequest == SET_CONFIGURATION && bmRequestType == 0) 
		{
		usb_configuration = wValue;
		usb_send_in();
		cfg = endpoint_config_table;
		for (i=1; i<5; i++) 
 3c2:	2f 5f       	subi	r18, 0xFF	; 255
 3c4:	25 30       	cpi	r18, 0x05	; 5
 3c6:	39 f7       	brne	.-50     	; 0x396 <__vector_11+0x160>
				{
				UECFG0X = pgm_read_byte(cfg++);
				UECFG1X = pgm_read_byte(cfg++);
				}
			}
		UERST = 0x1E;
 3c8:	8e e1       	ldi	r24, 0x1E	; 30
 3ca:	80 93 ea 00 	sts	0x00EA, r24
		UERST = 0;
 3ce:	10 92 ea 00 	sts	0x00EA, r1
 3d2:	7f c0       	rjmp	.+254    	; 0x4d2 <__vector_11+0x29c>
		return;
		}
	
	// ******** Get Configuratioin **********************		
	if (bRequest == GET_CONFIGURATION && bmRequestType == 0x80) 
 3d4:	38 30       	cpi	r19, 0x08	; 8
 3d6:	59 f4       	brne	.+22     	; 0x3ee <__vector_11+0x1b8>
 3d8:	40 38       	cpi	r20, 0x80	; 128
 3da:	29 f5       	brne	.+74     	; 0x426 <__vector_11+0x1f0>
}



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
 3dc:	80 91 e8 00 	lds	r24, 0x00E8
 3e0:	80 ff       	sbrs	r24, 0
 3e2:	fc cf       	rjmp	.-8      	; 0x3dc <__vector_11+0x1a6>
	
	// ******** Get Configuratioin **********************		
	if (bRequest == GET_CONFIGURATION && bmRequestType == 0x80) 
		{
		usb_wait_in_ready();
		UEDATX = usb_configuration;
 3e4:	80 91 01 01 	lds	r24, 0x0101
 3e8:	80 93 f1 00 	sts	0x00F1, r24
 3ec:	6b c0       	rjmp	.+214    	; 0x4c4 <__vector_11+0x28e>
		usb_send_in();
		return;
		}

	// ******** GET Status **********************		
	if (bRequest == GET_STATUS) 
 3ee:	33 23       	and	r19, r19
 3f0:	d1 f4       	brne	.+52     	; 0x426 <__vector_11+0x1f0>
}



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
 3f2:	80 91 e8 00 	lds	r24, 0x00E8
 3f6:	80 ff       	sbrs	r24, 0
 3f8:	fc cf       	rjmp	.-8      	; 0x3f2 <__vector_11+0x1bc>
	// ******** GET Status **********************		
	if (bRequest == GET_STATUS) 
		{
		usb_wait_in_ready();
		i = 0;
		if (bmRequestType == 0x82) 
 3fa:	42 38       	cpi	r20, 0x82	; 130
 3fc:	11 f0       	breq	.+4      	; 0x402 <__vector_11+0x1cc>
 3fe:	80 e0       	ldi	r24, 0x00	; 0
 400:	0d c0       	rjmp	.+26     	; 0x41c <__vector_11+0x1e6>
			{
			UENUM = wIndex;
 402:	60 93 e9 00 	sts	0x00E9, r22
			if (UECONX & (1<<STALLRQ)) i = 1;
 406:	80 91 eb 00 	lds	r24, 0x00EB
 40a:	90 e0       	ldi	r25, 0x00	; 0
 40c:	25 e0       	ldi	r18, 0x05	; 5
 40e:	96 95       	lsr	r25
 410:	87 95       	ror	r24
 412:	2a 95       	dec	r18
 414:	e1 f7       	brne	.-8      	; 0x40e <__vector_11+0x1d8>
 416:	81 70       	andi	r24, 0x01	; 1
			UENUM = 0;
 418:	10 92 e9 00 	sts	0x00E9, r1
			}
		UEDATX = i;
 41c:	80 93 f1 00 	sts	0x00F1, r24
		UEDATX = 0;
 420:	10 92 f1 00 	sts	0x00F1, r1
 424:	4f c0       	rjmp	.+158    	; 0x4c4 <__vector_11+0x28e>
			}
		}
*/
	// ******** RAW Interface **********************		

	if (wIndex == RAWHID_INTERFACE) 
 426:	67 2b       	or	r22, r23
 428:	09 f0       	breq	.+2      	; 0x42c <__vector_11+0x1f6>
 42a:	50 c0       	rjmp	.+160    	; 0x4cc <__vector_11+0x296>
		{
		// ****** GET REPORT ***********************
	
		if (bmRequestType == 0xA1 && bRequest == HID_GET_REPORT) 
 42c:	41 3a       	cpi	r20, 0xA1	; 161
 42e:	29 f5       	brne	.+74     	; 0x47a <__vector_11+0x244>
 430:	31 30       	cpi	r19, 0x01	; 1
 432:	09 f0       	breq	.+2      	; 0x436 <__vector_11+0x200>
 434:	4b c0       	rjmp	.+150    	; 0x4cc <__vector_11+0x296>
			{
			// wait for host ready for IN packet
			do 
				{
				i = UEINTX;
 436:	80 91 e8 00 	lds	r24, 0x00E8
				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
 43a:	28 2f       	mov	r18, r24
 43c:	30 e0       	ldi	r19, 0x00	; 0
 43e:	c9 01       	movw	r24, r18
 440:	85 70       	andi	r24, 0x05	; 5
 442:	90 70       	andi	r25, 0x00	; 0
 444:	89 2b       	or	r24, r25
 446:	b9 f3       	breq	.-18     	; 0x436 <__vector_11+0x200>
			if (i & (1<<RXOUTI)) return;	// abort
 448:	22 fd       	sbrc	r18, 2
 44a:	43 c0       	rjmp	.+134    	; 0x4d2 <__vector_11+0x29c>
			
			if (!(PINF & (1<<1))) wLength=64; else wLength=0;	// read state of button . if not pushed then read from 0 to 63 ,else from 64 to 127
 44c:	79 9b       	sbis	0x0f, 1	; 15
 44e:	03 c0       	rjmp	.+6      	; 0x456 <__vector_11+0x220>
 450:	60 e0       	ldi	r22, 0x00	; 0
 452:	70 e0       	ldi	r23, 0x00	; 0
 454:	02 c0       	rjmp	.+4      	; 0x45a <__vector_11+0x224>
 456:	60 e4       	ldi	r22, 0x40	; 64
 458:	70 e0       	ldi	r23, 0x00	; 0
			eeprom_read_block((void*)&buffer,(void*)wLength,RAWHID_TX_SIZE);	// read block
 45a:	82 e0       	ldi	r24, 0x02	; 2
 45c:	91 e0       	ldi	r25, 0x01	; 1
 45e:	40 e4       	ldi	r20, 0x40	; 64
 460:	50 e0       	ldi	r21, 0x00	; 0
 462:	0e 94 7c 02 	call	0x4f8	; 0x4f8 <__eerd_block_m32u4>
 466:	e2 e0       	ldi	r30, 0x02	; 2
 468:	f1 e0       	ldi	r31, 0x01	; 1
			// send IN packet
			for (len=0;len < (RAWHID_TX_SIZE ); len++) UEDATX=buffer[len]; // transfer data from buffer to USB trnsmit buffer
 46a:	81 91       	ld	r24, Z+
 46c:	80 93 f1 00 	sts	0x00F1, r24
 470:	81 e0       	ldi	r24, 0x01	; 1
 472:	e2 34       	cpi	r30, 0x42	; 66
 474:	f8 07       	cpc	r31, r24
 476:	c9 f7       	brne	.-14     	; 0x46a <__vector_11+0x234>
 478:	25 c0       	rjmp	.+74     	; 0x4c4 <__vector_11+0x28e>
			return;
			}
	
		// ****** GET REPORT ***********************

		if (bmRequestType == 0x21 && bRequest == HID_SET_REPORT) 
 47a:	41 32       	cpi	r20, 0x21	; 33
 47c:	39 f5       	brne	.+78     	; 0x4cc <__vector_11+0x296>
 47e:	39 30       	cpi	r19, 0x09	; 9
 480:	29 f5       	brne	.+74     	; 0x4cc <__vector_11+0x296>


// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
static inline void usb_wait_receive_out(void){while (!(UEINTX & (1<<RXOUTI))) ;}
 482:	80 91 e8 00 	lds	r24, 0x00E8
 486:	82 ff       	sbrs	r24, 2
 488:	fc cf       	rjmp	.-8      	; 0x482 <__vector_11+0x24c>
 48a:	e2 e0       	ldi	r30, 0x02	; 2
 48c:	f1 e0       	ldi	r31, 0x01	; 1
		// ****** GET REPORT ***********************

		if (bmRequestType == 0x21 && bRequest == HID_SET_REPORT) 
			{
			usb_wait_receive_out();
			for (len=0;len < (RAWHID_RX_SIZE );len++) buffer[len] = UEDATX; // read data from PC to buffer in size 64 bytes..
 48e:	80 91 f1 00 	lds	r24, 0x00F1
 492:	81 93       	st	Z+, r24
 494:	81 e0       	ldi	r24, 0x01	; 1
 496:	e2 34       	cpi	r30, 0x42	; 66
 498:	f8 07       	cpc	r31, r24
 49a:	c9 f7       	brne	.-14     	; 0x48e <__vector_11+0x258>
			if (!(PINF & (1<<1))) wLength=64; else wLength=0;	// read state of button . if not pushed then read from 0 to 63 ,else from 64 to 127
 49c:	79 9b       	sbis	0x0f, 1	; 15
 49e:	03 c0       	rjmp	.+6      	; 0x4a6 <__vector_11+0x270>
 4a0:	60 e0       	ldi	r22, 0x00	; 0
 4a2:	70 e0       	ldi	r23, 0x00	; 0
 4a4:	02 c0       	rjmp	.+4      	; 0x4aa <__vector_11+0x274>
 4a6:	60 e4       	ldi	r22, 0x40	; 64
 4a8:	70 e0       	ldi	r23, 0x00	; 0
			eeprom_write_block((void*)&buffer,(void*)wLength,RAWHID_TX_SIZE);
 4aa:	82 e0       	ldi	r24, 0x02	; 2
 4ac:	91 e0       	ldi	r25, 0x01	; 1
 4ae:	40 e4       	ldi	r20, 0x40	; 64
 4b0:	50 e0       	ldi	r21, 0x00	; 0
 4b2:	0e 94 8c 02 	call	0x518	; 0x518 <__eewr_block_m32u4>

// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
static inline void usb_wait_receive_out(void){while (!(UEINTX & (1<<RXOUTI))) ;}
static inline void usb_ack_out(void){	UEINTX = ~(1<<RXOUTI);}
 4b6:	8b ef       	ldi	r24, 0xFB	; 251
 4b8:	80 93 e8 00 	sts	0x00E8, r24
}



// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void){	while (!(UEINTX & (1<<TXINI))) ;}
 4bc:	80 91 e8 00 	lds	r24, 0x00E8
 4c0:	80 ff       	sbrs	r24, 0
 4c2:	fc cf       	rjmp	.-8      	; 0x4bc <__vector_11+0x286>
static inline void usb_send_in(void){UEINTX = ~(1<<TXINI);}
 4c4:	8e ef       	ldi	r24, 0xFE	; 254
 4c6:	80 93 e8 00 	sts	0x00E8, r24
 4ca:	03 c0       	rjmp	.+6      	; 0x4d2 <__vector_11+0x29c>
			}

		}

	}
UECONX = (1<<STALLRQ) | (1<<EPEN);	// stall
 4cc:	81 e2       	ldi	r24, 0x21	; 33
 4ce:	80 93 eb 00 	sts	0x00EB, r24
}
 4d2:	ff 91       	pop	r31
 4d4:	ef 91       	pop	r30
 4d6:	bf 91       	pop	r27
 4d8:	af 91       	pop	r26
 4da:	9f 91       	pop	r25
 4dc:	8f 91       	pop	r24
 4de:	7f 91       	pop	r23
 4e0:	6f 91       	pop	r22
 4e2:	5f 91       	pop	r21
 4e4:	4f 91       	pop	r20
 4e6:	3f 91       	pop	r19
 4e8:	2f 91       	pop	r18
 4ea:	1f 91       	pop	r17
 4ec:	0f 91       	pop	r16
 4ee:	0f 90       	pop	r0
 4f0:	0f be       	out	0x3f, r0	; 63
 4f2:	0f 90       	pop	r0
 4f4:	1f 90       	pop	r1
 4f6:	18 95       	reti

000004f8 <__eerd_block_m32u4>:
 4f8:	dc 01       	movw	r26, r24
 4fa:	cb 01       	movw	r24, r22

000004fc <__eerd_blraw_m32u4>:
 4fc:	fc 01       	movw	r30, r24
 4fe:	f9 99       	sbic	0x1f, 1	; 31
 500:	fe cf       	rjmp	.-4      	; 0x4fe <__eerd_blraw_m32u4+0x2>
 502:	06 c0       	rjmp	.+12     	; 0x510 <__eerd_blraw_m32u4+0x14>
 504:	f2 bd       	out	0x22, r31	; 34
 506:	e1 bd       	out	0x21, r30	; 33
 508:	f8 9a       	sbi	0x1f, 0	; 31
 50a:	31 96       	adiw	r30, 0x01	; 1
 50c:	00 b4       	in	r0, 0x20	; 32
 50e:	0d 92       	st	X+, r0
 510:	41 50       	subi	r20, 0x01	; 1
 512:	50 40       	sbci	r21, 0x00	; 0
 514:	b8 f7       	brcc	.-18     	; 0x504 <__eerd_blraw_m32u4+0x8>
 516:	08 95       	ret

00000518 <__eewr_block_m32u4>:
 518:	dc 01       	movw	r26, r24
 51a:	cb 01       	movw	r24, r22
 51c:	03 c0       	rjmp	.+6      	; 0x524 <__eewr_block_m32u4+0xc>
 51e:	2d 91       	ld	r18, X+
 520:	0e 94 97 02 	call	0x52e	; 0x52e <__eewr_r18_m32u4>
 524:	41 50       	subi	r20, 0x01	; 1
 526:	50 40       	sbci	r21, 0x00	; 0
 528:	d0 f7       	brcc	.-12     	; 0x51e <__eewr_block_m32u4+0x6>
 52a:	08 95       	ret

0000052c <__eewr_byte_m32u4>:
 52c:	26 2f       	mov	r18, r22

0000052e <__eewr_r18_m32u4>:
 52e:	f9 99       	sbic	0x1f, 1	; 31
 530:	fe cf       	rjmp	.-4      	; 0x52e <__eewr_r18_m32u4>
 532:	1f ba       	out	0x1f, r1	; 31
 534:	92 bd       	out	0x22, r25	; 34
 536:	81 bd       	out	0x21, r24	; 33
 538:	20 bd       	out	0x20, r18	; 32
 53a:	0f b6       	in	r0, 0x3f	; 63
 53c:	f8 94       	cli
 53e:	fa 9a       	sbi	0x1f, 2	; 31
 540:	f9 9a       	sbi	0x1f, 1	; 31
 542:	0f be       	out	0x3f, r0	; 63
 544:	01 96       	adiw	r24, 0x01	; 1
 546:	08 95       	ret

00000548 <_exit>:
 548:	f8 94       	cli

0000054a <__stop_program>:
 54a:	ff cf       	rjmp	.-2      	; 0x54a <__stop_program>
