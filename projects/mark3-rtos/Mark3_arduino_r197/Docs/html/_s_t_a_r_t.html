<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Mark3 Realtime Kernel: Getting Started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mark3 Realtime Kernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_s_t_a_r_t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Getting Started </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="START0"></a>
Kernel Setup</h1>
<p>This section details the process of defining threads, initializing the kernel, and adding threads to the scheduler.</p>
<p>If you're at all familiar with real-time operating systems, then these setup and initialization steps should be familiar. I've tried very hard to ensure that as much of the heavy lifting is hidden from the user, so that only the bare minimum of calls are required to get things started.</p>
<p>The examples presented in this chapter are real, working examples taken from the ATmega328p port.</p>
<p>First, you'll need to create the necessary data structures and functions for the threads:</p>
<ol type="1">
<li>Create a <a class="el" href="class_thread.html" title="Object providing fundamental multitasking support in the kernel. ">Thread</a> object for all of the "root" or "initial" tasks.</li>
<li>Allocate stacks for each of the Threads</li>
<li>Define an entry-point function for each <a class="el" href="class_thread.html" title="Object providing fundamental multitasking support in the kernel. ">Thread</a></li>
</ol>
<p>This is shown in the example code below:</p>
<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="thread_8h.html">thread.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="kernel_8h.html">kernel.h</a>&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//1) Create a thread object for all of the &quot;root&quot; or &quot;initial&quot; tasks</span></div>
<div class="line"><span class="keyword">static</span> <a class="code" href="class_thread.html">Thread</a> AppThread;</div>
<div class="line"><span class="keyword">static</span> <a class="code" href="class_thread.html">Thread</a> IdleThread;</div>
<div class="line"></div>
<div class="line"><span class="comment">//2) Allocate stacks for each thread</span></div>
<div class="line"><span class="preprocessor">#define STACK_SIZE_APP      (192)</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define STACK_SIZE_IDLE     (128)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="keyword">static</span> K_UCHAR aucAppStack[STACK_SIZE_APP];</div>
<div class="line"><span class="keyword">static</span> K_UCHAR aucIdleStack[STACK_SIZE_IDLE];</div>
<div class="line"></div>
<div class="line"><span class="comment">//3) Define entry point functions for each thread</span></div>
<div class="line"><span class="keywordtype">void</span> AppThread(<span class="keywordtype">void</span>);</div>
<div class="line"><span class="keywordtype">void</span> IdleThread(<span class="keywordtype">void</span>);</div>
</div><!-- fragment --><p>Next, we'll need to add the required kernel initialization code to main. This consists of running the <a class="el" href="class_kernel.html" title="Class that encapsulates all of the kernel startup functions. ">Kernel</a>'s init routine, initializing all of the threads we defined, adding the threads to the scheduler, and finally calling <a class="el" href="class_kernel.html#a4ebb7e08217fff17743e1b710f6bef4d" title="Start the kernel; function never returns. ">Kernel::Start()</a>, which transfers control of the system to the RTOS.</p>
<p>These steps are illustrated in the following example.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{       </div>
<div class="line">    <span class="comment">//1) Initialize the kernel prior to use</span></div>
<div class="line">    <a class="code" href="class_kernel.html#a82b9b509e35fb8e1c2b700abee9ed2db">Kernel::Init</a>();             <span class="comment">// MUST be before other kernel ops</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">//2) Initialize all of the threads we&#39;ve defined</span></div>
<div class="line">    AppThread.<a class="code" href="class_thread.html#ad90ade14d5797bc610ce60cb2b94094e">Init</a>( aucAppStack,        <span class="comment">// Pointer to the stack</span></div>
<div class="line">                    STACK_SIZE_APP,     <span class="comment">// Size of the stack</span></div>
<div class="line">                    1,          <span class="comment">// Thread priority                        </span></div>
<div class="line">                    (<span class="keywordtype">void</span>*)AppEntry,    <span class="comment">// Entry function</span></div>
<div class="line">                    NULL );             <span class="comment">// Entry function argument</span></div>
<div class="line"></div>
<div class="line">    IdleThread.<a class="code" href="class_thread.html#ad90ade14d5797bc610ce60cb2b94094e">Init</a>( aucIdleStack,      <span class="comment">// Pointer to the stack</span></div>
<div class="line">                     STACK_SIZE_IDLE,   <span class="comment">// Size of the stack</span></div>
<div class="line">                     0,         <span class="comment">// Thread priority</span></div>
<div class="line">                     (<span class="keywordtype">void</span>*)IdleEntry,  <span class="comment">// Entry function</span></div>
<div class="line">                     NULL );        <span class="comment">// Entry function argument</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">//3) Add the threads to the scheduler</span></div>
<div class="line">    AppThread.<a class="code" href="class_thread.html#a0dd76fc031edc105e87acdb6de28c1e5">Start</a>();          <span class="comment">// Actively schedule the threads</span></div>
<div class="line">    IdleThread.<a class="code" href="class_thread.html#a0dd76fc031edc105e87acdb6de28c1e5">Start</a>();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">//4) Give control of the system to the kernel</span></div>
<div class="line">    <a class="code" href="class_kernel.html#a4ebb7e08217fff17743e1b710f6bef4d">Kernel::Start</a>();            <span class="comment">// Start the kernel!</span></div>
<div class="line">}    </div>
</div><!-- fragment --><p>Not much to it, is there? There are a few noteworthy points in this code, though.</p>
<p>In order for the kernel to work properly, a system must always contain an idle thread; that is, a thread at priority level 0 that never blocks. This thread is responsible for performing any of the low-level power management on the CPU in order to maximize battery life in an embedded device. The idle thread must also never block, and it must never exit. Either of these operations will cause undefined behavior in the system.</p>
<p>The App thread is at a priority level greater-than 0. This ensures that as long as the App thread has something useful to do, it will be given control of the CPU. In this case, if the app thread blocks, control will be given back to the Idle thread, which will put the CPU into a power-saving mode until an interrupt occurs.</p>
<p>Stack sizes must be large enough to accommodate not only the requirements of the threads, but also the requirements of interrupts - up to the maximum interrupt-nesting level used. Stack overflows are super-easy to run into in an embedded system; if you encounter strange and unexplained behavior in your code, chances are good that one of your threads is blowing its stack.</p>
<h1><a class="anchor" id="THREADS"></a>
Threads</h1>
<p>Mark3 Threads act as independent tasks in the system. While they share the same address-space, global data, device-drivers, and system peripherals, each thread has its own set of CPU registers and stack, collectively known as the thread's <b>context</b>. The context is what allows the RTOS kernel to rapidly switch between threads at a high rate, giving the illusion that multiple things are happening in a system, when really, only one thread is executing at a time.</p>
<h2><a class="anchor" id="TH_SETUP"></a>
Thread Setup</h2>
<p>Each instance of the <a class="el" href="class_thread.html" title="Object providing fundamental multitasking support in the kernel. ">Thread</a> class represents a thread, its stack, its CPU context, and all of the state and metadata maintained by the kernel. Before a <a class="el" href="class_thread.html" title="Object providing fundamental multitasking support in the kernel. ">Thread</a> will be scheduled to run, it must first be initialized with the necessary configuration data.</p>
<p>The Init function gives the user the opportunity to set the stack, stack size, thread priority, entry-point function, entry-function argument, and round-robin time quantum:</p>
<p><a class="el" href="class_thread.html" title="Object providing fundamental multitasking support in the kernel. ">Thread</a> stacks are pointers to blobs of memory (usually K_CHAR arrays) carved out of the system's address space. Each thread must have a stack defined that's large enough to handle not only the requirements of local variables in the thread's code path, but also the maximum depth of the ISR stack.</p>
<p>Priorities should be chosen carefully such that the shortest tasks with the most strict determinism requirements are executed first - and are thus located in the highest priorities. Tasks that take the longest to execute (and require the least degree of responsiveness) must occupy the lower thread priorities. The idle thread must be the only thread occupying the lowest priority level.</p>
<p>The thread quantum only aplies when there are multiple threads in the ready queue at the same priority level. This interval is used to kick-off a timer that will cycle execution between the threads in the priority list so that they each get a fair chance to execute.</p>
<p>The entry function is the function that the kernel calls first when the thread instance is first started. Entry functions have at most one argument - a pointer to a data-object specified by the user during initialization.</p>
<p>An example thread initailization is shown below:</p>
<div class="fragment"><div class="line"><a class="code" href="class_thread.html">Thread</a> clMyThread;</div>
<div class="line">K_UCHAR aucStack[192];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> AppEntry(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">while</span>(1)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Do something!</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">...</div>
<div class="line">{    </div>
<div class="line">    clMyThread.<a class="code" href="class_thread.html#ad90ade14d5797bc610ce60cb2b94094e">Init</a>(aucStack,    <span class="comment">// Pointer to the stack to use by this thread</span></div>
<div class="line">                    192,             <span class="comment">// Size of the stack in bytes</span></div>
<div class="line">                    1,       <span class="comment">// Thread priority (0 = idle, 7 = max)</span></div>
<div class="line">                    (<span class="keywordtype">void</span>*)AppEntry, <span class="comment">// Function where the thread starts executing</span></div>
<div class="line">                    NULL );          <span class="comment">// Argument passed into the entry function</span></div>
<div class="line">                    </div>
<div class="line">}</div>
</div><!-- fragment --><p>Once a thread has been initialized, it can be added to the scheduler by calling:</p>
<div class="fragment"><div class="line">clMyThread.<a class="code" href="class_thread.html#a0dd76fc031edc105e87acdb6de28c1e5">Start</a>();</div>
</div><!-- fragment --><p>The thread will be placed into the <a class="el" href="class_scheduler.html" title="Priority-based round-robin Thread scheduling, using ThreadLists for housekeeping. ...">Scheduler</a>'s queue at the designated priority, where it will wait its turn for execution.</p>
<h2><a class="anchor" id="TH_ENTRY"></a>
Entry Functions</h2>
<p>Mark3 Threads should not run-to-completion - they should execute as infinite loops that perform a series of tasks, appropriately partitioned to provide the responsiveness characteristics desired in the system.</p>
<p>The most basic <a class="el" href="class_thread.html" title="Object providing fundamental multitasking support in the kernel. ">Thread</a> loop is shown below:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_thread.html">Thread</a>( <span class="keywordtype">void</span> *param )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">while</span>(1)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Do Something</span></div>
<div class="line">    }    </div>
<div class="line">}</div>
</div><!-- fragment --><p>Threads can interact with eachother in the system by means of synchronization objects (<a class="el" href="class_semaphore.html" title="Counting semaphore, based on BlockingObject base class. ">Semaphore</a>), mutual-exclusion objects (<a class="el" href="class_mutex.html" title="Mutual-exclusion locks, based on BlockingObject. ">Mutex</a>), Inter-process messaging (<a class="el" href="class_message_queue.html" title="List of messages, used as the channel for sending and receiving messages between threads. ">MessageQueue</a>), and timers (<a class="el" href="class_timer.html" title="Timer - an event-driven execution context based on a specified time interval. ">Timer</a>).</p>
<p>Threads can suspend their own execution for a predetermined period of time by using the static <a class="el" href="class_thread.html#a4e01fcd51057da0eb6d60b77b533e4da" title="Put the thread to sleep for the specified time (in milliseconds). ">Thread::Sleep()</a> method. Calling this will block the <a class="el" href="class_thread.html" title="Object providing fundamental multitasking support in the kernel. ">Thread</a>'s executin until the amount of time specified has ellapsed. Upon expiry, the thread will be placed back into the ready queue for its priority level, where it awaits its next turn to run.</p>
<h1><a class="anchor" id="TIMERS"></a>
Timers</h1>
<p><a class="el" href="class_timer.html" title="Timer - an event-driven execution context based on a specified time interval. ">Timer</a> objects are used to trigger callback events periodic or on a one-shot (alarm) basis.</p>
<p>While extremely simple to use, they provide one of the most powerful execution contexts in the system. The timer callbacks execute from within the timer callback ISR in an interrupt-enabled context. As such, timer callbacks are considered higher-priority than any thread in the system, but lower priority than other interrupts. Care must be taken to ensure that timer callbacks execute as quickly as possible to minimize the impact of processing on the throughput of tasks in the system. Wherever possible, heavy-lifting should be deferred to the threads by way of semaphores or messages.</p>
<p>Below is an example showing how to start a periodic system timer which will trigger every second:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <a class="code" href="class_timer.html">Timer</a> clTimer;</div>
<div class="line">    clTimer.<a class="code" href="class_timer.html#ae2ada8383290c09b3101be48f7e0016e">Init</a>();</div>
<div class="line">    </div>
<div class="line">    clTimer.<a class="code" href="class_timer.html#a0132e541cdf7c989de72668f1e569332">Start</a>( 1000,              </div>
<div class="line">                 1,                   </div>
<div class="line">                 MyCallback,          </div>
<div class="line">                 (<span class="keywordtype">void</span>*)&amp;my_data );   </div>
<div class="line">                 </div>
<div class="line">    ... <span class="comment">// Keep doing work in the thread</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Callback function, executed from the timer-expiry context.</span></div>
<div class="line"><span class="keywordtype">void</span> MyCallBack( <a class="code" href="class_thread.html">Thread</a> *pclOwner_, <span class="keywordtype">void</span> *pvData_ )</div>
<div class="line">{</div>
<div class="line">    LED.Flash(); <span class="comment">// Flash an LED.</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="SEM"></a>
Semaphores</h1>
<p>Semaphores are used to synchronized execution of threads based on the availability (and quantity) of application-specific resources in the system. They are extremely useful for solving producer-consumer problems, and are the method-of-choice for creating efficient, low latency systems, where ISRs post semaphores that are handled from within the context of individual threads. (Yes, Semaphores can be posted - but not pended - from the interrupt context).</p>
<p>The following is an example of the producer-consumer usage of a binary semaphore:</p>
<div class="fragment"><div class="line"><a class="code" href="class_semaphore.html">Semaphore</a> clSemaphore; <span class="comment">// Declare a semaphore shared between a producer and a consumer thread.</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> Producer()</div>
<div class="line">{</div>
<div class="line">    clSemaphore.<a class="code" href="class_semaphore.html#a3a46f5aa647c2fa69e1dbdab315e0ebe">Init</a>(0, 1);  </div>
<div class="line">    <span class="keywordflow">while</span>(1)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Do some work, create something to be consumed</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Post a semaphore, allowing another thread to consume the data</span></div>
<div class="line">        clSemaphore.<a class="code" href="class_semaphore.html#a1992c8b46527c96756ba6d9a1c754715">Post</a>();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> Consumer()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Assumes semaphore initialized before use...</span></div>
<div class="line">    While(1)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Wait for new data from the producer thread</span></div>
<div class="line">        clSemaphore.<a class="code" href="class_semaphore.html#ae6e5655b3ab1ad7054cd03c19f2156f2">Pend</a>();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Consume the data!</span></div>
<div class="line">    }</div>
<div class="line">}    </div>
</div><!-- fragment --><p>And an example of using semaphores from the ISR context to perform event- driven processing.</p>
<div class="fragment"><div class="line"><a class="code" href="class_semaphore.html">Semaphore</a> clSemaphore;</div>
<div class="line"></div>
<div class="line">__interrupt__ MyISR()</div>
<div class="line">{</div>
<div class="line">    clSemaphore.<a class="code" href="class_semaphore.html#a1992c8b46527c96756ba6d9a1c754715">Post</a>(); <span class="comment">// Post the interrupt.  Lightweight when uncontested.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> MyThread()</div>
<div class="line">{</div>
<div class="line">    clSemaphore.<a class="code" href="class_semaphore.html#a3a46f5aa647c2fa69e1dbdab315e0ebe">Init</a>(0, 1); <span class="comment">// Ensure this is initialized before the MyISR interrupt is enabled.</span></div>
<div class="line">    <span class="keywordflow">while</span>(1)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Wait until we get notification from the interrupt</span></div>
<div class="line">        clSemaphore.<a class="code" href="class_semaphore.html#ae6e5655b3ab1ad7054cd03c19f2156f2">Pend</a>();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Interrupt has fired, do the necessary work in this thread&#39;s context</span></div>
<div class="line">        HeavyLifting();</div>
<div class="line">    }    </div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="MUT"></a>
Mutexes</h1>
<p>Mutexes (Mutual exclusion objects) are provided as a means of creating "protected sections" around a particular resource, allowing for access of these objects to be serialized. Only one thread can hold the mutex at a time - other threads have to wait until the region is released by the owner thread before they can take their turn operating on the protected resource. Note that mutexes can only be owned by threads - they are not available to other contexts (i.e. interrupts). Calling the mutex APIs from an interrupt will cause catastrophic system failures.</p>
<p>Note that these objects are also not recursive- that is, the owner thread can not attempt to claim a mutex more than once.</p>
<p>Prioritiy inheritence is provided with these objects as a means to avoid prioritiy inversions. Whenever a thread at a priority than the mutex owner blocks on a mutex, the priority of the current thread is boosted to the highest-priority waiter to ensure that other tasks at intermediate priorities cannot artificically prevent progress from being made.</p>
<p><a class="el" href="class_mutex.html" title="Mutual-exclusion locks, based on BlockingObject. ">Mutex</a> objects are very easy to use, as there are only three operations supported: Initialize, Claim and Release. An example is shown below.</p>
<div class="fragment"><div class="line"><a class="code" href="class_mutex.html">Mutex</a> clMutex;  <span class="comment">// Create a mutex globally.</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> Init()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Initialize the mutex before use.</span></div>
<div class="line">    clMutex.<a class="code" href="class_mutex.html#a98d244451f2bebbcf1f3b3f822638083">Init</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Some function called from a thread</span></div>
<div class="line"><span class="keywordtype">void</span> Thread1Function()</div>
<div class="line">{</div>
<div class="line">    clMutex.<a class="code" href="class_mutex.html#ac879e02dfbd2b9d665af7581ba8dde29">Claim</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Once the mutex is owned, no other thread can </span></div>
<div class="line">    <span class="comment">// enter a block protect by the same mutex</span></div>
<div class="line"></div>
<div class="line">    my_protected_resource.do_something();</div>
<div class="line">    my_protected_resource.do_something_else();</div>
<div class="line"></div>
<div class="line">    clMutex.<a class="code" href="class_mutex.html#aac1f1ce8590239373e84782126711b83">Release</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Some function called from another thread</span></div>
<div class="line"><span class="keywordtype">void</span> Thread2Function()</div>
<div class="line">{</div>
<div class="line">    clMutex.<a class="code" href="class_mutex.html#ac879e02dfbd2b9d665af7581ba8dde29">Claim</a>();</div>
<div class="line">            </div>
<div class="line">    <span class="comment">// Once the mutex is owned, no other thread can </span></div>
<div class="line">    <span class="comment">// enter a block protect by the same mutex</span></div>
<div class="line"></div>
<div class="line">    my_protected_resource.do_something();</div>
<div class="line">    my_protected_resource.do_different_things();</div>
<div class="line">    </div>
<div class="line">    clMutex.<a class="code" href="class_mutex.html#aac1f1ce8590239373e84782126711b83">Release</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="EVF"></a>
Event Flags</h1>
<p>Event Flags are another synchronization object, conceptually similar to a semaphore.</p>
<p>Unlike a semaphore, however, the condition on which threads are unblocked is determined by a more complex set of rules. Each Event Flag object contains a 16-bit field, and threads block, waiting for combinations of bits within this field to become set.</p>
<p>A thread can wait on any pattern of bits from this field to be set, and any number of threads can wait on any number of different patterns. Threads can wait on a single bit, multiple bits, or bits from within a subset of bits within the field.</p>
<p>As a result, setting a single value in the flag can result in any number of threads becoming unblocked simultaneously. This mechanism is extremely powerful, allowing for all sorts of complex, yet efficient, thread synchronization schemes that can be created using a single shared object.</p>
<p>Note that Event Flags can be set from interrupts, but you cannot wait on an event flag from within an interrupt.</p>
<p>Examples demonstrating the use of event flags are shown below.</p>
<div class="fragment"><div class="line"><span class="comment">// Simple example showing a thread blocking on a multiple bits in the</span></div>
<div class="line"><span class="comment">// fields within an event flag.</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="class_event_flag.html">EventFlag</a> clEventFlag;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    clEventFlag.<a class="code" href="class_event_flag.html#a57860e16f01ca33e66bf03a6abca97f6">Init</a>(); <span class="comment">// Initialize event flag prior to use</span></div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> MyInterrupt()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Some interrupt corresponds to event 0x0020</span></div>
<div class="line">    clEventFlag.<a class="code" href="class_event_flag.html#a1d2aca0c447049d2215fab11c6be3ea9">Set</a>(0x0020);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> MyThreadFunc()</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordflow">while</span>(1)</div>
<div class="line">    {</div>
<div class="line">        ...</div>
<div class="line">        K_USHORT usWakeCondition;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Allow this thread to block on multiple flags</span></div>
<div class="line">        usWakeCondition = clEventFlag.<a class="code" href="class_event_flag.html#a12cde3afa132ff459a747d08115b738c">Wait</a>(0x00FF, EVENT_FLAG_ANY);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Clear the event condition that caused the thread to wake (in this case,</span></div>
<div class="line">        <span class="comment">// usWakeCondtion will equal 0x20 when triggered from the interrupt above)</span></div>
<div class="line">        clEventFlag.<a class="code" href="class_event_flag.html#a6be4275bdd6eab1961828b80472543d0">Clear</a>(usWakeCondition);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// &lt;do something&gt;</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="MSG"></a>
Messages</h1>
<p>Sending messages between threads is the key means of synchronizing access to data, and the primary mechanism to perform asynchronous data processing operations.</p>
<p>Sending a message consists of the following operations:</p>
<ul>
<li>Obtain a <a class="el" href="class_message.html" title="Class to provide message-based IPC services in the kernel. ">Message</a> object from the global message pool</li>
<li>Set the message data and event fields</li>
<li>Send the message to the destination message queue</li>
</ul>
<p>While receiving a message consists of the following steps:</p>
<ul>
<li>Wait for a messages in the destination message queue</li>
<li>Process the message data</li>
<li>Return the message back to the global message pool</li>
</ul>
<p>These operations, and the various data objects involved are discussed in more detail in the following section.</p>
<h2><a class="anchor" id="MSGO"></a>
Message Objects</h2>
<p><a class="el" href="class_message.html" title="Class to provide message-based IPC services in the kernel. ">Message</a> objects are used to communicate arbitrary data between threads in a safe and synchronous way.</p>
<p>The message object consists of an event code field and a data field. The event code is used to provide context to the message object, while the data field (essentially a void * data pointer) is used to provide a payload of data corresponding to the particular event.</p>
<p>Access to these fields is marshalled by accessors - the transmitting thread uses the SetData() and SetCode() methods to seed the data, while the receiving thread uses the GetData() and GetCode() methods to retrieve it.</p>
<p>By providing the data as a void data pointer instead of a fixed-size message, we achieve an unprecedented measure of simplicity and flexibility. Data can be either statically or dynamically allocated, and sized appropriately for the event without having to format and reformat data by both sending and receiving threads. The choices here are left to the user - and the kernel doesn't get in the way of efficiency.</p>
<p>It is worth noting that you can send messages to message queues from within ISR context. This helps maintain consistency, since the same APIs can be used to provide event-driven programming facilities throughout the whole of the OS.</p>
<h2><a class="anchor" id="MSGP"></a>
Global Message Pool</h2>
<p>To maintain efficiency in the messaging system (and to prevent over-allocation of data), a global pool of message objects is provided. The size of this message pool is specified in the implementation, and can be adjusted depending on the requirements of the target application as a compile-time option.</p>
<p>Allocating a message from the message pool is as simple as calling the <a class="el" href="class_global_message_pool.html#a1c3d7a90297854549d4a4580b627553b" title="Pop a message from the global queue, returning it to the user to be populated before sending by a tra...">GlobalMessagePool::Pop()</a> Method.</p>
<p>Messages are returned back to the <a class="el" href="class_global_message_pool.html#ae73d84b4818dfea46142ad2d699403d4" title="Return a previously-claimed message object back to the global queue. ">GlobalMessagePool::Push()</a> method once the message contents are no longer required.</p>
<p>One must be careful to ensure that discarded messages always are returned to the pool, otherwise a resource leak can occur, which may cripple the operating system's ability to pass data between threads.</p>
<h2><a class="anchor" id="MSGQ"></a>
Message Queues</h2>
<p><a class="el" href="class_message.html" title="Class to provide message-based IPC services in the kernel. ">Message</a> objects specify data with context, but do not specify where the messages will be sent. For this purpose we have a <a class="el" href="class_message_queue.html" title="List of messages, used as the channel for sending and receiving messages between threads. ">MessageQueue</a> object. Sending an object to a message queue involves calling the <a class="el" href="class_message_queue.html#a11e415ec9b7b776609875de94b76b588" title="Send a message object into this message queue. ">MessageQueue::Send()</a> method, passing in a pointer to the <a class="el" href="class_message.html" title="Class to provide message-based IPC services in the kernel. ">Message</a> object as an argument.</p>
<p>When a message is sent to the queue, the first thread blocked on the queue (as a result of calling the <a class="el" href="class_message_queue.html" title="List of messages, used as the channel for sending and receiving messages between threads. ">MessageQueue</a> Receive() method) will wake up, with a pointer to the <a class="el" href="class_message.html" title="Class to provide message-based IPC services in the kernel. ">Message</a> object returned.</p>
<p>It's worth noting that multiple threads can block on the same message queue, providing a means for multiple threads to share work in parallel.</p>
<h2><a class="anchor" id="MSGQS"></a>
Messaging Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Message queue object shared between threads</span></div>
<div class="line"><a class="code" href="class_message_queue.html">MessageQueue</a> clMsgQ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Function that initializes the shared message queue</span></div>
<div class="line"><span class="keywordtype">void</span> MsgQInit()</div>
<div class="line">{</div>
<div class="line">    clMsgQ.<a class="code" href="class_message_queue.html#a2e3d5b686824d4570e5eb2f30b94d657">Init</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Function called by one thread to send message data to </span></div>
<div class="line"><span class="comment">// another</span></div>
<div class="line"><span class="keywordtype">void</span> TxMessage()</div>
<div class="line">{   </div>
<div class="line">    <span class="comment">// Get a message, initialize its data</span></div>
<div class="line">    <a class="code" href="class_message.html">Message</a> *pclMesg = <a class="code" href="class_global_message_pool.html#a1c3d7a90297854549d4a4580b627553b">GlobalMessagePool::Pop</a>();</div>
<div class="line">    </div>
<div class="line">    pclMesg-&gt;<a class="code" href="class_message.html#a21ca7e296938a11fa9c5a3ec9f19efe7">SetCode</a>(0xAB);</div>
<div class="line">    pclMesg-&gt;<a class="code" href="class_message.html#a6f9711074ed367f13a42e8f4009e32a8">SetData</a>((<span class="keywordtype">void</span>*)some_data); </div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Send the data to the message queue</span></div>
<div class="line">    clMsgQ.<a class="code" href="class_message_queue.html#a11e415ec9b7b776609875de94b76b588">Send</a>(pclMesg);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Function called in the other thread to block until</span></div>
<div class="line"><span class="comment">// a message is received in the message queue.  </span></div>
<div class="line"><span class="keywordtype">void</span> RxMessage()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="class_message.html">Message</a> *pclMesg;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Block until we have a message in the queue</span></div>
<div class="line">    pclMesg = clMsgQ.<a class="code" href="class_message_queue.html#a4371acf2f7b0b28b28e83c072299b0ed">Receive</a>();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Do something with the data once the message is received</span></div>
<div class="line">    pclMesg-&gt;<a class="code" href="class_message.html#a1d4712509640a242d597ef581a1a152a">GetCode</a>();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Free the message once we&#39;re done with it.</span></div>
<div class="line">    <a class="code" href="class_global_message_pool.html#ae73d84b4818dfea46142ad2d699403d4">GlobalMessagePool::Push</a>(pclMesg);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="SLP"></a>
Sleep</h1>
<p>There are instances where it may be necessary for a thread to poll a resource, or wait a specific amount of time before proceeding to operate on a peripheral or volatile piece of data.</p>
<p>While the <a class="el" href="class_timer.html" title="Timer - an event-driven execution context based on a specified time interval. ">Timer</a> object is generally a better choice for performing time-sensitive operations (and certainly a better choice for periodic operations), the <a class="el" href="class_thread.html#a4e01fcd51057da0eb6d60b77b533e4da" title="Put the thread to sleep for the specified time (in milliseconds). ">Thread::Sleep()</a> method provides a convenient (and efficient) mechanism that allows for a thread to suspend its execution for a specified interval.</p>
<p>Note that when a thread is sleeping it is blocked, during which other threads can operate, or the system can enter its idle state.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> GetPeripheralData();</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> value;</div>
<div class="line">    <span class="comment">// The hardware manual for a peripheral specifies that</span></div>
<div class="line">    <span class="comment">// the &quot;foo()&quot; method will result in data being generated</span></div>
<div class="line">    <span class="comment">// that can be captured using the &quot;bar()&quot; method.</span></div>
<div class="line">    <span class="comment">// However, the value only becomes valid after 10ms</span></div>
<div class="line">    </div>
<div class="line">    peripheral.foo();   </div>
<div class="line">    <a class="code" href="class_thread.html#a4e01fcd51057da0eb6d60b77b533e4da">Thread::Sleep</a>(10);  <span class="comment">// Wait 10ms for data to become valid</span></div>
<div class="line">    value = peripheral.bar();</div>
<div class="line">    <span class="keywordflow">return</span> value;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="RR"></a>
Round-Robin Quantum</h1>
<p>Threads at the same thread priority are scheduled using a round-robin scheme. Each thread is given a timeslice (which can be configured) of which it shares time amongst ready threads in the group. Once a thread's timeslice has expired, the next thread in the priority group is chosen to run until its quantum has expired - the cycle continues over and over so long as each thread has work to be done.</p>
<p>By default, the round-robin interval is set at 4ms.</p>
<p>This value can be overridden by calling the thread's SetQuantum() with a new interval specified in milliseconds. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Mar 5 2015 22:35:13 for Mark3 Realtime Kernel by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
