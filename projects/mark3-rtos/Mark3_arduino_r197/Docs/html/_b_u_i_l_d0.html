<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Mark3 Realtime Kernel: Build System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mark3 Realtime Kernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_b_u_i_l_d0.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Build System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Mark3 is distributed with a recursive makefile build system, allowing the entire source tree to be built into a series of libraries with simple make commands.</p>
<p>The way the scripts work, every directory with a valid makefile is scanned, as well as all of its subdirectories. The build then generates binary components for all of the components it finds -libraries and executables. All libraries that are generated can then be imported into an application using the linker without having to copy-and-paste files on a module-by-module basis. Applications built during this process can then be loaded onto a device directly, without requiring a GUI-based IDE. As a result, Mark3 integrates well with 3rd party tools for continuous-integration and automated testing.</p>
<p>This modular framework allows for large volumes of libraries and binaries to be built at once - the default build script leverages this to build all of the examples and unit tests at once, linking against the pre-built kernel, services, and drivers. Whatever can be built as a library is built as a library, promoting reuse throughout the platform, and enabling Mark3 to be used as a platform, with an ecosystem of libraries, services, drivers and applications.</p>
<h1><a class="anchor" id="BUILDLAYOUT"></a>
Source Layout</h1>
<p>One key aspect of Mark3 is that system features are organized into their own separate modules. These modules are further grouped together into folders based on the type of features represented:</p>
<pre class="fragment">Root         Base folder, contains recursive makefiles for build system
    arduino      Arduino-specific headers and API documentation files
    bootloader   Mark3 Bootloader code for AVR microcontrollers
    build        Makefiles and device-configuraton data for various platforms
    docs         Documentation (including this)
    drivers      Device driver code for various supported devices
    example      Example applications
    fonts        Bitmap fonts converted from TTF, used by Mark3 graphics library
    kernel       Basic Mark3 Components (the focus of this manual)          
        cpu      CPU-specific porting code
    scripts      Scripts used to simplify build, documentation, and profiling
    services     Utility code and services, extended system features
    stage        Staging directory, where the build system places artifacts
    tests        Unit tests, written as C/C++ applications
    util         .net-based utils: font conversion, terminal, programmer, and configuration
</pre><h1><a class="anchor" id="BUILDKERNEL"></a>
Building the kernel</h1>
<p>The base.mak file determines how the kernel, drivers, and libraries are built, for what targets, and with what options. Most of these options can be copied directly from the options found in your IDE managed projects. Below is an overview of the main variables used to configure the build.</p>
<pre class="fragment">STAGE       - Location in the filesystem where the build output is stored
ROOT_DIR    - The location of the root source tree
ARCH        - The CPU architecture to build against
VARIANT     - The variant of the above CPU to target
TOOLCHAIN   - Which toolchain to build with (dependent on ARCH and VARIANT)
</pre><p>Build.mak contains the logic which is used to perform the recursive make in all directories. Unless you really know what you're doing, it's best to leave this as-is.</p>
<p>You must make sure that all required paths are set in your system environment variables so that they are accessible through from the command-line.</p>
<p>Once configured, you can build the source tree using the various make targets:</p>
<ul>
<li>make headers<ul>
<li>copy all headers in each module's /public subdirectory to the location specified by STAGE environment variable's ./inc subdirectory.</li>
</ul>
</li>
<li>make library<ul>
<li>regenerate all objects copy marked as libraries (i.e. the kernel + drivers). Resulting binaries are copied into STAGE's ./lib subdirectory.</li>
</ul>
</li>
<li>make binary<ul>
<li>build all executable projects in the root directory structure. In the default distribution, this includes the basic set of demos.</li>
</ul>
</li>
</ul>
<p>These steps are chained together automatically as part of the build.sh script found under the /scripts subdirectory. Running ./scripts/build.sh from the root of the embedded source directory will result in all headers being exported, libraries built, and applications built. This script will also default to building for atmega328p using GCC if none of the required environment variables have previously been configured.</p>
<p>To add new components to the recursive build system, simply add your code into a new folder beneath the root install location.</p>
<p>Source files, the module makefile and private header files go directly in the new folder, while public headers are placed in a ./public subdirectory. Create a ./obj directory to hold the output from the builds.</p>
<p>The contents of the module makefile looks something like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Include common prelude make file</span></div>
<div class="line"><span class="preprocessor"></span>include $(ROOT_DIR)base.mak</div>
<div class="line"></div>
<div class="line"># If we<span class="stringliteral">&#39;re building a library, set IS_LIB and LIBNAME</span></div>
<div class="line"><span class="stringliteral"># If we&#39;</span>re building an app, set IS_APP and APPNAME</div>
<div class="line">IS_LIB=1</div>
<div class="line">LIBNAME=mylib</div>
<div class="line"></div>
<div class="line">#<span class="keyword">this</span> is the list of the source modules required to build the kernel</div>
<div class="line">CPP_SOURCE = mylib.cpp \
             someotherfile.cpp</div>
<div class="line"></div>
<div class="line"># Similarly, C-language source would be under the C_SOURCE variable.</div>
<div class="line">             </div>
<div class="line"># Include the rest of the script that is actually used <span class="keywordflow">for</span> building the </div>
<div class="line"># outputs</div>
<div class="line">include $(ROOT_DIR)build.mak</div>
</div><!-- fragment --><p>Once you've placed your code files in the right place, and configured the makefile appropriately, a fresh call to make headers, make library, then make binary will guarantee that your code is built.</p>
<p>Now, you can still copy-and-paste the required kernel, port, and drivers, directly into your application avoiding the whole process of using make from the command line. To do this, run "make source" from the root directory in svn, and copy the contents of /stage/src into your project. This should contain the source to the kernel, all drivers, and all services that are in the tree - along with the necessary header files.</p>
<h1><a class="anchor" id="WINBUILD"></a>
Building on Windows</h1>
<p>Building Mark3 on Windows is the same as on Linux, but there are a few prerequisites that need to be taken into consideration before the build scripts and makefiles will work as expected.</p>
<p>Step 1 - Install Latest Atmel Studio IDE</p>
<p>Atmel Studio contains the AVR8 GCC toolchain, which contains the necessary compilers, assemblers, and platform support required to turn the source modules into libraries and executables.</p>
<p>To get Atmel Studio, go to the Atmel website (<a href="http://www.atmel.com">http://www.atmel.com</a>) and register to download the latest version. This is a free download (and rather large). The included IDE (if you choose to use it) is very slick, as it's based on Visual Studio, and contains a wonderful cycle-accurate simulator for AVR devices. In fact, the simulator is so good that most of the kernel and its drivers were developed using this tool.</p>
<p>Once you have downloaded and installed Atmel Studio, you will need to add the location of the AVR toolcahin to the PATH environment variable.</p>
<p>To do this, go to Control Panel -&gt; System and Security -&gt; System -&gt; Advanced System Settings, and edit the PATH variable. Append the location of the toolchain bin folder to the end of the variable.</p>
<p>On Windows 7 x64, it should look something like this:</p>
<p>C: Files (x86) Toolchain GCC\Native\3.4.2.1002-gnu-toolchain</p>
<p>Step 2 - Install MinGW and MinSys</p>
<p>MinGW (and MinSys in particular) provide a unix-like environment that runs under windows. Some of the utilities provided include a version of the bash shell, and GNU standard make - both which are required by the Mark3 recursive build system.</p>
<p>The MinGW installer can be downloaded from its project page on SourceForge. When installing, be sure to select the "MinSys" component.</p>
<p>Once installed, add the MinSys binary path to the PATH environment variable, in a similar fashion as with Atmel Studio in Step 1.</p>
<p>Step 3 - Setup Include Paths in Platform Makefile</p>
<p>The AVR header file path must be added to the "platform.mak" makefile for each AVR Target you are attempting to build for. These files can be located under /embedded/build/avr/atmegaXXX/. The path to the includes directory should be added to the end of the CFLAGS and CPPFLAGS variables, as shown in the following:</p>
<div class="fragment"><div class="line">TEST_INC=<span class="stringliteral">&quot;/c/Program Files (x86)/Atmel/Atmel Toolchain/AVR8 GCC/Native/3.4.2.1002/avr8-gnu-toolchain/include&quot;</span></div>
<div class="line">CFLAGS += -I$(TEST_INC)</div>
<div class="line">CPPFLAGS += -I$(TEST_INC)</div>
</div><!-- fragment --><p>Step 4 - Build Mark3 using Bash</p>
<p>Launch a terminal to your Mark3 base directory, and cd into the "embedded" folder. You should now be able to build Mark3 by running "bash ./build.sh" from the command-line.</p>
<p>Alternately, you can run bash itself, building Mark3 by running ./build.sh or the various make targets using the same synatx as documented previously.</p>
<p>Note - building on Windows is <em>slow</em>. This has a lot to do with how "make" performs under windows. There are faster substitutes for make (such as cs-make) that are exponentially quicker, and approach the performance of make on Linux. Other mechanisms, such as running make with multiple concurrent jobs (i.e. "make -j4") also helps significantly, especially on systems with multicore CPUs. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Mar 5 2015 22:35:13 for Mark3 Realtime Kernel by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
