#include <avr/pgmspace.h>
#include <TimerOne.h>
#include "font.h"
//#include <SevenSeg.h>
#include <PString.h>
//#include <OneWire.h>
//#include <TimerOne.h>
#include <avr/wdt.h>
#include <avr/sleep.h>
#include "LowPower.h"
#include <EEPROM.h>
#include <avr/power.h>

//#include <Helios.h>
//
//Helios helios;
//
//double dAzimuth;
//double dElevation;

// #include <DigisparkOLED.h>

#define SEGMENT
//#define MATRIX


#define NO_VOICE // Uncomment this line to dissable voice OUTPUT
#define FEMALE_VOICE // Uncomment this line to switch to a female voice

byte segmentPins[8]={
  4,5,6,12,10,8,13,11}; /// SUPERCAP blue -  common anode
byte digitPins[4]={
  3,16,14,15}; //dp = 6
#define ACTH LOW
#define ACTL HIGH

//byte segmentPins[8]={
//  13,14,12,9,11,16,4,6}; /// round board QDSP-6064
//byte digitPins[4]={
//  10,15,8,5}; //dp = 6
//#define ACTH HIGH
//#define ACTL LOW

//byte segmentPins[8]={5,14,11,16,17,6,12,15}; /// sqr board red KW4-311ABA blue common anode
//byte digitPins[4]={4,8,10,13}; //dp = 6
//#define ACTH LOW
//#define ACTL HIGH

//int rowPin[] = {14,13,5,10,6}; //TC03-11 round
//int colPin[] = {11,15,12,8,16,9,4};

int rowPin[] = {
  10,14,6,15,17}; //TC07-11 red board
int colPin[] = {
  4,5,16,8,11,12,13};

#define modeBtn   2
#define selectBtn   7
#define speaker   9

#include "Wire.h"
#include <DS3231.h>
#include <EEPROM.h>
//#include <bmp180.h>
//BMP180 bsensor;

// the song is stored in program memory only
//Indiana
const char song_1[] PROGMEM = ":d=4,o=5,b=250:e,8p,8f,8g,8p,1c6,8p.,d,8p,8e,1f,p.,g,8p,8a,8b,8p,1f6,p,a,8p,8b,2c6,2d6,2e6,e,8p,8f,8g,8p,1c6,p,d6,8p,8e6,1f.6,g,8p,8g,e.6,8p,d6,8p,8g,e.6,8p,d6,8p,8g,f.6,8p,e6,8p,8d6,2c6";
//Entertainer
const char song_2[] PROGMEM = ":d=4,o=5,b=140:8d,8d#,8e,c6,8e,c6,8e,2c.6,8c6,8d6,8d#6,8e6,8c6,8d6,e6,8b,d6,2c6,p,8d,8d#,8e,c6,8e,c6,8e,2c.6,8p,8a,8g,8f#,8a,8c6,e6,8d6,8c6,8a,2d6";
//StarWars
const char song_3[] PROGMEM = ":d=4,o=5,b=45:32p,32f#,32f#,32f#,8b.,8f#.6,32e6,32d#6,32c#6,8b.6,16f#.6,32e6,32d#6,32c#6,8b.6,16f#.6,32e6,32d#6,32e6,8c#.6,32f#,32f#,32f#,8b.,8f#.6,32e6,32d#6,32c#6,8b.6,16f#.6,32e6,32d#6,32c#6,8b.6,16f#.6,32e6,32d#6,32e6,8c#6";
//Flinstones
const char song_6[] PROGMEM = ":d=4,o=5,b=40:32p,16f6,16a#,16a#6,32g6,16f6,16a#.,16f6,32d#6,32d6,32d6,32d#6,32f6,16a#,16c6,d6,16f6,16a#.,16a#6,32g6,16f6,16a#.,32f6,32f6,32d#6,32d6,32d6,32d#6,32f6,16a#,16c6,a#,16a6,16d.6,16a#6,32a6,32a6,32g6,32f#6,32a6,8g6,16g6,16c.6,32a6,32a6,32g6,32g6,32f6,32e6,32g6,8f6,16f6,16a#.,16a#6,32g6,16f6,16a#.,16f6,32d#6,32d6,32d6,32d#6,32f6,16a#,16c.6,32d6,32d#6,32f6,16a#,16c.6,32d6,32d#6,32f6,16a#6,16c7,8a#.6";
//MahnaMahna
const char song_5[] PROGMEM = ":d=16,o=6,b=125:c#,c.,b5,8a#.5,8f.,4g#,a#,g.,4d#,8p,c#,c.,b5,8a#.5,8f.,g#.,8a#.,4g,8p,c#,c.,b5,8a#.5,8f.,4g#,f,g.,8d#.,f,g.,8d#.,f,8g,8d#.,f,8g,d#,8c,a#5,8d#.,8d#.,4d#,8d#.";
//MissionImp
const char song_4[] PROGMEM = ":d=16,o=6,b=95:32d,32d#,32d,32d#,32d,32d#,32d,32d#,32d,32d,32d#,32e,32f,32f#,32g,g,8p,g,8p,a#,p,c7,p,g,8p,g,8p,f,p,f#,p,g,8p,g,8p,a#,p,c7,p,g,8p,g,8p,f,p,f#,p,a#,g,2d,32p,a#,g,2c#,32p,a#,g,2c,a#5,8c,2p,32p,a#5,g5,2f#,32p,a#5,g5,2f,32p,a#5,g5,2e,d#,8d";

//const char song_1[] PROGMEM = "GoodBad:d=4,o=5,b=56:32p,32a#,32d#6,32a#,32d#6,8a#.,16f#.,16g#.,d#,32a#,32d#6,32a#,32d#6,8a#.,16f#.,16g#.,c#6,32a#,32d#6,32a#,32d#6,8a#.,16f#.,32f.,32d#.,c#,32a#,32d#6,32a#,32d#6,8a#.,16g#.,d#";
//const char song_1[] PROGMEM = "TopGun:d=4,o=4,b=31:32p,16c#,16g#,16g#,32f#,32f,32f#,32f,16d#,16d#,32c#,32d#,16f,32d#,32f,16f#,32f,32c#,16f,d#,16c#,16g#,16g#,32f#,32f,32f#,32f,16d#,16d#,32c#,32d#,16f,32d#,32f,16f#,32f,32c#,g#";
//const char song_1[] PROGMEM = "A-Team:d=8,o=5,b=125:4d#6,a#,2d#6,16p,g#,4a#,4d#.,p,16g,16a#,d#6,a#,f6,2d#6,16p,c#.6,16c6,16a#,g#.,2a#";
//const char song_1[] PROGMEM = "The Simpsons:d=4,o=5,b=160:c.6,e6,f#6,8a6,g.6,e6,c6,8a,8f#,8f#,8f#,2g,8p,8p,8f#,8f#,8f#,8g,a#.,8c6,8c6,8c6,c6";
//const char song_1[] PROGMEM = "Indiana:d=4,o=5,b=250:e,8p,8f,8g,8p,1c6,8p.,d,8p,8e,1f,p.,g,8p,8a,8b,8p,1f6,p,a,8p,8b,2c6,2d6,2e6,e,8p,8f,8g,8p,1c6,p,d6,8p,8e6,1f.6,g,8p,8g,e.6,8p,d6,8p,8g,e.6,8p,d6,8p,8g,f.6,8p,e6,8p,8d6,2c6";
//const char song_1[] PROGMEM = "TakeOnMe:d=4,o=4,b=160:8f#5,8f#5,8f#5,8d5,8p,8b,8p,8e5,8p,8e5,8p,8e5,8g#5,8g#5,8a5,8b5,8a5,8a5,8a5,8e5,8p,8d5,8p,8f#5,8p,8f#5,8p,8f#5,8e5,8e5,8f#5,8e5,8f#5,8f#5,8f#5,8d5,8p,8b,8p,8e5,8p,8e5,8p,8e5,8g#5,8g#5,8a5,8b5,8a5,8a5,8a5,8e5,8p,8d5,8p,8f#5,8p,8f#5,8p,8f#5,8e5,8e5";
//const char song_1[] PROGMEM = "LeisureSuit:d=16,o=6,b=56:f.5,f#.5,g.5,g#5,32a#5,f5,g#.5,a#.5,32f5,g#5,32a#5,g#5,8c#.,a#5,32c#,a5,a#.5,c#.,32a5,a#5,32c#,d#,8e,c#.,f.,f.,f.,f.,f,32e,d#,8d,a#.5,e,32f,e,32f,c#,d#.,c#";
//const char song_1[] PROGMEM = "Jeopardy:d=4,o=6,b=125:c,f,c,f5,c,f,2c,c,f,c,f,a.,8g,8f,8e,8d,8c#,c,f,c,f5,c,f,2c,f.,8d,c,a#5,a5,g5,f5,p,d#,g#,d#,g#5,d#,g#,2d#,d#,g#,d#,g#,c.7,8a#,8g#,8g,8f,8e,d#,g#,d#,g#5,d#,g#,2d#,g#.,8f,d#,c#,c,p,a#5,p,g#.5,d#,g#";
//const char song_1[] PROGMEM = "Gadget:d=16,o=5,b=50:32d#,32f,32f#,32g#,a#,f#,a,f,g#,f#,32d#,32f,32f#,32g#,a#,d#6,4d6,32d#,32f,32f#,32g#,a#,f#,a,f,g#,f#,8d#";
//const char song_1[] PROGMEM = "Smurfs:d=32,o=5,b=200:4c#6,16p,4f#6,p,16c#6,p,8d#6,p,8b,p,4g#,16p,4c#6,p,16a#,p,8f#,p,8a#,p,4g#,4p,g#,p,a#,p,b,p,c6,p,4c#6,16p,4f#6,p,16c#6,p,8d#6,p,8b,p,4g#,16p,4c#6,p,16a#,p,8b,p,8f,p,4f#";
//const char song_1[] PROGMEM = "Muppets:d=4,o=5,b=250:c6,c6,a,b,8a,b,g,p,c6,c6,a,8b,8a,8p,g.,p,e,e,g,f,8e,f,8c6,8c,8d,e,8e,8e,8p,8e,g,2p,c6,c6,a,b,8a,b,g,p,c6,c6,a,8b,a,g.,p,e,e,g,f,8e,f,8c6,8c,8d,e,8e,d,8d,c";
//const char song_1[] PROGMEM = "Xfiles:d=4,o=5,b=125:e,b,a,b,d6,2b.,1p,e,b,a,b,e6,2b.,1p,g6,f#6,e6,d6,e6,2b.,1p,g6,f#6,e6,d6,f#6,2b.,1p,e,b,a,b,d6,2b.,1p,e,b,a,b,e6,2b.,1p,e6,2b.";
//const char song_1[] PROGMEM = "Looney:d=4,o=5,b=140:32p,c6,8f6,8e6,8d6,8c6,a.,8c6,8f6,8e6,8d6,8d#6,e.6,8e6,8e6,8c6,8d6,8c6,8e6,8c6,8d6,8a,8c6,8g,8a#,8a,8f";
//const char song_1[] PROGMEM = "20thCenFox:d=16,o=5,b=140:b,8p,b,b,2b,p,c6,32p,b,32p,c6,32p,b,32p,c6,32p,b,8p,b,b,b,32p,b,32p,b,32p,b,32p,b,32p,b,32p,b,32p,g#,32p,a,32p,b,8p,b,b,2b,4p,8e,8g#,8b,1c#6,8f#,8a,8c#6,1e6,8a,8c#6,8e6,1e6,8b,8g#,8a,2b";
//const char song_1[] PROGMEM = "Bond:d=4,o=5,b=80:32p,16c#6,32d#6,32d#6,16d#6,8d#6,16c#6,16c#6,16c#6,16c#6,32e6,32e6,16e6,8e6,16d#6,16d#6,16d#6,16c#6,32d#6,32d#6,16d#6,8d#6,16c#6,16c#6,16c#6,16c#6,32e6,32e6,16e6,8e6,16d#6,16d6,16c#6,16c#7,c.7,16g#6,16f#6,g#.6";
//const char song_1[] PROGMEM = "MASH:d=8,o=5,b=140:4a,4g,f#,g,p,f#,p,g,p,f#,p,2e.,p,f#,e,4f#,e,f#,p,e,p,4d.,p,f#,4e,d,e,p,d,p,e,p,d,p,2c#.,p,d,c#,4d,c#,d,p,e,p,4f#,p,a,p,4b,a,b,p,a,p,b,p,2a.,4p,a,b,a,4b,a,b,p,2a.,a,4f#,a,b,p,d6,p,4e.6,d6,b,p,a,p,2b";

#include <TimeLord.h>
TimeLord myLord;
byte sun[]  = {
  0, 0, 0, 0, 0, 0};


// ID of the settings block
#define CONFIG_VERSION "ls4"
// Tell it where to store your config data in EEPROM
#define CONFIG_START 32
// Example settings structure
struct StoreStruct {
  // The variables of your settings

  int lat;
  int lon;
  byte tzone;
  byte dst;

  byte A1on;
  byte A2on;

  byte A1Hour;
  byte A1Minute;
  byte A2Minute;

  byte brightness;
  byte melody;
  byte A1d[7];
  byte topsleep;
  byte autoDisplay;

  char version_of_program[4]; // it is the last variable of the struct
} 
ee = {
  // The default values
  49,
  21,
  1,
  0,

  0, // Alarm 1 on
  0, // Alarm 2 on

  0,  // AL1 hours
  1, // AL1 minutes

  59, // AL2 minutes

  0, // brighest
  5, // melody  
  {
    0,0,0,0,0,0,0              }
  ,
  1, //sleep time
  0, //auto display
  CONFIG_VERSION
};

volatile byte daysPerMonth[12] = {
  31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

DS3231 Clock;
bool Century=false;
bool h12;
bool PM;
bool extRTC=false;

byte second, minute, hour, day, month;
int year;

int DN;   //Returns the number of day in the year
int WN;   //Returns the number of the week in the year

int rtctemp;
byte chled=0;

static unsigned long lastTick = 0; // set up a local variable to hold the last time we moved forward one second
static unsigned long lastSleep = 0; // set up a local variable to hold the last time we moved forward one second
byte menuPosition=0;
byte selectActive=0;
byte menuActive=0;
byte wakeupActive=0;
byte line=0;
byte mode=0;
byte setAlarm=0;
byte lastMinute;
int var=0;
int sleepTime=6000; // how many useconds in without button press before go to sleep
#define No_Change   32000



volatile byte row=0,col=0,mline=1, scdelay=0, textx=0, textindex=0;
int dumm=0;
byte videoram[11]={
  B00000,
  B00000,
  B00000,
  B00000,
  B00000,
  B00000,
  B00000,
  B00000,
  B00000,
  B00000,
  B00000,
};



byte bchar=0, dchar=0, textindex2=0;
byte deol=0;
byte digit=0;



/** LCD Store and print a string in flash memory.*/
#define MaxBuffer 460    //textovy buffer
//char buffer[MaxBuffer];
//PString screen(buffer, sizeof(buffer));
char LEDbuffer1[15];
PString led1(LEDbuffer1, 15);
char LEDbuffer2[15];
PString led2(LEDbuffer2, 15);
byte none;

void setup () {

  pinMode(speaker,OUTPUT); // blue top PWM
  pinMode(modeBtn,INPUT); // white led lamp
  pinMode(selectBtn,INPUT); // blue top PWM
  digitalWrite(modeBtn,HIGH);
  digitalWrite(selectBtn,HIGH);
  digitalWrite(speaker,LOW);



  //*-----------------------------------------------------------------------*/
  // Display setup

#ifdef SEGMENT
  for(int i = 0; i <8; i++){  //Set the 16 pins used to control the array as OUTPUTs
    pinMode(segmentPins[i], OUTPUT);
  }
  for(int i = 0; i <4; i++){  //Set the 16 pins used to control the array as OUTPUTs
    pinMode(digitPins[i], OUTPUT);
  }
#endif
#ifdef MATRIX
  for(int i = 0; i <5; i++){  //Set the 16 pins used to control the array as OUTPUTs
    pinMode(rowPin[i], OUTPUT);
  }
  for(int i = 0; i <7; i++){  //Set the 16 pins used to control the array as OUTPUTs
    pinMode(colPin[i], OUTPUT);
  }  
#endif
  attachInterrupt(0, modeInt, CHANGE);

  while (digitalRead(selectBtn)==HIGH) { // Press SELECT button after power on to start
    LowPower.powerSave(SLEEP_8S,ADC_OFF, BOD_OFF, TIMER2_OFF); //after POWER ON shutdown CPU to get all power for charging battery
    charging();
  } 

  //      playMelody (5);

  //if (modeClick()==HIGH) // Do not load config if MENU button is on hold
  //{
  loadConfig();
  //}

//  byte    data;         // Dummy data
//  Wire.begin(); 
//  Wire.beginTransmission(0x68);
//  Wire.write(&data, 0);
//
//  if ((Wire.endTransmission()) == 0)         // I2C 0x68 RTC Module found
//  {
//    //          beep();
//    extRTC=true;
//  }
//  else
//  {
//    extRTC=false;
//  }


    extRTC=false;



  if (extRTC)
  {
    readRtc ();
    none=Clock.checkIfAlarm(1);
    none=Clock.checkIfAlarm(2); // clear alarm bits

  }
  else
  {
    //Initialise the timer2 internall RTC
    RTCInit();
  }
  


  beep();  
 
  
  line=0;
  setRtcAlarms ();

  checkAlarms (1);

  displayOn();


  textindex=0;

  //disp.setActivePinState(LOW,HIGH);
  menuPosition=0;
  MCUSR = 0; // clear MCUSR 
  //  oled.begin();

  //  screen.begin();
  //  screen.print( readVcc());
  //  screen.println("V "); 
  //  screen.print( readTemp());
  //  screen.println(" C");
  //  screen.print(F("RAM:"));
  //  screen.println(FreeRam());


  //  oled.clear(); //all black
  //  oled.setCursor(0, 0); //top left
  //  oled.setFont(FONT6X8);
  //  oled.println(buffer);


  //  screenShow();

  //   bsensor.begin(1);


  wakeupActive=0;


  //disabling all unnecessary peripherals to reduce power
//  ADCSRA &= ~bit(ADEN); //disable ADC
//  power_adc_disable(); // disable ADC converter
  power_spi_disable(); // disable SPI
  power_usart0_disable();// disable Serial (USART)
//  power_timer1_disable();// disable Timer 1
  power_twi_disable(); // disable TWI (I2C)


}

void loop () {

  if ((millis() - lastSleep >= sleepTime)&(ee.topsleep!=0)) {
    wakeupActive=0;
    displayOff();
    byte i=0;

    while (wakeupActive==0){

      //  LowPower.powerStandby(); //SLEEP_FOREVER

      if (extRTC)
      {
        LowPower.powerSave(SLEEP_FOREVER,ADC_OFF, BOD_OFF, TIMER2_OFF);
        //     LowPower.powerSave(SLEEP_FOREVER, ADC_OFF, TIMER2_OFF, TIMER1_OFF, TIMER0_OFF, 
        //                SPI_OFF, USART0_OFF, TWI_OFF); //SLEEP_FOREVER //SLEEP_8S
      }
      else
      {
        LowPower.powerSave(SLEEP_FOREVER,ADC_OFF, BOD_OFF, TIMER2_ON);
        //       goSleep();
//             LowPower.powerExtStandby(SLEEP_FOREVER,ADC_OFF, BOD_OFF, TIMER2_ON); //SLEEP_FOREVER //SLEEP_8S
//        LowPower.powerSave(SLEEP_FOREVER,ADC_OFF, BOD_OFF, TIMER2_ON);
//        SMCR|=(1<<SE);
//        asm volatile("sleep"::);
//        SMCR&=~(1<<SE);

      }
      checkAlarms (0);
    }

    // continue after INT button wakeup  

    wakeupActive=0;
    menuPosition=0;
    mode=0;
    line=1;
    while (modeClick()==LOW) {
    }

    displayOn();
    lastSleep = millis();

  } 


  if (modeClick()==LOW)
  {
    menuPosition++;
  }

  if ((selectClick()==LOW)||(menuActive==1)||(millis() - lastTick >= 500)) {
    line++;
    if (menuActive==1){
      line=0;
      mline=1;
#ifdef MATRIX 
      clearVideoram();
#endif
      textindex=0;
    }  
    if (selectActive==1) {
      line=1;
      mline=2;   
#ifdef MATRIX 
      clearVideoram();
#endif
      textindex=0;
    }
    if (line>4) {
      line=0;
      if ((ee.autoDisplay==1)&(mode==0))
      {
        menuPosition++;
      }
    }

    lastTick = millis();
    led1.begin();
    led2.begin();

    sleepTime=30000; //in all modes go to sleep after 30s

    if (mode==0) 
    {
      if (menuPosition==0)
      {
        sleepTime=ee.topsleep*1000; //after wakeup go to sleep, time set in ee.topsleep
      }
      else
      {
        sleepTime=10000; //in time mode go to sleep after 5s
      }
      if (extRTC)
      {
        readRtc ();  // read time from RTC
      }  
      showTime ();
    }

    if (mode==1) 
    {
      setTime ();
    }

    if (mode==3) astrolab ();
    if (mode==4) setAlarms ();
    if (mode==5) setSystem ();
    if (mode==6) showSensors ();

    selectActive=0;
    screenShow();
    checkAlarms (1);

  }  


}
//**************************************************************************************************************************
void astrolab ()
{

  //3 Day tl_day 1-31
  //4 Month tl_month 1-12
  //5 Year tl_year 0-99

  sun[3]=day;
  sun[4]=month;
  sun[5]=year;
  myLord.Position(ee.lat, ee.lon); //49,20
  myLord.TimeZone( ee.tzone * 60);   // +1 * 60

    //helios.calcSunPos(year,month,day,hour,minute,second,ee.lon,ee.lat);
  //dAzimuth=helios.dAzimuth;
  //dElevation=helios.dElevation;

  switch (menuPosition)
  {
  case 0:  //----------------------------- Sun rise ----------------------------- 

    led1.print(F("s.ris"));
    sun[3]=day;
    sun[4]=month;
    sun[5]=year;
    myLord.SunRise(sun);

    led2.print(sun[2], 10); 
    led2.print(F("."));     
    led2.print(sun[1], 10);    
    //      led2.print(sun.sunrise_time());
    break;

  case 1:  //----------------------------- Sun set ----------------------------- 
    led1.print(F("s.set"));
    sun[3]=day;
    sun[4]=month;
    sun[5]=year;
    myLord.SunSet(sun);
    led2.print(sun[2], 10); 
    led2.print(F("."));     
    led2.print(sun[1], 10);          
    //      led2.print(sun.sunset_time());
    break;

  case 2:  //----------------------------- set day ----------------------------- 
    led1.print(F("day"));
    var = menuChange(0,31,day);
    if (var!=No_Change) day=var;
    led2.print(day);
    break;

  case 3:  //----------------------------- set month ----------------------------- 
    led1.print(F("mont"));
    var = menuChange(1,12,month);
    if (var!=No_Change) month=var;
    led2.print(month);
    break;

  case 4:  //----------------------------- set year ----------------------------- 
    led1.print(F("year"));
    var = menuChange(2000,2030,year);
    if (var!=No_Change) year=var;
    led2.print(year);
    break;


  case 5:  //----------------------------- set month ----------------------------- 
    led1.print(F("lat"));
    var = menuChange(-180,180,ee.lat);
    if (var!=No_Change) ee.lat=var;
    led2.print(ee.lat);
    break;

  case 6:  //----------------------------- set year ----------------------------- 
    led1.print(F("lon"));
    var = menuChange(-180,180,ee.lon);
    if (var!=No_Change) ee.lon=var;
    led2.print(ee.lon);
    break;

  case 7:  //----------------------------- set year ----------------------------- 
    led1.print(F("t.zon"));
    var = menuChange(-12,13,ee.tzone);
    if (var!=No_Change) ee.tzone=var;
    led2.print(ee.tzone);
    break;


  case 8:  //----------------------------- moon phase ----------------------------- 
    led1.print(F("m.pha"));
    sun[3]=day;
    sun[4]=month;
    sun[5]=year;
    led2.print(myLord.MoonPhase(sun));
    break;

  case 9:  //----------------------------- moon phase second calculation----------------------------- 

    led1.print(F("moon"));
    led2.print(Moon_phase(year,month,day));
    break;

  case 10:  //----------------------------- days from year begin ----------------------------- 

    led1.print(F("days"));
    led2.print(yearDay(day, month, year)); /// if lap year add1
    break;

  case 11:  //----------------------------- back ----------------------------- 
    led1.print(F("----"));
    led2.print(F("back"));
    modeRelease (); // wait for release mode button
    if (selectActive==1) {
      mode=0;
      saveConfig();
      selectRelease (); // wait for release select button
    }
    break;

  case 12:  //----------------------------- last menu  ----------------------------- 
    led1.print(F("end"));
    menuPosition=0;
    //      allOff();
  }
}

//**************************************************************************************************************************
//**************************************************************************************************************************

//**************************************************************************************************************************
//**************************************************************************************************************************
void setTime ()
{
  switch (menuPosition)
  {
  case 0:  //----------------------------- set hour ----------------------------- 
    led1.print(F("hour"));
    var = menuChange(0,23,hour);
    if (var!=No_Change) hour=var;
    led2.print(hour);
    break;

  case 1:  //----------------------------- set minute ----------------------------- 
    led1.print(F("min."));
    var = menuChange(0,59,minute);
    if (var!=No_Change) minute=var;
    led2.print(minute);
    break;


  case 2:  //----------------------------- set day ----------------------------- 
    led1.print(F("day"));
    var = menuChange(0,31,day);
    if (var!=No_Change) day=var;
    led2.print(day);
    break;

  case 3:  //----------------------------- set month ----------------------------- 
    led1.print(F("mont"));
    var = menuChange(1,12,month);
    if (var!=No_Change) month=var;
    led2.print(month);
    break;

  case 4:  //----------------------------- set year ----------------------------- 
    led1.print(F("year"));
    var = menuChange(2000,2030,year);
    if (var!=No_Change) year=var;
    led2.print(year);
    break;

  case 5:  //----------------------------- set year ----------------------------- 
    led1.print(F("sec"));
    var = menuChange(0,59,second);
    if (var!=No_Change) second=var;
    led2.print(second);
    break;

  case 6:  //----------------------------- back ----------------------------- 
    led1.print(F("----"));
    led2.print(F("back"));
    modeRelease (); // wait for release mode button
    if (selectActive==1) {
      mode=0;
      selectRelease (); // wait for release select button
    }
    break;

  case 7:  //----------------------------- save time to rtc ----------------------------- 
    led1.print(F("save"));
    led2.print(F("time"));
    modeRelease (); // wait for release mode button
    if (selectActive==1) {
      mode=0;
      setRtc();
      selectRelease (); // wait for release select button
    }
    break;

  case 8:  //----------------------------- end ----------------------------- 
    led1.print(F("end"));
    menuPosition=0;
    //      allOff();
  }
}

//**************************************************************************************************************************
void setAlarms ()
{
  switch (menuPosition)
  {
  case 0:  //----------------------------- set alarm 1 hour ----------------------------- 
    led1.print(F("A1 H"));
    var = menuChange(0,23,ee.A1Hour);
    if (var!=No_Change) ee.A1Hour=var;
    led2.print(ee.A1Hour);
    break;

  case 1:  //----------------------------- set alarm 1 minute ----------------------------- 
    led1.print(F("A1 M"));
    var = menuChange(0,59,ee.A1Minute);
    if (var!=No_Change) ee.A1Minute=var;
    led2.print(ee.A1Minute);
    break;


  case 2:  //----------------------------- set alarm 1 on/off ----------------------------- 
    led1.print(F("A 1"));
    modeRelease (); // wait for release mode button
    var = menuChange(0,1,ee.A1on);
    if (var!=No_Change) ee.A1on=var;
    on_off (ee.A1on);
    break;


  case 3:
    led1.print(F("mon."));
    var = menuChange(0,1,ee.A1d[0]);
    if (var!=No_Change) ee.A1d[0]=var;
    on_off (ee.A1d[0]);
    break;
  case 4:
    led1.print(F("tue."));
    var = menuChange(0,1,ee.A1d[1]);
    if (var!=No_Change) ee.A1d[1]=var;
    on_off (ee.A1d[1]);
    break;
  case 5:
    led1.print(F("wed."));
    var = menuChange(0,1,ee.A1d[2]);
    if (var!=No_Change) ee.A1d[2]=var;
    on_off (ee.A1d[2]);
    break;
  case 6:
    led1.print(F("thu."));
    var = menuChange(0,1,ee.A1d[3]);
    if (var!=No_Change) ee.A1d[3]=var;
    on_off (ee.A1d[3]);
    break;
  case 7:
    led1.print(F("fri."));
    var = menuChange(0,1,ee.A1d[4]);
    if (var!=No_Change) ee.A1d[4]=var;
    on_off (ee.A1d[4]);
    break;
  case 8:
    led1.print(F("sat."));
    var = menuChange(0,1,ee.A1d[5]);
    if (var!=No_Change) ee.A1d[5]=var;
    on_off (ee.A1d[5]);
    break;
  case 9:
    led1.print(F("sun."));
    var = menuChange(0,1,ee.A1d[6]);
    if (var!=No_Change) ee.A1d[6]=var;
    on_off (ee.A1d[6]);
    break;      




  case 10:  //----------------------------- set alarm 2 minute only ----------------------------- 
    led1.print(F("A2 M"));
    var = menuChange(0,59,ee.A2Minute);
    if (var!=No_Change) ee.A2Minute=var;
    led2.print(ee.A2Minute);
    break;

  case 11:  //----------------------------- set alarm 2 on/off ----------------------------- 
    led1.print(F("A 2"));
    modeRelease (); // wait for release mode button
    var = menuChange(0,1,ee.A2on);
    if (var!=No_Change) ee.A2on=var;
    on_off (ee.A2on);
    break;

  case 12:  //----------------------------- set alarm 1 RTTTL melody ----------------------------- 
    led1.print(F("song"));
    var = menuChange(0,6,ee.melody);
    if (var!=No_Change) ee.melody=var;
    led2.print(ee.melody);
    break;

  case 13:  //----------------------------- back ----------------------------- 
    led1.print(F("PLAY"));
    led2.print(ee.melody);
    if (selectActive==1) {
      playMelody (ee.melody);
      displayOn();
      menuPosition--;
    }
    break;

  case 14:  //----------------------------- back ----------------------------- 
    led1.print(F("----"));
    led2.print(F("back"));
    modeRelease (); // wait for release mode button
    if (selectActive==1) {
      mode=0;
      selectRelease (); // wait for release select button
    }
    break;

  case 15:  //----------------------------- save time to rtc ----------------------------- 
    led1.print(F("save"));
    led2.print(F("alrm"));
    if (selectActive==1) {
      mode=0;
      setRtcAlarms();
      saveConfig();
      selectRelease (); // wait for release select button
    }
    break;

  case 16:  //----------------------------- end ----------------------------- 
    led1.print(F("end"));
    menuPosition=0;
    //      allOff();
  }
}

//**************************************************************************************************************************
//**************************************************************************************************************************
void setSystem ()
{
  switch (menuPosition)
  {
  case 0:  //----------------------------- set brightness ----------------------------- 
    led1.print(F("brig"));
    var = menuChange(0,50,ee.brightness);
    if (var!=No_Change) ee.brightness=var;
    led2.print(ee.brightness);
    //      disp.setDutyCycle (ee.brightness*10);
    break;

  case 1:  //----------------------------- set sleep time ----------------------------- 
    led1.print(F("slp."));
    var = menuChange(0,30,ee.topsleep);
    if (var!=No_Change) ee.topsleep=var;
    led2.print(ee.topsleep);
    break;

  case 2:  //----------------------------- auto cycle items on display ----------------------------- 
    led1.print(F("auto"));
    var = menuChange(0,1,ee.autoDisplay);
    if (var!=No_Change) ee.autoDisplay=var;
    on_off (ee.autoDisplay);
    break;

  case 3:  //----------------------------- free ram----------------------------- 
    led1.print(F("free"));
    led2.print(FreeRam());
    break;


  case 4:  //----------------------------- back ----------------------------- 
    led1.print(F("----"));
    led2.print(F("back"));
    modeRelease (); // wait for release mode button
    if (selectActive==1) {
      mode=0;
      selectRelease (); // wait for release select button
    }
    break;

  case 5:  //----------------------------- save settings ----------------------------- 
    led1.print(F("save"));
    led2.print(F("sett"));
    if (selectActive==1) {
      mode=0;
      //      setRtcAlarms();
      saveConfig();
      selectRelease (); // wait for release select button
    }
    break;

  case 6:  //----------------------------- end ----------------------------- 
    led1.print(F("end"));
    menuPosition=0;
    //      allOff();
  }
}
//**************************************************************************************************************************
//**************************************************************************************************************************
void on_off (byte on)
{
  if (on==1)
  {
    led2.print(F(" on"));
  }
  else
  {
    led2.print(F("off"));
  }
}
void showSensors ()
{
  // C is shifted one decimal to avoid float
  //  int tempC  = bsensor.getCelsiusHundredths();
  // Pressure is in pascals
  //  long pressurePascals = bsensor.getPressurePascals();
  //centimeters
  //  long altitudeCm = bsensor.getAltitudeCentimeters(pressurePascals);

  switch (menuPosition)
  {
  case 0:  //----------------------------- pressure ----------------------------- 


    //  printf("The temperature is %.1f C\n", (float)tempC/10);
    //  printf("The pressure is %ld Pascals\n", pressurePascals);
    //  printf("The altitude in meters is %.2f\n", (float)altitudeCm/100);

    led1.print(F("hpa"));
    //      led2.print((float)pressurePascals/100);
    break;
  case 1:  //----------------------------- altitude ----------------------------- 
    led1.print(F("alt."));
    //     led2.print((float)altitudeCm/100);
    break;

  case 2:  //----------------------------- temperature ----------------------------- 
    led1.print(F("ps\370"));
    //      led2.print((float)tempC/10);
    break;

  case 3:  //----------------------------- temperature ----------------------------- 
    led1.print(F("br. \370"));
    led2.print(F("350"));
    break;

  case 4:  //----------------------------- temperature ----------------------------- 
    led1.print(F("dir"));
    led2.print(F("ne"));
    break;

  case 5:  //----------------------------- temperature ----------------------------- 
    led1.print(F("ir1.\370"));
    led2.print(F("35"));
    break;

  case 6:  //----------------------------- temperature ----------------------------- 
    led1.print(F("ir2.\370"));
    led2.print(F("35"));
    break;
  case 7:  //----------------------------- temperature ----------------------------- 
    led1.print(F("hrtr"));
    led2.print(F("66"));
    break;

  case 8:  //----------------------------- back ----------------------------- 
    led1.print(F("----"));
    led2.print(F("back"));
    if (selectActive==1) {
      mode=0;
      selectRelease (); // wait for release select button
    }
    break;

  case 9:  //----------------------------- save time to rtc ----------------------------- 
    led1.print(F("save"));
    led2.print(F("sett"));
    if (selectActive==1) {
      mode=0;
      saveConfig();
      selectRelease (); // wait for release select button
    }
    break;

  case 10:  //----------------------------- end ----------------------------- 
    led1.print(F("end"));
    menuPosition=0;
  }
}
//**************************************************************************************************************************



void showTime ()
{
  switch (menuPosition)
  {
  case 0:  //----------------------------- Time ----------------------------- 

    led1.print(F("TIME"));
    if (hour<10) led2.print(0);
    led2.print(hour);
    led2.print(F("."));
    if (minute<10) led2.print(0);
    led2.print(minute);

#ifndef NO_VOICE
    if (selectActive==1) {
      if (extRTC)
      {
        sayTime();
        displayOn();
      }

    }
#endif
    break;

  case 1:  //----------------------------- dow ----------------------------- 
    if (selectActive==1) {
      DayWeekNumber(day, month, year);
      led2.print(F("e."));
      led2.print(WN);
    }
    else
    {
      led1.print(F("DAY. "));
      switch (calcDOW(day, month, year))
      {
      case 1: 
        led2.print(F("mon.")); 
        break;
      case 2: 
        led2.print(F("tue.")); 
        break;
      case 3: 
        led2.print(F("wed.")); 
        break;
      case 4: 
        led2.print(F("thu.")); 
        break;
      case 5: 
        led2.print(F("fri.")); 
        break;
      case 6: 
        led2.print(F("sat.")); 
        break;
      case 7: 
        led2.print(F("sun.")); 
        break;
      }
    }
    break;
    //void DayWeekNumber(byte d, byte m, byte y)
  case 2:  //----------------------------- day ----------------------------- 
    if (selectActive==1) {
      DayWeekNumber(day, month, year);
      led2.print(F("d."));
      led2.print(DN);
    }
    else
    {
      led1.print(F("date"));
      led2.print(day);
    }
    break;

  case 3:  //----------------------------- month ----------------------------- 
    // dayT = daysPerMonth[month - 1];
    if (selectActive==1) {
      led2.print(F("m."));
      led2.print(daysPerMonth[month - 1]);
    }
    else
    {
      led1.print(F("mont."));
      switch (month)
      {
      case 1: 
        led2.print(F("jan")); 
        break;
      case 2: 
        led2.print(F("feb")); 
        break;
      case 3: 
        led2.print(F("mar")); 
        break;
      case 4: 
        led2.print(F("apr")); 
        break;
      case 5: 
        led2.print(F("may")); 
        break;
      case 6: 
        led2.print(F("jun")); 
        break;
      case 7: 
        led2.print(F("jul")); 
        break;
      case 8: 
        led2.print(F("aug")); 
        break;
      case 9: 
        led2.print(F("sept")); 
        break;
      case 10: 
        led2.print(F("oct")); 
        break;
      case 11: 
        led2.print(F("nov")); 
        break;
      case 12: 
        led2.print(F("dec")); 
        break;
      }
    }
    break;

  case 4:  //----------------------------- year ----------------------------- 
    led1.print(F("year"));
    led2.print(year);
    break;     



  case 5:  //----------------------------- Seconds ----------------------------- 
    led1.print(F("sec"));
    led2.print(second);
    break;

  case 6:  //----------------------------- DS3231 temperature ----------------------------- 
    led1.print(F("rtc@"));
    if (extRTC)
    {
      led2.print(rtctemp);
      led2.print(F("@C"));
    }
    else
    {
      led2.print(F("off"));
    }
    break;

  case 7:  //----------------------------- atmega328 temperature ----------------------------- 
    led1.print(F("cpu@"));
    led2.print(readTemp());
    led2.print(F("@C"));
    break;

  case 8:  //----------------------------- Show supply voltage ----------------------------- 
    led1.print(F("batr."));
//    led2.print(readVcc());
//   val = map(analogRead(7), 200, 850, 0, 100);
    led2.print(map(analogRead(7), 200, 850, 0, 100));
//    led2.print(F("u"));
    break;

  case 9:  //----------------------------- sunset sunrise calculator ----------------------------- 
    led1.print(F("Astr."));
    led2.print(F("calc"));
    if (selectActive==1) {
      mode=3;
      selectRelease (); // wait for release select button
    }
    break;

  case 10:  //----------------------------- IIC scaner ----------------------------- 
    led1.print(F("IIC"));
    led2.print(F("scan"));
    if (selectActive==1) {
      selectRelease (); // wait for release select button
      I2C_scaner();
    }
    break;

  case 11:  //----------------------------- Switch menu to alarm setup ----------------------------- 
    led1.print(F("Alar"));
    led2.print(F("set"));
    modeRelease (); // wait for release mode button
    if (selectActive==1) {
      mode=4;
      selectRelease (); // wait for release select button
    }
    break; 


  case 12:  //----------------------------- Switch menu to time setup ----------------------------- 
    led1.print(F("time"));
    led2.print(F("set"));
    if (selectActive==1) {
      mode=1;
      selectRelease (); // wait for release select button
    }
    break;     


  case 13:  //----------------------------- Switch menu to system setup ----------------------------- 
    led1.print(F("Syst"));
    led2.print(F("set"));
    if (selectActive==1) {
      mode=5;
      selectRelease (); // wait for release select button
    }
    break; 

  case 14:  //----------------------------- Switch menu to show sensors ----------------------------- 
    led1.print(F("sens"));
    led2.print(F("disp"));
    if (selectActive==1) {
      mode=6;
      selectRelease (); // wait for release select button
    }
    break; 

  case 15:  //----------------------------- Last menu ittem ----------------------------- 
    led1.print(F("end"));
    menuPosition=0;
  }
}
//**************************************************************************************************************************
//**************************************************************************************************************************
void screenShow()
{
  //  oled.clear(); //all black
  //  oled.setCursor(0, 0); //top left
  //  oled.setFont(FONT6X8);
  //  oled.println(buffer);
  //  oled.setFont(FONT8X16);
  //  oled.println(LEDbuffer1);
  //  oled.println(LEDbuffer2);

  if (line==0) {
    //    disp.write(LEDbuffer1);
    //    disp.changeDigit(2);
    //    disp.setDP();
    //    delay(5);
  }
  else
  {
    //    disp.write(LEDbuffer2);
    //    disp.changeDigit(1);
    //    disp.setDP();
    //    delay(5);
  }

}


//------------------------------------------------------------------------------
void checkAlarms (byte display_on)
{
  byte dow;
  //ee.A1d[0]
  dow=(calcDOW(day, month, year))-1;

  if (extRTC)
  {
    if (Clock.checkIfAlarm(1)&&(ee.A1on==1)) {
      if (ee.A1d[dow]==1){
        //      		beep();
        playMelody (ee.melody);
        if (display_on==1) {
          displayOn();
        }
      }
      wakeupActive=0;
    }

    if (Clock.checkIfAlarm(2)&&(ee.A2on==1)) {
      //		beep();
#ifndef NO_VOICE
      //        sayTime();
      playMelody (ee.melody);
#endif
      if (display_on==1) {
        displayOn();
      }
      wakeupActive=0;
    }


  } 
  else
  {

    if ((ee.A1Hour==hour)&&(ee.A1Minute==minute)&&(ee.A1d[dow]==1)&&(second<15)&&(ee.A1on==1)) {  
      playMelody (ee.melody);
      wakeupActive=0;
    }

    if ((ee.A1Minute==minute)&&(second<15)&&(ee.A2on==1)) {
      beep();
      wakeupActive=0;
    }  
  }
}

void readRtc ()
{
  year=2000+Clock.getYear();
  month=Clock.getMonth(Century);
  day=Clock.getDate();
  hour=Clock.getHour(h12, PM);
  minute=Clock.getMinute();
  second=Clock.getSecond();
  rtctemp=Clock.getTemperature();
}
void setRtc ()
{
  Clock.setHour(hour);
  Clock.setMinute(minute);
  Clock.setDate(day);
  Clock.setMonth(month);
  Clock.setYear(year-2000);
}

void setRtcAlarms ()
{
  if (extRTC)
  {
    Clock.setA1Time(0, ee.A1Hour, ee.A1Minute, 0, 8, false, false, false); //bit
    Clock.setA2Time(0, 0, ee.A2Minute, 96, false, false, false); //112 every minute 96 minutes match .... 

    // Turn on both alarms, with external interrupt
    Clock.turnOnAlarm(1);
    Clock.turnOnAlarm(2);
  }
}


int menuChange(int xmin,int xmax, int value )
{
  if (selectActive==1){
    //    delay(200);
    //    valueChanged = 1;
    //    beep();
    value++;
    if (value > xmax) {
      value = xmin;
    }
    if (value < xmin) {
      value = xmax;
    }
    selectActive=0;
    return (value);
  }
  return (No_Change);
}


byte modeClick () {
  if (digitalRead(modeBtn)==0)
  {
    lastSleep = millis();
    delay (200);
    menuActive=1;
    return (LOW);
  }
  else {
    menuActive=0; 
    return (HIGH);
  }
}

byte modeRelease () {

  while (digitalRead(modeBtn)==0)
  {
  }
  //    delay (300);
}

byte selectRelease () {

  if (digitalRead(selectBtn)==0)
  {
    while (digitalRead(selectBtn)==0)
    {
    }
  }
  beep ();
  selectActive=0; // clear select active
  menuPosition=0;
}

byte selectClick () {
  if (digitalRead(selectBtn)==LOW)
  {
    lastSleep = millis();
    //  beep();
    delay (300);
    //  beep();
    selectActive=1;

    return (LOW);
  }
  else { 
    return (HIGH);
  }
}

void beep ()
{
  playTone( 50, 5000);
  playTone( 50, 1000);
  digitalWrite(speaker,LOW);
}

// duration in mSecs, frequency in hertz
//void playTone(long duration, int freq) {
//  duration *= 1000;
//  int period = (1.0 / freq) * 1000000;
//  long elapsed_time = 0;
//  while (elapsed_time < duration) {
//    digitalWrite(speaker,HIGH);
//    delayMicroseconds(period / 2);
//    digitalWrite(speaker, LOW);
//    delayMicroseconds(period / 2);
//    elapsed_time += (period);
//  }
//}

// duration in mSecs, frequency in hertz

void playTone(long duration, int freq) {
  duration *= 700;
  int period = (1.0 / freq) * 1000000;
  long elapsed_time = 0;
  int amax=0;
  byte up=1;

  if (extRTC)
  {
    // Timer2, OC2B enable, fast PWM, CLK/1
    TCCR2A = (1<<COM2B1) | (1<<WGM21) | (1<<WGM20);
    TCCR2B = (1<<CS20);
    // interrupt on overflow
    TIMSK2 = (1<<TOIE2);
    // PD3 output
    while (elapsed_time < duration) {

      OCR2B = amax/2;
      delayMicroseconds(period /4); 
      OCR2B = amax;
      delayMicroseconds(period /4);
      OCR2B = amax/2;
      delayMicroseconds(period /4);
      OCR2B = 0;
      delayMicroseconds(period /4);

      if (up==1) {
        if (amax < 255) {
          amax=amax+30;
        }
        else
        {
          up=0;
        }
      }
      else
      {
        if (amax > 0) amax=amax-1;
        elapsed_time += (period);
      }
    }
    TCCR2A = 0;
    TCCR2B = 0;
    TIMSK2 = 0;
  }
  else
  {
    while (elapsed_time < duration) {
      digitalWrite(speaker,HIGH);
      delayMicroseconds(period / 2);
      digitalWrite(speaker, LOW);
      delayMicroseconds(period / 2);
      elapsed_time += (period);  
    }
  }  
}

//void playTone(long duration, int freq) {
//  duration *= 2;
//  int period = (1.0 / freq) * (100000);
//  int amax=255;
//  long elapsed_time = 0;
//   // Timer2, OC2B enable, fast PWM, CLK/1
//  TCCR2A = (1<<COM2B1) | (1<<WGM21) | (1<<WGM20);
//  TCCR2B = (1<<CS20);
//  // interrupt on overflow
//  TIMSK2 = (1<<TOIE2);
//  // PD3 output
//  
//  while (elapsed_time < duration) {
//
//
//
//  for(int fadeValue = 0 ; fadeValue <= amax; fadeValue +=5) { 
//    // sets the value (range from 0 to 255):
//OCR2B = fadeValue;        
//    // wait for 30 milliseconds to see the dimming effect    
//    delayMicroseconds(period);                            
//  } 
//
//  for(int fadeValue = amax ; fadeValue >= 0; fadeValue -=5) { 
//    // sets the value (range from 0 to 255):
//OCR2B = fadeValue;          
//    // wait for 30 milliseconds to see the dimming effect    
//    delayMicroseconds(period);                         
//  }


//if (amax > 0) amax=amax-1;
//    elapsed_time += (period);
//
//
//  }
//}


//now we go sleep disabling all unnecessary peripherals
void goSleep() {
  power_timer0_disable();// disable Timer 0

  set_sleep_mode(SLEEP_MODE_PWR_SAVE);
  
  //as explained in the datasheet, after and before the sleep mode, with timer 2 in asyncrhonous mode, we
  //need to write anything to this register and then wait for those registers flag go to zero.
  OCR2A = 0xFF;
  while (ASSR & (_BV(TCN2UB) | _BV(TCR2AUB) | _BV(TCR2BUB) | _BV(OCR2AUB) | _BV(OCR2BUB))) {
  }
  
  //go sleep
  sleep_mode();
  
  //the same as above
  OCR2A = 0xFF;
  while (ASSR & (_BV(TCN2UB) | _BV(TCR2AUB) | _BV(TCR2BUB) | _BV(OCR2AUB) | _BV(OCR2BUB))) {
  }
  
  power_timer0_enable();// re-enable Timer 0
}





void modeInt()
{
  wakeupActive=1;
}

/*
//**************************************************************************************************************************
 //**********************-----------------------------   UTIL  -------------------------*************************************
 //**************************************************************************************************************************
 */

float readVcc() {
  long vcc;
  // Read 1.1V reference against AVcc
  ADMUX = _BV(REFS0) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
  delay(2); // Wait for Vref to settle
  ADCSRA |= _BV(ADSC); // Convert
  while (bit_is_set(ADCSRA,ADSC));
  vcc = ADCL;
  vcc |= ADCH<<8;
  vcc = 1126400L / vcc; // Back-calculate AVcc in mV
  vcc = vcc;
  return  ((float)vcc)/1000;
}

float readTemp() {
  long cputemp;
  // Read temperature sensor against 1.1V reference
  ADMUX = _BV(REFS1) | _BV(REFS0) | _BV(MUX3);
  delay(2); // Wait for Vref to settle
  ADCSRA |= _BV(ADSC); // Convert
  while (bit_is_set(ADCSRA,ADSC));
  cputemp = ADCL;
  cputemp |= ADCH<<8;
  cputemp = ((cputemp - 125) * 1075);
  return ((float)cputemp)/10000;
}

//------------------------------------------------------------------------------
/** Return the number of bytes currently free in RAM. */

int FreeRam(void)
{
  extern int  __bss_end;
  extern int  *__brkval;
  int free_memory;
  if((int)__brkval == 0) {
    // if no heap use from end of bss section
    free_memory = ((int)&free_memory) - ((int)&__bss_end);
  }
  else {
    // use from top of stack to heap
    free_memory = ((int)&free_memory) - ((int)__brkval);
  }
  return free_memory;
}
prog_uint16_t days[] PROGMEM={
  0,31,60,91,121,152,182,213,244,274,305,335};
//----------- dni-

int yearDay(byte d, byte m, int y){
  //int days[]={0,31,59,90,120,151,181,212,243,273,304,334};    // Number of days at the beginning of the month in a not leap year.
  int doy;
  doy = d+(pgm_read_word(&days[m-1]));
  return doy;
}

byte Moon_phase(int year,int month,int day)
{
  /*k
   Calculates the moon phase (0-7), accurate to 1 segment.
   0 = > new moon.
   4 => Full moon.
   */

  int g, e;

  if (month == 1) --day;
  else if (month == 2) day += 30;
  else // m >= 3
  {
    day += 28 + (month-2)*3059/100;

    // adjust for leap years
    if (!(year & 3)) ++day;
    if ((year%100) == 0) --day;
  }

  g = (year-1900)%19 + 1;
  e = (11*g + 18) % 30;
  if ((e == 25 && g > 11) || e == 24) e++;
  return ((((e + day)*6+11)%177)/22 & 7);
}

byte calcDOW(byte d, byte m, int y)
{
  int dow;
  byte mArr[12] = {
    6,2,2,5,0,3,5,1,4,6,2,4                      };

  dow = (y % 100);
  dow = dow*1.25;
  dow += d;
  dow += mArr[m-1];
  if (((y % 4)==0) && (m<3))
    dow -= 1;
  while (dow>7)
    dow -= 7;

  return dow;
}

void DayWeekNumber(byte d, byte m, byte y){
  int days[]={
    0,31,59,90,120,151,181,212,243,273,304,334              };    // Number of days at the beginning of the month in a not leap year.
  int w; 
  //Start to calculate the number of day
  if (m==1 || m==2){
    DN = days[(m-1)]+d;                     //for any type of year, it calculate the number of days for January or february
  }                        // Now, try to calculate for the other months
  else if ((y % 4 == 0 && y % 100 != 0) ||  y % 400 == 0){  //those are the conditions to have a leap year
    DN = days[(m-1)]+d+1;     // if leap year, calculate in the same way but increasing one day
  }
  else {                                //if not a leap year, calculate in the normal way, such as January or February
    DN = days[(m-1)]+d;
  }
  // Now start to calculate Week number
  w=calcDOW(d, m, y);
  if (w==0){


    WN = (DN-7+10)/7;             //if it is sunday (time library returns 0)
  }
  else{
    WN = (DN-w+10)/7;        // for the other days of week
  }
}


void playMelody (byte mel)
{
  displayOff();

  switch (mel)
  {
  case 0: 
#ifndef NO_VOICE
    // beep();
    sayTime();
#endif
    break;
  case 1: 
    playRtttl(song_1, 0); 
    break;
  case 2: 
    playRtttl(song_2, 0); 
    break;
  case 3: 
    playRtttl(song_3, 0); 
    break;
  case 4: 
    playRtttl(song_4, 0); 
    break;
  case 5: 
    playRtttl(song_5, 0); 
    break;
  case 6: 
    playRtttl(song_6, 0); 
    break;
  }
  //displayOn();
}

#ifndef NO_VOICE


/****************************************************************************\
 *                                                                            *
 * Solder Time II speech support                                              *
 *                                                                            *
 * by GoingDigital 2012                                                       *
 *                                                                            *
 * This is a hacked around version of the Talkie Speech Synthesis library,    *
 * which is a software emulation of the 80's Texas Instruments speech chips,  *
 * as used in Speak'n'Spell, TI99/4A, Acorn BBC Micro speech addon and others.*
 *                                                                            *
 * For more vocabulary, or an easy to use Arduino library version, check out  *
 * http://github.com/GoingDigital                                             *
 *                                                                            *
 * Speech sounds here are extracts from the Acorn Computers BBC Microcomputer *
 * Speech Synthesiser upgrade. This was famous at the time as the first ever  *
 * computer voice with an english accent. It was voiced by Kenneth Kendall,   *
 * a BBC newsreader of the era.                                               *
 *                                                                            *
 * Thanks to the MAME team for reverse engineering and documenting the        *
 * Texas Instruments TMS5220 series devices.                                  *
 *                                                                            *
 * Talkie is designed for a 16MHz clocked device. Unfortunately SolderTime is *
 * running at 8MHz, so the core synthesis code needs extra speed tweaks to    *
 * achieve real-time synthesis.                                               *
 \****************************************************************************/




// Speech vocabulary
// This data is in TMS5220 compressed format. Must be in PROGMEM.
//
// More speech segments with different voices are available from the Talkie library above.
//
#ifndef FEMALE_VOICE
// Male voice, from Acorn BBC Micro speech ROM (British english voice)
uint8_t spONE[]       PROGMEM = {
  0xA6,0x90,0x76,0xCC,0x43,0x6B,0xB9,0x42,0xD8,0x35,0x77,0xA9,0x19,0x72,0xE5,0x46,0xD2,0x62,0x56,0xCB,0xAC,0x9F,0x68,0xE1,0x4E,0x23,0x09,0x71,0x23,0x55,0x3A,0x9E,0xB8,0xC4,0x4B,0x77,0x6D,0x74,0xE3,0x93,0x54,0x7B,0xE5,0x6E,0x2D,0x4F,0xD6,0xEC,0x56,0x84,0xB5,0x3A,0x45,0x0D,0x5D,0xA1,0xD6,0xA8,0xF4,0xC5,0x58,0x84,0x78,0xEC,0x34,0x64,0x6D,0x16,0xEA,0x8D,0xC2,0x90,0x95,0x66,0xB1,0x25,0x0E,0x43,0x92,0x1A,0x43,0x9E,0x26,0x0C,0x49,0x49,0xB4,0x78,0xEA,0x34,0x16,0x1B,0xA6,0xEA,0xB1,0xC9,0x24,0x82,0xBB,0x88,0xC8,0x06,0x00,0xF8,0x26};
uint8_t spTWO[]       PROGMEM = {
  0x0E,0x58,0x56,0xCB,0x00,0xD7,0xAB,0x19,0xE0,0x38,0xCB,0xE6,0x0C,0x65,0x8A,0x61,0xAD,0x86,0x9D,0xA5,0x79,0xA4,0x2D,0x1E,0x6E,0x61,0x69,0x9A,0xF6,0x79,0x04,0x85,0xA4,0x6B,0xC8,0xEF,0x16,0x17,0x94,0xA1,0xC1,0xBB,0x5B,0x5E,0x61,0x86,0x05,0x7E,0x0A,0xA5,0x0A,0x25,0xA6,0x75,0x3A,0x34,0x8E,0x5F,0xA8,0xEB,0x4B,0xD7,0x49,0xBB,0xE6,0x12,0x8F,0xDD,0xE0,0xC5,0x78,0xB2,0xBC,0x36,0x83,0x15,0xEB,0x2E,0xF2,0x48,0x0D,0x46,0x9E,0x89,0xE9,0x2B,0x31,0xC8,0x32,0x2C,0x9E,0xAB,0xFF,0x5A,0x26};
uint8_t spTHREE[]     PROGMEM = {
  0x08,0xA8,0xC2,0x8C,0x02,0x04,0x68,0x2A,0xDC,0xF9,0x51,0x5B,0x96,0x79,0x8D,0x10,0xE5,0xCA,0x2E,0x9A,0x76,0x72,0xD0,0xC2,0x5C,0x25,0x21,0x23,0xCD,0x0C,0x4F,0xD4,0x22,0x7A,0x46,0x34,0x3E,0xF1,0x48,0x86,0xD2,0xB1,0xEA,0x24,0x33,0x16,0x62,0xE7,0xAA,0x55,0xAC,0xD4,0x04,0xD5,0x8D,0x47,0xB3,0x53,0x33,0xE4,0x2C,0x69,0xED,0x4E,0x81,0x30,0x53,0xA7,0xF5,0xBB,0x14,0x43,0xF4,0x92,0x36,0xEC,0x92,0x04,0xD5,0x4B,0xD2,0xB8,0xAB,0x23,0xF4,0x34,0xCE,0x63,0x19,0x57,0x73,0x84,0xAE,0x26,0x69,0x9C,0x8D,0xC0,0xAB,0x6B,0x87,0xB1,0x7B,0x94,0x99,0x8A,0xF2,0x5A,0x66};
uint8_t spFOUR[]      PROGMEM = {
  0x08,0xA8,0xCA,0x94,0x00,0x5D,0x84,0x31,0x20,0xA9,0x0A,0x05,0x54,0x1D,0x16,0xBC,0xAA,0xDC,0xC3,0xC4,0xCE,0x0A,0x92,0xDA,0x94,0xA0,0x4D,0xC7,0x4F,0x7C,0xDA,0x0B,0x73,0x9F,0x20,0xAA,0x2D,0x73,0xCE,0x75,0x92,0x28,0xB7,0x23,0xD9,0xF7,0xCA,0x82,0xB9,0x16,0xD3,0x5C,0xA3,0x88,0x7A,0x2A,0x83,0x72,0x8D,0x2E,0xEA,0xED,0x08,0xCC,0xD3,0x86,0x68,0xB6,0xCD,0x29,0x77,0x19,0xA3,0xDE,0xD6,0xA0,0xDE,0x65,0x0C,0x66,0x5B,0x82,0x73,0x97,0x31,0xD8,0x2D,0x0B,0xEA,0x53,0xC6,0x10,0xB6,0x24,0xB8,0x77,0x99,0x42,0x98,0x4C,0xE5,0xDC,0x6E,0x0A,0xA3,0x4C,0xC3,0x17,0xFE,0x5A,0x16};
uint8_t spFIVE[]      PROGMEM = {
  0x08,0xE8,0xD2,0x15,0x03,0x02,0xA8,0x3A,0x5D,0x01,0x55,0x96,0x0E,0x3F,0xA5,0x70,0xE7,0x98,0xBD,0x82,0xDC,0xDB,0x5D,0xAD,0xD6,0x0A,0x4A,0xF8,0x70,0xF5,0x86,0x27,0x2E,0xFE,0xD3,0xC5,0x6B,0x9D,0xB4,0xE9,0xAB,0x94,0x68,0x78,0xAA,0xEA,0x2F,0xC3,0xA3,0xF1,0xE9,0x6A,0xD8,0x88,0xF0,0xD9,0xA7,0x6F,0x61,0xA2,0xDC,0x66,0xAF,0xBE,0x85,0xB6,0x34,0x9B,0xB5,0xFA,0xEE,0x5D,0xD2,0x73,0xCE,0xEA,0xBB,0x33,0x8A,0xAC,0x3A,0x63,0xE8,0x56,0x29,0xAB,0xAB,0x94,0xBE,0x67,0x45,0xCB,0x9E,0x5D,0xFA,0xE6,0x04,0xB3,0x72,0x76,0xEA,0x8A,0x26,0x6F,0xCF,0x29,0xA9,0x4D,0xCA,0x34,0x3D,0x6A,0xC7,0xC1,0x0F,0xFF,0x5A,0x56};
uint8_t spSIX[]       PROGMEM = {
  0x04,0xF8,0x82,0x8D,0x03,0x0A,0xF8,0xCA,0xDC,0x01,0x5F,0x79,0x28,0xE0,0xEB,0x30,0x05,0x7C,0xED,0xBE,0xBC,0xAD,0x8A,0x34,0x62,0xD5,0x0D,0x4E,0xB4,0xDC,0x12,0x87,0x77,0x1A,0xD5,0x28,0x09,0x1E,0xBE,0x24,0x36,0xA8,0x15,0xCA,0xDD,0x45,0x64,0x03,0x80,0x01,0xF2,0x54,0x31,0xC0,0x57,0x15,0x02,0xF8,0xCA,0x8C,0x01,0xDF,0x58,0x12,0xE0,0x1B,0x0B,0x04,0x7C,0x2F,0x86,0x80,0xEF,0xD4,0xFE,0x5A,0x36};
uint8_t spSEVEN[]     PROGMEM = {
  0x08,0xF8,0x5C,0x9D,0x01,0x5F,0x78,0x08,0xE0,0x8B,0x74,0x05,0x7C,0x15,0xAE,0x81,0x61,0x57,0x6B,0x9A,0xDC,0x75,0x8E,0xD7,0x6D,0x48,0x89,0x2F,0x3E,0x41,0x0B,0xED,0x29,0x3A,0xFB,0x44,0xD5,0xA7,0x87,0xDA,0xA2,0x96,0xC4,0x50,0x11,0xCA,0xB5,0x54,0xAD,0x65,0x6A,0x88,0xB8,0x6A,0x6D,0x0E,0x63,0xC6,0xD6,0xB8,0x8D,0xB9,0x46,0x38,0xD9,0xEC,0x34,0xE5,0xAC,0x45,0xBE,0x75,0xC2,0x94,0x84,0x78,0xBB,0x37,0xB6,0x93,0x9E,0xC8,0x24,0x82,0xBB,0x88,0xC8,0x06,0x00,0x80,0xFF,0x5A,0x76};
uint8_t spEIGHT[]     PROGMEM = {
  0x23,0x1E,0xC5,0x58,0x33,0xA7,0x9E,0xA0,0x6A,0xF1,0xAD,0x9E,0xB2,0xE2,0xEE,0x49,0xAB,0x3A,0xCA,0x2A,0x66,0x72,0x94,0xE9,0xDA,0xBB,0x0A,0xC3,0x30,0x8C,0xB5,0x1D,0x5B,0x4C,0x42,0xB9,0xBB,0x88,0x6C,0x00,0x00,0x01,0x5C,0x91,0x26,0x01,0x04,0x14,0x9F,0xFA,0x5A,0x0E};
uint8_t spNINE[]      PROGMEM = {
  0xA1,0x4A,0x4C,0xF4,0x31,0xDD,0x85,0x32,0x71,0xB6,0xC7,0x74,0x97,0x8A,0xCC,0x54,0x1F,0xCB,0x5D,0xC9,0x33,0x35,0x7D,0xCC,0xE4,0x2D,0x6B,0x20,0xF9,0x58,0xEB,0x9F,0xA4,0xCB,0x56,0x13,0x6F,0x74,0xE2,0xAE,0x37,0x5C,0x3D,0xD1,0x89,0x9B,0xBD,0x74,0xF1,0x44,0x27,0x69,0xE6,0xDA,0xD5,0x13,0x9D,0xB4,0xAB,0x9B,0x10,0x4F,0x74,0xF2,0x29,0x67,0xC2,0x3C,0xE5,0x29,0xA7,0xE9,0xAA,0x90,0x54,0xA7,0x9A,0xBE,0x3D,0x52,0x5A,0x9D,0x66,0xC5,0x51,0x49,0x6B,0x74,0xDA,0x95,0x46,0x30,0xA2,0xD1,0xE8,0x66,0x2E,0xE4,0xCA,0xCA,0x6D,0x58,0x21,0x89,0x3A,0x23,0x87,0x21,0x73,0xB5,0x71,0x4D,0x6A,0x86,0x20,0x2C,0xCE,0xCD,0x89,0x1A,0x82,0xB0,0x5C,0xB5,0x24,0x6A,0x08,0x22,0x2A,0x2D,0x3D,0xAB,0x3E,0x4A,0xAD,0x34,0xF3,0xF5,0x5A,0x4E};
uint8_t spTWEN_[]     PROGMEM = {
  0x01,0x98,0xC1,0xC2,0x00,0xCD,0x4E,0x28,0xA0,0xCC,0x8A,0xE2,0xC7,0xA2,0x6E,0x16,0x8D,0x8E,0x57,0xBC,0x4B,0xBA,0xAF,0x3E,0x7E,0x0F,0x45,0xE1,0xDA,0xF9,0x04,0xD3,0x35,0x85,0x7A,0xAB,0x13,0x75,0xE5,0xD4,0x16,0x89,0x46,0xDC,0x94,0xD0,0x51,0xD9,0x4D,0x69,0x56,0x1C,0xC5,0xA9,0x8C,0xD4,0x42,0xB9,0xBB,0x88,0x6C,0x80,0xFF,0x66};
uint8_t spTHIR_[]     PROGMEM = {
  0x08,0xC8,0x22,0x19,0x01,0x4D,0x05,0x0B,0xA0,0x73,0x17,0x03,0x74,0xE1,0x96,0x9C,0x69,0x92,0x4B,0xCC,0xF1,0x08,0xA3,0x77,0x1E,0xAF,0xB2,0xC7,0x2F,0xD6,0xB4,0x2C,0x2F,0x1F,0xBF,0x9B,0xE0,0x0C,0x79,0x7C,0x82,0x6E,0x92,0x3D,0x64,0xF5,0x09,0x7B,0x70,0x09,0xD3,0x39,0x27,0xAA,0x8E,0x23,0xBD,0xAA,0xA6,0xB4,0x39,0x56,0xD3,0xAC,0x85,0x40,0xA1,0xDC,0x5D,0x44,0x36,0xFC,0x16};
uint8_t spFOUR_[]     PROGMEM = {
  0x08,0xA8,0xCA,0x94,0x00,0x5D,0x84,0x31,0x20,0xA9,0x0A,0x05,0x54,0x1D,0x16,0xBC,0xAA,0xDC,0xC3,0xC4,0xCE,0x0A,0x92,0xDA,0x94,0xA0,0x4D,0xC7,0x4F,0x7C,0xDA,0x0B,0x73,0x9F,0x20,0xAA,0x2D,0x73,0xCE,0xB5,0x92,0x60,0xAE,0xC5,0x34,0xD7,0xC8,0xA2,0x9E,0xCA,0xA0,0x5C,0x2D,0x8B,0x66,0xDB,0x9C,0x72,0xA7,0x22,0x98,0x6D,0x09,0xCE,0x6D,0x8A,0x30,0xCA,0x34,0x7C,0xE1,0xFF,0x56};
uint8_t spFIF_[]      PROGMEM = {
  0x08,0x28,0xD4,0x14,0x03,0x06,0x68,0x2A,0x74,0x79,0xCD,0x30,0x75,0xFB,0xE4,0x13,0x4C,0x1D,0xC8,0x13,0xAB,0x4E,0xD0,0x9D,0x62,0x94,0x4F,0x29,0x51,0x53,0x4A,0x9E,0x3E,0x59,0x00,0x4D,0x98,0x28,0x60,0x99,0x54,0x0D,0x20,0x50,0x28,0x77,0x17,0x91,0x0D,0xF0,0x36};
uint8_t spSIX_[]      PROGMEM = {
  0x04,0xF8,0x82,0x8D,0x03,0x0A,0xF8,0xCA,0xDC,0x01,0x5F,0x79,0x28,0xE0,0x6B,0xF7,0xE5,0x6D,0x55,0xA4,0x11,0xAB,0x4E,0xB4,0xDC,0x12,0x87,0x77,0x0A,0xCD,0x28,0x09,0x1E,0xBE,0x04,0xB5,0x42,0xB9,0xBB,0x88,0x6C,0x00,0x06,0xE4,0xA9,0x22,0x80,0xAF,0xCC,0x08,0xF0,0x8D,0x25,0x06,0xFE,0x76};
uint8_t spSEVEN_[]    PROGMEM = {
  0x08,0xF8,0x5C,0x9D,0x01,0x5F,0x78,0x08,0xE0,0x8B,0x74,0x05,0x7C,0x15,0xAE,0x81,0x61,0x57,0x6B,0x9A,0xDC,0x75,0x4E,0xD0,0x42,0x7B,0x8A,0xCE,0xBE,0x41,0x4B,0x62,0xA8,0x08,0xE5,0x5A,0xAA,0xD6,0x32,0x35,0x44,0x5C,0xB5,0x36,0x87,0x31,0x63,0x6B,0xDC,0xDB,0x34,0xE6,0x1A,0xE1,0x64,0xB3,0xC3,0x94,0xB3,0x16,0xF9,0xD6,0x71,0x53,0x12,0xE2,0xED,0xDE,0xF8,0xFF,0x0E};
uint8_t spEIGH_[]     PROGMEM = {
  0x23,0x1E,0xC5,0x58,0x33,0xA7,0x9E,0xA0,0x6A,0xF1,0xAD,0x9E,0xB2,0xE2,0xEE,0x49,0xAB,0x3A,0xCA,0x2A,0x66,0x72,0x94,0xE9,0xDA,0xBB,0x0A,0xC3,0x30,0x8C,0xB5,0x1D,0x5B,0x4C,0x42,0xB9,0xBB,0x88,0x6C,0x00,0x80,0xFF,0x4E};
uint8_t spNINE_[]     PROGMEM = {
  0xA1,0x4A,0x4C,0xF4,0x31,0xDD,0x85,0x32,0x71,0xB6,0xC7,0x74,0x57,0xF2,0x4C,0x4D,0x1F,0x33,0x79,0xCB,0x1A,0x48,0x3E,0xD6,0xFA,0x27,0xE9,0xB2,0xD5,0xC4,0x1B,0x9D,0xB8,0xD9,0x4B,0x17,0x4F,0x74,0xD2,0xAE,0x6E,0x42,0x3C,0xD1,0x29,0xA7,0xE9,0xAA,0x90,0x54,0xA7,0x9A,0xBE,0x3D,0x52,0x5A,0x9D,0x66,0xC5,0x51,0x49,0x6B,0x74,0xDA,0x95,0x46,0x30,0xA2,0xD1,0xE8,0x66,0x2E,0xE4,0xCA,0xCA,0x6D,0x58,0x21,0x89,0x3A,0x23,0x87,0x21,0x73,0xB5,0x71,0x4D,0x6A,0x86,0x20,0x2C,0xCE,0xCD,0xC9,0xFF,0x41};
uint8_t sp_TEEN[]     PROGMEM = {
  0xA0,0x80,0x25,0x5C,0x14,0x70,0x5C,0x71,0x89,0x87,0x21,0xCA,0x19,0xDB,0x2D,0xE9,0x8E,0xA8,0x77,0xA2,0x8C,0x64,0x06,0x01,0xDF,0xAA,0x3C,0xEB,0xD6,0xAE,0xA4,0x20,0x3B,0xB3,0x4B,0x3F,0x12,0x48,0x5E,0xC5,0x29,0xC3,0x4C,0x48,0x76,0x5D,0xBB,0x0C,0x23,0xA2,0xC4,0x75,0xE4,0x32,0x64,0xAE,0x36,0xAE,0x49,0xC3,0x10,0x84,0xC5,0xB9,0x39,0x71,0x43,0x10,0x96,0xAB,0x96,0x44,0x0D,0x59,0x72,0x96,0x59,0x6A,0x31,0x74,0x19,0xE6,0x66,0xB6,0xFF,0x09,0x15,0x5A};
uint8_t sp_T[]        PROGMEM = {
  0x04,0x68,0x24,0xC4,0x01,0x07,0x44,0x1A,0xA0,0x42,0xE3,0xD1,0x0C,0x67,0x68,0x36,0xB5,0x5B,0x3F,0xBC,0x91,0x47,0xCD,0x49,0xD3,0x70,0x4A,0x91,0x35,0x3B,0x2F,0xFF,0x2D,0x5A};
uint8_t spOCLOCK[]    PROGMEM = {
  0x2B,0xAB,0xA6,0xC3,0x9D,0x37,0xAF,0x3C,0x87,0x0C,0x17,0x79,0xD5,0x8A,0x38,0x9D,0xDD,0x7A,0x16,0x2A,0x84,0x72,0x77,0x11,0xD9,0x00,0x00,0x06,0x28,0xA5,0x3B,0x00,0x5D,0x6B,0xA4,0x60,0x59,0x0D,0x09,0x55,0x32,0xBC,0xA4,0x35,0x4B,0xAD,0xD1,0x70,0x73,0xF6,0x16,0xD7,0x29,0x2B,0xCC,0xAD,0xCA,0x4D,0x67,0xAD,0x2C,0xF5,0xAE,0x50,0x9D,0x38,0x86,0xD4,0x3B,0x4B,0x65,0x65,0x98,0xD2,0x4B,0x75,0xF3,0xDA,0x64,0x12,0xCA,0xDD,0x45,0x64,0x03,0x00,0x00,0x28,0x20,0x15,0x23,0x02,0xE4,0xE4,0x8C,0x80,0x2C,0x07,0xFE,0x31,0x79};
uint8_t spO[]         PROGMEM = {
  0x2B,0xC9,0x21,0xCD,0x2C,0x1F,0xEE,0xE4,0xA4,0xC5,0x54,0x9A,0xE9,0xA6,0x9B,0xAE,0x2C,0xBB,0x4A,0x55,0xDB,0xB4,0xB3,0x95,0xA7,0xD4,0x2E,0xEA,0xAB,0x67,0xDE,0xF2,0x68,0xC7,0x4D,0x74,0x63,0x29,0x82,0x5E,0x4F,0xD4,0x9D,0xB9,0x08,0x95,0xB1,0xE7,0x2E,0xB6,0xD1,0x57,0xA6,0x52,0x69,0xD4,0xB5,0x16,0xAA,0xCA,0xB7,0x54,0xE1,0x1C,0xFD,0x69,0x61,0x79,0x19,0x61,0x72,0x79};
uint8_t spZERO[]      PROGMEM = {
  0xA2,0x2B,0x20,0x2D,0xAA,0x1A,0xAA,0xB6,0x81,0xD4,0x88,0x72,0xAC,0x80,0x8F,0xC4,0x34,0x90,0xAA,0x8F,0x44,0xD5,0x43,0x4D,0xCB,0x16,0x33,0x8C,0xB6,0x44,0x23,0x9A,0xDC,0x21,0xA7,0x6B,0xAD,0x60,0x28,0x83,0x9C,0x9E,0x75,0x82,0x69,0x12,0x74,0xB2,0xD1,0xF1,0x87,0x74,0xAA,0x89,0x46,0x27,0x18,0x36,0x39,0x5C,0x17,0x9D,0x60,0xA8,0x92,0x34,0x5B,0xB4,0xA2,0xA6,0xCA,0xD2,0x7D,0xD1,0x88,0x73,0xB6,0xF2,0xA8,0x96,0x23,0xCD,0x83,0x4D,0x23,0x5D,0xB7,0x2C,0x0F,0x74,0xF3,0xC8,0xDC,0x8A,0x5C,0xA9,0xA4,0x3B,0x55,0xAB,0x73,0xE5,0xE2,0x3A,0xD7,0x6D,0x2C,0x49,0x8B,0x3D,0x6F,0x95,0xB1,0x78,0x4D,0xD7,0x78,0x94,0xA6,0x64,0xC3,0x33,0xE2,0x52,0x9A,0x92,0x8D,0x08,0xF3,0x4B,0x61,0x4A,0x31,0xDC,0xB8,0x26,0xBB,0x25,0x05,0x77,0x95,0x7A,0xF4,0x06,0x06};
uint8_t spHUNDRED[]   PROGMEM = {
  0xA2,0x6D,0x76,0xD2,0x5D,0x1B,0xE9,0x62,0xFB,0xD7,0x3F,0x7E,0xB7,0x69,0x05,0x9E,0x7A,0x04,0x95,0xBB,0xAC,0x64,0xE2,0x11,0x35,0x9C,0x7C,0xE2,0x49,0x4A,0x1C,0xA5,0xC5,0x52,0xB9,0x0E,0x89,0xD5,0x56,0xA1,0x63,0x4B,0x16,0xA1,0x2D,0x21,0xCD,0x84,0x23,0x85,0xB6,0xD7,0x11,0x75,0x93,0xDD,0xDA,0x52,0x38,0xC9,0xAA,0x75,0xEB,0xB3,0xA3,0xF2,0xC8,0xC6,0xA5,0x2F,0x8E,0xCA,0x33,0x16,0x85,0xB1,0x58,0xAA,0xC8,0x6A,0x28,0xA6,0x2C,0x45,0xC3,0xB3,0x31,0x99,0x84,0x72,0x77,0x11,0xD9,0x60,0xA6,0x6D,0xDC,0xC5,0xD4,0xCD,0xFF,0x06,0x06,0x06};
uint8_t spTEN[]       PROGMEM = {
  0x0E,0x38,0xD4,0x53,0x01,0x8B,0x85,0x68,0x60,0x05,0xDD,0x29,0x5B,0xBA,0xE9,0x1B,0x9D,0x68,0xE6,0x62,0x73,0x6F,0x7C,0xA2,0x19,0x46,0x34,0xBC,0xD1,0x49,0x56,0x68,0xD1,0xB4,0xC5,0x27,0x1F,0x39,0xC5,0xCD,0x67,0x9F,0xB2,0x3B,0xD3,0x8C,0x9C,0x33,0x9A,0xEE,0x4C,0x5D,0x62,0x4E,0xEA,0xAB,0x61,0x4B,0x49,0xB9,0xA9,0xCF,0x4A,0xBC,0x34,0xED,0x84,0x21,0x69,0x4D,0xD7,0x74,0x15,0x86,0x24,0xDC,0xCA,0x4A,0xB1,0x1B,0x92,0x94,0x28,0x4B,0x55,0x6E,0x48,0x52,0xC2,0x33,0x55,0xFF,0x69,0x39,0x41,0x09,0x15};
uint8_t spELEVEN[]    PROGMEM = {
  0x25,0xED,0x5A,0x29,0x36,0xAB,0x8C,0xAC,0x1B,0xC3,0xD8,0x5A,0xB8,0xE2,0x41,0x5C,0xEC,0x32,0xD3,0x48,0x07,0x56,0xB5,0xB2,0x34,0x2D,0xA9,0xC0,0xC3,0x3A,0x56,0xB5,0xA4,0x80,0x08,0xED,0x6C,0xD5,0xE2,0x0E,0xDC,0xB9,0xA3,0xE5,0x09,0x06,0x77,0xEE,0xB4,0x45,0x27,0x1A,0xA2,0x34,0xD2,0x16,0x9D,0xA8,0xCB,0xB4,0x72,0x7F,0x74,0x92,0xAE,0xC7,0xDD,0x78,0x51,0xCB,0x4B,0x2C,0x0F,0x96,0xDA,0xA1,0x69,0xAA,0x2C,0x84,0x63,0xBB,0xB9,0xF1,0x52,0x57,0x4E,0x9C,0xC6,0x5C,0x23,0x9C,0x6C,0x76,0x98,0x72,0xD6,0x22,0xDF,0x3A,0x66,0x4A,0x42,0xBC,0xDD,0x1B,0xDB,0x09,0x8D,0x22,0xB8,0x8B,0x88,0x6C,0x00,0x80,0xFF,0x11,0x51,0x71,0x41,0x71,0x39,0x51};
uint8_t spTWELVE[]    PROGMEM = {
  0x06,0x58,0xCA,0xCC,0x00,0x4D,0x57,0x09,0xA0,0xC4,0x88,0xE4,0x85,0x1A,0x66,0xEA,0xAB,0x9A,0x1F,0x6B,0xAB,0x8B,0x6E,0x3A,0x7E,0x71,0xA3,0x6E,0xBC,0xF9,0x84,0xD5,0x8D,0xBA,0xCB,0xCA,0x13,0x35,0xD5,0xEA,0xA9,0x9B,0x4E,0xD2,0xED,0x78,0x18,0xAD,0x3A,0x45,0x0D,0xE5,0xC9,0xB6,0x7A,0x0C,0x25,0xB6,0x25,0xC5,0xED,0x32,0xE4,0xD6,0x16,0x54,0xB7,0xCB,0x9C,0x83,0x57,0x50,0x2D,0x2A,0x6B,0x76,0x9E,0x89,0xBE,0xAA,0x2C,0x29,0x64,0x18,0x59,0xEA,0xB2,0x24,0x9F,0x69,0xE8,0xA9,0xD3,0x12,0x8D,0x75,0xB1,0x75,0x4D,0x4B,0x8C,0x5E,0x46,0xD6,0x3A,0xCD,0xC1,0xB5,0x86,0xF8,0x66,0x04,0xB0,0x16,0x4A,0x80,0xA2,0xCB,0x10,0x50,0x55,0xDB,0xFF,0x51,0x05,0x4D,0x15};
#else
// Female voice, from talking clock speech ROM (American english voice)
uint8_t spTHE[]       PROGMEM = {
  0x08,0xE8,0x3E,0x55,0x01,0xC3,0x86,0x27,0xAF,0x72,0x0D,0x4D,0x97,0xD5,0xBC,0x64,0x3C,0xF2,0x5C,0x51,0xF1,0x93,0x36,0x8F,0x4F,0x59,0x2A,0x42,0x7A,0x32,0xC3,0x64,0xFF,0x3F};
uint8_t spTIME[]      PROGMEM = {
  0x0E,0x28,0xAC,0x2D,0x01,0x5D,0xB6,0x0D,0x33,0xF3,0x54,0xB3,0x60,0xBA,0x8C,0x54,0x5C,0xCD,0x2D,0xD4,0x32,0x73,0x0F,0x8E,0x34,0x33,0xCB,0x4A,0x25,0xD4,0x25,0x83,0x2C,0x2B,0xD5,0x50,0x97,0x08,0x32,0xEC,0xD4,0xDC,0x4C,0x33,0xC8,0x70,0x73,0x0F,0x33,0xCD,0x20,0xC3,0xCB,0x43,0xDD,0x3C,0xCD,0x8C,0x20,0x77,0x89,0xF4,0x94,0xB2,0xE2,0xE2,0x35,0x22,0x5D,0xD6,0x4A,0x8A,0x96,0xCC,0x36,0x25,0x2D,0xC9,0x9A,0x7B,0xC2,0x18,0x87,0x24,0x4B,0x1C,0xC9,0x50,0x19,0x92,0x2C,0x71,0x34,0x4B,0x45,0x8A,0x8B,0xC4,0x96,0xB6,0x5A,0x29,0x2A,0x92,0x5A,0xCA,0x53,0x96,0x20,0x05,0x09,0xF5,0x92,0x5D,0xBC,0xE8,0x58,0x4A,0xDD,0xAE,0x73,0xBD,0x65,0x4B,0x8D,0x78,0xCA,0x2B,0x4E,0xD8,0xD9,0xED,0x22,0x20,0x06,0x75,0x00,0x00,0x80,0xFF,0x07};
uint8_t spIS[]        PROGMEM = {
  0x21,0x18,0x96,0x38,0xB7,0x14,0x8D,0x60,0x3A,0xA6,0xE8,0x51,0xB4,0xDC,0x2E,0x48,0x7B,0x5A,0xF1,0x70,0x1B,0xA3,0xEC,0x09,0xC6,0xCB,0xEB,0x92,0x3D,0xA7,0x69,0x1F,0xAF,0x71,0x89,0x9C,0xA2,0xB3,0xFC,0xCA,0x35,0x72,0x9A,0xD1,0xF0,0xAB,0x12,0xB3,0x2B,0xC6,0xCD,0x4F,0xCC,0x32,0x26,0x19,0x07,0xDF,0x0B,0x8F,0xB8,0xA4,0xED,0x7C,0xCF,0x23,0x62,0x8B,0x8E,0xF1,0x23,0x0A,0x8B,0x6E,0xCB,0xCE,0xEF,0x54,0x44,0x3C,0xDC,0x08,0x60,0x0B,0x37,0x01,0x1C,0x53,0x26,0x80,0x15,0x4E,0x14,0xB0,0x54,0x2B,0x02,0xA4,0x69,0xFF,0x7F};
uint8_t spOH[]        PROGMEM = {
  0xC6,0xC9,0x71,0x5A,0xA2,0x92,0x14,0x2F,0x6E,0x97,0x9C,0x46,0x9D,0xDC,0xB0,0x4D,0x62,0x1B,0x55,0x70,0xDD,0x55,0xBE,0x0E,0x36,0xC1,0x33,0x37,0xA9,0xA7,0x51,0x1B,0xCF,0x3C,0xA5,0x9E,0x44,0xAC,0x3C,0x7D,0x98,0x7B,0x52,0x96,0x72,0x65,0x4B,0xF6,0x1A,0xD9,0xCA,0xF5,0x91,0x2D,0xA2,0x2A,0x4B,0xF7,0xFF,0x01};
uint8_t spOCLOCK[]    PROGMEM = {
  0x21,0x4E,0x3D,0xB8,0x2B,0x19,0xBB,0x24,0x0E,0xE5,0xEC,0x60,0xE4,0xF2,0x90,0x13,0xD4,0x2A,0x11,0x80,0x00,0x42,0x69,0x26,0x40,0xD0,0x2B,0x04,0x68,0xE0,0x4D,0x00,0x3A,0x35,0x35,0x33,0xB6,0x51,0xD9,0x64,0x34,0x82,0xB4,0x9A,0x63,0x92,0x55,0x89,0x52,0x5B,0xCA,0x2E,0x34,0x25,0x4E,0x63,0x28,0x3A,0x50,0x95,0x26,0x8D,0xE6,0xAA,0x64,0x58,0xEA,0x92,0xCE,0xC2,0x46,0x15,0x9B,0x86,0xCD,0x2A,0x2E,0x37,0x00,0x00,0x00,0x0C,0xC8,0xDD,0x05,0x01,0xB9,0x33,0x21,0xA0,0x74,0xD7,0xFF,0x07};
uint8_t spONE[]       PROGMEM = {
  0xCC,0x67,0x75,0x42,0x59,0x5D,0x3A,0x4F,0x9D,0x36,0x63,0xB7,0x59,0xDC,0x30,0x5B,0x5C,0x23,0x61,0xF3,0xE2,0x1C,0xF1,0xF0,0x98,0xC3,0x4B,0x7D,0x39,0xCA,0x1D,0x2C,0x2F,0xB7,0x15,0xEF,0x70,0x79,0xBC,0xD2,0x46,0x7C,0x52,0xE5,0xF1,0x4A,0x6A,0xB3,0x71,0x47,0xC3,0x2D,0x39,0x34,0x4B,0x23,0x35,0xB7,0x7A,0x55,0x33,0x8F,0x59,0xDC,0xA2,0x44,0xB5,0xBC,0x66,0x72,0x8B,0x64,0xF5,0xF6,0x98,0xC1,0x4D,0x42,0xD4,0x27,0x62,0x38,0x2F,0x4A,0xB6,0x9C,0x88,0x68,0xBC,0xA6,0x95,0xF8,0x5C,0xA1,0x09,0x86,0x77,0x91,0x11,0x5B,0xFF,0x0F};
uint8_t spTWO[]       PROGMEM = {
  0x0E,0x38,0x6E,0x25,0x00,0xA3,0x0D,0x3A,0xA0,0x37,0xC5,0xA0,0x05,0x9E,0x56,0x35,0x86,0xAA,0x5E,0x8C,0xA4,0x82,0xB2,0xD7,0x74,0x31,0x22,0x69,0xAD,0x1C,0xD3,0xC1,0xD0,0xFA,0x28,0x2B,0x2D,0x47,0xC3,0x1B,0xC2,0xC4,0xAE,0xC6,0xCD,0x9C,0x48,0x53,0x9A,0xFF,0x0F};
uint8_t spTHREE[]     PROGMEM = {
  0x02,0xD8,0x2E,0x9C,0x01,0xDB,0xA6,0x33,0x60,0xFB,0x30,0x01,0xEC,0x20,0x12,0x8C,0xE4,0xD8,0xCA,0x32,0x96,0x73,0x63,0x41,0x39,0x89,0x98,0xC1,0x4D,0x0D,0xED,0xB0,0x2A,0x05,0x37,0x0F,0xB4,0xA5,0xAE,0x5C,0xDC,0x36,0xD0,0x83,0x2F,0x4A,0x71,0x7B,0x03,0xF7,0x38,0x59,0xCD,0xED,0x1E,0xB4,0x6B,0x14,0x35,0xB7,0x6B,0x94,0x99,0x91,0xD5,0xDC,0x26,0x48,0x77,0x4B,0x66,0x71,0x1B,0x21,0xDB,0x2D,0x8A,0xC9,0x6D,0x88,0xFC,0x26,0x28,0x3A,0xB7,0x21,0xF4,0x1F,0xA3,0x65,0xBC,0x02,0x38,0xBB,0x3D,0x8E,0xF0,0x2B,0xE2,0x08,0xB7,0x34,0xFF,0x0F};
uint8_t spFOUR[]      PROGMEM = {
  0x0C,0x18,0xB6,0x9A,0x01,0xC3,0x75,0x09,0x60,0xD8,0x0E,0x09,0x30,0xA0,0x9B,0xB6,0xA0,0xBB,0xB0,0xAA,0x16,0x4E,0x82,0xEB,0xEA,0xA9,0xFA,0x59,0x49,0x9E,0x59,0x23,0x9A,0x27,0x3B,0x78,0x66,0xAE,0x4A,0x9C,0x9C,0xE0,0x99,0xD3,0x2A,0xBD,0x72,0x92,0xEF,0xE6,0x88,0xE4,0x45,0x4D,0x7E,0x98,0x2D,0x62,0x67,0x37,0xF9,0xA1,0x37,0xA7,0x6C,0x94,0xE4,0xC7,0x1E,0xDC,0x3C,0xA5,0x83,0x1F,0x8B,0xEB,0x52,0x0E,0x0E,0x7E,0x2E,0x4E,0xC7,0x31,0xD2,0x79,0xA5,0x3A,0x0D,0xD9,0xC4,0xFF,0x07};
uint8_t spFIVE[]      PROGMEM = {
  0x02,0xE8,0x3E,0x8C,0x01,0xDD,0x65,0x08,0x60,0x98,0x4C,0x06,0x34,0x93,0xCE,0x80,0xE6,0xDA,0x9A,0x14,0x6B,0xAA,0x47,0xD1,0x5E,0x56,0xAA,0x6D,0x56,0xCD,0x78,0xD9,0xA9,0x1C,0x67,0x05,0x83,0xE1,0xA4,0xBA,0x38,0xEE,0x16,0x86,0x9B,0xFA,0x60,0x87,0x5B,0x18,0x6E,0xEE,0x8B,0x1D,0x6E,0x61,0xB9,0x69,0x36,0x65,0xBA,0x8D,0xE5,0xE5,0x3E,0x1C,0xE9,0x0E,0x96,0x9B,0x5B,0xAB,0x95,0x2B,0x58,0x6E,0xCE,0xE5,0x3A,0x6A,0xF3,0xB8,0x35,0x84,0x7B,0x05,0xA3,0xE3,0x36,0xEF,0x92,0x19,0xB4,0x86,0xDB,0xB4,0x69,0xB4,0xD1,0x2A,0x4E,0x65,0x9A,0x99,0xCE,0x28,0xD9,0x85,0x71,0x4C,0x18,0x6D,0x67,0x47,0xC6,0x5E,0x53,0x4A,0x9C,0xB5,0xE2,0x85,0x45,0x26,0xFE,0x7F};
uint8_t spSIX[]       PROGMEM = {
  0x0E,0xD8,0xAE,0xDD,0x03,0x0E,0x38,0xA6,0xD2,0x01,0xD3,0xB4,0x2C,0xAD,0x6A,0x35,0x9D,0xB1,0x7D,0xDC,0xEE,0xC4,0x65,0xD7,0xF1,0x72,0x47,0x24,0xB3,0x19,0xD9,0xD9,0x05,0x70,0x40,0x49,0xEA,0x02,0x98,0xBE,0x42,0x01,0xDF,0xA4,0x69,0x40,0x00,0xDF,0x95,0xFC,0x3F};
uint8_t spSEVEN[]     PROGMEM = {
  0x02,0xB8,0x3A,0x8C,0x01,0xDF,0xA4,0x73,0x40,0x01,0x47,0xB9,0x2F,0x33,0x3B,0x73,0x5F,0x53,0x7C,0xEC,0x9A,0xC5,0x63,0xD5,0xD1,0x75,0xAE,0x5B,0xFC,0x64,0x5C,0x35,0x87,0x91,0xF1,0x83,0x36,0xB5,0x68,0x55,0xC5,0x6F,0xDA,0x45,0x2D,0x1C,0x2D,0xB7,0x38,0x37,0x9F,0x60,0x3C,0xBC,0x9A,0x85,0xA3,0x25,0x66,0xF7,0x8A,0x57,0x1C,0xA9,0x67,0x56,0xCA,0x5E,0xF0,0xB2,0x16,0xB2,0xF1,0x89,0xCE,0x8B,0x92,0x25,0xC7,0x2B,0x33,0xCF,0x48,0xB1,0x99,0xB4,0xF3,0xFF};
uint8_t spEIGHT[]     PROGMEM = {
  0xC3,0x6C,0x86,0xB3,0x27,0x6D,0x0F,0xA7,0x48,0x99,0x4E,0x55,0x3C,0xBC,0x22,0x65,0x36,0x4D,0xD1,0xF0,0x32,0xD3,0xBE,0x34,0xDA,0xC3,0xEB,0x82,0xE2,0xDA,0x65,0x35,0xAF,0x31,0xF2,0x6B,0x97,0x95,0xBC,0x86,0xD8,0x6F,0x82,0xA6,0x73,0x0B,0xC6,0x9E,0x72,0x99,0xCC,0xCB,0x02,0xAD,0x3C,0x9A,0x10,0x60,0xAB,0x62,0x05,0x2C,0x37,0x84,0x00,0xA9,0x73,0x00,0x00,0xFE,0x1F};
uint8_t spNINE[]      PROGMEM = {
  0xCC,0xA1,0x26,0xBB,0x83,0x93,0x18,0xCF,0x4A,0xAD,0x2E,0x31,0xED,0x3C,0xA7,0x24,0x26,0xC3,0x54,0xF1,0x92,0x64,0x8B,0x8A,0x98,0xCB,0x2B,0x2E,0x34,0x53,0x2D,0x0E,0x2F,0x57,0xB3,0x0C,0x0D,0x3C,0xBC,0x3C,0x4C,0x4B,0xCA,0xF4,0xF0,0x72,0x0F,0x6E,0x49,0x53,0xCD,0xCB,0x53,0x2D,0x35,0x4D,0x0F,0x2F,0x0F,0xD7,0x0C,0x0D,0x3D,0xBC,0xDC,0x4D,0xD3,0xDD,0xC2,0xF0,0x72,0x52,0x4F,0x57,0x9B,0xC3,0xAB,0x89,0xBD,0x42,0x2D,0x0F,0xAF,0x5A,0xD1,0x71,0x91,0x55,0xBC,0x2C,0xC5,0x3B,0xD8,0x65,0xF2,0x82,0x94,0x18,0x4E,0x3B,0xC1,0x73,0x42,0x32,0x33,0x15,0x45,0x4F,0x79,0x52,0x6A,0x55,0xA6,0xA3,0xFF,0x07};
uint8_t spTEN[]       PROGMEM = {
  0x0E,0xD8,0xB1,0xDD,0x01,0x3D,0xA8,0x24,0x7B,0x04,0x27,0x76,0x77,0xDC,0xEC,0xC2,0xC5,0x23,0x84,0xCD,0x72,0x9A,0x51,0xF7,0x62,0x45,0xC7,0xEB,0x4E,0x35,0x4A,0x14,0x2D,0xBF,0x45,0xB6,0x0A,0x75,0xB8,0xFC,0x16,0xD9,0x2A,0xD9,0xD6,0x0A,0x5A,0x10,0xCD,0xA2,0x48,0x23,0xA8,0x81,0x35,0x4B,0x2C,0xA7,0x20,0x69,0x0A,0xAF,0xB6,0x15,0x82,0xA4,0x29,0x3C,0xC7,0x52,0x08,0xA2,0x22,0xCF,0x68,0x4B,0x2E,0xF0,0x8A,0xBD,0xA3,0x2C,0xAB,0x40,0x1B,0xCE,0xAA,0xB2,0x6C,0x82,0x40,0x4D,0x7D,0xC2,0x89,0x88,0x8A,0x61,0xCC,0x74,0xD5,0xFF,0x0F};
uint8_t spELEVEN[]    PROGMEM = {
  0xC3,0xCD,0x76,0x5C,0xAE,0x14,0x0F,0x37,0x9B,0x71,0xDE,0x92,0x55,0xBC,0x2C,0x27,0x70,0xD3,0x76,0xF0,0x83,0x5E,0xA3,0x5E,0x5A,0xC1,0xF7,0x61,0x58,0xA7,0x19,0x35,0x3F,0x99,0x31,0xDE,0x52,0x74,0xFC,0xA2,0x26,0x64,0x4B,0xD1,0xF1,0xAB,0xAE,0xD0,0x2D,0xC5,0xC7,0x2F,0x36,0xDD,0x27,0x15,0x0F,0x3F,0xD9,0x08,0x9F,0x62,0xE4,0xC2,0x2C,0xD4,0xD8,0xD3,0x89,0x0B,0x1B,0x57,0x11,0x0B,0x3B,0xC5,0xCF,0xD6,0xCC,0xC6,0x64,0x35,0xAF,0x18,0x73,0x1F,0xA1,0x5D,0xBC,0x62,0x45,0xB3,0x45,0x51,0xF0,0xA2,0x62,0xAB,0x4A,0x5B,0xC9,0x4B,0x8A,0x2D,0xB3,0x6C,0x06,0x2F,0x29,0xB2,0xAC,0x8A,0x18,0xBC,0x28,0xD9,0xAA,0xD2,0x92,0xF1,0xBC,0xE0,0x98,0x8C,0x48,0xCC,0x17,0x52,0xA3,0x27,0x6D,0x93,0xD0,0x4B,0x8E,0x0E,0x77,0x02,0x00,0xFF,0x0F};
uint8_t spTWELVE[]    PROGMEM = {
  0x06,0x28,0x46,0xD3,0x01,0x25,0x06,0x13,0x20,0xBA,0x70,0x70,0xB6,0x79,0xCA,0x36,0xAE,0x28,0x38,0xE1,0x29,0xC5,0x35,0xA3,0xE6,0xC4,0x16,0x6A,0x53,0x8C,0x97,0x9B,0x72,0x86,0x4F,0x28,0x1A,0x6E,0x0A,0x59,0x36,0xAE,0x68,0xF8,0x29,0x67,0xFA,0x06,0xA3,0x16,0xC4,0x96,0xE6,0x53,0xAC,0x5A,0x9C,0x56,0x72,0x77,0x31,0x4E,0x49,0x5C,0x8D,0x5B,0x29,0x3B,0x24,0x61,0x1E,0x6C,0x9B,0x6C,0x97,0xF8,0xA7,0x34,0x19,0x92,0x4C,0x62,0x9E,0x72,0x65,0x58,0x12,0xB1,0x7E,0x09,0xD5,0x2E,0x53,0xC5,0xBA,0x36,0x6B,0xB9,0x2D,0x17,0x05,0xEE,0x9A,0x6E,0x8E,0x05,0x50,0x6C,0x19,0x07,0x18,0x50,0xBD,0x3B,0x01,0x92,0x08,0x41,0x40,0x10,0xA6,0xFF,0x0F};
uint8_t spTHIRTEEN[]  PROGMEM = {
  0x08,0xE8,0x2C,0x15,0x01,0x43,0x07,0x13,0xE0,0x98,0xB4,0xA6,0x35,0xA9,0x1E,0xDE,0x56,0x8E,0x53,0x9C,0x7A,0xE7,0xCA,0x5E,0x76,0x8D,0x94,0xE5,0x2B,0xAB,0xD9,0xB5,0x62,0xA4,0x9C,0xE4,0xE6,0xB4,0x41,0x1E,0x7C,0xB6,0x93,0xD7,0x16,0x99,0x5A,0xCD,0x61,0x76,0x55,0xC2,0x91,0x61,0x1B,0xC0,0x01,0x5D,0x85,0x05,0xE0,0x68,0x51,0x07,0x1C,0xA9,0x64,0x80,0x1D,0x4C,0x9C,0x95,0x88,0xD4,0x04,0x3B,0x4D,0x4E,0x21,0x5C,0x93,0xA8,0x26,0xB9,0x05,0x4B,0x6E,0xA0,0xE2,0xE4,0x57,0xC2,0xB9,0xC1,0xB2,0x93,0x5F,0x09,0xD7,0x24,0xCB,0x4E,0x41,0x25,0x54,0x1D,0x62,0x3B,0x05,0x8D,0x52,0x57,0xAA,0xAD,0x10,0x24,0x26,0xE3,0xE1,0x36,0x5D,0x10,0x85,0xB4,0x97,0x85,0x72,0x41,0x14,0x52,0x5E,0x1A,0xCA,0xF9,0x91,0x6B,0x7A,0x5B,0xC4,0xE0,0x17,0x2D,0x54,0x1D,0x92,0x8C,0x1F,0x25,0x4B,0x8F,0xB2,0x16,0x41,0xA1,0x4A,0x3E,0xE6,0xFA,0xFF,0x01};
uint8_t spFOURTEEN[]  PROGMEM = {
  0x0C,0x58,0xAE,0x5C,0x01,0xD9,0x87,0x07,0x51,0xB7,0x25,0xB3,0x8A,0x15,0x2C,0xF7,0x1C,0x35,0x87,0x4D,0xB2,0xDD,0x53,0xCE,0x28,0x2B,0xC9,0x0E,0x97,0x2D,0xBD,0x2A,0x17,0x27,0x76,0x8E,0xD2,0x9A,0x6C,0x80,0x94,0x71,0x00,0x00,0x02,0xB0,0x58,0x58,0x00,0x9E,0x0B,0x0A,0xC0,0xB2,0xCE,0xC1,0xC8,0x98,0x7A,0x52,0x95,0x24,0x2B,0x11,0xED,0x36,0xD4,0x92,0xDC,0x4C,0xB5,0xC7,0xC8,0x53,0xF1,0x2A,0xE5,0x1A,0x17,0x55,0xC5,0xAF,0x94,0xBB,0xCD,0x1C,0x26,0xBF,0x52,0x9A,0x72,0x53,0x98,0xFC,0xC2,0x68,0xD2,0x4D,0x61,0xF0,0xA3,0x90,0xB6,0xD6,0x50,0xC1,0x8F,0x42,0xDA,0x4A,0x43,0x39,0x3F,0x48,0x2D,0x6B,0x33,0xF9,0xFF};
uint8_t spFIFTEEN[]   PROGMEM = {
  0x08,0xE8,0x2A,0x0D,0x01,0xDD,0xBA,0x31,0x60,0x6A,0xF7,0xA0,0xAE,0x54,0xAA,0x5A,0x76,0x97,0xD9,0x34,0x69,0xEF,0x32,0x1E,0x66,0xE1,0xE2,0xB3,0x43,0xA9,0x18,0x55,0x92,0x4E,0x37,0x2D,0x67,0x6F,0xDF,0xA2,0x5A,0xB6,0x04,0x30,0x55,0xA8,0x00,0x86,0x09,0xE7,0x00,0x01,0x16,0x17,0x05,0x70,0x40,0x57,0xE5,0x01,0xF8,0x21,0x34,0x00,0xD3,0x19,0x33,0x80,0x89,0x9A,0x62,0x34,0x4C,0xD5,0x49,0xAE,0x8B,0x53,0x09,0xF7,0x26,0xD9,0x6A,0x7E,0x23,0x5C,0x13,0x12,0xB3,0x04,0x9D,0x50,0x4F,0xB1,0xAD,0x14,0x15,0xC2,0xD3,0xA1,0xB6,0x42,0x94,0xA8,0x8C,0x87,0xDB,0x74,0xB1,0x70,0x59,0xE1,0x2E,0xC9,0xC5,0x81,0x5B,0x55,0xA4,0x4C,0x17,0x47,0xC1,0x6D,0xE3,0x81,0x53,0x9C,0x84,0x6A,0x46,0xD9,0x4C,0x51,0x31,0x42,0xD9,0x66,0xC9,0x44,0x85,0x29,0x6A,0x9B,0xAD,0xFF,0x07};
uint8_t spSIXTEEN[]   PROGMEM = {
  0x0A,0x58,0x5A,0x5D,0x00,0x93,0x97,0x0B,0x60,0xA9,0x48,0x05,0x0C,0x15,0xAE,0x80,0xAD,0x3D,0x14,0x30,0x7D,0xD9,0x50,0x92,0x92,0xAC,0x0D,0xC5,0xCD,0x2A,0x82,0xAA,0x3B,0x98,0x04,0xB3,0x4A,0xC8,0x9A,0x90,0x05,0x09,0x68,0x51,0xD4,0x01,0x23,0x9F,0x1A,0x60,0xA9,0x12,0x03,0xDC,0x50,0x81,0x80,0x22,0xDC,0x20,0x00,0xCB,0x06,0x3A,0x60,0x16,0xE3,0x64,0x64,0x42,0xDD,0xCD,0x6A,0x8A,0x5D,0x28,0x75,0x07,0xA9,0x2A,0x5E,0x65,0x34,0xED,0x64,0xBB,0xF8,0x85,0xF2,0x94,0x8B,0xAD,0xE4,0x37,0x4A,0x5B,0x21,0xB6,0x52,0x50,0x19,0xAD,0xA7,0xD8,0x4A,0x41,0x14,0xDA,0x5E,0x12,0x3A,0x04,0x91,0x4B,0x7B,0x69,0xA8,0x10,0x24,0x2E,0xE5,0xA3,0x81,0x52,0x90,0x94,0x5A,0x55,0x98,0x32,0x41,0x50,0xCC,0x93,0x2E,0x47,0x85,0x89,0x1B,0x5B,0x5A,0x62,0x04,0x44,0xE3,0x02,0x80,0x80,0x64,0xDD,0xFF,0x1F};
uint8_t spSEVENTEEN[] PROGMEM = {
  0x02,0x98,0x3A,0x42,0x00,0x5B,0xA6,0x09,0x60,0xDB,0x52,0x06,0x1C,0x93,0x29,0x80,0xA9,0x52,0x87,0x9A,0xB5,0x99,0x4F,0xC8,0x3E,0x46,0xD6,0x5E,0x7E,0x66,0xFB,0x98,0xC5,0x5A,0xC6,0x9A,0x9C,0x63,0x15,0x6B,0x11,0x13,0x8A,0x9C,0x97,0xB9,0x9A,0x5A,0x39,0x71,0xEE,0xD2,0x29,0xC2,0xA6,0xB8,0x58,0x59,0x99,0x56,0x14,0xA3,0xE1,0x26,0x19,0x19,0xE3,0x8C,0x93,0x17,0xB4,0x46,0xB5,0x88,0x71,0x9E,0x97,0x9E,0xB1,0x2C,0xC5,0xF8,0x56,0xC4,0x58,0xA3,0x1C,0xE1,0x33,0x9D,0x13,0x41,0x8A,0x43,0x58,0xAD,0x95,0xA9,0xDB,0x36,0xC0,0xD1,0xC9,0x0E,0x58,0x4E,0x45,0x01,0x23,0xA9,0x04,0x37,0x13,0xAE,0x4D,0x65,0x52,0x82,0xCA,0xA9,0x37,0x99,0x4D,0x89,0xBA,0xC0,0xBC,0x14,0x36,0x25,0xEA,0x1C,0x73,0x52,0x1D,0x97,0xB8,0x33,0xAC,0x0E,0x75,0x9C,0xE2,0xCE,0xB0,0xDA,0xC3,0x51,0x4A,0x1A,0xA5,0xCA,0x70,0x5B,0x21,0xCE,0x4C,0x26,0xD2,0x6C,0xBA,0x38,0x71,0x2E,0x1F,0x2D,0xED,0xE2,0x24,0xB8,0xBC,0x3D,0x52,0x88,0xAB,0x50,0x8E,0xA8,0x48,0x22,0x4E,0x42,0xA0,0x26,0x55,0xFD,0x3F};
uint8_t spEIGHTEEN[]  PROGMEM = {
  0x2E,0x9C,0xD1,0x4D,0x54,0xEC,0x2C,0xBF,0x1B,0x8A,0x99,0x70,0x7C,0xFC,0x2E,0x29,0x6F,0x52,0xF6,0xF1,0xBA,0x20,0xBF,0x36,0xD9,0xCD,0xED,0x0C,0xF3,0x27,0x64,0x17,0x73,0x2B,0xA2,0x99,0x90,0x65,0xEC,0xED,0x40,0x73,0x32,0x12,0xB1,0xAF,0x30,0x35,0x0B,0xC7,0x00,0xE0,0x80,0xAE,0xDD,0x1C,0x70,0x43,0xAA,0x03,0x86,0x51,0x36,0xC0,0x30,0x64,0xCE,0x4C,0x98,0xFB,0x5C,0x65,0x07,0xAF,0x10,0xEA,0x0B,0x66,0x1B,0xFC,0x46,0xA8,0x3E,0x09,0x4D,0x08,0x2A,0xA6,0x3E,0x67,0x36,0x21,0x2A,0x98,0x67,0x9D,0x15,0xA7,0xA8,0x60,0xEE,0xB6,0x94,0x99,0xA2,0x4A,0x78,0x22,0xC2,0xA6,0x8B,0x8C,0x8E,0xCC,0x4C,0x8A,0x2E,0x8A,0x4C,0xD3,0x57,0x03,0x87,0x28,0x71,0x09,0x1F,0x2B,0xE4,0xA2,0xC4,0xC5,0x6D,0xAD,0x54,0x88,0xB2,0x63,0xC9,0xF2,0x50,0x2E,0x8A,0x4A,0x38,0x4A,0xEC,0x88,0x28,0x08,0xE3,0x28,0x49,0xF3,0xFF};
uint8_t spNINETEEN[]  PROGMEM = {
  0xC2,0xEA,0x8A,0x95,0x2B,0x6A,0x05,0x3F,0x71,0x71,0x5F,0x0D,0x12,0xFC,0x28,0x25,0x62,0x35,0xF0,0xF0,0xB3,0x48,0x1E,0x0F,0xC9,0xCB,0x2F,0x45,0x7C,0x2C,0x25,0x1F,0xBF,0x14,0xB3,0x2C,0xB5,0x75,0xFC,0x5A,0x5C,0xA3,0x5D,0xE1,0xF1,0x7A,0x76,0xB3,0x4E,0x45,0xC7,0xED,0x96,0x23,0x3B,0x18,0x37,0x7B,0x18,0xCC,0x09,0x51,0x13,0x4C,0xAB,0x6C,0x4C,0x4B,0x96,0xD2,0x49,0xAA,0x36,0x0B,0xC5,0xC2,0x20,0x26,0x27,0x35,0x63,0x09,0x3D,0x30,0x8B,0xF0,0x48,0x5C,0xCA,0x61,0xDD,0xCB,0xCD,0x91,0x03,0x8E,0x4B,0x76,0xC0,0xCC,0x4D,0x06,0x98,0x31,0x31,0x98,0x99,0x70,0x6D,0x2A,0xA3,0xE4,0x16,0xCA,0xBD,0xCE,0x5C,0x92,0x57,0x28,0xCF,0x09,0x69,0x2E,0x7E,0xA5,0x3C,0x63,0xA2,0x30,0x05,0x95,0xD2,0x74,0x98,0xCD,0x14,0x54,0xCA,0x53,0xA9,0x96,0x52,0x50,0x28,0x6F,0xBA,0xCB,0x0C,0x41,0x50,0xDE,0x65,0x2E,0xD3,0x05,0x89,0x4B,0x7B,0x6B,0x20,0x17,0x44,0xAE,0xED,0x23,0x81,0x52,0x90,0x85,0x73,0x57,0xD0,0x72,0x41,0xB1,0x02,0xDE,0x2E,0xDB,0x04,0x89,0x05,0x79,0xBB,0x62,0xE5,0x76,0x11,0xCA,0x61,0x0E,0xFF,0x1F};
uint8_t spTWENTY[]    PROGMEM = {
  0x01,0x98,0xD1,0xC2,0x00,0xCD,0xA4,0x32,0x20,0x79,0x13,0x04,0x28,0xE7,0x92,0xDC,0x70,0xCC,0x5D,0xDB,0x76,0xF3,0xD2,0x32,0x0B,0x0B,0x5B,0xC3,0x2B,0xCD,0xD4,0xDD,0x23,0x35,0xAF,0x44,0xE1,0xF0,0xB0,0x6D,0x3C,0xA9,0xAD,0x3D,0x35,0x0E,0xF1,0x0C,0x8B,0x28,0xF7,0x34,0x01,0x68,0x22,0xCD,0x00,0xC7,0xA4,0x04,0xBB,0x32,0xD6,0xAC,0x56,0x9C,0xDC,0xCA,0x28,0x66,0x53,0x51,0x70,0x2B,0xA5,0xBC,0x0D,0x9A,0xC1,0xEB,0x14,0x73,0x37,0x29,0x19,0xAF,0x33,0x8C,0x3B,0xA7,0x24,0xBC,0x42,0xB0,0xB7,0x59,0x09,0x09,0x3C,0x96,0xE9,0xF4,0x58,0xFF,0x0F};
uint8_t spTHIRTY[]    PROGMEM = {
  0x08,0x98,0xD6,0x15,0x01,0x43,0xBB,0x0A,0x20,0x1B,0x8B,0xE5,0x16,0xA3,0x1E,0xB6,0xB6,0x96,0x97,0x3C,0x57,0xD4,0x2A,0x5E,0x7E,0x4E,0xD8,0xE1,0x6B,0x7B,0xF8,0x39,0x63,0x0D,0x9F,0x95,0xE1,0xE7,0x4C,0x76,0xBC,0x91,0x5B,0x90,0x13,0xC6,0x68,0x57,0x4E,0x41,0x8B,0x10,0x5E,0x1D,0xA9,0x44,0xD3,0xBA,0x47,0xB8,0xDD,0xE4,0x35,0x86,0x11,0x93,0x94,0x92,0x5F,0x29,0xC7,0x4C,0x30,0x0C,0x41,0xC5,0x1C,0x3B,0x2E,0xD3,0x05,0x15,0x53,0x6C,0x07,0x4D,0x15,0x14,0x8C,0xB5,0xC9,0x6A,0x44,0x90,0x10,0x4E,0x9A,0xB6,0x21,0x81,0x23,0x3A,0x91,0x91,0xE8,0xFF,0x01};
uint8_t spFOURTY[]    PROGMEM = {
  0x04,0x18,0xB6,0x4C,0x00,0xC3,0x56,0x30,0xA0,0xE8,0xF4,0xA0,0x98,0x99,0x62,0x91,0xAE,0x83,0x6B,0x77,0x89,0x78,0x3B,0x09,0xAE,0xBD,0xA6,0x1E,0x63,0x3B,0x79,0x7E,0x71,0x5A,0x8F,0x95,0xE6,0xA5,0x4A,0x69,0xB9,0x4E,0x8A,0x5F,0x12,0x56,0xE4,0x58,0x69,0xE1,0x36,0xA1,0x69,0x2E,0x2B,0xF9,0x95,0x93,0x55,0x17,0xED,0xE4,0x37,0xC6,0xBA,0x93,0xB2,0x92,0xDF,0x19,0xD9,0x6E,0xC8,0x0A,0xFE,0x60,0xE8,0x37,0x21,0xC9,0xF9,0x8D,0x61,0x5F,0x32,0x13,0xE7,0x17,0x4C,0xD3,0xC6,0xB1,0x94,0x97,0x10,0x8F,0x8B,0xAD,0x11,0x7E,0xA1,0x9A,0x26,0x92,0xF6,0xFF,0x01};
uint8_t spFIFTY[]     PROGMEM = {
  0x08,0xE8,0x2E,0x84,0x00,0x23,0x84,0x13,0x60,0x38,0x95,0xA5,0x0F,0xCF,0xE2,0x79,0x8A,0x8F,0x37,0x02,0xB3,0xD5,0x2A,0x6E,0x5E,0x93,0x94,0x79,0x45,0xD9,0x05,0x5D,0x0A,0xB9,0x97,0x63,0x02,0x74,0xA7,0x82,0x80,0xEE,0xC3,0x10,0xD0,0x7D,0x28,0x03,0x6E,0x14,0x06,0x70,0xE6,0x0A,0xC9,0x9A,0x4E,0x37,0xD9,0x95,0x51,0xCE,0xBA,0xA2,0x14,0x0C,0x81,0x36,0x1B,0xB2,0x5C,0x30,0x38,0xFA,0x9C,0xC9,0x32,0x41,0xA7,0x18,0x3B,0xA2,0x48,0x04,0x05,0x51,0x4F,0x91,0x6D,0x12,0x04,0x20,0x9B,0x61,0x89,0xFF,0x1F};
#endif

// Speech parameter decoding tables
//
// These tables are used to decompress the bitstreams above into coeffients for the synthesis lattice filter.
//
// Note that K1 and K2 tables are truncated so the coefficients can be multiplied more quickly.
// See Talkie for higher precision tables.
//
uint8_t tmsEnergy[0x10] = {
  0x00,0x02,0x03,0x04,0x05,0x07,0x0a,0x0f,0x14,0x20,0x29,0x39,0x51,0x72,0xa1,0xff};
uint8_t tmsPeriod[0x40] = {
  0x00,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2D,0x2F,0x31,0x33,0x35,0x36,0x39,0x3B,0x3D,0x3F,0x42,0x45,0x47,0x49,0x4D,0x4F,0x51,0x55,0x57,0x5C,0x5F,0x63,0x66,0x6A,0x6E,0x73,0x77,0x7B,0x80,0x85,0x8A,0x8F,0x95,0x9A,0xA0};
int8_t tmsK1[0x20]     =  {
  0x83,0x84,0x84,0x84,0x85,0x85,0x86,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8F,0x91,0x93,0x99,0xA1,0xAC,0xB8,0xC7,0xD9,0xEC,0x00,0x14,0x27,0x39,0x48,0x55,0x5F,0x67,0x6D};
int8_t tmsK2[0x20]     =  {
  0xAE,0xB5,0xBC,0xC3,0xCC,0xD4,0xDE,0xE8,0xF2,0xFC,0x06,0x10,0x1A,0x24,0x2D,0x36,0x3E,0x46,0x4D,0x53,0x59,0x5E,0x62,0x66,0x6A,0x6D,0x70,0x72,0x74,0x76,0x77,0x7F};
int8_t tmsK3[0x10]      = {
  0x92,0x9F,0xAD,0xBA,0xC8,0xD5,0xE3,0xF0,0xFE,0x0B,0x19,0x26,0x34,0x41,0x4F,0x5C};
int8_t tmsK4[0x10]      = {
  0xAE,0xBC,0xCA,0xD8,0xE6,0xF4,0x01,0x0F,0x1D,0x2B,0x39,0x47,0x55,0x63,0x71,0x7E};
int8_t tmsK5[0x10]      = {
  0xAE,0xBA,0xC5,0xD1,0xDD,0xE8,0xF4,0xFF,0x0B,0x17,0x22,0x2E,0x39,0x45,0x51,0x5C};
int8_t tmsK6[0x10]      = {
  0xC0,0xCB,0xD6,0xE1,0xEC,0xF7,0x03,0x0E,0x19,0x24,0x2F,0x3A,0x45,0x50,0x5B,0x66};
int8_t tmsK7[0x10]      = {
  0xB3,0xBF,0xCB,0xD7,0xE3,0xEF,0xFB,0x07,0x13,0x1F,0x2B,0x37,0x43,0x4F,0x5A,0x66};
int8_t tmsK8[0x08]      = {
  0xC0,0xD8,0xF0,0x07,0x1F,0x37,0x4F,0x66};
int8_t tmsK9[0x08]      = {
  0xC0,0xD4,0xE8,0xFC,0x10,0x25,0x39,0x4D};
int8_t tmsK10[0x08]     = {
  0xCD,0xDF,0xF1,0x04,0x16,0x20,0x3B,0x4D};

// Voiced formant excitation signal
//
// This is the sound of one cycle of the simulated vocal chords.
#define CHIRP_SIZE 41
int8_t chirp[CHIRP_SIZE] = {
  0x00,0x2a,0xd4,0x32,0xb2,0x12,0x25,0x14,0x02,0xe1,0xc5,0x02,0x5f,0x5a,0x05,0x0f,0x26,0xfc,0xa5,0xa5,0xd6,0xdd,0xdc,0xfc,0x25,0x2b,0x22,0x21,0x0f,0xff,0xf8,0xee,0xed,0xef,0xf7,0xf6,0xfa,0x00,0x03,0x02,0x01};

// Synthesis parameters
//
uint8_t synthPeriod;
uint16_t synthEnergy;
int16_t synthK1,synthK2;
int8_t synthK3,synthK4,synthK5,synthK6,synthK7,synthK8,synthK9,synthK10;
uint8_t talkieSetup = 0;
uint8_t* ptrAddr;
uint8_t ptrBit;


/////////////////
// Say the time
/////////////////
//
void sayTime() {

  // Get the current time
  //
  //  checktime();
  //  int hours = HourTens * 10 + HourOnes;
  //  int minutes = MinTens * 10 + MinOnes;

  // We need to shut down the LED matrix, because:
  //  1) We need as many CPU cycles as we can get for all the synthesis maths
  //  2) We need Timer 1 as a timebase for our synthesis
  //  3) Don't want to burn out any LEDs by leaving them on.
  //
  displayOff();

  // Force LEDs off
  //  PORTC |= B00001111;
  //  PORTB = B11111111;
  //  PORTD |= B11110000;

  // Prep speech synth audio output
  //
  Timer1.initialize(125); // 8kHz sample rate
  Timer1.attachInterrupt(talkieInterruptHandler); 

  // This part converts the time into speech segments
  // You may need to alter this if you're using another voice or different speech segments.
  //
  // Most pronounciations have zero as a special case ('o'clock', 'zero', 'oh' or 'hundred'),
  // so sayNum() accepts a zero value parameter.

#ifndef FEMALE_VOICE
  // Mapping for male voice segments
  //

  // 24 hour pronunciation
  //
  // 00:00 => zero hundred
  // 00:03 => zero oh three
  // 23:59 => twenty-three fifty-nine
  //
  sayNum(hour,spZERO);
  if (minute > 0 && minute < 10) talkieSay(spO);
  sayNum(minute,spHUNDRED);
#else
  // Mapping for female voice segments
  //
  talkieSay(spTHE);
  talkieSay(spTIME);
  talkieSay(spIS);


  // 24 hour pronunciation (zero and hundred are not in this word set)
  //
  // 00:00 => oh o'clock
  // 00:03 => oh oh three
  // 23:59 => twenty-three fifty-nine
  //
  sayNum(hour,spOH);
  if (minute > 0 && minute < 10) talkieSay(spOH);
  sayNum(minute,spOCLOCK);

#endif

  talkieEnd();
  // Speech is complete, so shut down audio system

  //displayOn();

  digitalWrite(speaker, LOW);   
}

// Say a single number, with english pronounciation rules.
// 0 is pronounced different ways in different contexts,
// so this is handled as a special case.
//
void sayNum(int number,uint8_t* zero_phrase) {
  if (number==0) {
    talkieSay(zero_phrase);
  } 
  else {
#ifndef FEMALE_VOICE
    // Word segment mapping, male voice set
    if (number>=50) { 
      talkieSay(spFIF_); 
      talkieSay(sp_T); 
      number-=50; 
    }
    if (number>=40) { 
      talkieSay(spFOUR_); 
      talkieSay(sp_T); 
      number-=40; 
    }
    if (number>=30) { 
      talkieSay(spTHIR_); 
      talkieSay(sp_T); 
      number-=30; 
    }
    if (number>=20) { 
      talkieSay(spTWEN_); 
      talkieSay(sp_T); 
      number-=20; 
    }
    switch (number) {
    case 19: 
      talkieSay(spNINE_); 
      talkieSay(sp_TEEN); 
      break;
    case 18: 
      talkieSay(spEIGH_); 
      talkieSay(sp_TEEN); 
      break;
    case 17: 
      talkieSay(spSEVEN_); 
      talkieSay(sp_TEEN); 
      break;
    case 16: 
      talkieSay(spSIX_); 
      talkieSay(sp_TEEN); 
      break;
    case 15: 
      talkieSay(spFIF_); 
      talkieSay(sp_TEEN); 
      break;
    case 14: 
      talkieSay(spFOUR_); 
      talkieSay(sp_TEEN); 
      break;
    case 13: 
      talkieSay(spTHIR_); 
      talkieSay(sp_TEEN); 
      break;
    case 12: 
      talkieSay(spTWELVE); 
      break;
    case 11: 
      talkieSay(spELEVEN); 
      break;
    case 10: 
      talkieSay(spTEN); 
      break;
    case 9: 
      talkieSay(spNINE); 
      break;
    case 8: 
      talkieSay(spEIGHT); 
      break;
    case 7: 
      talkieSay(spSEVEN); 
      break;
    case 6: 
      talkieSay(spSIX); 
      break;
    case 5: 
      talkieSay(spFIVE); 
      break;
    case 4: 
      talkieSay(spFOUR); 
      break;
    case 3: 
      talkieSay(spTHREE); 
      break;
    case 2: 
      talkieSay(spTWO); 
      break;
    case 1: 
      talkieSay(spONE); 
      break;
    default: 
      break; // Say nothing more for numbers like 20 or 50
    }
#else
    // Word segment mapping, female voice set
    if (number>=50) { 
      talkieSay(spFIFTY); 
      number-=50; 
    }
    if (number>=40) { 
      talkieSay(spFOURTY); 
      number-=40; 
    }
    if (number>=30) { 
      talkieSay(spTHIRTY); 
      number-=30; 
    }
    if (number>=20) { 
      talkieSay(spTWENTY); 
      number-=20; 
    }
    switch (number) {
    case 19: 
      talkieSay(spNINETEEN); 
      break;
    case 18: 
      talkieSay(spEIGHTEEN); 
      break;
    case 17: 
      talkieSay(spSEVENTEEN); 
      break;
    case 16: 
      talkieSay(spSIXTEEN); 
      break;
    case 15: 
      talkieSay(spFIFTEEN); 
      break;
    case 14: 
      talkieSay(spFOURTEEN); 
      break;
    case 13: 
      talkieSay(spTHIRTEEN); 
      break;
    case 12: 
      talkieSay(spTWELVE); 
      break;
    case 11: 
      talkieSay(spELEVEN); 
      break;
    case 10: 
      talkieSay(spTEN); 
      break;
    case 9: 
      talkieSay(spNINE); 
      break;
    case 8: 
      talkieSay(spEIGHT); 
      break;
    case 7: 
      talkieSay(spSEVEN); 
      break;
    case 6: 
      talkieSay(spSIX); 
      break;
    case 5: 
      talkieSay(spFIVE); 
      break;
    case 4: 
      talkieSay(spFOUR); 
      break;
    case 3: 
      talkieSay(spTHREE); 
      break;
    case 2: 
      talkieSay(spTWO); 
      break;
    case 1: 
      talkieSay(spONE); 
      break;
    default: 
      break; // Say nothing more for numbers like 20 or 50
    }
#endif
  }
}



void talkieSetPtr(uint8_t* addr) {
  ptrAddr = addr;
  ptrBit = 0;
}

// The ROMs used with the TI speech were serial, not byte wide.
// Here's a handy routine to flip ROM data which is usually reversed.
uint8_t talkieRev(uint8_t a) {
  // 76543210
  a = (a>>4) | (a<<4); // Swap in groups of 4
  // 32107654
  a = ((a & 0xcc)>>2) | ((a & 0x33)<<2); // Swap in groups of 2
  // 10325476
  a = ((a & 0xaa)>>1) | ((a & 0x55)<<1); // Swap bit pairs
  // 01234567
  return a;
}
uint8_t talkieGetBits(uint8_t bits) {
  uint8_t value;
  uint16_t data;
  data = talkieRev(pgm_read_byte(ptrAddr))<<8;
  if (ptrBit+bits > 8) {
    data |= talkieRev(pgm_read_byte(ptrAddr+1));
  }
  data <<= ptrBit;
  value = data >> (16-bits);
  ptrBit += bits;
  if (ptrBit >= 8) {
    ptrBit -= 8;
    ptrAddr++;
  }
  return value;
}
void talkieBegin() {
  // Auto-setup.
  // 
  // Enable the speech system whenever say() is called.

  pinMode(3,OUTPUT);
  // Timer 2 set up as fast-as-possible PWM.
  //
  // 78.125kHz on 20MHz Arduino
  // 62.5kHz on 16MHz Arduino
  // 31.25kHz on 8MHz Arduino
  //
  // The PWM 'buzz' is well above human hearing range and is
  // very easy to filter out.
  //
  TCCR2A = _BV(COM2B1) | _BV(WGM21) | _BV(WGM20);
  TCCR2B = _BV(CS20);
  TIMSK2 = 0;

  // Unfortunately we can't calculate the next sample every PWM cycle
  // as the routine is too slow. So use Timer 1 to trigger that.

  // Timer 1 set up as a 8000Hz sample interrupt
  talkieSetup = 1;
}
void talkieEnd() {
  TCCR2A = 0;
  TCCR2B = 0;
  TIMSK2 = 0;

  // Unfortunately we can't calculate the next sample every PWM cycle
  // as the routine is too slow. So use Timer 1 to trigger that.

  // Timer 1 set up as a 8000Hz sample interrupt
  talkieSetup = 0;
}
void talkieSay(uint8_t* addr) {
  uint8_t energy;

  if (!talkieSetup) talkieBegin();

  talkieSetPtr(addr);
  do {
    uint8_t repeat;

    // Read speech data, processing the variable size frames.

    energy = talkieGetBits(4);
    if (energy == 0) {
      // Energy = 0: rest frame
      synthEnergy = 0;
    } 
    else if (energy == 0xf) {
      // Energy = 15: stop frame. Silence the synthesiser.
      synthEnergy = 0;
      synthK1 = 0;
      synthK2 = 0;
      synthK3 = 0;
      synthK4 = 0;
      synthK5 = 0;
      synthK6 = 0;
      synthK7 = 0;
      synthK8 = 0;
      synthK9 = 0;
      synthK10 = 0;
    } 
    else {
      synthEnergy = tmsEnergy[energy];
      repeat = talkieGetBits(1);
      synthPeriod = tmsPeriod[talkieGetBits(6)];
      // A repeat frame uses the last coefficients
      if (!repeat) {
        // All frames use the first 4 coefficients
        synthK1 = tmsK1[talkieGetBits(5)];
        synthK2 = tmsK2[talkieGetBits(5)];
        synthK3 = tmsK3[talkieGetBits(4)];
        synthK4 = tmsK4[talkieGetBits(4)];
        if (synthPeriod) {
          // Voiced frames use 6 extra coefficients.
          synthK5 = tmsK5[talkieGetBits(4)];
          synthK6 = tmsK6[talkieGetBits(4)];
          synthK7 = tmsK7[talkieGetBits(4)];
          synthK8 = tmsK8[talkieGetBits(3)];
          synthK9 = tmsK9[talkieGetBits(3)];
          synthK10 = tmsK10[talkieGetBits(3)];
        }
      }
    }
    delay(25);
  } 
  while (energy != 0xf);
}


void talkieInterruptHandler(){
  static uint8_t nextPwm;
  static uint8_t periodCounter;
  static int16_t x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10;
  int16_t u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10;

  OCR2B = nextPwm;
  if (synthPeriod) {
    // Voiced source
    if (periodCounter < synthPeriod) {
      periodCounter++;
    } 
    else {
      periodCounter = 0;
    }
    if (periodCounter < CHIRP_SIZE) {
      u10 = ((chirp[periodCounter]) * (uint32_t) synthEnergy) >> 8;
    } 
    else {
      u10 = 0;
    }
  } 
  else {
    // Unvoiced source
    static uint16_t synthRand = 1;
    synthRand = (synthRand >> 1) ^ ((synthRand & 1) ? 0xB800 : 0);
    u10 = (synthRand & 1) ? synthEnergy : -synthEnergy;
  }
  // Lattice filter forward path
  u9 = u10 - (((int16_t)synthK10*x9) >> 7);
  u8 = u9 - (((int16_t)synthK9*x8) >> 7);
  u7 = u8 - (((int16_t)synthK8*x7) >> 7);
  u6 = u7 - (((int16_t)synthK7*x6) >> 7);
  u5 = u6 - (((int16_t)synthK6*x5) >> 7);
  u4 = u5 - (((int16_t)synthK5*x4) >> 7);
  u3 = u4 - (((int16_t)synthK4*x3) >> 7);
  u2 = u3 - (((int16_t)synthK3*x2) >> 7);
  u1 = u2 - (((int16_t)synthK2*x1) >> 7); // K1 and K2 should be calculated with higher precision,
  u0 = u1 - (((int16_t)synthK1*x0) >> 7); // but this is a speed shortcut.

  // Output clamp
  if (u0 > 511) u0 = 511;
  if (u0 < -512) u0 = -512;

  // Lattice filter reverse path
  x9 = x8 + (((int16_t)synthK9*u8) >> 7);
  x8 = x7 + (((int16_t)synthK8*u7) >> 7);
  x7 = x6 + (((int16_t)synthK7*u6) >> 7);
  x6 = x5 + (((int16_t)synthK6*u5) >> 7);
  x5 = x4 + (((int16_t)synthK5*u4) >> 7);
  x4 = x3 + (((int16_t)synthK4*u3) >> 7);
  x3 = x2 + (((int16_t)synthK3*u2) >> 7);
  x2 = x1 + (((int16_t)synthK2*u1) >> 7);
  x1 = x0 + (((int16_t)synthK1*u0) >> 7);
  x0 = u0;

  nextPwm = (u0>>2)+0x80;
}


#endif
// end of VOICE module


void I2C_scaner()
{
  char    module_id;    // Target I2C ID
  byte    data;         // Dummy data
  byte    result;       // Result of TX

  for (byte module_id = 0; module_id <= 127; module_id ++)
  {
    Wire.beginTransmission(module_id);
    Wire.write(&data, 0);
    result = Wire.endTransmission();

    // I2C Module found out!
    if (result == 0)
    {
      line=0;
      led1.begin();
      led1.print(module_id, HEX);
      screenShow();
      delay(1000);
      beep();
      led1.begin(); 

      switch (module_id)
      {
      case 0x68: 
        led1.print(F("rtc")); 
        break;
      case 0x3c: 
        led1.print(F("oled")); 
        break;
      case 0x3d: 
        led1.print(F("oled")); 
        break;
      case 0x77: 
        led1.print(F("p180")); 
        break;
      case 0x1E: 
        led1.print(F("5883")); 
        break;


      }

      screenShow();
      beep();
      delay(1000);
    }
  }
}


//**************************************************************************************************************************
//**********************-----------------------------    CONFIG  -------------------------*************************************
//**************************************************************************************************************************


void loadConfig() {
  // To make sure there are settings, and they are YOURS!
  // If nothing is found it will use the default settings.
  if (//EEPROM.read(CONFIG_START + sizeof(settings) - 1) == settings.version_of_program[3] // this is '\0'
  EEPROM.read(CONFIG_START + sizeof(ee) - 2) == ee.version_of_program[2] &&
    EEPROM.read(CONFIG_START + sizeof(ee) - 3) == ee.version_of_program[1] &&
    EEPROM.read(CONFIG_START + sizeof(ee) - 4) == ee.version_of_program[0])
  { // reads settings from EEPROM
    for (unsigned int t=0; t<sizeof(ee); t++)
      *((char*)&ee + t) = EEPROM.read(CONFIG_START + t);
  } 
  else {
    // settings aren't valid! will overwrite with default settings
    saveConfig();
  }
}
//**************************************************************************************************************************
void saveConfig() {
  for (unsigned int t=0; t<sizeof(ee); t++)
  { // writes to EEPROM
    EEPROM.write(CONFIG_START + t, *((char*)&ee + t));
    // and verifies the data
    if (EEPROM.read(CONFIG_START + t) != *((char*)&ee + t))
    {
      // error writing to EEPROM
    }
  }
}

//**************************************************************************************************************************

void RTCInit(void)
{
  //Disable timer2 interrupts
  TIMSK2  = 0;
  //Enable asynchronous mode
  ASSR  = (1<<AS2);
  //set initial counter value
  TCNT2=0;
  //set prescaller 128
  TCCR2B |= (1<<CS22)|(1<<CS00);
  //wait for registers update
  while (ASSR & ((1<<TCN2UB)|(1<<TCR2BUB)));
  //clear interrupt flags
  TIFR2  = (1<<TOV2);
  //enable TOV2 interrupt
  TIMSK2  = (1<<TOIE2);
  SMCR|=(1<<SM1)|(1<<SM0);
}



//Overflow ISR software RTC
ISR(TIMER2_OVF_vect)
{
  second++;
  byte dayT;
  if (second > 59) {
    second = 0;
    minute++;
    if (minute > 59) {
      minute = 0;
      hour++;
      if (hour > 23) {
        hour = 0;
        day++;
        if (month == 2) { //february?
          if (isLeapYear(year)) {
            dayT = 29;
          } 
          else {
            dayT = 28;
          }
        } 
        else {
          dayT = daysPerMonth[month - 1];
        }
        if (day > dayT) {
          day = 1;
          month++;
          if (month > 12) {
            month = 1;
            year++;
          }
        }
      }
    }
  }

}
//check if the current year is a leap year
boolean isLeapYear(int yearT) {
  //	if (yearT == 0) { yearT = year; }
  if (((yearT % 4) == 0) && ((yearT % 100) != 0) || ((yearT % 400) == 0)) {
    return true;
  } 
  else {
    return false;
  }
}



//**************************************************************************************************************************

//------------------------------ Multiplex ---------------------------------
#ifdef SEGMENT

void multiplexint ()
{

  digitalWrite(digitPins[0], ACTH);
  digitalWrite(digitPins[1], ACTH);
  digitalWrite(digitPins[2], ACTH);
  digitalWrite(digitPins[3], ACTH);

  digitalWrite(segmentPins[0], ACTL);
  digitalWrite(segmentPins[1], ACTL);
  digitalWrite(segmentPins[2], ACTL);
  digitalWrite(segmentPins[3], ACTL);
  digitalWrite(segmentPins[4], ACTL);
  digitalWrite(segmentPins[5], ACTL);
  digitalWrite(segmentPins[6], ACTL);
  digitalWrite(segmentPins[7], ACTL);

  if (deol != 1){

    if (line==0) {
      if ((LEDbuffer1[textindex]) == 0){
        deol=1;
        bchar = 0;
      } 
      else
      {
        dchar=toupper(LEDbuffer1[textindex]);  
        bchar = (pgm_read_byte(&segment_data[dchar-32]));
        if ((LEDbuffer1[textindex+1]) == '.'){
          digitalWrite(segmentPins[7],ACTH);
          textindex++;
        }
        digitalWrite(digitPins[digit], ACTL);
      }
    }
    else
    {
      if ((LEDbuffer2[textindex]) == 0){
        deol=1;
        bchar = 0;
      } 
      else
      {
        dchar=toupper(LEDbuffer2[textindex]);  
        bchar = (pgm_read_byte(&segment_data[dchar-32]));
        if ((LEDbuffer2[textindex+1]) == '.'){
          digitalWrite(segmentPins[7],ACTH);
          textindex++;
        }
        if (digit<=4){    
          digitalWrite(digitPins[digit], ACTL);
        }
      }
    }




    if (bchar & 0b10000000){
      digitalWrite(segmentPins[0],ACTH);
    }
    if (bchar & 0b01000000){
      digitalWrite(segmentPins[1],ACTH);
    }
    if (bchar & 0b00100000){
      digitalWrite(segmentPins[2],ACTH);
    }
    if (bchar & 0b00010000){
      digitalWrite(segmentPins[3],ACTH);
    }
    if (bchar & 0b00001000){
      digitalWrite(segmentPins[4],ACTH);
    }
    if (bchar & 0b00000100){
      digitalWrite(segmentPins[5],ACTH);
    }
    if (bchar & 0b00000010){
      digitalWrite(segmentPins[6],ACTH);
    }
    if (bchar & 0b00000001){
      digitalWrite(segmentPins[7],ACTH);
    }
  }
  //    digitalWrite(digitPins[i], HIGH);
  if (((PINB & (1<<7))==0)&(digit==3)&line==2) {
    digitalWrite(segmentPins[7],ACTH); //charging
  }
  digit++;
  textindex++;
  if (digit==(4+ee.brightness)){
    digit=0;
    textindex=0;
    deol=0;
  }    


}

#endif





void displayOff()
{
  Timer1.stop();
  Timer1.detachInterrupt();


#ifdef SEGMENT
  for(int i = 0; i <8; i++){  //Set the 16 pins used to control the array as OUTPUTs
    digitalWrite(segmentPins[i], HIGH);
  }
  for(int i = 0; i <4; i++){  //Set the 16 pins used to control the array as OUTPUTs
    digitalWrite(digitPins[i], HIGH);
  }
  for(int i = 0; i <8; i++){  //Set the 16 pins used to control the array as OUTPUTs
    pinMode(segmentPins[i], INPUT);
  }
  for(int i = 0; i <4; i++){  //Set the 16 pins used to control the array as OUTPUTs
    pinMode(digitPins[i], INPUT);
  }
#endif

#ifdef MATRIX
  clearVideoram();
  for(int i = 0; i <5; i++){  //Set the 16 pins used to control the array as OUTPUTs
    digitalWrite(rowPin[i], HIGH);
  }
  for(int i = 0; i <7; i++){  //Set the 16 pins used to control the array as OUTPUTs
    digitalWrite(colPin[i], HIGH);
  }  
#endif


}

void displayOn ()
{
  Timer1.initialize(500);
  Timer1.attachInterrupt(multiplexint);

  for(int i = 0; i <8; i++){  //Set the 16 pins used to control the array as OUTPUTs
    pinMode(segmentPins[i], OUTPUT);
  }
  for(int i = 0; i <4; i++){  //Set the 16 pins used to control the array as OUTPUTs
    pinMode(digitPins[i], OUTPUT);
  }
  
}

void charging ()
{
  DDRB &= ~(1<<7);    //Configure PORTB pin 7 as an input
  PORTB |= (1<<7);    //Activate pull-ups in PORTB pin 7

#ifdef SEGMENT
    digitalWrite(segmentPins[7],ACTH);
  digitalWrite(digitPins[0], ACTH);
  digitalWrite(digitPins[1], ACTH);
  digitalWrite(digitPins[2], ACTH);
  digitalWrite(digitPins[3], ACTH);
  digitalWrite(digitPins[chled], ACTL);
  delay(1);
  digitalWrite(digitPins[chled], ACTH);
#endif

#ifdef MATRIX
  //
  digitalWrite(rowPin[0], HIGH);
  digitalWrite(rowPin[1], HIGH);
  digitalWrite(rowPin[2], LOW);
  digitalWrite(rowPin[3], HIGH);
  digitalWrite(rowPin[4], HIGH);


  //    digitalWrite(rowPin[chled], LOW);
  digitalWrite(colPin[chled], HIGH);     	
  delay(1);
  digitalWrite(colPin[chled], LOW); 

#endif
  if ((PINB & (1<<7))==0) {
    chled++;
    if (chled==4){
      chled=0;
    }
  }
}

#ifdef MATRIX
void ShowNumber(int number)
{
  byte data; 
  for(int i = 0; i <3; i++){
    videoram[i] = (pgm_read_byte(&font_data[(48+(number/10)*3)+i]));
    videoram[i+4] = (pgm_read_byte(&font_data[(48+(number % 10)*3)+i]));
  }
}

void printChar(int number)
{
  int i;
  for( i = 0; i <3; i++){
    videoram[i+7]= (pgm_read_byte(&font_data[((number-32 )*3)+i]));
  }
  videoram[i+8]=0;
}

void scrool()
{ 
  for(int i = 1; i <11; i++){
    videoram[i-1]=videoram[i];
  }

}

void clearVideoram()
{ 
  for(int i = 0; i <11; i++){
    videoram[i]=0;
  }

}

//------------------------------ Multiplex ---------------------------------
void multiplexint ()
{
  byte colData=0;
  digitalWrite(colPin[0], LOW);
  digitalWrite(colPin[1], LOW);
  digitalWrite(colPin[2], LOW);
  digitalWrite(colPin[3], LOW);
  digitalWrite(colPin[4], LOW);
  digitalWrite(colPin[5], LOW);
  digitalWrite(colPin[6], LOW);

  colData = videoram[col];
  for(row = 0; row <5; row++){

    if ( colData & (1<<row) ) {
      digitalWrite(rowPin[row], LOW);
    }
    else {	
      digitalWrite(rowPin[row], HIGH);
    }
  }
  digitalWrite(colPin[col], HIGH); 
  col++;
  if (col==7) {
    col=0;
    scdelay++;
    if (scdelay > 7) {
      if (textx > 3)
      {

        if (mline==1)
        {

          if (LEDbuffer1[textindex]==0)
          {
            textindex=0;
            mline=2;
          }
          else
          {
            printChar(toupper(LEDbuffer1[textindex]));
            textindex++;
            textx=0;
          }
        }
        else
        {
          if (LEDbuffer2[textindex]==0)
          {
            textindex=0;
            mline=1;
          }
          else
          {
            printChar(toupper(LEDbuffer2[textindex]));
            textindex++;
            textx=0;
          }
        }

      }
      textx++;
      scrool();
      scdelay=0;
    }
  }
}
#endif


#define isdigit(n) (n >= '0' && n <= '9')

inline char read_byte(const char *p, bool pgm)
{
  if (pgm)
    return pgm_read_byte(p);
  else
    return *p;
}



/*
 *
 * playing RTTTL music files in blocking mode
 * http://en.wikipedia.org/wiki/Ring_Tone_Transfer_Language
 *
 * based on Tone library demo
 *
 */


// duration in mSecs, frequency in hertz


void playRtttl(const prog_char *p, uint8_t octave_offset)
{
  // Absolutely no error checking in here

  byte default_dur = 4;
  byte default_oct = 6;
  int bpm = 63;
  int num;
  long wholenote;
  long duration;
  byte note;
  byte scale;
  bool pgm = true; //progmem  memory only
  wakeupActive=0;
  // format: d=N,o=N,b=NNN:
  // find the start (skip name, etc)

  while (read_byte(p, pgm) != ':')
    p++; // ignore name
  p++; // skip ':'

  // get default duration
  if (read_byte(p, pgm) == 'd')
  {
    p++;
    p++; // skip "d="
    num = 0;
    while (isdigit(read_byte(p, pgm)))
    {
      num = (num * 10) + (read_byte(p, pgm) - '0');
      p++;
    }
    if (num > 0)
      default_dur = num;
    p++; // skip comma
  }

  // get default octave
  if (read_byte(p, pgm) == 'o')
  {
    p++;
    p++; // skip "o="
    num = read_byte(p, pgm) - '0';
    p++;
    if (num >= 3 && num <= 7)
      default_oct = num;
    p++; // skip comma
  }

  // get BPM
  if (read_byte(p, pgm) == 'b')
  {
    p++;
    p++; // skip "b="
    num = 0;
    while (isdigit(read_byte(p, pgm)))
    {
      num = (num * 10) + (read_byte(p, pgm) - '0');
      p++;
    }
    bpm = num;
    p++; // skip colon
  }

  // BPM usually expresses the number of quarter notes per minute
  wholenote = (60 * 1000L / bpm) * 4; // this is the time for whole note (in milliseconds)

  // now begin note loop
  while ((read_byte(p, pgm)))
  {
    // first, get note duration, if available
    num = 0;
    while (isdigit(read_byte(p, pgm)))
    {
      num = (num * 10) + (read_byte(p, pgm) - '0');
      p++;
    }

    if (num)
      duration = wholenote / num;
    else
      duration = wholenote / default_dur; // we will need to check if we are a dotted note after

      // now get the note
    note = 0;

    switch (read_byte(p, pgm))
    {
    case 'c':
      note = 1;
      break;
    case 'd':
      note = 3;
      break;
    case 'e':
      note = 5;
      break;
    case 'f':
      note = 6;
      break;
    case 'g':
      note = 8;
      break;
    case 'a':
      note = 10;
      break;
    case 'b':
      note = 12;
      break;
    case 'p':
    default:
      note = 0;
    }
    p++;

    // now, get optional '#' sharp
    if (read_byte(p, pgm) == '#')
    {
      note++;
      p++;
    }

    // now, get optional '.' dotted note
    if (read_byte(p, pgm) == '.')
    {
      duration += duration / 2;
      p++;
    }

    // now, get scale
    if (isdigit(read_byte(p, pgm)))
    {
      scale = read_byte(p, pgm) - '0';
      p++;
    }
    else
    {
      scale = default_oct;
    }

    scale += octave_offset;

    if (read_byte(p, pgm) == ',')
      p++; // skip comma for next note (or we may be at the end)

    // now play the note

    if (note)
    {

      playTone(duration, pgm_read_word(&notes[(scale - 4) * 16 + note]));
    }
    else
    {
      delay(duration);
    }
    if ( wakeupActive==1) break;
  }
  digitalWrite(speaker,LOW);
}










