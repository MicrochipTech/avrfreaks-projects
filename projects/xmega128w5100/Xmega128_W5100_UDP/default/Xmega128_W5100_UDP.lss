
Xmega128_W5100_UDP.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002164  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000c6  00802000  00002164  000021f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000a6  008020c6  008020c6  000022be  2**0
                  ALLOC
  3 .debug_aranges 000000e0  00000000  00000000  000022be  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000007f6  00000000  00000000  0000239e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000036e0  00000000  00000000  00002b94  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000bc5  00000000  00000000  00006274  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001b55  00000000  00000000  00006e39  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000590  00000000  00000000  00008990  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00002004  00000000  00000000  00008f20  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001222  00000000  00000000  0000af24  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000c0  00000000  00000000  0000c146  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 fa 00 	jmp	0x1f4	; 0x1f4 <__ctors_end>
       4:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
       8:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
       c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      10:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      14:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      18:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      1c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      20:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      24:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      28:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      2c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      30:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      34:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      38:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      3c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      40:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      44:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      48:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      4c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      50:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      54:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      58:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      5c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      60:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      64:	0c 94 5c 04 	jmp	0x8b8	; 0x8b8 <__vector_25>
      68:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      6c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      70:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      74:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      78:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      7c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      80:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      84:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      88:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      8c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      90:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      94:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      98:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      9c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      a0:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      a4:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      a8:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      ac:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      b0:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      b4:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      b8:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      bc:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      c0:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      c4:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      c8:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      cc:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      d0:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      d4:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      d8:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      dc:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      e0:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      e4:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      e8:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      ec:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      f0:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      f4:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      f8:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
      fc:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     100:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     104:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     108:	0c 94 de 01 	jmp	0x3bc	; 0x3bc <__vector_66>
     10c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     110:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     114:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     118:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     11c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     120:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     124:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     128:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     12c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     130:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     134:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     138:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     13c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     140:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     144:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     148:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     14c:	0c 94 f2 01 	jmp	0x3e4	; 0x3e4 <__vector_83>
     150:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     154:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     158:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     15c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     160:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     164:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     168:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     16c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     170:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     174:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     178:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     17c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     180:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     184:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     188:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     18c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     190:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     194:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     198:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     19c:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1a0:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1a4:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1a8:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1ac:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1b0:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1b4:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1b8:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1bc:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1c0:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1c4:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1c8:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1cc:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1d0:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1d4:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1d8:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1dc:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1e0:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1e4:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1e8:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1ec:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>
     1f0:	0c 94 20 01 	jmp	0x240	; 0x240 <__bad_interrupt>

000001f4 <__ctors_end>:
     1f4:	11 24       	eor	r1, r1
     1f6:	1f be       	out	0x3f, r1	; 63
     1f8:	cf ef       	ldi	r28, 0xFF	; 255
     1fa:	df e3       	ldi	r29, 0x3F	; 63
     1fc:	de bf       	out	0x3e, r29	; 62
     1fe:	cd bf       	out	0x3d, r28	; 61
     200:	00 e0       	ldi	r16, 0x00	; 0
     202:	0c bf       	out	0x3c, r16	; 60
     204:	18 be       	out	0x38, r1	; 56
     206:	19 be       	out	0x39, r1	; 57
     208:	1a be       	out	0x3a, r1	; 58
     20a:	1b be       	out	0x3b, r1	; 59

0000020c <__do_copy_data>:
     20c:	10 e2       	ldi	r17, 0x20	; 32
     20e:	a0 e0       	ldi	r26, 0x00	; 0
     210:	b0 e2       	ldi	r27, 0x20	; 32
     212:	e4 e6       	ldi	r30, 0x64	; 100
     214:	f1 e2       	ldi	r31, 0x21	; 33
     216:	00 e0       	ldi	r16, 0x00	; 0
     218:	0b bf       	out	0x3b, r16	; 59
     21a:	02 c0       	rjmp	.+4      	; 0x220 <__do_copy_data+0x14>
     21c:	07 90       	elpm	r0, Z+
     21e:	0d 92       	st	X+, r0
     220:	a6 3c       	cpi	r26, 0xC6	; 198
     222:	b1 07       	cpc	r27, r17
     224:	d9 f7       	brne	.-10     	; 0x21c <__do_copy_data+0x10>
     226:	1b be       	out	0x3b, r1	; 59

00000228 <__do_clear_bss>:
     228:	11 e2       	ldi	r17, 0x21	; 33
     22a:	a6 ec       	ldi	r26, 0xC6	; 198
     22c:	b0 e2       	ldi	r27, 0x20	; 32
     22e:	01 c0       	rjmp	.+2      	; 0x232 <.do_clear_bss_start>

00000230 <.do_clear_bss_loop>:
     230:	1d 92       	st	X+, r1

00000232 <.do_clear_bss_start>:
     232:	ac 36       	cpi	r26, 0x6C	; 108
     234:	b1 07       	cpc	r27, r17
     236:	e1 f7       	brne	.-8      	; 0x230 <.do_clear_bss_loop>
     238:	0e 94 8a 02 	call	0x514	; 0x514 <main>
     23c:	0c 94 b0 10 	jmp	0x2160	; 0x2160 <_exit>

00000240 <__bad_interrupt>:
     240:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000244 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
     244:	0f 93       	push	r16
     246:	df 93       	push	r29
     248:	cf 93       	push	r28
     24a:	0f 92       	push	r0
     24c:	cd b7       	in	r28, 0x3d	; 61
     24e:	de b7       	in	r29, 0x3e	; 62
	AVR_ENTER_CRITICAL_REGION( );
     250:	2f b7       	in	r18, 0x3f	; 63
     252:	29 83       	std	Y+1, r18	; 0x01
     254:	f8 94       	cli
#endif /* __MEMORY_MODEL__ */

#elif defined __GNUC__
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
     256:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
     258:	fc 01       	movw	r30, r24
     25a:	08 ed       	ldi	r16, 0xD8	; 216
     25c:	04 bf       	out	0x34, r16	; 52
     25e:	60 83       	st	Z, r22
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

#endif
	AVR_LEAVE_CRITICAL_REGION( );
     260:	89 81       	ldd	r24, Y+1	; 0x01
     262:	8f bf       	out	0x3f, r24	; 63
}
     264:	0f 90       	pop	r0
     266:	cf 91       	pop	r28
     268:	df 91       	pop	r29
     26a:	0f 91       	pop	r16
     26c:	08 95       	ret

0000026e <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
     26e:	66 23       	and	r22, r22
     270:	11 f4       	brne	.+4      	; 0x276 <CLKSYS_XOSC_Config+0x8>
     272:	90 e0       	ldi	r25, 0x00	; 0
     274:	01 c0       	rjmp	.+2      	; 0x278 <CLKSYS_XOSC_Config+0xa>
     276:	90 e2       	ldi	r25, 0x20	; 32
     278:	48 2b       	or	r20, r24
     27a:	94 2b       	or	r25, r20
     27c:	e0 e5       	ldi	r30, 0x50	; 80
     27e:	f0 e0       	ldi	r31, 0x00	; 0
     280:	92 83       	std	Z+2, r25	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
     282:	08 95       	ret

00000284 <CLKSYS_PLL_Config>:
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
     284:	6f 71       	andi	r22, 0x1F	; 31
     286:	68 2b       	or	r22, r24
     288:	e0 e5       	ldi	r30, 0x50	; 80
     28a:	f0 e0       	ldi	r31, 0x00	; 0
     28c:	65 83       	std	Z+5, r22	; 0x05
}
     28e:	08 95       	ret

00000290 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
     290:	e0 e5       	ldi	r30, 0x50	; 80
     292:	f0 e0       	ldi	r31, 0x00	; 0
     294:	20 81       	ld	r18, Z
     296:	98 2f       	mov	r25, r24
     298:	90 95       	com	r25
     29a:	92 23       	and	r25, r18
     29c:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
     29e:	90 81       	ld	r25, Z
	return clkEnabled;
}
     2a0:	89 23       	and	r24, r25
     2a2:	08 95       	ret

000002a4 <CLKSYS_Prescalers_Config>:
 *  \param  PSBCfactor  Prescaler B and C division factor, in the combination
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
     2a4:	0f 93       	push	r16
     2a6:	df 93       	push	r29
     2a8:	cf 93       	push	r28
     2aa:	0f 92       	push	r0
     2ac:	cd b7       	in	r28, 0x3d	; 61
     2ae:	de b7       	in	r29, 0x3e	; 62
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
	AVR_ENTER_CRITICAL_REGION( );
     2b0:	9f b7       	in	r25, 0x3f	; 63
     2b2:	99 83       	std	Y+1, r25	; 0x01
     2b4:	f8 94       	cli
#endif /* __MEMORY_MODEL__ */

#elif defined __GNUC__
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
     2b6:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
     2b8:	68 2b       	or	r22, r24
     2ba:	81 e4       	ldi	r24, 0x41	; 65
     2bc:	90 e0       	ldi	r25, 0x00	; 0
     2be:	fc 01       	movw	r30, r24
     2c0:	08 ed       	ldi	r16, 0xD8	; 216
     2c2:	04 bf       	out	0x34, r16	; 52
     2c4:	60 83       	st	Z, r22
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

#endif
	AVR_LEAVE_CRITICAL_REGION( );
     2c6:	89 81       	ldd	r24, Y+1	; 0x01
     2c8:	8f bf       	out	0x3f, r24	; 63
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
	CCPWrite( &CLK.PSCTRL, PSconfig );
}
     2ca:	0f 90       	pop	r0
     2cc:	cf 91       	pop	r28
     2ce:	df 91       	pop	r29
     2d0:	0f 91       	pop	r16
     2d2:	08 95       	ret

000002d4 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
     2d4:	0f 93       	push	r16
     2d6:	df 93       	push	r29
     2d8:	cf 93       	push	r28
     2da:	0f 92       	push	r0
     2dc:	cd b7       	in	r28, 0x3d	; 61
     2de:	de b7       	in	r29, 0x3e	; 62
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
     2e0:	20 91 40 00 	lds	r18, 0x0040
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
	AVR_ENTER_CRITICAL_REGION( );
     2e4:	9f b7       	in	r25, 0x3f	; 63
     2e6:	99 83       	std	Y+1, r25	; 0x01
     2e8:	f8 94       	cli
#endif /* __MEMORY_MODEL__ */

#elif defined __GNUC__
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
     2ea:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
     2ec:	a0 e4       	ldi	r26, 0x40	; 64
     2ee:	b0 e0       	ldi	r27, 0x00	; 0
     2f0:	28 7f       	andi	r18, 0xF8	; 248
     2f2:	28 2b       	or	r18, r24
     2f4:	fd 01       	movw	r30, r26
     2f6:	08 ed       	ldi	r16, 0xD8	; 216
     2f8:	04 bf       	out	0x34, r16	; 52
     2fa:	20 83       	st	Z, r18
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

#endif
	AVR_LEAVE_CRITICAL_REGION( );
     2fc:	99 81       	ldd	r25, Y+1	; 0x01
     2fe:	9f bf       	out	0x3f, r25	; 63
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
	CCPWrite( &CLK.CTRL, clkCtrl );
	clkCtrl = ( CLK.CTRL & clockSource );
     300:	9c 91       	ld	r25, X
	return clkCtrl;
}
     302:	89 23       	and	r24, r25
     304:	0f 90       	pop	r0
     306:	cf 91       	pop	r28
     308:	df 91       	pop	r29
     30a:	0f 91       	pop	r16
     30c:	08 95       	ret

0000030e <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
     30e:	e0 e4       	ldi	r30, 0x40	; 64
     310:	f0 e0       	ldi	r31, 0x00	; 0
     312:	93 81       	ldd	r25, Z+3	; 0x03
     314:	91 7f       	andi	r25, 0xF1	; 241
     316:	91 60       	ori	r25, 0x01	; 1
     318:	98 2b       	or	r25, r24
     31a:	93 83       	std	Z+3, r25	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
     31c:	08 95       	ret

0000031e <CLKSYS_AutoCalibration_Enable>:
 *  \param  clkSource    Clock source to calibrate, either OSC_RC2MCREF_bm or
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
     31e:	28 2f       	mov	r18, r24
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
     320:	30 91 56 00 	lds	r19, 0x0056
     324:	66 23       	and	r22, r22
     326:	11 f0       	breq	.+4      	; 0x32c <CLKSYS_AutoCalibration_Enable+0xe>
     328:	98 2f       	mov	r25, r24
     32a:	01 c0       	rjmp	.+2      	; 0x32e <CLKSYS_AutoCalibration_Enable+0x10>
     32c:	90 e0       	ldi	r25, 0x00	; 0
     32e:	82 2f       	mov	r24, r18
     330:	80 95       	com	r24
     332:	83 23       	and	r24, r19
     334:	98 2b       	or	r25, r24
     336:	e0 e5       	ldi	r30, 0x50	; 80
     338:	f0 e0       	ldi	r31, 0x00	; 0
     33a:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
     33c:	21 30       	cpi	r18, 0x01	; 1
     33e:	31 f4       	brne	.+12     	; 0x34c <CLKSYS_AutoCalibration_Enable+0x2e>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
     340:	80 91 68 00 	lds	r24, 0x0068
     344:	81 60       	ori	r24, 0x01	; 1
     346:	80 93 68 00 	sts	0x0068, r24
     34a:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
     34c:	22 30       	cpi	r18, 0x02	; 2
     34e:	29 f4       	brne	.+10     	; 0x35a <CLKSYS_AutoCalibration_Enable+0x3c>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
     350:	80 91 60 00 	lds	r24, 0x0060
     354:	81 60       	ori	r24, 0x01	; 1
     356:	80 93 60 00 	sts	0x0060, r24
     35a:	08 95       	ret

0000035c <CLKSYS_XOSC_FailureDetection_Enable>:
 *  XOSCFD _will_ issue the XOSCF Non-maskable Interrupt (NMI) regardless of
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
     35c:	0f 93       	push	r16
     35e:	df 93       	push	r29
     360:	cf 93       	push	r28
     362:	0f 92       	push	r0
     364:	cd b7       	in	r28, 0x3d	; 61
     366:	de b7       	in	r29, 0x3e	; 62
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
	AVR_ENTER_CRITICAL_REGION( );
     368:	8f b7       	in	r24, 0x3f	; 63
     36a:	89 83       	std	Y+1, r24	; 0x01
     36c:	f8 94       	cli
#endif /* __MEMORY_MODEL__ */

#elif defined __GNUC__
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
     36e:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
     370:	23 e0       	ldi	r18, 0x03	; 3
     372:	83 e5       	ldi	r24, 0x53	; 83
     374:	90 e0       	ldi	r25, 0x00	; 0
     376:	fc 01       	movw	r30, r24
     378:	08 ed       	ldi	r16, 0xD8	; 216
     37a:	04 bf       	out	0x34, r16	; 52
     37c:	20 83       	st	Z, r18
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

#endif
	AVR_LEAVE_CRITICAL_REGION( );
     37e:	89 81       	ldd	r24, Y+1	; 0x01
     380:	8f bf       	out	0x3f, r24	; 63
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
}
     382:	0f 90       	pop	r0
     384:	cf 91       	pop	r28
     386:	df 91       	pop	r29
     388:	0f 91       	pop	r16
     38a:	08 95       	ret

0000038c <CLKSYS_Configuration_Lock>:
 *  This will lock the configuration until the next reset, or until the
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
     38c:	0f 93       	push	r16
     38e:	df 93       	push	r29
     390:	cf 93       	push	r28
     392:	0f 92       	push	r0
     394:	cd b7       	in	r28, 0x3d	; 61
     396:	de b7       	in	r29, 0x3e	; 62
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
	AVR_ENTER_CRITICAL_REGION( );
     398:	8f b7       	in	r24, 0x3f	; 63
     39a:	89 83       	std	Y+1, r24	; 0x01
     39c:	f8 94       	cli
#endif /* __MEMORY_MODEL__ */

#elif defined __GNUC__
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
     39e:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
     3a0:	21 e0       	ldi	r18, 0x01	; 1
     3a2:	82 e4       	ldi	r24, 0x42	; 66
     3a4:	90 e0       	ldi	r25, 0x00	; 0
     3a6:	fc 01       	movw	r30, r24
     3a8:	08 ed       	ldi	r16, 0xD8	; 216
     3aa:	04 bf       	out	0x34, r16	; 52
     3ac:	20 83       	st	Z, r18
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

#endif
	AVR_LEAVE_CRITICAL_REGION( );
     3ae:	89 81       	ldd	r24, Y+1	; 0x01
     3b0:	8f bf       	out	0x3f, r24	; 63
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
}
     3b2:	0f 90       	pop	r0
     3b4:	cf 91       	pop	r28
     3b6:	df 91       	pop	r29
     3b8:	0f 91       	pop	r16
     3ba:	08 95       	ret

000003bc <__vector_66>:
///////////////////		END PRINTF

//--------------------------------------------- INTERRUPTS ---------------------------------------
 
ISR(PORTA_INT0_vect) // Interrupt from W5100 
{
     3bc:	1f 92       	push	r1
     3be:	0f 92       	push	r0
     3c0:	0f b6       	in	r0, 0x3f	; 63
     3c2:	0f 92       	push	r0
     3c4:	08 b6       	in	r0, 0x38	; 56
     3c6:	0f 92       	push	r0
     3c8:	11 24       	eor	r1, r1
     3ca:	18 be       	out	0x38, r1	; 56
     3cc:	8f 93       	push	r24
	 PacketInBuf = 1;
     3ce:	81 e0       	ldi	r24, 0x01	; 1
     3d0:	80 93 65 21 	sts	0x2165, r24
	 //PORTF.OUTSET=PIN1_bm; // test com time
}
     3d4:	8f 91       	pop	r24
     3d6:	0f 90       	pop	r0
     3d8:	08 be       	out	0x38, r0	; 56
     3da:	0f 90       	pop	r0
     3dc:	0f be       	out	0x3f, r0	; 63
     3de:	0f 90       	pop	r0
     3e0:	1f 90       	pop	r1
     3e2:	18 95       	reti

000003e4 <__vector_83>:
    usart_rx_buf_put_byte(Temp);
    Temp++;
}

ISR(TCD1_OVF_vect) // Default 1 Hz
{
     3e4:	1f 92       	push	r1
     3e6:	0f 92       	push	r0
     3e8:	0f b6       	in	r0, 0x3f	; 63
     3ea:	0f 92       	push	r0
     3ec:	08 b6       	in	r0, 0x38	; 56
     3ee:	0f 92       	push	r0
     3f0:	0b b6       	in	r0, 0x3b	; 59
     3f2:	0f 92       	push	r0
     3f4:	11 24       	eor	r1, r1
     3f6:	18 be       	out	0x38, r1	; 56
     3f8:	1b be       	out	0x3b, r1	; 59
     3fa:	8f 93       	push	r24
     3fc:	ef 93       	push	r30
     3fe:	ff 93       	push	r31
 	PORTA.OUTTGL=PIN1_bm;
     400:	82 e0       	ldi	r24, 0x02	; 2
     402:	e0 e0       	ldi	r30, 0x00	; 0
     404:	f6 e0       	ldi	r31, 0x06	; 6
     406:	87 83       	std	Z+7, r24	; 0x07
	WDT_Reset();
     408:	a8 95       	wdr
}
     40a:	ff 91       	pop	r31
     40c:	ef 91       	pop	r30
     40e:	8f 91       	pop	r24
     410:	0f 90       	pop	r0
     412:	0b be       	out	0x3b, r0	; 59
     414:	0f 90       	pop	r0
     416:	08 be       	out	0x38, r0	; 56
     418:	0f 90       	pop	r0
     41a:	0f be       	out	0x3f, r0	; 63
     41c:	0f 90       	pop	r0
     41e:	1f 90       	pop	r1
     420:	18 95       	reti

00000422 <uart_putchar>:
///////////////////		START PRINTF

#include <stdio.h>

static int uart_putchar(char c, FILE *stream)
{
     422:	1f 93       	push	r17
     424:	18 2f       	mov	r17, r24
   if (c == '\n') uart_putchar('\r', stream);
     426:	8a 30       	cpi	r24, 0x0A	; 10
     428:	19 f4       	brne	.+6      	; 0x430 <uart_putchar+0xe>
     42a:	8d e0       	ldi	r24, 0x0D	; 13
     42c:	0e 94 11 02 	call	0x422	; 0x422 <uart_putchar>
   usart_send_byte(c);
     430:	81 2f       	mov	r24, r17
     432:	0e 94 26 05 	call	0xa4c	; 0xa4c <usart_send_byte>
   return 0;
}
     436:	80 e0       	ldi	r24, 0x00	; 0
     438:	90 e0       	ldi	r25, 0x00	; 0
     43a:	1f 91       	pop	r17
     43c:	08 95       	ret

0000043e <error_usa>:
	usart_send_byte('a');
}

void error_usa(void)
{
	usart_send_byte('e');
     43e:	85 e6       	ldi	r24, 0x65	; 101
     440:	0e 94 26 05 	call	0xa4c	; 0xa4c <usart_send_byte>
}
     444:	08 95       	ret

00000446 <acknowledge_usa>:
	return(newbyte);
}

void acknowledge_usa(void)
{
	usart_send_byte('a');
     446:	81 e6       	ldi	r24, 0x61	; 97
     448:	0e 94 26 05 	call	0xa4c	; 0xa4c <usart_send_byte>
}
     44c:	08 95       	ret

0000044e <error_eth>:
	Response[0] = 'a';
	sendto(sock,Response,RespLen,remoteIp,remotePort);
}

void error_eth(void)
{
     44e:	0f 93       	push	r16
     450:	1f 93       	push	r17
	SOCKET sock = 0x01;
	RespLen = 1;
     452:	81 e0       	ldi	r24, 0x01	; 1
     454:	80 93 64 21 	sts	0x2164, r24
	Response[0] = 'e';
     458:	85 e6       	ldi	r24, 0x65	; 101
     45a:	80 93 41 21 	sts	0x2141, r24
	sendto(sock,Response,RespLen,remoteIp,remotePort);
     45e:	00 91 62 21 	lds	r16, 0x2162
     462:	10 91 63 21 	lds	r17, 0x2163
     466:	81 e0       	ldi	r24, 0x01	; 1
     468:	61 e4       	ldi	r22, 0x41	; 65
     46a:	71 e2       	ldi	r23, 0x21	; 33
     46c:	41 e0       	ldi	r20, 0x01	; 1
     46e:	50 e0       	ldi	r21, 0x00	; 0
     470:	2b e3       	ldi	r18, 0x3B	; 59
     472:	31 e2       	ldi	r19, 0x21	; 33
     474:	0e 94 8b 0a 	call	0x1516	; 0x1516 <sendto>
}
     478:	1f 91       	pop	r17
     47a:	0f 91       	pop	r16
     47c:	08 95       	ret

0000047e <acknowledge_eth>:
{
	usart_send_byte('e');
}

void acknowledge_eth(void)
{
     47e:	0f 93       	push	r16
     480:	1f 93       	push	r17
	SOCKET sock = 0x01;
	RespLen = 1;
     482:	81 e0       	ldi	r24, 0x01	; 1
     484:	80 93 64 21 	sts	0x2164, r24
	Response[0] = 'a';
     488:	81 e6       	ldi	r24, 0x61	; 97
     48a:	80 93 41 21 	sts	0x2141, r24
	sendto(sock,Response,RespLen,remoteIp,remotePort);
     48e:	00 91 62 21 	lds	r16, 0x2162
     492:	10 91 63 21 	lds	r17, 0x2163
     496:	81 e0       	ldi	r24, 0x01	; 1
     498:	61 e4       	ldi	r22, 0x41	; 65
     49a:	71 e2       	ldi	r23, 0x21	; 33
     49c:	41 e0       	ldi	r20, 0x01	; 1
     49e:	50 e0       	ldi	r21, 0x00	; 0
     4a0:	2b e3       	ldi	r18, 0x3B	; 59
     4a2:	31 e2       	ldi	r19, 0x21	; 33
     4a4:	0e 94 8b 0a 	call	0x1516	; 0x1516 <sendto>
}
     4a8:	1f 91       	pop	r17
     4aa:	0f 91       	pop	r16
     4ac:	08 95       	ret

000004ae <Next_Byte_eth>:
 	PacketInBuf = 0;
	Packet_Pointer = DataSize; 
} 

uint8_t Next_Byte_eth(void)
{
     4ae:	1f 93       	push	r17
	uint8_t newbyte;
	newbyte=packetBuffer[DataSize-Packet_Pointer];
     4b0:	80 91 40 21 	lds	r24, 0x2140
     4b4:	e0 91 61 21 	lds	r30, 0x2161
     4b8:	f0 e0       	ldi	r31, 0x00	; 0
     4ba:	e8 1b       	sub	r30, r24
     4bc:	f1 09       	sbc	r31, r1
     4be:	e5 5e       	subi	r30, 0xE5	; 229
     4c0:	fe 4d       	sbci	r31, 0xDE	; 222
     4c2:	10 81       	ld	r17, Z
	Packet_Pointer--;
     4c4:	81 50       	subi	r24, 0x01	; 1
     4c6:	80 93 40 21 	sts	0x2140, r24
			
	if (Packet_Pointer == 0)
     4ca:	88 23       	and	r24, r24
     4cc:	29 f4       	brne	.+10     	; 0x4d8 <Next_Byte_eth+0x2a>
	{
			IINCHIP_WRITE(Sn_IR(1), 0xff);
     4ce:	82 e0       	ldi	r24, 0x02	; 2
     4d0:	95 e0       	ldi	r25, 0x05	; 5
     4d2:	6f ef       	ldi	r22, 0xFF	; 255
     4d4:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
			//PacketRespTo = 1;
	}
	
	return(newbyte);
}
     4d8:	81 2f       	mov	r24, r17
     4da:	1f 91       	pop	r17
     4dc:	08 95       	ret

000004de <Read_Packet_eth>:
}

 
//-------------------------------------------- END INTERRUPTS -------------------------------------
void Read_Packet_eth(void)
{
     4de:	0f 93       	push	r16
     4e0:	1f 93       	push	r17
	SOCKET sock = 0x01;
 	packetSize= getSn_RX_RSR(sock); // get received size
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	0e 94 e7 08 	call	0x11ce	; 0x11ce <getSn_RX_RSR>
     4e8:	48 2f       	mov	r20, r24
     4ea:	80 93 3f 21 	sts	0x213F, r24
	DataSize = recvfrom(sock,packetBuffer,packetSize,remoteIp,&remotePort);
     4ee:	81 e0       	ldi	r24, 0x01	; 1
     4f0:	6b e1       	ldi	r22, 0x1B	; 27
     4f2:	71 e2       	ldi	r23, 0x21	; 33
     4f4:	50 e0       	ldi	r21, 0x00	; 0
     4f6:	2b e3       	ldi	r18, 0x3B	; 59
     4f8:	31 e2       	ldi	r19, 0x21	; 33
     4fa:	02 e6       	ldi	r16, 0x62	; 98
     4fc:	11 e2       	ldi	r17, 0x21	; 33
     4fe:	0e 94 bf 09 	call	0x137e	; 0x137e <recvfrom>
     502:	80 93 61 21 	sts	0x2161, r24
 	PacketInBuf = 0;
     506:	10 92 65 21 	sts	0x2165, r1
	Packet_Pointer = DataSize; 
     50a:	80 93 40 21 	sts	0x2140, r24
} 
     50e:	1f 91       	pop	r17
     510:	0f 91       	pop	r16
     512:	08 95       	ret

00000514 <main>:
	sendto(sock,Response,RespLen,remoteIp,remotePort);
}


int main(void)
{
     514:	af 92       	push	r10
     516:	bf 92       	push	r11
     518:	cf 92       	push	r12
     51a:	df 92       	push	r13
     51c:	ef 92       	push	r14
     51e:	ff 92       	push	r15
     520:	0f 93       	push	r16
     522:	1f 93       	push	r17
     524:	df 93       	push	r29
     526:	cf 93       	push	r28
     528:	00 d0       	rcall	.+0      	; 0x52a <main+0x16>
     52a:	00 d0       	rcall	.+0      	; 0x52c <main+0x18>
     52c:	cd b7       	in	r28, 0x3d	; 61
     52e:	de b7       	in	r29, 0x3e	; 62

uint8_t STATUS = 1;

static void clock_init(void)
{   
    CLKSYS_Enable( OSC_RC32MEN_bm );
     530:	80 91 50 00 	lds	r24, 0x0050
     534:	82 60       	ori	r24, 0x02	; 2
     536:	80 93 50 00 	sts	0x0050, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
     53a:	80 e0       	ldi	r24, 0x00	; 0
     53c:	60 e0       	ldi	r22, 0x00	; 0
     53e:	0e 94 52 01 	call	0x2a4	; 0x2a4 <CLKSYS_Prescalers_Config>
	do {} while ( CLKSYS_IsReady( OSC_RC32MRDY_bm ) == 0 );
     542:	80 91 51 00 	lds	r24, 0x0051
     546:	81 ff       	sbrs	r24, 1
     548:	fc cf       	rjmp	.-8      	; 0x542 <main+0x2e>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     54a:	81 e0       	ldi	r24, 0x01	; 1
     54c:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable(OSC_RC2MCREF_bm);
     550:	81 e0       	ldi	r24, 0x01	; 1
     552:	0e 94 48 01 	call	0x290	; 0x290 <CLKSYS_Disable>
	CLKSYS_AutoCalibration_Enable(OSC_RC32MCREF_bm,1);
     556:	82 e0       	ldi	r24, 0x02	; 2
     558:	61 e0       	ldi	r22, 0x01	; 1
     55a:	0e 94 8f 01 	call	0x31e	; 0x31e <CLKSYS_AutoCalibration_Enable>
}

static void UsartC_init(void)
{
	usart_init(&PORTC, &USARTC0, 256000);
     55e:	80 e4       	ldi	r24, 0x40	; 64
     560:	96 e0       	ldi	r25, 0x06	; 6
     562:	60 ea       	ldi	r22, 0xA0	; 160
     564:	78 e0       	ldi	r23, 0x08	; 8
     566:	20 e0       	ldi	r18, 0x00	; 0
     568:	38 ee       	ldi	r19, 0xE8	; 232
     56a:	43 e0       	ldi	r20, 0x03	; 3
     56c:	50 e0       	ldi	r21, 0x00	; 0
     56e:	0e 94 b7 04 	call	0x96e	; 0x96e <usart_init>
{

	clock_init();
	UsartC_init();

	stdout = &mystdout; //printf 
     572:	88 eb       	ldi	r24, 0xB8	; 184
     574:	90 e2       	ldi	r25, 0x20	; 32
     576:	80 93 68 21 	sts	0x2168, r24
     57a:	90 93 69 21 	sts	0x2169, r25
	usart_rx_buf_flush(); //remove bad data we got at startup
     57e:	0e 94 e6 04 	call	0x9cc	; 0x9cc <usart_rx_buf_flush>
    
	printf("\n******* Booting up Xmegaboard ********\n");
     582:	80 e0       	ldi	r24, 0x00	; 0
     584:	90 e2       	ldi	r25, 0x20	; 32
     586:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <puts>
	PORTA.OUTSET=PIN1_bm;	// at the end of init

*/


	PORTJ.DIRSET = 0xFF;	// DA Array
     58a:	8f ef       	ldi	r24, 0xFF	; 255
     58c:	e0 e0       	ldi	r30, 0x00	; 0
     58e:	f7 e0       	ldi	r31, 0x07	; 7
     590:	81 83       	std	Z+1, r24	; 0x01
	PORTK.DIRSET = 0xFF;	// DA Array
     592:	e0 e2       	ldi	r30, 0x20	; 32
     594:	f7 e0       	ldi	r31, 0x07	; 7
     596:	81 83       	std	Z+1, r24	; 0x01



//SS_DFL, same SPID as Wiznet
	PORTQ.DIRSET = PIN3_bm;
     598:	e0 ec       	ldi	r30, 0xC0	; 192
     59a:	f7 e0       	ldi	r31, 0x07	; 7
     59c:	88 e0       	ldi	r24, 0x08	; 8
     59e:	81 83       	std	Z+1, r24	; 0x01
	PORTQ.OUTSET = PIN3_bm;
     5a0:	85 83       	std	Z+5, r24	; 0x05

// Enable SPI on Wiznet W5100
	PORTH.DIRSET=PIN7_bm;  
     5a2:	f0 ee       	ldi	r31, 0xE0	; 224
     5a4:	af 2e       	mov	r10, r31
     5a6:	f6 e0       	ldi	r31, 0x06	; 6
     5a8:	bf 2e       	mov	r11, r31
     5aa:	10 e8       	ldi	r17, 0x80	; 128
     5ac:	d5 01       	movw	r26, r10
     5ae:	11 96       	adiw	r26, 0x01	; 1
     5b0:	1c 93       	st	X, r17
     5b2:	11 97       	sbiw	r26, 0x01	; 1
 	PORTH.OUTSET=PIN7_bm;
     5b4:	15 96       	adiw	r26, 0x05	; 5
     5b6:	1c 93       	st	X, r17

// Enable power to Wiznet W5100
	PORTA.DIRSET=PIN0_bm;  
     5b8:	c1 2c       	mov	r12, r1
     5ba:	e6 e0       	ldi	r30, 0x06	; 6
     5bc:	de 2e       	mov	r13, r30
     5be:	81 e0       	ldi	r24, 0x01	; 1
     5c0:	f6 01       	movw	r30, r12
     5c2:	81 83       	std	Z+1, r24	; 0x01
 	PORTA.OUTSET=PIN0_bm;
     5c4:	85 83       	std	Z+5, r24	; 0x05

// reset w5100
	PORTF.DIRSET=PIN6_bm; // pin5 on revB
     5c6:	e0 ea       	ldi	r30, 0xA0	; 160
     5c8:	f6 e0       	ldi	r31, 0x06	; 6
     5ca:	80 e4       	ldi	r24, 0x40	; 64
     5cc:	81 83       	std	Z+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     5ce:	95 e1       	ldi	r25, 0x15	; 21
     5d0:	9a 95       	dec	r25
     5d2:	f1 f7       	brne	.-4      	; 0x5d0 <main+0xbc>
	_delay_us(2);
	PORTF.OUTSET=PIN6_bm;
     5d4:	85 83       	std	Z+5, r24	; 0x05




	/* Configure PA2 as input, triggered on falling edge. */
	PORT_ConfigurePins( &PORTA,
     5d6:	80 e0       	ldi	r24, 0x00	; 0
     5d8:	96 e0       	ldi	r25, 0x06	; 6
     5da:	64 e0       	ldi	r22, 0x04	; 4
     5dc:	40 e0       	ldi	r20, 0x00	; 0
     5de:	20 e0       	ldi	r18, 0x00	; 0
     5e0:	00 e0       	ldi	r16, 0x00	; 0
     5e2:	72 e0       	ldi	r23, 0x02	; 2
     5e4:	e7 2e       	mov	r14, r23
     5e6:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <PORT_ConfigurePins>
	                    false,
	                    false,
	                    PORT_OPC_TOTEM_gc,
	                    PORT_ISC_FALLING_gc );

	PORT_SetPinsAsInput( &PORTA, PIN2_bm );
     5ea:	84 e0       	ldi	r24, 0x04	; 4
     5ec:	d6 01       	movw	r26, r12
     5ee:	12 96       	adiw	r26, 0x02	; 2
     5f0:	8c 93       	st	X, r24

 
	/* Configure Interrupt0 to have low interrupt level, triggered by pin 0. */
	PORT_ConfigureInterrupt0( &PORTA, PORT_INT0LVL_MED_gc, PIN2_bm );
     5f2:	80 e0       	ldi	r24, 0x00	; 0
     5f4:	96 e0       	ldi	r25, 0x06	; 6
     5f6:	62 e0       	ldi	r22, 0x02	; 2
     5f8:	44 e0       	ldi	r20, 0x04	; 4
     5fa:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <PORT_ConfigureInterrupt0>
}

static void ETH_Init(void)
{     
    //Enabling SPI on wiznet chip
    PORTH.DIRSET = PIN7_bm;
     5fe:	f5 01       	movw	r30, r10
     600:	11 83       	std	Z+1, r17	; 0x01
    PORTH.OUTSET = PIN7_bm;
     602:	15 83       	std	Z+5, r17	; 0x05
    // setting up SPI
    SPID_Init();
     604:	0e 94 91 04 	call	0x922	; 0x922 <SPID_Init>

    printf("Reseting iinchip\n");
     608:	88 e2       	ldi	r24, 0x28	; 40
     60a:	90 e2       	ldi	r25, 0x20	; 32
     60c:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <puts>
     610:	88 ee       	ldi	r24, 0xE8	; 232
     612:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     614:	20 e2       	ldi	r18, 0x20	; 32
     616:	33 e0       	ldi	r19, 0x03	; 3
     618:	f9 01       	movw	r30, r18
     61a:	31 97       	sbiw	r30, 0x01	; 1
     61c:	f1 f7       	brne	.-4      	; 0x61a <main+0x106>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     61e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     620:	d9 f7       	brne	.-10     	; 0x618 <main+0x104>
    _delay_ms(100); // as done in dns example from wiznet

	iinchip_init(); // reset iinchip. This might not be necessary for SPI communication
     622:	0e 94 14 06 	call	0xc28	; 0xc28 <iinchip_init>

    
	uint8_t ip[6]; //6 because it is also used for the mac address
	printf("Setting mac, subnet and gateway\n");
     626:	89 e3       	ldi	r24, 0x39	; 57
     628:	90 e2       	ldi	r25, 0x20	; 32
     62a:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <puts>
	// MAC address
	ip[0] = 0x00; ip[1] = 0x08; ip[2] = 0xDC; ip[3] = 0x00; ip[4] = 0x00; ip[5] = 0x4F;
     62e:	19 82       	std	Y+1, r1	; 0x01
     630:	88 e0       	ldi	r24, 0x08	; 8
     632:	8a 83       	std	Y+2, r24	; 0x02
     634:	8c ed       	ldi	r24, 0xDC	; 220
     636:	8b 83       	std	Y+3, r24	; 0x03
     638:	1c 82       	std	Y+4, r1	; 0x04
     63a:	1d 82       	std	Y+5, r1	; 0x05
     63c:	8f e4       	ldi	r24, 0x4F	; 79
     63e:	8e 83       	std	Y+6, r24	; 0x06
	setMacAddress( ip );
     640:	8e 01       	movw	r16, r28
     642:	0f 5f       	subi	r16, 0xFF	; 255
     644:	1f 4f       	sbci	r17, 0xFF	; 255
     646:	c8 01       	movw	r24, r16
     648:	0e 94 36 06 	call	0xc6c	; 0xc6c <setMacAddress>

	// subnet mask
	ip[0] = 255;ip[1] = 255;ip[2] = 255;ip[3] = 0;
     64c:	8f ef       	ldi	r24, 0xFF	; 255
     64e:	89 83       	std	Y+1, r24	; 0x01
     650:	8a 83       	std	Y+2, r24	; 0x02
     652:	8b 83       	std	Y+3, r24	; 0x03
     654:	1c 82       	std	Y+4, r1	; 0x04
	setSubnetMask( ip );
     656:	c8 01       	movw	r24, r16
     658:	0e 94 60 06 	call	0xcc0	; 0xcc0 <setSubnetMask>

	// gateway address
	ip[0] =192 ;ip[1] = 168;ip[2] = 0;ip[3] = 1;
     65c:	50 ec       	ldi	r21, 0xC0	; 192
     65e:	e5 2e       	mov	r14, r21
     660:	e9 82       	std	Y+1, r14	; 0x01
     662:	48 ea       	ldi	r20, 0xA8	; 168
     664:	f4 2e       	mov	r15, r20
     666:	fa 82       	std	Y+2, r15	; 0x02
     668:	1b 82       	std	Y+3, r1	; 0x03
     66a:	81 e0       	ldi	r24, 0x01	; 1
     66c:	8c 83       	std	Y+4, r24	; 0x04
	setGatewayAddress( ip );
     66e:	c8 01       	movw	r24, r16
     670:	0e 94 7e 06 	call	0xcfc	; 0xcfc <setGatewayAddress>

	// ip address
	ip[0] = 192;ip[1] = 168;ip[2] = 0;ip[3] = 100;
     674:	e9 82       	std	Y+1, r14	; 0x01
     676:	fa 82       	std	Y+2, r15	; 0x02
     678:	1b 82       	std	Y+3, r1	; 0x03
     67a:	84 e6       	ldi	r24, 0x64	; 100
     67c:	8c 83       	std	Y+4, r24	; 0x04
	printf("Setting IP address %i.%i.%i.%i \n",ip[0], ip[1], ip[2], ip[3]);
     67e:	8d b7       	in	r24, 0x3d	; 61
     680:	9e b7       	in	r25, 0x3e	; 62
     682:	0a 97       	sbiw	r24, 0x0a	; 10
     684:	8d bf       	out	0x3d, r24	; 61
     686:	9e bf       	out	0x3e, r25	; 62
     688:	ed b7       	in	r30, 0x3d	; 61
     68a:	fe b7       	in	r31, 0x3e	; 62
     68c:	31 96       	adiw	r30, 0x01	; 1
     68e:	89 e5       	ldi	r24, 0x59	; 89
     690:	90 e2       	ldi	r25, 0x20	; 32
     692:	ad b7       	in	r26, 0x3d	; 61
     694:	be b7       	in	r27, 0x3e	; 62
     696:	11 96       	adiw	r26, 0x01	; 1
     698:	8d 93       	st	X+, r24
     69a:	9c 93       	st	X, r25
     69c:	12 97       	sbiw	r26, 0x02	; 2
     69e:	89 81       	ldd	r24, Y+1	; 0x01
     6a0:	82 83       	std	Z+2, r24	; 0x02
     6a2:	13 82       	std	Z+3, r1	; 0x03
     6a4:	8a 81       	ldd	r24, Y+2	; 0x02
     6a6:	84 83       	std	Z+4, r24	; 0x04
     6a8:	15 82       	std	Z+5, r1	; 0x05
     6aa:	8b 81       	ldd	r24, Y+3	; 0x03
     6ac:	86 83       	std	Z+6, r24	; 0x06
     6ae:	17 82       	std	Z+7, r1	; 0x07
     6b0:	84 e6       	ldi	r24, 0x64	; 100
     6b2:	90 e0       	ldi	r25, 0x00	; 0
     6b4:	80 87       	std	Z+8, r24	; 0x08
     6b6:	91 87       	std	Z+9, r25	; 0x09
     6b8:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <printf>
	setIPAddress( ip );
     6bc:	ed b7       	in	r30, 0x3d	; 61
     6be:	fe b7       	in	r31, 0x3e	; 62
     6c0:	3a 96       	adiw	r30, 0x0a	; 10
     6c2:	ed bf       	out	0x3d, r30	; 61
     6c4:	fe bf       	out	0x3e, r31	; 62
     6c6:	c8 01       	movw	r24, r16
     6c8:	0e 94 18 06 	call	0xc30	; 0xc30 <setIPAddress>

    //printf("Setting mask\n");
    //setIMR( 0xEF); // set interrupt mask == do we generate interrupt for IP conflict, Dest unreachable, ...
    //
	
	printf("sysinit\n");
     6cc:	8a e7       	ldi	r24, 0x7A	; 122
     6ce:	90 e2       	ldi	r25, 0x20	; 32
     6d0:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <puts>
	sysinit(0x11, 0x11); // setting tx/rx buf size 0x11 is 8 kbytes ans is he maximum for the chip
     6d4:	81 e1       	ldi	r24, 0x11	; 17
     6d6:	61 e1       	ldi	r22, 0x11	; 17
     6d8:	0e 94 9c 06 	call	0xd38	; 0xd38 <sysinit>

static void UDP_Init(void) 
{
	uint16_t port = 1776;
    SOCKET sock = 0x01;
	setIMR(0b00000010); // Enable interrupt on socket 1
     6dc:	82 e0       	ldi	r24, 0x02	; 2
     6de:	0e 94 ca 07 	call	0xf94	; 0xf94 <setIMR>
	printf("Opening socket on port : %d \n", port);
     6e2:	00 d0       	rcall	.+0      	; 0x6e4 <main+0x1d0>
     6e4:	0f 92       	push	r0
     6e6:	82 e8       	ldi	r24, 0x82	; 130
     6e8:	90 e2       	ldi	r25, 0x20	; 32
     6ea:	ad b7       	in	r26, 0x3d	; 61
     6ec:	be b7       	in	r27, 0x3e	; 62
     6ee:	11 96       	adiw	r26, 0x01	; 1
     6f0:	8d 93       	st	X+, r24
     6f2:	9c 93       	st	X, r25
     6f4:	12 97       	sbiw	r26, 0x02	; 2
     6f6:	80 ef       	ldi	r24, 0xF0	; 240
     6f8:	96 e0       	ldi	r25, 0x06	; 6
     6fa:	13 96       	adiw	r26, 0x03	; 3
     6fc:	8d 93       	st	X+, r24
     6fe:	9c 93       	st	X, r25
     700:	14 97       	sbiw	r26, 0x04	; 4
     702:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <printf>
     706:	0f 90       	pop	r0
     708:	0f 90       	pop	r0
     70a:	0f 90       	pop	r0
     70c:	0f 90       	pop	r0
 
    while ( socket(sock,  Sn_MR_UDP, port , 0x00) != 1 ) { // create socket.
        printf("socket creation failed");
     70e:	30 ea       	ldi	r19, 0xA0	; 160
     710:	e3 2e       	mov	r14, r19
     712:	30 e2       	ldi	r19, 0x20	; 32
     714:	f3 2e       	mov	r15, r19
     716:	00 e2       	ldi	r16, 0x20	; 32
     718:	13 e0       	ldi	r17, 0x03	; 3
     71a:	11 c0       	rjmp	.+34     	; 0x73e <main+0x22a>
     71c:	0f 92       	push	r0
     71e:	0f 92       	push	r0
     720:	ed b7       	in	r30, 0x3d	; 61
     722:	fe b7       	in	r31, 0x3e	; 62
     724:	e1 82       	std	Z+1, r14	; 0x01
     726:	f2 82       	std	Z+2, r15	; 0x02
     728:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <printf>
     72c:	80 e1       	ldi	r24, 0x10	; 16
     72e:	97 e2       	ldi	r25, 0x27	; 39
     730:	0f 90       	pop	r0
     732:	0f 90       	pop	r0
     734:	f8 01       	movw	r30, r16
     736:	31 97       	sbiw	r30, 0x01	; 1
     738:	f1 f7       	brne	.-4      	; 0x736 <main+0x222>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     73a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     73c:	d9 f7       	brne	.-10     	; 0x734 <main+0x220>
	uint16_t port = 1776;
    SOCKET sock = 0x01;
	setIMR(0b00000010); // Enable interrupt on socket 1
	printf("Opening socket on port : %d \n", port);
 
    while ( socket(sock,  Sn_MR_UDP, port , 0x00) != 1 ) { // create socket.
     73e:	81 e0       	ldi	r24, 0x01	; 1
     740:	62 e0       	ldi	r22, 0x02	; 2
     742:	40 ef       	ldi	r20, 0xF0	; 240
     744:	56 e0       	ldi	r21, 0x06	; 6
     746:	20 e0       	ldi	r18, 0x00	; 0
     748:	0e 94 65 0c 	call	0x18ca	; 0x18ca <socket>
     74c:	81 30       	cpi	r24, 0x01	; 1
     74e:	31 f7       	brne	.-52     	; 0x71c <main+0x208>
	
	ETH_Init();
	
	UDP_Init(); 

	WDT_EnableAndSetTimeout( WDT_PER_2KCLK_gc );
     750:	80 e2       	ldi	r24, 0x20	; 32
     752:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <WDT_EnableAndSetTimeout>
	
	PMIC.CTRL |= PMIC_LOLVLEN_bm; //Enable low level Interrupts 
     756:	e0 ea       	ldi	r30, 0xA0	; 160
     758:	f0 e0       	ldi	r31, 0x00	; 0
     75a:	80 91 a2 00 	lds	r24, 0x00A2
     75e:	81 60       	ori	r24, 0x01	; 1
     760:	82 83       	std	Z+2, r24	; 0x02
	PMIC.CTRL |= PMIC_MEDLVLEN_bm;//Enable Medium level Interrupts
     762:	80 91 a2 00 	lds	r24, 0x00A2
     766:	82 60       	ori	r24, 0x02	; 2
     768:	82 83       	std	Z+2, r24	; 0x02
	PMIC.CTRL |= PMIC_HILVLEN_bm; //Enable High level Interrupts
     76a:	80 91 a2 00 	lds	r24, 0x00A2
     76e:	84 60       	ori	r24, 0x04	; 4
     770:	82 83       	std	Z+2, r24	; 0x02
	sei();
     772:	78 94       	sei

		// status led
	PORTA.DIRSET=PIN1_bm;
     774:	82 e0       	ldi	r24, 0x02	; 2
     776:	e0 e0       	ldi	r30, 0x00	; 0
     778:	f6 e0       	ldi	r31, 0x06	; 6
     77a:	81 83       	std	Z+1, r24	; 0x01
}


static void init_status_tick(void){
	/* Set up Timer/Counter E0 with OVF interrupt. */
	TCD1.INTCTRLA = (TCD1.INTCTRLA & ~TC1_OVFINTLVL_gm) | TC_OVFINTLVL_LO_gc;	//enable overflow interrupt: OFF test
     77c:	e0 e4       	ldi	r30, 0x40	; 64
     77e:	f9 e0       	ldi	r31, 0x09	; 9
     780:	80 91 46 09 	lds	r24, 0x0946
     784:	8c 7f       	andi	r24, 0xFC	; 252
     786:	81 60       	ori	r24, 0x01	; 1
     788:	86 83       	std	Z+6, r24	; 0x06
 	
	switch (STATUS)
     78a:	80 91 b7 20 	lds	r24, 0x20B7
     78e:	82 30       	cpi	r24, 0x02	; 2
     790:	19 f0       	breq	.+6      	; 0x798 <main+0x284>
     792:	83 30       	cpi	r24, 0x03	; 3
     794:	39 f4       	brne	.+14     	; 0x7a4 <main+0x290>
     796:	03 c0       	rjmp	.+6      	; 0x79e <main+0x28a>
	{
		case 1:	TCD1.PER =31250; break;
		case 2: TCD1.PER =31250/2; break;
     798:	89 e0       	ldi	r24, 0x09	; 9
     79a:	9d e3       	ldi	r25, 0x3D	; 61
     79c:	05 c0       	rjmp	.+10     	; 0x7a8 <main+0x294>
		case 3: TCD1.PER =31250/10; break;
     79e:	85 e3       	ldi	r24, 0x35	; 53
     7a0:	9c e0       	ldi	r25, 0x0C	; 12
     7a2:	02 c0       	rjmp	.+4      	; 0x7a8 <main+0x294>
 		default:TCD1.PER =31250; break;
     7a4:	82 e1       	ldi	r24, 0x12	; 18
     7a6:	9a e7       	ldi	r25, 0x7A	; 122
     7a8:	86 a3       	std	Z+38, r24	; 0x26
     7aa:	97 a3       	std	Z+39, r25	; 0x27
	}		
	
	//TCD1.PER =31250;  
 	TCD1.CTRLA = TC_CLKSEL_DIV1024_gc; // 1 Hz
     7ac:	87 e0       	ldi	r24, 0x07	; 7
     7ae:	80 93 40 09 	sts	0x0940, r24
					break;
				case 'K':
				case 'k':
					if (Packet_Pointer > 0)
					{
						PORTK.OUT = Next_Byte_eth();
     7b2:	20 e2       	ldi	r18, 0x20	; 32
     7b4:	a2 2e       	mov	r10, r18
     7b6:	27 e0       	ldi	r18, 0x07	; 7
     7b8:	b2 2e       	mov	r11, r18
 /**************************************** I/O Connected to Darlington Array's ***********************************/
				case 'J':
				case 'j':
					if (Packet_Pointer > 0)
					{
						PORTJ.OUT = Next_Byte_eth();
     7ba:	c1 2c       	mov	r12, r1
     7bc:	97 e0       	ldi	r25, 0x07	; 7
     7be:	d9 2e       	mov	r13, r25
					acknowledge_eth();
					break;
/************************************* Turn off power to eth chip W5100 *****************************/
				case 'w':
					acknowledge_eth();
					PORTA.OUTCLR=PIN0_bm;
     7c0:	e1 2c       	mov	r14, r1
     7c2:	86 e0       	ldi	r24, 0x06	; 6
     7c4:	f8 2e       	mov	r15, r24
     7c6:	00 e2       	ldi	r16, 0x20	; 32
     7c8:	13 e0       	ldi	r17, 0x03	; 3
	init_status_tick();

 
	while(1)
	{
		if (PacketInBuf == 1 && (0x04 & getSn_IR(0x01)))		// falling edge and bit Res (bit 2) in Socket 01 set.
     7ca:	80 91 65 21 	lds	r24, 0x2165
     7ce:	81 30       	cpi	r24, 0x01	; 1
     7d0:	31 f4       	brne	.+12     	; 0x7de <main+0x2ca>
     7d2:	0e 94 c9 0c 	call	0x1992	; 0x1992 <getSn_IR>
     7d6:	82 ff       	sbrs	r24, 2
     7d8:	02 c0       	rjmp	.+4      	; 0x7de <main+0x2ca>
		{	
			Read_Packet_eth();
     7da:	0e 94 6f 02 	call	0x4de	; 0x4de <Read_Packet_eth>
		}		
//////////////// Respond to command from UDP on port 1776		

		if (Packet_Pointer > 0)
     7de:	80 91 40 21 	lds	r24, 0x2140
     7e2:	88 23       	and	r24, r24
     7e4:	91 f1       	breq	.+100    	; 0x84a <main+0x336>
		{
 			
		
		switch (Next_Byte_eth())
     7e6:	0e 94 57 02 	call	0x4ae	; 0x4ae <Next_Byte_eth>
     7ea:	81 36       	cpi	r24, 0x61	; 97
     7ec:	f9 f0       	breq	.+62     	; 0x82c <main+0x318>
     7ee:	82 36       	cpi	r24, 0x62	; 98
     7f0:	38 f4       	brcc	.+14     	; 0x800 <main+0x2ec>
     7f2:	8a 34       	cpi	r24, 0x4A	; 74
     7f4:	99 f0       	breq	.+38     	; 0x81c <main+0x308>
     7f6:	8b 34       	cpi	r24, 0x4B	; 75
     7f8:	e1 f0       	breq	.+56     	; 0x832 <main+0x31e>
     7fa:	81 34       	cpi	r24, 0x41	; 65
     7fc:	21 f5       	brne	.+72     	; 0x846 <main+0x332>
     7fe:	16 c0       	rjmp	.+44     	; 0x82c <main+0x318>
     800:	8b 36       	cpi	r24, 0x6B	; 107
     802:	b9 f0       	breq	.+46     	; 0x832 <main+0x31e>
     804:	87 37       	cpi	r24, 0x77	; 119
     806:	19 f0       	breq	.+6      	; 0x80e <main+0x2fa>
     808:	8a 36       	cpi	r24, 0x6A	; 106
     80a:	e9 f4       	brne	.+58     	; 0x846 <main+0x332>
     80c:	07 c0       	rjmp	.+14     	; 0x81c <main+0x308>
				case 'a':
					acknowledge_eth();
					break;
/************************************* Turn off power to eth chip W5100 *****************************/
				case 'w':
					acknowledge_eth();
     80e:	0e 94 3f 02 	call	0x47e	; 0x47e <acknowledge_eth>
					PORTA.OUTCLR=PIN0_bm;
     812:	81 e0       	ldi	r24, 0x01	; 1
     814:	d7 01       	movw	r26, r14
     816:	16 96       	adiw	r26, 0x06	; 6
     818:	8c 93       	st	X, r24
     81a:	17 c0       	rjmp	.+46     	; 0x84a <main+0x336>
					break;
 /**************************************** I/O Connected to Darlington Array's ***********************************/
				case 'J':
				case 'j':
					if (Packet_Pointer > 0)
     81c:	80 91 40 21 	lds	r24, 0x2140
     820:	88 23       	and	r24, r24
     822:	89 f0       	breq	.+34     	; 0x846 <main+0x332>
					{
						PORTJ.OUT = Next_Byte_eth();
     824:	0e 94 57 02 	call	0x4ae	; 0x4ae <Next_Byte_eth>
     828:	f6 01       	movw	r30, r12
     82a:	84 83       	std	Z+4, r24	; 0x04
				 		acknowledge_eth();
     82c:	0e 94 3f 02 	call	0x47e	; 0x47e <acknowledge_eth>
     830:	0c c0       	rjmp	.+24     	; 0x84a <main+0x336>
						error_eth();
					}
					break;
				case 'K':
				case 'k':
					if (Packet_Pointer > 0)
     832:	80 91 40 21 	lds	r24, 0x2140
     836:	88 23       	and	r24, r24
     838:	31 f0       	breq	.+12     	; 0x846 <main+0x332>
					{
						PORTK.OUT = Next_Byte_eth();
     83a:	0e 94 57 02 	call	0x4ae	; 0x4ae <Next_Byte_eth>
     83e:	d5 01       	movw	r26, r10
     840:	14 96       	adiw	r26, 0x04	; 4
     842:	8c 93       	st	X, r24
     844:	f3 cf       	rjmp	.-26     	; 0x82c <main+0x318>
					{
						error_eth();
					}
					break;
 				default:
				error_eth(); 
     846:	0e 94 27 02 	call	0x44e	; 0x44e <error_eth>
		}	
			 
		
//////////////// Respond to command from USART
		
		if ( usart_rx_buf_has_data() ) 
     84a:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <usart_rx_buf_has_data>
     84e:	88 23       	and	r24, r24
     850:	09 f4       	brne	.+2      	; 0x854 <main+0x340>
     852:	bb cf       	rjmp	.-138    	; 0x7ca <main+0x2b6>
		{
			uint8_t newbyte;
			cli();
     854:	f8 94       	cli
			newbyte = usart_rx_buf_get_byte();
     856:	0e 94 0e 05 	call	0xa1c	; 0xa1c <usart_rx_buf_get_byte>
			sei();
     85a:	78 94       	sei
 
			
			switch (newbyte)
     85c:	82 35       	cpi	r24, 0x52	; 82
     85e:	e9 f0       	breq	.+58     	; 0x89a <main+0x386>
     860:	83 35       	cpi	r24, 0x53	; 83
     862:	18 f4       	brcc	.+6      	; 0x86a <main+0x356>
     864:	81 34       	cpi	r24, 0x41	; 65
     866:	29 f5       	brne	.+74     	; 0x8b2 <main+0x39e>
     868:	04 c0       	rjmp	.+8      	; 0x872 <main+0x35e>
     86a:	87 35       	cpi	r24, 0x57	; 87
     86c:	31 f0       	breq	.+12     	; 0x87a <main+0x366>
     86e:	81 36       	cpi	r24, 0x61	; 97
     870:	01 f5       	brne	.+64     	; 0x8b2 <main+0x39e>
	return(newbyte);
}

void acknowledge_usa(void)
{
	usart_send_byte('a');
     872:	81 e6       	ldi	r24, 0x61	; 97
     874:	0e 94 26 05 	call	0xa4c	; 0xa4c <usart_send_byte>
     878:	a8 cf       	rjmp	.-176    	; 0x7ca <main+0x2b6>
				case 'A':
				case 'a':
					acknowledge_usa();
					break;
				case 'W':
					PORTA.OUTSET=PIN0_bm;
     87a:	81 e0       	ldi	r24, 0x01	; 1
     87c:	f7 01       	movw	r30, r14
     87e:	85 83       	std	Z+5, r24	; 0x05
	return(newbyte);
}

void acknowledge_usa(void)
{
	usart_send_byte('a');
     880:	81 e6       	ldi	r24, 0x61	; 97
     882:	0e 94 26 05 	call	0xa4c	; 0xa4c <usart_send_byte>
     886:	80 e2       	ldi	r24, 0x20	; 32
     888:	9e e4       	ldi	r25, 0x4E	; 78
     88a:	f8 01       	movw	r30, r16
     88c:	31 97       	sbiw	r30, 0x01	; 1
     88e:	f1 f7       	brne	.-4      	; 0x88c <main+0x378>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     890:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     892:	d9 f7       	brne	.-10     	; 0x88a <main+0x376>
					break;
				case 'W':
					PORTA.OUTSET=PIN0_bm;
					acknowledge_usa();
					_delay_ms(2000);
					acknowledge_eth();
     894:	0e 94 3f 02 	call	0x47e	; 0x47e <acknowledge_eth>
     898:	98 cf       	rjmp	.-208    	; 0x7ca <main+0x2b6>
	return(newbyte);
}

void acknowledge_usa(void)
{
	usart_send_byte('a');
     89a:	81 e6       	ldi	r24, 0x61	; 97
     89c:	0e 94 26 05 	call	0xa4c	; 0xa4c <usart_send_byte>
					_delay_ms(2000);
					acknowledge_eth();
				 	break;
				case 'R':
				 	acknowledge_usa();
				 	cli();
     8a0:	f8 94       	cli
     8a2:	88 e9       	ldi	r24, 0x98	; 152
     8a4:	9a e3       	ldi	r25, 0x3A	; 58
     8a6:	f8 01       	movw	r30, r16
     8a8:	31 97       	sbiw	r30, 0x01	; 1
     8aa:	f1 f7       	brne	.-4      	; 0x8a8 <main+0x394>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     8ac:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8ae:	d9 f7       	brne	.-10     	; 0x8a6 <main+0x392>
     8b0:	8c cf       	rjmp	.-232    	; 0x7ca <main+0x2b6>
					_delay_ms(1500);	// Force reset by not resetting WDT on time
				 	break;
				default:
				error_eth();
     8b2:	0e 94 27 02 	call	0x44e	; 0x44e <error_eth>
     8b6:	89 cf       	rjmp	.-238    	; 0x7ca <main+0x2b6>

000008b8 <__vector_25>:
	 PacketInBuf = 1;
	 //PORTF.OUTSET=PIN1_bm; // test com time
}

ISR(USARTC0_RXC_vect) //Reception Complete interrupt
{
     8b8:	1f 92       	push	r1
     8ba:	0f 92       	push	r0
     8bc:	0f b6       	in	r0, 0x3f	; 63
     8be:	0f 92       	push	r0
     8c0:	08 b6       	in	r0, 0x38	; 56
     8c2:	0f 92       	push	r0
     8c4:	09 b6       	in	r0, 0x39	; 57
     8c6:	0f 92       	push	r0
     8c8:	0b b6       	in	r0, 0x3b	; 59
     8ca:	0f 92       	push	r0
     8cc:	11 24       	eor	r1, r1
     8ce:	18 be       	out	0x38, r1	; 56
     8d0:	19 be       	out	0x39, r1	; 57
     8d2:	1b be       	out	0x3b, r1	; 59
     8d4:	2f 93       	push	r18
     8d6:	3f 93       	push	r19
     8d8:	4f 93       	push	r20
     8da:	5f 93       	push	r21
     8dc:	6f 93       	push	r22
     8de:	7f 93       	push	r23
     8e0:	8f 93       	push	r24
     8e2:	9f 93       	push	r25
     8e4:	af 93       	push	r26
     8e6:	bf 93       	push	r27
     8e8:	ef 93       	push	r30
     8ea:	ff 93       	push	r31
    uint8_t Temp;
    Temp = USARTC0.DATA ; 
     8ec:	80 91 a0 08 	lds	r24, 0x08A0
    usart_rx_buf_put_byte(Temp);
     8f0:	0e 94 f8 04 	call	0x9f0	; 0x9f0 <usart_rx_buf_put_byte>
    Temp++;
}
     8f4:	ff 91       	pop	r31
     8f6:	ef 91       	pop	r30
     8f8:	bf 91       	pop	r27
     8fa:	af 91       	pop	r26
     8fc:	9f 91       	pop	r25
     8fe:	8f 91       	pop	r24
     900:	7f 91       	pop	r23
     902:	6f 91       	pop	r22
     904:	5f 91       	pop	r21
     906:	4f 91       	pop	r20
     908:	3f 91       	pop	r19
     90a:	2f 91       	pop	r18
     90c:	0f 90       	pop	r0
     90e:	0b be       	out	0x3b, r0	; 59
     910:	0f 90       	pop	r0
     912:	09 be       	out	0x39, r0	; 57
     914:	0f 90       	pop	r0
     916:	08 be       	out	0x38, r0	; 56
     918:	0f 90       	pop	r0
     91a:	0f be       	out	0x3f, r0	; 63
     91c:	0f 90       	pop	r0
     91e:	1f 90       	pop	r1
     920:	18 95       	reti

00000922 <SPID_Init>:
#include "spi_xmega.h"

void SPID_Init()
{
    /* Init SS pin as output with wired AND and pull-up. */
    PORTD.DIRSET = SPID_SS_bm;
     922:	e0 e6       	ldi	r30, 0x60	; 96
     924:	f6 e0       	ldi	r31, 0x06	; 6
     926:	90 e1       	ldi	r25, 0x10	; 16
     928:	91 83       	std	Z+1, r25	; 0x01
    PORTD.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     92a:	88 e3       	ldi	r24, 0x38	; 56
     92c:	84 8b       	std	Z+20, r24	; 0x14

    /* Set SS output to high. (No slave addressed). */
    PORTD.OUTSET = SPID_SS_bm;
     92e:	95 83       	std	Z+5, r25	; 0x05

    // SPI setup. options choosen from spi.f for atmega128
    // MSB first => DORD must be null => not set
    SPID.CTRL = SPI_PRESCALER_DIV4_gc|  SPI_ENABLE_bm | SPI_MASTER_bm | SPI_MODE_0_gc; //| SPI_CLK2X_bm ;
     930:	80 e5       	ldi	r24, 0x50	; 80
     932:	80 93 c0 09 	sts	0x09C0, r24

//    SPIREG.INTCTRL = SPI_INTLVL_LO_gc; // interrupt level

    	/* MOSI and SCK as output. */
    PORTD.DIRSET = SPID_MOSI_bm | SPID_SCK_bm; 
     936:	80 ea       	ldi	r24, 0xA0	; 160
     938:	81 83       	std	Z+1, r24	; 0x01

}
     93a:	08 95       	ret

0000093c <SPIC_Init>:


void SPIC_Init()
{
    /* Init SS pin as output with wired AND and pull-up. */
    PORTC.DIRSET = PIN4_bm;
     93c:	e0 e4       	ldi	r30, 0x40	; 64
     93e:	f6 e0       	ldi	r31, 0x06	; 6
     940:	90 e1       	ldi	r25, 0x10	; 16
     942:	91 83       	std	Z+1, r25	; 0x01
    PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     944:	88 e3       	ldi	r24, 0x38	; 56
     946:	84 8b       	std	Z+20, r24	; 0x14

    /* Set SS output to high. (No slave addressed). */
    PORTC.OUTSET = PIN4_bm;
     948:	95 83       	std	Z+5, r25	; 0x05

    // SPI setup. options choosen from spi.f for xmega128a1
    // MSB first => DORD must be null => not set
    SPIC.CTRL = SPI_PRESCALER_DIV16_gc|  SPI_ENABLE_bm | SPI_MASTER_bm | SPI_MODE_3_gc;// | SPI_CLK2X_bm ;
     94a:	8d e5       	ldi	r24, 0x5D	; 93
     94c:	80 93 c0 08 	sts	0x08C0, r24

//    SPIREG.INTCTRL = SPI_INTLVL_LO_gc; // interrupt level

    	/* MOSI and SCK as output. */
    PORTC.DIRSET = SPIC_MOSI_bm | SPIC_SCK_bm; 
     950:	80 ea       	ldi	r24, 0xA0	; 160
     952:	81 83       	std	Z+1, r24	; 0x01

}
     954:	08 95       	ret

00000956 <IINCHIP_SpiSendData>:



void IINCHIP_SpiSendData(uint8_t data)
{
    SPID.DATA = data ; //send data
     956:	e0 ec       	ldi	r30, 0xC0	; 192
     958:	f9 e0       	ldi	r31, 0x09	; 9
     95a:	83 83       	std	Z+3, r24	; 0x03
    while(!(SPID.STATUS & SPI_IF_bm)) {}; //wait for transmition complete
     95c:	80 91 c2 09 	lds	r24, 0x09C2
     960:	87 ff       	sbrs	r24, 7
     962:	fc cf       	rjmp	.-8      	; 0x95c <IINCHIP_SpiSendData+0x6>
}
     964:	08 95       	ret

00000966 <IINCHIP_SpiRecvData>:

uint8_t IINCHIP_SpiRecvData()
{
    return SPID.DATA;
     966:	e0 ec       	ldi	r30, 0xC0	; 192
     968:	f9 e0       	ldi	r31, 0x09	; 9
     96a:	83 81       	ldd	r24, Z+3	; 0x03
}
     96c:	08 95       	ret

0000096e <usart_init>:
static volatile uint8_t usart_rx_buf_tail = 0;
static volatile uint8_t usart_rx_buf[usart_rx_buf_size];

//	ex : usart_init(&PORTC, &USARTC0, 9600);
void usart_init(PORT_t *port, USART_t *usart, uint32_t baudrate)
{
     96e:	ef 92       	push	r14
     970:	ff 92       	push	r15
     972:	0f 93       	push	r16
     974:	1f 93       	push	r17
     976:	7c 01       	movw	r14, r24
     978:	8b 01       	movw	r16, r22
    //calculate UBRR value. It is 8UL if using double speed transfer
    //((F_CPU/(BSCALE**2 * BAUDRATE * 16UL))-1) 
    //uint32_t bselvalue = ( (F_CPU / (baudrate * 16)) - 1 );
    // this is supposed to be a better calculation of bselvalue 
    uint16_t bselvalue = ((F_CPU / 16 + baudrate / 2) / baudrate - 1);
     97a:	ca 01       	movw	r24, r20
     97c:	b9 01       	movw	r22, r18
     97e:	96 95       	lsr	r25
     980:	87 95       	ror	r24
     982:	77 95       	ror	r23
     984:	67 95       	ror	r22
     986:	60 58       	subi	r22, 0x80	; 128
     988:	7b 47       	sbci	r23, 0x7B	; 123
     98a:	81 4e       	sbci	r24, 0xE1	; 225
     98c:	9f 4f       	sbci	r25, 0xFF	; 255
     98e:	0e 94 43 10 	call	0x2086	; 0x2086 <__udivmodsi4>
     992:	21 50       	subi	r18, 0x01	; 1
     994:	30 40       	sbci	r19, 0x00	; 0

    //XCLK is 0 for C0 and 5 for C1
	// RXD0 as input. this is PC2 for C0 and PC6 for USARTC1	 
	port->DIRCLR   = PIN2_bm;
     996:	84 e0       	ldi	r24, 0x04	; 4
     998:	f7 01       	movw	r30, r14
     99a:	82 83       	std	Z+2, r24	; 0x02
  	// TXD0 as output. this is PC3 for C0 and PC7 for USARTC1
	port->DIRSET   = PIN3_bm;
     99c:	88 e0       	ldi	r24, 0x08	; 8
     99e:	81 83       	std	Z+1, r24	; 0x01
	
	usart->CTRLC = USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABLED_gc | USART_CHSIZE_8BIT_gc ; //Asynchronous, No parity , 8BIT, 
     9a0:	83 e0       	ldi	r24, 0x03	; 3
     9a2:	f8 01       	movw	r30, r16
     9a4:	85 83       	std	Z+5, r24	; 0x05
    //USARTC0.CTRLA =  USART_DREINTLVL_LO_gc ; //done in exampl e, not sure why
    usart->CTRLA |= USART_RXCINTLVL_LO_gc; //Enable interrup on receive
     9a6:	83 81       	ldd	r24, Z+3	; 0x03
     9a8:	80 61       	ori	r24, 0x10	; 16
     9aa:	83 83       	std	Z+3, r24	; 0x03

    usart->BAUDCTRLA = (uint8_t)bselvalue; //set baudrate
     9ac:	26 83       	std	Z+6, r18	; 0x06
    usart->BAUDCTRLB = (0 << USART_BSCALE0_bp)|(bselvalue >> 8); // set scale factor
     9ae:	37 83       	std	Z+7, r19	; 0x07
    usart->CTRLB &= ~USART_CLK2X_bm; // disable usart 2x 
     9b0:	84 81       	ldd	r24, Z+4	; 0x04
     9b2:	8b 7f       	andi	r24, 0xFB	; 251
     9b4:	84 83       	std	Z+4, r24	; 0x04
    //usart->CTRLB |= USART_CLK2X_bm;
	usart->CTRLB |= USART_RXEN_bm ; // enable USART receiver
     9b6:	84 81       	ldd	r24, Z+4	; 0x04
     9b8:	80 61       	ori	r24, 0x10	; 16
     9ba:	84 83       	std	Z+4, r24	; 0x04
    usart->CTRLB |= USART_TXEN_bm ; // enable USART transmit
     9bc:	84 81       	ldd	r24, Z+4	; 0x04
     9be:	88 60       	ori	r24, 0x08	; 8
     9c0:	84 83       	std	Z+4, r24	; 0x04
}
     9c2:	1f 91       	pop	r17
     9c4:	0f 91       	pop	r16
     9c6:	ff 90       	pop	r15
     9c8:	ef 90       	pop	r14
     9ca:	08 95       	ret

000009cc <usart_rx_buf_flush>:

void usart_rx_buf_flush(void)
{
    usart_rx_buf_head = usart_rx_buf_tail;
     9cc:	80 91 c7 20 	lds	r24, 0x20C7
     9d0:	80 93 c6 20 	sts	0x20C6, r24
}
     9d4:	08 95       	ret

000009d6 <usart_rx_buf_has_data>:

uint8_t usart_rx_buf_has_data(void)
{
    return  (usart_rx_buf_size + usart_rx_buf_head - usart_rx_buf_tail ) % usart_rx_buf_size;
     9d6:	80 91 c6 20 	lds	r24, 0x20C6
     9da:	20 91 c7 20 	lds	r18, 0x20C7
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	80 96       	adiw	r24, 0x20	; 32
     9e2:	82 1b       	sub	r24, r18
     9e4:	91 09       	sbc	r25, r1
     9e6:	60 e2       	ldi	r22, 0x20	; 32
     9e8:	70 e0       	ldi	r23, 0x00	; 0
     9ea:	0e 94 30 10 	call	0x2060	; 0x2060 <__divmodhi4>
}
     9ee:	08 95       	ret

000009f0 <usart_rx_buf_put_byte>:

void usart_rx_buf_put_byte(uint8_t data)
{
     9f0:	98 2f       	mov	r25, r24
	uint8_t idx = (usart_rx_buf_head + 1) % usart_rx_buf_size;
     9f2:	80 91 c6 20 	lds	r24, 0x20C6
     9f6:	28 2f       	mov	r18, r24
     9f8:	30 e0       	ldi	r19, 0x00	; 0
     9fa:	2f 5f       	subi	r18, 0xFF	; 255
     9fc:	3f 4f       	sbci	r19, 0xFF	; 255
     9fe:	2f 71       	andi	r18, 0x1F	; 31
     a00:	30 70       	andi	r19, 0x00	; 0
	if (idx != usart_rx_buf_tail) { // do not explode buffer
     a02:	80 91 c7 20 	lds	r24, 0x20C7
     a06:	82 17       	cp	r24, r18
     a08:	41 f0       	breq	.+16     	; 0xa1a <usart_rx_buf_put_byte+0x2a>
		usart_rx_buf[usart_rx_buf_head] = data;
     a0a:	e0 91 c6 20 	lds	r30, 0x20C6
     a0e:	f0 e0       	ldi	r31, 0x00	; 0
     a10:	e8 53       	subi	r30, 0x38	; 56
     a12:	ff 4d       	sbci	r31, 0xDF	; 223
     a14:	90 83       	st	Z, r25
		usart_rx_buf_head = idx;
     a16:	20 93 c6 20 	sts	0x20C6, r18
     a1a:	08 95       	ret

00000a1c <usart_rx_buf_get_byte>:
	}
}

uint8_t usart_rx_buf_get_byte(void)
{
	if (usart_rx_buf_head == usart_rx_buf_tail) {
     a1c:	90 91 c6 20 	lds	r25, 0x20C6
     a20:	80 91 c7 20 	lds	r24, 0x20C7
     a24:	98 17       	cp	r25, r24
     a26:	11 f4       	brne	.+4      	; 0xa2c <usart_rx_buf_get_byte+0x10>
     a28:	ef ef       	ldi	r30, 0xFF	; 255
     a2a:	0e c0       	rjmp	.+28     	; 0xa48 <usart_rx_buf_get_byte+0x2c>
		return -1;
	} else {
		uint8_t data = usart_rx_buf[usart_rx_buf_tail];
     a2c:	e0 91 c7 20 	lds	r30, 0x20C7
     a30:	f0 e0       	ldi	r31, 0x00	; 0
     a32:	e8 53       	subi	r30, 0x38	; 56
     a34:	ff 4d       	sbci	r31, 0xDF	; 223
     a36:	e0 81       	ld	r30, Z
		usart_rx_buf_tail = (usart_rx_buf_tail + 1) % usart_rx_buf_size;
     a38:	80 91 c7 20 	lds	r24, 0x20C7
     a3c:	90 e0       	ldi	r25, 0x00	; 0
     a3e:	01 96       	adiw	r24, 0x01	; 1
     a40:	8f 71       	andi	r24, 0x1F	; 31
     a42:	90 70       	andi	r25, 0x00	; 0
     a44:	80 93 c7 20 	sts	0x20C7, r24
		return data;
	}
}
     a48:	8e 2f       	mov	r24, r30
     a4a:	08 95       	ret

00000a4c <usart_send_byte>:


void usart_send_byte(uint8_t byte)
{
     a4c:	98 2f       	mov	r25, r24
    while ((USARTC0.STATUS & USART_DREIF_bm) == 0) ;
     a4e:	80 91 a1 08 	lds	r24, 0x08A1
     a52:	85 ff       	sbrs	r24, 5
     a54:	fc cf       	rjmp	.-8      	; 0xa4e <usart_send_byte+0x2>
    USARTC0.DATA = byte ; 
     a56:	90 93 a0 08 	sts	0x08A0, r25
}
     a5a:	08 95       	ret

00000a5c <getIINCHIP_RxMAX>:
	} while (val != val1);
   return val;
}

uint16_t getIINCHIP_RxMAX(uint8_t s)
{
     a5c:	e8 2f       	mov	r30, r24
     a5e:	f0 e0       	ldi	r31, 0x00	; 0
     a60:	ee 0f       	add	r30, r30
     a62:	ff 1f       	adc	r31, r31
     a64:	ee 5f       	subi	r30, 0xFE	; 254
     a66:	fe 4d       	sbci	r31, 0xDE	; 222
   return RSIZE[s];
}
     a68:	80 81       	ld	r24, Z
     a6a:	91 81       	ldd	r25, Z+1	; 0x01
     a6c:	08 95       	ret

00000a6e <getIINCHIP_TxMAX>:
uint16_t getIINCHIP_TxMAX(uint8_t s)
{
     a6e:	e8 2f       	mov	r30, r24
     a70:	f0 e0       	ldi	r31, 0x00	; 0
     a72:	ee 0f       	add	r30, r30
     a74:	ff 1f       	adc	r31, r31
     a76:	e6 50       	subi	r30, 0x06	; 6
     a78:	ff 4d       	sbci	r31, 0xDF	; 223
   return SSIZE[s];
}
     a7a:	80 81       	ld	r24, Z
     a7c:	91 81       	ldd	r25, Z+1	; 0x01
     a7e:	08 95       	ret

00000a80 <getIINCHIP_RxBASE>:
uint16_t getIINCHIP_RxBASE(uint8_t s)
{
     a80:	e8 2f       	mov	r30, r24
     a82:	f0 e0       	ldi	r31, 0x00	; 0
     a84:	ee 0f       	add	r30, r30
     a86:	ff 1f       	adc	r31, r31
     a88:	ee 5e       	subi	r30, 0xEE	; 238
     a8a:	fe 4d       	sbci	r31, 0xDE	; 222
   return RBUFBASEADDRESS[s];
}
     a8c:	80 81       	ld	r24, Z
     a8e:	91 81       	ldd	r25, Z+1	; 0x01
     a90:	08 95       	ret

00000a92 <getIINCHIP_TxBASE>:
uint16_t getIINCHIP_TxBASE(uint8_t s)
{
     a92:	e8 2f       	mov	r30, r24
     a94:	f0 e0       	ldi	r31, 0x00	; 0
     a96:	ee 0f       	add	r30, r30
     a98:	ff 1f       	adc	r31, r31
     a9a:	e6 5f       	subi	r30, 0xF6	; 246
     a9c:	fe 4d       	sbci	r31, 0xDE	; 222
   return SBUFBASEADDRESS[s];
}
     a9e:	80 81       	ld	r24, Z
     aa0:	91 81       	ldd	r25, Z+1	; 0x01
     aa2:	08 95       	ret

00000aa4 <getIINCHIP_RxMASK>:
void setMR(uint8_t val)
{
	IINCHIP_WRITE(MR,val);
}
uint16_t getIINCHIP_RxMASK(uint8_t s)
{
     aa4:	e8 2f       	mov	r30, r24
     aa6:	f0 e0       	ldi	r31, 0x00	; 0
     aa8:	ee 0f       	add	r30, r30
     aaa:	ff 1f       	adc	r31, r31
     aac:	ee 50       	subi	r30, 0x0E	; 14
     aae:	ff 4d       	sbci	r31, 0xDF	; 223
   return RMASK[s];
}
     ab0:	80 81       	ld	r24, Z
     ab2:	91 81       	ldd	r25, Z+1	; 0x01
     ab4:	08 95       	ret

00000ab6 <getIINCHIP_TxMASK>:
uint16_t getIINCHIP_TxMASK(uint8_t s)
{
     ab6:	e8 2f       	mov	r30, r24
     ab8:	f0 e0       	ldi	r31, 0x00	; 0
     aba:	ee 0f       	add	r30, r30
     abc:	ff 1f       	adc	r31, r31
     abe:	e6 51       	subi	r30, 0x16	; 22
     ac0:	ff 4d       	sbci	r31, 0xDF	; 223
   return SMASK[s];
}
     ac2:	80 81       	ld	r24, Z
     ac4:	91 81       	ldd	r25, Z+1	; 0x01
     ac6:	08 95       	ret

00000ac8 <wiz_write_buf>:

/**
@brief	This function writes into W5100 memory(Buffer)
*/ 
uint16_t wiz_write_buf(uint16_t addr,uint8_t* buf,uint16_t len)
{
     ac8:	9f 92       	push	r9
     aca:	af 92       	push	r10
     acc:	bf 92       	push	r11
     ace:	cf 92       	push	r12
     ad0:	df 92       	push	r13
     ad2:	ef 92       	push	r14
     ad4:	ff 92       	push	r15
     ad6:	0f 93       	push	r16
     ad8:	1f 93       	push	r17
     ada:	cf 93       	push	r28
     adc:	df 93       	push	r29
     ade:	8c 01       	movw	r16, r24
     ae0:	6b 01       	movw	r12, r22
     ae2:	7a 01       	movw	r14, r20
     ae4:	c0 e0       	ldi	r28, 0x00	; 0
     ae6:	d0 e0       	ldi	r29, 0x00	; 0
	uint16_t idx = 0;
      
	for(idx=0;idx<len;idx++)
	   {
		IINCHIP_CSoff();                             // CS=0, SPI start 
     ae8:	70 e6       	ldi	r23, 0x60	; 96
     aea:	a7 2e       	mov	r10, r23
     aec:	76 e0       	ldi	r23, 0x06	; 6
     aee:	b7 2e       	mov	r11, r23
     af0:	60 e1       	ldi	r22, 0x10	; 16
     af2:	96 2e       	mov	r9, r22
     af4:	16 c0       	rjmp	.+44     	; 0xb22 <wiz_write_buf+0x5a>
     af6:	f5 01       	movw	r30, r10
     af8:	96 82       	std	Z+6, r9	; 0x06

		IINCHIP_SpiSendData(0xF0);
     afa:	80 ef       	ldi	r24, 0xF0	; 240
     afc:	0e 94 ab 04 	call	0x956	; 0x956 <IINCHIP_SpiSendData>
		IINCHIP_SpiSendData(((addr+idx) & 0xFF00) >> 8);
     b00:	81 2f       	mov	r24, r17
     b02:	0e 94 ab 04 	call	0x956	; 0x956 <IINCHIP_SpiSendData>
		IINCHIP_SpiSendData((addr+idx) & 0x00FF);
     b06:	80 2f       	mov	r24, r16
     b08:	0e 94 ab 04 	call	0x956	; 0x956 <IINCHIP_SpiSendData>
		IINCHIP_SpiSendData(buf[idx]);
     b0c:	f6 01       	movw	r30, r12
     b0e:	ec 0f       	add	r30, r28
     b10:	fd 1f       	adc	r31, r29
     b12:	80 81       	ld	r24, Z
     b14:	0e 94 ab 04 	call	0x956	; 0x956 <IINCHIP_SpiSendData>

		IINCHIP_CSon();                             // CS=0, SPI end 
     b18:	f5 01       	movw	r30, r10
     b1a:	95 82       	std	Z+5, r9	; 0x05
*/ 
uint16_t wiz_write_buf(uint16_t addr,uint8_t* buf,uint16_t len)
{
	uint16_t idx = 0;
      
	for(idx=0;idx<len;idx++)
     b1c:	21 96       	adiw	r28, 0x01	; 1
     b1e:	0f 5f       	subi	r16, 0xFF	; 255
     b20:	1f 4f       	sbci	r17, 0xFF	; 255
     b22:	ce 15       	cp	r28, r14
     b24:	df 05       	cpc	r29, r15
     b26:	38 f3       	brcs	.-50     	; 0xaf6 <wiz_write_buf+0x2e>
		IINCHIP_CSon();                             // CS=0, SPI end 
	   }


	return len;
}
     b28:	c7 01       	movw	r24, r14
     b2a:	df 91       	pop	r29
     b2c:	cf 91       	pop	r28
     b2e:	1f 91       	pop	r17
     b30:	0f 91       	pop	r16
     b32:	ff 90       	pop	r15
     b34:	ef 90       	pop	r14
     b36:	df 90       	pop	r13
     b38:	cf 90       	pop	r12
     b3a:	bf 90       	pop	r11
     b3c:	af 90       	pop	r10
     b3e:	9f 90       	pop	r9
     b40:	08 95       	ret

00000b42 <write_data>:
buffer of the chip. It calculate the actual physical address where one has to write
the data in transmite buffer. Here also take care of the condition while it exceed
the Tx memory uper-bound of socket.
*/
void write_data(SOCKET s, volatile uint8_t * src, volatile uint8_t * dst, uint16_t len)
{
     b42:	cf 92       	push	r12
     b44:	df 92       	push	r13
     b46:	ef 92       	push	r14
     b48:	ff 92       	push	r15
     b4a:	0f 93       	push	r16
     b4c:	1f 93       	push	r17
     b4e:	cf 93       	push	r28
     b50:	df 93       	push	r29
     b52:	7b 01       	movw	r14, r22
     b54:	e9 01       	movw	r28, r18
{
   return RMASK[s];
}
uint16_t getIINCHIP_TxMASK(uint8_t s)
{
   return SMASK[s];
     b56:	e8 2f       	mov	r30, r24
     b58:	f0 e0       	ldi	r31, 0x00	; 0
{
	uint16_t size;
	uint16_t dst_mask;
	uint8_t * dst_ptr;

	dst_mask = (uint16_t)dst & getIINCHIP_TxMASK(s);
     b5a:	ee 0f       	add	r30, r30
     b5c:	ff 1f       	adc	r31, r31
     b5e:	df 01       	movw	r26, r30
     b60:	a6 51       	subi	r26, 0x16	; 22
     b62:	bf 4d       	sbci	r27, 0xDF	; 223
     b64:	8d 91       	ld	r24, X+
     b66:	9c 91       	ld	r25, X
     b68:	48 23       	and	r20, r24
     b6a:	59 23       	and	r21, r25
	dst_ptr = (uint8_t *)(getIINCHIP_TxBASE(s) + dst_mask);
     b6c:	aa e0       	ldi	r26, 0x0A	; 10
     b6e:	ca 2e       	mov	r12, r26
     b70:	a1 e2       	ldi	r26, 0x21	; 33
     b72:	da 2e       	mov	r13, r26
     b74:	ce 0e       	add	r12, r30
     b76:	df 1e       	adc	r13, r31
     b78:	d6 01       	movw	r26, r12
     b7a:	2d 91       	ld	r18, X+
     b7c:	3c 91       	ld	r19, X
     b7e:	24 0f       	add	r18, r20
     b80:	35 1f       	adc	r19, r21
{
   return RSIZE[s];
}
uint16_t getIINCHIP_TxMAX(uint8_t s)
{
   return SSIZE[s];
     b82:	e6 50       	subi	r30, 0x06	; 6
     b84:	ff 4d       	sbci	r31, 0xDF	; 223
     b86:	01 90       	ld	r0, Z+
     b88:	f0 81       	ld	r31, Z
     b8a:	e0 2d       	mov	r30, r0
	uint8_t * dst_ptr;

	dst_mask = (uint16_t)dst & getIINCHIP_TxMASK(s);
	dst_ptr = (uint8_t *)(getIINCHIP_TxBASE(s) + dst_mask);
	
	if (dst_mask + len > getIINCHIP_TxMAX(s)) 
     b8c:	ca 01       	movw	r24, r20
     b8e:	8c 0f       	add	r24, r28
     b90:	9d 1f       	adc	r25, r29
     b92:	e8 17       	cp	r30, r24
     b94:	f9 07       	cpc	r31, r25
     b96:	80 f4       	brcc	.+32     	; 0xbb8 <write_data+0x76>
	{
		size = getIINCHIP_TxMAX(s) - dst_mask;
     b98:	8f 01       	movw	r16, r30
     b9a:	04 1b       	sub	r16, r20
     b9c:	15 0b       	sbc	r17, r21
		wiz_write_buf((uint16_t)dst_ptr, (uint8_t*)src, size);
     b9e:	c9 01       	movw	r24, r18
     ba0:	a8 01       	movw	r20, r16
     ba2:	0e 94 64 05 	call	0xac8	; 0xac8 <wiz_write_buf>
		src += size;
		size = len - size;
		dst_ptr = (uint8_t *)(getIINCHIP_TxBASE(s));
		wiz_write_buf((uint16_t)dst_ptr, (uint8_t*)src, size);
     ba6:	c0 1b       	sub	r28, r16
     ba8:	d1 0b       	sbc	r29, r17
     baa:	f6 01       	movw	r30, r12
     bac:	80 81       	ld	r24, Z
     bae:	91 81       	ldd	r25, Z+1	; 0x01
     bb0:	0e 0d       	add	r16, r14
     bb2:	1f 1d       	adc	r17, r15
     bb4:	b8 01       	movw	r22, r16
     bb6:	01 c0       	rjmp	.+2      	; 0xbba <write_data+0x78>
	} 
	else
	{
		wiz_write_buf((uint16_t)dst_ptr, (uint8_t*)src, len);
     bb8:	c9 01       	movw	r24, r18
     bba:	ae 01       	movw	r20, r28
     bbc:	0e 94 64 05 	call	0xac8	; 0xac8 <wiz_write_buf>
	}
}
     bc0:	df 91       	pop	r29
     bc2:	cf 91       	pop	r28
     bc4:	1f 91       	pop	r17
     bc6:	0f 91       	pop	r16
     bc8:	ff 90       	pop	r15
     bca:	ef 90       	pop	r14
     bcc:	df 90       	pop	r13
     bce:	cf 90       	pop	r12
     bd0:	08 95       	ret

00000bd2 <IINCHIP_WRITE>:

 /**
@brief	This function writes the data into W5100 registers.
*/
uint8_t IINCHIP_WRITE(uint16_t addr,uint8_t data)
{
     bd2:	cf 92       	push	r12
     bd4:	df 92       	push	r13
     bd6:	ef 92       	push	r14
     bd8:	ff 92       	push	r15
     bda:	0f 93       	push	r16
     bdc:	1f 93       	push	r17
     bde:	d8 2e       	mov	r13, r24
     be0:	e9 2e       	mov	r14, r25
     be2:	c6 2e       	mov	r12, r22
	IINCHIP_CSoff();                             // CS=0, SPI start
     be4:	00 e6       	ldi	r16, 0x60	; 96
     be6:	16 e0       	ldi	r17, 0x06	; 6
     be8:	80 e1       	ldi	r24, 0x10	; 16
     bea:	f8 2e       	mov	r15, r24
     bec:	f8 01       	movw	r30, r16
     bee:	f6 82       	std	Z+6, r15	; 0x06

	IINCHIP_SpiSendData(0xF0);
     bf0:	80 ef       	ldi	r24, 0xF0	; 240
     bf2:	0e 94 ab 04 	call	0x956	; 0x956 <IINCHIP_SpiSendData>
	IINCHIP_SpiSendData((addr & 0xFF00) >> 8);
     bf6:	8e 2d       	mov	r24, r14
     bf8:	0e 94 ab 04 	call	0x956	; 0x956 <IINCHIP_SpiSendData>
	IINCHIP_SpiSendData(addr & 0x00FF);
     bfc:	8d 2d       	mov	r24, r13
     bfe:	0e 94 ab 04 	call	0x956	; 0x956 <IINCHIP_SpiSendData>
	IINCHIP_SpiSendData(data);
     c02:	8c 2d       	mov	r24, r12
     c04:	0e 94 ab 04 	call	0x956	; 0x956 <IINCHIP_SpiSendData>

	IINCHIP_CSon();    
     c08:	f8 01       	movw	r30, r16
     c0a:	f5 82       	std	Z+5, r15	; 0x05

	return 1;
}
     c0c:	81 e0       	ldi	r24, 0x01	; 1
     c0e:	1f 91       	pop	r17
     c10:	0f 91       	pop	r16
     c12:	ff 90       	pop	r15
     c14:	ef 90       	pop	r14
     c16:	df 90       	pop	r13
     c18:	cf 90       	pop	r12
     c1a:	08 95       	ret

00000c1c <setMR>:
	} while (val != val1);
   return val;
}

void setMR(uint8_t val)
{
     c1c:	68 2f       	mov	r22, r24
	IINCHIP_WRITE(MR,val);
     c1e:	80 e0       	ldi	r24, 0x00	; 0
     c20:	90 e8       	ldi	r25, 0x80	; 128
     c22:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
}
     c26:	08 95       	ret

00000c28 <iinchip_init>:
/**
@brief	This function is for resetting of the iinchip. Initializes the iinchip to work in whether DIRECT or INDIRECT mode
*/ 
void iinchip_init(void)
{	
	setMR( MR_RST );
     c28:	80 e8       	ldi	r24, 0x80	; 128
     c2a:	0e 94 0e 06 	call	0xc1c	; 0xc1c <setMR>
}
     c2e:	08 95       	ret

00000c30 <setIPAddress>:
@brief	This function sets up Source IP address.
*/
void setIPAddress(
	uint8_t * addr	/**< a pointer to a 4 -byte array responsible to set the Source IP address. */
	)
{
     c30:	0f 93       	push	r16
     c32:	1f 93       	push	r17
     c34:	8c 01       	movw	r16, r24
	IINCHIP_WRITE((SIPR0 + 0),addr[0]);
     c36:	8f e0       	ldi	r24, 0x0F	; 15
     c38:	90 e0       	ldi	r25, 0x00	; 0
     c3a:	f8 01       	movw	r30, r16
     c3c:	60 81       	ld	r22, Z
     c3e:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE((SIPR0 + 1),addr[1]);
     c42:	80 e1       	ldi	r24, 0x10	; 16
     c44:	90 e0       	ldi	r25, 0x00	; 0
     c46:	f8 01       	movw	r30, r16
     c48:	61 81       	ldd	r22, Z+1	; 0x01
     c4a:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE((SIPR0 + 2),addr[2]);
     c4e:	81 e1       	ldi	r24, 0x11	; 17
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	f8 01       	movw	r30, r16
     c54:	62 81       	ldd	r22, Z+2	; 0x02
     c56:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE((SIPR0 + 3),addr[3]);
     c5a:	82 e1       	ldi	r24, 0x12	; 18
     c5c:	90 e0       	ldi	r25, 0x00	; 0
     c5e:	f8 01       	movw	r30, r16
     c60:	63 81       	ldd	r22, Z+3	; 0x03
     c62:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
}
     c66:	1f 91       	pop	r17
     c68:	0f 91       	pop	r16
     c6a:	08 95       	ret

00000c6c <setMacAddress>:
@brief	This function sets up MAC address.
*/ 
void setMacAddress(
	uint8_t * addr	/**< a pointer to a 6 -byte array responsible to set the MAC address. */
	)
{
     c6c:	0f 93       	push	r16
     c6e:	1f 93       	push	r17
     c70:	8c 01       	movw	r16, r24
	IINCHIP_WRITE((SHAR0 + 0),addr[0]);
     c72:	89 e0       	ldi	r24, 0x09	; 9
     c74:	90 e0       	ldi	r25, 0x00	; 0
     c76:	f8 01       	movw	r30, r16
     c78:	60 81       	ld	r22, Z
     c7a:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE((SHAR0 + 1),addr[1]);
     c7e:	8a e0       	ldi	r24, 0x0A	; 10
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	f8 01       	movw	r30, r16
     c84:	61 81       	ldd	r22, Z+1	; 0x01
     c86:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE((SHAR0 + 2),addr[2]);
     c8a:	8b e0       	ldi	r24, 0x0B	; 11
     c8c:	90 e0       	ldi	r25, 0x00	; 0
     c8e:	f8 01       	movw	r30, r16
     c90:	62 81       	ldd	r22, Z+2	; 0x02
     c92:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE((SHAR0 + 3),addr[3]);
     c96:	8c e0       	ldi	r24, 0x0C	; 12
     c98:	90 e0       	ldi	r25, 0x00	; 0
     c9a:	f8 01       	movw	r30, r16
     c9c:	63 81       	ldd	r22, Z+3	; 0x03
     c9e:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE((SHAR0 + 4),addr[4]);
     ca2:	8d e0       	ldi	r24, 0x0D	; 13
     ca4:	90 e0       	ldi	r25, 0x00	; 0
     ca6:	f8 01       	movw	r30, r16
     ca8:	64 81       	ldd	r22, Z+4	; 0x04
     caa:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE((SHAR0 + 5),addr[5]);
     cae:	8e e0       	ldi	r24, 0x0E	; 14
     cb0:	90 e0       	ldi	r25, 0x00	; 0
     cb2:	f8 01       	movw	r30, r16
     cb4:	65 81       	ldd	r22, Z+5	; 0x05
     cb6:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
}
     cba:	1f 91       	pop	r17
     cbc:	0f 91       	pop	r16
     cbe:	08 95       	ret

00000cc0 <setSubnetMask>:
@brief	It sets up SubnetMask address
*/ 
void setSubnetMask(
	uint8_t * addr	/**< a pointer to a 4 -byte array responsible to set the SubnetMask address */
	)
{
     cc0:	0f 93       	push	r16
     cc2:	1f 93       	push	r17
     cc4:	8c 01       	movw	r16, r24
	IINCHIP_WRITE((SUBR0 + 0),addr[0]);
     cc6:	85 e0       	ldi	r24, 0x05	; 5
     cc8:	90 e0       	ldi	r25, 0x00	; 0
     cca:	f8 01       	movw	r30, r16
     ccc:	60 81       	ld	r22, Z
     cce:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE((SUBR0 + 1),addr[1]);
     cd2:	86 e0       	ldi	r24, 0x06	; 6
     cd4:	90 e0       	ldi	r25, 0x00	; 0
     cd6:	f8 01       	movw	r30, r16
     cd8:	61 81       	ldd	r22, Z+1	; 0x01
     cda:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE((SUBR0 + 2),addr[2]);
     cde:	87 e0       	ldi	r24, 0x07	; 7
     ce0:	90 e0       	ldi	r25, 0x00	; 0
     ce2:	f8 01       	movw	r30, r16
     ce4:	62 81       	ldd	r22, Z+2	; 0x02
     ce6:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE((SUBR0 + 3),addr[3]);
     cea:	88 e0       	ldi	r24, 0x08	; 8
     cec:	90 e0       	ldi	r25, 0x00	; 0
     cee:	f8 01       	movw	r30, r16
     cf0:	63 81       	ldd	r22, Z+3	; 0x03
     cf2:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
}
     cf6:	1f 91       	pop	r17
     cf8:	0f 91       	pop	r16
     cfa:	08 95       	ret

00000cfc <setGatewayAddress>:
@brief	This function sets up gateway IP address.
*/ 
void setGatewayAddress(
	uint8_t * addr	/**< a pointer to a 4 -byte array responsible to set the Gateway IP address. */
	)
{
     cfc:	0f 93       	push	r16
     cfe:	1f 93       	push	r17
     d00:	8c 01       	movw	r16, r24
	IINCHIP_WRITE((GAR0 + 0),addr[0]);
     d02:	81 e0       	ldi	r24, 0x01	; 1
     d04:	90 e0       	ldi	r25, 0x00	; 0
     d06:	f8 01       	movw	r30, r16
     d08:	60 81       	ld	r22, Z
     d0a:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE((GAR0 + 1),addr[1]);
     d0e:	82 e0       	ldi	r24, 0x02	; 2
     d10:	90 e0       	ldi	r25, 0x00	; 0
     d12:	f8 01       	movw	r30, r16
     d14:	61 81       	ldd	r22, Z+1	; 0x01
     d16:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE((GAR0 + 2),addr[2]);
     d1a:	83 e0       	ldi	r24, 0x03	; 3
     d1c:	90 e0       	ldi	r25, 0x00	; 0
     d1e:	f8 01       	movw	r30, r16
     d20:	62 81       	ldd	r22, Z+2	; 0x02
     d22:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE((GAR0 + 3),addr[3]);
     d26:	84 e0       	ldi	r24, 0x04	; 4
     d28:	90 e0       	ldi	r25, 0x00	; 0
     d2a:	f8 01       	movw	r30, r16
     d2c:	63 81       	ldd	r22, Z+3	; 0x03
     d2e:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
}
     d32:	1f 91       	pop	r17
     d34:	0f 91       	pop	r16
     d36:	08 95       	ret

00000d38 <sysinit>:
*/ 
void sysinit(
	uint8_t tx_size, 	/**< tx_size Tx memory size (00 - 1KByte, 01- 2KBtye, 10 - 4KByte, 11 - 8KByte) */
	uint8_t rx_size		/**< rx_size Rx memory size (00 - 1KByte, 01- 2KBtye, 10 - 4KByte, 11 - 8KByte) */
	)
{
     d38:	2f 92       	push	r2
     d3a:	3f 92       	push	r3
     d3c:	4f 92       	push	r4
     d3e:	5f 92       	push	r5
     d40:	6f 92       	push	r6
     d42:	7f 92       	push	r7
     d44:	8f 92       	push	r8
     d46:	9f 92       	push	r9
     d48:	af 92       	push	r10
     d4a:	bf 92       	push	r11
     d4c:	cf 92       	push	r12
     d4e:	df 92       	push	r13
     d50:	ef 92       	push	r14
     d52:	ff 92       	push	r15
     d54:	0f 93       	push	r16
     d56:	1f 93       	push	r17
     d58:	df 93       	push	r29
     d5a:	cf 93       	push	r28
     d5c:	00 d0       	rcall	.+0      	; 0xd5e <sysinit+0x26>
     d5e:	0f 92       	push	r0
     d60:	cd b7       	in	r28, 0x3d	; 61
     d62:	de b7       	in	r29, 0x3e	; 62
     d64:	18 2f       	mov	r17, r24
     d66:	06 2f       	mov	r16, r22


	ssum = 0;
	rsum = 0;
	
	IINCHIP_WRITE(TMSR,tx_size); /* Set Tx memory size for each channel */
     d68:	8b e1       	ldi	r24, 0x1B	; 27
     d6a:	90 e0       	ldi	r25, 0x00	; 0
     d6c:	61 2f       	mov	r22, r17
     d6e:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE(RMSR,rx_size);	 /* Set Rx memory size for each channel */
     d72:	8a e1       	ldi	r24, 0x1A	; 26
     d74:	90 e0       	ldi	r25, 0x00	; 0
     d76:	60 2f       	mov	r22, r16
     d78:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>

	SBUFBASEADDRESS[0] = (uint16_t)(__DEF_IINCHIP_MAP_TXBUF__);		/* Set base address of Tx memory for channel #0 */
     d7c:	80 e0       	ldi	r24, 0x00	; 0
     d7e:	90 e4       	ldi	r25, 0x40	; 64
     d80:	80 93 0a 21 	sts	0x210A, r24
     d84:	90 93 0b 21 	sts	0x210B, r25
	RBUFBASEADDRESS[0] = (uint16_t)(__DEF_IINCHIP_MAP_RXBUF__);		/* Set base address of Rx memory for channel #0 */
     d88:	80 e0       	ldi	r24, 0x00	; 0
     d8a:	90 e6       	ldi	r25, 0x60	; 96
     d8c:	80 93 12 21 	sts	0x2112, r24
     d90:	90 93 13 21 	sts	0x2113, r25
     d94:	6a ef       	ldi	r22, 0xFA	; 250
     d96:	70 e2       	ldi	r23, 0x20	; 32
     d98:	82 e0       	ldi	r24, 0x02	; 2
     d9a:	91 e2       	ldi	r25, 0x21	; 33
     d9c:	8b 83       	std	Y+3, r24	; 0x03
     d9e:	9c 83       	std	Y+4, r25	; 0x04
     da0:	22 ef       	ldi	r18, 0xF2	; 242
     da2:	c2 2e       	mov	r12, r18
     da4:	20 e2       	ldi	r18, 0x20	; 32
     da6:	d2 2e       	mov	r13, r18
     da8:	9a ee       	ldi	r25, 0xEA	; 234
     daa:	e9 2e       	mov	r14, r25
     dac:	90 e2       	ldi	r25, 0x20	; 32
     dae:	f9 2e       	mov	r15, r25
     db0:	aa 24       	eor	r10, r10
     db2:	bb 24       	eor	r11, r11
     db4:	66 24       	eor	r6, r6
     db6:	77 24       	eor	r7, r7
     db8:	88 24       	eor	r8, r8
     dba:	99 24       	eor	r9, r9
     dbc:	40 e0       	ldi	r20, 0x00	; 0
     dbe:	50 e0       	ldi	r21, 0x00	; 0
	{
		SSIZE[i] = (int16_t)(0);
		RSIZE[i] = (int16_t)(0);
		if (ssum < 8192)
		{
         switch((tx_size >> i*2) & 0x03)  // Set Tx memory size
     dc0:	e1 2f       	mov	r30, r17
     dc2:	f0 e0       	ldi	r31, 0x00	; 0
     dc4:	e9 83       	std	Y+1, r30	; 0x01
     dc6:	fa 83       	std	Y+2, r31	; 0x02
				break;
			}
		}
		if (rsum < 8192)
		{
         switch((rx_size >> i*2) & 0x03)     // Set Rx memory size
     dc8:	20 2e       	mov	r2, r16
     dca:	33 24       	eor	r3, r3
	RBUFBASEADDRESS[0] = (uint16_t)(__DEF_IINCHIP_MAP_RXBUF__);		/* Set base address of Rx memory for channel #0 */


   for (i = 0 ; i < MAX_SOCK_NUM; i++)       // Set the size, masking and base address of Tx & Rx memory by each channel
	{
		SSIZE[i] = (int16_t)(0);
     dcc:	fb 01       	movw	r30, r22
     dce:	10 82       	st	Z, r1
     dd0:	11 82       	std	Z+1, r1	; 0x01
		RSIZE[i] = (int16_t)(0);
     dd2:	eb 81       	ldd	r30, Y+3	; 0x03
     dd4:	fc 81       	ldd	r31, Y+4	; 0x04
     dd6:	10 82       	st	Z, r1
     dd8:	11 82       	std	Z+1, r1	; 0x01
		if (ssum < 8192)
     dda:	f0 e0       	ldi	r31, 0x00	; 0
     ddc:	6f 16       	cp	r6, r31
     dde:	f0 e2       	ldi	r31, 0x20	; 32
     de0:	7f 06       	cpc	r7, r31
     de2:	dc f5       	brge	.+118    	; 0xe5a <sysinit+0x122>
		{
         switch((tx_size >> i*2) & 0x03)  // Set Tx memory size
     de4:	89 81       	ldd	r24, Y+1	; 0x01
     de6:	9a 81       	ldd	r25, Y+2	; 0x02
     de8:	04 2e       	mov	r0, r20
     dea:	02 c0       	rjmp	.+4      	; 0xdf0 <sysinit+0xb8>
     dec:	95 95       	asr	r25
     dee:	87 95       	ror	r24
     df0:	0a 94       	dec	r0
     df2:	e2 f7       	brpl	.-8      	; 0xdec <sysinit+0xb4>
     df4:	83 70       	andi	r24, 0x03	; 3
     df6:	90 70       	andi	r25, 0x00	; 0
     df8:	81 30       	cpi	r24, 0x01	; 1
     dfa:	91 05       	cpc	r25, r1
     dfc:	a1 f0       	breq	.+40     	; 0xe26 <sysinit+0xee>
     dfe:	82 30       	cpi	r24, 0x02	; 2
     e00:	91 05       	cpc	r25, r1
     e02:	1c f4       	brge	.+6      	; 0xe0a <sysinit+0xd2>
     e04:	89 2b       	or	r24, r25
     e06:	39 f0       	breq	.+14     	; 0xe16 <sysinit+0xde>
     e08:	28 c0       	rjmp	.+80     	; 0xe5a <sysinit+0x122>
     e0a:	82 30       	cpi	r24, 0x02	; 2
     e0c:	91 05       	cpc	r25, r1
     e0e:	99 f0       	breq	.+38     	; 0xe36 <sysinit+0xfe>
     e10:	03 97       	sbiw	r24, 0x03	; 3
     e12:	19 f5       	brne	.+70     	; 0xe5a <sysinit+0x122>
     e14:	18 c0       	rjmp	.+48     	; 0xe46 <sysinit+0x10e>
			{
			case 0:
				SSIZE[i] = (int16_t)(1024);
     e16:	80 e0       	ldi	r24, 0x00	; 0
     e18:	94 e0       	ldi	r25, 0x04	; 4
     e1a:	fb 01       	movw	r30, r22
     e1c:	80 83       	st	Z, r24
     e1e:	91 83       	std	Z+1, r25	; 0x01
				SMASK[i] = (uint16_t)(0x03FF);
     e20:	8f ef       	ldi	r24, 0xFF	; 255
     e22:	93 e0       	ldi	r25, 0x03	; 3
     e24:	17 c0       	rjmp	.+46     	; 0xe54 <sysinit+0x11c>
				break;
			case 1:
				SSIZE[i] = (int16_t)(2048);
     e26:	80 e0       	ldi	r24, 0x00	; 0
     e28:	98 e0       	ldi	r25, 0x08	; 8
     e2a:	fb 01       	movw	r30, r22
     e2c:	80 83       	st	Z, r24
     e2e:	91 83       	std	Z+1, r25	; 0x01
				SMASK[i] = (uint16_t)(0x07FF);
     e30:	8f ef       	ldi	r24, 0xFF	; 255
     e32:	97 e0       	ldi	r25, 0x07	; 7
     e34:	0f c0       	rjmp	.+30     	; 0xe54 <sysinit+0x11c>
				break;
			case 2:
				SSIZE[i] = (int16_t)(4096);
     e36:	80 e0       	ldi	r24, 0x00	; 0
     e38:	90 e1       	ldi	r25, 0x10	; 16
     e3a:	fb 01       	movw	r30, r22
     e3c:	80 83       	st	Z, r24
     e3e:	91 83       	std	Z+1, r25	; 0x01
				SMASK[i] = (uint16_t)(0x0FFF);
     e40:	8f ef       	ldi	r24, 0xFF	; 255
     e42:	9f e0       	ldi	r25, 0x0F	; 15
     e44:	07 c0       	rjmp	.+14     	; 0xe54 <sysinit+0x11c>
				break;
			case 3:
				SSIZE[i] = (int16_t)(8192);
     e46:	80 e0       	ldi	r24, 0x00	; 0
     e48:	90 e2       	ldi	r25, 0x20	; 32
     e4a:	fb 01       	movw	r30, r22
     e4c:	80 83       	st	Z, r24
     e4e:	91 83       	std	Z+1, r25	; 0x01
				SMASK[i] = (uint16_t)(0x1FFF);
     e50:	8f ef       	ldi	r24, 0xFF	; 255
     e52:	9f e1       	ldi	r25, 0x1F	; 31
     e54:	f7 01       	movw	r30, r14
     e56:	80 83       	st	Z, r24
     e58:	91 83       	std	Z+1, r25	; 0x01
				break;
			}
		}
		if (rsum < 8192)
     e5a:	90 e0       	ldi	r25, 0x00	; 0
     e5c:	89 16       	cp	r8, r25
     e5e:	90 e2       	ldi	r25, 0x20	; 32
     e60:	99 06       	cpc	r9, r25
     e62:	0c f0       	brlt	.+2      	; 0xe66 <sysinit+0x12e>
     e64:	3e c0       	rjmp	.+124    	; 0xee2 <sysinit+0x1aa>
		{
         switch((rx_size >> i*2) & 0x03)     // Set Rx memory size
     e66:	c1 01       	movw	r24, r2
     e68:	04 2e       	mov	r0, r20
     e6a:	02 c0       	rjmp	.+4      	; 0xe70 <sysinit+0x138>
     e6c:	95 95       	asr	r25
     e6e:	87 95       	ror	r24
     e70:	0a 94       	dec	r0
     e72:	e2 f7       	brpl	.-8      	; 0xe6c <sysinit+0x134>
     e74:	83 70       	andi	r24, 0x03	; 3
     e76:	90 70       	andi	r25, 0x00	; 0
     e78:	81 30       	cpi	r24, 0x01	; 1
     e7a:	91 05       	cpc	r25, r1
     e7c:	a9 f0       	breq	.+42     	; 0xea8 <sysinit+0x170>
     e7e:	82 30       	cpi	r24, 0x02	; 2
     e80:	91 05       	cpc	r25, r1
     e82:	1c f4       	brge	.+6      	; 0xe8a <sysinit+0x152>
     e84:	89 2b       	or	r24, r25
     e86:	39 f0       	breq	.+14     	; 0xe96 <sysinit+0x15e>
     e88:	2c c0       	rjmp	.+88     	; 0xee2 <sysinit+0x1aa>
     e8a:	82 30       	cpi	r24, 0x02	; 2
     e8c:	91 05       	cpc	r25, r1
     e8e:	a9 f0       	breq	.+42     	; 0xeba <sysinit+0x182>
     e90:	03 97       	sbiw	r24, 0x03	; 3
     e92:	39 f5       	brne	.+78     	; 0xee2 <sysinit+0x1aa>
     e94:	1b c0       	rjmp	.+54     	; 0xecc <sysinit+0x194>
			{
			case 0:
				RSIZE[i] = (int16_t)(1024);
     e96:	80 e0       	ldi	r24, 0x00	; 0
     e98:	94 e0       	ldi	r25, 0x04	; 4
     e9a:	eb 81       	ldd	r30, Y+3	; 0x03
     e9c:	fc 81       	ldd	r31, Y+4	; 0x04
     e9e:	80 83       	st	Z, r24
     ea0:	91 83       	std	Z+1, r25	; 0x01
				RMASK[i] = (uint16_t)(0x03FF);
     ea2:	8f ef       	ldi	r24, 0xFF	; 255
     ea4:	93 e0       	ldi	r25, 0x03	; 3
     ea6:	1a c0       	rjmp	.+52     	; 0xedc <sysinit+0x1a4>
				break;
			case 1:
				RSIZE[i] = (int16_t)(2048);
     ea8:	80 e0       	ldi	r24, 0x00	; 0
     eaa:	98 e0       	ldi	r25, 0x08	; 8
     eac:	eb 81       	ldd	r30, Y+3	; 0x03
     eae:	fc 81       	ldd	r31, Y+4	; 0x04
     eb0:	80 83       	st	Z, r24
     eb2:	91 83       	std	Z+1, r25	; 0x01
				RMASK[i] = (uint16_t)(0x07FF);
     eb4:	8f ef       	ldi	r24, 0xFF	; 255
     eb6:	97 e0       	ldi	r25, 0x07	; 7
     eb8:	11 c0       	rjmp	.+34     	; 0xedc <sysinit+0x1a4>
				break;
			case 2:
				RSIZE[i] = (int16_t)(4096);
     eba:	80 e0       	ldi	r24, 0x00	; 0
     ebc:	90 e1       	ldi	r25, 0x10	; 16
     ebe:	eb 81       	ldd	r30, Y+3	; 0x03
     ec0:	fc 81       	ldd	r31, Y+4	; 0x04
     ec2:	80 83       	st	Z, r24
     ec4:	91 83       	std	Z+1, r25	; 0x01
				RMASK[i] = (uint16_t)(0x0FFF);
     ec6:	8f ef       	ldi	r24, 0xFF	; 255
     ec8:	9f e0       	ldi	r25, 0x0F	; 15
     eca:	08 c0       	rjmp	.+16     	; 0xedc <sysinit+0x1a4>
				break;
			case 3:
				RSIZE[i] = (int16_t)(8192);
     ecc:	80 e0       	ldi	r24, 0x00	; 0
     ece:	90 e2       	ldi	r25, 0x20	; 32
     ed0:	eb 81       	ldd	r30, Y+3	; 0x03
     ed2:	fc 81       	ldd	r31, Y+4	; 0x04
     ed4:	80 83       	st	Z, r24
     ed6:	91 83       	std	Z+1, r25	; 0x01
				RMASK[i] = (uint16_t)(0x1FFF);
     ed8:	8f ef       	ldi	r24, 0xFF	; 255
     eda:	9f e1       	ldi	r25, 0x1F	; 31
     edc:	f6 01       	movw	r30, r12
     ede:	80 83       	st	Z, r24
     ee0:	91 83       	std	Z+1, r25	; 0x01
				break;
			}
		}
		ssum += SSIZE[i];
     ee2:	fb 01       	movw	r30, r22
     ee4:	40 80       	ld	r4, Z
     ee6:	51 80       	ldd	r5, Z+1	; 0x01
		rsum += RSIZE[i];
     ee8:	eb 81       	ldd	r30, Y+3	; 0x03
     eea:	fc 81       	ldd	r31, Y+4	; 0x04
     eec:	00 81       	ld	r16, Z
     eee:	11 81       	ldd	r17, Z+1	; 0x01

      if (i != 0)             // Sets base address of Tx and Rx memory for channel #1,#2,#3
     ef0:	a1 14       	cp	r10, r1
     ef2:	b1 04       	cpc	r11, r1
     ef4:	f1 f0       	breq	.+60     	; 0xf32 <sysinit+0x1fa>
*/ 
void sysinit(
	uint8_t tx_size, 	/**< tx_size Tx memory size (00 - 1KByte, 01- 2KBtye, 10 - 4KByte, 11 - 8KByte) */
	uint8_t rx_size		/**< rx_size Rx memory size (00 - 1KByte, 01- 2KBtye, 10 - 4KByte, 11 - 8KByte) */
	)
{
     ef6:	fa 01       	movw	r30, r20
     ef8:	e6 5f       	subi	r30, 0xF6	; 246
     efa:	fe 4d       	sbci	r31, 0xDE	; 222
		ssum += SSIZE[i];
		rsum += RSIZE[i];

      if (i != 0)             // Sets base address of Tx and Rx memory for channel #1,#2,#3
		{
			SBUFBASEADDRESS[i] = SBUFBASEADDRESS[i-1] + SSIZE[i-1];
     efc:	da 01       	movw	r26, r20
     efe:	a8 50       	subi	r26, 0x08	; 8
     f00:	bf 4d       	sbci	r27, 0xDF	; 223
     f02:	8d 91       	ld	r24, X+
     f04:	9c 91       	ld	r25, X
     f06:	32 91       	ld	r19, -Z
     f08:	22 91       	ld	r18, -Z
     f0a:	32 96       	adiw	r30, 0x02	; 2
     f0c:	82 0f       	add	r24, r18
     f0e:	93 1f       	adc	r25, r19
     f10:	80 83       	st	Z, r24
     f12:	91 83       	std	Z+1, r25	; 0x01
*/ 
void sysinit(
	uint8_t tx_size, 	/**< tx_size Tx memory size (00 - 1KByte, 01- 2KBtye, 10 - 4KByte, 11 - 8KByte) */
	uint8_t rx_size		/**< rx_size Rx memory size (00 - 1KByte, 01- 2KBtye, 10 - 4KByte, 11 - 8KByte) */
	)
{
     f14:	fa 01       	movw	r30, r20
     f16:	ee 5e       	subi	r30, 0xEE	; 238
     f18:	fe 4d       	sbci	r31, 0xDE	; 222
		rsum += RSIZE[i];

      if (i != 0)             // Sets base address of Tx and Rx memory for channel #1,#2,#3
		{
			SBUFBASEADDRESS[i] = SBUFBASEADDRESS[i-1] + SSIZE[i-1];
			RBUFBASEADDRESS[i] = RBUFBASEADDRESS[i-1] + RSIZE[i-1];
     f1a:	da 01       	movw	r26, r20
     f1c:	a0 50       	subi	r26, 0x00	; 0
     f1e:	bf 4d       	sbci	r27, 0xDF	; 223
     f20:	8d 91       	ld	r24, X+
     f22:	9c 91       	ld	r25, X
     f24:	32 91       	ld	r19, -Z
     f26:	22 91       	ld	r18, -Z
     f28:	32 96       	adiw	r30, 0x02	; 2
     f2a:	82 0f       	add	r24, r18
     f2c:	93 1f       	adc	r25, r19
     f2e:	80 83       	st	Z, r24
     f30:	91 83       	std	Z+1, r25	; 0x01

	SBUFBASEADDRESS[0] = (uint16_t)(__DEF_IINCHIP_MAP_TXBUF__);		/* Set base address of Tx memory for channel #0 */
	RBUFBASEADDRESS[0] = (uint16_t)(__DEF_IINCHIP_MAP_RXBUF__);		/* Set base address of Rx memory for channel #0 */


   for (i = 0 ; i < MAX_SOCK_NUM; i++)       // Set the size, masking and base address of Tx & Rx memory by each channel
     f32:	08 94       	sec
     f34:	a1 1c       	adc	r10, r1
     f36:	b1 1c       	adc	r11, r1
     f38:	6e 5f       	subi	r22, 0xFE	; 254
     f3a:	7f 4f       	sbci	r23, 0xFF	; 255
     f3c:	4e 5f       	subi	r20, 0xFE	; 254
     f3e:	5f 4f       	sbci	r21, 0xFF	; 255
     f40:	8b 81       	ldd	r24, Y+3	; 0x03
     f42:	9c 81       	ldd	r25, Y+4	; 0x04
     f44:	02 96       	adiw	r24, 0x02	; 2
     f46:	8b 83       	std	Y+3, r24	; 0x03
     f48:	9c 83       	std	Y+4, r25	; 0x04
     f4a:	e2 e0       	ldi	r30, 0x02	; 2
     f4c:	f0 e0       	ldi	r31, 0x00	; 0
     f4e:	ce 0e       	add	r12, r30
     f50:	df 1e       	adc	r13, r31
     f52:	ee 0e       	add	r14, r30
     f54:	ff 1e       	adc	r15, r31
     f56:	f4 e0       	ldi	r31, 0x04	; 4
     f58:	af 16       	cp	r10, r31
     f5a:	b1 04       	cpc	r11, r1
     f5c:	29 f0       	breq	.+10     	; 0xf68 <sysinit+0x230>
				RSIZE[i] = (int16_t)(8192);
				RMASK[i] = (uint16_t)(0x1FFF);
				break;
			}
		}
		ssum += SSIZE[i];
     f5e:	64 0c       	add	r6, r4
     f60:	75 1c       	adc	r7, r5
		rsum += RSIZE[i];
     f62:	80 0e       	add	r8, r16
     f64:	91 1e       	adc	r9, r17
     f66:	32 cf       	rjmp	.-412    	; 0xdcc <sysinit+0x94>
		{
			SBUFBASEADDRESS[i] = SBUFBASEADDRESS[i-1] + SSIZE[i-1];
			RBUFBASEADDRESS[i] = RBUFBASEADDRESS[i-1] + RSIZE[i-1];
		}
	}
}
     f68:	24 96       	adiw	r28, 0x04	; 4
     f6a:	cd bf       	out	0x3d, r28	; 61
     f6c:	de bf       	out	0x3e, r29	; 62
     f6e:	cf 91       	pop	r28
     f70:	df 91       	pop	r29
     f72:	1f 91       	pop	r17
     f74:	0f 91       	pop	r16
     f76:	ff 90       	pop	r15
     f78:	ef 90       	pop	r14
     f7a:	df 90       	pop	r13
     f7c:	cf 90       	pop	r12
     f7e:	bf 90       	pop	r11
     f80:	af 90       	pop	r10
     f82:	9f 90       	pop	r9
     f84:	8f 90       	pop	r8
     f86:	7f 90       	pop	r7
     f88:	6f 90       	pop	r6
     f8a:	5f 90       	pop	r5
     f8c:	4f 90       	pop	r4
     f8e:	3f 90       	pop	r3
     f90:	2f 90       	pop	r2
     f92:	08 95       	ret

00000f94 <setIMR>:

If any bit in IMR is set as '0' then there is not interrupt signal though the bit is
set in IR register.
*/
void setIMR(uint8_t mask)
{
     f94:	68 2f       	mov	r22, r24
	IINCHIP_WRITE(IMR,mask); // must be setted 0x10.
     f96:	86 e1       	ldi	r24, 0x16	; 22
     f98:	90 e0       	ldi	r25, 0x00	; 0
     f9a:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
}
     f9e:	08 95       	ret

00000fa0 <wiz_read_buf>:

/**
@brief	This function reads into W5100 memory(Buffer)
*/ 
uint16_t wiz_read_buf(uint16_t addr, uint8_t* buf,uint16_t len)
{
     fa0:	9f 92       	push	r9
     fa2:	af 92       	push	r10
     fa4:	bf 92       	push	r11
     fa6:	cf 92       	push	r12
     fa8:	df 92       	push	r13
     faa:	ef 92       	push	r14
     fac:	ff 92       	push	r15
     fae:	0f 93       	push	r16
     fb0:	1f 93       	push	r17
     fb2:	cf 93       	push	r28
     fb4:	df 93       	push	r29
     fb6:	8c 01       	movw	r16, r24
     fb8:	6b 01       	movw	r12, r22
     fba:	7a 01       	movw	r14, r20
     fbc:	c0 e0       	ldi	r28, 0x00	; 0
     fbe:	d0 e0       	ldi	r29, 0x00	; 0
	uint16_t idx = 0;
   
	for (idx=0; idx<len; idx++)
      	   {
		IINCHIP_CSoff();                             // CS=0, SPI start 
     fc0:	40 e6       	ldi	r20, 0x60	; 96
     fc2:	a4 2e       	mov	r10, r20
     fc4:	46 e0       	ldi	r20, 0x06	; 6
     fc6:	b4 2e       	mov	r11, r20
     fc8:	30 e1       	ldi	r19, 0x10	; 16
     fca:	93 2e       	mov	r9, r19
     fcc:	19 c0       	rjmp	.+50     	; 0x1000 <wiz_read_buf+0x60>
     fce:	f5 01       	movw	r30, r10
     fd0:	96 82       	std	Z+6, r9	; 0x06

		IINCHIP_SpiSendData(0x0F);
     fd2:	8f e0       	ldi	r24, 0x0F	; 15
     fd4:	0e 94 ab 04 	call	0x956	; 0x956 <IINCHIP_SpiSendData>
		IINCHIP_SpiSendData(((addr+idx) & 0xFF00) >> 8);
     fd8:	81 2f       	mov	r24, r17
     fda:	0e 94 ab 04 	call	0x956	; 0x956 <IINCHIP_SpiSendData>
		IINCHIP_SpiSendData((addr+idx) & 0x00FF);
     fde:	80 2f       	mov	r24, r16
     fe0:	0e 94 ab 04 	call	0x956	; 0x956 <IINCHIP_SpiSendData>


		IINCHIP_SpiSendData(0);
     fe4:	80 e0       	ldi	r24, 0x00	; 0
     fe6:	0e 94 ab 04 	call	0x956	; 0x956 <IINCHIP_SpiSendData>
		buf[idx] = IINCHIP_SpiRecvData();
     fea:	0e 94 b3 04 	call	0x966	; 0x966 <IINCHIP_SpiRecvData>
     fee:	f6 01       	movw	r30, r12
     ff0:	ec 0f       	add	r30, r28
     ff2:	fd 1f       	adc	r31, r29
     ff4:	80 83       	st	Z, r24

		IINCHIP_CSon();                             // CS=0, SPI end 	   
     ff6:	f5 01       	movw	r30, r10
     ff8:	95 82       	std	Z+5, r9	; 0x05
*/ 
uint16_t wiz_read_buf(uint16_t addr, uint8_t* buf,uint16_t len)
{
	uint16_t idx = 0;
   
	for (idx=0; idx<len; idx++)
     ffa:	21 96       	adiw	r28, 0x01	; 1
     ffc:	0f 5f       	subi	r16, 0xFF	; 255
     ffe:	1f 4f       	sbci	r17, 0xFF	; 255
    1000:	ce 15       	cp	r28, r14
    1002:	df 05       	cpc	r29, r15
    1004:	20 f3       	brcs	.-56     	; 0xfce <wiz_read_buf+0x2e>
		IINCHIP_CSon();                             // CS=0, SPI end 	   
	   }


	return len;
}
    1006:	c7 01       	movw	r24, r14
    1008:	df 91       	pop	r29
    100a:	cf 91       	pop	r28
    100c:	1f 91       	pop	r17
    100e:	0f 91       	pop	r16
    1010:	ff 90       	pop	r15
    1012:	ef 90       	pop	r14
    1014:	df 90       	pop	r13
    1016:	cf 90       	pop	r12
    1018:	bf 90       	pop	r11
    101a:	af 90       	pop	r10
    101c:	9f 90       	pop	r9
    101e:	08 95       	ret

00001020 <read_data>:
It calculate the actual physical address where one has to read
the data from Receive buffer. Here also take care of the condition while it exceed
the Rx memory uper-bound of socket.
*/
void read_data(SOCKET s, volatile uint8_t * src, volatile uint8_t * dst, uint16_t len)
{
    1020:	cf 92       	push	r12
    1022:	df 92       	push	r13
    1024:	ef 92       	push	r14
    1026:	ff 92       	push	r15
    1028:	0f 93       	push	r16
    102a:	1f 93       	push	r17
    102c:	cf 93       	push	r28
    102e:	df 93       	push	r29
    1030:	7a 01       	movw	r14, r20
    1032:	e9 01       	movw	r28, r18
{
	IINCHIP_WRITE(MR,val);
}
uint16_t getIINCHIP_RxMASK(uint8_t s)
{
   return RMASK[s];
    1034:	e8 2f       	mov	r30, r24
    1036:	f0 e0       	ldi	r31, 0x00	; 0
{
	uint16_t size;
	uint16_t src_mask;
	uint8_t * src_ptr;

	src_mask = (uint16_t)src & getIINCHIP_RxMASK(s);
    1038:	ee 0f       	add	r30, r30
    103a:	ff 1f       	adc	r31, r31
    103c:	df 01       	movw	r26, r30
    103e:	ae 50       	subi	r26, 0x0E	; 14
    1040:	bf 4d       	sbci	r27, 0xDF	; 223
    1042:	8d 91       	ld	r24, X+
    1044:	9c 91       	ld	r25, X
    1046:	68 23       	and	r22, r24
    1048:	79 23       	and	r23, r25
	src_ptr = (uint8_t *)(getIINCHIP_RxBASE(s) + src_mask);
    104a:	52 e1       	ldi	r21, 0x12	; 18
    104c:	c5 2e       	mov	r12, r21
    104e:	51 e2       	ldi	r21, 0x21	; 33
    1050:	d5 2e       	mov	r13, r21
    1052:	ce 0e       	add	r12, r30
    1054:	df 1e       	adc	r13, r31
    1056:	d6 01       	movw	r26, r12
    1058:	2d 91       	ld	r18, X+
    105a:	3c 91       	ld	r19, X
    105c:	26 0f       	add	r18, r22
    105e:	37 1f       	adc	r19, r23
   return val;
}

uint16_t getIINCHIP_RxMAX(uint8_t s)
{
   return RSIZE[s];
    1060:	ee 5f       	subi	r30, 0xFE	; 254
    1062:	fe 4d       	sbci	r31, 0xDE	; 222
    1064:	01 90       	ld	r0, Z+
    1066:	f0 81       	ld	r31, Z
    1068:	e0 2d       	mov	r30, r0
	uint8_t * src_ptr;

	src_mask = (uint16_t)src & getIINCHIP_RxMASK(s);
	src_ptr = (uint8_t *)(getIINCHIP_RxBASE(s) + src_mask);
	
	if( (src_mask + len) > getIINCHIP_RxMAX(s) ) 
    106a:	ce 01       	movw	r24, r28
    106c:	86 0f       	add	r24, r22
    106e:	97 1f       	adc	r25, r23
    1070:	e8 17       	cp	r30, r24
    1072:	f9 07       	cpc	r31, r25
    1074:	88 f4       	brcc	.+34     	; 0x1098 <read_data+0x78>
	{
		size = getIINCHIP_RxMAX(s) - src_mask;
    1076:	8f 01       	movw	r16, r30
    1078:	06 1b       	sub	r16, r22
    107a:	17 0b       	sbc	r17, r23
		wiz_read_buf((uint16_t)src_ptr, (uint8_t*)dst,size);
    107c:	c9 01       	movw	r24, r18
    107e:	b7 01       	movw	r22, r14
    1080:	a8 01       	movw	r20, r16
    1082:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <wiz_read_buf>
		dst += size;
		size = len - size;
		src_ptr = (uint8_t *)(getIINCHIP_RxBASE(s));
		wiz_read_buf((uint16_t)src_ptr, (uint8_t*) dst,size);
    1086:	c0 1b       	sub	r28, r16
    1088:	d1 0b       	sbc	r29, r17
    108a:	f6 01       	movw	r30, r12
    108c:	80 81       	ld	r24, Z
    108e:	91 81       	ldd	r25, Z+1	; 0x01
    1090:	0e 0d       	add	r16, r14
    1092:	1f 1d       	adc	r17, r15
    1094:	b8 01       	movw	r22, r16
    1096:	02 c0       	rjmp	.+4      	; 0x109c <read_data+0x7c>
	} 
	else
	{
		wiz_read_buf((uint16_t)src_ptr, (uint8_t*) dst,len);
    1098:	c9 01       	movw	r24, r18
    109a:	b7 01       	movw	r22, r14
    109c:	ae 01       	movw	r20, r28
    109e:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <wiz_read_buf>
	}
}
    10a2:	df 91       	pop	r29
    10a4:	cf 91       	pop	r28
    10a6:	1f 91       	pop	r17
    10a8:	0f 91       	pop	r16
    10aa:	ff 90       	pop	r15
    10ac:	ef 90       	pop	r14
    10ae:	df 90       	pop	r13
    10b0:	cf 90       	pop	r12
    10b2:	08 95       	ret

000010b4 <IINCHIP_READ>:

/**
@brief	This function reads the value from W5100 registers.
*/
uint8_t IINCHIP_READ(uint16_t addr)
{
    10b4:	df 92       	push	r13
    10b6:	ef 92       	push	r14
    10b8:	ff 92       	push	r15
    10ba:	0f 93       	push	r16
    10bc:	1f 93       	push	r17
    10be:	d8 2e       	mov	r13, r24
    10c0:	f9 2e       	mov	r15, r25
	uint8_t data;
 
	IINCHIP_CSoff();                             // CS=0, SPI start
    10c2:	00 e6       	ldi	r16, 0x60	; 96
    10c4:	16 e0       	ldi	r17, 0x06	; 6
    10c6:	b0 e1       	ldi	r27, 0x10	; 16
    10c8:	eb 2e       	mov	r14, r27
    10ca:	f8 01       	movw	r30, r16
    10cc:	e6 82       	std	Z+6, r14	; 0x06

	IINCHIP_SpiSendData(0x0F);
    10ce:	8f e0       	ldi	r24, 0x0F	; 15
    10d0:	0e 94 ab 04 	call	0x956	; 0x956 <IINCHIP_SpiSendData>
	IINCHIP_SpiSendData((addr & 0xFF00) >> 8);
    10d4:	8f 2d       	mov	r24, r15
    10d6:	0e 94 ab 04 	call	0x956	; 0x956 <IINCHIP_SpiSendData>
	IINCHIP_SpiSendData(addr & 0x00FF);
    10da:	8d 2d       	mov	r24, r13
    10dc:	0e 94 ab 04 	call	0x956	; 0x956 <IINCHIP_SpiSendData>
	
	
	IINCHIP_SpiSendData(0);
    10e0:	80 e0       	ldi	r24, 0x00	; 0
    10e2:	0e 94 ab 04 	call	0x956	; 0x956 <IINCHIP_SpiSendData>
	data = IINCHIP_SpiRecvData();
    10e6:	0e 94 b3 04 	call	0x966	; 0x966 <IINCHIP_SpiRecvData>

	IINCHIP_CSon();                          	// SPI end
    10ea:	f8 01       	movw	r30, r16
    10ec:	e5 82       	std	Z+5, r14	; 0x05

	return data;
}
    10ee:	1f 91       	pop	r17
    10f0:	0f 91       	pop	r16
    10f2:	ff 90       	pop	r15
    10f4:	ef 90       	pop	r14
    10f6:	df 90       	pop	r13
    10f8:	08 95       	ret

000010fa <getSn_TX_FSR>:

This gives free buffer size of transmit buffer. This is the data size that user can transmit.
User shuold check this value first and control the size of transmitting data
*/
uint16_t getSn_TX_FSR(SOCKET s)
{
    10fa:	8f 92       	push	r8
    10fc:	9f 92       	push	r9
    10fe:	af 92       	push	r10
    1100:	bf 92       	push	r11
    1102:	cf 92       	push	r12
    1104:	df 92       	push	r13
    1106:	ef 92       	push	r14
    1108:	ff 92       	push	r15
    110a:	0f 93       	push	r16
    110c:	1f 93       	push	r17
    110e:	cf 93       	push	r28
    1110:	df 93       	push	r29
	uint16_t val=0,val1=0;
	do
	{
		val1 = IINCHIP_READ(Sn_TX_FSR0(s));
    1112:	90 e0       	ldi	r25, 0x00	; 0
    1114:	98 2f       	mov	r25, r24
    1116:	88 27       	eor	r24, r24
    1118:	80 5e       	subi	r24, 0xE0	; 224
    111a:	9b 4f       	sbci	r25, 0xFB	; 251
    111c:	4c 01       	movw	r8, r24
		val1 = (val1 << 8) + IINCHIP_READ(Sn_TX_FSR0(s) + 1);
    111e:	5c 01       	movw	r10, r24
    1120:	08 94       	sec
    1122:	a1 1c       	adc	r10, r1
    1124:	b1 1c       	adc	r11, r1
    1126:	c0 e0       	ldi	r28, 0x00	; 0
    1128:	d0 e0       	ldi	r29, 0x00	; 0
uint16_t getSn_TX_FSR(SOCKET s)
{
	uint16_t val=0,val1=0;
	do
	{
		val1 = IINCHIP_READ(Sn_TX_FSR0(s));
    112a:	c4 01       	movw	r24, r8
    112c:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
		val1 = (val1 << 8) + IINCHIP_READ(Sn_TX_FSR0(s) + 1);
    1130:	f8 2e       	mov	r15, r24
    1132:	ee 24       	eor	r14, r14
    1134:	c5 01       	movw	r24, r10
    1136:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    113a:	67 01       	movw	r12, r14
    113c:	c8 0e       	add	r12, r24
    113e:	d1 1c       	adc	r13, r1
      if (val1 != 0)
    1140:	c1 14       	cp	r12, r1
    1142:	d1 04       	cpc	r13, r1
    1144:	59 f0       	breq	.+22     	; 0x115c <getSn_TX_FSR+0x62>
		{
   			val = IINCHIP_READ(Sn_TX_FSR0(s));
    1146:	c4 01       	movw	r24, r8
    1148:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
   			val = (val << 8) + IINCHIP_READ(Sn_TX_FSR0(s) + 1);
    114c:	18 2f       	mov	r17, r24
    114e:	00 e0       	ldi	r16, 0x00	; 0
    1150:	c5 01       	movw	r24, r10
    1152:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    1156:	e8 01       	movw	r28, r16
    1158:	c8 0f       	add	r28, r24
    115a:	d1 1d       	adc	r29, r1
		}
	} while (val != val1);
    115c:	cc 15       	cp	r28, r12
    115e:	dd 05       	cpc	r29, r13
    1160:	21 f7       	brne	.-56     	; 0x112a <getSn_TX_FSR+0x30>
   return val;
}
    1162:	ce 01       	movw	r24, r28
    1164:	df 91       	pop	r29
    1166:	cf 91       	pop	r28
    1168:	1f 91       	pop	r17
    116a:	0f 91       	pop	r16
    116c:	ff 90       	pop	r15
    116e:	ef 90       	pop	r14
    1170:	df 90       	pop	r13
    1172:	cf 90       	pop	r12
    1174:	bf 90       	pop	r11
    1176:	af 90       	pop	r10
    1178:	9f 90       	pop	r9
    117a:	8f 90       	pop	r8
    117c:	08 95       	ret

0000117e <getSn_DIPR>:
{
   return SBUFBASEADDRESS[s];
}

void getSn_DIPR(SOCKET s, uint8_t * addr)
{
    117e:	ef 92       	push	r14
    1180:	ff 92       	push	r15
    1182:	0f 93       	push	r16
    1184:	1f 93       	push	r17
    1186:	7b 01       	movw	r14, r22
	addr[0] = IINCHIP_READ(Sn_DIPR0(s));
    1188:	08 2f       	mov	r16, r24
    118a:	10 e0       	ldi	r17, 0x00	; 0
    118c:	0c 5f       	subi	r16, 0xFC	; 252
    118e:	1f 4f       	sbci	r17, 0xFF	; 255
    1190:	10 2f       	mov	r17, r16
    1192:	00 27       	eor	r16, r16
    1194:	c8 01       	movw	r24, r16
    1196:	0c 96       	adiw	r24, 0x0c	; 12
    1198:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    119c:	f7 01       	movw	r30, r14
    119e:	80 83       	st	Z, r24
	addr[1] = IINCHIP_READ(Sn_DIPR0(s)+1);
    11a0:	c8 01       	movw	r24, r16
    11a2:	0d 96       	adiw	r24, 0x0d	; 13
    11a4:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    11a8:	f7 01       	movw	r30, r14
    11aa:	81 83       	std	Z+1, r24	; 0x01
	addr[2] = IINCHIP_READ(Sn_DIPR0(s)+2);
    11ac:	c8 01       	movw	r24, r16
    11ae:	0e 96       	adiw	r24, 0x0e	; 14
    11b0:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    11b4:	f7 01       	movw	r30, r14
    11b6:	82 83       	std	Z+2, r24	; 0x02
	addr[3] = IINCHIP_READ(Sn_DIPR0(s)+3);
    11b8:	c8 01       	movw	r24, r16
    11ba:	0f 96       	adiw	r24, 0x0f	; 15
    11bc:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    11c0:	f7 01       	movw	r30, r14
    11c2:	83 83       	std	Z+3, r24	; 0x03
}
    11c4:	1f 91       	pop	r17
    11c6:	0f 91       	pop	r16
    11c8:	ff 90       	pop	r15
    11ca:	ef 90       	pop	r14
    11cc:	08 95       	ret

000011ce <getSn_RX_RSR>:
@brief	 get socket RX recv buf size

This gives size of received data in receive buffer. 
*/
uint16_t getSn_RX_RSR(SOCKET s)
{
    11ce:	8f 92       	push	r8
    11d0:	9f 92       	push	r9
    11d2:	af 92       	push	r10
    11d4:	bf 92       	push	r11
    11d6:	cf 92       	push	r12
    11d8:	df 92       	push	r13
    11da:	ef 92       	push	r14
    11dc:	ff 92       	push	r15
    11de:	0f 93       	push	r16
    11e0:	1f 93       	push	r17
    11e2:	cf 93       	push	r28
    11e4:	df 93       	push	r29
	uint16_t val=0,val1=0;
	do
	{
		val1 = IINCHIP_READ(Sn_RX_RSR0(s));
    11e6:	90 e0       	ldi	r25, 0x00	; 0
    11e8:	04 96       	adiw	r24, 0x04	; 4
    11ea:	98 2f       	mov	r25, r24
    11ec:	88 27       	eor	r24, r24
    11ee:	36 e2       	ldi	r19, 0x26	; 38
    11f0:	83 2e       	mov	r8, r19
    11f2:	91 2c       	mov	r9, r1
    11f4:	88 0e       	add	r8, r24
    11f6:	99 1e       	adc	r9, r25
		val1 = (val1 << 8) + IINCHIP_READ(Sn_RX_RSR0(s) + 1);
    11f8:	27 e2       	ldi	r18, 0x27	; 39
    11fa:	a2 2e       	mov	r10, r18
    11fc:	b1 2c       	mov	r11, r1
    11fe:	a8 0e       	add	r10, r24
    1200:	b9 1e       	adc	r11, r25
    1202:	c0 e0       	ldi	r28, 0x00	; 0
    1204:	d0 e0       	ldi	r29, 0x00	; 0
uint16_t getSn_RX_RSR(SOCKET s)
{
	uint16_t val=0,val1=0;
	do
	{
		val1 = IINCHIP_READ(Sn_RX_RSR0(s));
    1206:	c4 01       	movw	r24, r8
    1208:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
		val1 = (val1 << 8) + IINCHIP_READ(Sn_RX_RSR0(s) + 1);
    120c:	f8 2e       	mov	r15, r24
    120e:	ee 24       	eor	r14, r14
    1210:	c5 01       	movw	r24, r10
    1212:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    1216:	67 01       	movw	r12, r14
    1218:	c8 0e       	add	r12, r24
    121a:	d1 1c       	adc	r13, r1
      if(val1 != 0)
    121c:	c1 14       	cp	r12, r1
    121e:	d1 04       	cpc	r13, r1
    1220:	59 f0       	breq	.+22     	; 0x1238 <getSn_RX_RSR+0x6a>
		{
   			val = IINCHIP_READ(Sn_RX_RSR0(s));
    1222:	c4 01       	movw	r24, r8
    1224:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
   			val = (val << 8) + IINCHIP_READ(Sn_RX_RSR0(s) + 1);
    1228:	18 2f       	mov	r17, r24
    122a:	00 e0       	ldi	r16, 0x00	; 0
    122c:	c5 01       	movw	r24, r10
    122e:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    1232:	e8 01       	movw	r28, r16
    1234:	c8 0f       	add	r28, r24
    1236:	d1 1d       	adc	r29, r1
		}
	} while (val != val1);
    1238:	cc 15       	cp	r28, r12
    123a:	dd 05       	cpc	r29, r13
    123c:	21 f7       	brne	.-56     	; 0x1206 <getSn_RX_RSR+0x38>
   return val;
}
    123e:	ce 01       	movw	r24, r28
    1240:	df 91       	pop	r29
    1242:	cf 91       	pop	r28
    1244:	1f 91       	pop	r17
    1246:	0f 91       	pop	r16
    1248:	ff 90       	pop	r15
    124a:	ef 90       	pop	r14
    124c:	df 90       	pop	r13
    124e:	cf 90       	pop	r12
    1250:	bf 90       	pop	r11
    1252:	af 90       	pop	r10
    1254:	9f 90       	pop	r9
    1256:	8f 90       	pop	r8
    1258:	08 95       	ret

0000125a <getSn_SR>:
/**
@brief	 get socket status
*/
uint8_t getSn_SR(SOCKET s)
{
   return IINCHIP_READ(Sn_SR(s));
    125a:	90 e0       	ldi	r25, 0x00	; 0
    125c:	98 2f       	mov	r25, r24
    125e:	88 27       	eor	r24, r24
    1260:	8d 5f       	subi	r24, 0xFD	; 253
    1262:	9b 4f       	sbci	r25, 0xFB	; 251
    1264:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
}
    1268:	08 95       	ret

0000126a <recv_data_processing>:
This function read the Rx read pointer register
and after copy the data from receive buffer update the Rx write pointer register.
User should read upper byte first and lower byte later to get proper value.
*/
void recv_data_processing(SOCKET s, uint8_t *data, uint16_t len)
{
    126a:	7f 92       	push	r7
    126c:	8f 92       	push	r8
    126e:	9f 92       	push	r9
    1270:	af 92       	push	r10
    1272:	bf 92       	push	r11
    1274:	cf 92       	push	r12
    1276:	df 92       	push	r13
    1278:	ef 92       	push	r14
    127a:	ff 92       	push	r15
    127c:	0f 93       	push	r16
    127e:	1f 93       	push	r17
    1280:	78 2e       	mov	r7, r24
    1282:	4b 01       	movw	r8, r22
    1284:	5a 01       	movw	r10, r20
	uint16_t ptr;
	ptr = IINCHIP_READ(Sn_RX_RD0(s));
    1286:	e8 2e       	mov	r14, r24
    1288:	ff 24       	eor	r15, r15
    128a:	84 e0       	ldi	r24, 0x04	; 4
    128c:	90 e0       	ldi	r25, 0x00	; 0
    128e:	e8 0e       	add	r14, r24
    1290:	f9 1e       	adc	r15, r25
    1292:	fe 2c       	mov	r15, r14
    1294:	ee 24       	eor	r14, r14
    1296:	68 e2       	ldi	r22, 0x28	; 40
    1298:	c6 2e       	mov	r12, r22
    129a:	d1 2c       	mov	r13, r1
    129c:	ce 0c       	add	r12, r14
    129e:	df 1c       	adc	r13, r15
    12a0:	c6 01       	movw	r24, r12
    12a2:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
	ptr = ((ptr & 0x00ff) << 8) + IINCHIP_READ(Sn_RX_RD0(s) + 1);
    12a6:	18 2f       	mov	r17, r24
    12a8:	00 e0       	ldi	r16, 0x00	; 0
    12aa:	89 e2       	ldi	r24, 0x29	; 41
    12ac:	90 e0       	ldi	r25, 0x00	; 0
    12ae:	e8 0e       	add	r14, r24
    12b0:	f9 1e       	adc	r15, r25
    12b2:	c7 01       	movw	r24, r14
    12b4:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    12b8:	08 0f       	add	r16, r24
    12ba:	11 1d       	adc	r17, r1
#ifdef __DEF_IINCHIP_DBG__
	printf("ISR_RX: rd_ptr : %.4x\r\n", ptr);
#endif
	read_data(s, (uint8_t *)ptr, data, len); // read data
    12bc:	87 2d       	mov	r24, r7
    12be:	b8 01       	movw	r22, r16
    12c0:	a4 01       	movw	r20, r8
    12c2:	95 01       	movw	r18, r10
    12c4:	0e 94 10 08 	call	0x1020	; 0x1020 <read_data>
	ptr += len;
    12c8:	0a 0d       	add	r16, r10
    12ca:	1b 1d       	adc	r17, r11
	IINCHIP_WRITE(Sn_RX_RD0(s),(uint8_t)((ptr & 0xff00) >> 8));
    12cc:	c6 01       	movw	r24, r12
    12ce:	61 2f       	mov	r22, r17
    12d0:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE((Sn_RX_RD0(s) + 1),(uint8_t)(ptr & 0x00ff));
    12d4:	c7 01       	movw	r24, r14
    12d6:	60 2f       	mov	r22, r16
    12d8:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
}
    12dc:	1f 91       	pop	r17
    12de:	0f 91       	pop	r16
    12e0:	ff 90       	pop	r15
    12e2:	ef 90       	pop	r14
    12e4:	df 90       	pop	r13
    12e6:	cf 90       	pop	r12
    12e8:	bf 90       	pop	r11
    12ea:	af 90       	pop	r10
    12ec:	9f 90       	pop	r9
    12ee:	8f 90       	pop	r8
    12f0:	7f 90       	pop	r7
    12f2:	08 95       	ret

000012f4 <send_data_processing>:

This function read the Tx write pointer register and after copy the data in buffer update the Tx write pointer
register. User should read upper byte first and lower byte later to get proper value.
*/
void send_data_processing(SOCKET s, uint8_t *data, uint16_t len)
{
    12f4:	7f 92       	push	r7
    12f6:	8f 92       	push	r8
    12f8:	9f 92       	push	r9
    12fa:	af 92       	push	r10
    12fc:	bf 92       	push	r11
    12fe:	cf 92       	push	r12
    1300:	df 92       	push	r13
    1302:	ef 92       	push	r14
    1304:	ff 92       	push	r15
    1306:	0f 93       	push	r16
    1308:	1f 93       	push	r17
    130a:	78 2e       	mov	r7, r24
    130c:	4b 01       	movw	r8, r22
    130e:	5a 01       	movw	r10, r20
	uint16_t ptr;
	ptr = IINCHIP_READ(Sn_TX_WR0(s));
    1310:	e8 2e       	mov	r14, r24
    1312:	ff 24       	eor	r15, r15
    1314:	84 e0       	ldi	r24, 0x04	; 4
    1316:	90 e0       	ldi	r25, 0x00	; 0
    1318:	e8 0e       	add	r14, r24
    131a:	f9 1e       	adc	r15, r25
    131c:	fe 2c       	mov	r15, r14
    131e:	ee 24       	eor	r14, r14
    1320:	e4 e2       	ldi	r30, 0x24	; 36
    1322:	ce 2e       	mov	r12, r30
    1324:	d1 2c       	mov	r13, r1
    1326:	ce 0c       	add	r12, r14
    1328:	df 1c       	adc	r13, r15
    132a:	c6 01       	movw	r24, r12
    132c:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
	ptr = ((ptr & 0x00ff) << 8) + IINCHIP_READ(Sn_TX_WR0(s) + 1);
    1330:	18 2f       	mov	r17, r24
    1332:	00 e0       	ldi	r16, 0x00	; 0
    1334:	85 e2       	ldi	r24, 0x25	; 37
    1336:	90 e0       	ldi	r25, 0x00	; 0
    1338:	e8 0e       	add	r14, r24
    133a:	f9 1e       	adc	r15, r25
    133c:	c7 01       	movw	r24, r14
    133e:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    1342:	08 0f       	add	r16, r24
    1344:	11 1d       	adc	r17, r1
	write_data(s, data, (uint8_t *)(ptr), len);
    1346:	87 2d       	mov	r24, r7
    1348:	b4 01       	movw	r22, r8
    134a:	a8 01       	movw	r20, r16
    134c:	95 01       	movw	r18, r10
    134e:	0e 94 a1 05 	call	0xb42	; 0xb42 <write_data>
	ptr += len;
    1352:	0a 0d       	add	r16, r10
    1354:	1b 1d       	adc	r17, r11
	IINCHIP_WRITE(Sn_TX_WR0(s),(uint8_t)((ptr & 0xff00) >> 8));
    1356:	c6 01       	movw	r24, r12
    1358:	61 2f       	mov	r22, r17
    135a:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
	IINCHIP_WRITE((Sn_TX_WR0(s) + 1),(uint8_t)(ptr & 0x00ff));
    135e:	c7 01       	movw	r24, r14
    1360:	60 2f       	mov	r22, r16
    1362:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
}
    1366:	1f 91       	pop	r17
    1368:	0f 91       	pop	r16
    136a:	ff 90       	pop	r15
    136c:	ef 90       	pop	r14
    136e:	df 90       	pop	r13
    1370:	cf 90       	pop	r12
    1372:	bf 90       	pop	r11
    1374:	af 90       	pop	r10
    1376:	9f 90       	pop	r9
    1378:	8f 90       	pop	r8
    137a:	7f 90       	pop	r7
    137c:	08 95       	ret

0000137e <recvfrom>:
	uint8_t * buf, 	/**< a pointer to copy the data to be received */
	uint16_t len, 	/**< the data size to read */
	uint8_t * addr, 	/**< a pointer to store the peer's IP address */
	uint16_t *port	/**< a pointer to store the peer's port number. */
	)
{
    137e:	2f 92       	push	r2
    1380:	3f 92       	push	r3
    1382:	4f 92       	push	r4
    1384:	5f 92       	push	r5
    1386:	6f 92       	push	r6
    1388:	7f 92       	push	r7
    138a:	8f 92       	push	r8
    138c:	9f 92       	push	r9
    138e:	af 92       	push	r10
    1390:	bf 92       	push	r11
    1392:	df 92       	push	r13
    1394:	ef 92       	push	r14
    1396:	ff 92       	push	r15
    1398:	0f 93       	push	r16
    139a:	1f 93       	push	r17
    139c:	df 93       	push	r29
    139e:	cf 93       	push	r28
    13a0:	cd b7       	in	r28, 0x3d	; 61
    13a2:	de b7       	in	r29, 0x3e	; 62
    13a4:	28 97       	sbiw	r28, 0x08	; 8
    13a6:	cd bf       	out	0x3d, r28	; 61
    13a8:	de bf       	out	0x3e, r29	; 62
    13aa:	d8 2e       	mov	r13, r24
    13ac:	2b 01       	movw	r4, r22
    13ae:	79 01       	movw	r14, r18
    13b0:	18 01       	movw	r2, r16
	uint8_t head[8];
	uint16_t data_len=0;
	uint16_t ptr=0;

	if ( len > 0 )
    13b2:	45 2b       	or	r20, r21
    13b4:	19 f4       	brne	.+6      	; 0x13bc <recvfrom+0x3e>
    13b6:	ee 24       	eor	r14, r14
    13b8:	ff 24       	eor	r15, r15
    13ba:	97 c0       	rjmp	.+302    	; 0x14ea <recvfrom+0x16c>
	{
   	ptr = IINCHIP_READ(Sn_RX_RD0(s));
    13bc:	90 e0       	ldi	r25, 0x00	; 0
    13be:	04 96       	adiw	r24, 0x04	; 4
    13c0:	78 2e       	mov	r7, r24
    13c2:	66 24       	eor	r6, r6
    13c4:	b8 e2       	ldi	r27, 0x28	; 40
    13c6:	ab 2e       	mov	r10, r27
    13c8:	b1 2c       	mov	r11, r1
    13ca:	a6 0c       	add	r10, r6
    13cc:	b7 1c       	adc	r11, r7
    13ce:	c5 01       	movw	r24, r10
    13d0:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
   	ptr = ((ptr & 0x00ff) << 8) + IINCHIP_READ(Sn_RX_RD0(s) + 1);
    13d4:	18 2f       	mov	r17, r24
    13d6:	00 e0       	ldi	r16, 0x00	; 0
    13d8:	a9 e2       	ldi	r26, 0x29	; 41
    13da:	8a 2e       	mov	r8, r26
    13dc:	91 2c       	mov	r9, r1
    13de:	86 0c       	add	r8, r6
    13e0:	97 1c       	adc	r9, r7
    13e2:	c4 01       	movw	r24, r8
    13e4:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    13e8:	08 0f       	add	r16, r24
    13ea:	11 1d       	adc	r17, r1
   	switch (IINCHIP_READ(Sn_MR(s)) & 0x07)
    13ec:	c3 01       	movw	r24, r6
    13ee:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    13f2:	90 e0       	ldi	r25, 0x00	; 0
    13f4:	87 70       	andi	r24, 0x07	; 7
    13f6:	90 70       	andi	r25, 0x00	; 0
    13f8:	83 30       	cpi	r24, 0x03	; 3
    13fa:	91 05       	cpc	r25, r1
    13fc:	49 f1       	breq	.+82     	; 0x1450 <recvfrom+0xd2>
    13fe:	84 30       	cpi	r24, 0x04	; 4
    1400:	91 05       	cpc	r25, r1
    1402:	09 f4       	brne	.+2      	; 0x1406 <recvfrom+0x88>
    1404:	40 c0       	rjmp	.+128    	; 0x1486 <recvfrom+0x108>
    1406:	02 97       	sbiw	r24, 0x02	; 2
    1408:	19 f0       	breq	.+6      	; 0x1410 <recvfrom+0x92>
    140a:	ee 24       	eor	r14, r14
    140c:	ff 24       	eor	r15, r15
    140e:	61 c0       	rjmp	.+194    	; 0x14d2 <recvfrom+0x154>
   	{
   	case Sn_MR_UDP :
   			read_data(s, (uint8_t *)ptr, head, 0x08);
    1410:	8d 2d       	mov	r24, r13
    1412:	b8 01       	movw	r22, r16
    1414:	ae 01       	movw	r20, r28
    1416:	4f 5f       	subi	r20, 0xFF	; 255
    1418:	5f 4f       	sbci	r21, 0xFF	; 255
    141a:	28 e0       	ldi	r18, 0x08	; 8
    141c:	30 e0       	ldi	r19, 0x00	; 0
    141e:	0e 94 10 08 	call	0x1020	; 0x1020 <read_data>
   			ptr += 8;
    1422:	08 5f       	subi	r16, 0xF8	; 248
    1424:	1f 4f       	sbci	r17, 0xFF	; 255
   			// read peer's IP address, port number.
    			addr[0] = head[0];
    1426:	89 81       	ldd	r24, Y+1	; 0x01
    1428:	f7 01       	movw	r30, r14
    142a:	80 83       	st	Z, r24
   			addr[1] = head[1];
    142c:	8a 81       	ldd	r24, Y+2	; 0x02
    142e:	81 83       	std	Z+1, r24	; 0x01
   			addr[2] = head[2];
    1430:	8b 81       	ldd	r24, Y+3	; 0x03
    1432:	82 83       	std	Z+2, r24	; 0x02
   			addr[3] = head[3];
    1434:	8c 81       	ldd	r24, Y+4	; 0x04
    1436:	83 83       	std	Z+3, r24	; 0x03
   			*port = head[4];
   			*port = (*port << 8) + head[5];
    1438:	9d 81       	ldd	r25, Y+5	; 0x05
    143a:	80 e0       	ldi	r24, 0x00	; 0
    143c:	2e 81       	ldd	r18, Y+6	; 0x06
    143e:	82 0f       	add	r24, r18
    1440:	91 1d       	adc	r25, r1
    1442:	f1 01       	movw	r30, r2
    1444:	80 83       	st	Z, r24
    1446:	91 83       	std	Z+1, r25	; 0x01
   			data_len = head[6];
   			data_len = (data_len << 8) + head[7];
    1448:	9f 81       	ldd	r25, Y+7	; 0x07
    144a:	80 e0       	ldi	r24, 0x00	; 0
    144c:	28 85       	ldd	r18, Y+8	; 0x08
    144e:	17 c0       	rjmp	.+46     	; 0x147e <recvfrom+0x100>
			IINCHIP_WRITE(Sn_RX_RD0(s),(uint8_t)((ptr & 0xff00) >> 8));
			IINCHIP_WRITE((Sn_RX_RD0(s) + 1),(uint8_t)(ptr & 0x00ff));
   			break;
   
   	case Sn_MR_IPRAW :
   			read_data(s, (uint8_t *)ptr, head, 0x06);
    1450:	8d 2d       	mov	r24, r13
    1452:	b8 01       	movw	r22, r16
    1454:	ae 01       	movw	r20, r28
    1456:	4f 5f       	subi	r20, 0xFF	; 255
    1458:	5f 4f       	sbci	r21, 0xFF	; 255
    145a:	26 e0       	ldi	r18, 0x06	; 6
    145c:	30 e0       	ldi	r19, 0x00	; 0
    145e:	0e 94 10 08 	call	0x1020	; 0x1020 <read_data>
   			ptr += 6;
    1462:	0a 5f       	subi	r16, 0xFA	; 250
    1464:	1f 4f       	sbci	r17, 0xFF	; 255
   
   			addr[0] = head[0];
    1466:	89 81       	ldd	r24, Y+1	; 0x01
    1468:	f7 01       	movw	r30, r14
    146a:	80 83       	st	Z, r24
   			addr[1] = head[1];
    146c:	8a 81       	ldd	r24, Y+2	; 0x02
    146e:	81 83       	std	Z+1, r24	; 0x01
   			addr[2] = head[2];
    1470:	8b 81       	ldd	r24, Y+3	; 0x03
    1472:	82 83       	std	Z+2, r24	; 0x02
   			addr[3] = head[3];
    1474:	8c 81       	ldd	r24, Y+4	; 0x04
    1476:	83 83       	std	Z+3, r24	; 0x03
   			data_len = head[4];
   			data_len = (data_len << 8) + head[5];
    1478:	9d 81       	ldd	r25, Y+5	; 0x05
    147a:	80 e0       	ldi	r24, 0x00	; 0
    147c:	2e 81       	ldd	r18, Y+6	; 0x06
    147e:	7c 01       	movw	r14, r24
    1480:	e2 0e       	add	r14, r18
    1482:	f1 1c       	adc	r15, r1
    1484:	16 c0       	rjmp	.+44     	; 0x14b2 <recvfrom+0x134>
			IINCHIP_WRITE(Sn_RX_RD0(s),(uint8_t)((ptr & 0xff00) >> 8));
			IINCHIP_WRITE((Sn_RX_RD0(s) + 1),(uint8_t)(ptr & 0x00ff));
   			break;

   	case Sn_MR_MACRAW :
   			read_data(s,(uint8_t*)ptr,head,2);
    1486:	8d 2d       	mov	r24, r13
    1488:	b8 01       	movw	r22, r16
    148a:	ae 01       	movw	r20, r28
    148c:	4f 5f       	subi	r20, 0xFF	; 255
    148e:	5f 4f       	sbci	r21, 0xFF	; 255
    1490:	22 e0       	ldi	r18, 0x02	; 2
    1492:	30 e0       	ldi	r19, 0x00	; 0
    1494:	0e 94 10 08 	call	0x1020	; 0x1020 <read_data>
   			ptr+=2;
    1498:	0e 5f       	subi	r16, 0xFE	; 254
    149a:	1f 4f       	sbci	r17, 0xFF	; 255
   			data_len = head[0];
   			data_len = (data_len<<8) + head[1] - 2;
    149c:	99 81       	ldd	r25, Y+1	; 0x01
    149e:	80 e0       	ldi	r24, 0x00	; 0
    14a0:	2a 81       	ldd	r18, Y+2	; 0x02
    14a2:	e2 2e       	mov	r14, r18
    14a4:	ff 24       	eor	r15, r15
    14a6:	2e ef       	ldi	r18, 0xFE	; 254
    14a8:	3f ef       	ldi	r19, 0xFF	; 255
    14aa:	e2 0e       	add	r14, r18
    14ac:	f3 1e       	adc	r15, r19
    14ae:	e8 0e       	add	r14, r24
    14b0:	f9 1e       	adc	r15, r25

   			read_data(s,(uint8_t*) ptr,buf,data_len);
    14b2:	8d 2d       	mov	r24, r13
    14b4:	b8 01       	movw	r22, r16
    14b6:	a2 01       	movw	r20, r4
    14b8:	97 01       	movw	r18, r14
    14ba:	0e 94 10 08 	call	0x1020	; 0x1020 <read_data>
   			ptr += data_len;
    14be:	0e 0d       	add	r16, r14
    14c0:	1f 1d       	adc	r17, r15
   			IINCHIP_WRITE(Sn_RX_RD0(s),(uint8_t)((ptr & 0xff00) >> 8));
    14c2:	c5 01       	movw	r24, r10
    14c4:	61 2f       	mov	r22, r17
    14c6:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
   			IINCHIP_WRITE((Sn_RX_RD0(s) + 1),(uint8_t)(ptr & 0x00ff));
    14ca:	c4 01       	movw	r24, r8
    14cc:	60 2f       	mov	r22, r16
    14ce:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
			break;

   	default :
   			break;
   	}
		IINCHIP_WRITE(Sn_CR(s),Sn_CR_RECV);
    14d2:	83 01       	movw	r16, r6
    14d4:	0f 5f       	subi	r16, 0xFF	; 255
    14d6:	1f 4f       	sbci	r17, 0xFF	; 255
    14d8:	c8 01       	movw	r24, r16
    14da:	60 e4       	ldi	r22, 0x40	; 64
    14dc:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>

		/* +20071122[chungs]:wait to process the command... */
		while( IINCHIP_READ(Sn_CR(s)) ) 
    14e0:	c8 01       	movw	r24, r16
    14e2:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    14e6:	88 23       	and	r24, r24
    14e8:	d9 f7       	brne	.-10     	; 0x14e0 <recvfrom+0x162>
			;
	}
 	return data_len;
}
    14ea:	c7 01       	movw	r24, r14
    14ec:	28 96       	adiw	r28, 0x08	; 8
    14ee:	cd bf       	out	0x3d, r28	; 61
    14f0:	de bf       	out	0x3e, r29	; 62
    14f2:	cf 91       	pop	r28
    14f4:	df 91       	pop	r29
    14f6:	1f 91       	pop	r17
    14f8:	0f 91       	pop	r16
    14fa:	ff 90       	pop	r15
    14fc:	ef 90       	pop	r14
    14fe:	df 90       	pop	r13
    1500:	bf 90       	pop	r11
    1502:	af 90       	pop	r10
    1504:	9f 90       	pop	r9
    1506:	8f 90       	pop	r8
    1508:	7f 90       	pop	r7
    150a:	6f 90       	pop	r6
    150c:	5f 90       	pop	r5
    150e:	4f 90       	pop	r4
    1510:	3f 90       	pop	r3
    1512:	2f 90       	pop	r2
    1514:	08 95       	ret

00001516 <sendto>:
	const uint8_t * buf, 	/**< a pointer to the data */
	uint16_t len, 		/**< the data size to send */
	uint8_t * addr, 		/**< the peer's Destination IP address */
	uint16_t port		/**< the peer's destination port number */
	)
{
    1516:	5f 92       	push	r5
    1518:	6f 92       	push	r6
    151a:	7f 92       	push	r7
    151c:	8f 92       	push	r8
    151e:	9f 92       	push	r9
    1520:	af 92       	push	r10
    1522:	bf 92       	push	r11
    1524:	cf 92       	push	r12
    1526:	df 92       	push	r13
    1528:	ef 92       	push	r14
    152a:	ff 92       	push	r15
    152c:	0f 93       	push	r16
    152e:	1f 93       	push	r17
    1530:	cf 93       	push	r28
    1532:	df 93       	push	r29
    1534:	58 2e       	mov	r5, r24
    1536:	3b 01       	movw	r6, r22
    1538:	e9 01       	movw	r28, r18
    153a:	48 01       	movw	r8, r16
{
   return RSIZE[s];
}
uint16_t getIINCHIP_TxMAX(uint8_t s)
{
   return SSIZE[s];
    153c:	08 2f       	mov	r16, r24
    153e:	10 e0       	ldi	r17, 0x00	; 0
    1540:	f8 01       	movw	r30, r16
    1542:	ee 0f       	add	r30, r30
    1544:	ff 1f       	adc	r31, r31
    1546:	e6 50       	subi	r30, 0x06	; 6
    1548:	ff 4d       	sbci	r31, 0xDF	; 223
    154a:	20 81       	ld	r18, Z
    154c:	31 81       	ldd	r19, Z+1	; 0x01
	
   if (len > getIINCHIP_TxMAX(s)) ret = getIINCHIP_TxMAX(s); // check size not to exceed MAX size.
   else ret = len;

	if
		(
    154e:	68 81       	ld	r22, Y
    1550:	66 23       	and	r22, r22
    1552:	51 f4       	brne	.+20     	; 0x1568 <sendto+0x52>
    1554:	89 81       	ldd	r24, Y+1	; 0x01
    1556:	88 23       	and	r24, r24
    1558:	39 f4       	brne	.+14     	; 0x1568 <sendto+0x52>
    155a:	8a 81       	ldd	r24, Y+2	; 0x02
    155c:	88 23       	and	r24, r24
    155e:	21 f4       	brne	.+8      	; 0x1568 <sendto+0x52>
    1560:	8b 81       	ldd	r24, Y+3	; 0x03
    1562:	88 23       	and	r24, r24
    1564:	09 f4       	brne	.+2      	; 0x1568 <sendto+0x52>
    1566:	5c c0       	rjmp	.+184    	; 0x1620 <sendto+0x10a>
    1568:	81 14       	cp	r8, r1
    156a:	91 04       	cpc	r9, r1
    156c:	09 f4       	brne	.+2      	; 0x1570 <sendto+0x5a>
    156e:	58 c0       	rjmp	.+176    	; 0x1620 <sendto+0x10a>
    1570:	69 01       	movw	r12, r18
    1572:	42 17       	cp	r20, r18
    1574:	53 07       	cpc	r21, r19
    1576:	08 f4       	brcc	.+2      	; 0x157a <sendto+0x64>
    1578:	6a 01       	movw	r12, r20
    157a:	c1 14       	cp	r12, r1
    157c:	d1 04       	cpc	r13, r1
    157e:	09 f4       	brne	.+2      	; 0x1582 <sendto+0x6c>
    1580:	51 c0       	rjmp	.+162    	; 0x1624 <sendto+0x10e>
 	   /* +2008.01 [bj] : added return value */
 	   ret = 0;
	}
	else
	{
		IINCHIP_WRITE(Sn_DIPR0(s),addr[0]);
    1582:	94 e0       	ldi	r25, 0x04	; 4
    1584:	a9 2e       	mov	r10, r25
    1586:	b1 2c       	mov	r11, r1
    1588:	a0 0e       	add	r10, r16
    158a:	b1 1e       	adc	r11, r17
    158c:	fa 2c       	mov	r15, r10
    158e:	ee 24       	eor	r14, r14
    1590:	c7 01       	movw	r24, r14
    1592:	0c 96       	adiw	r24, 0x0c	; 12
    1594:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
		IINCHIP_WRITE((Sn_DIPR0(s) + 1),addr[1]);
    1598:	c7 01       	movw	r24, r14
    159a:	0d 96       	adiw	r24, 0x0d	; 13
    159c:	69 81       	ldd	r22, Y+1	; 0x01
    159e:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
		IINCHIP_WRITE((Sn_DIPR0(s) + 2),addr[2]);
    15a2:	c7 01       	movw	r24, r14
    15a4:	0e 96       	adiw	r24, 0x0e	; 14
    15a6:	6a 81       	ldd	r22, Y+2	; 0x02
    15a8:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
		IINCHIP_WRITE((Sn_DIPR0(s) + 3),addr[3]);
    15ac:	c7 01       	movw	r24, r14
    15ae:	0f 96       	adiw	r24, 0x0f	; 15
    15b0:	6b 81       	ldd	r22, Y+3	; 0x03
    15b2:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DPORT0(s),(uint8_t)((port & 0xff00) >> 8));
    15b6:	87 01       	movw	r16, r14
    15b8:	00 5f       	subi	r16, 0xF0	; 240
    15ba:	1f 4f       	sbci	r17, 0xFF	; 255
    15bc:	c8 01       	movw	r24, r16
    15be:	69 2d       	mov	r22, r9
    15c0:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
		IINCHIP_WRITE((Sn_DPORT0(s) + 1),(uint8_t)(port & 0x00ff));
    15c4:	c8 01       	movw	r24, r16
    15c6:	01 96       	adiw	r24, 0x01	; 1
    15c8:	68 2d       	mov	r22, r8
    15ca:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>

  		// copy data
  		send_data_processing(s, (uint8_t *)buf, ret);
    15ce:	85 2d       	mov	r24, r5
    15d0:	b3 01       	movw	r22, r6
    15d2:	a6 01       	movw	r20, r12
    15d4:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <send_data_processing>
		IINCHIP_WRITE(Sn_CR(s),Sn_CR_SEND);
    15d8:	e7 01       	movw	r28, r14
    15da:	21 96       	adiw	r28, 0x01	; 1
    15dc:	ce 01       	movw	r24, r28
    15de:	60 e2       	ldi	r22, 0x20	; 32
    15e0:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>

		/* +20071122[chungs]:wait to process the command... */
		while( IINCHIP_READ(Sn_CR(s)) ) 
    15e4:	ce 01       	movw	r24, r28
    15e6:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    15ea:	88 23       	and	r24, r24
    15ec:	d9 f7       	brne	.-10     	; 0x15e4 <sendto+0xce>
    15ee:	0a c0       	rjmp	.+20     	; 0x1604 <sendto+0xee>
		/* ------- */
		
/* +2008.01 bj */	
	   while ( (IINCHIP_READ(Sn_IR(s)) & Sn_IR_SEND_OK) != Sn_IR_SEND_OK ) 
		{
	      if (IINCHIP_READ(Sn_IR(s)) & Sn_IR_TIMEOUT)
    15f0:	c8 01       	movw	r24, r16
    15f2:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    15f6:	83 ff       	sbrs	r24, 3
    15f8:	09 c0       	rjmp	.+18     	; 0x160c <sendto+0xf6>
			{
         	IINCHIP_WRITE(Sn_IR(s), (Sn_IR_SEND_OK | Sn_IR_TIMEOUT)); /* clear SEND_OK & TIMEOUT */
    15fa:	c8 01       	movw	r24, r16
    15fc:	68 e1       	ldi	r22, 0x18	; 24
    15fe:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
    1602:	0e c0       	rjmp	.+28     	; 0x1620 <sendto+0x10a>
		while( IINCHIP_READ(Sn_CR(s)) ) 
			;
		/* ------- */
		
/* +2008.01 bj */	
	   while ( (IINCHIP_READ(Sn_IR(s)) & Sn_IR_SEND_OK) != Sn_IR_SEND_OK ) 
    1604:	1a 2d       	mov	r17, r10
    1606:	00 27       	eor	r16, r16
    1608:	0e 5f       	subi	r16, 0xFE	; 254
    160a:	1f 4f       	sbci	r17, 0xFF	; 255
    160c:	c8 01       	movw	r24, r16
    160e:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    1612:	84 ff       	sbrs	r24, 4
    1614:	ed cf       	rjmp	.-38     	; 0x15f0 <sendto+0xda>
			return 0;
			}
		}

/* +2008.01 bj */	
	   IINCHIP_WRITE(Sn_IR(s), Sn_IR_SEND_OK);
    1616:	c8 01       	movw	r24, r16
    1618:	60 e1       	ldi	r22, 0x10	; 16
    161a:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
    161e:	02 c0       	rjmp	.+4      	; 0x1624 <sendto+0x10e>
    1620:	cc 24       	eor	r12, r12
    1622:	dd 24       	eor	r13, r13

	}
	return ret;
}
    1624:	c6 01       	movw	r24, r12
    1626:	df 91       	pop	r29
    1628:	cf 91       	pop	r28
    162a:	1f 91       	pop	r17
    162c:	0f 91       	pop	r16
    162e:	ff 90       	pop	r15
    1630:	ef 90       	pop	r14
    1632:	df 90       	pop	r13
    1634:	cf 90       	pop	r12
    1636:	bf 90       	pop	r11
    1638:	af 90       	pop	r10
    163a:	9f 90       	pop	r9
    163c:	8f 90       	pop	r8
    163e:	7f 90       	pop	r7
    1640:	6f 90       	pop	r6
    1642:	5f 90       	pop	r5
    1644:	08 95       	ret

00001646 <recv>:
uint16_t recv(
	SOCKET s, 	/**< socket index */
	uint8_t * buf, 	/**< a pointer to copy the data to be received */
	uint16_t len	/**< the data size to be read */
	)
{
    1646:	ff 92       	push	r15
    1648:	0f 93       	push	r16
    164a:	1f 93       	push	r17
    164c:	cf 93       	push	r28
    164e:	df 93       	push	r29
    1650:	f8 2e       	mov	r15, r24
    1652:	8a 01       	movw	r16, r20
	uint16_t ret=0;


	if ( len > 0 )
    1654:	41 15       	cp	r20, r1
    1656:	51 05       	cpc	r21, r1
    1658:	19 f4       	brne	.+6      	; 0x1660 <recv+0x1a>
    165a:	40 e0       	ldi	r20, 0x00	; 0
    165c:	50 e0       	ldi	r21, 0x00	; 0
    165e:	10 c0       	rjmp	.+32     	; 0x1680 <recv+0x3a>
	{
		recv_data_processing(s, buf, len);
    1660:	0e 94 35 09 	call	0x126a	; 0x126a <recv_data_processing>
		IINCHIP_WRITE(Sn_CR(s),Sn_CR_RECV);
    1664:	df 2d       	mov	r29, r15
    1666:	c0 e0       	ldi	r28, 0x00	; 0
    1668:	cf 5f       	subi	r28, 0xFF	; 255
    166a:	db 4f       	sbci	r29, 0xFB	; 251
    166c:	ce 01       	movw	r24, r28
    166e:	60 e4       	ldi	r22, 0x40	; 64
    1670:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>

		/* +20071122[chungs]:wait to process the command... */
		while( IINCHIP_READ(Sn_CR(s)) ) 
    1674:	ce 01       	movw	r24, r28
    1676:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    167a:	88 23       	and	r24, r24
    167c:	d9 f7       	brne	.-10     	; 0x1674 <recv+0x2e>
    167e:	a8 01       	movw	r20, r16
			;
		ret = len;
	}
	return ret;
}
    1680:	ca 01       	movw	r24, r20
    1682:	df 91       	pop	r29
    1684:	cf 91       	pop	r28
    1686:	1f 91       	pop	r17
    1688:	0f 91       	pop	r16
    168a:	ff 90       	pop	r15
    168c:	08 95       	ret

0000168e <disconnect>:
/**
@brief	This function used for disconnect the socket and parameter is "s" which represent the socket number
@return	1 for success else 0.
*/ 
void disconnect(SOCKET s)
{
    168e:	cf 93       	push	r28
    1690:	df 93       	push	r29
	IINCHIP_WRITE(Sn_CR(s),Sn_CR_DISCON);
    1692:	90 e0       	ldi	r25, 0x00	; 0
    1694:	d8 2f       	mov	r29, r24
    1696:	cc 27       	eor	r28, r28
    1698:	cf 5f       	subi	r28, 0xFF	; 255
    169a:	db 4f       	sbci	r29, 0xFB	; 251
    169c:	ce 01       	movw	r24, r28
    169e:	68 e0       	ldi	r22, 0x08	; 8
    16a0:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>

	/* +20071122[chungs]:wait to process the command... */
	while( IINCHIP_READ(Sn_CR(s)) ) 
    16a4:	ce 01       	movw	r24, r28
    16a6:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    16aa:	88 23       	and	r24, r24
    16ac:	d9 f7       	brne	.-10     	; 0x16a4 <disconnect+0x16>
		;
}
    16ae:	df 91       	pop	r29
    16b0:	cf 91       	pop	r28
    16b2:	08 95       	ret

000016b4 <connect>:
		This function waits for the untill the connection is established.
		
@return	1 for success else 0.
*/ 
uint8_t connect(SOCKET s, uint8_t * addr, uint16_t port)
{
    16b4:	cf 92       	push	r12
    16b6:	df 92       	push	r13
    16b8:	ef 92       	push	r14
    16ba:	ff 92       	push	r15
    16bc:	0f 93       	push	r16
    16be:	1f 93       	push	r17
    16c0:	cf 93       	push	r28
    16c2:	df 93       	push	r29
    16c4:	08 2f       	mov	r16, r24
    16c6:	eb 01       	movw	r28, r22
    16c8:	6a 01       	movw	r12, r20
	uint8_t ret;
	if 
		(
    16ca:	68 81       	ld	r22, Y
    16cc:	6f 3f       	cpi	r22, 0xFF	; 255
    16ce:	51 f4       	brne	.+20     	; 0x16e4 <connect+0x30>
    16d0:	89 81       	ldd	r24, Y+1	; 0x01
    16d2:	8f 3f       	cpi	r24, 0xFF	; 255
    16d4:	91 f4       	brne	.+36     	; 0x16fa <connect+0x46>
    16d6:	8a 81       	ldd	r24, Y+2	; 0x02
    16d8:	8f 3f       	cpi	r24, 0xFF	; 255
    16da:	79 f4       	brne	.+30     	; 0x16fa <connect+0x46>
    16dc:	8b 81       	ldd	r24, Y+3	; 0x03
    16de:	8f 3f       	cpi	r24, 0xFF	; 255
    16e0:	61 f4       	brne	.+24     	; 0x16fa <connect+0x46>
    16e2:	3f c0       	rjmp	.+126    	; 0x1762 <connect+0xae>
    16e4:	66 23       	and	r22, r22
    16e6:	49 f4       	brne	.+18     	; 0x16fa <connect+0x46>
    16e8:	89 81       	ldd	r24, Y+1	; 0x01
    16ea:	88 23       	and	r24, r24
    16ec:	31 f4       	brne	.+12     	; 0x16fa <connect+0x46>
    16ee:	8a 81       	ldd	r24, Y+2	; 0x02
    16f0:	88 23       	and	r24, r24
    16f2:	19 f4       	brne	.+6      	; 0x16fa <connect+0x46>
    16f4:	8b 81       	ldd	r24, Y+3	; 0x03
    16f6:	88 23       	and	r24, r24
    16f8:	a1 f1       	breq	.+104    	; 0x1762 <connect+0xae>
    16fa:	c1 14       	cp	r12, r1
    16fc:	d1 04       	cpc	r13, r1
    16fe:	89 f1       	breq	.+98     	; 0x1762 <connect+0xae>
	}
	else
	{
		ret = 1;
		// set destination IP
		IINCHIP_WRITE(Sn_DIPR0(s),addr[0]);
    1700:	10 e0       	ldi	r17, 0x00	; 0
    1702:	0c 5f       	subi	r16, 0xFC	; 252
    1704:	1f 4f       	sbci	r17, 0xFF	; 255
    1706:	f0 2e       	mov	r15, r16
    1708:	ee 24       	eor	r14, r14
    170a:	c7 01       	movw	r24, r14
    170c:	0c 96       	adiw	r24, 0x0c	; 12
    170e:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
		IINCHIP_WRITE((Sn_DIPR0(s) + 1),addr[1]);
    1712:	c7 01       	movw	r24, r14
    1714:	0d 96       	adiw	r24, 0x0d	; 13
    1716:	69 81       	ldd	r22, Y+1	; 0x01
    1718:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
		IINCHIP_WRITE((Sn_DIPR0(s) + 2),addr[2]);
    171c:	c7 01       	movw	r24, r14
    171e:	0e 96       	adiw	r24, 0x0e	; 14
    1720:	6a 81       	ldd	r22, Y+2	; 0x02
    1722:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
		IINCHIP_WRITE((Sn_DIPR0(s) + 3),addr[3]);
    1726:	c7 01       	movw	r24, r14
    1728:	0f 96       	adiw	r24, 0x0f	; 15
    172a:	6b 81       	ldd	r22, Y+3	; 0x03
    172c:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DPORT0(s),(uint8_t)((port & 0xff00) >> 8));
    1730:	87 01       	movw	r16, r14
    1732:	00 5f       	subi	r16, 0xF0	; 240
    1734:	1f 4f       	sbci	r17, 0xFF	; 255
    1736:	c8 01       	movw	r24, r16
    1738:	6d 2d       	mov	r22, r13
    173a:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
		IINCHIP_WRITE((Sn_DPORT0(s) + 1),(uint8_t)(port & 0x00ff));
    173e:	c8 01       	movw	r24, r16
    1740:	01 96       	adiw	r24, 0x01	; 1
    1742:	6c 2d       	mov	r22, r12
    1744:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_CR(s),Sn_CR_CONNECT);
    1748:	e7 01       	movw	r28, r14
    174a:	21 96       	adiw	r28, 0x01	; 1
    174c:	ce 01       	movw	r24, r28
    174e:	64 e0       	ldi	r22, 0x04	; 4
    1750:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
      /* m2008.01 [bj] :  wait for completion */
		while ( IINCHIP_READ(Sn_CR(s)) ) ;
    1754:	ce 01       	movw	r24, r28
    1756:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    175a:	88 23       	and	r24, r24
    175c:	d9 f7       	brne	.-10     	; 0x1754 <connect+0xa0>
    175e:	81 e0       	ldi	r24, 0x01	; 1
    1760:	01 c0       	rjmp	.+2      	; 0x1764 <connect+0xb0>
    1762:	80 e0       	ldi	r24, 0x00	; 0

	}

	return ret;
}
    1764:	df 91       	pop	r29
    1766:	cf 91       	pop	r28
    1768:	1f 91       	pop	r17
    176a:	0f 91       	pop	r16
    176c:	ff 90       	pop	r15
    176e:	ef 90       	pop	r14
    1770:	df 90       	pop	r13
    1772:	cf 90       	pop	r12
    1774:	08 95       	ret

00001776 <listen>:
@return	1 for success else 0.
*/ 
uint8_t listen(
	SOCKET s	/**< the socket number */
	)
{
    1776:	cf 93       	push	r28
    1778:	df 93       	push	r29
	uint8_t ret;
	if (IINCHIP_READ(Sn_SR(s)) == SOCK_INIT)
    177a:	90 e0       	ldi	r25, 0x00	; 0
    177c:	04 96       	adiw	r24, 0x04	; 4
    177e:	d8 2f       	mov	r29, r24
    1780:	cc 27       	eor	r28, r28
    1782:	ce 01       	movw	r24, r28
    1784:	03 96       	adiw	r24, 0x03	; 3
    1786:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    178a:	83 31       	cpi	r24, 0x13	; 19
    178c:	11 f0       	breq	.+4      	; 0x1792 <listen+0x1c>
    178e:	80 e0       	ldi	r24, 0x00	; 0
    1790:	0b c0       	rjmp	.+22     	; 0x17a8 <listen+0x32>
	{
		IINCHIP_WRITE(Sn_CR(s),Sn_CR_LISTEN);
    1792:	21 96       	adiw	r28, 0x01	; 1
    1794:	ce 01       	movw	r24, r28
    1796:	62 e0       	ldi	r22, 0x02	; 2
    1798:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
		/* +20071122[chungs]:wait to process the command... */
		while( IINCHIP_READ(Sn_CR(s)) ) 
    179c:	ce 01       	movw	r24, r28
    179e:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    17a2:	88 23       	and	r24, r24
    17a4:	d9 f7       	brne	.-10     	; 0x179c <listen+0x26>
    17a6:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		ret = 0;
	}
	return ret;
}
    17a8:	df 91       	pop	r29
    17aa:	cf 91       	pop	r28
    17ac:	08 95       	ret

000017ae <close>:

/**
@brief	This function close the socket and parameter is "s" which represent the socket number
*/ 
void close(SOCKET s)
{
    17ae:	0f 93       	push	r16
    17b0:	1f 93       	push	r17
    17b2:	cf 93       	push	r28
    17b4:	df 93       	push	r29
	
	IINCHIP_WRITE(Sn_CR(s),Sn_CR_CLOSE);
    17b6:	08 2f       	mov	r16, r24
    17b8:	10 e0       	ldi	r17, 0x00	; 0
    17ba:	0c 5f       	subi	r16, 0xFC	; 252
    17bc:	1f 4f       	sbci	r17, 0xFF	; 255
    17be:	d0 2f       	mov	r29, r16
    17c0:	cc 27       	eor	r28, r28
    17c2:	21 96       	adiw	r28, 0x01	; 1
    17c4:	ce 01       	movw	r24, r28
    17c6:	60 e1       	ldi	r22, 0x10	; 16
    17c8:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>

	/* +20071122[chungs]:wait to process the command... */
	while( IINCHIP_READ(Sn_CR(s)) ) 
    17cc:	ce 01       	movw	r24, r28
    17ce:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    17d2:	88 23       	and	r24, r24
    17d4:	d9 f7       	brne	.-10     	; 0x17cc <close+0x1e>
		;

	IINCHIP_WRITE(Sn_IR(s), 0xFF);
    17d6:	90 2f       	mov	r25, r16
    17d8:	88 27       	eor	r24, r24
    17da:	02 96       	adiw	r24, 0x02	; 2
    17dc:	6f ef       	ldi	r22, 0xFF	; 255
    17de:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
}
    17e2:	df 91       	pop	r29
    17e4:	cf 91       	pop	r28
    17e6:	1f 91       	pop	r17
    17e8:	0f 91       	pop	r16
    17ea:	08 95       	ret

000017ec <send>:
uint16_t send(
	SOCKET s, 		/**< the socket index */
	const uint8_t * buf, 	/**< a pointer to data */
	uint16_t len		/**< the data size to be send */
	)
{
    17ec:	6f 92       	push	r6
    17ee:	7f 92       	push	r7
    17f0:	8f 92       	push	r8
    17f2:	9f 92       	push	r9
    17f4:	af 92       	push	r10
    17f6:	bf 92       	push	r11
    17f8:	df 92       	push	r13
    17fa:	ef 92       	push	r14
    17fc:	ff 92       	push	r15
    17fe:	0f 93       	push	r16
    1800:	1f 93       	push	r17
    1802:	cf 93       	push	r28
    1804:	df 93       	push	r29
    1806:	d8 2e       	mov	r13, r24
    1808:	3b 01       	movw	r6, r22
{
   return RSIZE[s];
}
uint16_t getIINCHIP_TxMAX(uint8_t s)
{
   return SSIZE[s];
    180a:	90 e0       	ldi	r25, 0x00	; 0
    180c:	fc 01       	movw	r30, r24
    180e:	ee 0f       	add	r30, r30
    1810:	ff 1f       	adc	r31, r31
    1812:	e6 50       	subi	r30, 0x06	; 6
    1814:	ff 4d       	sbci	r31, 0xDF	; 223
    1816:	00 81       	ld	r16, Z
    1818:	11 81       	ldd	r17, Z+1	; 0x01
    181a:	40 17       	cp	r20, r16
    181c:	51 07       	cpc	r21, r17
    181e:	08 f4       	brcc	.+2      	; 0x1822 <send+0x36>
    1820:	8a 01       	movw	r16, r20

   // if freebuf is available, start.
	do 
	{
		freesize = getSn_TX_FSR(s);
		status = IINCHIP_READ(Sn_SR(s));
    1822:	b4 e0       	ldi	r27, 0x04	; 4
    1824:	ab 2e       	mov	r10, r27
    1826:	b1 2c       	mov	r11, r1
    1828:	a8 0e       	add	r10, r24
    182a:	b9 1e       	adc	r11, r25
    182c:	fa 2c       	mov	r15, r10
    182e:	ee 24       	eor	r14, r14
    1830:	f3 e0       	ldi	r31, 0x03	; 3
    1832:	8f 2e       	mov	r8, r31
    1834:	91 2c       	mov	r9, r1
    1836:	8e 0c       	add	r8, r14
    1838:	9f 1c       	adc	r9, r15
   else ret = len;

   // if freebuf is available, start.
	do 
	{
		freesize = getSn_TX_FSR(s);
    183a:	8d 2d       	mov	r24, r13
    183c:	0e 94 7d 08 	call	0x10fa	; 0x10fa <getSn_TX_FSR>
    1840:	ec 01       	movw	r28, r24
		status = IINCHIP_READ(Sn_SR(s));
    1842:	c4 01       	movw	r24, r8
    1844:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
		if ((status != SOCK_ESTABLISHED) && (status != SOCK_CLOSE_WAIT))
    1848:	87 31       	cpi	r24, 0x17	; 23
    184a:	29 f0       	breq	.+10     	; 0x1856 <send+0x6a>
    184c:	8c 31       	cpi	r24, 0x1C	; 28
    184e:	19 f0       	breq	.+6      	; 0x1856 <send+0x6a>
    1850:	00 e0       	ldi	r16, 0x00	; 0
    1852:	10 e0       	ldi	r17, 0x00	; 0
    1854:	03 c0       	rjmp	.+6      	; 0x185c <send+0x70>
		{
			ret = 0; 
			break;
		}
	} while (freesize < ret);
    1856:	c0 17       	cp	r28, r16
    1858:	d1 07       	cpc	r29, r17
    185a:	78 f3       	brcs	.-34     	; 0x183a <send+0x4e>

      // copy data
	send_data_processing(s, (uint8_t *)buf, ret);
    185c:	8d 2d       	mov	r24, r13
    185e:	b3 01       	movw	r22, r6
    1860:	a8 01       	movw	r20, r16
    1862:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <send_data_processing>
	IINCHIP_WRITE(Sn_CR(s),Sn_CR_SEND);
    1866:	e7 01       	movw	r28, r14
    1868:	21 96       	adiw	r28, 0x01	; 1
    186a:	ce 01       	movw	r24, r28
    186c:	60 e2       	ldi	r22, 0x20	; 32
    186e:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>

	/* +20071122[chungs]:wait to process the command... */
	while( IINCHIP_READ(Sn_CR(s)) ) 
    1872:	ce 01       	movw	r24, r28
    1874:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    1878:	88 23       	and	r24, r24
    187a:	d9 f7       	brne	.-10     	; 0x1872 <send+0x86>
    187c:	0b c0       	rjmp	.+22     	; 0x1894 <send+0xa8>
	/* ------- */

	while ( (IINCHIP_READ(Sn_IR(s)) & Sn_IR_SEND_OK) != Sn_IR_SEND_OK ) 
	{
		/* m2008.01 [bj] : reduce code */
		if ( IINCHIP_READ(Sn_SR(s)) == SOCK_CLOSED )
    187e:	c4 01       	movw	r24, r8
    1880:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    1884:	88 23       	and	r24, r24
    1886:	49 f4       	brne	.+18     	; 0x189a <send+0xae>
		{
			close(s);
    1888:	8d 2d       	mov	r24, r13
    188a:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <close>
    188e:	00 e0       	ldi	r16, 0x00	; 0
    1890:	10 e0       	ldi	r17, 0x00	; 0
    1892:	0c c0       	rjmp	.+24     	; 0x18ac <send+0xc0>
	/* +20071122[chungs]:wait to process the command... */
	while( IINCHIP_READ(Sn_CR(s)) ) 
		;
	/* ------- */

	while ( (IINCHIP_READ(Sn_IR(s)) & Sn_IR_SEND_OK) != Sn_IR_SEND_OK ) 
    1894:	da 2d       	mov	r29, r10
    1896:	cc 27       	eor	r28, r28
    1898:	22 96       	adiw	r28, 0x02	; 2
    189a:	ce 01       	movw	r24, r28
    189c:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    18a0:	84 ff       	sbrs	r24, 4
    18a2:	ed cf       	rjmp	.-38     	; 0x187e <send+0x92>
		{
			close(s);
			return 0;
		}
  	}
	IINCHIP_WRITE(Sn_IR(s), Sn_IR_SEND_OK);
    18a4:	ce 01       	movw	r24, r28
    18a6:	60 e1       	ldi	r22, 0x10	; 16
    18a8:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
  	return ret;
}
    18ac:	c8 01       	movw	r24, r16
    18ae:	df 91       	pop	r29
    18b0:	cf 91       	pop	r28
    18b2:	1f 91       	pop	r17
    18b4:	0f 91       	pop	r16
    18b6:	ff 90       	pop	r15
    18b8:	ef 90       	pop	r14
    18ba:	df 90       	pop	r13
    18bc:	bf 90       	pop	r11
    18be:	af 90       	pop	r10
    18c0:	9f 90       	pop	r9
    18c2:	8f 90       	pop	r8
    18c4:	7f 90       	pop	r7
    18c6:	6f 90       	pop	r6
    18c8:	08 95       	ret

000018ca <socket>:
	SOCKET s, 		/**< for socket number */
	uint8_t protocol, 	/**< for socket protocol */
	uint16_t port, 		/**< the source port for the socket */
	uint8_t flag		/**< the option for the socket */
	)
{
    18ca:	cf 92       	push	r12
    18cc:	df 92       	push	r13
    18ce:	ef 92       	push	r14
    18d0:	ff 92       	push	r15
    18d2:	0f 93       	push	r16
    18d4:	1f 93       	push	r17
    18d6:	cf 93       	push	r28
    18d8:	df 93       	push	r29
    18da:	08 2f       	mov	r16, r24
    18dc:	e6 2e       	mov	r14, r22
    18de:	ea 01       	movw	r28, r20
    18e0:	f2 2e       	mov	r15, r18
	uint8_t ret;
	if ((protocol == Sn_MR_TCP) || (protocol == Sn_MR_UDP) || (protocol == Sn_MR_IPRAW) || (protocol == Sn_MR_MACRAW) || (protocol == Sn_MR_PPPOE))
    18e2:	86 2f       	mov	r24, r22
    18e4:	81 50       	subi	r24, 0x01	; 1
    18e6:	85 30       	cpi	r24, 0x05	; 5
    18e8:	10 f0       	brcs	.+4      	; 0x18ee <socket+0x24>
    18ea:	80 e0       	ldi	r24, 0x00	; 0
    18ec:	49 c0       	rjmp	.+146    	; 0x1980 <socket+0xb6>
	{
		close(s);
    18ee:	80 2f       	mov	r24, r16
    18f0:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <close>
		IINCHIP_WRITE(Sn_MR(s),protocol | flag);
    18f4:	10 e0       	ldi	r17, 0x00	; 0
    18f6:	0c 5f       	subi	r16, 0xFC	; 252
    18f8:	1f 4f       	sbci	r17, 0xFF	; 255
    18fa:	d0 2e       	mov	r13, r16
    18fc:	cc 24       	eor	r12, r12
    18fe:	fe 28       	or	r15, r14
    1900:	c6 01       	movw	r24, r12
    1902:	6f 2d       	mov	r22, r15
    1904:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
    1908:	26 e0       	ldi	r18, 0x06	; 6
    190a:	00 0f       	add	r16, r16
    190c:	11 1f       	adc	r17, r17
    190e:	2a 95       	dec	r18
    1910:	e1 f7       	brne	.-8      	; 0x190a <socket+0x40>
		if (port != 0) {
    1912:	20 97       	sbiw	r28, 0x00	; 0
    1914:	71 f0       	breq	.+28     	; 0x1932 <socket+0x68>
			IINCHIP_WRITE(Sn_PORT0(s),(uint8_t)((port & 0xff00) >> 8));
    1916:	0f 5f       	subi	r16, 0xFF	; 255
    1918:	1f 4f       	sbci	r17, 0xFF	; 255
    191a:	00 0f       	add	r16, r16
    191c:	11 1f       	adc	r17, r17
    191e:	00 0f       	add	r16, r16
    1920:	11 1f       	adc	r17, r17
    1922:	c8 01       	movw	r24, r16
    1924:	6d 2f       	mov	r22, r29
    1926:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
			IINCHIP_WRITE((Sn_PORT0(s) + 1),(uint8_t)(port & 0x00ff));
    192a:	c8 01       	movw	r24, r16
    192c:	01 96       	adiw	r24, 0x01	; 1
    192e:	6c 2f       	mov	r22, r28
    1930:	18 c0       	rjmp	.+48     	; 0x1962 <socket+0x98>
		} else {
			local_port++; // if don't set the source port, set local_port number.
    1932:	20 91 e8 20 	lds	r18, 0x20E8
    1936:	30 91 e9 20 	lds	r19, 0x20E9
    193a:	2f 5f       	subi	r18, 0xFF	; 255
    193c:	3f 4f       	sbci	r19, 0xFF	; 255
    193e:	20 93 e8 20 	sts	0x20E8, r18
    1942:	30 93 e9 20 	sts	0x20E9, r19
			IINCHIP_WRITE(Sn_PORT0(s),(uint8_t)((local_port & 0xff00) >> 8));
    1946:	0f 5f       	subi	r16, 0xFF	; 255
    1948:	1f 4f       	sbci	r17, 0xFF	; 255
    194a:	00 0f       	add	r16, r16
    194c:	11 1f       	adc	r17, r17
    194e:	00 0f       	add	r16, r16
    1950:	11 1f       	adc	r17, r17
    1952:	c8 01       	movw	r24, r16
    1954:	63 2f       	mov	r22, r19
    1956:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
			IINCHIP_WRITE((Sn_PORT0(s) + 1),(uint8_t)(local_port & 0x00ff));
    195a:	c8 01       	movw	r24, r16
    195c:	01 96       	adiw	r24, 0x01	; 1
    195e:	60 91 e8 20 	lds	r22, 0x20E8
    1962:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>
		}
		IINCHIP_WRITE(Sn_CR(s),Sn_CR_OPEN); // run sockinit Sn_CR
    1966:	86 01       	movw	r16, r12
    1968:	0f 5f       	subi	r16, 0xFF	; 255
    196a:	1f 4f       	sbci	r17, 0xFF	; 255
    196c:	c8 01       	movw	r24, r16
    196e:	61 e0       	ldi	r22, 0x01	; 1
    1970:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <IINCHIP_WRITE>

		/* +20071122[chungs]:wait to process the command... */
		while( IINCHIP_READ(Sn_CR(s)) ) 
    1974:	c8 01       	movw	r24, r16
    1976:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
    197a:	88 23       	and	r24, r24
    197c:	d9 f7       	brne	.-10     	; 0x1974 <socket+0xaa>
    197e:	81 e0       	ldi	r24, 0x01	; 1
	{
		ret = 0;
	}
	//printf("Sn_SR = %.2x , Protocol = %.2x\r\n", IINCHIP_READ(Sn_SR(s)), IINCHIP_READ(Sn_MR(s)));
	return ret;
}
    1980:	df 91       	pop	r29
    1982:	cf 91       	pop	r28
    1984:	1f 91       	pop	r17
    1986:	0f 91       	pop	r16
    1988:	ff 90       	pop	r15
    198a:	ef 90       	pop	r14
    198c:	df 90       	pop	r13
    198e:	cf 90       	pop	r12
    1990:	08 95       	ret

00001992 <getSn_IR>:

These below functions are used to read the Interrupt & Soket Status register
*/
uint8_t getSn_IR(SOCKET s)
{
   return IINCHIP_READ(Sn_IR(s));
    1992:	90 e0       	ldi	r25, 0x00	; 0
    1994:	98 2f       	mov	r25, r24
    1996:	88 27       	eor	r24, r24
    1998:	8e 5f       	subi	r24, 0xFE	; 254
    199a:	9b 4f       	sbci	r25, 0xFB	; 251
    199c:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
}
    19a0:	08 95       	ret

000019a2 <getIR>:
/**
@brief	This function gets Interrupt register in common register.
 */
uint8_t getIR( void )
{
   return IINCHIP_READ(IR);
    19a2:	85 e1       	ldi	r24, 0x15	; 21
    19a4:	90 e0       	ldi	r25, 0x00	; 0
    19a6:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <IINCHIP_READ>
}
    19aa:	08 95       	ret

000019ac <WDT_Enable>:
 *  wait for the watchdog to be synchronized to the other clock domains. before
 *  proceeding
 */
void WDT_Enable( void )
{
	uint8_t temp = WDT.CTRL | WDT_ENABLE_bm | WDT_CEN_bm;
    19ac:	80 91 80 00 	lds	r24, 0x0080
    19b0:	83 60       	ori	r24, 0x03	; 3
	CCP = CCP_IOREG_gc;
    19b2:	98 ed       	ldi	r25, 0xD8	; 216
    19b4:	94 bf       	out	0x34, r25	; 52
	WDT.CTRL = temp;
    19b6:	80 93 80 00 	sts	0x0080, r24

	/* Wait for WD to synchronize with new settings. */
	while(WDT_IsSyncBusy()){
    19ba:	80 91 82 00 	lds	r24, 0x0082
    19be:	80 fd       	sbrc	r24, 0
    19c0:	fc cf       	rjmp	.-8      	; 0x19ba <WDT_Enable+0xe>

	}
}
    19c2:	08 95       	ret

000019c4 <WDT_EnableAndSetTimeout>:
 *
 *  \param  period  Watchdog Timer timeout period
 */
void WDT_EnableAndSetTimeout( WDT_PER_t period )
{
	uint8_t temp = WDT_ENABLE_bm | WDT_CEN_bm | period;
    19c4:	83 60       	ori	r24, 0x03	; 3
	CCP = CCP_IOREG_gc;
    19c6:	98 ed       	ldi	r25, 0xD8	; 216
    19c8:	94 bf       	out	0x34, r25	; 52
	WDT.CTRL = temp;
    19ca:	80 93 80 00 	sts	0x0080, r24

	/* Wait for WD to synchronize with new settings. */
	while(WDT_IsSyncBusy()){
    19ce:	80 91 82 00 	lds	r24, 0x0082
    19d2:	80 fd       	sbrc	r24, 0
    19d4:	fc cf       	rjmp	.-8      	; 0x19ce <WDT_EnableAndSetTimeout+0xa>

	}
}
    19d6:	08 95       	ret

000019d8 <WDT_Disable>:
 *  automatically ignored during the change enable period. Disable functions
 *  operate asynchronously with immidiate effect.
 */
void WDT_Disable( void )
{
	uint8_t temp = (WDT.CTRL & ~WDT_ENABLE_bm) | WDT_CEN_bm;
    19d8:	e0 e8       	ldi	r30, 0x80	; 128
    19da:	f0 e0       	ldi	r31, 0x00	; 0
    19dc:	80 81       	ld	r24, Z
    19de:	8c 7f       	andi	r24, 0xFC	; 252
    19e0:	81 60       	ori	r24, 0x01	; 1
	CCP = CCP_IOREG_gc;
    19e2:	98 ed       	ldi	r25, 0xD8	; 216
    19e4:	94 bf       	out	0x34, r25	; 52
	WDT.CTRL = temp;
    19e6:	80 83       	st	Z, r24
}
    19e8:	08 95       	ret

000019ea <WDT_IsWindowModeEnabled>:
 *  \retval  true   The WD Window Mode is enabled.
 *  \retval  false  The WD Eindow Mode is not enabled.
 */
bool WDT_IsWindowModeEnabled( void )
{
	uint8_t wdwm_enabled = (WDT.WINCTRL & WDT_WEN_bm);
    19ea:	e0 e8       	ldi	r30, 0x80	; 128
    19ec:	f0 e0       	ldi	r31, 0x00	; 0
    19ee:	81 81       	ldd	r24, Z+1	; 0x01
    19f0:	86 95       	lsr	r24
	return wdwm_enabled;
}
    19f2:	81 70       	andi	r24, 0x01	; 1
    19f4:	08 95       	ret

000019f6 <WDT_EnableWindowMode>:
 *  \retval  true   The WD is enabled before enabling window mode
 *  \retval  false  The WD is not enabled before enabling window mode.
 */
bool WDT_EnableWindowMode( void )
{
	uint8_t wd_enable = WDT.CTRL & WDT_ENABLE_bm;
    19f6:	20 91 80 00 	lds	r18, 0x0080
	uint8_t temp = WDT.WINCTRL | WDT_WEN_bm | WDT_WCEN_bm;
    19fa:	90 91 81 00 	lds	r25, 0x0081
    19fe:	93 60       	ori	r25, 0x03	; 3
	CCP = CCP_IOREG_gc;
    1a00:	88 ed       	ldi	r24, 0xD8	; 216
    1a02:	84 bf       	out	0x34, r24	; 52
	WDT.WINCTRL = temp;
    1a04:	e0 e8       	ldi	r30, 0x80	; 128
    1a06:	f0 e0       	ldi	r31, 0x00	; 0
    1a08:	91 83       	std	Z+1, r25	; 0x01
        
	/* Wait for WD to synchronize with new settings. */
	while(WDT_IsSyncBusy()){
    1a0a:	80 91 82 00 	lds	r24, 0x0082
    1a0e:	80 fd       	sbrc	r24, 0
    1a10:	fc cf       	rjmp	.-8      	; 0x1a0a <WDT_EnableWindowMode+0x14>
    1a12:	26 95       	lsr	r18

	}
        
	return wd_enable;
}
    1a14:	82 2f       	mov	r24, r18
    1a16:	81 70       	andi	r24, 0x01	; 1
    1a18:	08 95       	ret

00001a1a <WDT_EnableWindowModeAndSetTimeout>:
 *  \retval  true   The WD is enabled before enabling window mode
 *  \retval  false  The WD is not enabled before enabling window mode.
 */
bool WDT_EnableWindowModeAndSetTimeout( WDT_WPER_t period )
{
	uint8_t wd_enable = WDT.CTRL & WDT_ENABLE_bm;
    1a1a:	20 91 80 00 	lds	r18, 0x0080
	uint8_t temp = WDT_WEN_bm | WDT_WCEN_bm | period;
    1a1e:	83 60       	ori	r24, 0x03	; 3
	CCP = CCP_IOREG_gc;
    1a20:	98 ed       	ldi	r25, 0xD8	; 216
    1a22:	94 bf       	out	0x34, r25	; 52
	WDT.WINCTRL = temp;
    1a24:	e0 e8       	ldi	r30, 0x80	; 128
    1a26:	f0 e0       	ldi	r31, 0x00	; 0
    1a28:	81 83       	std	Z+1, r24	; 0x01
        
	/* Wait for WD to synchronize with new settings. */
	while(WDT_IsSyncBusy()){
    1a2a:	80 91 82 00 	lds	r24, 0x0082
    1a2e:	80 fd       	sbrc	r24, 0
    1a30:	fc cf       	rjmp	.-8      	; 0x1a2a <WDT_EnableWindowModeAndSetTimeout+0x10>
    1a32:	26 95       	lsr	r18

	}
        
	return wd_enable;
}
    1a34:	82 2f       	mov	r24, r18
    1a36:	81 70       	andi	r24, 0x01	; 1
    1a38:	08 95       	ret

00001a3a <WDT_DisableWindowMode>:
 *  automatically ignored during the change enable period. Disable functions
 *  operate asynchronously with immidiate effect.
 */
void WDT_DisableWindowMode( void )
{
	uint8_t temp = (WDT.WINCTRL & ~WDT_WEN_bm) | WDT_WCEN_bm;
    1a3a:	e0 e8       	ldi	r30, 0x80	; 128
    1a3c:	f0 e0       	ldi	r31, 0x00	; 0
    1a3e:	81 81       	ldd	r24, Z+1	; 0x01
    1a40:	8c 7f       	andi	r24, 0xFC	; 252
    1a42:	81 60       	ori	r24, 0x01	; 1
	CCP = CCP_IOREG_gc;
    1a44:	98 ed       	ldi	r25, 0xD8	; 216
    1a46:	94 bf       	out	0x34, r25	; 52
	WDT.WINCTRL = temp;
    1a48:	81 83       	std	Z+1, r24	; 0x01
}
    1a4a:	08 95       	ret

00001a4c <PORT_ConfigureInterrupt0>:
 *  \param pinMask    A mask that selects the pins to associate with port interrupt 0.
 */
void PORT_ConfigureInterrupt0( PORT_t * port,
                               PORT_INT0LVL_t intLevel,
                               uint8_t pinMask )
{
    1a4c:	fc 01       	movw	r30, r24
	port->INTCTRL = ( port->INTCTRL & ~PORT_INT0LVL_gm ) | intLevel;
    1a4e:	81 85       	ldd	r24, Z+9	; 0x09
    1a50:	8c 7f       	andi	r24, 0xFC	; 252
    1a52:	86 2b       	or	r24, r22
    1a54:	81 87       	std	Z+9, r24	; 0x09
	port->INT0MASK = pinMask;
    1a56:	42 87       	std	Z+10, r20	; 0x0a
}
    1a58:	08 95       	ret

00001a5a <PORT_ConfigureInterrupt1>:
 *  \param pinMask    A mask that selects the pins to associate with port interrupt 1.
 */
void PORT_ConfigureInterrupt1( PORT_t * port,
                               PORT_INT1LVL_t intLevel,
                               uint8_t pinMask )
{
    1a5a:	fc 01       	movw	r30, r24
	port->INTCTRL = ( port->INTCTRL & ~PORT_INT1LVL_gm ) | intLevel;
    1a5c:	81 85       	ldd	r24, Z+9	; 0x09
    1a5e:	83 7f       	andi	r24, 0xF3	; 243
    1a60:	86 2b       	or	r24, r22
    1a62:	81 87       	std	Z+9, r24	; 0x09
	port->INT1MASK = pinMask;
    1a64:	43 87       	std	Z+11, r20	; 0x0b
}
    1a66:	08 95       	ret

00001a68 <PORT_ConfigurePins>:
                         uint8_t pinMask,
                         uint8_t slewRateEnable,
                         uint8_t invertEnable,
                         PORT_OPC_t opc,
                         PORT_ISC_t isc)
{
    1a68:	ef 92       	push	r14
    1a6a:	0f 93       	push	r16
    1a6c:	fc 01       	movw	r30, r24
	/* Build pin control register value. */
	uint8_t temp = (uint8_t) opc |
	               isc |
	               (slewRateEnable ? PORT_SRLEN_bm : 0) |
	               (invertEnable ? PORT_INVEN_bm : 0);
    1a6e:	44 23       	and	r20, r20
    1a70:	11 f4       	brne	.+4      	; 0x1a76 <PORT_ConfigurePins+0xe>
    1a72:	90 e0       	ldi	r25, 0x00	; 0
    1a74:	01 c0       	rjmp	.+2      	; 0x1a78 <PORT_ConfigurePins+0x10>
    1a76:	90 e8       	ldi	r25, 0x80	; 128
    1a78:	22 23       	and	r18, r18
    1a7a:	11 f4       	brne	.+4      	; 0x1a80 <PORT_ConfigurePins+0x18>
    1a7c:	80 e0       	ldi	r24, 0x00	; 0
    1a7e:	01 c0       	rjmp	.+2      	; 0x1a82 <PORT_ConfigurePins+0x1a>
    1a80:	80 e4       	ldi	r24, 0x40	; 64
    1a82:	e0 2a       	or	r14, r16
    1a84:	9e 29       	or	r25, r14
    1a86:	98 2b       	or	r25, r24

	/* Configure the pins in one atomic operation. */

	/* Save status register. */
	uint8_t sreg = SREG;
    1a88:	8f b7       	in	r24, 0x3f	; 63

	cli();
    1a8a:	f8 94       	cli
	PORTCFG.MPCMASK = pinMask;
    1a8c:	60 93 b0 00 	sts	0x00B0, r22
	port->PIN0CTRL = temp;
    1a90:	90 8b       	std	Z+16, r25	; 0x10

	/* Restore status register. */
	SREG = sreg;
    1a92:	8f bf       	out	0x3f, r24	; 63
}
    1a94:	0f 91       	pop	r16
    1a96:	ef 90       	pop	r14
    1a98:	08 95       	ret

00001a9a <PORT_MapVirtualPort0>:
 *
 *  \param realPort Selects the real port to map to virtual port 0.
 */
void PORT_MapVirtualPort0(PORTCFG_VP0MAP_t realPort)
{
	PORTCFG.VPCTRLA = ( PORTCFG.VPCTRLA & ~PORTCFG_VP0MAP_gm ) | realPort;
    1a9a:	e0 eb       	ldi	r30, 0xB0	; 176
    1a9c:	f0 e0       	ldi	r31, 0x00	; 0
    1a9e:	92 81       	ldd	r25, Z+2	; 0x02
    1aa0:	90 7f       	andi	r25, 0xF0	; 240
    1aa2:	98 2b       	or	r25, r24
    1aa4:	92 83       	std	Z+2, r25	; 0x02
}
    1aa6:	08 95       	ret

00001aa8 <PORT_MapVirtualPort1>:
 *
 *  \param realPort Selects the real port to map to virtual port 1.
 */
void PORT_MapVirtualPort1(PORTCFG_VP1MAP_t realPort)
{
	PORTCFG.VPCTRLA = ( PORTCFG.VPCTRLA & ~PORTCFG_VP1MAP_gm ) | realPort;
    1aa8:	e0 eb       	ldi	r30, 0xB0	; 176
    1aaa:	f0 e0       	ldi	r31, 0x00	; 0
    1aac:	92 81       	ldd	r25, Z+2	; 0x02
    1aae:	9f 70       	andi	r25, 0x0F	; 15
    1ab0:	98 2b       	or	r25, r24
    1ab2:	92 83       	std	Z+2, r25	; 0x02
}
    1ab4:	08 95       	ret

00001ab6 <PORT_MapVirtualPort2>:
 *
 *  \param realPort Selects the real port to map to virtual port 2.
 */
void PORT_MapVirtualPort2(PORTCFG_VP2MAP_t realPort)
{
	PORTCFG.VPCTRLB = ( PORTCFG.VPCTRLB & ~PORTCFG_VP2MAP_gm ) | realPort;
    1ab6:	e0 eb       	ldi	r30, 0xB0	; 176
    1ab8:	f0 e0       	ldi	r31, 0x00	; 0
    1aba:	93 81       	ldd	r25, Z+3	; 0x03
    1abc:	90 7f       	andi	r25, 0xF0	; 240
    1abe:	98 2b       	or	r25, r24
    1ac0:	93 83       	std	Z+3, r25	; 0x03
}
    1ac2:	08 95       	ret

00001ac4 <PORT_MapVirtualPort3>:
 *
 *  \param realPort Selects the real port to map to virtual port 3.
 */
void PORT_MapVirtualPort3(PORTCFG_VP3MAP_t realPort)
{
	PORTCFG.VPCTRLB = ( PORTCFG.VPCTRLB & ~PORTCFG_VP3MAP_gm ) | realPort;
    1ac4:	e0 eb       	ldi	r30, 0xB0	; 176
    1ac6:	f0 e0       	ldi	r31, 0x00	; 0
    1ac8:	93 81       	ldd	r25, Z+3	; 0x03
    1aca:	9f 70       	andi	r25, 0x0F	; 15
    1acc:	98 2b       	or	r25, r24
    1ace:	93 83       	std	Z+3, r25	; 0x03
}
    1ad0:	08 95       	ret

00001ad2 <printf>:
    1ad2:	a0 e0       	ldi	r26, 0x00	; 0
    1ad4:	b0 e0       	ldi	r27, 0x00	; 0
    1ad6:	ef e6       	ldi	r30, 0x6F	; 111
    1ad8:	fd e0       	ldi	r31, 0x0D	; 13
    1ada:	0c 94 89 10 	jmp	0x2112	; 0x2112 <__prologue_saves__+0x20>
    1ade:	fe 01       	movw	r30, r28
    1ae0:	36 96       	adiw	r30, 0x06	; 6
    1ae2:	61 91       	ld	r22, Z+
    1ae4:	71 91       	ld	r23, Z+
    1ae6:	80 91 68 21 	lds	r24, 0x2168
    1aea:	90 91 69 21 	lds	r25, 0x2169
    1aee:	af 01       	movw	r20, r30
    1af0:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <vfprintf>
    1af4:	20 96       	adiw	r28, 0x00	; 0
    1af6:	e2 e0       	ldi	r30, 0x02	; 2
    1af8:	0c 94 a5 10 	jmp	0x214a	; 0x214a <__epilogue_restores__+0x20>

00001afc <puts>:
    1afc:	0f 93       	push	r16
    1afe:	1f 93       	push	r17
    1b00:	cf 93       	push	r28
    1b02:	df 93       	push	r29
    1b04:	8c 01       	movw	r16, r24
    1b06:	e0 91 68 21 	lds	r30, 0x2168
    1b0a:	f0 91 69 21 	lds	r31, 0x2169
    1b0e:	83 81       	ldd	r24, Z+3	; 0x03
    1b10:	81 ff       	sbrs	r24, 1
    1b12:	21 c0       	rjmp	.+66     	; 0x1b56 <puts+0x5a>
    1b14:	c0 e0       	ldi	r28, 0x00	; 0
    1b16:	d0 e0       	ldi	r29, 0x00	; 0
    1b18:	0d c0       	rjmp	.+26     	; 0x1b34 <puts+0x38>
    1b1a:	e0 91 68 21 	lds	r30, 0x2168
    1b1e:	f0 91 69 21 	lds	r31, 0x2169
    1b22:	20 85       	ldd	r18, Z+8	; 0x08
    1b24:	31 85       	ldd	r19, Z+9	; 0x09
    1b26:	bf 01       	movw	r22, r30
    1b28:	f9 01       	movw	r30, r18
    1b2a:	19 95       	eicall
    1b2c:	89 2b       	or	r24, r25
    1b2e:	11 f0       	breq	.+4      	; 0x1b34 <puts+0x38>
    1b30:	cf ef       	ldi	r28, 0xFF	; 255
    1b32:	df ef       	ldi	r29, 0xFF	; 255
    1b34:	f8 01       	movw	r30, r16
    1b36:	81 91       	ld	r24, Z+
    1b38:	8f 01       	movw	r16, r30
    1b3a:	88 23       	and	r24, r24
    1b3c:	71 f7       	brne	.-36     	; 0x1b1a <puts+0x1e>
    1b3e:	e0 91 68 21 	lds	r30, 0x2168
    1b42:	f0 91 69 21 	lds	r31, 0x2169
    1b46:	20 85       	ldd	r18, Z+8	; 0x08
    1b48:	31 85       	ldd	r19, Z+9	; 0x09
    1b4a:	8a e0       	ldi	r24, 0x0A	; 10
    1b4c:	bf 01       	movw	r22, r30
    1b4e:	f9 01       	movw	r30, r18
    1b50:	19 95       	eicall
    1b52:	89 2b       	or	r24, r25
    1b54:	11 f0       	breq	.+4      	; 0x1b5a <puts+0x5e>
    1b56:	cf ef       	ldi	r28, 0xFF	; 255
    1b58:	df ef       	ldi	r29, 0xFF	; 255
    1b5a:	ce 01       	movw	r24, r28
    1b5c:	df 91       	pop	r29
    1b5e:	cf 91       	pop	r28
    1b60:	1f 91       	pop	r17
    1b62:	0f 91       	pop	r16
    1b64:	08 95       	ret

00001b66 <vfprintf>:
    1b66:	ab e0       	ldi	r26, 0x0B	; 11
    1b68:	b0 e0       	ldi	r27, 0x00	; 0
    1b6a:	e9 eb       	ldi	r30, 0xB9	; 185
    1b6c:	fd e0       	ldi	r31, 0x0D	; 13
    1b6e:	0c 94 79 10 	jmp	0x20f2	; 0x20f2 <__prologue_saves__>
    1b72:	3c 01       	movw	r6, r24
    1b74:	2b 01       	movw	r4, r22
    1b76:	5a 01       	movw	r10, r20
    1b78:	fc 01       	movw	r30, r24
    1b7a:	16 82       	std	Z+6, r1	; 0x06
    1b7c:	17 82       	std	Z+7, r1	; 0x07
    1b7e:	83 81       	ldd	r24, Z+3	; 0x03
    1b80:	81 fd       	sbrc	r24, 1
    1b82:	03 c0       	rjmp	.+6      	; 0x1b8a <vfprintf+0x24>
    1b84:	6f ef       	ldi	r22, 0xFF	; 255
    1b86:	7f ef       	ldi	r23, 0xFF	; 255
    1b88:	c6 c1       	rjmp	.+908    	; 0x1f16 <vfprintf+0x3b0>
    1b8a:	9a e0       	ldi	r25, 0x0A	; 10
    1b8c:	89 2e       	mov	r8, r25
    1b8e:	1e 01       	movw	r2, r28
    1b90:	08 94       	sec
    1b92:	21 1c       	adc	r2, r1
    1b94:	31 1c       	adc	r3, r1
    1b96:	f3 01       	movw	r30, r6
    1b98:	23 81       	ldd	r18, Z+3	; 0x03
    1b9a:	f2 01       	movw	r30, r4
    1b9c:	23 fd       	sbrc	r18, 3
    1b9e:	85 91       	lpm	r24, Z+
    1ba0:	23 ff       	sbrs	r18, 3
    1ba2:	81 91       	ld	r24, Z+
    1ba4:	2f 01       	movw	r4, r30
    1ba6:	88 23       	and	r24, r24
    1ba8:	09 f4       	brne	.+2      	; 0x1bac <vfprintf+0x46>
    1baa:	b2 c1       	rjmp	.+868    	; 0x1f10 <vfprintf+0x3aa>
    1bac:	85 32       	cpi	r24, 0x25	; 37
    1bae:	39 f4       	brne	.+14     	; 0x1bbe <vfprintf+0x58>
    1bb0:	23 fd       	sbrc	r18, 3
    1bb2:	85 91       	lpm	r24, Z+
    1bb4:	23 ff       	sbrs	r18, 3
    1bb6:	81 91       	ld	r24, Z+
    1bb8:	2f 01       	movw	r4, r30
    1bba:	85 32       	cpi	r24, 0x25	; 37
    1bbc:	29 f4       	brne	.+10     	; 0x1bc8 <vfprintf+0x62>
    1bbe:	90 e0       	ldi	r25, 0x00	; 0
    1bc0:	b3 01       	movw	r22, r6
    1bc2:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <fputc>
    1bc6:	e7 cf       	rjmp	.-50     	; 0x1b96 <vfprintf+0x30>
    1bc8:	98 2f       	mov	r25, r24
    1bca:	ff 24       	eor	r15, r15
    1bcc:	ee 24       	eor	r14, r14
    1bce:	99 24       	eor	r9, r9
    1bd0:	ff e1       	ldi	r31, 0x1F	; 31
    1bd2:	ff 15       	cp	r31, r15
    1bd4:	d0 f0       	brcs	.+52     	; 0x1c0a <vfprintf+0xa4>
    1bd6:	9b 32       	cpi	r25, 0x2B	; 43
    1bd8:	69 f0       	breq	.+26     	; 0x1bf4 <vfprintf+0x8e>
    1bda:	9c 32       	cpi	r25, 0x2C	; 44
    1bdc:	28 f4       	brcc	.+10     	; 0x1be8 <vfprintf+0x82>
    1bde:	90 32       	cpi	r25, 0x20	; 32
    1be0:	59 f0       	breq	.+22     	; 0x1bf8 <vfprintf+0x92>
    1be2:	93 32       	cpi	r25, 0x23	; 35
    1be4:	91 f4       	brne	.+36     	; 0x1c0a <vfprintf+0xa4>
    1be6:	0e c0       	rjmp	.+28     	; 0x1c04 <vfprintf+0x9e>
    1be8:	9d 32       	cpi	r25, 0x2D	; 45
    1bea:	49 f0       	breq	.+18     	; 0x1bfe <vfprintf+0x98>
    1bec:	90 33       	cpi	r25, 0x30	; 48
    1bee:	69 f4       	brne	.+26     	; 0x1c0a <vfprintf+0xa4>
    1bf0:	41 e0       	ldi	r20, 0x01	; 1
    1bf2:	24 c0       	rjmp	.+72     	; 0x1c3c <vfprintf+0xd6>
    1bf4:	52 e0       	ldi	r21, 0x02	; 2
    1bf6:	f5 2a       	or	r15, r21
    1bf8:	84 e0       	ldi	r24, 0x04	; 4
    1bfa:	f8 2a       	or	r15, r24
    1bfc:	28 c0       	rjmp	.+80     	; 0x1c4e <vfprintf+0xe8>
    1bfe:	98 e0       	ldi	r25, 0x08	; 8
    1c00:	f9 2a       	or	r15, r25
    1c02:	25 c0       	rjmp	.+74     	; 0x1c4e <vfprintf+0xe8>
    1c04:	e0 e1       	ldi	r30, 0x10	; 16
    1c06:	fe 2a       	or	r15, r30
    1c08:	22 c0       	rjmp	.+68     	; 0x1c4e <vfprintf+0xe8>
    1c0a:	f7 fc       	sbrc	r15, 7
    1c0c:	29 c0       	rjmp	.+82     	; 0x1c60 <vfprintf+0xfa>
    1c0e:	89 2f       	mov	r24, r25
    1c10:	80 53       	subi	r24, 0x30	; 48
    1c12:	8a 30       	cpi	r24, 0x0A	; 10
    1c14:	70 f4       	brcc	.+28     	; 0x1c32 <vfprintf+0xcc>
    1c16:	f6 fe       	sbrs	r15, 6
    1c18:	05 c0       	rjmp	.+10     	; 0x1c24 <vfprintf+0xbe>
    1c1a:	98 9c       	mul	r9, r8
    1c1c:	90 2c       	mov	r9, r0
    1c1e:	11 24       	eor	r1, r1
    1c20:	98 0e       	add	r9, r24
    1c22:	15 c0       	rjmp	.+42     	; 0x1c4e <vfprintf+0xe8>
    1c24:	e8 9c       	mul	r14, r8
    1c26:	e0 2c       	mov	r14, r0
    1c28:	11 24       	eor	r1, r1
    1c2a:	e8 0e       	add	r14, r24
    1c2c:	f0 e2       	ldi	r31, 0x20	; 32
    1c2e:	ff 2a       	or	r15, r31
    1c30:	0e c0       	rjmp	.+28     	; 0x1c4e <vfprintf+0xe8>
    1c32:	9e 32       	cpi	r25, 0x2E	; 46
    1c34:	29 f4       	brne	.+10     	; 0x1c40 <vfprintf+0xda>
    1c36:	f6 fc       	sbrc	r15, 6
    1c38:	6b c1       	rjmp	.+726    	; 0x1f10 <vfprintf+0x3aa>
    1c3a:	40 e4       	ldi	r20, 0x40	; 64
    1c3c:	f4 2a       	or	r15, r20
    1c3e:	07 c0       	rjmp	.+14     	; 0x1c4e <vfprintf+0xe8>
    1c40:	9c 36       	cpi	r25, 0x6C	; 108
    1c42:	19 f4       	brne	.+6      	; 0x1c4a <vfprintf+0xe4>
    1c44:	50 e8       	ldi	r21, 0x80	; 128
    1c46:	f5 2a       	or	r15, r21
    1c48:	02 c0       	rjmp	.+4      	; 0x1c4e <vfprintf+0xe8>
    1c4a:	98 36       	cpi	r25, 0x68	; 104
    1c4c:	49 f4       	brne	.+18     	; 0x1c60 <vfprintf+0xfa>
    1c4e:	f2 01       	movw	r30, r4
    1c50:	23 fd       	sbrc	r18, 3
    1c52:	95 91       	lpm	r25, Z+
    1c54:	23 ff       	sbrs	r18, 3
    1c56:	91 91       	ld	r25, Z+
    1c58:	2f 01       	movw	r4, r30
    1c5a:	99 23       	and	r25, r25
    1c5c:	09 f0       	breq	.+2      	; 0x1c60 <vfprintf+0xfa>
    1c5e:	b8 cf       	rjmp	.-144    	; 0x1bd0 <vfprintf+0x6a>
    1c60:	89 2f       	mov	r24, r25
    1c62:	85 54       	subi	r24, 0x45	; 69
    1c64:	83 30       	cpi	r24, 0x03	; 3
    1c66:	18 f0       	brcs	.+6      	; 0x1c6e <vfprintf+0x108>
    1c68:	80 52       	subi	r24, 0x20	; 32
    1c6a:	83 30       	cpi	r24, 0x03	; 3
    1c6c:	38 f4       	brcc	.+14     	; 0x1c7c <vfprintf+0x116>
    1c6e:	44 e0       	ldi	r20, 0x04	; 4
    1c70:	50 e0       	ldi	r21, 0x00	; 0
    1c72:	a4 0e       	add	r10, r20
    1c74:	b5 1e       	adc	r11, r21
    1c76:	5f e3       	ldi	r21, 0x3F	; 63
    1c78:	59 83       	std	Y+1, r21	; 0x01
    1c7a:	0f c0       	rjmp	.+30     	; 0x1c9a <vfprintf+0x134>
    1c7c:	93 36       	cpi	r25, 0x63	; 99
    1c7e:	31 f0       	breq	.+12     	; 0x1c8c <vfprintf+0x126>
    1c80:	93 37       	cpi	r25, 0x73	; 115
    1c82:	79 f0       	breq	.+30     	; 0x1ca2 <vfprintf+0x13c>
    1c84:	93 35       	cpi	r25, 0x53	; 83
    1c86:	09 f0       	breq	.+2      	; 0x1c8a <vfprintf+0x124>
    1c88:	56 c0       	rjmp	.+172    	; 0x1d36 <vfprintf+0x1d0>
    1c8a:	20 c0       	rjmp	.+64     	; 0x1ccc <vfprintf+0x166>
    1c8c:	f5 01       	movw	r30, r10
    1c8e:	80 81       	ld	r24, Z
    1c90:	89 83       	std	Y+1, r24	; 0x01
    1c92:	42 e0       	ldi	r20, 0x02	; 2
    1c94:	50 e0       	ldi	r21, 0x00	; 0
    1c96:	a4 0e       	add	r10, r20
    1c98:	b5 1e       	adc	r11, r21
    1c9a:	61 01       	movw	r12, r2
    1c9c:	01 e0       	ldi	r16, 0x01	; 1
    1c9e:	10 e0       	ldi	r17, 0x00	; 0
    1ca0:	12 c0       	rjmp	.+36     	; 0x1cc6 <vfprintf+0x160>
    1ca2:	f5 01       	movw	r30, r10
    1ca4:	c0 80       	ld	r12, Z
    1ca6:	d1 80       	ldd	r13, Z+1	; 0x01
    1ca8:	f6 fc       	sbrc	r15, 6
    1caa:	03 c0       	rjmp	.+6      	; 0x1cb2 <vfprintf+0x14c>
    1cac:	6f ef       	ldi	r22, 0xFF	; 255
    1cae:	7f ef       	ldi	r23, 0xFF	; 255
    1cb0:	02 c0       	rjmp	.+4      	; 0x1cb6 <vfprintf+0x150>
    1cb2:	69 2d       	mov	r22, r9
    1cb4:	70 e0       	ldi	r23, 0x00	; 0
    1cb6:	42 e0       	ldi	r20, 0x02	; 2
    1cb8:	50 e0       	ldi	r21, 0x00	; 0
    1cba:	a4 0e       	add	r10, r20
    1cbc:	b5 1e       	adc	r11, r21
    1cbe:	c6 01       	movw	r24, r12
    1cc0:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <strnlen>
    1cc4:	8c 01       	movw	r16, r24
    1cc6:	5f e7       	ldi	r21, 0x7F	; 127
    1cc8:	f5 22       	and	r15, r21
    1cca:	14 c0       	rjmp	.+40     	; 0x1cf4 <vfprintf+0x18e>
    1ccc:	f5 01       	movw	r30, r10
    1cce:	c0 80       	ld	r12, Z
    1cd0:	d1 80       	ldd	r13, Z+1	; 0x01
    1cd2:	f6 fc       	sbrc	r15, 6
    1cd4:	03 c0       	rjmp	.+6      	; 0x1cdc <vfprintf+0x176>
    1cd6:	6f ef       	ldi	r22, 0xFF	; 255
    1cd8:	7f ef       	ldi	r23, 0xFF	; 255
    1cda:	02 c0       	rjmp	.+4      	; 0x1ce0 <vfprintf+0x17a>
    1cdc:	69 2d       	mov	r22, r9
    1cde:	70 e0       	ldi	r23, 0x00	; 0
    1ce0:	42 e0       	ldi	r20, 0x02	; 2
    1ce2:	50 e0       	ldi	r21, 0x00	; 0
    1ce4:	a4 0e       	add	r10, r20
    1ce6:	b5 1e       	adc	r11, r21
    1ce8:	c6 01       	movw	r24, r12
    1cea:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <strnlen_P>
    1cee:	8c 01       	movw	r16, r24
    1cf0:	50 e8       	ldi	r21, 0x80	; 128
    1cf2:	f5 2a       	or	r15, r21
    1cf4:	f3 fe       	sbrs	r15, 3
    1cf6:	07 c0       	rjmp	.+14     	; 0x1d06 <vfprintf+0x1a0>
    1cf8:	1a c0       	rjmp	.+52     	; 0x1d2e <vfprintf+0x1c8>
    1cfa:	80 e2       	ldi	r24, 0x20	; 32
    1cfc:	90 e0       	ldi	r25, 0x00	; 0
    1cfe:	b3 01       	movw	r22, r6
    1d00:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <fputc>
    1d04:	ea 94       	dec	r14
    1d06:	8e 2d       	mov	r24, r14
    1d08:	90 e0       	ldi	r25, 0x00	; 0
    1d0a:	08 17       	cp	r16, r24
    1d0c:	19 07       	cpc	r17, r25
    1d0e:	a8 f3       	brcs	.-22     	; 0x1cfa <vfprintf+0x194>
    1d10:	0e c0       	rjmp	.+28     	; 0x1d2e <vfprintf+0x1c8>
    1d12:	f6 01       	movw	r30, r12
    1d14:	f7 fc       	sbrc	r15, 7
    1d16:	85 91       	lpm	r24, Z+
    1d18:	f7 fe       	sbrs	r15, 7
    1d1a:	81 91       	ld	r24, Z+
    1d1c:	6f 01       	movw	r12, r30
    1d1e:	90 e0       	ldi	r25, 0x00	; 0
    1d20:	b3 01       	movw	r22, r6
    1d22:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <fputc>
    1d26:	e1 10       	cpse	r14, r1
    1d28:	ea 94       	dec	r14
    1d2a:	01 50       	subi	r16, 0x01	; 1
    1d2c:	10 40       	sbci	r17, 0x00	; 0
    1d2e:	01 15       	cp	r16, r1
    1d30:	11 05       	cpc	r17, r1
    1d32:	79 f7       	brne	.-34     	; 0x1d12 <vfprintf+0x1ac>
    1d34:	ea c0       	rjmp	.+468    	; 0x1f0a <vfprintf+0x3a4>
    1d36:	94 36       	cpi	r25, 0x64	; 100
    1d38:	11 f0       	breq	.+4      	; 0x1d3e <vfprintf+0x1d8>
    1d3a:	99 36       	cpi	r25, 0x69	; 105
    1d3c:	69 f5       	brne	.+90     	; 0x1d98 <vfprintf+0x232>
    1d3e:	f7 fe       	sbrs	r15, 7
    1d40:	08 c0       	rjmp	.+16     	; 0x1d52 <vfprintf+0x1ec>
    1d42:	f5 01       	movw	r30, r10
    1d44:	20 81       	ld	r18, Z
    1d46:	31 81       	ldd	r19, Z+1	; 0x01
    1d48:	42 81       	ldd	r20, Z+2	; 0x02
    1d4a:	53 81       	ldd	r21, Z+3	; 0x03
    1d4c:	84 e0       	ldi	r24, 0x04	; 4
    1d4e:	90 e0       	ldi	r25, 0x00	; 0
    1d50:	0a c0       	rjmp	.+20     	; 0x1d66 <vfprintf+0x200>
    1d52:	f5 01       	movw	r30, r10
    1d54:	80 81       	ld	r24, Z
    1d56:	91 81       	ldd	r25, Z+1	; 0x01
    1d58:	9c 01       	movw	r18, r24
    1d5a:	44 27       	eor	r20, r20
    1d5c:	37 fd       	sbrc	r19, 7
    1d5e:	40 95       	com	r20
    1d60:	54 2f       	mov	r21, r20
    1d62:	82 e0       	ldi	r24, 0x02	; 2
    1d64:	90 e0       	ldi	r25, 0x00	; 0
    1d66:	a8 0e       	add	r10, r24
    1d68:	b9 1e       	adc	r11, r25
    1d6a:	9f e6       	ldi	r25, 0x6F	; 111
    1d6c:	f9 22       	and	r15, r25
    1d6e:	57 ff       	sbrs	r21, 7
    1d70:	09 c0       	rjmp	.+18     	; 0x1d84 <vfprintf+0x21e>
    1d72:	50 95       	com	r21
    1d74:	40 95       	com	r20
    1d76:	30 95       	com	r19
    1d78:	21 95       	neg	r18
    1d7a:	3f 4f       	sbci	r19, 0xFF	; 255
    1d7c:	4f 4f       	sbci	r20, 0xFF	; 255
    1d7e:	5f 4f       	sbci	r21, 0xFF	; 255
    1d80:	e0 e8       	ldi	r30, 0x80	; 128
    1d82:	fe 2a       	or	r15, r30
    1d84:	ca 01       	movw	r24, r20
    1d86:	b9 01       	movw	r22, r18
    1d88:	a1 01       	movw	r20, r2
    1d8a:	2a e0       	ldi	r18, 0x0A	; 10
    1d8c:	30 e0       	ldi	r19, 0x00	; 0
    1d8e:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <__ultoa_invert>
    1d92:	d8 2e       	mov	r13, r24
    1d94:	d2 18       	sub	r13, r2
    1d96:	40 c0       	rjmp	.+128    	; 0x1e18 <vfprintf+0x2b2>
    1d98:	95 37       	cpi	r25, 0x75	; 117
    1d9a:	29 f4       	brne	.+10     	; 0x1da6 <vfprintf+0x240>
    1d9c:	1f 2d       	mov	r17, r15
    1d9e:	1f 7e       	andi	r17, 0xEF	; 239
    1da0:	2a e0       	ldi	r18, 0x0A	; 10
    1da2:	30 e0       	ldi	r19, 0x00	; 0
    1da4:	1d c0       	rjmp	.+58     	; 0x1de0 <vfprintf+0x27a>
    1da6:	1f 2d       	mov	r17, r15
    1da8:	19 7f       	andi	r17, 0xF9	; 249
    1daa:	9f 36       	cpi	r25, 0x6F	; 111
    1dac:	61 f0       	breq	.+24     	; 0x1dc6 <vfprintf+0x260>
    1dae:	90 37       	cpi	r25, 0x70	; 112
    1db0:	20 f4       	brcc	.+8      	; 0x1dba <vfprintf+0x254>
    1db2:	98 35       	cpi	r25, 0x58	; 88
    1db4:	09 f0       	breq	.+2      	; 0x1db8 <vfprintf+0x252>
    1db6:	ac c0       	rjmp	.+344    	; 0x1f10 <vfprintf+0x3aa>
    1db8:	0f c0       	rjmp	.+30     	; 0x1dd8 <vfprintf+0x272>
    1dba:	90 37       	cpi	r25, 0x70	; 112
    1dbc:	39 f0       	breq	.+14     	; 0x1dcc <vfprintf+0x266>
    1dbe:	98 37       	cpi	r25, 0x78	; 120
    1dc0:	09 f0       	breq	.+2      	; 0x1dc4 <vfprintf+0x25e>
    1dc2:	a6 c0       	rjmp	.+332    	; 0x1f10 <vfprintf+0x3aa>
    1dc4:	04 c0       	rjmp	.+8      	; 0x1dce <vfprintf+0x268>
    1dc6:	28 e0       	ldi	r18, 0x08	; 8
    1dc8:	30 e0       	ldi	r19, 0x00	; 0
    1dca:	0a c0       	rjmp	.+20     	; 0x1de0 <vfprintf+0x27a>
    1dcc:	10 61       	ori	r17, 0x10	; 16
    1dce:	14 fd       	sbrc	r17, 4
    1dd0:	14 60       	ori	r17, 0x04	; 4
    1dd2:	20 e1       	ldi	r18, 0x10	; 16
    1dd4:	30 e0       	ldi	r19, 0x00	; 0
    1dd6:	04 c0       	rjmp	.+8      	; 0x1de0 <vfprintf+0x27a>
    1dd8:	14 fd       	sbrc	r17, 4
    1dda:	16 60       	ori	r17, 0x06	; 6
    1ddc:	20 e1       	ldi	r18, 0x10	; 16
    1dde:	32 e0       	ldi	r19, 0x02	; 2
    1de0:	17 ff       	sbrs	r17, 7
    1de2:	08 c0       	rjmp	.+16     	; 0x1df4 <vfprintf+0x28e>
    1de4:	f5 01       	movw	r30, r10
    1de6:	60 81       	ld	r22, Z
    1de8:	71 81       	ldd	r23, Z+1	; 0x01
    1dea:	82 81       	ldd	r24, Z+2	; 0x02
    1dec:	93 81       	ldd	r25, Z+3	; 0x03
    1dee:	44 e0       	ldi	r20, 0x04	; 4
    1df0:	50 e0       	ldi	r21, 0x00	; 0
    1df2:	08 c0       	rjmp	.+16     	; 0x1e04 <vfprintf+0x29e>
    1df4:	f5 01       	movw	r30, r10
    1df6:	80 81       	ld	r24, Z
    1df8:	91 81       	ldd	r25, Z+1	; 0x01
    1dfa:	bc 01       	movw	r22, r24
    1dfc:	80 e0       	ldi	r24, 0x00	; 0
    1dfe:	90 e0       	ldi	r25, 0x00	; 0
    1e00:	42 e0       	ldi	r20, 0x02	; 2
    1e02:	50 e0       	ldi	r21, 0x00	; 0
    1e04:	a4 0e       	add	r10, r20
    1e06:	b5 1e       	adc	r11, r21
    1e08:	a1 01       	movw	r20, r2
    1e0a:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <__ultoa_invert>
    1e0e:	d8 2e       	mov	r13, r24
    1e10:	d2 18       	sub	r13, r2
    1e12:	8f e7       	ldi	r24, 0x7F	; 127
    1e14:	f8 2e       	mov	r15, r24
    1e16:	f1 22       	and	r15, r17
    1e18:	f6 fe       	sbrs	r15, 6
    1e1a:	0b c0       	rjmp	.+22     	; 0x1e32 <vfprintf+0x2cc>
    1e1c:	5e ef       	ldi	r21, 0xFE	; 254
    1e1e:	f5 22       	and	r15, r21
    1e20:	d9 14       	cp	r13, r9
    1e22:	38 f4       	brcc	.+14     	; 0x1e32 <vfprintf+0x2cc>
    1e24:	f4 fe       	sbrs	r15, 4
    1e26:	07 c0       	rjmp	.+14     	; 0x1e36 <vfprintf+0x2d0>
    1e28:	f2 fc       	sbrc	r15, 2
    1e2a:	05 c0       	rjmp	.+10     	; 0x1e36 <vfprintf+0x2d0>
    1e2c:	8f ee       	ldi	r24, 0xEF	; 239
    1e2e:	f8 22       	and	r15, r24
    1e30:	02 c0       	rjmp	.+4      	; 0x1e36 <vfprintf+0x2d0>
    1e32:	1d 2d       	mov	r17, r13
    1e34:	01 c0       	rjmp	.+2      	; 0x1e38 <vfprintf+0x2d2>
    1e36:	19 2d       	mov	r17, r9
    1e38:	f4 fe       	sbrs	r15, 4
    1e3a:	0d c0       	rjmp	.+26     	; 0x1e56 <vfprintf+0x2f0>
    1e3c:	fe 01       	movw	r30, r28
    1e3e:	ed 0d       	add	r30, r13
    1e40:	f1 1d       	adc	r31, r1
    1e42:	80 81       	ld	r24, Z
    1e44:	80 33       	cpi	r24, 0x30	; 48
    1e46:	19 f4       	brne	.+6      	; 0x1e4e <vfprintf+0x2e8>
    1e48:	99 ee       	ldi	r25, 0xE9	; 233
    1e4a:	f9 22       	and	r15, r25
    1e4c:	08 c0       	rjmp	.+16     	; 0x1e5e <vfprintf+0x2f8>
    1e4e:	1f 5f       	subi	r17, 0xFF	; 255
    1e50:	f2 fe       	sbrs	r15, 2
    1e52:	05 c0       	rjmp	.+10     	; 0x1e5e <vfprintf+0x2f8>
    1e54:	03 c0       	rjmp	.+6      	; 0x1e5c <vfprintf+0x2f6>
    1e56:	8f 2d       	mov	r24, r15
    1e58:	86 78       	andi	r24, 0x86	; 134
    1e5a:	09 f0       	breq	.+2      	; 0x1e5e <vfprintf+0x2f8>
    1e5c:	1f 5f       	subi	r17, 0xFF	; 255
    1e5e:	0f 2d       	mov	r16, r15
    1e60:	f3 fc       	sbrc	r15, 3
    1e62:	14 c0       	rjmp	.+40     	; 0x1e8c <vfprintf+0x326>
    1e64:	f0 fe       	sbrs	r15, 0
    1e66:	0f c0       	rjmp	.+30     	; 0x1e86 <vfprintf+0x320>
    1e68:	1e 15       	cp	r17, r14
    1e6a:	10 f0       	brcs	.+4      	; 0x1e70 <vfprintf+0x30a>
    1e6c:	9d 2c       	mov	r9, r13
    1e6e:	0b c0       	rjmp	.+22     	; 0x1e86 <vfprintf+0x320>
    1e70:	9d 2c       	mov	r9, r13
    1e72:	9e 0c       	add	r9, r14
    1e74:	91 1a       	sub	r9, r17
    1e76:	1e 2d       	mov	r17, r14
    1e78:	06 c0       	rjmp	.+12     	; 0x1e86 <vfprintf+0x320>
    1e7a:	80 e2       	ldi	r24, 0x20	; 32
    1e7c:	90 e0       	ldi	r25, 0x00	; 0
    1e7e:	b3 01       	movw	r22, r6
    1e80:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <fputc>
    1e84:	1f 5f       	subi	r17, 0xFF	; 255
    1e86:	1e 15       	cp	r17, r14
    1e88:	c0 f3       	brcs	.-16     	; 0x1e7a <vfprintf+0x314>
    1e8a:	04 c0       	rjmp	.+8      	; 0x1e94 <vfprintf+0x32e>
    1e8c:	1e 15       	cp	r17, r14
    1e8e:	10 f4       	brcc	.+4      	; 0x1e94 <vfprintf+0x32e>
    1e90:	e1 1a       	sub	r14, r17
    1e92:	01 c0       	rjmp	.+2      	; 0x1e96 <vfprintf+0x330>
    1e94:	ee 24       	eor	r14, r14
    1e96:	04 ff       	sbrs	r16, 4
    1e98:	0f c0       	rjmp	.+30     	; 0x1eb8 <vfprintf+0x352>
    1e9a:	80 e3       	ldi	r24, 0x30	; 48
    1e9c:	90 e0       	ldi	r25, 0x00	; 0
    1e9e:	b3 01       	movw	r22, r6
    1ea0:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <fputc>
    1ea4:	02 ff       	sbrs	r16, 2
    1ea6:	1d c0       	rjmp	.+58     	; 0x1ee2 <vfprintf+0x37c>
    1ea8:	01 fd       	sbrc	r16, 1
    1eaa:	03 c0       	rjmp	.+6      	; 0x1eb2 <vfprintf+0x34c>
    1eac:	88 e7       	ldi	r24, 0x78	; 120
    1eae:	90 e0       	ldi	r25, 0x00	; 0
    1eb0:	0e c0       	rjmp	.+28     	; 0x1ece <vfprintf+0x368>
    1eb2:	88 e5       	ldi	r24, 0x58	; 88
    1eb4:	90 e0       	ldi	r25, 0x00	; 0
    1eb6:	0b c0       	rjmp	.+22     	; 0x1ece <vfprintf+0x368>
    1eb8:	80 2f       	mov	r24, r16
    1eba:	86 78       	andi	r24, 0x86	; 134
    1ebc:	91 f0       	breq	.+36     	; 0x1ee2 <vfprintf+0x37c>
    1ebe:	01 ff       	sbrs	r16, 1
    1ec0:	02 c0       	rjmp	.+4      	; 0x1ec6 <vfprintf+0x360>
    1ec2:	8b e2       	ldi	r24, 0x2B	; 43
    1ec4:	01 c0       	rjmp	.+2      	; 0x1ec8 <vfprintf+0x362>
    1ec6:	80 e2       	ldi	r24, 0x20	; 32
    1ec8:	f7 fc       	sbrc	r15, 7
    1eca:	8d e2       	ldi	r24, 0x2D	; 45
    1ecc:	90 e0       	ldi	r25, 0x00	; 0
    1ece:	b3 01       	movw	r22, r6
    1ed0:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <fputc>
    1ed4:	06 c0       	rjmp	.+12     	; 0x1ee2 <vfprintf+0x37c>
    1ed6:	80 e3       	ldi	r24, 0x30	; 48
    1ed8:	90 e0       	ldi	r25, 0x00	; 0
    1eda:	b3 01       	movw	r22, r6
    1edc:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <fputc>
    1ee0:	9a 94       	dec	r9
    1ee2:	d9 14       	cp	r13, r9
    1ee4:	c0 f3       	brcs	.-16     	; 0x1ed6 <vfprintf+0x370>
    1ee6:	da 94       	dec	r13
    1ee8:	f1 01       	movw	r30, r2
    1eea:	ed 0d       	add	r30, r13
    1eec:	f1 1d       	adc	r31, r1
    1eee:	80 81       	ld	r24, Z
    1ef0:	90 e0       	ldi	r25, 0x00	; 0
    1ef2:	b3 01       	movw	r22, r6
    1ef4:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <fputc>
    1ef8:	dd 20       	and	r13, r13
    1efa:	a9 f7       	brne	.-22     	; 0x1ee6 <vfprintf+0x380>
    1efc:	06 c0       	rjmp	.+12     	; 0x1f0a <vfprintf+0x3a4>
    1efe:	80 e2       	ldi	r24, 0x20	; 32
    1f00:	90 e0       	ldi	r25, 0x00	; 0
    1f02:	b3 01       	movw	r22, r6
    1f04:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <fputc>
    1f08:	ea 94       	dec	r14
    1f0a:	ee 20       	and	r14, r14
    1f0c:	c1 f7       	brne	.-16     	; 0x1efe <vfprintf+0x398>
    1f0e:	43 ce       	rjmp	.-890    	; 0x1b96 <vfprintf+0x30>
    1f10:	f3 01       	movw	r30, r6
    1f12:	66 81       	ldd	r22, Z+6	; 0x06
    1f14:	77 81       	ldd	r23, Z+7	; 0x07
    1f16:	cb 01       	movw	r24, r22
    1f18:	2b 96       	adiw	r28, 0x0b	; 11
    1f1a:	e2 e1       	ldi	r30, 0x12	; 18
    1f1c:	0c 94 95 10 	jmp	0x212a	; 0x212a <__epilogue_restores__>

00001f20 <strnlen_P>:
    1f20:	fc 01       	movw	r30, r24
    1f22:	05 90       	lpm	r0, Z+
    1f24:	61 50       	subi	r22, 0x01	; 1
    1f26:	70 40       	sbci	r23, 0x00	; 0
    1f28:	01 10       	cpse	r0, r1
    1f2a:	d8 f7       	brcc	.-10     	; 0x1f22 <strnlen_P+0x2>
    1f2c:	80 95       	com	r24
    1f2e:	90 95       	com	r25
    1f30:	8e 0f       	add	r24, r30
    1f32:	9f 1f       	adc	r25, r31
    1f34:	08 95       	ret

00001f36 <strnlen>:
    1f36:	fc 01       	movw	r30, r24
    1f38:	61 50       	subi	r22, 0x01	; 1
    1f3a:	70 40       	sbci	r23, 0x00	; 0
    1f3c:	01 90       	ld	r0, Z+
    1f3e:	01 10       	cpse	r0, r1
    1f40:	d8 f7       	brcc	.-10     	; 0x1f38 <strnlen+0x2>
    1f42:	80 95       	com	r24
    1f44:	90 95       	com	r25
    1f46:	8e 0f       	add	r24, r30
    1f48:	9f 1f       	adc	r25, r31
    1f4a:	08 95       	ret

00001f4c <fputc>:
    1f4c:	0f 93       	push	r16
    1f4e:	1f 93       	push	r17
    1f50:	cf 93       	push	r28
    1f52:	df 93       	push	r29
    1f54:	8c 01       	movw	r16, r24
    1f56:	eb 01       	movw	r28, r22
    1f58:	8b 81       	ldd	r24, Y+3	; 0x03
    1f5a:	81 ff       	sbrs	r24, 1
    1f5c:	1b c0       	rjmp	.+54     	; 0x1f94 <fputc+0x48>
    1f5e:	82 ff       	sbrs	r24, 2
    1f60:	0d c0       	rjmp	.+26     	; 0x1f7c <fputc+0x30>
    1f62:	2e 81       	ldd	r18, Y+6	; 0x06
    1f64:	3f 81       	ldd	r19, Y+7	; 0x07
    1f66:	8c 81       	ldd	r24, Y+4	; 0x04
    1f68:	9d 81       	ldd	r25, Y+5	; 0x05
    1f6a:	28 17       	cp	r18, r24
    1f6c:	39 07       	cpc	r19, r25
    1f6e:	64 f4       	brge	.+24     	; 0x1f88 <fputc+0x3c>
    1f70:	e8 81       	ld	r30, Y
    1f72:	f9 81       	ldd	r31, Y+1	; 0x01
    1f74:	01 93       	st	Z+, r16
    1f76:	e8 83       	st	Y, r30
    1f78:	f9 83       	std	Y+1, r31	; 0x01
    1f7a:	06 c0       	rjmp	.+12     	; 0x1f88 <fputc+0x3c>
    1f7c:	e8 85       	ldd	r30, Y+8	; 0x08
    1f7e:	f9 85       	ldd	r31, Y+9	; 0x09
    1f80:	80 2f       	mov	r24, r16
    1f82:	19 95       	eicall
    1f84:	89 2b       	or	r24, r25
    1f86:	31 f4       	brne	.+12     	; 0x1f94 <fputc+0x48>
    1f88:	8e 81       	ldd	r24, Y+6	; 0x06
    1f8a:	9f 81       	ldd	r25, Y+7	; 0x07
    1f8c:	01 96       	adiw	r24, 0x01	; 1
    1f8e:	8e 83       	std	Y+6, r24	; 0x06
    1f90:	9f 83       	std	Y+7, r25	; 0x07
    1f92:	02 c0       	rjmp	.+4      	; 0x1f98 <fputc+0x4c>
    1f94:	0f ef       	ldi	r16, 0xFF	; 255
    1f96:	1f ef       	ldi	r17, 0xFF	; 255
    1f98:	c8 01       	movw	r24, r16
    1f9a:	df 91       	pop	r29
    1f9c:	cf 91       	pop	r28
    1f9e:	1f 91       	pop	r17
    1fa0:	0f 91       	pop	r16
    1fa2:	08 95       	ret

00001fa4 <__ultoa_invert>:
    1fa4:	fa 01       	movw	r30, r20
    1fa6:	aa 27       	eor	r26, r26
    1fa8:	28 30       	cpi	r18, 0x08	; 8
    1faa:	51 f1       	breq	.+84     	; 0x2000 <__ultoa_invert+0x5c>
    1fac:	20 31       	cpi	r18, 0x10	; 16
    1fae:	81 f1       	breq	.+96     	; 0x2010 <__ultoa_invert+0x6c>
    1fb0:	e8 94       	clt
    1fb2:	6f 93       	push	r22
    1fb4:	6e 7f       	andi	r22, 0xFE	; 254
    1fb6:	6e 5f       	subi	r22, 0xFE	; 254
    1fb8:	7f 4f       	sbci	r23, 0xFF	; 255
    1fba:	8f 4f       	sbci	r24, 0xFF	; 255
    1fbc:	9f 4f       	sbci	r25, 0xFF	; 255
    1fbe:	af 4f       	sbci	r26, 0xFF	; 255
    1fc0:	b1 e0       	ldi	r27, 0x01	; 1
    1fc2:	3e d0       	rcall	.+124    	; 0x2040 <__ultoa_invert+0x9c>
    1fc4:	b4 e0       	ldi	r27, 0x04	; 4
    1fc6:	3c d0       	rcall	.+120    	; 0x2040 <__ultoa_invert+0x9c>
    1fc8:	67 0f       	add	r22, r23
    1fca:	78 1f       	adc	r23, r24
    1fcc:	89 1f       	adc	r24, r25
    1fce:	9a 1f       	adc	r25, r26
    1fd0:	a1 1d       	adc	r26, r1
    1fd2:	68 0f       	add	r22, r24
    1fd4:	79 1f       	adc	r23, r25
    1fd6:	8a 1f       	adc	r24, r26
    1fd8:	91 1d       	adc	r25, r1
    1fda:	a1 1d       	adc	r26, r1
    1fdc:	6a 0f       	add	r22, r26
    1fde:	71 1d       	adc	r23, r1
    1fe0:	81 1d       	adc	r24, r1
    1fe2:	91 1d       	adc	r25, r1
    1fe4:	a1 1d       	adc	r26, r1
    1fe6:	20 d0       	rcall	.+64     	; 0x2028 <__ultoa_invert+0x84>
    1fe8:	09 f4       	brne	.+2      	; 0x1fec <__ultoa_invert+0x48>
    1fea:	68 94       	set
    1fec:	3f 91       	pop	r19
    1fee:	2a e0       	ldi	r18, 0x0A	; 10
    1ff0:	26 9f       	mul	r18, r22
    1ff2:	11 24       	eor	r1, r1
    1ff4:	30 19       	sub	r19, r0
    1ff6:	30 5d       	subi	r19, 0xD0	; 208
    1ff8:	31 93       	st	Z+, r19
    1ffa:	de f6       	brtc	.-74     	; 0x1fb2 <__ultoa_invert+0xe>
    1ffc:	cf 01       	movw	r24, r30
    1ffe:	08 95       	ret
    2000:	46 2f       	mov	r20, r22
    2002:	47 70       	andi	r20, 0x07	; 7
    2004:	40 5d       	subi	r20, 0xD0	; 208
    2006:	41 93       	st	Z+, r20
    2008:	b3 e0       	ldi	r27, 0x03	; 3
    200a:	0f d0       	rcall	.+30     	; 0x202a <__ultoa_invert+0x86>
    200c:	c9 f7       	brne	.-14     	; 0x2000 <__ultoa_invert+0x5c>
    200e:	f6 cf       	rjmp	.-20     	; 0x1ffc <__ultoa_invert+0x58>
    2010:	46 2f       	mov	r20, r22
    2012:	4f 70       	andi	r20, 0x0F	; 15
    2014:	40 5d       	subi	r20, 0xD0	; 208
    2016:	4a 33       	cpi	r20, 0x3A	; 58
    2018:	18 f0       	brcs	.+6      	; 0x2020 <__ultoa_invert+0x7c>
    201a:	49 5d       	subi	r20, 0xD9	; 217
    201c:	31 fd       	sbrc	r19, 1
    201e:	40 52       	subi	r20, 0x20	; 32
    2020:	41 93       	st	Z+, r20
    2022:	02 d0       	rcall	.+4      	; 0x2028 <__ultoa_invert+0x84>
    2024:	a9 f7       	brne	.-22     	; 0x2010 <__ultoa_invert+0x6c>
    2026:	ea cf       	rjmp	.-44     	; 0x1ffc <__ultoa_invert+0x58>
    2028:	b4 e0       	ldi	r27, 0x04	; 4
    202a:	a6 95       	lsr	r26
    202c:	97 95       	ror	r25
    202e:	87 95       	ror	r24
    2030:	77 95       	ror	r23
    2032:	67 95       	ror	r22
    2034:	ba 95       	dec	r27
    2036:	c9 f7       	brne	.-14     	; 0x202a <__ultoa_invert+0x86>
    2038:	00 97       	sbiw	r24, 0x00	; 0
    203a:	61 05       	cpc	r22, r1
    203c:	71 05       	cpc	r23, r1
    203e:	08 95       	ret
    2040:	9b 01       	movw	r18, r22
    2042:	ac 01       	movw	r20, r24
    2044:	0a 2e       	mov	r0, r26
    2046:	06 94       	lsr	r0
    2048:	57 95       	ror	r21
    204a:	47 95       	ror	r20
    204c:	37 95       	ror	r19
    204e:	27 95       	ror	r18
    2050:	ba 95       	dec	r27
    2052:	c9 f7       	brne	.-14     	; 0x2046 <__ultoa_invert+0xa2>
    2054:	62 0f       	add	r22, r18
    2056:	73 1f       	adc	r23, r19
    2058:	84 1f       	adc	r24, r20
    205a:	95 1f       	adc	r25, r21
    205c:	a0 1d       	adc	r26, r0
    205e:	08 95       	ret

00002060 <__divmodhi4>:
    2060:	97 fb       	bst	r25, 7
    2062:	09 2e       	mov	r0, r25
    2064:	07 26       	eor	r0, r23
    2066:	0a d0       	rcall	.+20     	; 0x207c <__divmodhi4_neg1>
    2068:	77 fd       	sbrc	r23, 7
    206a:	04 d0       	rcall	.+8      	; 0x2074 <__divmodhi4_neg2>
    206c:	2e d0       	rcall	.+92     	; 0x20ca <__udivmodhi4>
    206e:	06 d0       	rcall	.+12     	; 0x207c <__divmodhi4_neg1>
    2070:	00 20       	and	r0, r0
    2072:	1a f4       	brpl	.+6      	; 0x207a <__divmodhi4_exit>

00002074 <__divmodhi4_neg2>:
    2074:	70 95       	com	r23
    2076:	61 95       	neg	r22
    2078:	7f 4f       	sbci	r23, 0xFF	; 255

0000207a <__divmodhi4_exit>:
    207a:	08 95       	ret

0000207c <__divmodhi4_neg1>:
    207c:	f6 f7       	brtc	.-4      	; 0x207a <__divmodhi4_exit>
    207e:	90 95       	com	r25
    2080:	81 95       	neg	r24
    2082:	9f 4f       	sbci	r25, 0xFF	; 255
    2084:	08 95       	ret

00002086 <__udivmodsi4>:
    2086:	a1 e2       	ldi	r26, 0x21	; 33
    2088:	1a 2e       	mov	r1, r26
    208a:	aa 1b       	sub	r26, r26
    208c:	bb 1b       	sub	r27, r27
    208e:	fd 01       	movw	r30, r26
    2090:	0d c0       	rjmp	.+26     	; 0x20ac <__udivmodsi4_ep>

00002092 <__udivmodsi4_loop>:
    2092:	aa 1f       	adc	r26, r26
    2094:	bb 1f       	adc	r27, r27
    2096:	ee 1f       	adc	r30, r30
    2098:	ff 1f       	adc	r31, r31
    209a:	a2 17       	cp	r26, r18
    209c:	b3 07       	cpc	r27, r19
    209e:	e4 07       	cpc	r30, r20
    20a0:	f5 07       	cpc	r31, r21
    20a2:	20 f0       	brcs	.+8      	; 0x20ac <__udivmodsi4_ep>
    20a4:	a2 1b       	sub	r26, r18
    20a6:	b3 0b       	sbc	r27, r19
    20a8:	e4 0b       	sbc	r30, r20
    20aa:	f5 0b       	sbc	r31, r21

000020ac <__udivmodsi4_ep>:
    20ac:	66 1f       	adc	r22, r22
    20ae:	77 1f       	adc	r23, r23
    20b0:	88 1f       	adc	r24, r24
    20b2:	99 1f       	adc	r25, r25
    20b4:	1a 94       	dec	r1
    20b6:	69 f7       	brne	.-38     	; 0x2092 <__udivmodsi4_loop>
    20b8:	60 95       	com	r22
    20ba:	70 95       	com	r23
    20bc:	80 95       	com	r24
    20be:	90 95       	com	r25
    20c0:	9b 01       	movw	r18, r22
    20c2:	ac 01       	movw	r20, r24
    20c4:	bd 01       	movw	r22, r26
    20c6:	cf 01       	movw	r24, r30
    20c8:	08 95       	ret

000020ca <__udivmodhi4>:
    20ca:	aa 1b       	sub	r26, r26
    20cc:	bb 1b       	sub	r27, r27
    20ce:	51 e1       	ldi	r21, 0x11	; 17
    20d0:	07 c0       	rjmp	.+14     	; 0x20e0 <__udivmodhi4_ep>

000020d2 <__udivmodhi4_loop>:
    20d2:	aa 1f       	adc	r26, r26
    20d4:	bb 1f       	adc	r27, r27
    20d6:	a6 17       	cp	r26, r22
    20d8:	b7 07       	cpc	r27, r23
    20da:	10 f0       	brcs	.+4      	; 0x20e0 <__udivmodhi4_ep>
    20dc:	a6 1b       	sub	r26, r22
    20de:	b7 0b       	sbc	r27, r23

000020e0 <__udivmodhi4_ep>:
    20e0:	88 1f       	adc	r24, r24
    20e2:	99 1f       	adc	r25, r25
    20e4:	5a 95       	dec	r21
    20e6:	a9 f7       	brne	.-22     	; 0x20d2 <__udivmodhi4_loop>
    20e8:	80 95       	com	r24
    20ea:	90 95       	com	r25
    20ec:	bc 01       	movw	r22, r24
    20ee:	cd 01       	movw	r24, r26
    20f0:	08 95       	ret

000020f2 <__prologue_saves__>:
    20f2:	2f 92       	push	r2
    20f4:	3f 92       	push	r3
    20f6:	4f 92       	push	r4
    20f8:	5f 92       	push	r5
    20fa:	6f 92       	push	r6
    20fc:	7f 92       	push	r7
    20fe:	8f 92       	push	r8
    2100:	9f 92       	push	r9
    2102:	af 92       	push	r10
    2104:	bf 92       	push	r11
    2106:	cf 92       	push	r12
    2108:	df 92       	push	r13
    210a:	ef 92       	push	r14
    210c:	ff 92       	push	r15
    210e:	0f 93       	push	r16
    2110:	1f 93       	push	r17
    2112:	cf 93       	push	r28
    2114:	df 93       	push	r29
    2116:	cd b7       	in	r28, 0x3d	; 61
    2118:	de b7       	in	r29, 0x3e	; 62
    211a:	ca 1b       	sub	r28, r26
    211c:	db 0b       	sbc	r29, r27
    211e:	0f b6       	in	r0, 0x3f	; 63
    2120:	f8 94       	cli
    2122:	de bf       	out	0x3e, r29	; 62
    2124:	0f be       	out	0x3f, r0	; 63
    2126:	cd bf       	out	0x3d, r28	; 61
    2128:	19 94       	eijmp

0000212a <__epilogue_restores__>:
    212a:	2a 88       	ldd	r2, Y+18	; 0x12
    212c:	39 88       	ldd	r3, Y+17	; 0x11
    212e:	48 88       	ldd	r4, Y+16	; 0x10
    2130:	5f 84       	ldd	r5, Y+15	; 0x0f
    2132:	6e 84       	ldd	r6, Y+14	; 0x0e
    2134:	7d 84       	ldd	r7, Y+13	; 0x0d
    2136:	8c 84       	ldd	r8, Y+12	; 0x0c
    2138:	9b 84       	ldd	r9, Y+11	; 0x0b
    213a:	aa 84       	ldd	r10, Y+10	; 0x0a
    213c:	b9 84       	ldd	r11, Y+9	; 0x09
    213e:	c8 84       	ldd	r12, Y+8	; 0x08
    2140:	df 80       	ldd	r13, Y+7	; 0x07
    2142:	ee 80       	ldd	r14, Y+6	; 0x06
    2144:	fd 80       	ldd	r15, Y+5	; 0x05
    2146:	0c 81       	ldd	r16, Y+4	; 0x04
    2148:	1b 81       	ldd	r17, Y+3	; 0x03
    214a:	aa 81       	ldd	r26, Y+2	; 0x02
    214c:	b9 81       	ldd	r27, Y+1	; 0x01
    214e:	ce 0f       	add	r28, r30
    2150:	d1 1d       	adc	r29, r1
    2152:	0f b6       	in	r0, 0x3f	; 63
    2154:	f8 94       	cli
    2156:	de bf       	out	0x3e, r29	; 62
    2158:	0f be       	out	0x3f, r0	; 63
    215a:	cd bf       	out	0x3d, r28	; 61
    215c:	ed 01       	movw	r28, r26
    215e:	08 95       	ret

00002160 <_exit>:
    2160:	f8 94       	cli

00002162 <__stop_program>:
    2162:	ff cf       	rjmp	.-2      	; 0x2162 <__stop_program>
