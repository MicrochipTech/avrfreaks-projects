
02_Xmega-A1 Xplained PLL SDRAM.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000654  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000c  00802000  00000654  000006e8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000009  0080200c  0080200c  000006f4  2**0
                  ALLOC
  3 .stab         00000714  00000000  00000000  000006f4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00000e08  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000d0  00000000  00000000  00000e90  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000117d  00000000  00000000  00000f60  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000003f2  00000000  00000000  000020dd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000060a  00000000  00000000  000024cf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000194  00000000  00000000  00002adc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006bb  00000000  00000000  00002c70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000003cd  00000000  00000000  0000332b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000038  00000000  00000000  000036f8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__ctors_end>
   4:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
   8:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
   c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  10:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  14:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  18:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  1c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  20:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  24:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  28:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  2c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  30:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  34:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  38:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  3c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  40:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  44:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  48:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  4c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  50:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  54:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  58:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  5c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  60:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  64:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  68:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  6c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  70:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  74:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  78:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  7c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  80:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  84:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  88:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  8c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  90:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  94:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  98:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  9c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  a0:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  a4:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  a8:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  ac:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  b0:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  b4:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  b8:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  bc:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  c0:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  c4:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  c8:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  cc:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  d0:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  d4:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  d8:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  dc:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  e0:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  e4:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  e8:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  ec:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  f0:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  f4:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  f8:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
  fc:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 100:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 104:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 108:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 10c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 110:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 114:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 118:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 11c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 120:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 124:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 128:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 12c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 130:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 134:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 138:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 13c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 140:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 144:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 148:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 14c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 150:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 154:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 158:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 15c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 160:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 164:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 168:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 16c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 170:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 174:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 178:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 17c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 180:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 184:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 188:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 18c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 190:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 194:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 198:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 19c:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1a0:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1a4:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1a8:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1ac:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1b0:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1b4:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1b8:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1bc:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1c0:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1c4:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1c8:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1cc:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1d0:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1d4:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1d8:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1dc:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1e0:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1e4:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1e8:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1ec:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>
 1f0:	0c 94 32 01 	jmp	0x264	; 0x264 <__bad_interrupt>

000001f4 <__ctors_start>:
 1f4:	0f 03       	fmul	r16, r23

000001f6 <__ctors_end>:
 1f6:	11 24       	eor	r1, r1
 1f8:	1f be       	out	0x3f, r1	; 63
 1fa:	cf ef       	ldi	r28, 0xFF	; 255
 1fc:	df e3       	ldi	r29, 0x3F	; 63
 1fe:	de bf       	out	0x3e, r29	; 62
 200:	cd bf       	out	0x3d, r28	; 61
 202:	00 e0       	ldi	r16, 0x00	; 0
 204:	0c bf       	out	0x3c, r16	; 60
 206:	18 be       	out	0x38, r1	; 56
 208:	19 be       	out	0x39, r1	; 57
 20a:	1a be       	out	0x3a, r1	; 58
 20c:	1b be       	out	0x3b, r1	; 59

0000020e <__do_copy_data>:
 20e:	10 e2       	ldi	r17, 0x20	; 32
 210:	a0 e0       	ldi	r26, 0x00	; 0
 212:	b0 e2       	ldi	r27, 0x20	; 32
 214:	e4 e5       	ldi	r30, 0x54	; 84
 216:	f6 e0       	ldi	r31, 0x06	; 6
 218:	00 e0       	ldi	r16, 0x00	; 0
 21a:	0b bf       	out	0x3b, r16	; 59
 21c:	02 c0       	rjmp	.+4      	; 0x222 <__do_copy_data+0x14>
 21e:	07 90       	elpm	r0, Z+
 220:	0d 92       	st	X+, r0
 222:	ac 30       	cpi	r26, 0x0C	; 12
 224:	b1 07       	cpc	r27, r17
 226:	d9 f7       	brne	.-10     	; 0x21e <__do_copy_data+0x10>
 228:	1b be       	out	0x3b, r1	; 59

0000022a <__do_clear_bss>:
 22a:	10 e2       	ldi	r17, 0x20	; 32
 22c:	ac e0       	ldi	r26, 0x0C	; 12
 22e:	b0 e2       	ldi	r27, 0x20	; 32
 230:	01 c0       	rjmp	.+2      	; 0x234 <.do_clear_bss_start>

00000232 <.do_clear_bss_loop>:
 232:	1d 92       	st	X+, r1

00000234 <.do_clear_bss_start>:
 234:	a5 31       	cpi	r26, 0x15	; 21
 236:	b1 07       	cpc	r27, r17
 238:	e1 f7       	brne	.-8      	; 0x232 <.do_clear_bss_loop>

0000023a <__do_global_ctors>:
 23a:	11 e0       	ldi	r17, 0x01	; 1
 23c:	c6 ef       	ldi	r28, 0xF6	; 246
 23e:	d1 e0       	ldi	r29, 0x01	; 1
 240:	00 e0       	ldi	r16, 0x00	; 0
 242:	06 c0       	rjmp	.+12     	; 0x250 <__do_global_ctors+0x16>
 244:	22 97       	sbiw	r28, 0x02	; 2
 246:	01 09       	sbc	r16, r1
 248:	fe 01       	movw	r30, r28
 24a:	0b bf       	out	0x3b, r16	; 59
 24c:	0e 94 24 03 	call	0x648	; 0x648 <__tablejump_elpm__>
 250:	c4 3f       	cpi	r28, 0xF4	; 244
 252:	d1 07       	cpc	r29, r17
 254:	80 e0       	ldi	r24, 0x00	; 0
 256:	08 07       	cpc	r16, r24
 258:	a9 f7       	brne	.-22     	; 0x244 <__do_global_ctors+0xa>
 25a:	1b be       	out	0x3b, r1	; 59
 25c:	0e 94 8b 02 	call	0x516	; 0x516 <main>
 260:	0c 94 28 03 	jmp	0x650	; 0x650 <_exit>

00000264 <__bad_interrupt>:
 264:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000268 <_ZN15eSystemClockDef7eCPPSetEPVhh>:
									
}	

// =============================================================================================================================================================================================
void eSystemClockDef::eCPPSet( volatile uint8_t * address, uint8_t value )
{
 268:	0f 93       	push	r16
	// AVR_ENTER_CRITICAL_REGION( );
	
	volatile uint8_t * tmpAddr = address;
	
	#ifdef RAMPZ
	RAMPZ = 0;
 26a:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
 26c:	fc 01       	movw	r30, r24
 26e:	08 ed       	ldi	r16, 0xD8	; 216
 270:	04 bf       	out	0x34, r16	; 52
 272:	60 83       	st	Z, r22
	// AVR_LEAVE_CRITICAL_REGION( );
	#endif
}
 274:	0f 91       	pop	r16
 276:	08 95       	ret

00000278 <_ZN15eSystemClockDef8SetClockE13eClockTypeDef>:
						
};

// =============================================================================================================================================================================================
void eSystemClockDef::SetClock( eClockTypeDef ClockType )
{
 278:	1f 93       	push	r17
 27a:	cf 93       	push	r28
 27c:	df 93       	push	r29
 27e:	d8 2f       	mov	r29, r24
	unsigned char Value, Clock_Source_Mask;

	// SELECT CLOCK SOURCE: 2 Mhz Int. Osc. Clock 
	Value = (0 << 2) | (0 << 1) | (0 << 0);						// 2 Mhz Int. Osc.
	eCPPSet( &CLK.CTRL, Value );
 280:	80 e4       	ldi	r24, 0x40	; 64
 282:	90 e0       	ldi	r25, 0x00	; 0
 284:	60 e0       	ldi	r22, 0x00	; 0
 286:	0e 94 34 01 	call	0x268	; 0x268 <_ZN15eSystemClockDef7eCPPSetEPVhh>

	// DISABLE PLL
	switch( ClockType )
 28a:	d2 30       	cpi	r29, 0x02	; 2
 28c:	49 f4       	brne	.+18     	; 0x2a0 <_ZN15eSystemClockDef8SetClockE13eClockTypeDef+0x28>
	{
		default: { break; }
		case ectPLL_128_Mhz_64_Mhz_32_Mhz:
		{
			Value = OSC.CTRL & ~(1 << 4);									// DISABLE PLL
 28e:	60 91 50 00 	lds	r22, 0x0050
 292:	6f 7e       	andi	r22, 0xEF	; 239
			eCPPSet( &OSC.CTRL, Value );
 294:	80 e5       	ldi	r24, 0x50	; 80
 296:	90 e0       	ldi	r25, 0x00	; 0
 298:	0e 94 34 01 	call	0x268	; 0x268 <_ZN15eSystemClockDef7eCPPSetEPVhh>
			break;
		}			
		case ectPLL_128_Mhz_64_Mhz_32_Mhz:
		{
			OSC.PLLCTRL = (1 << 7) | (0 << 6)	|						// 32 Mhz. Int. Osc.
										(16);														// 16x = 32 / 4 * 16 = 128 MHz (ClkPer4)
 29c:	80 e9       	ldi	r24, 0x90	; 144
 29e:	01 c0       	rjmp	.+2      	; 0x2a2 <_ZN15eSystemClockDef8SetClockE13eClockTypeDef+0x2a>
	switch( ClockType )
	{
		default:
		{
			OSC.PLLCTRL = (0 << 7) | (0 << 6) |						// 2 Mhz Int. Osc.
										(1);														// 1x
 2a0:	81 e0       	ldi	r24, 0x01	; 1
 2a2:	e0 e5       	ldi	r30, 0x50	; 80
 2a4:	f0 e0       	ldi	r31, 0x00	; 0
 2a6:	85 83       	std	Z+5, r24	; 0x05
		}			
		case ectPLL_128_Mhz_64_Mhz_32_Mhz:
		{
			OSC.PLLCTRL = (1 << 7) | (0 << 6)	|						// 32 Mhz. Int. Osc.
										(16);														// 16x = 32 / 4 * 16 = 128 MHz (ClkPer4)
			break;
 2a8:	ed 2f       	mov	r30, r29
 2aa:	e1 50       	subi	r30, 0x01	; 1
 2ac:	e2 30       	cpi	r30, 0x02	; 2
 2ae:	28 f4       	brcc	.+10     	; 0x2ba <_ZN15eSystemClockDef8SetClockE13eClockTypeDef+0x42>
 2b0:	f0 e0       	ldi	r31, 0x00	; 0
 2b2:	e6 5f       	subi	r30, 0xF6	; 246
 2b4:	ff 4d       	sbci	r31, 0xDF	; 223
 2b6:	10 81       	ld	r17, Z
 2b8:	01 c0       	rjmp	.+2      	; 0x2bc <_ZN15eSystemClockDef8SetClockE13eClockTypeDef+0x44>
						
};

// =============================================================================================================================================================================================
void eSystemClockDef::SetClock( eClockTypeDef ClockType )
{
 2ba:	11 e0       	ldi	r17, 0x01	; 1
	Clock_Source_Mask = (1 << 2) |								// 32 kHz Int. Osc.
											(1 << 1) |								// 32 Mhz Int. Osc.
											(1 << 4);									// PLL
	 */
	// Clock_Source_Mask |= (1 << 2);								// 32 kHz Int. Osc.
	eCPPSet( &OSC.CTRL, Clock_Source_Mask );
 2bc:	80 e5       	ldi	r24, 0x50	; 80
 2be:	90 e0       	ldi	r25, 0x00	; 0
 2c0:	61 2f       	mov	r22, r17
 2c2:	0e 94 34 01 	call	0x268	; 0x268 <_ZN15eSystemClockDef7eCPPSetEPVhh>
 2c6:	d2 30       	cpi	r29, 0x02	; 2
 2c8:	11 f0       	breq	.+4      	; 0x2ce <_ZN15eSystemClockDef8SetClockE13eClockTypeDef+0x56>
 2ca:	c0 e0       	ldi	r28, 0x00	; 0
 2cc:	01 c0       	rjmp	.+2      	; 0x2d0 <_ZN15eSystemClockDef8SetClockE13eClockTypeDef+0x58>
 2ce:	c3 e0       	ldi	r28, 0x03	; 3
			Value = (0 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2) |					// PSADIV = DIV 1
							(0 << 1) | (0 << 0);																						// PSBDIV = 1, PSCDIV = 1 
			break;
		}
	};			
	eCPPSet( &CLK.PSCTRL, Value );
 2d0:	81 e4       	ldi	r24, 0x41	; 65
 2d2:	90 e0       	ldi	r25, 0x00	; 0
 2d4:	6c 2f       	mov	r22, r28
 2d6:	0e 94 34 01 	call	0x268	; 0x268 <_ZN15eSystemClockDef7eCPPSetEPVhh>
	
	// WAIT FOR CLOCK SOURCES IS READY
	while ( (OSC.STATUS & Clock_Source_Mask) != Clock_Source_Mask );				
 2da:	80 91 51 00 	lds	r24, 0x0051
 2de:	81 23       	and	r24, r17
 2e0:	81 17       	cp	r24, r17
 2e2:	d9 f7       	brne	.-10     	; 0x2da <_ZN15eSystemClockDef8SetClockE13eClockTypeDef+0x62>
							 
	// SELECT CLOCK SOURCE: PLL	
	switch( ClockType )
 2e4:	d1 30       	cpi	r29, 0x01	; 1
 2e6:	29 f0       	breq	.+10     	; 0x2f2 <_ZN15eSystemClockDef8SetClockE13eClockTypeDef+0x7a>
 2e8:	d1 30       	cpi	r29, 0x01	; 1
 2ea:	38 f0       	brcs	.+14     	; 0x2fa <_ZN15eSystemClockDef8SetClockE13eClockTypeDef+0x82>
 2ec:	d2 30       	cpi	r29, 0x02	; 2
 2ee:	31 f4       	brne	.+12     	; 0x2fc <_ZN15eSystemClockDef8SetClockE13eClockTypeDef+0x84>
 2f0:	02 c0       	rjmp	.+4      	; 0x2f6 <_ZN15eSystemClockDef8SetClockE13eClockTypeDef+0x7e>
			Value = (0 << 2) | (0 << 1) | (0 << 0);															// 2 Mhz. Int. Osc.
			break;
		}
		case ectInternal_Oscilator_32_Mhz:
		{
			Value = (0 << 2) | (0 << 1) | (1 << 0);															// 32 Mhz. Int. Osc.
 2f2:	c1 e0       	ldi	r28, 0x01	; 1
			break;
 2f4:	03 c0       	rjmp	.+6      	; 0x2fc <_ZN15eSystemClockDef8SetClockE13eClockTypeDef+0x84>
		}
		case ectPLL_128_Mhz_64_Mhz_32_Mhz:
		{				
			Value = (1 << 2) | (0 << 1) | (0 << 0);															// PLL
 2f6:	c4 e0       	ldi	r28, 0x04	; 4
			break;
 2f8:	01 c0       	rjmp	.+2      	; 0x2fc <_ZN15eSystemClockDef8SetClockE13eClockTypeDef+0x84>
	// SELECT CLOCK SOURCE: PLL	
	switch( ClockType )
	{
		case ectInternal_Oscilator_2_Mhz:
		{
			Value = (0 << 2) | (0 << 1) | (0 << 0);															// 2 Mhz. Int. Osc.
 2fa:	c0 e0       	ldi	r28, 0x00	; 0
		{				
			Value = (1 << 2) | (0 << 1) | (0 << 0);															// PLL
			break;
		}
	};			
	eCPPSet( &CLK.CTRL, Value );
 2fc:	80 e4       	ldi	r24, 0x40	; 64
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	6c 2f       	mov	r22, r28
 302:	0e 94 34 01 	call	0x268	; 0x268 <_ZN15eSystemClockDef7eCPPSetEPVhh>
	
	// DISABLE OTHER CLOCK SOURCES
	eCPPSet( &OSC.CTRL, Clock_Source_Mask );		
 306:	80 e5       	ldi	r24, 0x50	; 80
 308:	90 e0       	ldi	r25, 0x00	; 0
 30a:	61 2f       	mov	r22, r17
 30c:	0e 94 34 01 	call	0x268	; 0x268 <_ZN15eSystemClockDef7eCPPSetEPVhh>
	DFLLRC32M.COMP1 = 0x37;
	DFLLRC32M.COMP2 = 0xA0;
	DFLLRC32M.CTRL = (1 << 0);		// AUTO CALIB. ENABLE
	*/
									
}	
 310:	df 91       	pop	r29
 312:	cf 91       	pop	r28
 314:	1f 91       	pop	r17
 316:	08 95       	ret

00000318 <_ZN10eSDRAM_DefC1Ev>:
		void FillBlock( const unsigned long Address, const unsigned long Size, const unsigned char FillByte );
		
};

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
eSDRAM_Def::eSDRAM_Def()
 318:	fc 01       	movw	r30, r24
{
	BaseAddress = 0x800000;			// DO NOT CHANGE !
 31a:	40 e0       	ldi	r20, 0x00	; 0
 31c:	50 e0       	ldi	r21, 0x00	; 0
 31e:	60 e8       	ldi	r22, 0x80	; 128
 320:	70 e0       	ldi	r23, 0x00	; 0
 322:	40 83       	st	Z, r20
 324:	51 83       	std	Z+1, r21	; 0x01
 326:	62 83       	std	Z+2, r22	; 0x02
 328:	73 83       	std	Z+3, r23	; 0x03
	SizeInBytes = 0x800000;			// 8 MB (DO NOT CHANGE)
 32a:	44 83       	std	Z+4, r20	; 0x04
 32c:	55 83       	std	Z+5, r21	; 0x05
 32e:	66 83       	std	Z+6, r22	; 0x06
 330:	77 83       	std	Z+7, r23	; 0x07
}	
 332:	08 95       	ret

00000334 <_ZN10eSDRAM_Def4InitEv>:

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void eSDRAM_Def::Init()
{
	// SETUP EBI PORT DIRECTIONS
	PORTJ.DIR = 0xFF;
 334:	8f ef       	ldi	r24, 0xFF	; 255
 336:	80 93 00 07 	sts	0x0700, r24
	PORTK.DIR = 0xFF;
 33a:	80 93 20 07 	sts	0x0720, r24
	PORTH.DIR = 0xFF;
 33e:	80 93 e0 06 	sts	0x06E0, r24
	PORTH.OUT = 0xFF;							// [0] !WE, [1] !CAS, [2] !RAS, [3] !DQM = MALI BY MAT PULL-UP (na vystupe neviem ako :-) )
 342:	e0 ee       	ldi	r30, 0xE0	; 224
 344:	f6 e0       	ldi	r31, 0x06	; 6
 346:	84 83       	std	Z+4, r24	; 0x04
	
	// EBI SDRAM INIT
	EBI.CTRL = 0x00 |							// [7..6] 00 = 4 bits Data
						 0x0C |							// [3..2] 11 = NOALE = no address multiplexing
						 0x01;							// [1..0] 01 = EBI enabled, IFMODE: 01 = 3 PORTS
 348:	e0 e4       	ldi	r30, 0x40	; 64
 34a:	f4 e0       	ldi	r31, 0x04	; 4
 34c:	8d e0       	ldi	r24, 0x0D	; 13
 34e:	80 93 40 04 	sts	0x0440, r24
	// S CL = 2 NECHCE IST DOBRE (HORNE ADRESY NESTIHA)
	EBI.SDRAMCTRLA = (1 << 2) |		// [3] SDCAS = SDRAM CAS latency (0 = 2 CLK, 1 = 3 CLK)
									 (1 << 1) |		// [2] SDROW = SDRAM ROW bits (0 = 11 bits, 1 = 12 bits)
									 0x02;				// [1..0] SDCOL = SDRAM COLUMN bits (00 = 8 bits, 01 = 9 bits, 10 = 10 bits, 11 = 11 bits)
 352:	86 e0       	ldi	r24, 0x06	; 6
 354:	81 83       	std	Z+1, r24	; 0x01
									 0x28 |				// [5..3] ESRDLY = SDRAM EXIT SELF-REFRESH DELAY (101 = 5 clks)
									 0x01;				// [2..0] ROWCOLDLY = SDRAM ROW TO COLUMN DELAY (001 = 1 clks)
	*/
	EBI.SDRAMCTRLB = 0x80 |				// [7..6] MRDLY = SDRAM MODE DELAY (10 = 2 clks)
									 0x38 |				// [5..3] ROWCYCDLY = SDRAM ROW CYCLE DELAY (111 = 7 clks)
									 0x07;				// [2..0] RPDLY = SDRAM ROW TO PRECHARGE DELAY (111 = 7 clks)
 356:	8f eb       	ldi	r24, 0xBF	; 191
 358:	80 87       	std	Z+8, r24	; 0x08
	EBI.SDRAMCTRLC = 0x40 |				// [7..6] WRDLY = SDRAM WRITE RECOVERYDELAY (01 = 1 clks)
									 0x38 |				// [5..3] ESRDLY = SDRAM EXIT SELF-REFRESH DELAY (111 = 7 clks)
									 0x07;				// [2..0] ROWCOLDLY = SDRAM ROW TO COLUMN DELAY (111 = 7 clks)
 35a:	8f e7       	ldi	r24, 0x7F	; 127
 35c:	81 87       	std	Z+9, r24	; 0x09
	// EBI.REFRESH = 1000;						// [9..0] REFRESH = SDRAM REFRESH period : 64000000 / 1000000 = 64 ClkPer2 na 1 us => 1000 / 64 = 15.625 us
	EBI.REFRESH = 960;						// [9..0] REFRESH = SDRAM REFRESH period : 64000000 / 1000000 = 64 ClkPer2 na 1 us => 960 / 64 = 15 us (max. 15.625 us - najdlhsi mozny cas)
 35e:	80 ec       	ldi	r24, 0xC0	; 192
 360:	93 e0       	ldi	r25, 0x03	; 3
 362:	84 83       	std	Z+4, r24	; 0x04
 364:	95 83       	std	Z+5, r25	; 0x05
	// EBI.INITDLY = 6400;						// [13..0] INITDLY = SDRAM initialization delay : 64000000 / 1000000 = 64 ClkPer2 na 1 us * 100 => 6400 = 100 us
	EBI.INITDLY = 7680;						// [13..0] INITDLY = SDRAM initialization delay : 64000000 / 1000000 = 64 ClkPer2 na 1 us * 120 => 7680 = 120 us
 366:	80 e0       	ldi	r24, 0x00	; 0
 368:	9e e1       	ldi	r25, 0x1E	; 30
 36a:	86 83       	std	Z+6, r24	; 0x06
 36c:	97 83       	std	Z+7, r25	; 0x07
	EBI.CS3.BASEADDR = (0x800000UL >> 8) & 0xFFF0;
 36e:	80 e0       	ldi	r24, 0x00	; 0
 370:	90 e8       	ldi	r25, 0x80	; 128
 372:	86 8f       	std	Z+30, r24	; 0x1e
 374:	97 8f       	std	Z+31, r25	; 0x1f
	EBI.CS3.CTRLA = 0x3C |				// [6..2] ASIZE = SDRAM ADDRESS SIZE IN BYTES (01111 = 8 MB)
									0x03;					// [1..0] MODE = SDRAM CHIP SELECT MODE (11 = SDRAM)
 376:	8f e3       	ldi	r24, 0x3F	; 63
 378:	84 8f       	std	Z+28, r24	; 0x1c
	EBI.CS3.CTRLB = 0x00;					// [2] SDRAM SELF-REFRESH ENABLE (0 - disabled)
 37a:	15 8e       	std	Z+29, r1	; 0x1d
	// [1..0] SDRAM MODE = (0 = Normal Mode)
	while ((EBI.CS3.CTRLB & 0x80) != 0x80);			// Cakaj kym sa inicializuje
 37c:	80 91 5d 04 	lds	r24, 0x045D
 380:	87 ff       	sbrs	r24, 7
 382:	fc cf       	rjmp	.-8      	; 0x37c <_ZN10eSDRAM_Def4InitEv+0x48>
	// ROW CYSLE DELAY = 7 CLK
	// ROW TO PRECHARGE DELAY = 7 CLK
	// WRITE RECOVERY DELAY = 1 CLK
	// SELF REFRESH TO ACTIVE DELAY = 7 CLK
	// ROW TO COL DELAY = 7 CLK
}	
 384:	08 95       	ret

00000386 <_ZN10eSDRAM_Def9ReadBlockEmPKht>:

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void eSDRAM_Def::ReadBlock( const unsigned long Source_Address, const unsigned char *SRAM_Target_Data, const unsigned short Size )
{
 386:	0f 93       	push	r16
 388:	1f 93       	push	r17
	if (Size == 0) { return; }
 38a:	01 15       	cp	r16, r1
 38c:	11 05       	cpc	r17, r1
 38e:	09 f4       	brne	.+2      	; 0x392 <_ZN10eSDRAM_Def9ReadBlockEmPKht+0xc>
 390:	25 c0       	rjmp	.+74     	; 0x3dc <LOOP_eSDRAM_ReadBlock_217+0x26>
		"pop r26 \n\t"								// obnov X
		"pop r31 \n\t"
		"pop r30 \n\t"								// obnov Z
		:
		: "r"(Source_Address), "i"(&RAMPZ), "r"(SRAM_Target_Data), "r"(Size), "i"(&RAMPX)	
	);
 392:	ef 93       	push	r30
 394:	ff 93       	push	r31
 396:	af 93       	push	r26
 398:	bf 93       	push	r27
 39a:	9f 93       	push	r25
 39c:	9b b7       	in	r25, 0x3b	; 59
 39e:	9f 93       	push	r25
 3a0:	99 b7       	in	r25, 0x39	; 57
 3a2:	9f 93       	push	r25
 3a4:	8f 93       	push	r24
 3a6:	7f 93       	push	r23
 3a8:	81 2f       	mov	r24, r17
 3aa:	70 2f       	mov	r23, r16
 3ac:	fa 01       	movw	r30, r20
 3ae:	6b bf       	out	0x3b, r22	; 59
 3b0:	d9 01       	movw	r26, r18
 3b2:	99 27       	eor	r25, r25
 3b4:	99 bf       	out	0x39, r25	; 57

000003b6 <LOOP_eSDRAM_ReadBlock_217>:
 3b6:	91 91       	ld	r25, Z+
 3b8:	9d 93       	st	X+, r25
 3ba:	71 50       	subi	r23, 0x01	; 1
 3bc:	80 40       	sbci	r24, 0x00	; 0
 3be:	77 2b       	or	r23, r23
 3c0:	d1 f7       	brne	.-12     	; 0x3b6 <LOOP_eSDRAM_ReadBlock_217>
 3c2:	88 2b       	or	r24, r24
 3c4:	c1 f7       	brne	.-16     	; 0x3b6 <LOOP_eSDRAM_ReadBlock_217>
 3c6:	7f 91       	pop	r23
 3c8:	8f 91       	pop	r24
 3ca:	9f 91       	pop	r25
 3cc:	99 bf       	out	0x39, r25	; 57
 3ce:	9f 91       	pop	r25
 3d0:	9b bf       	out	0x3b, r25	; 59
 3d2:	9f 91       	pop	r25
 3d4:	bf 91       	pop	r27
 3d6:	af 91       	pop	r26
 3d8:	ff 91       	pop	r31
 3da:	ef 91       	pop	r30
	
}	
 3dc:	1f 91       	pop	r17
 3de:	0f 91       	pop	r16
 3e0:	08 95       	ret

000003e2 <_ZN10eSDRAM_Def10WriteBlockEmPKht>:

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void eSDRAM_Def::WriteBlock( const unsigned long Target_Address, const unsigned char *SRAM_Source_Data, const unsigned short Size )
{
 3e2:	0f 93       	push	r16
 3e4:	1f 93       	push	r17
	if (Size == 0) { return; }
 3e6:	01 15       	cp	r16, r1
 3e8:	11 05       	cpc	r17, r1
 3ea:	09 f4       	brne	.+2      	; 0x3ee <_ZN10eSDRAM_Def10WriteBlockEmPKht+0xc>
 3ec:	25 c0       	rjmp	.+74     	; 0x438 <LOOP_eSDRAM_WriteBlock_240+0x26>
		"pop r26 \n\t"								// obnov X
		"pop r31 \n\t"
		"pop r30 \n\t"								// obnov Z
		:
		: "r"(Target_Address), "i"(&RAMPZ), "r"(SRAM_Source_Data), "r"(Size), "i"(&RAMPX)	
	);
 3ee:	ef 93       	push	r30
 3f0:	ff 93       	push	r31
 3f2:	af 93       	push	r26
 3f4:	bf 93       	push	r27
 3f6:	9f 93       	push	r25
 3f8:	9b b7       	in	r25, 0x3b	; 59
 3fa:	9f 93       	push	r25
 3fc:	99 b7       	in	r25, 0x39	; 57
 3fe:	9f 93       	push	r25
 400:	8f 93       	push	r24
 402:	7f 93       	push	r23
 404:	81 2f       	mov	r24, r17
 406:	70 2f       	mov	r23, r16
 408:	fa 01       	movw	r30, r20
 40a:	6b bf       	out	0x3b, r22	; 59
 40c:	d9 01       	movw	r26, r18
 40e:	99 27       	eor	r25, r25
 410:	99 bf       	out	0x39, r25	; 57

00000412 <LOOP_eSDRAM_WriteBlock_240>:
 412:	9d 91       	ld	r25, X+
 414:	91 93       	st	Z+, r25
 416:	71 50       	subi	r23, 0x01	; 1
 418:	80 40       	sbci	r24, 0x00	; 0
 41a:	77 2b       	or	r23, r23
 41c:	d1 f7       	brne	.-12     	; 0x412 <LOOP_eSDRAM_WriteBlock_240>
 41e:	88 2b       	or	r24, r24
 420:	c1 f7       	brne	.-16     	; 0x412 <LOOP_eSDRAM_WriteBlock_240>
 422:	7f 91       	pop	r23
 424:	8f 91       	pop	r24
 426:	9f 91       	pop	r25
 428:	99 bf       	out	0x39, r25	; 57
 42a:	9f 91       	pop	r25
 42c:	9b bf       	out	0x3b, r25	; 59
 42e:	9f 91       	pop	r25
 430:	bf 91       	pop	r27
 432:	af 91       	pop	r26
 434:	ff 91       	pop	r31
 436:	ef 91       	pop	r30
}
 438:	1f 91       	pop	r17
 43a:	0f 91       	pop	r16
 43c:	08 95       	ret

0000043e <_ZN10eSDRAM_Def9FillBlockEmmh>:

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void eSDRAM_Def::FillBlock( const unsigned long Address, const unsigned long Size, const unsigned char FillByte )
{
 43e:	6f 92       	push	r6
 440:	7f 92       	push	r7
 442:	8f 92       	push	r8
 444:	9f 92       	push	r9
 446:	af 92       	push	r10
 448:	bf 92       	push	r11
 44a:	cf 92       	push	r12
 44c:	df 92       	push	r13
 44e:	ef 92       	push	r14
 450:	0f 93       	push	r16
 452:	1f 93       	push	r17
		:
		: "l"(Address),
			"l"(Size),
			"l"(FillByte),
			"i"(&RAMPZ)
	);
 454:	3a 01       	movw	r6, r20
 456:	4b 01       	movw	r8, r22
 458:	58 01       	movw	r10, r16
 45a:	69 01       	movw	r12, r18
 45c:	9f 93       	push	r25
 45e:	4f 93       	push	r20
 460:	5f 93       	push	r21
 462:	6f 93       	push	r22
 464:	ef 93       	push	r30
 466:	ff 93       	push	r31
 468:	9b b7       	in	r25, 0x3b	; 59
 46a:	9f 93       	push	r25
 46c:	f3 01       	movw	r30, r6
 46e:	98 2d       	mov	r25, r8
 470:	9b bf       	out	0x3b, r25	; 59
 472:	4a 2d       	mov	r20, r10
 474:	5b 2d       	mov	r21, r11
 476:	6c 2d       	mov	r22, r12
 478:	9e 2d       	mov	r25, r14

0000047a <LOOP_eSDRAM_FillBlock_271>:
 47a:	91 93       	st	Z+, r25
 47c:	41 50       	subi	r20, 0x01	; 1
 47e:	50 40       	sbci	r21, 0x00	; 0
 480:	60 40       	sbci	r22, 0x00	; 0
 482:	44 2b       	or	r20, r20
 484:	d1 f7       	brne	.-12     	; 0x47a <LOOP_eSDRAM_FillBlock_271>
 486:	55 2b       	or	r21, r21
 488:	c1 f7       	brne	.-16     	; 0x47a <LOOP_eSDRAM_FillBlock_271>
 48a:	66 2b       	or	r22, r22
 48c:	b1 f7       	brne	.-20     	; 0x47a <LOOP_eSDRAM_FillBlock_271>
 48e:	9f 91       	pop	r25
 490:	9b bf       	out	0x3b, r25	; 59
 492:	ff 91       	pop	r31
 494:	ef 91       	pop	r30
 496:	6f 91       	pop	r22
 498:	5f 91       	pop	r21
 49a:	4f 91       	pop	r20
 49c:	9f 91       	pop	r25
}	
 49e:	1f 91       	pop	r17
 4a0:	0f 91       	pop	r16
 4a2:	ef 90       	pop	r14
 4a4:	df 90       	pop	r13
 4a6:	cf 90       	pop	r12
 4a8:	bf 90       	pop	r11
 4aa:	af 90       	pop	r10
 4ac:	9f 90       	pop	r9
 4ae:	8f 90       	pop	r8
 4b0:	7f 90       	pop	r7
 4b2:	6f 90       	pop	r6
 4b4:	08 95       	ret

000004b6 <_ZN10eSDRAM_Def5Read8Em>:
		: "r"(Address), "i"(&RAMPZ)
		: "r30", "r31"
	);

	return( Value );
}
 4b6:	fa 01       	movw	r30, r20
 4b8:	6b bf       	out	0x3b, r22	; 59
 4ba:	80 81       	ld	r24, Z
 4bc:	1b be       	out	0x3b, r1	; 59
 4be:	08 95       	ret

000004c0 <_ZN10eSDRAM_Def6Read16Em>:
		"ld %B0, Z \n\t"
		"out %2, __zero_reg__ \n\t"
		: "=r"(Value)
		: "r"(Address), "i"(&RAMPZ)
		: "r30", "r31"
	);
 4c0:	fa 01       	movw	r30, r20
 4c2:	6b bf       	out	0x3b, r22	; 59
 4c4:	81 91       	ld	r24, Z+
 4c6:	90 81       	ld	r25, Z
 4c8:	1b be       	out	0x3b, r1	; 59

	return( Value );
}
 4ca:	08 95       	ret

000004cc <_ZN10eSDRAM_Def6Read32Em>:

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
unsigned long eSDRAM_Def::Read32( const unsigned long Address )
{
 4cc:	0f 93       	push	r16
 4ce:	1f 93       	push	r17
		"ld %D0, Z \n\t"
		"out %2, __zero_reg__ \n\t"
		: "=r"(Value)
		: "r"(Address), "i"(&RAMPZ)
		: "r30", "r31"
	);
 4d0:	fa 01       	movw	r30, r20
 4d2:	6b bf       	out	0x3b, r22	; 59
 4d4:	01 91       	ld	r16, Z+
 4d6:	11 91       	ld	r17, Z+
 4d8:	21 91       	ld	r18, Z+
 4da:	30 81       	ld	r19, Z
 4dc:	1b be       	out	0x3b, r1	; 59

	return( Value );
}
 4de:	b8 01       	movw	r22, r16
 4e0:	c9 01       	movw	r24, r18
 4e2:	1f 91       	pop	r17
 4e4:	0f 91       	pop	r16
 4e6:	08 95       	ret

000004e8 <_ZN10eSDRAM_Def6Write8Emh>:
		"st Z, %1 \n\t"
		"out %2, __zero_reg__ \n\t"
		:
		: "r"(Address), "r"(Value), "i"(&RAMPZ)
		: "r30", "r31"
	);
 4e8:	fa 01       	movw	r30, r20
 4ea:	6b bf       	out	0x3b, r22	; 59
 4ec:	20 83       	st	Z, r18
 4ee:	1b be       	out	0x3b, r1	; 59
}
 4f0:	08 95       	ret

000004f2 <_ZN10eSDRAM_Def7Write16Emt>:
		"st Z, %B1 \n\t"
		"out %2, __zero_reg__ \n\t"
		:
		: "r"(Address), "r"(Value), "i"(&RAMPZ)
		: "r30", "r31"
	);
 4f2:	fa 01       	movw	r30, r20
 4f4:	6b bf       	out	0x3b, r22	; 59
 4f6:	21 93       	st	Z+, r18
 4f8:	30 83       	st	Z, r19
 4fa:	1b be       	out	0x3b, r1	; 59
}
 4fc:	08 95       	ret

000004fe <_ZN10eSDRAM_Def7Write32Emm>:

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void eSDRAM_Def::Write32( const unsigned long Address, unsigned long Value )
{
 4fe:	0f 93       	push	r16
 500:	1f 93       	push	r17
		"st Z, %D1 \n\t"
		"out %2, __zero_reg__ \n\t"
		:
		: "r"(Address), "r"(Value), "i"(&RAMPZ)
		: "r30", "r31"
	);
 502:	fa 01       	movw	r30, r20
 504:	6b bf       	out	0x3b, r22	; 59
 506:	01 93       	st	Z+, r16
 508:	11 93       	st	Z+, r17
 50a:	21 93       	st	Z+, r18
 50c:	30 83       	st	Z, r19
 50e:	1b be       	out	0x3b, r1	; 59
}
 510:	1f 91       	pop	r17
 512:	0f 91       	pop	r16
 514:	08 95       	ret

00000516 <main>:
eSDRAM_Def eSDRAM;

// MAIN
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
int main(void)
{
 516:	cf 93       	push	r28
 518:	df 93       	push	r29
 51a:	cd b7       	in	r28, 0x3d	; 61
 51c:	de b7       	in	r29, 0x3e	; 62
 51e:	2a 97       	sbiw	r28, 0x0a	; 10
 520:	cd bf       	out	0x3d, r28	; 61
 522:	de bf       	out	0x3e, r29	; 62
  // INIT CLOCK, SDRAM
	// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	// Setup PLL and clock
	eSystemClock.SetClock( ectPLL_128_Mhz_64_Mhz_32_Mhz );				// ClkPer4 = 128 Mhz, ClkPer2 = 64 Mhz (use SDRAM), SysClk = CpuClk = 32 Mhz
 524:	82 e0       	ldi	r24, 0x02	; 2
 526:	0e 94 3c 01 	call	0x278	; 0x278 <_ZN15eSystemClockDef8SetClockE13eClockTypeDef>
	eSDRAM.Init();																								// Init SDRAM via EBI, Start Address = 0x800000, End Address = 0xFFFFFF, Size = 0x800000 (8 MB)
 52a:	8c e0       	ldi	r24, 0x0C	; 12
 52c:	90 e2       	ldi	r25, 0x20	; 32
 52e:	0e 94 9a 01 	call	0x334	; 0x334 <_ZN10eSDRAM_Def4InitEv>
	
	// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	unsigned char Data[10] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0xFF };			// this is in SRAM
 532:	de 01       	movw	r26, r28
 534:	11 96       	adiw	r26, 0x01	; 1
 536:	e0 e0       	ldi	r30, 0x00	; 0
 538:	f0 e2       	ldi	r31, 0x20	; 32
 53a:	8a e0       	ldi	r24, 0x0A	; 10
 53c:	01 90       	ld	r0, Z+
 53e:	0d 92       	st	X+, r0
 540:	81 50       	subi	r24, 0x01	; 1
 542:	e1 f7       	brne	.-8      	; 0x53c <main+0x26>
	unsigned char DataIndex = 0, TempByte;

	// PORTE (Leds) as OUTPUT
	PORTE.DIR = 0xFF;
 544:	8f ef       	ldi	r24, 0xFF	; 255
 546:	80 93 80 06 	sts	0x0680, r24
	
	// Write Data to SDRAM at Address 0x812345 (0x800000 = BaseAddress, 0x012345 = Offset)
	eSDRAM.WriteBlock( 0x812345UL, Data, sizeof(Data) );
 54a:	8c e0       	ldi	r24, 0x0C	; 12
 54c:	90 e2       	ldi	r25, 0x20	; 32
 54e:	45 e4       	ldi	r20, 0x45	; 69
 550:	53 e2       	ldi	r21, 0x23	; 35
 552:	61 e8       	ldi	r22, 0x81	; 129
 554:	70 e0       	ldi	r23, 0x00	; 0
 556:	9e 01       	movw	r18, r28
 558:	2f 5f       	subi	r18, 0xFF	; 255
 55a:	3f 4f       	sbci	r19, 0xFF	; 255
 55c:	0a e0       	ldi	r16, 0x0A	; 10
 55e:	10 e0       	ldi	r17, 0x00	; 0
 560:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <_ZN10eSDRAM_Def10WriteBlockEmPKht>
 564:	fe 01       	movw	r30, r28
 566:	31 96       	adiw	r30, 0x01	; 1
 568:	8a e0       	ldi	r24, 0x0A	; 10
		
	// Clear Data array
	for (DataIndex = 0; DataIndex < sizeof(Data); DataIndex++)
	{
		Data[ DataIndex ] = 0;
 56a:	11 92       	st	Z+, r1
 56c:	81 50       	subi	r24, 0x01	; 1
	
	// Write Data to SDRAM at Address 0x812345 (0x800000 = BaseAddress, 0x012345 = Offset)
	eSDRAM.WriteBlock( 0x812345UL, Data, sizeof(Data) );
		
	// Clear Data array
	for (DataIndex = 0; DataIndex < sizeof(Data); DataIndex++)
 56e:	e9 f7       	brne	.-6      	; 0x56a <main+0x54>
	{
		Data[ DataIndex ] = 0;
	}	
	
	// Read back from SDRAM
	eSDRAM.ReadBlock( 0x812345UL, Data, sizeof(Data) );
 570:	8c e0       	ldi	r24, 0x0C	; 12
 572:	90 e2       	ldi	r25, 0x20	; 32
 574:	45 e4       	ldi	r20, 0x45	; 69
 576:	53 e2       	ldi	r21, 0x23	; 35
 578:	61 e8       	ldi	r22, 0x81	; 129
 57a:	70 e0       	ldi	r23, 0x00	; 0
 57c:	7e 01       	movw	r14, r28
 57e:	08 94       	sec
 580:	e1 1c       	adc	r14, r1
 582:	f1 1c       	adc	r15, r1
 584:	97 01       	movw	r18, r14
 586:	0a e0       	ldi	r16, 0x0A	; 10
 588:	10 e0       	ldi	r17, 0x00	; 0
 58a:	0e 94 c3 01 	call	0x386	; 0x386 <_ZN10eSDRAM_Def9ReadBlockEmPKht>
	
	// Show Data on Leds
	DataIndex = 0;
 58e:	10 e0       	ldi	r17, 0x00	; 0
	while(1)
  {
		
		PORTE.OUT = ~Data[ DataIndex ];																	// Show Data on leds
 590:	e0 e8       	ldi	r30, 0x80	; 128
 592:	ce 2e       	mov	r12, r30
 594:	e6 e0       	ldi	r30, 0x06	; 6
 596:	de 2e       	mov	r13, r30
 598:	f7 01       	movw	r30, r14
 59a:	e1 0f       	add	r30, r17
 59c:	f1 1d       	adc	r31, r1
 59e:	80 81       	ld	r24, Z
 5a0:	80 95       	com	r24
 5a2:	d6 01       	movw	r26, r12
 5a4:	14 96       	adiw	r26, 0x04	; 4
 5a6:	8c 93       	st	X, r24
 5a8:	14 97       	sbiw	r26, 0x04	; 4
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 5aa:	8f ef       	ldi	r24, 0xFF	; 255
 5ac:	97 ea       	ldi	r25, 0xA7	; 167
 5ae:	a1 e6       	ldi	r26, 0x61	; 97
 5b0:	81 50       	subi	r24, 0x01	; 1
 5b2:	90 40       	sbci	r25, 0x00	; 0
 5b4:	a0 40       	sbci	r26, 0x00	; 0
 5b6:	e1 f7       	brne	.-8      	; 0x5b0 <main+0x9a>
 5b8:	00 c0       	rjmp	.+0      	; 0x5ba <main+0xa4>
 5ba:	00 00       	nop
		_delay_ms( 1000 );																							// Wait 1 second
		
		DataIndex++;
 5bc:	1f 5f       	subi	r17, 0xFF	; 255
		if (DataIndex >= sizeof(Data)) { DataIndex = 0; }
 5be:	1a 30       	cpi	r17, 0x0A	; 10
 5c0:	08 f0       	brcs	.+2      	; 0x5c4 <main+0xae>
 5c2:	10 e0       	ldi	r17, 0x00	; 0
			
		// if you want to read byte from sdram can you do this
		TempByte = eSDRAM.Read8( 0x812345 );														// Read Byte from SDRAM
 5c4:	8c e0       	ldi	r24, 0x0C	; 12
 5c6:	90 e2       	ldi	r25, 0x20	; 32
 5c8:	45 e4       	ldi	r20, 0x45	; 69
 5ca:	53 e2       	ldi	r21, 0x23	; 35
 5cc:	61 e8       	ldi	r22, 0x81	; 129
 5ce:	70 e0       	ldi	r23, 0x00	; 0
 5d0:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <_ZN10eSDRAM_Def5Read8Em>
		TempByte = eSDRAM.Read8( eSDRAM.BaseAddress + 0x012345UL );				
 5d4:	40 91 0c 20 	lds	r20, 0x200C
 5d8:	50 91 0d 20 	lds	r21, 0x200D
 5dc:	60 91 0e 20 	lds	r22, 0x200E
 5e0:	70 91 0f 20 	lds	r23, 0x200F
 5e4:	4b 5b       	subi	r20, 0xBB	; 187
 5e6:	5c 4d       	sbci	r21, 0xDC	; 220
 5e8:	6e 4f       	sbci	r22, 0xFE	; 254
 5ea:	7f 4f       	sbci	r23, 0xFF	; 255
 5ec:	8c e0       	ldi	r24, 0x0C	; 12
 5ee:	90 e2       	ldi	r25, 0x20	; 32
 5f0:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <_ZN10eSDRAM_Def5Read8Em>
		TempByte = eSDRAM.Read8( eSDRAM.BaseAddress + 0x012345UL + (unsigned long)DataIndex );
 5f4:	40 91 0c 20 	lds	r20, 0x200C
 5f8:	50 91 0d 20 	lds	r21, 0x200D
 5fc:	60 91 0e 20 	lds	r22, 0x200E
 600:	70 91 0f 20 	lds	r23, 0x200F
 604:	4b 5b       	subi	r20, 0xBB	; 187
 606:	5c 4d       	sbci	r21, 0xDC	; 220
 608:	6e 4f       	sbci	r22, 0xFE	; 254
 60a:	7f 4f       	sbci	r23, 0xFF	; 255
 60c:	41 0f       	add	r20, r17
 60e:	51 1d       	adc	r21, r1
 610:	61 1d       	adc	r22, r1
 612:	71 1d       	adc	r23, r1
 614:	8c e0       	ldi	r24, 0x0C	; 12
 616:	90 e2       	ldi	r25, 0x20	; 32
 618:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <_ZN10eSDRAM_Def5Read8Em>
	// Read back from SDRAM
	eSDRAM.ReadBlock( 0x812345UL, Data, sizeof(Data) );
	
	// Show Data on Leds
	DataIndex = 0;
	while(1)
 61c:	bd cf       	rjmp	.-134    	; 0x598 <main+0x82>

0000061e <_GLOBAL__sub_I__ZN15eSystemClockDef8SetClockE13eClockTypeDef>:
};

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
eSDRAM_Def::eSDRAM_Def()
{
	BaseAddress = 0x800000;			// DO NOT CHANGE !
 61e:	80 e0       	ldi	r24, 0x00	; 0
 620:	90 e0       	ldi	r25, 0x00	; 0
 622:	a0 e8       	ldi	r26, 0x80	; 128
 624:	b0 e0       	ldi	r27, 0x00	; 0
 626:	80 93 0c 20 	sts	0x200C, r24
 62a:	90 93 0d 20 	sts	0x200D, r25
 62e:	a0 93 0e 20 	sts	0x200E, r26
 632:	b0 93 0f 20 	sts	0x200F, r27
	SizeInBytes = 0x800000;			// 8 MB (DO NOT CHANGE)
 636:	80 93 10 20 	sts	0x2010, r24
 63a:	90 93 11 20 	sts	0x2011, r25
 63e:	a0 93 12 20 	sts	0x2012, r26
 642:	b0 93 13 20 	sts	0x2013, r27
		// if you want to read byte from sdram can you do this
		TempByte = eSDRAM.Read8( 0x812345 );														// Read Byte from SDRAM
		TempByte = eSDRAM.Read8( eSDRAM.BaseAddress + 0x012345UL );				
		TempByte = eSDRAM.Read8( eSDRAM.BaseAddress + 0x012345UL + (unsigned long)DataIndex );
  }
 646:	08 95       	ret

00000648 <__tablejump_elpm__>:
 648:	07 90       	elpm	r0, Z+
 64a:	f6 91       	elpm	r31, Z
 64c:	e0 2d       	mov	r30, r0
 64e:	19 94       	eijmp

00000650 <_exit>:
 650:	f8 94       	cli

00000652 <__stop_program>:
 652:	ff cf       	rjmp	.-2      	; 0x652 <__stop_program>
