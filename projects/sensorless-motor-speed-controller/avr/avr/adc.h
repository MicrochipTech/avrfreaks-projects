/* copyright
   * (c) 2004 Stephen Humble stephenhumble at telstra.com
   *
   *  This file is part of robotx see http://Robotx.sourceforge.net
   *  dual sensorless motor driver firmware.
   *
   *  This is free software; you can redistribute it and/or modify
   *  it under the terms of the GNU General Public License as published by
   *  the Free Software Foundation; either version 2 of the License, or
   *  (at your option) any later version.
*/

#include <avr/io.h>
#include <inttypes.h>

#ifndef _ADC_H_
#define _ADC_H_

#define ADCSCALE 1024
#define VOLTAGE_REF	((1<<REFS0)|(1<<REFS1))
//#define VOLTAGE_REF	(0)
enum
{
   ADTS_FREERUN=0, 			// free run
      ADTS_ACOMP=_BV(ADTS0), 		// analogue comparator
      ADTS_EXTI0=_BV(ADTS1), 		// external interrupt 0
      ADTS_CT0C=_BV(ADTS1) | _BV(ADTS0),// counter timer 0 compare match
      ADTS_CT0O=_BV(ADTS2) ,  		// counter timer 0 overflow
      ADTS_CMB=_BV(ADTS2) | _BV(ADTS0), // counter timer compare match B???
      ADTS_CT1C=_BV(ADTS2) |_BV(ADTS1), // counter timer 1 compare match
      ADTS_CT1O=_BV(ADTS2) |_BV(ADTS1) |_BV(ADTS0), // counter timer 1 overflow
      ADTS_MASK=_BV(ADTS2) |_BV(ADTS1) |_BV(ADTS0), // bit mask
};

/* adc table 
   this is a single linked table of ADC operations its gets 
   generated by bridge routines
   and the adc interrupt routine iterates through it
  it is looped back on it's self 
*/
struct adc_op{
      uint8_t count;  // timer compare interrupt count
      uint8_t opera;
      struct adc_op *next;   // linked list next pointer
};
#define ADC_MAX 24
extern volatile struct adc_op adc_tab[ADC_MAX];
extern char adc_req;  // this is used to assign adc conversions
extern unsigned char adc_tail;
extern unsigned char adc_hook;
extern unsigned char adc_head;
extern volatile int8_t      adcpnt;
//extern uint16_t		volts_sum[ 8 ];
extern volatile uint16_t		adc_battery;
extern volatile uint16_t		adc_temperature;
extern volatile struct adc_op *adc_pnt;
extern volatile uint8_t 	adc_state;

void adc_read( void );

void init_adc( void );

void adc_task( void );

void adc_data(void);
void adc_test(void);

// ENUMERATED LIST of adc operations which can be requested or performed
#define ADC_BRU (2^6);
#define ADC_BRQ (2^5);
enum{  ADC_BRU_1I=1,
	  ADC_BRU_1V=3,
	  ADC_BRU_2I,
	  ADC_BRU_2V,
	  ADC_BRQ_1I,
	  ADC_BRQ_1V,
	  ADC_BRQ_2I,
	  ADC_BRQ_2V,
	  ADC_VCC,
	  ADC_TEMPERATURE,
	  ADC_WELD_V,
	  ADC_WELD_I,
	  ADC_WELD_IRRX,
	  ADC_WELD_IRRX2,
	  ADC_POT1,
	  ADC_POT2,
	  ADC_POT3  };

uint8_t adc_set(uint8_t state);
#endif
