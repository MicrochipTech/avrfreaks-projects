<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>cocoOS: docMessages.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>docMessages.h File Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
If the tasks in an application needs to exchange more information than just simple events, they can use messages. The base type for messages is the Msg_t, which is a struct with only one member: signal. <div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>{
    uint8_t signal;
} Msg_t;
</pre></div><p>
From this base type, the application can create its own message types containing the members needed: <div class="fragment"><pre class="fragment"><span class="keyword">enum</span> {
    LED_ON_SIG,
    LED_OFF_SIG
};

<span class="keyword">typedef</span> <span class="keyword">struct </span>{
    Msg_t super;    <span class="comment">/* All application defined message types should inherit from the Msg_t */</span>
    uint8_t led;
} LedMsg_t;

<span class="keywordtype">void</span> task( <span class="keywordtype">void</span> ) {
    <span class="keyword">static</span> LedMsg_t ledMsg;

    ledMsg.super.signal = LED_ON_SIG;
    ledMsg.led = 0;

    <a class="code" href="os__appl_a_p_i_8h.html#c19d6a48c1cb673360ae220aaf2a9d53">task_open</a>();
    ...
    <a class="code" href="os__appl_a_p_i_8h.html#7912af19af4a033fd9caf27879614945">task_close</a>();
}
</pre></div><p>
<b>Message passing</b> <br>
 Messages are passed between tasks using pointers. The message pointer is put into a tasks queue of message pointers, the message queue. The application must allocate space for this message queue and pass the address of the queue when creating the task: <div class="fragment"><pre class="fragment"><span class="keyword">static</span> Msg_t *msgpool[ Q_SIZE ];

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {
    <a class="code" href="os__appl_a_p_i_8h.html#0dd35dda08098d9f347d34e597d8a03e">task_create</a>( task, prio, msgpool, Q_SIZE );
}
</pre></div><p>
One thing to be aware of when using pointers to messages, is that the message the pointer points to is not allowed to change before the message has been read by the receiver task. It is up to the application to assure this will not happen.<br>
 <br>
<p>
<b>Mutual exclusion and synchronization</b> <br>
 For each message queue, cocoOS creates a binary semaphore and an event intended to be used for mutual exclusion and synchronization. <br>
 Before accessing the queue for either posting or receiving a message, the semaphore should be aquired. If the semaphore is already taken by another task, the task will be put into the waiting state until the semaphore is released. <br>
 <br>
<p>
The event associated with a message queue is automatically signaled when the queue contents changes, i.e. a message is posted to or removed from the queue. A task can choose to wait for the event when a message queue was full or empty when trying to post or receive a message respectively. Then when the event is signalled, the task can make a new post/receive retry to the message queue. <br>
<p>
<b>Posting messages</b> <br>
 The simplest way of posting a message into another task's message queue is to use <a class="el" href="os__appl_a_p_i_8h.html#f7294179cef18edc6e016ef5c0fc5650">msg_post()</a>: <div class="fragment"><pre class="fragment"><span class="keyword">static</span> Msg_t *msgpool[ 16 ];
<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
        ...
    <a class="code" href="os__appl_a_p_i_8h.html#0dd35dda08098d9f347d34e597d8a03e">task_create</a>( task1, 1, NULL, 0 );
    <a class="code" href="os__appl_a_p_i_8h.html#0dd35dda08098d9f347d34e597d8a03e">task_create</a>( task2, 2, msgpool, 16 );
    ...
    <a class="code" href="os__appl_a_p_i_8h.html#19c7111cf2121a69331d99dabe3e9df0">os_start</a>();
    <span class="keywordflow">return</span> 0;
}


<span class="keyword">static</span> <span class="keywordtype">void</span> task1(<span class="keywordtype">void</span>) {
    <span class="keyword">static</span> Msg_t msg;

    msg.signal = 10MS_SIG;
    
    <a class="code" href="os__appl_a_p_i_8h.html#c19d6a48c1cb673360ae220aaf2a9d53">task_open</a>();
    
    <span class="keywordflow">for</span> (;;) {
        
        <a class="code" href="os__appl_a_p_i_8h.html#d8232a672a6d4f3a4532bea410a0b1ef">task_wait</a>( 10 );
        
        <span class="comment">/* Always aquire the message queue semaphore */</span>
        <a class="code" href="os__appl_a_p_i_8h.html#e66288422355db64c18c53676e53eddb">msg_q_get</a>( task2 );

        <span class="comment">/* Post the message into task2's queue */</span>
        <a class="code" href="os__appl_a_p_i_8h.html#f7294179cef18edc6e016ef5c0fc5650">msg_post</a>( task2, &amp;msg) );

        <span class="comment">/* Release the semaphore */</span>
        <a class="code" href="os__appl_a_p_i_8h.html#dc67691f29549315143cc60ff43e2306">msg_q_give</a>( task2 );  
    }

    <a class="code" href="os__appl_a_p_i_8h.html#7912af19af4a033fd9caf27879614945">task_close</a>();

}
</pre></div><p>
In the example above, the message is only posted if there is place for it in the queue. The posting task is not notified in case there is no place left for the message. However, if the posting task evaluates the return value of the post operation it can take apropiate actions upon posting failure:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> Msg_t *msgpool[ 16 ];
<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
        ...
    <a class="code" href="os__appl_a_p_i_8h.html#0dd35dda08098d9f347d34e597d8a03e">task_create</a>( task1, 1, NULL, 0 );
    <a class="code" href="os__appl_a_p_i_8h.html#0dd35dda08098d9f347d34e597d8a03e">task_create</a>( task2, 2, msgpool, 16 );
    ...
    <a class="code" href="os__appl_a_p_i_8h.html#19c7111cf2121a69331d99dabe3e9df0">os_start</a>();
    <span class="keywordflow">return</span> 0;
}


<span class="keyword">static</span> <span class="keywordtype">void</span> task1(<span class="keywordtype">void</span>)
{
    <span class="keyword">static</span> Msg_t msg;
    <span class="keyword">static</span> uint8_t posted;
    

    msg.signal = 10MS_SIG;
    
    <a class="code" href="os__appl_a_p_i_8h.html#c19d6a48c1cb673360ae220aaf2a9d53">task_open</a>();
    
    <span class="keywordflow">for</span> ( ;; ) {
        <span class="keywordflow">do</span> {
            <a class="code" href="os__appl_a_p_i_8h.html#e66288422355db64c18c53676e53eddb">msg_q_get</a>( task2 );
            posted = <a class="code" href="os__appl_a_p_i_8h.html#f7294179cef18edc6e016ef5c0fc5650">msg_post</a>( task2, &amp;msg );
    
            <span class="comment">/* If the queue was full, wait for the change event. This will release the semaphore. */</span>
            <span class="keywordflow">if</span> ( posted == MSG_QUEUE_FULL ) {
                <a class="code" href="os__appl_a_p_i_8h.html#24a1c276cfb77f61f43fdd74308ad4b9">msg_q_event_wait</a>( task2 );
            }
            <span class="keywordflow">else</span> {
                <span class="comment">/* The message was posted, release the semaphore */</span>
                <a class="code" href="os__appl_a_p_i_8h.html#dc67691f29549315143cc60ff43e2306">msg_q_give</a>( task2 );
            }
        } <span class="keywordflow">while</span>( posted == MSG_QUEUE_FULL );

        <a class="code" href="os__appl_a_p_i_8h.html#d8232a672a6d4f3a4532bea410a0b1ef">task_wait</a>( 10 );
    }

    <a class="code" href="os__appl_a_p_i_8h.html#7912af19af4a033fd9caf27879614945">task_close</a>();

}
</pre></div><p>
<b>Receiving messages</b><br>
 Receiving messages is done in the same manner as posting messages, but instead of checking for return value MSG_QUEUE_FULL, the task should check for return value MSG_QUEUE_EMPTY. <br>
 <b>Message API</b><br>
 The message API consists of the following macros and functions:<br>
<ul>
<li><a class="el" href="os__appl_a_p_i_8h.html#f7294179cef18edc6e016ef5c0fc5650">msg_post()</a></li><li><a class="el" href="os__appl_a_p_i_8h.html#89f1464763ebc2ac0bc2915ad301b25f">msg_receive()</a></li><li><a class="el" href="os__appl_a_p_i_8h.html#e66288422355db64c18c53676e53eddb">msg_q_get()</a></li><li><a class="el" href="os__appl_a_p_i_8h.html#dc67691f29549315143cc60ff43e2306">msg_q_give()</a></li><li><a class="el" href="os__appl_a_p_i_8h.html#24a1c276cfb77f61f43fdd74308ad4b9">msg_q_event_wait()</a> </li></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Nov 14 20:00:25 2010 for cocoOS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
