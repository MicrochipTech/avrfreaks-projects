<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>cocoOS: docTasks.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>docTasks.h File Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<b> Tasks </b> <br>
 The main building block of your application is the task. The tasks should be created in the main function of the application before starting the os. The number of created tasks must not exceed the defined value N_TASKS in <a class="el" href="os__defines_8h.html">os_defines.h</a>. A task is created this way: <div class="fragment"><pre class="fragment">Msg_t *queue[Q_SIZE];

taskId = <a class="code" href="os__appl_a_p_i_8h.html#0dd35dda08098d9f347d34e597d8a03e">task_create</a>( taskProc, prio, queue, Q_SIZE );
</pre></div> The return value, <em>taskId</em>, above is just an uint8_t that can be used to identify the different tasks.<br>
<p>
<em>taskProc</em> is a function pointer to the task procedure that is executed when the task is scheduled to run.<br>
<p>
<em>prio</em> is the task priority in range 1-254, where 1 is highest priority. The kernel always lets the task with highest priority execute first. There can not be two tasks with same priority. <br>
<p>
<em>queue</em> is a pointer to a message queue for the task. Messages are sent between tasks using pointers, so the queue consists of message pointers, Msg_t*. If the specified size is 0, no message queue is allocated for the task, and the queue parameter is ignored.<br>
<p>
<em>Q_SIZE</em> is the length of the message queue. Set to 0 if no queue should be used.<p>
<b>Task Procedures</b><br>
 The code section of a task procedure must begin and end with the <a class="el" href="os__appl_a_p_i_8h.html#c19d6a48c1cb673360ae220aaf2a9d53">task_open()</a> and <a class="el" href="os__appl_a_p_i_8h.html#7912af19af4a033fd9caf27879614945">task_close()</a> macros respectively. A very simple task is shown below: <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> task(<span class="keywordtype">void</span>) {
    <a class="code" href="os__appl_a_p_i_8h.html#c19d6a48c1cb673360ae220aaf2a9d53">task_open</a>();
    ...
    <a class="code" href="os__appl_a_p_i_8h.html#7912af19af4a033fd9caf27879614945">task_close</a>();
}
</pre></div> This task will execute only once. When the <a class="el" href="os__appl_a_p_i_8h.html#7912af19af4a033fd9caf27879614945">task_close()</a> line is executed, the task is put in the killed state and will not be executed again. If the task has to synchronize with some external event, we can put a blocking call in the middle:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> task(<span class="keywordtype">void</span>) {
    <a class="code" href="os__appl_a_p_i_8h.html#c19d6a48c1cb673360ae220aaf2a9d53">task_open</a>();
    ...
    <a class="code" href="os__appl_a_p_i_8h.html#576b2326d068ab852846ee612c7b954c">event_wait</a>(evt);
    ...
    <a class="code" href="os__appl_a_p_i_8h.html#7912af19af4a033fd9caf27879614945">task_close</a>();
}
</pre></div> This task will run to the <a class="el" href="os__appl_a_p_i_8h.html#576b2326d068ab852846ee612c7b954c">event_wait()</a> call and then block. The kernel will schedule other tasks to execute and eventually the event will be signalled which will put the task back to ready state again. Execution will be resumed after the <a class="el" href="os__appl_a_p_i_8h.html#576b2326d068ab852846ee612c7b954c">event_wait()</a> call. Once the <a class="el" href="os__appl_a_p_i_8h.html#7912af19af4a033fd9caf27879614945">task_close()</a> statement is reached, the task will be killed and will not be executed again.<p>
If we want a task to be excuted periodically we must put the code into an endless loop: <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> task(<span class="keywordtype">void</span>) {
    <a class="code" href="os__appl_a_p_i_8h.html#c19d6a48c1cb673360ae220aaf2a9d53">task_open</a>();
    <span class="keywordflow">for</span> (;;) {
        ...
        ...
        <a class="code" href="os__appl_a_p_i_8h.html#d8232a672a6d4f3a4532bea410a0b1ef">task_wait</a>(TASK_DELAY_TICKS);
    }
    <a class="code" href="os__appl_a_p_i_8h.html#7912af19af4a033fd9caf27879614945">task_close</a>();
}
</pre></div><p>
Another example of a task waiting for characters to be received on the serial port: <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> task(<span class="keywordtype">void</span>) {
    uint8_t data;
    <a class="code" href="os__appl_a_p_i_8h.html#c19d6a48c1cb673360ae220aaf2a9d53">task_open</a>();
    <span class="keywordflow">for</span> (;;) {
        <a class="code" href="os__appl_a_p_i_8h.html#576b2326d068ab852846ee612c7b954c">event_wait</a>(rxEvt);
        uart_get(&amp;data);
        ...
    }
    <a class="code" href="os__appl_a_p_i_8h.html#7912af19af4a033fd9caf27879614945">task_close</a>();
}
</pre></div> The rxEvt may be signalled from the uart ISR using <a class="el" href="os__appl_a_p_i_8h.html#90cd2126d49864ddb72738c12a01b34e">event_ISR_signal(rxEvt)</a>.<p>
<b>Task API </b> <br>
 The task API consists of the following functions and macros:<ul>
<li><a class="el" href="os__appl_a_p_i_8h.html#0dd35dda08098d9f347d34e597d8a03e">task_create()</a></li><li><a class="el" href="os__appl_a_p_i_8h.html#36df952f331631590dc3a982e0e8a2d4">task_kill()</a></li><li><a class="el" href="os__appl_a_p_i_8h.html#c19d6a48c1cb673360ae220aaf2a9d53">task_open()</a></li><li><a class="el" href="os__appl_a_p_i_8h.html#7912af19af4a033fd9caf27879614945">task_close()</a></li><li><a class="el" href="os__appl_a_p_i_8h.html#7d1f6736c118f92f06a5d9218e0ba977">task_suspend()</a></li><li><a class="el" href="os__appl_a_p_i_8h.html#6de09b7f20e384d58bbf330c19447a79">task_resume()</a></li><li><a class="el" href="os__appl_a_p_i_8h.html#5587eb98c16ed4dd2adaa8ae2f3bb1e1">task_state_get()</a></li><li><a class="el" href="os__appl_a_p_i_8h.html#b9e114be01c136878fc271be2a9c45cf">task_id_get()</a></li><li><a class="el" href="os__appl_a_p_i_8h.html#d8232a672a6d4f3a4532bea410a0b1ef">task_wait()</a> </li></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Nov 14 20:00:25 2010 for cocoOS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
