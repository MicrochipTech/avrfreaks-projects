
M_BUS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000576  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  00000576  0000060a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000003a  00800062  00800062  0000060c  2**0
                  ALLOC
  3 .noinit       00000000  0080009c  0080009c  0000060c  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  0000060c  2**0
                  CONTENTS
  5 .stab         00000354  00000000  00000000  0000060c  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      00000084  00000000  00000000  00000960  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 0000012c  00000000  00000000  000009e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000009ba  00000000  00000000  00000b10  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00001268  00000000  00000000  000014ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000073a  00000000  00000000  00002732  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00000e51  00000000  00000000  00002e6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000345  00000000  00000000  00003cbd  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
   0:	0b c0       	rjmp	.+22     	; 0x18 <__ctors_end>
   2:	b9 c0       	rjmp	.+370    	; 0x176 <__vector_1>
   4:	22 c0       	rjmp	.+68     	; 0x4a <__bad_interrupt>
   6:	21 c0       	rjmp	.+66     	; 0x4a <__bad_interrupt>
   8:	32 c1       	rjmp	.+612    	; 0x26e <__vector_4>
   a:	1f c0       	rjmp	.+62     	; 0x4a <__bad_interrupt>
   c:	18 c1       	rjmp	.+560    	; 0x23e <__vector_6>
   e:	1d c0       	rjmp	.+58     	; 0x4a <__bad_interrupt>
  10:	1c c0       	rjmp	.+56     	; 0x4a <__bad_interrupt>
  12:	1b c0       	rjmp	.+54     	; 0x4a <__bad_interrupt>
  14:	1a c0       	rjmp	.+52     	; 0x4a <__bad_interrupt>
  16:	19 c0       	rjmp	.+50     	; 0x4a <__bad_interrupt>

00000018 <__ctors_end>:
  18:	11 24       	eor	r1, r1
  1a:	1f be       	out	0x3f, r1	; 63
  1c:	cf ed       	ldi	r28, 0xDF	; 223
  1e:	cd bf       	out	0x3d, r28	; 61

00000020 <__do_copy_data>:
  20:	10 e0       	ldi	r17, 0x00	; 0
  22:	a0 e6       	ldi	r26, 0x60	; 96
  24:	b0 e0       	ldi	r27, 0x00	; 0
  26:	e6 e7       	ldi	r30, 0x76	; 118
  28:	f5 e0       	ldi	r31, 0x05	; 5
  2a:	03 c0       	rjmp	.+6      	; 0x32 <.do_copy_data_start>

0000002c <.do_copy_data_loop>:
  2c:	c8 95       	lpm
  2e:	31 96       	adiw	r30, 0x01	; 1
  30:	0d 92       	st	X+, r0

00000032 <.do_copy_data_start>:
  32:	a2 36       	cpi	r26, 0x62	; 98
  34:	b1 07       	cpc	r27, r17
  36:	d1 f7       	brne	.-12     	; 0x2c <.do_copy_data_loop>

00000038 <__do_clear_bss>:
  38:	10 e0       	ldi	r17, 0x00	; 0
  3a:	a2 e6       	ldi	r26, 0x62	; 98
  3c:	b0 e0       	ldi	r27, 0x00	; 0
  3e:	01 c0       	rjmp	.+2      	; 0x42 <.do_clear_bss_start>

00000040 <.do_clear_bss_loop>:
  40:	1d 92       	st	X+, r1

00000042 <.do_clear_bss_start>:
  42:	ac 39       	cpi	r26, 0x9C	; 156
  44:	b1 07       	cpc	r27, r17
  46:	e1 f7       	brne	.-8      	; 0x40 <.do_clear_bss_loop>
  48:	64 c2       	rjmp	.+1224   	; 0x512 <main>

0000004a <__bad_interrupt>:
  4a:	da cf       	rjmp	.-76     	; 0x0 <__vectors>

0000004c <send>:
#include "M_BUS_data.h"

/*********************************************************************************/
void send(unsigned char nmbr)                                   // Send on M-BUS
{
  4c:	38 2f       	mov	r19, r24
    unsigned char n;
    unsigned char m;
    unsigned char s_temp;

    while (bus_busy>0);                             //wait if there is receiving
  4e:	e0 91 77 00 	lds	r30, 0x0077
  52:	ee 23       	and	r30, r30
  54:	e1 f7       	brne	.-8      	; 0x4e <send+0x2>
    GIMSK &= 0xbf;                                      //INT0 interrupt disable
  56:	8b b7       	in	r24, 0x3b	; 59
  58:	8f 7b       	andi	r24, 0xBF	; 191
  5a:	8b bf       	out	0x3b, r24	; 59
    TIMSK = 0x20;                                           //T1 compare 1B interrupt enable (T0 disable)
  5c:	80 e2       	ldi	r24, 0x20	; 32
  5e:	89 bf       	out	0x39, r24	; 57

                                                                        //PWM settings (use OC1B)
    TCCR1A = 0x21;                                      //COM1B1=H, COM1B0=L, PWM1B=H
  60:	81 e2       	ldi	r24, 0x21	; 33
  62:	80 bf       	out	0x30, r24	; 48
    TCCR1B = 0x80;                                      //CTC1=H, T1-stoped
  64:	80 e8       	ldi	r24, 0x80	; 128
  66:	8f bd       	out	0x2f, r24	; 47
    OCR1C = 187;                                            //upper limit T1 (3000us)
  68:	8b eb       	ldi	r24, 0xBB	; 187
  6a:	8b bd       	out	0x2b, r24	; 43
    for(m=0;m<nmbr;m++)
  6c:	2e 2f       	mov	r18, r30
  6e:	e3 17       	cp	r30, r19
  70:	d8 f4       	brcc	.+54     	; 0xa8 <send+0x5c>
  72:	60 e7       	ldi	r22, 0x70	; 112
  74:	55 e2       	ldi	r21, 0x25	; 37
  76:	45 e8       	ldi	r20, 0x85	; 133
    {
        s_temp=*(S_BUS+m);                              //copy byte to temp
  78:	e2 2f       	mov	r30, r18
  7a:	ff 27       	eor	r31, r31
  7c:	e5 58       	subi	r30, 0x85	; 133
  7e:	ff 4f       	sbci	r31, 0xFF	; 255
  80:	e0 81       	ld	r30, Z
        for(n=4;n>0;n--)                                    //4 times - 4 bits
  82:	94 e0       	ldi	r25, 0x04	; 4
        {
                                                //put the value to compare register
            if(s_temp&0x08) OCR1B = 112;                        //if bit is 1 (1800us)
  84:	e3 ff       	sbrs	r30, 3
  86:	02 c0       	rjmp	.+4      	; 0x8c <send+0x40>
  88:	6c bd       	out	0x2c, r22	; 44
  8a:	01 c0       	rjmp	.+2      	; 0x8e <send+0x42>
            else            OCR1B = 37;                     //if bit is 0 (600us)
  8c:	5c bd       	out	0x2c, r21	; 44
            TCCR1B = 0x85;                                      //start T1 with prescaler clk/16
  8e:	4f bd       	out	0x2f, r20	; 47
            s_temp = (s_temp << 1);                         //shift temp left 1 time
  90:	ee 0f       	add	r30, r30
            while (s_flag==0);
  92:	80 91 76 00 	lds	r24, 0x0076
  96:	88 23       	and	r24, r24
  98:	e1 f3       	breq	.-8      	; 0x92 <send+0x46>
            s_flag = 0;                             //reset flag
  9a:	10 92 76 00 	sts	0x0076, r1
  9e:	91 50       	subi	r25, 0x01	; 1
  a0:	89 f7       	brne	.-30     	; 0x84 <send+0x38>
  a2:	2f 5f       	subi	r18, 0xFF	; 255
  a4:	23 17       	cp	r18, r19
  a6:	40 f3       	brcs	.-48     	; 0x78 <send+0x2c>

        }
    }
    TCCR1B = 0x80;                                      //CTC1=H, T1-stoped
  a8:	80 e8       	ldi	r24, 0x80	; 128
  aa:	8f bd       	out	0x2f, r24	; 47
    TIMSK = 0x02;                                       //T0 overflow interrupt enable
  ac:	82 e0       	ldi	r24, 0x02	; 2
  ae:	89 bf       	out	0x39, r24	; 57
    MCUCR = 0x03;                                       //INT0 rising edge sensitive
  b0:	83 e0       	ldi	r24, 0x03	; 3
  b2:	85 bf       	out	0x35, r24	; 53
    GIMSK |= 0x40;                                      //INT0 interrupt enable
  b4:	8b b7       	in	r24, 0x3b	; 59
  b6:	80 64       	ori	r24, 0x40	; 64
  b8:	8b bf       	out	0x3b, r24	; 59
    s_flag = 0;                                     //reset flag
  ba:	10 92 76 00 	sts	0x0076, r1
    bus_busy=0;                                     //reset flag "bus is busy"
  be:	10 92 77 00 	sts	0x0077, r1
  c2:	08 95       	ret

000000c4 <ping_ok>:
/****************************Ping_Ok***********************************************/
/*********************************************************************************/
void ping_ok(void)
{
Trame_Locale[0]=RESPONSE_START;
  c4:	89 e0       	ldi	r24, 0x09	; 9
  c6:	80 93 62 00 	sts	0x0062, r24
Trame_Locale[1]=PING_OK;
  ca:	88 e0       	ldi	r24, 0x08	; 8
  cc:	80 93 63 00 	sts	0x0063, r24

send_frame(&Trame_Locale[0],PING_OK_LENGTH);
  d0:	62 e0       	ldi	r22, 0x02	; 2
  d2:	70 e0       	ldi	r23, 0x00	; 0
  d4:	82 e6       	ldi	r24, 0x62	; 98
  d6:	90 e0       	ldi	r25, 0x00	; 0
  d8:	25 d0       	rcall	.+74     	; 0x124 <send_frame>
  da:	08 95       	ret

000000dc <Compute_CRC>:
#include "M_BUS_Modules.h"

char Compute_CRC (char *Buffer_Ptr, unsigned char number_chars)									//count CRC, and put it
{												//in the last send location
	unsigned char temp =0;
  dc:	20 e0       	ldi	r18, 0x00	; 0
	unsigned char n ;
	for (n=0;n<number_chars;n++)
  de:	32 2f       	mov	r19, r18
  e0:	26 17       	cp	r18, r22
  e2:	38 f4       	brcc	.+14     	; 0xf2 <__stack+0x13>
  e4:	f9 2f       	mov	r31, r25
  e6:	e8 2f       	mov	r30, r24
	{
		temp = Buffer_Ptr[n] ^ temp;								//XOR all bytes
  e8:	81 91       	ld	r24, Z+
  ea:	28 27       	eor	r18, r24
  ec:	3f 5f       	subi	r19, 0xFF	; 255
  ee:	36 17       	cp	r19, r22
  f0:	d8 f3       	brcs	.-10     	; 0xe8 <__stack+0x9>
	}
	temp++;											                //and increment
  f2:	2f 5f       	subi	r18, 0xFF	; 255
	if (temp>15) temp=0;									//reset if too big
  f4:	20 31       	cpi	r18, 0x10	; 16
  f6:	08 f0       	brcs	.+2      	; 0xfa <__stack+0x1b>
  f8:	20 e0       	ldi	r18, 0x00	; 0

    return temp;
}
  fa:	82 2f       	mov	r24, r18
  fc:	99 27       	eor	r25, r25
  fe:	08 95       	ret

00000100 <init>:
#include <avr/interrupt.h>
#include "M_BUS_Modules.h"
void init(void)
{
	DDRA = 0xff;					//DB7,  DB6,  DB5,  DB4,  RS,   S2,   S1,   E
 100:	8f ef       	ldi	r24, 0xFF	; 255
 102:	8a bb       	out	0x1a, r24	; 26
												//PA7   PA6   PA5   PA4   PA3   PA2   PA1   PA0
												// O     O     O     O     O     O     O     O
												// 1     1     1     1     1     1     1     1

	PORTA = 0xfe;					// 1     1     1     1     1     1     1     0
 104:	8e ef       	ldi	r24, 0xFE	; 254
 106:	8b bb       	out	0x1b, r24	; 27

	DDRB = 0x0e;					//RES,  INT0, SW'S, NC,   OC1B, SCK,  MISO, MOSI
 108:	8e e0       	ldi	r24, 0x0E	; 14
 10a:	87 bb       	out	0x17, r24	; 23
	     										//PB7   PB6   PB5   PB4   PB3   PB2   PB1   PB0
												// I     I     I     I     O     O     O     I
												// 0     0     0     0     1     1     1     0

	PORTB = 0x42;					// 0     1     0     0     0     0     1     0
 10c:	82 e4       	ldi	r24, 0x42	; 66
 10e:	88 bb       	out	0x18, r24	; 24

	TIMSK |= 0x02;				//T0 overflow interrupt enable
 110:	89 b7       	in	r24, 0x39	; 57
 112:	82 60       	ori	r24, 0x02	; 2
 114:	89 bf       	out	0x39, r24	; 57
	MCUCR = 0x03;				//INT0 rising edge sensitive
 116:	83 e0       	ldi	r24, 0x03	; 3
 118:	85 bf       	out	0x35, r24	; 53
	GIMSK |= 0x40;				//INT0 interrupt enable
 11a:	8b b7       	in	r24, 0x3b	; 59
 11c:	80 64       	ori	r24, 0x40	; 64
 11e:	8b bf       	out	0x3b, r24	; 59
	sei();	 								 //global interrupt enable
 120:	78 94       	sei
 122:	08 95       	ret

00000124 <send_frame>:
#include "M_BUS_Modules.h"
#include "M_BUS_data.h"
//*********************************************************************************
void send_frame(char *Frame_Char_Ptr,int Frame_Lenght)
{
 124:	0f 93       	push	r16
 126:	1f 93       	push	r17
 128:	cf 93       	push	r28
 12a:	df 93       	push	r29
 12c:	d7 2f       	mov	r29, r23
 12e:	c6 2f       	mov	r28, r22
int i;
for (i =0; i < Frame_Lenght; i++)
 130:	20 e0       	ldi	r18, 0x00	; 0
 132:	30 e0       	ldi	r19, 0x00	; 0
 134:	26 17       	cp	r18, r22
 136:	37 07       	cpc	r19, r23
 138:	5c f4       	brge	.+22     	; 0x150 <send_frame+0x2c>
 13a:	ab e7       	ldi	r26, 0x7B	; 123
 13c:	b0 e0       	ldi	r27, 0x00	; 0
 13e:	f9 2f       	mov	r31, r25
 140:	e8 2f       	mov	r30, r24
    {
    S_BUS[i]=Frame_Char_Ptr[i];
 142:	81 91       	ld	r24, Z+
 144:	8d 93       	st	X+, r24
 146:	2f 5f       	subi	r18, 0xFF	; 255
 148:	3f 4f       	sbci	r19, 0xFF	; 255
 14a:	2c 17       	cp	r18, r28
 14c:	3d 07       	cpc	r19, r29
 14e:	cc f3       	brlt	.-14     	; 0x142 <send_frame+0x1e>
    }
// Compute the CRC
S_BUS[Frame_Lenght]=Compute_CRC (&(S_BUS[0]), Frame_Lenght);
 150:	0c 2f       	mov	r16, r28
 152:	1d 2f       	mov	r17, r29
 154:	05 58       	subi	r16, 0x85	; 133
 156:	1f 4f       	sbci	r17, 0xFF	; 255
 158:	6c 2f       	mov	r22, r28
 15a:	8b e7       	ldi	r24, 0x7B	; 123
 15c:	90 e0       	ldi	r25, 0x00	; 0
 15e:	be df       	rcall	.-132    	; 0xdc <Compute_CRC>
 160:	f1 2f       	mov	r31, r17
 162:	e0 2f       	mov	r30, r16
 164:	80 83       	st	Z, r24
Frame_Lenght++;
// Send the frame
send(Frame_Lenght);
 166:	8c 2f       	mov	r24, r28
 168:	8f 5f       	subi	r24, 0xFF	; 255
 16a:	70 df       	rcall	.-288    	; 0x4c <send>
 16c:	df 91       	pop	r29
 16e:	cf 91       	pop	r28
 170:	1f 91       	pop	r17
 172:	0f 91       	pop	r16
 174:	08 95       	ret

00000176 <__vector_1>:
/*********************************************************************************/
/* Ce handler se déclenche sur front du signal d'entrée                                                                     */
/*********************************************************************************/
SIGNAL (SIG_INTERRUPT0)                                     //INT0 interrupt handler
{
 176:	1f 92       	push	r1
 178:	0f 92       	push	r0
 17a:	0f b6       	in	r0, 0x3f	; 63
 17c:	0f 92       	push	r0
 17e:	11 24       	eor	r1, r1
 180:	8f 93       	push	r24
 182:	9f 93       	push	r25
 184:	ef 93       	push	r30
 186:	ff 93       	push	r31
    bus_busy = 1;                                                                   //set flag "bus is busy"
 188:	91 e0       	ldi	r25, 0x01	; 1
 18a:	90 93 77 00 	sts	0x0077, r25
	/* -----------------------------------------------------------------------------------------------------------------  */
	/* Le front montant désigne le début d'un bit.                                                                                 */
    /*  Sur un front montant du signal (Entrée lue à 1) :                                                                       */
	/*  1 - On inhibe l'interruption INTO                                                                                              */
	/*  2 - On paramètre le déclenchement de l'interruption sur front descendant du signal           */
	/*  3 - On réactive l'interruption                                                                                                     */
	/*  4 - On démarre le timer T0 en lui donnant Commentaires valeur 186.                                    */
	/*  5 - On paramètre le prescaler à CLK/64, ce qui redémarre le compteur                                */
	/* ----------------------------------------------------------------------------------------------------------------- */
    if (PINB & 0x40)                                        //if INT0 = 1
 18e:	b6 9b       	sbis	0x16, 6	; 22
 190:	0c c0       	rjmp	.+24     	; 0x1aa <__vector_1+0x34>
    {
        GIMSK &= 0xbf;                                  //INT0 interrupt disable
 192:	8b b7       	in	r24, 0x3b	; 59
 194:	8f 7b       	andi	r24, 0xBF	; 191
 196:	8b bf       	out	0x3b, r24	; 59
        MCUCR = 0x02;                                   //INT0 falling edge sensitive
 198:	82 e0       	ldi	r24, 0x02	; 2
 19a:	85 bf       	out	0x35, r24	; 53
        GIMSK |= 0x40;                                  //INT0 interrupt enable
 19c:	8b b7       	in	r24, 0x3b	; 59
 19e:	80 64       	ori	r24, 0x40	; 64
 1a0:	8b bf       	out	0x3b, r24	; 59
        TCNT0 = 186;                                    //start T0 with the value
 1a2:	8a eb       	ldi	r24, 0xBA	; 186
 1a4:	82 bf       	out	0x32, r24	; 50
        TCCR0 = 0x0b;                                   //and prescaler CLK/64 (reset prescaler)
 1a6:	8b e0       	ldi	r24, 0x0B	; 11
 1a8:	83 bf       	out	0x33, r24	; 51
    }
	/* -----------------------------------------------------------------------------------------------------------------  */
	/* Le front descendant désigne la fin d'un bit.                                                                               */
    /*  Sur un front descendant du signal (Entrée lue à 0) :                                                                 */
	/*  1 - On évalue la durée du bit pour déterminer si c'est un bit 0 ou un bit 1                              */
	/*  2 - On enregistre le bit dans le queue de reception                                                                  */
	/* ----------------------------------------------------------------------------------------------------------------- */
    if (!(PINB & 0x40))                                     //if INT0 = 0
 1aa:	b6 99       	sbic	0x16, 6	; 22
 1ac:	3f c0       	rjmp	.+126    	; 0x22c <__vector_1+0xb6>
    {
        if (TCNT0 > 208)                                   // Si la durée du front > 1.3 ms alors c'est un 1
 1ae:	82 b7       	in	r24, 0x32	; 50
 1b0:	81 3d       	cpi	r24, 0xD1	; 209
 1b2:	28 f0       	brcs	.+10     	; 0x1be <__vector_1+0x48>
			{
			bus_byte ++;
 1b4:	80 91 7a 00 	lds	r24, 0x007A
 1b8:	8f 5f       	subi	r24, 0xFF	; 255
 1ba:	80 93 7a 00 	sts	0x007A, r24
			}
        bus_byte = (bus_byte << 1);                             //shift byte left
 1be:	80 91 7a 00 	lds	r24, 0x007A
 1c2:	88 0f       	add	r24, r24
 1c4:	80 93 7a 00 	sts	0x007A, r24
        n_bit++;                                        //inc bit number
 1c8:	80 91 79 00 	lds	r24, 0x0079
 1cc:	8f 5f       	subi	r24, 0xFF	; 255
 1ce:	80 93 79 00 	sts	0x0079, r24
        if (n_bit == 4)                                 //if bit number is 4
 1d2:	80 91 79 00 	lds	r24, 0x0079
 1d6:	84 30       	cpi	r24, 0x04	; 4
 1d8:	09 f5       	brne	.+66     	; 0x21c <__vector_1+0xa6>
        {
            n_bit = 0;                                  //reset bit number
 1da:	10 92 79 00 	sts	0x0079, r1
            bus_byte = (bus_byte >> 1);                         //correction of shifting
 1de:	80 91 7a 00 	lds	r24, 0x007A
 1e2:	86 95       	lsr	r24
 1e4:	80 93 7a 00 	sts	0x007A, r24
            *(R_BUS + n_byte)=bus_byte;                     //put the byte in table
 1e8:	80 91 78 00 	lds	r24, 0x0078
 1ec:	e8 2f       	mov	r30, r24
 1ee:	ff 27       	eor	r31, r31
 1f0:	e5 57       	subi	r30, 0x75	; 117
 1f2:	ff 4f       	sbci	r31, 0xFF	; 255
 1f4:	80 91 7a 00 	lds	r24, 0x007A
 1f8:	80 83       	st	Z, r24
            bus_byte = 0;                               //reset byte
 1fa:	10 92 7a 00 	sts	0x007A, r1
            n_byte++;                               //inc byte number
 1fe:	80 91 78 00 	lds	r24, 0x0078
 202:	8f 5f       	subi	r24, 0xFF	; 255
 204:	80 93 78 00 	sts	0x0078, r24

			// robustesse : La taille de R_BUS est de 16
            if (n_byte == 16)                               //if byte number is 16
 208:	80 91 78 00 	lds	r24, 0x0078
 20c:	80 31       	cpi	r24, 0x10	; 16
 20e:	31 f4       	brne	.+12     	; 0x21c <__vector_1+0xa6>
            {
                n_byte = 0;                         //reset byte number
 210:	10 92 78 00 	sts	0x0078, r1
                received = 1;                           //set M-Bus receive flag
 214:	90 93 9b 00 	sts	0x009B, r25
                bus_busy = 0;                           //reset flag "bus is busy"
 218:	10 92 77 00 	sts	0x0077, r1
            }
        }
    GIMSK &= 0xbf;                                      //INT0 interrupt disable
 21c:	8b b7       	in	r24, 0x3b	; 59
 21e:	8f 7b       	andi	r24, 0xBF	; 191
 220:	8b bf       	out	0x3b, r24	; 59
    MCUCR = 0x03;                                       //INT0 rising edge sensitive
 222:	83 e0       	ldi	r24, 0x03	; 3
 224:	85 bf       	out	0x35, r24	; 53
    GIMSK |= 0x40;                                      //INT0 interrupt enable
 226:	8b b7       	in	r24, 0x3b	; 59
 228:	80 64       	ori	r24, 0x40	; 64
 22a:	8b bf       	out	0x3b, r24	; 59
 22c:	ff 91       	pop	r31
 22e:	ef 91       	pop	r30
 230:	9f 91       	pop	r25
 232:	8f 91       	pop	r24
 234:	0f 90       	pop	r0
 236:	0f be       	out	0x3f, r0	; 63
 238:	0f 90       	pop	r0
 23a:	1f 90       	pop	r1
 23c:	18 95       	reti

0000023e <__vector_6>:
    }
}

/* -----------------------------------------------------------------------------------------------------------------  */
/* Le SIGNAL_OVERFLOW indique que le compteur a dépassé sa valeur maximale                 */
/* A rappeler que l'overflow n'arrive que si un front montant à été vu, donc quand un bit        */
/*  a été reçu (un bit commençant par un front montant.                                                                */
/* Normalement quand une trame est reçue, les bit s'enchainent donc l'overflow n'est en        */
/* en principe possible que lorque l'autoradio à terminé sa trame                                                */
/* ------------------------------------------------------------------------------------------------------------------ */
SIGNAL (SIG_OVERFLOW0)                                  //T0 overflow interrupt handler
{
 23e:	1f 92       	push	r1
 240:	0f 92       	push	r0
 242:	0f b6       	in	r0, 0x3f	; 63
 244:	0f 92       	push	r0
 246:	11 24       	eor	r1, r1
 248:	8f 93       	push	r24
    TCCR0 = 0x00;                                       //stop T0
 24a:	13 be       	out	0x33, r1	; 51
    n_bit = 0;                                          //reset bit number
 24c:	10 92 79 00 	sts	0x0079, r1
    n_byte = 0;                                     //reset byte number
 250:	10 92 78 00 	sts	0x0078, r1
    bus_byte = 0;                                       //reset byte
 254:	10 92 7a 00 	sts	0x007A, r1
    received = 1;                                       //set M-Bus receive flag
 258:	81 e0       	ldi	r24, 0x01	; 1
 25a:	80 93 9b 00 	sts	0x009B, r24
    bus_busy = 0;                                       //reset flag "bus is busy"
 25e:	10 92 77 00 	sts	0x0077, r1
 262:	8f 91       	pop	r24
 264:	0f 90       	pop	r0
 266:	0f be       	out	0x3f, r0	; 63
 268:	0f 90       	pop	r0
 26a:	1f 90       	pop	r1
 26c:	18 95       	reti

0000026e <__vector_4>:
}

/*********************************************************************************/
SIGNAL (SIG_OUTPUT_COMPARE1B)                                           //T1 compare 1B interrupt handler
{
 26e:	1f 92       	push	r1
 270:	0f 92       	push	r0
 272:	0f b6       	in	r0, 0x3f	; 63
 274:	0f 92       	push	r0
 276:	11 24       	eor	r1, r1
 278:	8f 93       	push	r24
    s_flag = 1;                                     //set flag
 27a:	81 e0       	ldi	r24, 0x01	; 1
 27c:	80 93 76 00 	sts	0x0076, r24
 280:	8f 91       	pop	r24
 282:	0f 90       	pop	r0
 284:	0f be       	out	0x3f, r0	; 63
 286:	0f 90       	pop	r0
 288:	1f 90       	pop	r1
 28a:	18 95       	reti

0000028c <Ack_Play_State>:
#include "M_BUS_data.h"
//*********************************************************************************
void Ack_Play_State(char  Play_State, char Flag_1, char Flag_2, char Flag_3)
{
Trame_Locale[0]=RESPONSE_START;
 28c:	99 e0       	ldi	r25, 0x09	; 9
 28e:	90 93 62 00 	sts	0x0062, r25
Trame_Locale[1]=GIVE_PLAY_STATE ;
 292:	90 93 63 00 	sts	0x0063, r25
Trame_Locale[2]=Play_State;
 296:	80 93 64 00 	sts	0x0064, r24
//Track
Trame_Locale[3]=0x00;
 29a:	10 92 65 00 	sts	0x0065, r1
Trame_Locale[4]=0x01;
 29e:	81 e0       	ldi	r24, 0x01	; 1
 2a0:	80 93 66 00 	sts	0x0066, r24
// Index
Trame_Locale[5]=0x00;
 2a4:	10 92 67 00 	sts	0x0067, r1
Trame_Locale[6]=0x01;
 2a8:	80 93 68 00 	sts	0x0068, r24
// Min
Trame_Locale[7]=0x00;
 2ac:	10 92 69 00 	sts	0x0069, r1
Trame_Locale[8]=0x00;
 2b0:	10 92 6a 00 	sts	0x006A, r1
// Sec
Trame_Locale[9]=0x00;
 2b4:	10 92 6b 00 	sts	0x006B, r1
Trame_Locale[10]=0x01;
 2b8:	80 93 6c 00 	sts	0x006C, r24
// Flag_1
Trame_Locale[11]=Flag_1;
 2bc:	60 93 6d 00 	sts	0x006D, r22
// Flag_2
Trame_Locale[12]=Flag_2;
 2c0:	40 93 6e 00 	sts	0x006E, r20
// Constante a 0x00
Trame_Locale[13]=0x00;
 2c4:	10 92 6f 00 	sts	0x006F, r1
// Flag_3
Trame_Locale[14]=Flag_3;
 2c8:	20 93 70 00 	sts	0x0070, r18

send_frame(&Trame_Locale[0],PLAY_STATE_LENGTH);
 2cc:	6f e0       	ldi	r22, 0x0F	; 15
 2ce:	70 e0       	ldi	r23, 0x00	; 0
 2d0:	82 e6       	ldi	r24, 0x62	; 98
 2d2:	90 e0       	ldi	r25, 0x00	; 0
 2d4:	27 df       	rcall	.-434    	; 0x124 <send_frame>
 2d6:	08 95       	ret

000002d8 <Ack_Wait>:
/****************************Ack_Wait***********************************************/
/*********************************************************************************/
void  Ack_Wait(void)
{
Trame_Locale[0]=RESPONSE_START;
 2d8:	89 e0       	ldi	r24, 0x09	; 9
 2da:	80 93 62 00 	sts	0x0062, r24
Trame_Locale[1]=ACK_WAIT ;
 2de:	8f e0       	ldi	r24, 0x0F	; 15
 2e0:	80 93 63 00 	sts	0x0063, r24
Trame_Locale[2]=0x00;
 2e4:	10 92 64 00 	sts	0x0064, r1
Trame_Locale[3]=0x00;
 2e8:	10 92 65 00 	sts	0x0065, r1
Trame_Locale[4]=0x00;
 2ec:	10 92 66 00 	sts	0x0066, r1
Trame_Locale[5]=0x00;
 2f0:	10 92 67 00 	sts	0x0067, r1
Trame_Locale[6]=0x00;
 2f4:	10 92 68 00 	sts	0x0068, r1

send_frame(&Trame_Locale[0],ACK_WAIT_LENGTH);
 2f8:	67 e0       	ldi	r22, 0x07	; 7
 2fa:	70 e0       	ldi	r23, 0x00	; 0
 2fc:	82 e6       	ldi	r24, 0x62	; 98
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	11 df       	rcall	.-478    	; 0x124 <send_frame>
 302:	08 95       	ret

00000304 <Ack_Change_Disk>:
#include "M_BUS_data.h"
//*********************************************************************************
void Ack_Change_Disk(void)
{
Trame_Locale[0]=RESPONSE_START;
 304:	89 e0       	ldi	r24, 0x09	; 9
 306:	80 93 62 00 	sts	0x0062, r24
Trame_Locale[1]=GIVE_CHANGING_INFO ;
 30a:	9b e0       	ldi	r25, 0x0B	; 11
 30c:	90 93 63 00 	sts	0x0063, r25
Trame_Locale[2]=0x09;  // CHANGING OK
 310:	80 93 64 00 	sts	0x0064, r24
//Disk
Trame_Locale[3]=0x01;
 314:	81 e0       	ldi	r24, 0x01	; 1
 316:	80 93 65 00 	sts	0x0065, r24
// Track
Trame_Locale[4]=0x00;
 31a:	10 92 66 00 	sts	0x0066, r1
Trame_Locale[5]=0x01;
 31e:	80 93 67 00 	sts	0x0067, r24
// Flag 1
Trame_Locale[6]=0x00;
 322:	10 92 68 00 	sts	0x0068, r1
// Flag 2
Trame_Locale[7]=0x00;
 326:	10 92 69 00 	sts	0x0069, r1
// Flag 3
Trame_Locale[8]=0x00;
 32a:	10 92 6a 00 	sts	0x006A, r1
// Flag 4
Trame_Locale[9]=0x00;
 32e:	10 92 6b 00 	sts	0x006B, r1
// Flag 5
Trame_Locale[10]=0x01; // Done
 332:	80 93 6c 00 	sts	0x006C, r24

send_frame(&Trame_Locale[0],CHANGING_INFO_LENGTH);
 336:	6b e0       	ldi	r22, 0x0B	; 11
 338:	70 e0       	ldi	r23, 0x00	; 0
 33a:	82 e6       	ldi	r24, 0x62	; 98
 33c:	90 e0       	ldi	r25, 0x00	; 0
 33e:	f2 de       	rcall	.-540    	; 0x124 <send_frame>
 340:	08 95       	ret

00000342 <Ack_Disk_Info>:
#include "M_BUS_data.h"
//*********************************************************************************
void Ack_Disk_Info(void)
{
Trame_Locale[0]=RESPONSE_START;
 342:	99 e0       	ldi	r25, 0x09	; 9
 344:	90 93 62 00 	sts	0x0062, r25
Trame_Locale[1]=GIVE_DISK_INFO ;
 348:	8c e0       	ldi	r24, 0x0C	; 12
 34a:	80 93 63 00 	sts	0x0063, r24
// Disk
Trame_Locale[2]=0x01;
 34e:	81 e0       	ldi	r24, 0x01	; 1
 350:	80 93 64 00 	sts	0x0064, r24
// ??
Trame_Locale[3]=0x00;
 354:	10 92 65 00 	sts	0x0065, r1
Trame_Locale[4]=0x01;
 358:	80 93 66 00 	sts	0x0066, r24
// Tracks
Trame_Locale[5]=0x09;
 35c:	90 93 67 00 	sts	0x0067, r25
Trame_Locale[6]=0x09;
 360:	90 93 68 00 	sts	0x0068, r25
// Min
Trame_Locale[7]=0x05;
 364:	85 e0       	ldi	r24, 0x05	; 5
 366:	80 93 69 00 	sts	0x0069, r24
Trame_Locale[8]=0x05;
 36a:	80 93 6a 00 	sts	0x006A, r24
// Sec
Trame_Locale[9]=0x05;
 36e:	80 93 6b 00 	sts	0x006B, r24
Trame_Locale[10]=0x05;
 372:	80 93 6c 00 	sts	0x006C, r24
// Flag 1
Trame_Locale[11]=0x00;
 376:	10 92 6d 00 	sts	0x006D, r1
send_frame(&Trame_Locale[0],DISK_INFO_LENGTH);
 37a:	6c e0       	ldi	r22, 0x0C	; 12
 37c:	70 e0       	ldi	r23, 0x00	; 0
 37e:	82 e6       	ldi	r24, 0x62	; 98
 380:	90 e0       	ldi	r25, 0x00	; 0
 382:	d0 de       	rcall	.-608    	; 0x124 <send_frame>
 384:	08 95       	ret

00000386 <Decode_Received>:
#include "M_BUS_data.h"
//************************************ main program *******************************
void Decode_Received(void)
{
	Request_Id=R_BUS[1];
 386:	80 91 8c 00 	lds	r24, 0x008C
 38a:	80 93 73 00 	sts	0x0073, r24
	switch (Request_Id)
 38e:	99 27       	eor	r25, r25
 390:	88 30       	cpi	r24, 0x08	; 8
 392:	91 05       	cpc	r25, r1
 394:	09 f4       	brne	.+2      	; 0x398 <Decode_Received+0x12>
 396:	44 c0       	rjmp	.+136    	; 0x420 <Decode_Received+0x9a>
 398:	89 30       	cpi	r24, 0x09	; 9
 39a:	91 05       	cpc	r25, r1
 39c:	1c f4       	brge	.+6      	; 0x3a4 <Decode_Received+0x1e>
 39e:	01 97       	sbiw	r24, 0x01	; 1
 3a0:	29 f0       	breq	.+10     	; 0x3ac <Decode_Received+0x26>
 3a2:	42 c0       	rjmp	.+132    	; 0x428 <Decode_Received+0xa2>
 3a4:	09 97       	sbiw	r24, 0x09	; 9
 3a6:	09 f4       	brne	.+2      	; 0x3aa <Decode_Received+0x24>
 3a8:	3d c0       	rjmp	.+122    	; 0x424 <Decode_Received+0x9e>
 3aa:	3e c0       	rjmp	.+124    	; 0x428 <Decode_Received+0xa2>
	{
		case SETTTING:
				Commande_Type=R_BUS[2];
 3ac:	80 91 8d 00 	lds	r24, 0x008D
 3b0:	80 93 72 00 	sts	0x0072, r24

				switch (Commande_Type)
 3b4:	99 27       	eor	r25, r25
 3b6:	83 30       	cpi	r24, 0x03	; 3
 3b8:	91 05       	cpc	r25, r1
 3ba:	b9 f0       	breq	.+46     	; 0x3ea <Decode_Received+0x64>
 3bc:	84 30       	cpi	r24, 0x04	; 4
 3be:	91 05       	cpc	r25, r1
 3c0:	1c f4       	brge	.+6      	; 0x3c8 <Decode_Received+0x42>
 3c2:	01 97       	sbiw	r24, 0x01	; 1
 3c4:	21 f0       	breq	.+8      	; 0x3ce <Decode_Received+0x48>
 3c6:	30 c0       	rjmp	.+96     	; 0x428 <Decode_Received+0xa2>
 3c8:	04 97       	sbiw	r24, 0x04	; 4
 3ca:	09 f1       	breq	.+66     	; 0x40e <Decode_Received+0x88>
 3cc:	2d c0       	rjmp	.+90     	; 0x428 <Decode_Received+0xa2>
				{
					case SET_PLAY_STATE:
						Actual_Play_State	=  ( (R_BUS[3] & 0x04)*2 ) | ( R_BUS[4] & 0x03 );
 3ce:	80 91 8e 00 	lds	r24, 0x008E
 3d2:	99 27       	eor	r25, r25
 3d4:	84 70       	andi	r24, 0x04	; 4
 3d6:	90 70       	andi	r25, 0x00	; 0
 3d8:	88 0f       	add	r24, r24
 3da:	99 1f       	adc	r25, r25
 3dc:	20 91 8f 00 	lds	r18, 0x008F
 3e0:	23 70       	andi	r18, 0x03	; 3
 3e2:	28 2b       	or	r18, r24
 3e4:	20 93 60 00 	sts	0x0060, r18
 3e8:	08 c0       	rjmp	.+16     	; 0x3fa <Decode_Received+0x74>
						Ack_Play_State (Last_Play_State, Actual_Repeat_Mode, Actual_Prog_Mode, Actual_Play_State);
						// Mise à jour de l'état de lecture actuel - Pour le moment on cinsidère qu'on est toujours en mode Play
						//Actual_Play_State = ;
					break;

					case SET_MEDIA:
						// Changement de Disque OK
						Ack_Change_Disk();
 3ea:	8c df       	rcall	.-232    	; 0x304 <Ack_Change_Disk>
						// Attendre 100 ms
						loop_ms(100);
 3ec:	84 e6       	ldi	r24, 0x64	; 100
 3ee:	90 e0       	ldi	r25, 0x00	; 0
 3f0:	1f d0       	rcall	.+62     	; 0x430 <loop_ms>
						// Status Disque
						Ack_Disk_Info();
 3f2:	a7 df       	rcall	.-178    	; 0x342 <Ack_Disk_Info>
						// Attendre 100 ms
						loop_ms(100);
 3f4:	84 e6       	ldi	r24, 0x64	; 100
 3f6:	90 e0       	ldi	r25, 0x00	; 0
 3f8:	1b d0       	rcall	.+54     	; 0x430 <loop_ms>
						// Play State
						Ack_Play_State (Last_Play_State, Actual_Repeat_Mode, Actual_Prog_Mode, Actual_Play_State);
 3fa:	20 91 60 00 	lds	r18, 0x0060
 3fe:	40 91 74 00 	lds	r20, 0x0074
 402:	60 91 75 00 	lds	r22, 0x0075
 406:	80 91 61 00 	lds	r24, 0x0061
 40a:	40 df       	rcall	.-384    	; 0x28c <Ack_Play_State>
					break;
 40c:	0e c0       	rjmp	.+28     	; 0x42a <Decode_Received+0xa4>

					case SET_PLAY_MODE :
						// Il n'y a pas de réponse particulière à cette requête.
						Actual_Repeat_Mode = R_BUS[3];
 40e:	80 91 8e 00 	lds	r24, 0x008E
 412:	80 93 75 00 	sts	0x0075, r24
						Actual_Prog_Mode = R_BUS[4];
 416:	80 91 8f 00 	lds	r24, 0x008F
 41a:	80 93 74 00 	sts	0x0074, r24
					break;
 41e:	05 c0       	rjmp	.+10     	; 0x42a <Decode_Received+0xa4>

					default:
						Ack_Wait();
					break;
				}
		break;
		case PING:                                                // PING
				ping_ok();
 420:	51 de       	rcall	.-862    	; 0xc4 <ping_ok>
		break;
 422:	03 c0       	rjmp	.+6      	; 0x42a <Decode_Received+0xa4>
		case POWER_UP:                                  // POWER_UP
				Ack_Power_Up();
 424:	24 d0       	rcall	.+72     	; 0x46e <Ack_Power_Up>
		break;
 426:	01 c0       	rjmp	.+2      	; 0x42a <Decode_Received+0xa4>
		default:
				Ack_Wait();
 428:	57 df       	rcall	.-338    	; 0x2d8 <Ack_Wait>
		break;
	}
    received = 0;                               //reset M-Bus receive flag
 42a:	10 92 9b 00 	sts	0x009B, r1
 42e:	08 95       	ret

00000430 <loop_ms>:
#include "M_BUS_Modules.h"

/*************************** Loop_Ms ***********************************************/
void loop_ms(int ms)                                        //time loop => one loop = 1 ms
{
 430:	0f 93       	push	r16
 432:	1f 93       	push	r17
 434:	cf 93       	push	r28
 436:	df 93       	push	r29
 438:	08 2f       	mov	r16, r24
 43a:	19 2f       	mov	r17, r25
/*      Local data          */
    int boucle_ms;
/***********************/
        for(boucle_ms=0;boucle_ms<ms;boucle_ms++)
 43c:	c0 e0       	ldi	r28, 0x00	; 0
 43e:	d0 e0       	ldi	r29, 0x00	; 0
 440:	c8 17       	cp	r28, r24
 442:	d9 07       	cpc	r29, r25
 444:	3c f4       	brge	.+14     	; 0x454 <loop_ms+0x24>
    {
    time_loop(100);
 446:	84 e6       	ldi	r24, 0x64	; 100
 448:	90 e0       	ldi	r25, 0x00	; 0
 44a:	09 d0       	rcall	.+18     	; 0x45e <time_loop>
 44c:	21 96       	adiw	r28, 0x01	; 1
 44e:	c0 17       	cp	r28, r16
 450:	d1 07       	cpc	r29, r17
 452:	cc f3       	brlt	.-14     	; 0x446 <loop_ms+0x16>
 454:	df 91       	pop	r29
 456:	cf 91       	pop	r28
 458:	1f 91       	pop	r17
 45a:	0f 91       	pop	r16
 45c:	08 95       	ret

0000045e <time_loop>:

/****************************Time_Loop ***********************************************/
void time_loop(int tenmicros)                                       //time loop => one loop = 10 us
{
    for(;tenmicros>0;tenmicros--)
 45e:	18 16       	cp	r1, r24
 460:	19 06       	cpc	r1, r25
 462:	24 f4       	brge	.+8      	; 0x46c <time_loop+0xe>
    {
        asm volatile ("push r1""\n\t"
 464:	1f 92       	push	r1
 466:	1f 90       	pop	r1
 468:	01 97       	sbiw	r24, 0x01	; 1
 46a:	f9 cf       	rjmp	.-14     	; 0x45e <time_loop>
 46c:	08 95       	ret

0000046e <Ack_Power_Up>:
#include "M_BUS_Modules.h"
#include "M_BUS_data.h"
//*********************************************************************************
void Ack_Power_Up(void)
{
 46e:	ef 92       	push	r14
 470:	ff 92       	push	r15
 472:	0f 93       	push	r16
 474:	1f 93       	push	r17
Ack_Disk_Info();
 476:	65 df       	rcall	.-310    	; 0x342 <Ack_Disk_Info>

// Attendre 100 ms
loop_ms(100);
 478:	84 e6       	ldi	r24, 0x64	; 100
 47a:	90 e0       	ldi	r25, 0x00	; 0
 47c:	d9 df       	rcall	.-78     	; 0x430 <loop_ms>

Trame_Locale[0]=RESPONSE_START;
 47e:	02 e6       	ldi	r16, 0x62	; 98
 480:	10 e0       	ldi	r17, 0x00	; 0
 482:	99 e0       	ldi	r25, 0x09	; 9
 484:	e9 2e       	mov	r14, r25
 486:	e0 92 62 00 	sts	0x0062, r14
Trame_Locale[1]=0x0A ;
 48a:	8a e0       	ldi	r24, 0x0A	; 10
 48c:	f8 2e       	mov	r15, r24
 48e:	f0 92 63 00 	sts	0x0063, r15
Trame_Locale[2]=0x00;
 492:	10 92 64 00 	sts	0x0064, r1
Trame_Locale[3]=0x00;
 496:	10 92 65 00 	sts	0x0065, r1
Trame_Locale[4]=0x00;
 49a:	10 92 66 00 	sts	0x0066, r1
Trame_Locale[5]=0x00;
 49e:	10 92 67 00 	sts	0x0067, r1
Trame_Locale[6]=0x00;
 4a2:	10 92 68 00 	sts	0x0068, r1
Trame_Locale[7]=0x00;
 4a6:	10 92 69 00 	sts	0x0069, r1
Trame_Locale[8]=0x00;
 4aa:	10 92 6a 00 	sts	0x006A, r1
Trame_Locale[9]=0x00;
 4ae:	10 92 6b 00 	sts	0x006B, r1
Trame_Locale[10]=0x00;
 4b2:	10 92 6c 00 	sts	0x006C, r1
Trame_Locale[11]=0x00;
 4b6:	10 92 6d 00 	sts	0x006D, r1
send_frame(&Trame_Locale[0],12);
 4ba:	6c e0       	ldi	r22, 0x0C	; 12
 4bc:	70 e0       	ldi	r23, 0x00	; 0
 4be:	91 2f       	mov	r25, r17
 4c0:	80 2f       	mov	r24, r16
 4c2:	30 de       	rcall	.-928    	; 0x124 <send_frame>

// Attendre 100 ms
loop_ms(100);
 4c4:	84 e6       	ldi	r24, 0x64	; 100
 4c6:	90 e0       	ldi	r25, 0x00	; 0
 4c8:	b3 df       	rcall	.-154    	; 0x430 <loop_ms>

Trame_Locale[0]=RESPONSE_START;
 4ca:	e0 92 62 00 	sts	0x0062, r14
Trame_Locale[1]=0x0A ;
 4ce:	f0 92 63 00 	sts	0x0063, r15
Trame_Locale[2]=0x00;
 4d2:	10 92 64 00 	sts	0x0064, r1
Trame_Locale[3]=0x00;
 4d6:	10 92 65 00 	sts	0x0065, r1
Trame_Locale[4]=0x00;
 4da:	10 92 66 00 	sts	0x0066, r1
Trame_Locale[5]=0x0D;
 4de:	8d e0       	ldi	r24, 0x0D	; 13
 4e0:	80 93 67 00 	sts	0x0067, r24
Trame_Locale[6]=0x05;
 4e4:	85 e0       	ldi	r24, 0x05	; 5
 4e6:	80 93 68 00 	sts	0x0068, r24
Trame_Locale[7]=0x05;
 4ea:	80 93 69 00 	sts	0x0069, r24
Trame_Locale[8]=0x05;
 4ee:	80 93 6a 00 	sts	0x006A, r24
Trame_Locale[9]=0x05;
 4f2:	80 93 6b 00 	sts	0x006B, r24
send_frame(&Trame_Locale[0],10);
 4f6:	6a e0       	ldi	r22, 0x0A	; 10
 4f8:	70 e0       	ldi	r23, 0x00	; 0
 4fa:	91 2f       	mov	r25, r17
 4fc:	80 2f       	mov	r24, r16
 4fe:	12 de       	rcall	.-988    	; 0x124 <send_frame>

// Attendre 100 ms
loop_ms(100);
 500:	84 e6       	ldi	r24, 0x64	; 100
 502:	90 e0       	ldi	r25, 0x00	; 0
 504:	95 df       	rcall	.-214    	; 0x430 <loop_ms>

Ack_Change_Disk();
 506:	fe de       	rcall	.-516    	; 0x304 <Ack_Change_Disk>
 508:	1f 91       	pop	r17
 50a:	0f 91       	pop	r16
 50c:	ff 90       	pop	r15
 50e:	ef 90       	pop	r14
 510:	08 95       	ret

00000512 <main>:
#include "M_BUS_Modules.h"
#include "M_BUS_data.h"
//************************************ main program *******************************
int main (void)
{
 512:	cf ed       	ldi	r28, 0xDF	; 223
 514:	d0 e0       	ldi	r29, 0x00	; 0
 516:	de bf       	out	0x3e, r29	; 62
 518:	cd bf       	out	0x3d, r28	; 61
    int Compteur_1 =0;
 51a:	c0 e0       	ldi	r28, 0x00	; 0
 51c:	d0 e0       	ldi	r29, 0x00	; 0
    int Compteur_2 =0;
 51e:	0c 2f       	mov	r16, r28
 520:	1d 2f       	mov	r17, r29
    init();                                         //initialization
 522:	ee dd       	rcall	.-1060   	; 0x100 <init>

    // Tache de fond (Boucle infinie)
    for(;;)
    {
    if (received == 1)                                    // Si on a reçu une donnée et que 1er caractère est "1" alors on teste la commande reçue
 524:	80 91 9b 00 	lds	r24, 0x009B
 528:	81 30       	cpi	r24, 0x01	; 1
 52a:	39 f4       	brne	.+14     	; 0x53a <main+0x28>
        {
		if ((*R_BUS)==1)                              // Si la requête vient de l'autoradio (robustesse)
 52c:	80 91 8b 00 	lds	r24, 0x008B
 530:	81 30       	cpi	r24, 0x01	; 1
 532:	09 f4       	brne	.+2      	; 0x536 <main+0x24>
			{
	        Decode_Received();
 534:	28 df       	rcall	.-432    	; 0x386 <Decode_Received>
			}
        received = 0;                                      //reset M-Bus receive flag
 536:	10 92 9b 00 	sts	0x009B, r1
        }
		// en tâche de fond quand on a rien reçu et qu'on est en mode lecture, on envoi les info à l'autoradio
	if ( (Actual_Play_State	== 0x01) && ( Compteur_2 >= 25) )    // 25 -> (25 * 16 000) * (18i * 0.0625µs) = 450 ms
 53a:	80 91 60 00 	lds	r24, 0x0060
 53e:	81 30       	cpi	r24, 0x01	; 1
 540:	81 f4       	brne	.+32     	; 0x562 <main+0x50>
 542:	c9 31       	cpi	r28, 0x19	; 25
 544:	d1 05       	cpc	r29, r1
 546:	6c f0       	brlt	.+26     	; 0x562 <main+0x50>
		{
			Ack_Play_State (Last_Play_State, Actual_Repeat_Mode, Actual_Prog_Mode, Actual_Play_State);
 548:	20 91 60 00 	lds	r18, 0x0060
 54c:	40 91 74 00 	lds	r20, 0x0074
 550:	60 91 75 00 	lds	r22, 0x0075
 554:	80 91 61 00 	lds	r24, 0x0061
 558:	99 de       	rcall	.-718    	; 0x28c <Ack_Play_State>
			Compteur_1 = 0;
 55a:	c0 e0       	ldi	r28, 0x00	; 0
 55c:	d0 e0       	ldi	r29, 0x00	; 0
			Compteur_2 = 0;
 55e:	0c 2f       	mov	r16, r28
 560:	1d 2f       	mov	r17, r29
		}
	Compteur_1 ++;
 562:	0f 5f       	subi	r16, 0xFF	; 255
 564:	1f 4f       	sbci	r17, 0xFF	; 255
	if (	Compteur_1 >= 16000 )   // 16 000 -> 18ms pour 18 instructions
 566:	8e e3       	ldi	r24, 0x3E	; 62
 568:	00 38       	cpi	r16, 0x80	; 128
 56a:	18 07       	cpc	r17, r24
 56c:	dc f2       	brlt	.-74     	; 0x524 <main+0x12>
		{
			Compteur_1 = 0;
 56e:	00 e0       	ldi	r16, 0x00	; 0
 570:	10 e0       	ldi	r17, 0x00	; 0
			Compteur_2 ++;
 572:	21 96       	adiw	r28, 0x01	; 1
 574:	d7 cf       	rjmp	.-82     	; 0x524 <main+0x12>
