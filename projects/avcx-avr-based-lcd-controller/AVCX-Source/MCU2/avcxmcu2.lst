
AVRASM ver. 2.1.30  C:\Electronics\AVRProjects\AVCX-Color LCD  (A3810)\Code Listings\MCU2\AVCXMega128.asm Sat Nov 22 17:08:18 2008

C:\Electronics\AVRProjects\AVCX-Color LCD  (A3810)\Code Listings\MCU2\AVCXMega128.asm(3): Including file 'C:\Program Files\Atmel\AVR Tools\AvrAssembler2\Appnotes\m128def.inc'
C:\Electronics\AVRProjects\AVCX-Color LCD  (A3810)\Code Listings\MCU2\AVCXMega128.asm(4): Including file 'C:\Electronics\AVRProjects\AVCX-Color LCD  (A3810)\Code Listings\MCU2\Macros.inc'
C:\Electronics\AVRProjects\AVCX-Color LCD  (A3810)\Code Listings\MCU2\AVCXMega128.asm(1177): Including file 'C:\Electronics\AVRProjects\AVCX-Color LCD  (A3810)\Code Listings\MCU2\Font8x8.inc'
                 
                 .LIST
                 .LISTMAC
                 
                 ;
                 ; Software based on the Grand Prize winning Entry for the
                 ; Circuit Cellar 2004 AVR Contest
                 ; Project AVCX: http://www.circuitcellar.com/avr2004/grand.html
                 ;
                 ; It is re-used here with permission from Circuit Cellar
                 ;
                 ; Modified 2008 by Jan de Rie
                 ;
                 ; Besides a bug fix, the runtime design of MCU2 was completely redesigned
                 ; because the original design was very timing sensitive. For example, a large
                 ; delay was used in the MCU1 line scanning timing to accomodate MCU2
                 ;
                 ; In general, the only time MCU2 can access the video memory is between
                 ; Int6 and Int7 events (the RAM window). Incoming graphics commands are
                 ; stored in a buffer which is processed during the RAM window, when it
                 ; is safe to write to the video memory).
                 ;
                 ; 1. the incoming bytes buffer was only 256 bytes but the CLRSCR command
                 ;	 for example takes 57 mSecs to execute, which equates to 663 incoming
                 ;	 bytes at 115,200 bps. A lot of these bytes could be discarded.
                 ;	 The full bitmap commands expect 76,800 data bytes.
                 ;	 With multibyte commands, the state machine would get out of sync
                 ;
                 ; 2. The graphics command processing during Int6 was not always completed
                 ;	 before Int7 occured, requiring a clever and tricky recovery mechanism
                 ;	 to make sure the previous processing was completed on the next Int6.
                 ;	 This mechanism required that no functions were called while doing
                 ;	 graphic commands processing.
                 ;
                 ; 3. While graphics processing occured during the Int6 ISR, no incoming bytes
                 ;	 were accepted.
                 ;
                 ; 4. the RAM window is fairly long at the end of each screen. From lines 160 to 200,
                 ;	 the RAM window is open all the time because this is "overscan" time. Even though
                 ;	 the HSYNC signal is still properly issues, no data bytes are used by the LCD.
                 ;	 In the original design, the RAM window was closed at line 185, probably because
                 ;	 too many serial input bytes were lost. (the serial input was disabled during
                 ;	 the RAM window in the original design)
                 ;
                 ; The new design uses a 2K input buffer, plenty for the most demanding input.
                 ; It also accepts incoming characters at all times. There are a few short moments
                 ; where interrupts are disabled, mostly to ensure atomic operations on 16 bit pointers
                 ; or when toggling the memory controls
                 ;
                 ; Graphics processing is now done in the forever loop, not in an ISR. The forever loop gets interrupted
                 ; when an Int7 occurs. The Int7 ISR releases the memory bus, sets the state to FROZEN
                 ; and waits until the state changes to UNFREEZE. This state change occurs when Int6 hits.
                 ; Int6 does nothing but changing the state. Int7 grabs the memory bus again and finishes,
                 ; allowing the forever loop to continue graphics processing at the point it was interrupted.
                 ; In summary, when the forever loops runs, it is safe to access the video memory. When it is
                 ; not safe, the code loops inside the Int7 ISR. Incoming bytes are accepted at all times.
                 ; The performance of MCU2, specially wrt incoming bytes, is now guaranteed, independant of
                 ; the specific timing of Int6 and Int7 (as long as they alternate)
                 ; Well almost. There were also screen artifacts at the beginning of each line when MCU2 accessed
                 ; the memory. These artefacts were caused by the fact the MCU2 didn't release the memory bus fast
                 ; enough, causing bus contention. This was fixed by sending the RAM_STOP signal from MCU1 to MCU2
                 ; earlier (from Dot clock 262 to Dot clock 252). This however leaves only 8 dot clocks (16 cycles)
                 ; for MCU2 to access the memory, which is not enough, causing even a 3K input buffer to overflow
                 ; So some freeze (12 uSecs, value = 15, original value was 100) is still present.
                 ;
                 ; During the VSYNC period, the RAM window is now closed at line 200, allowing for a longer RAM window.
                 ;
                 ; Part of the reason why INT7 is slow to respond on MCU2 is the fact that SerialInput interrupts are
                 ; on. When the INT7 interrupt occurs while a serial input is active, the INT7 interrupt is pended
                 ; and won't get triggered until the serial input interrupt is completed. For this reason, the
                 ; Serial Input ISR processing must be a short as possible.
                 ; The same artifacts were showing in the original design even though the serial input interrupt was disabled.
                 ; Need more testing, e.g. by disabling serial input interrupts while the RAM window is open. TODO
                 ; On MCU1, the timing of INT7 is now advanced to minimize this effect, making the RAM window very short
                 ; specially without the Freeze hack.
                 ;
                 ; The modified source files result in an LCD refresh rate of 66.6 Hz, double the original design,
                 ; with little, if any, serial input rate limitations.
                 ;
                 ; The Sony LCD supports a 9-bit colordepth per pixel. 9 bits is an awkward number for an 8 bit processor.
                 ; To send a complete bitmap over the serial port in 9 bits, the original design used 2 bytes per pixel,
                 ; for a total of 76,800 bytes. Even at 115200 bps, this still takes over 6 seconds. Therefore I added a
                 ; "Short bitmap" command, which only sends 8 bits, ignoring the lowest BLUE bit. Sending the short bitmap
                 ; still takes 3.3 seconds.
                 ;
                 ; It would be nice to have a way to resetting the Graphics commands parser, There are multi-byte commands plus
                 ; the bitmaps, which expect 38,400 or 76,800 bytes. Once the parser gets out of sync, it may gobble the next 76,800
                 ; input bytes as it expects bitmap data.
                 ;
                 ; The pixel set functions have not been tested
                 ;
                 ; The current design relies on registers X and Y to be dedicated to the Serial Input buffer, which makes
                 ; it difficult to convert the code to C.
                 ; I have tried to use memory based pointers but this results in memory bus contention at the beginning
                 ; of the scan lines when serial data are coming in to MCU2, because it can take too long for MCU2 to respond
                 ; to the INT7 request from MCU1 (SerialIn ISR is too slow)
                 ; If this program needs to be converted to C, the timing of INT7 in MCU1 must be advanced, at least to DotClock 248.
                 ; The freeze window may have to be extended too in that case.
                 ;
                 ;##########################################################
                 ;##                     ###################################
                 ;## GENERAL DEFINITIONS ###################################
                 ;##                     ###################################
                 ;##########################################################
                 
                 .EQU IN_PROGRESS = 0   ;Int_6 Processing in progress
                                        ;For Int_6 use only
                 .EQU NULL = 0          ;Null string termination
                 
                 .EQU STANDBY      = $00
                 .EQU COLOR        = $88
                 .EQU MOVE         = $90
                 .EQU PUT_CHAR     = $A0
                 .EQU PRINT_STRING = $B0
                 .EQU PICTURE      = $C0
                 .EQU	SHORTPICTURE = 0xC1
                 .EQU CLEAR_SCR    = $43
                 .EQU PSET         = 4
                 .EQU ARG_X        = 1
                 .EQU ARG_Y        = 2
                 .EQU CRD_INC      = 0
                 .EQU CRD_DEC      = 8
                 .EQU LIGHT_ON     = $7F
                 .EQU LIGHT_OFF    = $40
                 .EQU FONT_HEIGH   = 1
                 .EQU FONT_WIDTH   = 1
                 .EQU ODD_BYTE     = 1
                 
                 #define		DEBUG 0
                 
                 #define	State_FREEZING		10
                 #define	State_FROZEN		11
                 #define	State_UNFREEZING	12
                 #define	State_ACTIVE		13
                 
                 ;##########################################################
                 ;##                  ######################################
                 ;## GLOBAL VARIABLES ######################################
                 ;##                  ######################################
                 ;##########################################################
                 
                 ;Register Variables
                 ;==================
                 ;Lower Registers
                 .def	_0		=	r15
                 .def	_min1	=	r14
                 .def	RxData	=	r13
                 .def	RxFlags	=	r12
                 
                 ;Upper Registers
                 ;.def StateReg	=	r20
                 
                 .DEF Vx        = R24  ;Video X coordinate
                 .DEF Vy        = R25   ;Video Y coordinate
                 ;
                 ; registers X & Y are currently reserved for the serial input buffer handling
                 ; MEMPTRS will use ram based pointers
                 ;
                 #define	MEMPTRS	0
                 
                 .DSEG
                 .ORG $100
                 ;
                 ; At Serial Input speed of 115200, time per byte is 86 uSec
                 ; Longest instruction is ClrScr, which takes 57 millisecs -> 662 character buffer needed
                 ;
                 #define UART_115200 	3
                 #define UART_38400		11
                 #define	UART_SPEED		UART_115200		;with larger RxBuffer
                 
                 
                 ;RAM Variables
                 ;=============
000100           RxBuffer: .BYTE 2048    ;Serial In Receive Buffer
                 RxBufferEnd:
                 
                 #if DEBUG
                 #endif
                 
000900           GrStateMem:		.byte	1
000901           GrOldCmdMem:	.byte	1
000902           State:			.byte	1
                 #if MEMPTRS
                 #endif
                 
                 ;##########################################################
                 ;##             ###########################################
                 ;## STACK SPACE ###########################################
                 ;##             ###########################################
                 ;##########################################################
                 
                 .EQU STACK_SIZE = 256
                 
                 .DSEG
                 
                 .ORG (RAMEND - STACK_SIZE)
                 
000fff           StackBottom: .BYTE STACK_SIZE
                 
                 .CSEG
                 ;##########################################################
                 ;##                   #####################################
                 ;## INTERRUPT VECTORS #####################################
                 ;##                   #####################################
                 ;##########################################################
                 
                 ;INTERRUPT VECTORS
                 .ORG 0x000
000000 940c 0047 jmp  Reset
000002 940c 0000 jmp  0
000004 940c 0000 jmp  0
000006 940c 0000 jmp  0
000008 940c 0000 jmp  0
00000a 940c 0000 jmp  0
00000c 940c 0000 jmp  0
00000e 940c 00b7 jmp  Int_6
000010 940c 00c6 jmp  Int_7
000012 940c 0000 jmp  0
000014 940c 0000 jmp  0
000016 940c 0000 jmp  0
000018 940c 0000 jmp  0
00001a 940c 0000 jmp  0
00001c 940c 0000 jmp  0
00001e 940c 0000 jmp  0
000020 940c 0000 jmp  0
000022 940c 0000 jmp  0
000024 940c 01f3 jmp  IntUart_0_Rx
000026 940c 0000 jmp  0
000028 940c 0000 jmp  0
00002a 940c 0000 jmp  0
00002c 940c 0000 jmp  0
00002e 940c 0000 jmp  0
000030 940c 0000 jmp  0
000032 940c 0000 jmp  0
000034 940c 0000 jmp  0
000036 940c 0000 jmp  0
000038 940c 0000 jmp  0
00003a 940c 0000 jmp  0
00003c 940c 0000 jmp  0
00003e 940c 0000 jmp  0
000040 940c 0000 jmp  0
000042 940c 0000 jmp  0
000044 940c 0000 jmp  0
                 
                 #if DEBUG
                 #else
                 InitDebug:
                 DebugL0:
                 DebugL1:
                 DebugL2:
                 DebugL3:
                 L4On:
                 L4Off:
000046 9508      	ret
                 #endif
                 
                 ;##########################################################
                 ;##             ###########################################
                 ;## ENTRY POINT ###########################################
                 ;##             ###########################################
                 ;##########################################################
                 
                 Reset:
                   ; Disable Interrupts during initializations
000047 94f8        cli
                 
                 ;##########################################################
                 ;##                              ##########################
                 ;## STACK POINTER INITIALIZATION ##########################
                 ;##                              ##########################
                 ;##########################################################
000048 e100        ldi r16, HIGH(RAMEND)
000049 bf0e        out SPH, r16
00004a ef0f        ldi r16, LOW(RAMEND)
00004b bf0d        out SPL, r16
                 ;
                 ; registers initialization
                 ;
00004c 2700      	clr		r16
00004d 2ef0      	mov		_0,r16
00004e 950a      	dec		r16
00004f 2ee0      	mov		_min1,r16
                 
                 ;##########################################################
                 ;##                          ##############################
                 ;## I/O PORTS INITIALIZATION ##############################
                 ;##                          ##############################
                 ;##########################################################
                 
                   ; Initialize PORT G
                   ; =================
                   ; 4 3210 Bit No
                   ; 0 0000 Value
                   ; o ioii Direction
000050 e00b        ldi r16, 0b01011
000051 9300 0065   sts PORTG, r16
000053 e104        ldi r16, 0b10100
000054 9300 0064   sts DDRG, r16
                 
                   ; Initialize PORT E
                   ; =================
                   ; 7654 3210 Bit No
                   ; 1111 0000 Value
                   ; iioo ooii Direction	sb: iioiooii but E4 is n.c.
000056 ef0f        ldi r16, 0b11111111
000057 b903        out PORTE, r16
000058 e20c        ldi r16, 0b00101100
000059 b902        out DDRE,  r16
                 
                   ; Initialize PORT A
                   ; =================
                   ; 7654 3210 Bit No
                   ; ---- ---- Value
                   ; oooo oooo Direction
00005a ef0f        ldi r16, 0b11111111
00005b bb0a        out DDRA, r16
                 
                   ; Initialize PORT C
                   ; =================
                   ; 7654 3210 Bit No
                   ; ---- ---- Value
                   ; oooo oooo Direction
00005c bb04        out DDRC, r16
                 
                   ; Initialize PORT B
                   ; =================
                   ; 7654 3210 Bit No
                   ; ---- ---- Value
                   ; oooo oooo Direction
00005d bb07        out DDRB, r16
                 
                   ; Initialize all other ports
                   ; as inputs with pull-up resistors
                   ; 7654 3210 Bit No
                   ; 1111 1111 Value
                   ; iiii iiii Direction
00005e ef0f        ldi r16, $FF
00005f bb02        out PORTD, r16
000060 9300 0062   sts PORTF,r16
000062 e000        ldi r16, 0
000063 bb01        out DDRD, r16
000064 9300 0061   sts DDRF, r16
                 
000066 dfdf      	rcall	InitDebug
                 
                 ;##########################################################
                 ;##                                    ####################
                 ;## EXTERNAL INTERRUPTS INITIALIZATION ####################
                 ;##                                    ####################
                 ;##########################################################
                 
                   ; INT0: Off
                   ; INT1: Off
                   ; INT2: Off
                   ; INT3: Off
                   ; INT4: Off
                   ; INT5: Off
                   ; INT6: On, Falling Edge
                   ; INT7: On, Falling Edge
                 
000067 e000        ldi r16,  $00
000068 9300 006a   sts EICRA, r16
00006a ea00        ldi r16,  0b10100000			;Falling edge int7 & int6
00006b bf0a        out EICRB, r16
00006c ec00        ldi r16,  $C0
00006d bf08        out EIFR,  r16
                   ; Mask off all external interrupts for now
00006e e000        ldi r16,  $00
00006f bf09        out EIMSK, r16
                 
                 ;##########################################################
                 ;##                        ################################
                 ;## USART 0 INITIALIZATION ################################
                 ;##                        ################################
                 ;##########################################################
                 
                   ; Receiver:    On, Interrupt: On
                   ; Transmitter: On, Interrupt: Off
                   ; Mode:        Asynchronous
                   ; Parameters:  8 Data, 1 Stop, No Parity
                   ; Baud rate:   UART_SPEED
000070 e000        ldi r16,   $00
000071 b90b        out UCSR0A, r16
000072 e908        ldi r16,   $98
000073 b90a        out UCSR0B, r16
000074 e006        ldi r16,   $06
000075 9300 0095   sts UCSR0C, r16
000077 e003        ldi r16,   (UART_SPEED & 0xff)
000078 b909        out UBRR0L, r16
000079 e000        ldi r16,   (UART_SPEED >> 8)
00007a 9300 0090   sts UBRR0H, r16
                 
                 ;##########################################################
                 ;##                                  ######################
                 ;## ANALOG COMPARATOR INITIALIZATION ######################
                 ;##                                  ######################
                 ;##########################################################
                 
                   ;Analog Comparator: Off
00007c e800        ldi r16,  $80
00007d b908        out ACSR,  r16
00007e e000        ldi r16,  $00
00007f bd00        out SFIOR, r16
                 
                 
                 ;##########################################################
                 ;##                          ##############################
                 ;## VARIABLES INITIALIZATION ##############################
                 ;##                          ##############################
                 ;##########################################################
                 
000080 92f0 0900   sts	GrStateMem,_0		; GrState = STANDBY
000082 92f0 0901   sts	GrOldCmdMem,_0		;nothing
                 
                 #if DEBUG
                 #endif
                 
000084 e001      	ldi		r16,HIGH(RxBuffer)
                 #if MEMPTRS
                 #else
000085 2dcf      	mov		YL,_0
000086 2daf      	mov		XL,_0
000087 2fd0      	mov		YH,r16
000088 2fb0      	mov		XH,r16
                 #endif
                 
                 ;##########################################################
                 ;##                               #########################
                 ;## VARIOUS FINAL INITIALIZATIONS #########################
                 ;##                               #########################
                 ;##########################################################
                 
                   ; Select Upper Page of Flash for fonts, bitmaps, etc.
000089 e011        ldi r17, 1
00008a bf1b        out RAMPZ, r17
                 
                   ;Clear Screen
                +
00008b 981a     +cbi PORTE , 2
00008c e007     +ldi r16 , 7
00008d 0f00     +lsl r16
00008e 0f00     +lsl r16
00008f 0f00     +lsl r16
000090 6007     +ori r16 , 7
000091 0f00     +lsl r16
000092 0f00     +lsl r16
000093 0f00     +lsl r16
000094 f408     +brcc PC + 2
000095 9a1a     +sbi PORTE , 2
000096 6007     +ori r16 , 7
000097 bb08     +out PORTB , r16
                   SET_COLOR 7, 7, 7
                 #if 0
                 #endif
                 ;
                 ;  PrintString("Ready")
                 ;
                 
000098 e413      	ldi		r17,0x43		;clear Screen
000099 d165      	rcall	Serial_In
                 
00009a e818      	ldi		r17,0x88		;Set Color 0,0,0
00009b d163      	rcall	Serial_In
00009c e010      	ldi		r17,0
00009d d161      	rcall	Serial_In
                 
00009e eb10      	ldi		r17,0xB0		;String
00009f d15f      	rcall	Serial_In
                 
0000a0 e512      	ldi r17, 'R'
0000a1 d15d        	rcall	Serial_In
0000a2 e615      	ldi r17, 'e'
0000a3 d15b      	rcall	Serial_In
0000a4 e611      	ldi r17, 'a'
0000a5 d159      	rcall	Serial_In
0000a6 e614      	ldi r17, 'd'
0000a7 d157      	rcall	Serial_In
0000a8 e719      	ldi r17, 'y'
0000a9 d155      	rcall	Serial_In
0000aa e010      	ldi r17, 0
0000ab d153      	rcall	Serial_In
                 
                   ;Clear Int_6 & Int_7 flags
0000ac ec00        ldi r16,  0b11000000
0000ad bf08        out EIFR,  r16
                 ;
                 ; enable both Int_6 and Int_7
                 ;
0000ae ec00      	ldi r16, 0b11000000
0000af bf09      	out EIMSK, r16
0000b0 e00d      	ldi	r16,State_ACTIVE
0000b1 9300 0902 	sts		State,r16
                 ;	ldi	StateReg,State_ACTIVE
0000b3 9478      	sei
0000b4 d011      	rcall	Int_7			;wait for INT6
                 ;
                 ; we come back here after INT6 has been received
                 ;
                 MainLoop:
                 ;
                 ; process queued graphic commands from SerialIn
                 ;
0000b5 d036      	rcall		ProcessCommands
0000b6 cffe      	rjmp	 	MainLoop
                 
                 ;##########################################################
                 ;##                           #############################
                 ;## VRAM ACCESS START (Int_6) #############################
                 ;##                           #############################
                 ;##########################################################
                 Int_6:
0000b7 930f      	push	r16
0000b8 b70f      	in		r16,SREG
0000b9 930f      	push	r16
0000ba 9100 0902 	lds		r16,State
0000bc 300b      	cpi		r16,State_FROZEN
0000bd f009      	breq	Int_6_L100
0000be df87      	rcall	DebugL0				;error
                 Int_6_L100:
0000bf e00c      	ldi		r16,State_UNFREEZING
0000c0 9300 0902 	sts		State,r16
                 ;	ldi		StateReg,State_UNFREEZING
0000c2 910f      	pop		r16
0000c3 bf0f      	out		SREG,r16
0000c4 910f      	pop		r16
0000c5 9518      	reti
                 
                 ;##########################################################
                 ;##                           #############################
                 ;## VRAM ACCESS END (Int_7)   #############################
                 ;##                           #############################
                 ;##########################################################
                 
                 Int_7:
                 ;
                 ;	Disconnect VRAM
                 ;
                +
0000c6 bafa     +out DDRA , _0
0000c7 baf4     +out DDRC , _0
0000c8 baf7     +out DDRB , _0
0000c9 9812     +cbi DDRE , 2
0000ca 9a1b     +sbi PORTE , 3
0000cb 981d     +cbi PORTE , 5
                 	VRAM_RELEASE
0000cc 930f      	push	r16
0000cd b70f      	in		r16,SREG
0000ce 930f      	push	r16
0000cf df76      	rcall	L4On
                 ;
                 ; Check Logic
                 ;
0000d0 9100 0902 	lds		r16,State
0000d2 300d      	cpi		r16,State_ACTIVE
                 ;	cpi		StateReg,State_ACTIVE
0000d3 f009      	breq	Int_7_L100
0000d4 df71      	rcall	DebugL1				;error
                 Int_7_L100:
0000d5 e00b      	ldi		r16,State_FROZEN
0000d6 9300 0902 	sts		State,r16
                 ;	ldi		StateReg,State_FROZEN
0000d8 9478      	sei							;allow interrups for Serial In, Int_6
                 
                 Int_7_Loop:
0000d9 9100 0902 	lds		r16,State
0000db 300c      	cpi		r16,State_UNFREEZING		;wait for Int_6 interrupt
                 ;	cpi		StateReg,State_UNFREEZING		;wait for Int_6 interrupt
0000dc f7e1      	brne	Int_7_Loop
                 
0000dd 94f8      	cli
                 ;
                 ; State is now State_UNFREEZING
                 ; Take control over Video RAM
                 ;
                +
0000de 9a1d     +sbi PORTE , 5
0000df 9a1b     +sbi PORTE , 3
0000e0 9a12     +sbi DDRE , 2
0000e1 baea     +out DDRA , _min1
0000e2 bae4     +out DDRC , _min1
0000e3 bae7     +out DDRB , _min1
                   	VRAM_CONNECT
0000e4 e00d      	ldi		r16,State_ACTIVE
0000e5 9300 0902 	sts		State,r16
                 ;	ldi		StateReg,State_ACTIVE
                 			
0000e7 df5e      	rcall	L4Off
0000e8 910f      	pop		r16
0000e9 bf0f      	out		SREG,r16
0000ea 910f      	pop		r16
0000eb 9518      	reti
                 
                 
                 ;####################################
                 ;# Graphic Command Processing BEGIN #
                 ;####################################
                 ;
                 ; only while doing processing
                 ;
                 .DEF GrCmd     = R21  ;Current Graphic Command
                 .DEF GrState   = R22  ;Graphic Command state machine variable
                 .DEF GrOldCmd  = R23   ;Last Graphic Command
                 
                 ProcessCommands:
0000ec 9160 0900 	lds		GrState,GrStateMem
0000ee 9170 0901 	lds		GrOldCmd,GrOldCmdMem
                 CommandLoop:
                   ;BEGIN while (RxReadPtr != RxWritePtr)
0000f0 94f8      	cli
                 #if MEMPTRS
                 #endif
0000f1 17db      	cp		YH,XH
0000f2 07ca      	cpc		YL,XL
0000f3 9478      	sei
0000f4 f429      	brne	Int6_L01
0000f5 9360 0900 	sts		GrStateMem,GrState
0000f7 9370 0901 	sts		GrOldCmdMem,GrOldCmd
0000f9 9508      	ret
                 
                 Int6_L01:
                   ;Get next Graphic Command
                   ;GrCmd = RxReadPtr
0000fa 915c      	ld	GrCmd,X
                 
                 
                   ;#######################
                   ;# State Machine BEGIN #
                   ;#######################
                 
                 ;------------------------------------------------------------------
                 GrState_STANDBY:
0000fb 3060        cpi GrState, STANDBY
0000fc f009        breq PC+2
0000fd c057        rjmp GrState_PICTURE
                 
                   ;Decode Command
0000fe 2fe5        mov  ZL, GrCmd
0000ff 7ce0        andi ZL, 0b11000000
000100 34e0        cpi  ZL, 0b01000000
000101 f409        brne MultiByteCommand
000102 c005        rjmp SingleByteCommand
                 
                 MultiByteCommand:
000103 2f75        mov  GrOldCmd, GrCmd
000104 2f65        mov  GrState, GrCmd
000105 7f68        andi GrState, $F8
000106 940c 01c7   jmp GetNextCommand
                 
                 SingleByteCommand:
                 
                 ClrScreen:
000108 3453        cpi GrCmd, CLEAR_SCR
000109 f481        brne LightOn
                +
00010a e99f     +ldi Vy , 159
00010b bb95     +out PORTC , Vy
00010c ee8f     +ldi Vx , 239
00010d bb8b     +out PORTA , Vx
00010e 94f8     +cli
00010f 981b     +cbi PORTE , 3
000110 9a1b     +sbi PORTE , 3
000111 9478     +sei
000112 5081     +subi Vx , 1
000113 f7c8     +brcc PC - 6
000114 5091     +subi Vy , 1
000115 f7a8     +brcc PC - 10
000116 e080     +ldi Vx , 0
000117 e090     +ldi Vy , 0
                   CLR_SCREEN
000118 940c 01c7   jmp GetNextCommand
                 
                 LightOn:
00011a 375f        cpi GrCmd, LIGHT_ON
00011b f429        brne LightOff
00011c e150        ldi GrCmd, 0b10000
00011d 9350 0065   sts PORTG, GrCmd
00011f 940c 01c7   jmp GetNextCommand
                 
                 LightOff:
000121 3450        cpi GrCmd, LIGHT_OFF
000122 f429        brne GrPset
000123 e050        ldi GrCmd, 0b00000
000124 9350 0065   sts PORTG, GrCmd
000126 940c 01c7   jmp GetNextCommand
                 
                 GrPset:
000128 ff52        sbrs GrCmd, 2
000129 c004        rjmp CrdDec
                +
00012a 94f8     +cli
00012b 981b     +cbi PORTE , 3
00012c 9a1b     +sbi PORTE , 3
00012d 9478     +sei
                   VRAM_WR
                 
                 CrdDec:
00012e ff53        sbrs GrCmd, 3
00012f c012        rjmp CrdInc
                 
000130 ff50        sbrs GrCmd, 0
000131 c006        rjmp CrdDecVy
000132 958a        dec Vx
000133 3f8f        cpi Vx, $FF
000134 f409        brne PC+2
000135 ee8f        ldi Vx, 239
000136 bb8b        out PORTA, Vx
000137 c08f        rjmp GetNextCommand
                 
                 CrdDecVy:
000138 ff51        sbrs GrCmd, 1
000139 940c 01c7   jmp GetNextCommand
                 
00013b 959a        dec Vy
00013c 3f9f        cpi Vy, $FF
00013d f409        brne PC+2
00013e e99f        ldi Vy, 159
00013f bb95        out PORTC, Vy
000140 940c 01c7   jmp GetNextCommand
                 
                 CrdInc:
000142 ff50        sbrs GrCmd, 0
000143 c007        rjmp CrdIncVy
000144 9583        inc Vx
000145 3f80        cpi Vx, 240
000146 f409        brne PC+2
000147 e080        ldi Vx, 0
000148 bb8b        out PORTA, Vx
000149 940c 01c7   jmp GetNextCommand
                 
                 CrdIncVy:
00014b ff51        sbrs GrCmd, 1
00014c 940c 01c7   jmp GetNextCommand
00014e 9593        inc Vy
00014f 3a90        cpi Vy, 160
000150 f409        brne PC+2
000151 e090        ldi Vy, 0
000152 bb95        out PORTC, Vy
000153 940c 01c7   jmp GetNextCommand
                 
                 ;------------------------------------------------------------------
                 
                 
                 GrState_PICTURE:
000155 3c60        cpi GrState, (PICTURE & 0xC0)
000156 f009        breq PC+2
000157 c03d        rjmp GrState_COLOR
                 
                   ; PICTURE Commands just issued?
000158 2f07        mov	r16,GROldCmd
000159 7c00        andi	r16,0xC0
00015a 3c00        cpi	r16,PICTURE
00015b f421        brne GrPict_00
00015c e080        ldi Vx, 0
00015d e99f        ldi Vy, 159
00015e e010        ldi r17, 0
00015f 7071        andi GrOldCmd, 0x01
                 
                 GrPict_00:
000160 3071      	cpi		GrOldCmd, (SHORTPICTURE & 0x01)
000161 f491      	brne	GrPict_DblByte
000162 bb95      	out		PORTC,Vy
000163 bb8b      	out		PORTA,Vx
000164 bb58      	out		PORTB,GrCmd
                +
000165 94f8     +cli
000166 981b     +cbi PORTE , 3
000167 9a1b     +sbi PORTE , 3
000168 9478     +sei
                 	VRAM_WR
000169 9583      	inc		Vx
00016a 3f80      	cpi		Vx,240
00016b f009      	breq	GrPict_003
00016c c05a      	rjmp	GetNextCommand
                 GrPict_003:
00016d 2d8f      	mov		Vx,_0
00016e 959a      	dec		Vy
00016f 3f9f      	cpi		Vy,255
000170 f009      	breq	GrPict_004
000171 c055      	rjmp	GetNextCommand
                 GrPict_004:
000172 2d9f      	mov		Vy,_0
000173 c052      	rjmp	GrState_DEFAULT		;done
                 
                 GrPict_DblByte:
000174 3010        cpi  r17, 0
000175 f009        breq GrPict_EvenByte
000176 c006        rjmp GrPict_OddByte
                 
                 GrPict_EvenByte:
000177 e017        ldi r17, 7
000178 bb95        out PORTC, Vy
000179 bb8b        out PORTA, Vx
00017a bb58        out PORTB, GrCmd
00017b 940c 01c7   jmp GetNextCommand
                 
                 GrPict_OddByte:
00017d e010        ldi r17, 0
00017e 3050        cpi GrCmd, 0
00017f f411        brne GrPict_01
000180 981a        cbi  PORTE, 2
000181 c001        rjmp GrPict_02
                 GrPict_01:
000182 9a1a        sbi  PORTE, 2
                 GrPict_02:
                +
000183 94f8     +cli
000184 981b     +cbi PORTE , 3
000185 9a1b     +sbi PORTE , 3
000186 9478     +sei
                   VRAM_WR
000187 9583        inc Vx
000188 3f80        cpi Vx, 240
000189 f011        breq GrPict_03
00018a 940c 01c7   jmp GetNextCommand
                 
                 GrPict_03:
00018c e080        ldi Vx, 0
00018d 959a        dec Vy
00018e 3f9f        cpi Vy, 255
00018f f011        breq GrPict_04
000190 940c 01c7   jmp GetNextCommand
                 GrPict_04:
000192 e090        ldi Vy, 0
000193 940c 01c6   jmp GrState_DEFAULT
                 
                 GrState_COLOR:
000195 3868        cpi GrState, COLOR
000196 f009        breq PC+2
000197 c00d        rjmp GrState_MOVE
                 
000198 0f55        lsl  GrCmd
000199 0f55        lsl  GrCmd
00019a 9576        lsr  GrOldCmd
00019b 9557        ror  GrCmd
00019c 9576        lsr  GrOldCmd
00019d 9557        ror  GrCmd
00019e 981a        cbi  PORTE, 2
00019f 9576        lsr  GrOldCmd
0001a0 f408        brcc Color_00
0001a1 9a1a        sbi PORTE, 2
                 Color_00:
0001a2 bb58        out PORTB, GrCmd
                 
0001a3 940c 01c6   jmp GrState_DEFAULT
                 
                 ;------------------------------------------------------------------
                 GrState_MOVE:
0001a5 3960        cpi GrState, MOVE
0001a6 f009        breq PC+2
0001a7 c011        rjmp GrState_PRINT_STRING
                 
0001a8 ff70        sbrs GrOldCmd, 0
0001a9 c003        rjmp GrMoveVy
0001aa 2f85        mov Vx, GrCmd
0001ab bb8b        out PORTA, Vx
0001ac c004        rjmp GrMovePset
                 
                 GrMoveVy:
                 #if 1	;BUG FIX
0001ad ff71        sbrs GrOldCmd, 1
                 #else
                 #endif
0001ae c008        rjmp GrMoveEnd
0001af 2f95        mov Vy, GrCmd
0001b0 bb95        out PORTC, Vy
                 
                 GrMovePset:
0001b1 ff72        sbrs GrOldCmd, 2
0001b2 c004        rjmp GrMoveEnd
                +
0001b3 94f8     +cli
0001b4 981b     +cbi PORTE , 3
0001b5 9a1b     +sbi PORTE , 3
0001b6 9478     +sei
                   VRAM_WR
                 
                 GrMoveEnd:
0001b7 940c 01c6   jmp GrState_DEFAULT
                 
                 ;------------------------------------------------------------------
                 GrState_PRINT_STRING:
0001b9 3b60        cpi GrState, PRINT_STRING
0001ba f029        breq GrL_00
                 
                 GrState_PUT_CHAR:
0001bb 3a60        cpi GrState, PUT_CHAR
0001bc f009        breq PC+2
0001bd c008        rjmp GrState_DEFAULT
0001be 2766        clr GrState      ; GrState = STANDBY
0001bf c003        rjmp GrL_01
                 
                 
                 ; Check if NULL
                 GrL_00:
0001c0 3050        cpi GrCmd, NULL
0001c1 f409        brne GrL_01
0001c2 c003        rjmp GrState_DEFAULT
                 GrL_01:
0001c3 d00b      	rcall	PutChar				;print GrCmd
                 GrL_02:
0001c4 940c 01c7   jmp GetNextCommand
                 ;------------------------------------------------------------------
                 
                 GrState_DEFAULT:
0001c6 2766        clr GrState      ; GrState = STANDBY
                 
                   ;#######################
                   ;# State Machine END   #
                   ;#######################
                 
                 GetNextCommand:
0001c7 94f8      	cli
                 #if MEMPTRS
                 #endif
0001c8 9611      	adiw	X,1					;increment queue tail ptr
0001c9 30b9      	cpi		XH,HIGH(RxBufferEnd)
0001ca f409      	brne	GRL_104
                 #if DEBUG
                 #endif
0001cb e0b1      	ldi		XH,HIGH(RxBuffer)
                 GRL_104:
                 #if MEMPTRS
                 #endif
0001cc 9478      	sei
0001cd 940c 00f0 	jmp		CommandLoop
                   ;END while (RxReadPtr != RxWritePtr)
                 
                 
                 ;##########################################################
                 ;##                                         ###############
                 ;## PUTCHAR - Character printing subroutine ###############
                 ; IN:	GrCmd - char to print
                 ;##                                         ###############
                 ;##########################################################
                 PutChar:
0001cf e028        ldi	r18,FONT_WIDTH*8	;column counter
                   ; Get Font8x8[GrCmd][0]
0001d0 e0e0        ldi ZL,  LOW(Font8x8*2)
0001d1 e0f0        ldi ZH, HIGH(Font8x8*2)
0001d2 e018        ldi r17, FONT_WIDTH*FONT_HEIGH*8
0001d3 2f05        mov	r16,GrCmd
0001d4 9f01        mul r16, r17
0001d5 0de0        add ZL, R0					;table position
0001d6 1df1        adc ZH, R1
0001d7 2f09        mov r16, Vy					;Y bit position
                 
                 GrLoop_01:
0001d8 e038        ldi r19, FONT_HEIGH*8			;row counter
0001d9 9117        elpm r17, Z+					;get bit pattern
                 GrLoop_02:
0001da 9516        lsr r17						;highest bit into carry
0001db f428        brcc GrJump_01
0001dc bb95        out PORTC, Vy					;bit was high
0001dd 94f8        cli
0001de 981b        cbi PORTE, 3					;toggle WR line
0001df 9a1b        sbi PORTE, 3
0001e0 9478        sei
                 GrJump_01:
0001e1 9593        inc Vy						;next Y position (row)
0001e2 3a90        cpi	Vy,160					;overflow?
0001e3 f008        brlo	GrJump_03
0001e4 e090        ldi	Vy,0					;to top row. No need to update Vx
                 GrJump_03:
0001e5 953a        dec	r19						;next row
0001e6 f799        brne GrLoop_02
                 
0001e7 2f90        mov Vy, r16					;restore Y position
0001e8 9583        inc Vx						;next X position
0001e9 3f80        cpi Vx, 240					;overflow?
0001ea f018        brlo GrJump_02				;no
0001eb e080        ldi Vx, 0						;wrap to next line
0001ec 5f98        subi Vy, (255-FONT_HEIGH*8)+1
0001ed 2f09        mov r16, Vy					;also update restore value
                 GrJump_02:
0001ee bb8b        out PORTA, Vx					;new memory address
0001ef bb95        out PORTC, Vy
                 
0001f0 952a      	dec  r18						;next column
0001f1 f731      	brne GrLoop_01
0001f2 9508      	ret
                 
                 .UNDEF GrCmd
                 .UNDEF GrState
                 .UNDEF GrOldCmd
                 
                 
                 ;##########################################################
                 ;##                             ###########################
                 ;## RS232 RECEIVE EVENT HANDLER ###########################
                 ;##                             ###########################
                 ;##########################################################
                 ;
                 ; Try to make this as short as possible since the Int7 interrupt
                 ; may occur while we're processing this request. Delaying Int7
                 ; handling delays releasing the SRAM bus, causing bus contention.
                 ; Interrupt priorities would be useful here.
                 ;
                 ; Use 2 permanently reserved registers: RxFlags, RxData
                 ;
                 ; Registers X and Y are permanently reserved as Serial Input Buffer pointers
                 ; MEMPTRS replaces that convention with memory based pointers.
                 ;
                 IntUart_0_Rx:
0001f3 b6cf      	in		RxFlags,SREG
                 #if MEMPTRS
                 #endif
                 ;
                 ; Get Data from Rs232
                 ;
0001f4 b0dc      	in RxData, UDR0
                 ;	out UDR0, GrState
                 #if 0
                 #endif
                 #if MEMPTRS
                 #endif
0001f5 92d9      	st		Y+,RxData				;store and increment queue head ptr
0001f6 30d9      	cpi		YH,HIGH(RxBufferEnd)
0001f7 f409      	brne	IntUart_0_L100
0001f8 e0d1      	ldi		YH,HIGH(RxBuffer)
                 IntUart_0_L100:
                 #if MEMPTRS
                 #else
0001f9 17db      	cp		YH,XH					;overflow test
0001fa 07ca      	cpc		YL,XL
                 #endif
0001fb f409      	brne	IntUart_0_Out
                 ;
                 ; input buffer overflow
                 ; consider sending Xoff-Xon to the sender. Xoff when say < 256 bytes left, Xon when >256 bytes in buffer
                 ;
                 #if DEBUG
                 #else
0001fc 9721      	sbiw	Y,1
                 #endif
                 IntUart_0_Out:
                 #if MEMPTRS
                 #endif
0001fd becf      	out		SREG,RxFlags
0001fe 9518      	reti
                 
                 ;##########################################################
                 ;##                             ###########################
                 ;## Serial In Queue HANDLER     ###########################
                 ;##                             ###########################
                 ; IN: r17
                 ;
                 ; USES: r17, Y
                 ;
                 ;##########################################################
                 Serial_In:
                 ;
                 ; Store Data in r17 to HeadPtr
                 ; This code is always running with ints disabled
                 ;
                 ; Y points to first free position (head)
                 ; X points to oldest entry (tail)
                 ;
                 #if MEMPTRS
                 #endif
0001ff 9319      	st		Y+,r17				;store and increment queue head ptr
000200 30d9      	cpi		YH,HIGH(RxBufferEnd)
000201 f409      	brne	Serial_InL100
                 #if DEBUG
                 #endif
000202 e0d1      	ldi		YH,HIGH(RxBuffer)
                 Serial_InL100:
                 #if MEMPTRS
                 #else
000203 17db      	cp		YH,XH				;overflow test
000204 07ca      	cpc		YL,XL
                 #endif
000205 f409      	brne	Serial_Out
                 ;
                 ; input buffer overflow
                 ; consider sending Xoff-Xon to the sender. Xoff when say < 256 bytes left, Xon when >256 bytes in buffer
                 ;
                 #if DEBUG
                 #else
000206 9721      	sbiw	Y,1
                 #endif
                 Serial_Out:
                 #if MEMPTRS
                 #endif
000207 9508      	ret
                 
                 
                 ;##########################################################
                 ;##                     ###################################
                 ;## FONTS & BITMAPS     ###################################
                 ;##                     ###################################
                 ;##########################################################
                 ;##                     ###################################
                 ;## Located in the      ###################################
                 ;## Upper Page of Flash ###################################
                 ;##                     ###################################
                 ;##########################################################
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega128 register use summary:
r0 :   1 r1 :   1 r2 :   0 r3 :   0 r4 :   0 r5 :   0 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   2 r13:   2 r14:   4 r15:  10 
r16:  99 r17:  21 r18:   2 r19:   2 r20:   0 r21:  29 r22:  12 r23:  12 
r24:  27 r25:  32 r26:   4 r27:   6 r28:   4 r29:   8 r30:   5 r31:   2 
x  :   2 y  :   4 z  :   1 
Registers used: 24 out of 35 (68.6%)

ATmega128 instruction use summary:
.lds  :   0 .sts  :   0 adc   :   1 add   :   1 adiw  :   1 and   :   0 
andi  :   4 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   5 brcs  :   0 break :   0 breq  :  13 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   2 brlt  :   0 brmi  :   0 
brne  :  21 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :  11 cbr   :   0 
clc   :   0 clh   :   0 cli   :  10 cln   :   0 clr   :   3 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   3 cpc   :   3 
cpi   :  31 cpse  :   0 dec   :   7 elpm  :   1 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :   4 inc   :   6 
jmp   :  52 ld    :   1 ldd   :   0 ldi   :  66 lds   :   5 lpm   :   0 
lsl   :   8 lsr   :   4 mov   :  18 movw  :   0 mul   :   1 muls  :   0 
mulsu :   0 neg   :   0 nop   :   0 or    :   0 ori   :   2 out   :  48 
pop   :   4 push  :   4 rcall :  18 ret   :   4 reti  :   3 rjmp  :  23 
rol   :   0 ror   :   2 sbc   :   0 sbci  :   0 sbi   :  13 sbic  :   0 
sbis  :   0 sbiw  :   2 sbr   :   0 sbrc  :   0 sbrs  :   9 sec   :   0 
seh   :   0 sei   :  10 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   2 std   :   0 
sts   :  17 sub   :   0 subi  :   3 swap  :   0 tst   :   0 wdr   :   0 

Instructions used: 42 out of 114 (36.8%)

ATmega128 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x010800   1040   2048   3088  131072   2.4%
[.dseg] 0x000100 0x0010ff      0   2307   2307    4096  56.3%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 0 warnings
