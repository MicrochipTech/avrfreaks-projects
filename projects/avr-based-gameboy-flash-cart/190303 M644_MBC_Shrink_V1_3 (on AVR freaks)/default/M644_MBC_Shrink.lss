
M644_MBC_Shrink.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000004a  00800100  000041ec  00004f40  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000041ec  00000000  00000000  00000d54  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .MBC1_16M_0000 00000004  00008000  00008000  0000508e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .MBC1_16M_0010 00000004  00008040  00008040  000050a6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .MBC1_16M_0100 00000004  00008080  00008080  000050be  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .MBC1_16M_0110 00000004  000080c0  000080c0  000050d2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .MBC1_16M_1000 00000002  00008100  00008100  000050e4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .MBC1_16M_1010 00000002  00008140  00008140  000050e8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .MBC1_16M_1100 00000002  00008180  00008180  000050ec  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .MBC1_16M_1110 00000002  000081c0  000081c0  000050f0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .MBC1_16M_0001 00000014  00008020  00008020  00005092  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .MBC1_16M_0011 00000014  00008060  00008060  000050aa  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .MBC1_16M_0101 00000010  000080a0  000080a0  000050c2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .MBC1_16M_0111 0000000e  000080e0  000080e0  000050d6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .MBC1_16M_1001 00000002  00008120  00008120  000050e6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .MBC1_16M_1011 00000002  00008160  00008160  000050ea  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .MBC1_16M_1101 00000002  000081a0  000081a0  000050ee  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .MBC1_16M_1111 00000002  000081e0  000081e0  000050f2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .MBC1_4M_0000 00000004  00008200  00008200  000050f4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .MBC1_4M_0010 00000004  00008240  00008240  0000510c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .MBC1_4M_0100 00000004  00008280  00008280  00005124  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .MBC1_4M_0110 00000004  000082c0  000082c0  00005136  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .MBC1_4M_1000 00000002  00008300  00008300  00005146  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .MBC1_4M_1010 00000002  00008340  00008340  0000514a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .MBC1_4M_1100 00000002  00008380  00008380  0000514e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .MBC1_4M_1110 00000002  000083c0  000083c0  00005152  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .MBC1_4M_0001 00000014  00008220  00008220  000050f8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .MBC1_4M_0011 00000014  00008260  00008260  00005110  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .MBC1_4M_0101 0000000e  000082a0  000082a0  00005128  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .MBC1_4M_0111 0000000c  000082e0  000082e0  0000513a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .MBC1_4M_1001 00000002  00008320  00008320  00005148  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .MBC1_4M_1011 00000002  00008360  00008360  0000514c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .MBC1_4M_1101 00000002  000083a0  000083a0  00005150  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .MBC1_4M_1111 00000002  000083e0  000083e0  00005154  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .MBC5_0000    00000008  00008400  00008400  00005156  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .MBC5_0010    00000008  00008440  00008440  00005170  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .MBC5_0100    00000008  00008480  00008480  00005182  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .MBC5_0110    00000008  000084c0  000084c0  00005198  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .MBC5_1000    00000008  00008500  00008500  000051a2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 39 .MBC5_1010    00000008  00008540  00008540  000051b0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 40 .MBC5_1100    00000008  00008580  00008580  000051be  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .MBC5_1110    00000008  000085c0  000085c0  000051cc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .MBC5_0001    00000012  00008420  00008420  0000515e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .MBC5_0011    0000000a  00008460  00008460  00005178  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .MBC5_0101    0000000e  000084a0  000084a0  0000518a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 45 .MBC5_0111    00000002  000084e0  000084e0  000051a0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 46 .MBC5_1001    00000006  00008520  00008520  000051aa  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 47 .MBC5_1011    00000006  00008560  00008560  000051b8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 48 .MBC5_1101    00000006  000085a0  000085a0  000051c6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .MBC5_1111    00000002  000085e0  000085e0  000051d4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .MBC_BASE     00000104  00007e00  00007e00  00004f8a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 51 .MBC3_0000    00000014  00008600  00008600  000051d6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .MBC3_0010    00000014  00008640  00008640  000051fe  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .MBC3_0100    00000014  00008680  00008680  00005226  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .MBC3_0110    00000014  000086c0  000086c0  0000525a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 55 .MBC3_1000    0000001c  00008700  00008700  00005284  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 56 .MBC3_1010    00000006  00008740  00008740  000052ba  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 57 .MBC3_1100    0000001c  00008780  00008780  000052e0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 58 .MBC3_1110    0000001c  000087c0  000087c0  00005302  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 59 .MBC3_0001    00000014  00008620  00008620  000051ea  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 60 .MBC3_0011    00000014  00008660  00008660  00005212  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 61 .MBC3_0101    00000020  000086a0  000086a0  0000523a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 62 .MBC3_0111    00000016  000086e0  000086e0  0000526e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 63 .MBC3_1001    0000001a  00008720  00008720  000052a0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 64 .MBC3_1011    00000020  00008760  00008760  000052c0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 65 .MBC3_1101    00000006  000087a0  000087a0  000052fc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 66 .MBC3_1111    0000001a  000087e0  000087e0  0000531e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 67 .MBC5_DSM_0000 00000006  00008800  00008800  00005338  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 68 .MBC5_DSM_0010 00000006  00008840  00008840  00005346  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 69 .MBC5_DSM_0100 00000006  00008880  00008880  00005352  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 70 .MBC5_DSM_0110 00000006  000088c0  000088c0  00005362  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 71 .MBC5_DSM_1000 00000006  00008900  00008900  0000536a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 72 .MBC5_DSM_1010 00000002  00008940  00008940  00005372  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 73 .MBC5_DSM_1100 00000006  00008980  00008980  00005376  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 74 .MBC5_DSM_1110 00000006  000089c0  000089c0  0000537e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 75 .MBC5_DSM_0001 00000008  00008820  00008820  0000533e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 76 .MBC5_DSM_0011 00000006  00008860  00008860  0000534c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 77 .MBC5_DSM_0101 0000000a  000088a0  000088a0  00005358  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 78 .MBC5_DSM_0111 00000002  000088e0  000088e0  00005368  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 79 .MBC5_DSM_1001 00000002  00008920  00008920  00005370  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 80 .MBC5_DSM_1011 00000002  00008960  00008960  00005374  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 81 .MBC5_DSM_1101 00000002  000089a0  000089a0  0000537c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 82 .MBC5_DSM_1111 00000002  000089e0  000089e0  00005384  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 83 .MBC2_0000    00000004  00008a00  00008a00  00005386  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 84 .MBC2_0100    00000004  00008a80  00008a80  000053b0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 85 .MBC2_1000    00000004  00008b00  00008b00  000053b6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 86 .MBC2_1100    00000004  00008b80  00008b80  000053e4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 87 .MBC2_0001    00000026  00008a20  00008a20  0000538a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 88 .MBC2_0101    00000002  00008aa0  00008aa0  000053b4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 89 .MBC2_1001    0000002a  00008b20  00008b20  000053ba  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 90 .MBC2_1101    00000002  00008ba0  00008ba0  000053e8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 91 .MBC3_RTC_0000 00000014  00008c00  00008c00  000053ea  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 92 .MBC3_RTC_0010 00000014  00008c40  00008c40  0000540e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 93 .MBC3_RTC_0100 00000014  00008c80  00008c80  00005436  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 94 .MBC3_RTC_0110 00000014  00008cc0  00008cc0  00005468  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 95 .MBC3_RTC_1000 0000001c  00008d00  00008d00  00005492  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 96 .MBC3_RTC_1010 00000016  00008d40  00008d40  000054c8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 97 .MBC3_RTC_1100 0000001c  00008d80  00008d80  000054fe  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 98 .MBC3_RTC_1110 0000001c  00008dc0  00008dc0  00005520  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 99 .MBC3_RTC_0001 00000010  00008c20  00008c20  000053fe  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
100 .MBC3_RTC_0011 00000014  00008c60  00008c60  00005422  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
101 .MBC3_RTC_0101 0000001e  00008ca0  00008ca0  0000544a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
102 .MBC3_RTC_0111 00000016  00008ce0  00008ce0  0000547c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
103 .MBC3_RTC_1001 0000001a  00008d20  00008d20  000054ae  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
104 .MBC3_RTC_1011 00000020  00008d60  00008d60  000054de  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
105 .MBC3_RTC_1101 00000006  00008da0  00008da0  0000551a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
106 .MBC3_RTC_1111 0000001a  00008de0  00008de0  0000553c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
107 .bss          0000046a  0080014a  0080014a  00005556  2**0
                  ALLOC
108 .debug_aranges 00000440  00000000  00000000  00005558  2**3
                  CONTENTS, READONLY, DEBUGGING
109 .debug_pubnames 00000733  00000000  00000000  00005998  2**0
                  CONTENTS, READONLY, DEBUGGING
110 .debug_info   000040f8  00000000  00000000  000060cb  2**0
                  CONTENTS, READONLY, DEBUGGING
111 .debug_abbrev 00000d57  00000000  00000000  0000a1c3  2**0
                  CONTENTS, READONLY, DEBUGGING
112 .debug_line   000052d1  00000000  00000000  0000af1a  2**0
                  CONTENTS, READONLY, DEBUGGING
113 .debug_frame  000004a0  00000000  00000000  000101ec  2**2
                  CONTENTS, READONLY, DEBUGGING
114 .debug_str    0000095a  00000000  00000000  0001068c  2**0
                  CONTENTS, READONLY, DEBUGGING
115 .debug_loc    000018c1  00000000  00000000  00010fe6  2**0
                  CONTENTS, READONLY, DEBUGGING
116 .debug_ranges 00000b88  00000000  00000000  000128a8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 06 05 	jmp	0xa0c	; 0xa0c <__ctors_end>
       4:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
       8:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
       c:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      10:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      14:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      18:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      1c:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      20:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      24:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      28:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      2c:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      30:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      34:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      38:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      3c:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      40:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      44:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      48:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      4c:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      50:	0c 94 26 08 	jmp	0x104c	; 0x104c <__vector_20>
      54:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      58:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      5c:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      60:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      64:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      68:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>
      6c:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__bad_interrupt>

00000070 <__c.1513>:
      70:	4d 42 43 31 5f 31 36 4d 00                          MBC1_16M.

00000079 <__c.1511>:
      79:	4d 42 43 35 20 20 20 20 00                          MBC5    .

00000082 <__c.1509>:
      82:	4d 42 43 33 20 20 20 20 00                          MBC3    .

0000008b <__c.1507>:
      8b:	4d 42 43 32 20 20 20 20 00                          MBC2    .

00000094 <__c.1505>:
      94:	4d 42 43 31 5f 31 36 4d 00                          MBC1_16M.

0000009d <__c.1503>:
      9d:	57 41 52 4e 49 4e 47 3a 20 52 4f 4d 20 61 6e 64     WARNING: ROM and
      ad:	20 52 41 4d 20 73 69 7a 65 20 62 6f 74 68 20 65      RAM size both e
      bd:	78 63 65 65 64 20 4d 42 43 31 20 6d 6f 64 65 20     xceed MBC1 mode 
      cd:	73 69 7a 65 73 2e 20 41 73 73 75 6d 69 6e 67 20     sizes. Assuming 
      dd:	4d 42 43 33 20 6d 6f 64 65 0d 0a 00                 MBC3 mode...

000000e9 <__c.1501>:
      e9:	4d 42 43 33 20 20 20 20 00                          MBC3    .

000000f2 <__c.1499>:
      f2:	4d 42 43 31 5f 34 4d 20 00                          MBC1_4M .

000000fb <__c.1497>:
      fb:	0d 0a 49 6e 76 61 6c 69 64 20 45 45 50 52 4f 4d     ..Invalid EEPROM
     10b:	20 76 61 6c 75 65 73 20 64 65 74 65 63 74 65 64      values detected
     11b:	2e 20 57 72 69 74 69 6e 67 20 64 65 66 61 75 6c     . Writing defaul
     12b:	74 20 76 61 6c 75 65 73 0d 0a 00                    t values...

00000136 <commonReturn>:
     136:	50 72 65 73 73 20 53 50 41 43 45 42 41 52 20 74     Press SPACEBAR t
     146:	6f 20 72 65 74 75 72 6e 20 74 6f 20 74 68 65 20     o return to the 
     156:	6d 61 69 6e 20 6d 65 6e 75 0d 0a 00                 main menu...

00000162 <commonAbort>:
     162:	27 4e 27 20 72 65 63 65 69 76 65 64 2e 20 41 62     'N' received. Ab
     172:	6f 72 74 69 6e 67 2e 0d 0a 00                       orting....

0000017c <commonEmpty>:
     17c:	4e 6f 74 20 69 6d 70 6c 65 6d 65 6e 74 65 64 20     Not implemented 
     18c:	79 65 74 0d 0a 00                                   yet...

00000192 <__c.1789>:
     192:	4e 6f 74 68 69 6e 67 20 74 6f 20 73 65 65 20 68     Nothing to see h
     1a2:	65 72 65 21 0d 0a 00                                ere!...

000001a9 <__c.1782>:
     1a9:	4d 42 43 20 6d 6f 64 65 20 69 73 20 6e 6f 77 3a     MBC mode is now:
     1b9:	20 00                                                .

000001bb <__c.1780>:
     1bb:	43 61 6e 63 65 6c 20 73 65 6c 65 63 74 69 6f 6e     Cancel selection
     1cb:	2e 0d 0a 00                                         ....

000001cf <__c.1778>:
     1cf:	4d 42 43 35 20 20 20 20 00                          MBC5    .

000001d8 <__c.1776>:
     1d8:	4d 42 43 33 20 20 20 20 00                          MBC3    .

000001e1 <__c.1774>:
     1e1:	4d 42 43 32 20 20 20 20 00                          MBC2    .

000001ea <__c.1772>:
     1ea:	4d 42 43 31 5f 34 4d 20 00                          MBC1_4M .

000001f3 <__c.1770>:
     1f3:	4d 42 43 31 5f 31 36 4d 00                          MBC1_16M.

000001fc <__c.1767>:
     1fc:	55 6e 6b 6e 6f 77 6e 20 73 65 6c 65 63 74 69 6f     Unknown selectio
     20c:	6e 3a 00                                            n:.

0000020f <__c.1763>:
     20f:	63 20 2d 20 43 61 6e 63 65 6c 20 73 65 6c 65 63     c - Cancel selec
     21f:	74 69 6f 6e 0d 0a 00                                tion...

00000226 <__c.1761>:
     226:	34 20 2d 20 4d 42 43 35 0d 0a 00                    4 - MBC5...

00000231 <__c.1759>:
     231:	33 20 2d 20 4d 42 43 33 0d 0a 00                    3 - MBC3...

0000023c <__c.1757>:
     23c:	32 20 2d 20 4d 42 43 32 0d 0a 00                    2 - MBC2...

00000247 <__c.1755>:
     247:	31 20 2d 20 4d 42 43 31 20 34 4d 62 0d 0a 00        1 - MBC1 4Mb...

00000256 <__c.1753>:
     256:	30 20 2d 20 4d 42 43 31 20 31 36 4d 62 0d 0a 00     0 - MBC1 16Mb...

00000266 <__c.1751>:
     266:	53 65 6c 65 63 74 20 6f 6e 65 20 6f 66 20 74 68     Select one of th
     276:	65 20 4d 42 43 20 6d 6f 64 65 73 20 62 65 6c 6f     e MBC modes belo
     286:	77 3a 0d 0a 00                                      w:...

0000028b <__c.1736>:
     28b:	31 3a 20 30 78 00                                   1: 0x.

00000291 <__c.1734>:
     291:	46 6c 61 73 68 20 63 68 69 70 20 49 44 20 28 65     Flash chip ID (e
     2a1:	78 70 65 63 74 69 6e 67 20 30 78 44 36 20 66 6f     xpecting 0xD6 fo
     2b1:	72 20 4d 61 63 72 6f 6e 69 78 29 0d 0a 30 3a 20     r Macronix)..0: 
     2c1:	30 78 00                                            0x.

000002c4 <__c.1725>:
     2c4:	46 69 6c 65 20 73 65 6e 74 21 0d 0a 00              File sent!...

000002d1 <__c.1723>:
     2d1:	53 65 6c 65 63 74 20 59 4d 4f 44 45 4d 20 72 65     Select YMODEM re
     2e1:	63 65 69 76 65 20 6f 6e 20 79 6f 75 72 20 74 65     ceive on your te
     2f1:	72 6d 69 6e 61 6c 20 74 6f 20 64 6f 77 6e 6c 6f     rminal to downlo
     301:	61 64 2e 20 41 56 52 20 77 69 6c 6c 20 62 65 20     ad. AVR will be 
     311:	77 61 69 74 69 6e 67 0d 0a 00                       waiting...

0000031b <__c.1721>:
     31b:	43 6f 6e 66 69 72 6d 20 79 6f 75 20 77 69 73 68     Confirm you wish
     32b:	20 74 6f 20 64 75 6d 70 20 74 68 65 20 63 75 72      to dump the cur
     33b:	72 65 6e 74 20 73 61 76 65 20 66 69 6c 65 20 28     rent save file (
     34b:	59 2f 4e 29 0d 0a 00                                Y/N)...

00000352 <__c.1707>:
     352:	4c 61 73 74 20 41 64 64 72 3a 20 00                 Last Addr: .

0000035e <__c.1705>:
     35e:	46 69 72 73 74 20 41 64 64 72 3a 20 00              First Addr: .

0000036b <__c.1703>:
     36b:	52 41 4d 20 77 72 69 74 65 20 65 72 72 6f 72 73     RAM write errors
     37b:	3a 20 00                                            : .

0000037e <__c.1701>:
     37e:	0d 0a 46 69 6c 65 20 72 65 63 65 69 76 65 64 21     ..File received!
     38e:	20 53 69 7a 65 3a 20 00                              Size: .

00000396 <__c.1695>:
     396:	31 30 20 73 65 63 6f 6e 64 20 64 65 6c 61 79 2e     10 second delay.
     3a6:	20 51 75 69 63 6b 2c 20 73 65 6c 65 63 74 20 74      Quick, select t
     3b6:	68 65 20 66 69 6c 65 20 74 6f 20 64 6f 77 6e 6c     he file to downl
     3c6:	6f 61 64 20 76 69 61 20 59 4d 4f 44 45 4d 20 70     oad via YMODEM p
     3d6:	72 6f 74 6f 63 6f 6c 0d 0a 00                       rotocol...

000003e0 <__c.1693>:
     3e0:	43 6f 6e 66 69 72 6d 20 79 6f 75 20 77 69 73 68     Confirm you wish
     3f0:	20 74 6f 20 64 6f 77 6e 6c 6f 61 64 20 61 20 73      to download a s
     400:	61 76 65 20 66 69 6c 65 20 28 59 2f 4e 29 0d 0a     ave file (Y/N)..
	...

00000411 <__c.1685>:
     411:	46 69 6c 65 20 73 65 6e 74 21 0d 0a 00              File sent!...

0000041e <__c.1683>:
     41e:	53 65 6c 65 63 74 20 59 4d 4f 44 45 4d 20 72 65     Select YMODEM re
     42e:	63 65 69 76 65 20 6f 6e 20 79 6f 75 72 20 74 65     ceive on your te
     43e:	72 6d 69 6e 61 6c 20 74 6f 20 64 6f 77 6e 6c 6f     rminal to downlo
     44e:	61 64 2e 20 41 56 52 20 77 69 6c 6c 20 62 65 20     ad. AVR will be 
     45e:	77 61 69 74 69 6e 67 0d 0a 00                       waiting...

00000468 <__c.1681>:
     468:	43 6f 6e 66 69 72 6d 20 79 6f 75 20 77 69 73 68     Confirm you wish
     478:	20 74 6f 20 64 75 6d 70 20 74 68 65 20 63 75 72      to dump the cur
     488:	72 65 6e 74 20 52 4f 4d 20 28 59 2f 4e 29 0d 0a     rent ROM (Y/N)..
	...

00000499 <__c.1660>:
     499:	4d 42 43 31 5f 31 36 4d 00                          MBC1_16M.

000004a2 <__c.1658>:
     4a2:	4d 42 43 35 20 20 20 20 00                          MBC5    .

000004ab <__c.1656>:
     4ab:	4d 42 43 33 20 20 20 20 00                          MBC3    .

000004b4 <__c.1654>:
     4b4:	4d 42 43 32 20 20 20 20 00                          MBC2    .

000004bd <__c.1652>:
     4bd:	4d 42 43 31 5f 31 36 4d 00                          MBC1_16M.

000004c6 <__c.1650>:
     4c6:	57 41 52 4e 49 4e 47 3a 20 52 4f 4d 20 61 6e 64     WARNING: ROM and
     4d6:	20 52 41 4d 20 73 69 7a 65 20 62 6f 74 68 20 65      RAM size both e
     4e6:	78 63 65 65 64 20 4d 42 43 31 20 6d 6f 64 65 20     xceed MBC1 mode 
     4f6:	73 69 7a 65 73 2e 20 41 73 73 75 6d 69 6e 67 20     sizes. Assuming 
     506:	4d 42 43 33 20 6d 6f 64 65 0d 0a 00                 MBC3 mode...

00000512 <__c.1648>:
     512:	4d 42 43 33 20 20 20 20 00                          MBC3    .

0000051b <__c.1646>:
     51b:	4d 42 43 31 5f 34 4d 20 00                          MBC1_4M .

00000524 <__c.1644>:
     524:	0d 0a 4d 61 78 20 61 64 64 72 65 73 73 20 20 20     ..Max address   
     534:	20 20 20 20 20 3a 20 00                                  : .

0000053c <__c.1642>:
     53c:	0d 0a 46 69 6c 65 20 72 65 63 65 69 76 65 64 21     ..File received!
     54c:	20 53 69 7a 65 3a 20 00                              Size: .

00000554 <__c.1640>:
     554:	0d 0a 45 72 72 6f 72 3a 20 00                       ..Error: .

0000055e <__c.1629>:
     55e:	31 30 20 73 65 63 6f 6e 64 20 64 65 6c 61 79 2e     10 second delay.
     56e:	20 51 75 69 63 6b 2c 20 73 65 6c 65 63 74 20 74      Quick, select t
     57e:	68 65 20 66 69 6c 65 20 74 6f 20 64 6f 77 6e 6c     he file to downl
     58e:	6f 61 64 20 76 69 61 20 59 4d 4f 44 45 4d 20 70     oad via YMODEM p
     59e:	72 6f 74 6f 63 6f 6c 0d 0a 00                       rotocol...

000005a8 <__c.1627>:
     5a8:	45 72 61 73 69 6e 67 20 63 68 69 70 28 73 29 0d     Erasing chip(s).
     5b8:	0a 00                                               ..

000005ba <__c.1625>:
     5ba:	43 6f 6e 66 69 72 6d 20 79 6f 75 20 77 69 73 68     Confirm you wish
     5ca:	20 74 6f 20 65 72 61 73 65 20 61 6e 64 20 66 6c      to erase and fl
     5da:	61 73 68 20 61 20 6e 65 77 20 52 4f 4d 20 28 59     ash a new ROM (Y
     5ea:	2f 4e 29 0d 0a 00                                   /N)...

000005f0 <__c.1597>:
     5f0:	0d 0a 46 69 72 6d 77 61 72 65 20 72 65 76 2e 3a     ..Firmware rev.:
     600:	20 20 20 20 00                                          .

00000605 <__c.1595>:
     605:	4d 42 43 20 6d 6f 64 65 3a 20 20 20 20 20 20 20     MBC mode:       
     615:	20 20 00                                              .

00000618 <__c.1593>:
     618:	0d 0a 4d 42 43 20 6d 6f 64 65 20 6f 6e 20 62 6f     ..MBC mode on bo
     628:	6f 74 20 28 46 72 6f 6d 20 45 45 50 52 4f 4d 29     ot (From EEPROM)
     638:	0d 0a 00                                            ...

0000063b <__c.1591>:
     63b:	43 47 42 20 73 75 70 70 6f 72 74 3f 3a 20 20 20     CGB support?:   
     64b:	20 20 30 78 00                                        0x.

00000650 <__c.1589>:
     650:	4d 42 43 20 74 79 70 65 3a 20 20 20 20 20 20 20     MBC type:       
     660:	20 20 30 78 00                                        0x.

00000665 <__c.1587>:
     665:	53 52 41 4d 20 73 69 7a 65 3a 20 20 20 20 20 20     SRAM size:      
     675:	20 20 30 78 00                                        0x.

0000067a <__c.1585>:
     67a:	52 4f 4d 20 73 69 7a 65 3a 20 20 20 20 20 20 20     ROM size:       
     68a:	20 20 30 78 00                                        0x.

0000068f <__c.1583>:
     68f:	52 4f 4d 20 6e 61 6d 65 3a 20 20 20 20 20 20 20     ROM name:       
     69f:	20 20 00                                              .

000006a2 <__c.1581>:
     6a2:	47 61 6d 65 62 6f 79 20 52 4f 4d 20 69 6e 66 6f     Gameboy ROM info
     6b2:	20 28 66 72 6f 6d 20 66 6c 61 73 68 29 3a 0d 0a      (from flash):..
	...

000006c3 <__c.1571>:
     6c3:	55 6e 6b 6e 6f 77 6e 20 72 65 71 75 65 73 74 0d     Unknown request.
     6d3:	0a 00                                               ..

000006d5 <__c.1569>:
     6d5:	0d 0a 55 73 65 72 20 73 65 6c 65 63 74 69 6f 6e     ..User selection
     6e5:	3a 20 00                                            : .

000006e8 <__c.1567>:
     6e8:	0d 0a 44 69 73 63 6f 6e 6e 65 63 74 20 74 68 65     ..Disconnect the
     6f8:	20 63 61 62 6c 65 20 62 65 66 6f 72 65 20 75 73      cable before us
     708:	69 6e 67 20 74 68 65 20 63 61 72 74 20 69 6e 20     ing the cart in 
     718:	61 20 47 61 6d 65 62 6f 79 21 0d 0a 00              a Gameboy!...

00000725 <__c.1565>:
     725:	38 20 2d 20 44 65 62 75 67 20 6f 70 74 69 6f 6e     8 - Debug option
     735:	20 66 6f 72 20 74 65 73 74 69 6e 67 20 73 74 75      for testing stu
     745:	66 66 0d 0a 00                                      ff...

0000074a <__c.1563>:
     74a:	37 20 2d 20 46 6c 61 73 68 20 6e 65 77 20 63 61     7 - Flash new ca
     75a:	72 74 20 66 69 72 6d 77 61 72 65 20 28 6d 75 73     rt firmware (mus
     76a:	74 20 62 65 20 3c 35 36 4b 42 20 64 75 65 20 74     t be <56KB due t
     77a:	6f 20 70 6c 61 63 65 6d 65 6e 74 20 6f 66 20 62     o placement of b
     78a:	6f 6f 74 6c 6f 61 64 65 72 29 0d 0a 00              ootloader)...

00000797 <__c.1561>:
     797:	36 20 2d 20 46 6f 72 63 65 20 4d 42 43 20 6d 6f     6 - Force MBC mo
     7a7:	64 65 20 28 66 6f 72 20 69 6e 63 6f 72 72 65 63     de (for incorrec
     7b7:	74 20 63 61 72 74 72 69 64 67 65 20 68 65 61 64     t cartridge head
     7c7:	65 72 20 6f 72 20 63 6f 6d 70 61 74 69 62 69 6c     er or compatibil
     7d7:	69 74 79 20 74 65 73 74 73 29 0d 0a 00              ity tests)...

000007e4 <__c.1559>:
     7e4:	35 20 2d 20 56 69 65 77 20 66 6c 61 73 68 20 49     5 - View flash I
     7f4:	43 20 64 65 74 65 63 74 69 6f 6e 0d 0a 00           C detection...

00000802 <__c.1557>:
     802:	34 20 2d 20 44 75 6d 70 20 73 61 76 65 20 66 69     4 - Dump save fi
     812:	6c 65 20 74 6f 20 50 43 0d 0a 00                    le to PC...

0000081d <__c.1555>:
     81d:	33 20 2d 20 44 6f 77 6e 6c 6f 61 64 20 73 61 76     3 - Download sav
     82d:	65 20 66 69 6c 65 20 74 6f 20 63 61 72 74 0d 0a     e file to cart..
	...

0000083e <__c.1553>:
     83e:	32 20 2d 20 44 75 6d 70 20 52 4f 4d 20 74 6f 20     2 - Dump ROM to 
     84e:	50 43 0d 0a 00                                      PC...

00000853 <__c.1551>:
     853:	31 20 2d 20 44 6f 77 6e 6c 6f 61 64 20 6e 65 77     1 - Download new
     863:	20 52 4f 4d 20 74 6f 20 63 61 72 74 0d 0a 00         ROM to cart...

00000872 <__c.1549>:
     872:	30 20 2d 20 53 68 6f 77 20 73 79 73 74 65 6d 20     0 - Show system 
     882:	61 6e 64 20 52 4f 4d 20 69 6e 66 6f 72 6d 61 74     and ROM informat
     892:	69 6f 6e 0d 0a 00                                   ion...

00000898 <__c.1547>:
     898:	57 65 6c 63 6f 6d 65 20 74 6f 20 42 6c 61 6b 65     Welcome to Blake
     8a8:	27 73 20 47 42 20 66 6c 61 73 68 20 63 61 72 74     's GB flash cart
     8b8:	0d 0a 43 68 6f 6f 73 65 20 6f 6e 65 20 6f 66 20     ..Choose one of 
     8c8:	74 68 65 20 66 6f 6c 6c 6f 77 69 6e 67 20 6f 70     the following op
     8d8:	74 69 6f 6e 73 0d 0a 0d 0a 00                       tions.....

000008e2 <__c.1413>:
     8e2:	55 4e 4b 20 56 41 4c 00                             UNK VAL.

000008ea <__c.1411>:
     8ea:	43 47 42 20 6f 6e 6c 79 00                          CGB only.

000008f3 <__c.1409>:
     8f3:	47 42 20 26 20 43 47 42 00                          GB & CGB.

000008fc <__c.1407>:
     8fc:	50 72 65 2d 43 47 42 00                             Pre-CGB.

00000904 <__c.1405>:
     904:	55 6e 73 75 70 70 6f 72 74 65 64 20 4d 42 43 20     Unsupported MBC 
     914:	74 79 70 65 00                                      type.

00000919 <__c.1403>:
     919:	4d 42 43 32 20 42 41 54 54 00                       MBC2 BATT.

00000923 <__c.1401>:
     923:	4d 42 43 32 00                                      MBC2.

00000928 <__c.1399>:
     928:	4d 42 43 33 20 52 41 4d 20 42 41 54 54 00           MBC3 RAM BATT.

00000936 <__c.1397>:
     936:	4d 42 43 33 20 52 41 4d 00                          MBC3 RAM.

0000093f <__c.1395>:
     93f:	4d 42 43 33 00                                      MBC3.

00000944 <__c.1393>:
     944:	4d 42 43 33 20 52 54 43 20 52 41 4d 20 42 41 54     MBC3 RTC RAM BAT
     954:	54 00                                               T.

00000956 <__c.1391>:
     956:	4d 42 43 33 20 52 54 43 20 42 41 54 54 00           MBC3 RTC BATT.

00000964 <__c.1389>:
     964:	4d 42 43 35 20 52 55 4d 42 4c 45 20 52 41 4d 20     MBC5 RUMBLE RAM 
     974:	42 41 54 54 00                                      BATT.

00000979 <__c.1387>:
     979:	4d 42 43 35 20 52 55 4d 42 4c 45 20 52 41 4d 00     MBC5 RUMBLE RAM.

00000989 <__c.1385>:
     989:	4d 42 43 35 20 52 55 4d 42 4c 45 00                 MBC5 RUMBLE.

00000995 <__c.1383>:
     995:	4d 42 43 35 20 52 41 4d 20 42 41 54 54 00           MBC5 RAM BATT.

000009a3 <__c.1381>:
     9a3:	4d 42 43 35 20 52 41 4d 00                          MBC5 RAM.

000009ac <__c.1379>:
     9ac:	4d 42 43 35 00                                      MBC5.

000009b1 <__c.1377>:
     9b1:	4d 42 43 31 20 52 41 4d 20 42 41 54 54 00           MBC1 RAM BATT.

000009bf <__c.1375>:
     9bf:	4d 42 43 31 20 52 41 4d 00                          MBC1 RAM.

000009c8 <__c.1373>:
     9c8:	4d 42 43 31 00                                      MBC1.

000009cd <__c.1371>:
     9cd:	52 4f 4d 20 6f 6e 6c 79 00                          ROM only.

000009d6 <__c.1413>:
     9d6:	4d 4f 44 45 20 55 4e 4b 00                          MODE UNK.

000009df <__c.1411>:
     9df:	4d 42 43 35 20 20 20 20 00                          MBC5    .

000009e8 <__c.1409>:
     9e8:	4d 42 43 33 20 20 20 20 00                          MBC3    .

000009f1 <__c.1407>:
     9f1:	4d 42 43 32 20 20 20 20 00                          MBC2    .

000009fa <__c.1405>:
     9fa:	4d 42 43 31 5f 34 4d 20 00                          MBC1_4M .

00000a03 <__c.1403>:
     a03:	4d 42 43 31 5f 31 36 4d 00                          MBC1_16M.

00000a0c <__ctors_end>:
     a0c:	11 24       	eor	r1, r1
     a0e:	1f be       	out	0x3f, r1	; 63
     a10:	cf ef       	ldi	r28, 0xFF	; 255
     a12:	d0 e1       	ldi	r29, 0x10	; 16
     a14:	de bf       	out	0x3e, r29	; 62
     a16:	cd bf       	out	0x3d, r28	; 61

00000a18 <__do_copy_data>:
     a18:	11 e0       	ldi	r17, 0x01	; 1
     a1a:	a0 e0       	ldi	r26, 0x00	; 0
     a1c:	b1 e0       	ldi	r27, 0x01	; 1
     a1e:	ec ee       	ldi	r30, 0xEC	; 236
     a20:	f1 e4       	ldi	r31, 0x41	; 65
     a22:	02 c0       	rjmp	.+4      	; 0xa28 <.do_copy_data_start>

00000a24 <.do_copy_data_loop>:
     a24:	05 90       	lpm	r0, Z+
     a26:	0d 92       	st	X+, r0

00000a28 <.do_copy_data_start>:
     a28:	aa 34       	cpi	r26, 0x4A	; 74
     a2a:	b1 07       	cpc	r27, r17
     a2c:	d9 f7       	brne	.-10     	; 0xa24 <.do_copy_data_loop>

00000a2e <__do_clear_bss>:
     a2e:	15 e0       	ldi	r17, 0x05	; 5
     a30:	aa e4       	ldi	r26, 0x4A	; 74
     a32:	b1 e0       	ldi	r27, 0x01	; 1
     a34:	01 c0       	rjmp	.+2      	; 0xa38 <.do_clear_bss_start>

00000a36 <.do_clear_bss_loop>:
     a36:	1d 92       	st	X+, r1

00000a38 <.do_clear_bss_start>:
     a38:	a4 3b       	cpi	r26, 0xB4	; 180
     a3a:	b1 07       	cpc	r27, r17
     a3c:	e1 f7       	brne	.-8      	; 0xa36 <.do_clear_bss_loop>
     a3e:	0e 94 25 05 	call	0xa4a	; 0xa4a <main>
     a42:	0c 94 f4 20 	jmp	0x41e8	; 0x41e8 <_exit>

00000a46 <__bad_interrupt>:
     a46:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000a4a <main>:
      correct pinout. Now for the first test game...
*/

int main() {

  PORTA |= (1 << PA7); // Pull up INTRAMEN ASAP - may be the reason save files are corrupting without this. Need to test
     a4a:	17 9a       	sbi	0x02, 7	; 2

  uint8_t startMode = PIND & (1 << PD0); // Mode detect on RXD pin

  if(startMode) {
     a4c:	48 9b       	sbis	0x09, 0	; 9
     a4e:	5a c0       	rjmp	.+180    	; 0xb04 <main+0xba>

    // Set up the flash and SRAM chip port pins
    memory_init();
     a50:	0e 94 85 10 	call	0x210a	; 0x210a <memory_init>

    // Set up the UART
    usart_init_Xlarge(115200); 
     a54:	60 e0       	ldi	r22, 0x00	; 0
     a56:	72 ec       	ldi	r23, 0xC2	; 194
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	90 e0       	ldi	r25, 0x00	; 0
     a5c:	0e 94 e7 07 	call	0xfce	; 0xfce <usart_init_Xlarge>
          checks until afterwards though. Also, I'm doing a whole chip erase atm when writing, so how would
          I fix this if a CRC error appeared as I haven't got the byte-write program correct!
    */

    // Initialise values
    flashAddress.address32 = 0;
     a60:	10 92 61 05 	sts	0x0561, r1
     a64:	10 92 62 05 	sts	0x0562, r1
     a68:	10 92 63 05 	sts	0x0563, r1
     a6c:	10 92 64 05 	sts	0x0564, r1
    get_GBROM_info(&gbRomData);
     a70:	8b e6       	ldi	r24, 0x6B	; 107
     a72:	95 e0       	ldi	r25, 0x05	; 5
     a74:	0e 94 10 1c 	call	0x3820	; 0x3820 <get_GBROM_info>
    read_gbeepromdat(&eepData);
     a78:	84 ea       	ldi	r24, 0xA4	; 164
     a7a:	95 e0       	ldi	r25, 0x05	; 5
     a7c:	0e 94 c9 1f 	call	0x3f92	; 0x3f92 <read_gbeepromdat>

    if((eepData.MBCMode != CART_MODE_MBC1_16M) && 
     a80:	90 91 a4 05 	lds	r25, 0x05A4
     a84:	89 2f       	mov	r24, r25
     a86:	80 54       	subi	r24, 0x40	; 64
     a88:	83 30       	cpi	r24, 0x03	; 3
     a8a:	a0 f1       	brcs	.+104    	; 0xaf4 <main+0xaa>
     a8c:	95 34       	cpi	r25, 0x45	; 69
     a8e:	91 f1       	breq	.+100    	; 0xaf4 <main+0xaa>
     a90:	93 34       	cpi	r25, 0x43	; 67
     a92:	81 f1       	breq	.+96     	; 0xaf4 <main+0xaa>
       (eepData.MBCMode != CART_MODE_MBC5) && 
       (eepData.MBCMode != CART_MODE_MBC2) && 
       (eepData.MBCMode != CART_MODE_MBC3)) {

      // Default values are incorrect. Require writing EEPROM values
      usart_transmit_str_P(PSTR("\r\nInvalid EEPROM values detected. Writing default values\r\n"));
     a94:	8b ef       	ldi	r24, 0xFB	; 251
     a96:	90 e0       	ldi	r25, 0x00	; 0
     a98:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

      // Set the default mode 
      if(gbRomData.MBCtype < 0x04) {
     a9c:	90 91 84 05 	lds	r25, 0x0584
     aa0:	94 30       	cpi	r25, 0x04	; 4
     aa2:	08 f0       	brcs	.+2      	; 0xaa6 <main+0x5c>
     aa4:	46 c0       	rjmp	.+140    	; 0xb32 <main+0xe8>
        // MBC1 or ROM only
    
        if(gbRomData.RAMsizeBytes > 8192 && gbRomData.ROMsizeBytes <= 524288) {
     aa6:	80 91 82 05 	lds	r24, 0x0582
     aaa:	90 91 83 05 	lds	r25, 0x0583
     aae:	81 50       	subi	r24, 0x01	; 1
     ab0:	90 42       	sbci	r25, 0x20	; 32
     ab2:	a8 f1       	brcs	.+106    	; 0xb1e <main+0xd4>
     ab4:	80 91 7d 05 	lds	r24, 0x057D
     ab8:	90 91 7e 05 	lds	r25, 0x057E
     abc:	a0 91 7f 05 	lds	r26, 0x057F
     ac0:	b0 91 80 05 	lds	r27, 0x0580
     ac4:	81 50       	subi	r24, 0x01	; 1
     ac6:	90 40       	sbci	r25, 0x00	; 0
     ac8:	a8 40       	sbci	r26, 0x08	; 8
     aca:	b0 40       	sbci	r27, 0x00	; 0
     acc:	f0 f0       	brcs	.+60     	; 0xb0a <main+0xc0>
          eepData.MBCMode = CART_MODE_MBC1_4M;
          strcpy_P(eepData.MBCName, PSTR("MBC1_4M "));
        } else if(gbRomData.RAMsizeBytes > 8192 && gbRomData.ROMsizeBytes > 524288) {
          eepData.MBCMode = CART_MODE_MBC3;
     ace:	83 e4       	ldi	r24, 0x43	; 67
     ad0:	80 93 a4 05 	sts	0x05A4, r24
          strcpy_P(eepData.MBCName, PSTR("MBC3    "));
     ad4:	85 ea       	ldi	r24, 0xA5	; 165
     ad6:	95 e0       	ldi	r25, 0x05	; 5
     ad8:	69 ee       	ldi	r22, 0xE9	; 233
     ada:	70 e0       	ldi	r23, 0x00	; 0
     adc:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
          usart_transmit_str_P(PSTR("WARNING: ROM and RAM size both exceed MBC1 mode sizes. Assuming MBC3 mode\r\n"));
     ae0:	8d e9       	ldi	r24, 0x9D	; 157
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
      } else {
        // default to MBC116M8k unless someone else says...
        eepData.MBCMode = CART_MODE_MBC1_16M;
        strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
      }
      program_initial_gbeepromdat(eepData.MBCMode);
     ae8:	80 91 a4 05 	lds	r24, 0x05A4
     aec:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <program_initial_gbeepromdat>
      wait_for_continue();
     af0:	0e 94 64 16 	call	0x2cc8	; 0x2cc8 <wait_for_continue>
    }

    // Turn off unnecessary peripherals
    PRR |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRTIM2)|(1<<PRTWI));
     af4:	80 91 64 00 	lds	r24, 0x0064
     af8:	8d 6e       	ori	r24, 0xED	; 237
     afa:	80 93 64 00 	sts	0x0064, r24

    show_menu(); // Loops in here. Don't expect to come out.
     afe:	0e 94 ef 1a 	call	0x35de	; 0x35de <show_menu>
     b02:	ff cf       	rjmp	.-2      	; 0xb02 <main+0xb8>
  
  } else {
    // MBC mode. Jump to the correct handler

    launch_mbc_mode();
     b04:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <launch_mbc_mode>
     b08:	fc cf       	rjmp	.-8      	; 0xb02 <main+0xb8>
      // Set the default mode 
      if(gbRomData.MBCtype < 0x04) {
        // MBC1 or ROM only
    
        if(gbRomData.RAMsizeBytes > 8192 && gbRomData.ROMsizeBytes <= 524288) {
          eepData.MBCMode = CART_MODE_MBC1_4M;
     b0a:	81 e4       	ldi	r24, 0x41	; 65
     b0c:	80 93 a4 05 	sts	0x05A4, r24
          strcpy_P(eepData.MBCName, PSTR("MBC1_4M "));
     b10:	85 ea       	ldi	r24, 0xA5	; 165
     b12:	95 e0       	ldi	r25, 0x05	; 5
     b14:	62 ef       	ldi	r22, 0xF2	; 242
     b16:	70 e0       	ldi	r23, 0x00	; 0
     b18:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
     b1c:	e5 cf       	rjmp	.-54     	; 0xae8 <main+0x9e>
        } else if(gbRomData.RAMsizeBytes > 8192 && gbRomData.ROMsizeBytes > 524288) {
          eepData.MBCMode = CART_MODE_MBC3;
          strcpy_P(eepData.MBCName, PSTR("MBC3    "));
          usart_transmit_str_P(PSTR("WARNING: ROM and RAM size both exceed MBC1 mode sizes. Assuming MBC3 mode\r\n"));
        } else {
          eepData.MBCMode = CART_MODE_MBC1_16M;
     b1e:	80 e4       	ldi	r24, 0x40	; 64
     b20:	80 93 a4 05 	sts	0x05A4, r24
          strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
     b24:	85 ea       	ldi	r24, 0xA5	; 165
     b26:	95 e0       	ldi	r25, 0x05	; 5
     b28:	64 e9       	ldi	r22, 0x94	; 148
     b2a:	70 e0       	ldi	r23, 0x00	; 0
     b2c:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
     b30:	db cf       	rjmp	.-74     	; 0xae8 <main+0x9e>
        }

      } else if(gbRomData.MBCtype == 0x05 || gbRomData.MBCtype == 0x06) {
     b32:	89 2f       	mov	r24, r25
     b34:	85 50       	subi	r24, 0x05	; 5
     b36:	82 30       	cpi	r24, 0x02	; 2
     b38:	80 f0       	brcs	.+32     	; 0xb5a <main+0x110>
        // MBC2
        eepData.MBCMode = CART_MODE_MBC2;
        strcpy_P(eepData.MBCName, PSTR("MBC2    "));
      
      } else if(gbRomData.MBCtype >= 0x0F && gbRomData.MBCtype <= 0x13) {
     b3a:	89 2f       	mov	r24, r25
     b3c:	8f 50       	subi	r24, 0x0F	; 15
     b3e:	85 30       	cpi	r24, 0x05	; 5
     b40:	00 f1       	brcs	.+64     	; 0xb82 <main+0x138>
        // MBC3
        eepData.MBCMode = CART_MODE_MBC3;
        strcpy_P(eepData.MBCName, PSTR("MBC3    "));

      } else if(gbRomData.MBCtype >= 0x19) {
     b42:	99 31       	cpi	r25, 0x19	; 25
     b44:	a0 f0       	brcs	.+40     	; 0xb6e <main+0x124>
        // MBC5
        eepData.MBCMode = CART_MODE_MBC5;
     b46:	82 e4       	ldi	r24, 0x42	; 66
     b48:	80 93 a4 05 	sts	0x05A4, r24
        strcpy_P(eepData.MBCName, PSTR("MBC5    "));
     b4c:	85 ea       	ldi	r24, 0xA5	; 165
     b4e:	95 e0       	ldi	r25, 0x05	; 5
     b50:	69 e7       	ldi	r22, 0x79	; 121
     b52:	70 e0       	ldi	r23, 0x00	; 0
     b54:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
     b58:	c7 cf       	rjmp	.-114    	; 0xae8 <main+0x9e>
          strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
        }

      } else if(gbRomData.MBCtype == 0x05 || gbRomData.MBCtype == 0x06) {
        // MBC2
        eepData.MBCMode = CART_MODE_MBC2;
     b5a:	85 e4       	ldi	r24, 0x45	; 69
     b5c:	80 93 a4 05 	sts	0x05A4, r24
        strcpy_P(eepData.MBCName, PSTR("MBC2    "));
     b60:	85 ea       	ldi	r24, 0xA5	; 165
     b62:	95 e0       	ldi	r25, 0x05	; 5
     b64:	6b e8       	ldi	r22, 0x8B	; 139
     b66:	70 e0       	ldi	r23, 0x00	; 0
     b68:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
     b6c:	bd cf       	rjmp	.-134    	; 0xae8 <main+0x9e>
        // MBC5
        eepData.MBCMode = CART_MODE_MBC5;
        strcpy_P(eepData.MBCName, PSTR("MBC5    "));
      } else {
        // default to MBC116M8k unless someone else says...
        eepData.MBCMode = CART_MODE_MBC1_16M;
     b6e:	80 e4       	ldi	r24, 0x40	; 64
     b70:	80 93 a4 05 	sts	0x05A4, r24
        strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
     b74:	85 ea       	ldi	r24, 0xA5	; 165
     b76:	95 e0       	ldi	r25, 0x05	; 5
     b78:	60 e7       	ldi	r22, 0x70	; 112
     b7a:	70 e0       	ldi	r23, 0x00	; 0
     b7c:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
     b80:	b3 cf       	rjmp	.-154    	; 0xae8 <main+0x9e>
        eepData.MBCMode = CART_MODE_MBC2;
        strcpy_P(eepData.MBCName, PSTR("MBC2    "));
      
      } else if(gbRomData.MBCtype >= 0x0F && gbRomData.MBCtype <= 0x13) {
        // MBC3
        eepData.MBCMode = CART_MODE_MBC3;
     b82:	83 e4       	ldi	r24, 0x43	; 67
     b84:	80 93 a4 05 	sts	0x05A4, r24
        strcpy_P(eepData.MBCName, PSTR("MBC3    "));
     b88:	85 ea       	ldi	r24, 0xA5	; 165
     b8a:	95 e0       	ldi	r25, 0x05	; 5
     b8c:	62 e8       	ldi	r22, 0x82	; 130
     b8e:	70 e0       	ldi	r23, 0x00	; 0
     b90:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
     b94:	a9 cf       	rjmp	.-174    	; 0xae8 <main+0x9e>

00000b96 <usart_init>:
	// Set baud rate: 19200bps when @ 8Mhz
	UBRR0H = (unsigned char)(25>>8);
	UBRR0L = (unsigned char)25;
*/
	// Calculate the baud value
	uint16_t num = (uint32_t)F_CPU / (16 * (uint32_t)baud) - 1;
     b96:	9c 01       	movw	r18, r24
     b98:	40 e0       	ldi	r20, 0x00	; 0
     b9a:	50 e0       	ldi	r21, 0x00	; 0
     b9c:	22 0f       	add	r18, r18
     b9e:	33 1f       	adc	r19, r19
     ba0:	44 1f       	adc	r20, r20
     ba2:	55 1f       	adc	r21, r21
     ba4:	22 0f       	add	r18, r18
     ba6:	33 1f       	adc	r19, r19
     ba8:	44 1f       	adc	r20, r20
     baa:	55 1f       	adc	r21, r21
     bac:	22 0f       	add	r18, r18
     bae:	33 1f       	adc	r19, r19
     bb0:	44 1f       	adc	r20, r20
     bb2:	55 1f       	adc	r21, r21
     bb4:	22 0f       	add	r18, r18
     bb6:	33 1f       	adc	r19, r19
     bb8:	44 1f       	adc	r20, r20
     bba:	55 1f       	adc	r21, r21
     bbc:	60 e0       	ldi	r22, 0x00	; 0
     bbe:	70 ec       	ldi	r23, 0xC0	; 192
     bc0:	89 e8       	ldi	r24, 0x89	; 137
     bc2:	91 e0       	ldi	r25, 0x01	; 1
     bc4:	0e 94 68 20 	call	0x40d0	; 0x40d0 <__udivmodsi4>
     bc8:	21 50       	subi	r18, 0x01	; 1
     bca:	30 40       	sbci	r19, 0x00	; 0
	
	// Set baud rate 
	UBRR0H = (unsigned char)(num>>8);
     bcc:	30 93 c5 00 	sts	0x00C5, r19
	UBRR0L = (unsigned char)num;
     bd0:	20 93 c4 00 	sts	0x00C4, r18
	/* Enable receiver and transmitter */
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
     bd4:	88 e1       	ldi	r24, 0x18	; 24
     bd6:	80 93 c1 00 	sts	0x00C1, r24
	/* Set frame format: 8data, 1stop bit */
	UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
     bda:	86 e0       	ldi	r24, 0x06	; 6
     bdc:	80 93 c2 00 	sts	0x00C2, r24
}
     be0:	08 95       	ret

00000be2 <usart_transmit>:

void usart_transmit(unsigned char data)
{
     be2:	98 2f       	mov	r25, r24
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     be4:	80 91 c0 00 	lds	r24, 0x00C0
     be8:	85 ff       	sbrs	r24, 5
     bea:	fc cf       	rjmp	.-8      	; 0xbe4 <usart_transmit+0x2>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     bec:	90 93 c6 00 	sts	0x00C6, r25
}
     bf0:	08 95       	ret

00000bf2 <usart_receive>:

char usart_receive(void)
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
     bf2:	80 91 c0 00 	lds	r24, 0x00C0
     bf6:	87 ff       	sbrs	r24, 7
     bf8:	fc cf       	rjmp	.-8      	; 0xbf2 <usart_receive>
	{
	}
	/* Get and return received data from buffer */
	return UDR0;
     bfa:	80 91 c6 00 	lds	r24, 0x00C6
}
     bfe:	08 95       	ret

00000c00 <usart_transmit_str>:

void usart_transmit_str(const char* data)
{
     c00:	fc 01       	movw	r30, r24
	// There's still data to go so keep sending it until it ends
	while(*data)
     c02:	90 81       	ld	r25, Z
     c04:	99 23       	and	r25, r25
     c06:	51 f0       	breq	.+20     	; 0xc1c <usart_transmit_str+0x1c>
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     c08:	80 91 c0 00 	lds	r24, 0x00C0
     c0c:	85 ff       	sbrs	r24, 5
     c0e:	fc cf       	rjmp	.-8      	; 0xc08 <usart_transmit_str+0x8>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     c10:	90 93 c6 00 	sts	0x00C6, r25
{
	// There's still data to go so keep sending it until it ends
	while(*data)
	{
		usart_transmit(*data);
        data++;
     c14:	31 96       	adiw	r30, 0x01	; 1
}

void usart_transmit_str(const char* data)
{
	// There's still data to go so keep sending it until it ends
	while(*data)
     c16:	90 81       	ld	r25, Z
     c18:	99 23       	and	r25, r25
     c1a:	b1 f7       	brne	.-20     	; 0xc08 <usart_transmit_str+0x8>
     c1c:	08 95       	ret

00000c1e <usart_transmit_str_P>:
        data++;
	}
}

void usart_transmit_str_P(const char* data)
{
     c1e:	ac 01       	movw	r20, r24
  while (pgm_read_byte(data) != 0x00) {
     c20:	9a 01       	movw	r18, r20
     c22:	fa 01       	movw	r30, r20
     c24:	84 91       	lpm	r24, Z+
     c26:	88 23       	and	r24, r24
     c28:	79 f0       	breq	.+30     	; 0xc48 <usart_transmit_str_P+0x2a>
	  usart_transmit(pgm_read_byte(data++));
     c2a:	4f 5f       	subi	r20, 0xFF	; 255
     c2c:	5f 4f       	sbci	r21, 0xFF	; 255
     c2e:	f9 01       	movw	r30, r18
     c30:	94 91       	lpm	r25, Z+
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     c32:	80 91 c0 00 	lds	r24, 0x00C0
     c36:	85 ff       	sbrs	r24, 5
     c38:	fc cf       	rjmp	.-8      	; 0xc32 <usart_transmit_str_P+0x14>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     c3a:	90 93 c6 00 	sts	0x00C6, r25
	}
}

void usart_transmit_str_P(const char* data)
{
  while (pgm_read_byte(data) != 0x00) {
     c3e:	9a 01       	movw	r18, r20
     c40:	fa 01       	movw	r30, r20
     c42:	84 91       	lpm	r24, Z+
     c44:	88 23       	and	r24, r24
     c46:	89 f7       	brne	.-30     	; 0xc2a <usart_transmit_str_P+0xc>
     c48:	08 95       	ret

00000c4a <usart_transmit_int32>:
    usart_transmit_str(buffer);

}

void usart_transmit_int32(uint32_t num)
{
     c4a:	af 92       	push	r10
     c4c:	bf 92       	push	r11
     c4e:	cf 92       	push	r12
     c50:	df 92       	push	r13
     c52:	ef 92       	push	r14
     c54:	ff 92       	push	r15
     c56:	0f 93       	push	r16
     c58:	df 93       	push	r29
     c5a:	cf 93       	push	r28
     c5c:	cd b7       	in	r28, 0x3d	; 61
     c5e:	de b7       	in	r29, 0x3e	; 62
     c60:	2d 97       	sbiw	r28, 0x0d	; 13
     c62:	0f b6       	in	r0, 0x3f	; 63
     c64:	f8 94       	cli
     c66:	de bf       	out	0x3e, r29	; 62
     c68:	0f be       	out	0x3f, r0	; 63
     c6a:	cd bf       	out	0x3d, r28	; 61
     c6c:	6b 01       	movw	r12, r22
     c6e:	7c 01       	movw	r14, r24
	char buffer[11];
  uint8_t i = 0;

  buffer[0] = '0';
     c70:	80 e3       	ldi	r24, 0x30	; 48
     c72:	89 83       	std	Y+1, r24	; 0x01
     c74:	00 e0       	ldi	r16, 0x00	; 0
     c76:	c1 14       	cp	r12, r1
     c78:	d1 04       	cpc	r13, r1
     c7a:	e1 04       	cpc	r14, r1
     c7c:	f1 04       	cpc	r15, r1
     c7e:	21 f5       	brne	.+72     	; 0xcc8 <usart_transmit_int32+0x7e>
     c80:	01 e0       	ldi	r16, 0x01	; 1
    i++;
  }

  // Now we've converted it in reverse, pump it back out correctly
  for(; i > 0; i--) {
    usart_transmit(buffer[i - 1]);
     c82:	fe 01       	movw	r30, r28
     c84:	e0 0f       	add	r30, r16
     c86:	f1 1d       	adc	r31, r1
     c88:	e0 81       	ld	r30, Z
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     c8a:	80 91 c0 00 	lds	r24, 0x00C0
     c8e:	85 ff       	sbrs	r24, 5
     c90:	fc cf       	rjmp	.-8      	; 0xc8a <usart_transmit_int32+0x40>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     c92:	e0 93 c6 00 	sts	0x00C6, r30
    num /= 10;
    i++;
  }

  // Now we've converted it in reverse, pump it back out correctly
  for(; i > 0; i--) {
     c96:	01 50       	subi	r16, 0x01	; 1
     c98:	00 23       	and	r16, r16
     c9a:	99 f7       	brne	.-26     	; 0xc82 <usart_transmit_int32+0x38>
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     c9c:	80 91 c0 00 	lds	r24, 0x00C0
     ca0:	85 ff       	sbrs	r24, 5
     ca2:	fc cf       	rjmp	.-8      	; 0xc9c <usart_transmit_int32+0x52>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     ca4:	10 92 c6 00 	sts	0x00C6, r1
  // Now we've converted it in reverse, pump it back out correctly
  for(; i > 0; i--) {
    usart_transmit(buffer[i - 1]);
  }
  usart_transmit('\0');
}
     ca8:	2d 96       	adiw	r28, 0x0d	; 13
     caa:	0f b6       	in	r0, 0x3f	; 63
     cac:	f8 94       	cli
     cae:	de bf       	out	0x3e, r29	; 62
     cb0:	0f be       	out	0x3f, r0	; 63
     cb2:	cd bf       	out	0x3d, r28	; 61
     cb4:	cf 91       	pop	r28
     cb6:	df 91       	pop	r29
     cb8:	0f 91       	pop	r16
     cba:	ff 90       	pop	r15
     cbc:	ef 90       	pop	r14
     cbe:	df 90       	pop	r13
     cc0:	cf 90       	pop	r12
     cc2:	bf 90       	pop	r11
     cc4:	af 90       	pop	r10
     cc6:	08 95       	ret
     cc8:	5e 01       	movw	r10, r28
     cca:	08 94       	sec
     ccc:	a1 1c       	adc	r10, r1
     cce:	b1 1c       	adc	r11, r1
  if(num == 0) {
    i = 1; // Need to push at least one value out
  }

  while(num > 0) {
    buffer[i] = num % 10 + '0';
     cd0:	c5 01       	movw	r24, r10
     cd2:	80 0f       	add	r24, r16
     cd4:	91 1d       	adc	r25, r1
     cd6:	9d 87       	std	Y+13, r25	; 0x0d
     cd8:	8c 87       	std	Y+12, r24	; 0x0c
     cda:	c7 01       	movw	r24, r14
     cdc:	b6 01       	movw	r22, r12
     cde:	2a e0       	ldi	r18, 0x0A	; 10
     ce0:	30 e0       	ldi	r19, 0x00	; 0
     ce2:	40 e0       	ldi	r20, 0x00	; 0
     ce4:	50 e0       	ldi	r21, 0x00	; 0
     ce6:	0e 94 68 20 	call	0x40d0	; 0x40d0 <__udivmodsi4>
     cea:	60 5d       	subi	r22, 0xD0	; 208
     cec:	ec 85       	ldd	r30, Y+12	; 0x0c
     cee:	fd 85       	ldd	r31, Y+13	; 0x0d
     cf0:	60 83       	st	Z, r22
    num /= 10;
     cf2:	c7 01       	movw	r24, r14
     cf4:	b6 01       	movw	r22, r12
     cf6:	2a e0       	ldi	r18, 0x0A	; 10
     cf8:	30 e0       	ldi	r19, 0x00	; 0
     cfa:	40 e0       	ldi	r20, 0x00	; 0
     cfc:	50 e0       	ldi	r21, 0x00	; 0
     cfe:	0e 94 68 20 	call	0x40d0	; 0x40d0 <__udivmodsi4>
     d02:	c9 01       	movw	r24, r18
     d04:	da 01       	movw	r26, r20
     d06:	6c 01       	movw	r12, r24
     d08:	7d 01       	movw	r14, r26
    i++;
     d0a:	0f 5f       	subi	r16, 0xFF	; 255

  if(num == 0) {
    i = 1; // Need to push at least one value out
  }

  while(num > 0) {
     d0c:	c1 14       	cp	r12, r1
     d0e:	d1 04       	cpc	r13, r1
     d10:	e1 04       	cpc	r14, r1
     d12:	f1 04       	cpc	r15, r1
     d14:	e9 f6       	brne	.-70     	; 0xcd0 <usart_transmit_int32+0x86>
     d16:	c0 cf       	rjmp	.-128    	; 0xc98 <usart_transmit_int32+0x4e>

00000d18 <usart_rec_disable>:
  usart_transmit('\0');
}

void usart_rec_disable(void)
{
	UCSR0B |= (0<<RXEN0);
     d18:	e1 ec       	ldi	r30, 0xC1	; 193
     d1a:	f0 e0       	ldi	r31, 0x00	; 0
     d1c:	80 81       	ld	r24, Z
     d1e:	80 83       	st	Z, r24
}
     d20:	08 95       	ret

00000d22 <usart_rec_enable>:

void usart_rec_enable(void)
{
	UCSR0B |= (1<<RXEN0);
     d22:	e1 ec       	ldi	r30, 0xC1	; 193
     d24:	f0 e0       	ldi	r31, 0x00	; 0
     d26:	80 81       	ld	r24, Z
     d28:	80 61       	ori	r24, 0x10	; 16
     d2a:	80 83       	st	Z, r24
}
     d2c:	08 95       	ret

00000d2e <save_cursor_pos>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     d2e:	80 91 c0 00 	lds	r24, 0x00C0
     d32:	85 ff       	sbrs	r24, 5
     d34:	fc cf       	rjmp	.-8      	; 0xd2e <save_cursor_pos>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     d36:	8b e1       	ldi	r24, 0x1B	; 27
     d38:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     d3c:	80 91 c0 00 	lds	r24, 0x00C0
     d40:	85 ff       	sbrs	r24, 5
     d42:	fc cf       	rjmp	.-8      	; 0xd3c <save_cursor_pos+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     d44:	8b e5       	ldi	r24, 0x5B	; 91
     d46:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     d4a:	80 91 c0 00 	lds	r24, 0x00C0
     d4e:	85 ff       	sbrs	r24, 5
     d50:	fc cf       	rjmp	.-8      	; 0xd4a <save_cursor_pos+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     d52:	83 e7       	ldi	r24, 0x73	; 115
     d54:	80 93 c6 00 	sts	0x00C6, r24
{
    usart_transmit('\x1b');
	usart_transmit('[');

    usart_transmit( 's' );
}
     d58:	08 95       	ret

00000d5a <restore_cursor_pos>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     d5a:	80 91 c0 00 	lds	r24, 0x00C0
     d5e:	85 ff       	sbrs	r24, 5
     d60:	fc cf       	rjmp	.-8      	; 0xd5a <restore_cursor_pos>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     d62:	8b e1       	ldi	r24, 0x1B	; 27
     d64:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     d68:	80 91 c0 00 	lds	r24, 0x00C0
     d6c:	85 ff       	sbrs	r24, 5
     d6e:	fc cf       	rjmp	.-8      	; 0xd68 <restore_cursor_pos+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     d70:	8b e5       	ldi	r24, 0x5B	; 91
     d72:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     d76:	80 91 c0 00 	lds	r24, 0x00C0
     d7a:	85 ff       	sbrs	r24, 5
     d7c:	fc cf       	rjmp	.-8      	; 0xd76 <restore_cursor_pos+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     d7e:	85 e7       	ldi	r24, 0x75	; 117
     d80:	80 93 c6 00 	sts	0x00C6, r24
{
    usart_transmit('\x1b');
	usart_transmit('[');

    usart_transmit( 'u' );
}
     d84:	08 95       	ret

00000d86 <erase_screen_bottom>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     d86:	80 91 c0 00 	lds	r24, 0x00C0
     d8a:	85 ff       	sbrs	r24, 5
     d8c:	fc cf       	rjmp	.-8      	; 0xd86 <erase_screen_bottom>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     d8e:	8b e1       	ldi	r24, 0x1B	; 27
     d90:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     d94:	80 91 c0 00 	lds	r24, 0x00C0
     d98:	85 ff       	sbrs	r24, 5
     d9a:	fc cf       	rjmp	.-8      	; 0xd94 <erase_screen_bottom+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     d9c:	8b e5       	ldi	r24, 0x5B	; 91
     d9e:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     da2:	80 91 c0 00 	lds	r24, 0x00C0
     da6:	85 ff       	sbrs	r24, 5
     da8:	fc cf       	rjmp	.-8      	; 0xda2 <erase_screen_bottom+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     daa:	8a e4       	ldi	r24, 0x4A	; 74
     dac:	80 93 c6 00 	sts	0x00C6, r24
{
    usart_transmit('\x1b');
	usart_transmit('[');

    usart_transmit( 'J' );
}
     db0:	08 95       	ret

00000db2 <erase_screen_top>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     db2:	80 91 c0 00 	lds	r24, 0x00C0
     db6:	85 ff       	sbrs	r24, 5
     db8:	fc cf       	rjmp	.-8      	; 0xdb2 <erase_screen_top>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     dba:	8b e1       	ldi	r24, 0x1B	; 27
     dbc:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     dc0:	80 91 c0 00 	lds	r24, 0x00C0
     dc4:	85 ff       	sbrs	r24, 5
     dc6:	fc cf       	rjmp	.-8      	; 0xdc0 <erase_screen_top+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     dc8:	8b e5       	ldi	r24, 0x5B	; 91
     dca:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     dce:	80 91 c0 00 	lds	r24, 0x00C0
     dd2:	85 ff       	sbrs	r24, 5
     dd4:	fc cf       	rjmp	.-8      	; 0xdce <erase_screen_top+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     dd6:	81 e3       	ldi	r24, 0x31	; 49
     dd8:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     ddc:	80 91 c0 00 	lds	r24, 0x00C0
     de0:	85 ff       	sbrs	r24, 5
     de2:	fc cf       	rjmp	.-8      	; 0xddc <erase_screen_top+0x2a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     de4:	8a e4       	ldi	r24, 0x4A	; 74
     de6:	80 93 c6 00 	sts	0x00C6, r24
    usart_transmit('\x1b');
	usart_transmit('[');         
    
    usart_transmit( '1' );
    usart_transmit( 'J' );
}
     dea:	08 95       	ret

00000dec <erase_screen_endline>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     dec:	80 91 c0 00 	lds	r24, 0x00C0
     df0:	85 ff       	sbrs	r24, 5
     df2:	fc cf       	rjmp	.-8      	; 0xdec <erase_screen_endline>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     df4:	8b e1       	ldi	r24, 0x1B	; 27
     df6:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     dfa:	80 91 c0 00 	lds	r24, 0x00C0
     dfe:	85 ff       	sbrs	r24, 5
     e00:	fc cf       	rjmp	.-8      	; 0xdfa <erase_screen_endline+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e02:	8b e5       	ldi	r24, 0x5B	; 91
     e04:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e08:	80 91 c0 00 	lds	r24, 0x00C0
     e0c:	85 ff       	sbrs	r24, 5
     e0e:	fc cf       	rjmp	.-8      	; 0xe08 <erase_screen_endline+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e10:	8b e4       	ldi	r24, 0x4B	; 75
     e12:	80 93 c6 00 	sts	0x00C6, r24
{
    usart_transmit('\x1b');
	usart_transmit('[');
    
    usart_transmit( 'K' );
}
     e16:	08 95       	ret

00000e18 <erase_screen_startline>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e18:	80 91 c0 00 	lds	r24, 0x00C0
     e1c:	85 ff       	sbrs	r24, 5
     e1e:	fc cf       	rjmp	.-8      	; 0xe18 <erase_screen_startline>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e20:	8b e1       	ldi	r24, 0x1B	; 27
     e22:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e26:	80 91 c0 00 	lds	r24, 0x00C0
     e2a:	85 ff       	sbrs	r24, 5
     e2c:	fc cf       	rjmp	.-8      	; 0xe26 <erase_screen_startline+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e2e:	8b e5       	ldi	r24, 0x5B	; 91
     e30:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e34:	80 91 c0 00 	lds	r24, 0x00C0
     e38:	85 ff       	sbrs	r24, 5
     e3a:	fc cf       	rjmp	.-8      	; 0xe34 <erase_screen_startline+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e3c:	81 e3       	ldi	r24, 0x31	; 49
     e3e:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e42:	80 91 c0 00 	lds	r24, 0x00C0
     e46:	85 ff       	sbrs	r24, 5
     e48:	fc cf       	rjmp	.-8      	; 0xe42 <erase_screen_startline+0x2a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e4a:	8b e4       	ldi	r24, 0x4B	; 75
     e4c:	80 93 c6 00 	sts	0x00C6, r24
    usart_transmit('\x1b');
	usart_transmit('[');
    
    usart_transmit( '1' );
    usart_transmit( 'K' );
}
     e50:	08 95       	ret

00000e52 <erase_screen_line>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e52:	80 91 c0 00 	lds	r24, 0x00C0
     e56:	85 ff       	sbrs	r24, 5
     e58:	fc cf       	rjmp	.-8      	; 0xe52 <erase_screen_line>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e5a:	8b e1       	ldi	r24, 0x1B	; 27
     e5c:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e60:	80 91 c0 00 	lds	r24, 0x00C0
     e64:	85 ff       	sbrs	r24, 5
     e66:	fc cf       	rjmp	.-8      	; 0xe60 <erase_screen_line+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e68:	8b e5       	ldi	r24, 0x5B	; 91
     e6a:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e6e:	80 91 c0 00 	lds	r24, 0x00C0
     e72:	85 ff       	sbrs	r24, 5
     e74:	fc cf       	rjmp	.-8      	; 0xe6e <erase_screen_line+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e76:	82 e3       	ldi	r24, 0x32	; 50
     e78:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e7c:	80 91 c0 00 	lds	r24, 0x00C0
     e80:	85 ff       	sbrs	r24, 5
     e82:	fc cf       	rjmp	.-8      	; 0xe7c <erase_screen_line+0x2a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e84:	8b e4       	ldi	r24, 0x4B	; 75
     e86:	80 93 c6 00 	sts	0x00C6, r24
    usart_transmit('\x1b');
	usart_transmit('[');
    
    usart_transmit( '2' );
    usart_transmit( 'K' );
}
     e8a:	08 95       	ret

00000e8c <ht_set_display_colour>:

void ht_set_display_colour( unsigned char fg_bg, unsigned char colour )
{
     e8c:	98 2f       	mov	r25, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e8e:	80 91 c0 00 	lds	r24, 0x00C0
     e92:	85 ff       	sbrs	r24, 5
     e94:	fc cf       	rjmp	.-8      	; 0xe8e <ht_set_display_colour+0x2>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e96:	8b e1       	ldi	r24, 0x1B	; 27
     e98:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e9c:	80 91 c0 00 	lds	r24, 0x00C0
     ea0:	85 ff       	sbrs	r24, 5
     ea2:	fc cf       	rjmp	.-8      	; 0xe9c <ht_set_display_colour+0x10>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     ea4:	8b e5       	ldi	r24, 0x5B	; 91
     ea6:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     eaa:	80 91 c0 00 	lds	r24, 0x00C0
     eae:	85 ff       	sbrs	r24, 5
     eb0:	fc cf       	rjmp	.-8      	; 0xeaa <ht_set_display_colour+0x1e>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     eb2:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     eb6:	80 91 c0 00 	lds	r24, 0x00C0
     eba:	85 ff       	sbrs	r24, 5
     ebc:	fc cf       	rjmp	.-8      	; 0xeb6 <ht_set_display_colour+0x2a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     ebe:	60 93 c6 00 	sts	0x00C6, r22
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     ec2:	80 91 c0 00 	lds	r24, 0x00C0
     ec6:	85 ff       	sbrs	r24, 5
     ec8:	fc cf       	rjmp	.-8      	; 0xec2 <ht_set_display_colour+0x36>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     eca:	8d e6       	ldi	r24, 0x6D	; 109
     ecc:	80 93 c6 00 	sts	0x00C6, r24
	usart_transmit('[');
    
    usart_transmit( fg_bg );                 // Select foreground/background
    usart_transmit( colour );
    usart_transmit( 'm' );
}
     ed0:	08 95       	ret

00000ed2 <ht_set_display_attribute_mode>:

void ht_set_display_attribute_mode( unsigned char mode )
{
     ed2:	98 2f       	mov	r25, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     ed4:	80 91 c0 00 	lds	r24, 0x00C0
     ed8:	85 ff       	sbrs	r24, 5
     eda:	fc cf       	rjmp	.-8      	; 0xed4 <ht_set_display_attribute_mode+0x2>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     edc:	8b e1       	ldi	r24, 0x1B	; 27
     ede:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     ee2:	80 91 c0 00 	lds	r24, 0x00C0
     ee6:	85 ff       	sbrs	r24, 5
     ee8:	fc cf       	rjmp	.-8      	; 0xee2 <ht_set_display_attribute_mode+0x10>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     eea:	8b e5       	ldi	r24, 0x5B	; 91
     eec:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     ef0:	80 91 c0 00 	lds	r24, 0x00C0
     ef4:	85 ff       	sbrs	r24, 5
     ef6:	fc cf       	rjmp	.-8      	; 0xef0 <ht_set_display_attribute_mode+0x1e>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     ef8:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     efc:	80 91 c0 00 	lds	r24, 0x00C0
     f00:	85 ff       	sbrs	r24, 5
     f02:	fc cf       	rjmp	.-8      	; 0xefc <ht_set_display_attribute_mode+0x2a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f04:	8d e6       	ldi	r24, 0x6D	; 109
     f06:	80 93 c6 00 	sts	0x00C6, r24
    usart_transmit('\x1b');
	usart_transmit('[');
    
    usart_transmit( mode );
    usart_transmit( 'm' );
}
     f0a:	08 95       	ret

00000f0c <ht_scroll_all>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f0c:	80 91 c0 00 	lds	r24, 0x00C0
     f10:	85 ff       	sbrs	r24, 5
     f12:	fc cf       	rjmp	.-8      	; 0xf0c <ht_scroll_all>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f14:	8b e1       	ldi	r24, 0x1B	; 27
     f16:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f1a:	80 91 c0 00 	lds	r24, 0x00C0
     f1e:	85 ff       	sbrs	r24, 5
     f20:	fc cf       	rjmp	.-8      	; 0xf1a <ht_scroll_all+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f22:	8b e5       	ldi	r24, 0x5B	; 91
     f24:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f28:	80 91 c0 00 	lds	r24, 0x00C0
     f2c:	85 ff       	sbrs	r24, 5
     f2e:	fc cf       	rjmp	.-8      	; 0xf28 <ht_scroll_all+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f30:	82 e7       	ldi	r24, 0x72	; 114
     f32:	80 93 c6 00 	sts	0x00C6, r24
{
    usart_transmit('\x1b');
	usart_transmit('[');
    
    usart_transmit( 'r' );
}
     f36:	08 95       	ret

00000f38 <ht_print_screen>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f38:	80 91 c0 00 	lds	r24, 0x00C0
     f3c:	85 ff       	sbrs	r24, 5
     f3e:	fc cf       	rjmp	.-8      	; 0xf38 <ht_print_screen>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f40:	8b e1       	ldi	r24, 0x1B	; 27
     f42:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f46:	80 91 c0 00 	lds	r24, 0x00C0
     f4a:	85 ff       	sbrs	r24, 5
     f4c:	fc cf       	rjmp	.-8      	; 0xf46 <ht_print_screen+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f4e:	8b e5       	ldi	r24, 0x5B	; 91
     f50:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f54:	80 91 c0 00 	lds	r24, 0x00C0
     f58:	85 ff       	sbrs	r24, 5
     f5a:	fc cf       	rjmp	.-8      	; 0xf54 <ht_print_screen+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f5c:	89 e6       	ldi	r24, 0x69	; 105
     f5e:	80 93 c6 00 	sts	0x00C6, r24
{
    usart_transmit('\x1b');
	usart_transmit('[');                         // Send escape sequence start
   
    usart_transmit( 'i' );
}
     f62:	08 95       	ret

00000f64 <usart_transmit_dec>:

//***************************
// Convert byte to 3 ASCII digits and send
//***************************
void usart_transmit_dec( unsigned char value )
{
     f64:	38 2f       	mov	r19, r24
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
     f66:	84 36       	cpi	r24, 0x64	; 100
     f68:	70 f1       	brcs	.+92     	; 0xfc6 <usart_transmit_dec+0x62>

//***************************
// Convert byte to 3 ASCII digits and send
//***************************
void usart_transmit_dec( unsigned char value )
{
     f6a:	28 2f       	mov	r18, r24
     f6c:	24 56       	subi	r18, 0x64	; 100
     f6e:	82 2f       	mov	r24, r18
     f70:	64 e6       	ldi	r22, 0x64	; 100
     f72:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
     f76:	39 2f       	mov	r19, r25
     f78:	82 2f       	mov	r24, r18
     f7a:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
     f7e:	98 2f       	mov	r25, r24
     f80:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f82:	80 91 c0 00 	lds	r24, 0x00C0
     f86:	85 ff       	sbrs	r24, 5
     f88:	fc cf       	rjmp	.-8      	; 0xf82 <usart_transmit_dec+0x1e>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f8a:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
     f8e:	3a 30       	cpi	r19, 0x0A	; 10
     f90:	e0 f0       	brcs	.+56     	; 0xfca <usart_transmit_dec+0x66>

//***************************
// Convert byte to 3 ASCII digits and send
//***************************
void usart_transmit_dec( unsigned char value )
{
     f92:	23 2f       	mov	r18, r19
     f94:	2a 50       	subi	r18, 0x0A	; 10
     f96:	82 2f       	mov	r24, r18
     f98:	6a e0       	ldi	r22, 0x0A	; 10
     f9a:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
     f9e:	39 2f       	mov	r19, r25
     fa0:	82 2f       	mov	r24, r18
     fa2:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
     fa6:	98 2f       	mov	r25, r24
     fa8:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     faa:	80 91 c0 00 	lds	r24, 0x00C0
     fae:	85 ff       	sbrs	r24, 5
     fb0:	fc cf       	rjmp	.-8      	; 0xfaa <usart_transmit_dec+0x46>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     fb2:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     fb6:	80 91 c0 00 	lds	r24, 0x00C0
     fba:	85 ff       	sbrs	r24, 5
     fbc:	fc cf       	rjmp	.-8      	; 0xfb6 <usart_transmit_dec+0x52>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
     fbe:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     fc0:	30 93 c6 00 	sts	0x00C6, r19
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
}
     fc4:	08 95       	ret
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
     fc6:	90 e3       	ldi	r25, 0x30	; 48
     fc8:	dc cf       	rjmp	.-72     	; 0xf82 <usart_transmit_dec+0x1e>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
     fca:	90 e3       	ldi	r25, 0x30	; 48
     fcc:	ee cf       	rjmp	.-36     	; 0xfaa <usart_transmit_dec+0x46>

00000fce <usart_init_Xlarge>:
    usart_transmit( '0' + value );            // Send third digit
}


void usart_init_Xlarge(uint32_t baud)
{
     fce:	9b 01       	movw	r18, r22
     fd0:	ac 01       	movw	r20, r24
	// Set baud rate: 19200bps when @ 8Mhz
	UBRR0H = (unsigned char)(25>>8);
	UBRR0L = (unsigned char)25;
*/
	// Calculate the baud value
	uint16_t num = (uint32_t)F_CPU / (16 * baud) - 1;
     fd2:	22 0f       	add	r18, r18
     fd4:	33 1f       	adc	r19, r19
     fd6:	44 1f       	adc	r20, r20
     fd8:	55 1f       	adc	r21, r21
     fda:	22 0f       	add	r18, r18
     fdc:	33 1f       	adc	r19, r19
     fde:	44 1f       	adc	r20, r20
     fe0:	55 1f       	adc	r21, r21
     fe2:	22 0f       	add	r18, r18
     fe4:	33 1f       	adc	r19, r19
     fe6:	44 1f       	adc	r20, r20
     fe8:	55 1f       	adc	r21, r21
     fea:	22 0f       	add	r18, r18
     fec:	33 1f       	adc	r19, r19
     fee:	44 1f       	adc	r20, r20
     ff0:	55 1f       	adc	r21, r21
     ff2:	60 e0       	ldi	r22, 0x00	; 0
     ff4:	70 ec       	ldi	r23, 0xC0	; 192
     ff6:	89 e8       	ldi	r24, 0x89	; 137
     ff8:	91 e0       	ldi	r25, 0x01	; 1
     ffa:	0e 94 68 20 	call	0x40d0	; 0x40d0 <__udivmodsi4>
     ffe:	21 50       	subi	r18, 0x01	; 1
    1000:	30 40       	sbci	r19, 0x00	; 0
	
	// Set baud rate 
	UBRR0H = (unsigned char)(num>>8);
    1002:	30 93 c5 00 	sts	0x00C5, r19
	UBRR0L = (unsigned char)num;
    1006:	20 93 c4 00 	sts	0x00C4, r18
	/* Enable receiver and transmitter */
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    100a:	88 e1       	ldi	r24, 0x18	; 24
    100c:	80 93 c1 00 	sts	0x00C1, r24
	/* Set frame format: 8data, 1stop bit */
	UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
    1010:	86 e0       	ldi	r24, 0x06	; 6
    1012:	80 93 c2 00 	sts	0x00C2, r24
}
    1016:	08 95       	ret

00001018 <usart_data_received>:

uint8_t usart_data_received(void)
{
	if(UCSR0A & (1<<RXC0))
    1018:	80 91 c0 00 	lds	r24, 0x00C0
	{
		return 1;
	}
	return 0;
}
    101c:	88 1f       	adc	r24, r24
    101e:	88 27       	eor	r24, r24
    1020:	88 1f       	adc	r24, r24
    1022:	08 95       	ret

00001024 <usart_int_enable>:

int usart_int_enable(int(*func)(unsigned char))
{
  UCSR0B |= (1 << RXCIE0);
    1024:	e1 ec       	ldi	r30, 0xC1	; 193
    1026:	f0 e0       	ldi	r31, 0x00	; 0
    1028:	20 81       	ld	r18, Z
    102a:	20 68       	ori	r18, 0x80	; 128
    102c:	20 83       	st	Z, r18
  
  _rx_func = func;
    102e:	90 93 53 01 	sts	0x0153, r25
    1032:	80 93 52 01 	sts	0x0152, r24

  return 0;
}
    1036:	80 e0       	ldi	r24, 0x00	; 0
    1038:	90 e0       	ldi	r25, 0x00	; 0
    103a:	08 95       	ret

0000103c <usart_int_disable>:

int usart_int_disable(int(*func)(unsigned char))
{
  UCSR0B &= ~(1 << RXCIE0);
    103c:	e1 ec       	ldi	r30, 0xC1	; 193
    103e:	f0 e0       	ldi	r31, 0x00	; 0
    1040:	80 81       	ld	r24, Z
    1042:	8f 77       	andi	r24, 0x7F	; 127
    1044:	80 83       	st	Z, r24

  return 0;
}
    1046:	80 e0       	ldi	r24, 0x00	; 0
    1048:	90 e0       	ldi	r25, 0x00	; 0
    104a:	08 95       	ret

0000104c <__vector_20>:

ISR(USART0_RX_vect)
{
    104c:	1f 92       	push	r1
    104e:	0f 92       	push	r0
    1050:	0f b6       	in	r0, 0x3f	; 63
    1052:	0f 92       	push	r0
    1054:	11 24       	eor	r1, r1
    1056:	2f 93       	push	r18
    1058:	3f 93       	push	r19
    105a:	4f 93       	push	r20
    105c:	5f 93       	push	r21
    105e:	6f 93       	push	r22
    1060:	7f 93       	push	r23
    1062:	8f 93       	push	r24
    1064:	9f 93       	push	r25
    1066:	af 93       	push	r26
    1068:	bf 93       	push	r27
    106a:	ef 93       	push	r30
    106c:	ff 93       	push	r31
  (*_rx_func)(UDR0);
    106e:	80 91 c6 00 	lds	r24, 0x00C6
    1072:	e0 91 52 01 	lds	r30, 0x0152
    1076:	f0 91 53 01 	lds	r31, 0x0153
    107a:	09 95       	icall
}
    107c:	ff 91       	pop	r31
    107e:	ef 91       	pop	r30
    1080:	bf 91       	pop	r27
    1082:	af 91       	pop	r26
    1084:	9f 91       	pop	r25
    1086:	8f 91       	pop	r24
    1088:	7f 91       	pop	r23
    108a:	6f 91       	pop	r22
    108c:	5f 91       	pop	r21
    108e:	4f 91       	pop	r20
    1090:	3f 91       	pop	r19
    1092:	2f 91       	pop	r18
    1094:	0f 90       	pop	r0
    1096:	0f be       	out	0x3f, r0	; 63
    1098:	0f 90       	pop	r0
    109a:	1f 90       	pop	r1
    109c:	18 95       	reti

0000109e <nibble_to_hex>:

char nibble_to_hex(uint8_t value) {
    109e:	df 93       	push	r29
    10a0:	cf 93       	push	r28
    10a2:	cd b7       	in	r28, 0x3d	; 61
    10a4:	de b7       	in	r29, 0x3e	; 62
    10a6:	60 97       	sbiw	r28, 0x10	; 16
    10a8:	0f b6       	in	r0, 0x3f	; 63
    10aa:	f8 94       	cli
    10ac:	de bf       	out	0x3e, r29	; 62
    10ae:	0f be       	out	0x3f, r0	; 63
    10b0:	cd bf       	out	0x3d, r28	; 61

  char ASCII[] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46};
    10b2:	ae 01       	movw	r20, r28
    10b4:	4f 5f       	subi	r20, 0xFF	; 255
    10b6:	5f 4f       	sbci	r21, 0xFF	; 255
    10b8:	9a 01       	movw	r18, r20
    10ba:	e5 e0       	ldi	r30, 0x05	; 5
    10bc:	f1 e0       	ldi	r31, 0x01	; 1
    10be:	90 e1       	ldi	r25, 0x10	; 16
    10c0:	01 90       	ld	r0, Z+
    10c2:	d9 01       	movw	r26, r18
    10c4:	0d 92       	st	X+, r0
    10c6:	9d 01       	movw	r18, r26
    10c8:	91 50       	subi	r25, 0x01	; 1
    10ca:	d1 f7       	brne	.-12     	; 0x10c0 <nibble_to_hex+0x22>
    10cc:	8f 70       	andi	r24, 0x0F	; 15
    10ce:	48 0f       	add	r20, r24
    10d0:	51 1d       	adc	r21, r1

  return ASCII[(value & 0x0F)];
}
    10d2:	fa 01       	movw	r30, r20
    10d4:	80 81       	ld	r24, Z
    10d6:	60 96       	adiw	r28, 0x10	; 16
    10d8:	0f b6       	in	r0, 0x3f	; 63
    10da:	f8 94       	cli
    10dc:	de bf       	out	0x3e, r29	; 62
    10de:	0f be       	out	0x3f, r0	; 63
    10e0:	cd bf       	out	0x3d, r28	; 61
    10e2:	cf 91       	pop	r28
    10e4:	df 91       	pop	r29
    10e6:	08 95       	ret

000010e8 <usart_clear_ht>:
{
	UCSR0B |= (1<<RXEN0);
}

void usart_clear_ht(void)
{
    10e8:	e0 e0       	ldi	r30, 0x00	; 0
    10ea:	f1 e0       	ldi	r31, 0x01	; 1
    10ec:	9b e1       	ldi	r25, 0x1B	; 27
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    10ee:	80 91 c0 00 	lds	r24, 0x00C0
    10f2:	85 ff       	sbrs	r24, 5
    10f4:	fc cf       	rjmp	.-8      	; 0x10ee <usart_clear_ht+0x6>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    10f6:	90 93 c6 00 	sts	0x00C6, r25
{
	// There's still data to go so keep sending it until it ends
	while(*data)
	{
		usart_transmit(*data);
        data++;
    10fa:	31 96       	adiw	r30, 0x01	; 1
}

void usart_transmit_str(const char* data)
{
	// There's still data to go so keep sending it until it ends
	while(*data)
    10fc:	90 81       	ld	r25, Z
    10fe:	99 23       	and	r25, r25
    1100:	b1 f7       	brne	.-20     	; 0x10ee <usart_clear_ht+0x6>
}

void usart_clear_ht(void)
{
	usart_transmit_str("\x1b[2J");
}
    1102:	08 95       	ret

00001104 <usart_transmit_int>:
	  usart_transmit(pgm_read_byte(data++));
  }
}

void usart_transmit_int(int16_t num)
{
    1104:	df 93       	push	r29
    1106:	cf 93       	push	r28
    1108:	cd b7       	in	r28, 0x3d	; 61
    110a:	de b7       	in	r29, 0x3e	; 62
    110c:	2a 97       	sbiw	r28, 0x0a	; 10
    110e:	0f b6       	in	r0, 0x3f	; 63
    1110:	f8 94       	cli
    1112:	de bf       	out	0x3e, r29	; 62
    1114:	0f be       	out	0x3f, r0	; 63
    1116:	cd bf       	out	0x3d, r28	; 61
    1118:	9c 01       	movw	r18, r24
	char buffer[10];
    uint16_t n, i;
    for(n = 10000, i = 0; n > 0; n /= 10, i++)
    {
        buffer[i] = ((num / n) % 10) + '0';
    111a:	60 e1       	ldi	r22, 0x10	; 16
    111c:	77 e2       	ldi	r23, 0x27	; 39
    111e:	0e 94 54 20 	call	0x40a8	; 0x40a8 <__udivmodhi4>
    1122:	cb 01       	movw	r24, r22
    1124:	6a e0       	ldi	r22, 0x0A	; 10
    1126:	70 e0       	ldi	r23, 0x00	; 0
    1128:	0e 94 54 20 	call	0x40a8	; 0x40a8 <__udivmodhi4>
    112c:	48 2f       	mov	r20, r24
    112e:	40 5d       	subi	r20, 0xD0	; 208
    1130:	49 83       	std	Y+1, r20	; 0x01
    1132:	c9 01       	movw	r24, r18
    1134:	68 ee       	ldi	r22, 0xE8	; 232
    1136:	73 e0       	ldi	r23, 0x03	; 3
    1138:	0e 94 54 20 	call	0x40a8	; 0x40a8 <__udivmodhi4>
    113c:	cb 01       	movw	r24, r22
    113e:	6a e0       	ldi	r22, 0x0A	; 10
    1140:	70 e0       	ldi	r23, 0x00	; 0
    1142:	0e 94 54 20 	call	0x40a8	; 0x40a8 <__udivmodhi4>
    1146:	80 5d       	subi	r24, 0xD0	; 208
    1148:	8a 83       	std	Y+2, r24	; 0x02
    114a:	c9 01       	movw	r24, r18
    114c:	64 e6       	ldi	r22, 0x64	; 100
    114e:	70 e0       	ldi	r23, 0x00	; 0
    1150:	0e 94 54 20 	call	0x40a8	; 0x40a8 <__udivmodhi4>
    1154:	cb 01       	movw	r24, r22
    1156:	6a e0       	ldi	r22, 0x0A	; 10
    1158:	70 e0       	ldi	r23, 0x00	; 0
    115a:	0e 94 54 20 	call	0x40a8	; 0x40a8 <__udivmodhi4>
    115e:	80 5d       	subi	r24, 0xD0	; 208
    1160:	8b 83       	std	Y+3, r24	; 0x03
    1162:	c9 01       	movw	r24, r18
    1164:	6a e0       	ldi	r22, 0x0A	; 10
    1166:	70 e0       	ldi	r23, 0x00	; 0
    1168:	0e 94 54 20 	call	0x40a8	; 0x40a8 <__udivmodhi4>
    116c:	cb 01       	movw	r24, r22
    116e:	6a e0       	ldi	r22, 0x0A	; 10
    1170:	70 e0       	ldi	r23, 0x00	; 0
    1172:	0e 94 54 20 	call	0x40a8	; 0x40a8 <__udivmodhi4>
    1176:	80 5d       	subi	r24, 0xD0	; 208
    1178:	8c 83       	std	Y+4, r24	; 0x04
    117a:	c9 01       	movw	r24, r18
    117c:	6a e0       	ldi	r22, 0x0A	; 10
    117e:	70 e0       	ldi	r23, 0x00	; 0
    1180:	0e 94 54 20 	call	0x40a8	; 0x40a8 <__udivmodhi4>
    1184:	80 5d       	subi	r24, 0xD0	; 208
    1186:	8d 83       	std	Y+5, r24	; 0x05
    }
    buffer[i] = '\0';
    1188:	1e 82       	std	Y+6, r1	; 0x06
}

void usart_transmit_str(const char* data)
{
	// There's still data to go so keep sending it until it ends
	while(*data)
    118a:	44 23       	and	r20, r20
    118c:	61 f0       	breq	.+24     	; 0x11a6 <usart_transmit_int+0xa2>
    118e:	fe 01       	movw	r30, r28
    1190:	31 96       	adiw	r30, 0x01	; 1
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1192:	80 91 c0 00 	lds	r24, 0x00C0
    1196:	85 ff       	sbrs	r24, 5
    1198:	fc cf       	rjmp	.-8      	; 0x1192 <usart_transmit_int+0x8e>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    119a:	40 93 c6 00 	sts	0x00C6, r20
{
	// There's still data to go so keep sending it until it ends
	while(*data)
	{
		usart_transmit(*data);
        data++;
    119e:	31 96       	adiw	r30, 0x01	; 1
}

void usart_transmit_str(const char* data)
{
	// There's still data to go so keep sending it until it ends
	while(*data)
    11a0:	40 81       	ld	r20, Z
    11a2:	44 23       	and	r20, r20
    11a4:	b1 f7       	brne	.-20     	; 0x1192 <usart_transmit_int+0x8e>
        buffer[i] = ((num / n) % 10) + '0';
    }
    buffer[i] = '\0';
    usart_transmit_str(buffer);

}
    11a6:	2a 96       	adiw	r28, 0x0a	; 10
    11a8:	0f b6       	in	r0, 0x3f	; 63
    11aa:	f8 94       	cli
    11ac:	de bf       	out	0x3e, r29	; 62
    11ae:	0f be       	out	0x3f, r0	; 63
    11b0:	cd bf       	out	0x3d, r28	; 61
    11b2:	cf 91       	pop	r28
    11b4:	df 91       	pop	r29
    11b6:	08 95       	ret

000011b8 <move_cursor>:
{
	usart_transmit_str("\x1b[2J");
}

void move_cursor(int distance, int direction) 
{
    11b8:	98 2f       	mov	r25, r24
    11ba:	46 2f       	mov	r20, r22
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    11bc:	80 91 c0 00 	lds	r24, 0x00C0
    11c0:	85 ff       	sbrs	r24, 5
    11c2:	fc cf       	rjmp	.-8      	; 0x11bc <move_cursor+0x4>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    11c4:	8b e1       	ldi	r24, 0x1B	; 27
    11c6:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    11ca:	80 91 c0 00 	lds	r24, 0x00C0
    11ce:	85 ff       	sbrs	r24, 5
    11d0:	fc cf       	rjmp	.-8      	; 0x11ca <move_cursor+0x12>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    11d2:	8b e5       	ldi	r24, 0x5B	; 91
    11d4:	80 93 c6 00 	sts	0x00C6, r24
void move_cursor(int distance, int direction) 
{
	usart_transmit('\x1b');
	usart_transmit('[');

	usart_transmit_dec(distance);
    11d8:	39 2f       	mov	r19, r25
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    11da:	94 36       	cpi	r25, 0x64	; 100
    11dc:	a8 f1       	brcs	.+106    	; 0x1248 <move_cursor+0x90>
{
	usart_transmit_str("\x1b[2J");
}

void move_cursor(int distance, int direction) 
{
    11de:	29 2f       	mov	r18, r25
    11e0:	24 56       	subi	r18, 0x64	; 100
    11e2:	82 2f       	mov	r24, r18
    11e4:	64 e6       	ldi	r22, 0x64	; 100
    11e6:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    11ea:	9c e9       	ldi	r25, 0x9C	; 156
    11ec:	89 9f       	mul	r24, r25
    11ee:	30 2d       	mov	r19, r0
    11f0:	11 24       	eor	r1, r1
    11f2:	32 0f       	add	r19, r18
    11f4:	98 2f       	mov	r25, r24
    11f6:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    11f8:	80 91 c0 00 	lds	r24, 0x00C0
    11fc:	85 ff       	sbrs	r24, 5
    11fe:	fc cf       	rjmp	.-8      	; 0x11f8 <move_cursor+0x40>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1200:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    1204:	3a 30       	cpi	r19, 0x0A	; 10
    1206:	10 f1       	brcs	.+68     	; 0x124c <move_cursor+0x94>
{
	usart_transmit_str("\x1b[2J");
}

void move_cursor(int distance, int direction) 
{
    1208:	23 2f       	mov	r18, r19
    120a:	2a 50       	subi	r18, 0x0A	; 10
    120c:	82 2f       	mov	r24, r18
    120e:	6a e0       	ldi	r22, 0x0A	; 10
    1210:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    1214:	39 2f       	mov	r19, r25
    1216:	82 2f       	mov	r24, r18
    1218:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    121c:	98 2f       	mov	r25, r24
    121e:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1220:	80 91 c0 00 	lds	r24, 0x00C0
    1224:	85 ff       	sbrs	r24, 5
    1226:	fc cf       	rjmp	.-8      	; 0x1220 <move_cursor+0x68>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1228:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    122c:	80 91 c0 00 	lds	r24, 0x00C0
    1230:	85 ff       	sbrs	r24, 5
    1232:	fc cf       	rjmp	.-8      	; 0x122c <move_cursor+0x74>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    1234:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1236:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    123a:	80 91 c0 00 	lds	r24, 0x00C0
    123e:	85 ff       	sbrs	r24, 5
    1240:	fc cf       	rjmp	.-8      	; 0x123a <move_cursor+0x82>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1242:	40 93 c6 00 	sts	0x00C6, r20
	usart_transmit('\x1b');
	usart_transmit('[');

	usart_transmit_dec(distance);
	usart_transmit(direction);
}
    1246:	08 95       	ret
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    1248:	90 e3       	ldi	r25, 0x30	; 48
    124a:	d6 cf       	rjmp	.-84     	; 0x11f8 <move_cursor+0x40>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    124c:	90 e3       	ldi	r25, 0x30	; 48
    124e:	e8 cf       	rjmp	.-48     	; 0x1220 <move_cursor+0x68>

00001250 <ht_scroll_limit>:
    
    usart_transmit( 'r' );
}

void ht_scroll_limit( unsigned char start, unsigned char end )
{
    1250:	38 2f       	mov	r19, r24
    1252:	46 2f       	mov	r20, r22
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1254:	80 91 c0 00 	lds	r24, 0x00C0
    1258:	85 ff       	sbrs	r24, 5
    125a:	fc cf       	rjmp	.-8      	; 0x1254 <ht_scroll_limit+0x4>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    125c:	8b e1       	ldi	r24, 0x1B	; 27
    125e:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1262:	80 91 c0 00 	lds	r24, 0x00C0
    1266:	85 ff       	sbrs	r24, 5
    1268:	fc cf       	rjmp	.-8      	; 0x1262 <ht_scroll_limit+0x12>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    126a:	8b e5       	ldi	r24, 0x5B	; 91
    126c:	80 93 c6 00 	sts	0x00C6, r24
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    1270:	34 36       	cpi	r19, 0x64	; 100
    1272:	08 f4       	brcc	.+2      	; 0x1276 <ht_scroll_limit+0x26>
    1274:	6c c0       	rjmp	.+216    	; 0x134e <ht_scroll_limit+0xfe>
    
    usart_transmit( 'r' );
}

void ht_scroll_limit( unsigned char start, unsigned char end )
{
    1276:	23 2f       	mov	r18, r19
    1278:	24 56       	subi	r18, 0x64	; 100
    127a:	82 2f       	mov	r24, r18
    127c:	64 e6       	ldi	r22, 0x64	; 100
    127e:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    1282:	39 2f       	mov	r19, r25
    1284:	82 2f       	mov	r24, r18
    1286:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    128a:	98 2f       	mov	r25, r24
    128c:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    128e:	80 91 c0 00 	lds	r24, 0x00C0
    1292:	85 ff       	sbrs	r24, 5
    1294:	fc cf       	rjmp	.-8      	; 0x128e <ht_scroll_limit+0x3e>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1296:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    129a:	3a 30       	cpi	r19, 0x0A	; 10
    129c:	08 f4       	brcc	.+2      	; 0x12a0 <ht_scroll_limit+0x50>
    129e:	59 c0       	rjmp	.+178    	; 0x1352 <ht_scroll_limit+0x102>
    
    usart_transmit( 'r' );
}

void ht_scroll_limit( unsigned char start, unsigned char end )
{
    12a0:	23 2f       	mov	r18, r19
    12a2:	2a 50       	subi	r18, 0x0A	; 10
    12a4:	82 2f       	mov	r24, r18
    12a6:	6a e0       	ldi	r22, 0x0A	; 10
    12a8:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    12ac:	39 2f       	mov	r19, r25
    12ae:	82 2f       	mov	r24, r18
    12b0:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    12b4:	98 2f       	mov	r25, r24
    12b6:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    12b8:	80 91 c0 00 	lds	r24, 0x00C0
    12bc:	85 ff       	sbrs	r24, 5
    12be:	fc cf       	rjmp	.-8      	; 0x12b8 <ht_scroll_limit+0x68>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    12c0:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    12c4:	80 91 c0 00 	lds	r24, 0x00C0
    12c8:	85 ff       	sbrs	r24, 5
    12ca:	fc cf       	rjmp	.-8      	; 0x12c4 <ht_scroll_limit+0x74>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    12cc:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    12ce:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    12d2:	80 91 c0 00 	lds	r24, 0x00C0
    12d6:	85 ff       	sbrs	r24, 5
    12d8:	fc cf       	rjmp	.-8      	; 0x12d2 <ht_scroll_limit+0x82>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    12da:	8b e3       	ldi	r24, 0x3B	; 59
    12dc:	80 93 c6 00 	sts	0x00C6, r24
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    12e0:	44 36       	cpi	r20, 0x64	; 100
    12e2:	c8 f1       	brcs	.+114    	; 0x1356 <ht_scroll_limit+0x106>
    
    usart_transmit( 'r' );
}

void ht_scroll_limit( unsigned char start, unsigned char end )
{
    12e4:	24 2f       	mov	r18, r20
    12e6:	24 56       	subi	r18, 0x64	; 100
    12e8:	82 2f       	mov	r24, r18
    12ea:	64 e6       	ldi	r22, 0x64	; 100
    12ec:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    12f0:	49 2f       	mov	r20, r25
    12f2:	82 2f       	mov	r24, r18
    12f4:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    12f8:	98 2f       	mov	r25, r24
    12fa:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    12fc:	80 91 c0 00 	lds	r24, 0x00C0
    1300:	85 ff       	sbrs	r24, 5
    1302:	fc cf       	rjmp	.-8      	; 0x12fc <ht_scroll_limit+0xac>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1304:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    1308:	4a 30       	cpi	r20, 0x0A	; 10
    130a:	38 f1       	brcs	.+78     	; 0x135a <ht_scroll_limit+0x10a>
    
    usart_transmit( 'r' );
}

void ht_scroll_limit( unsigned char start, unsigned char end )
{
    130c:	24 2f       	mov	r18, r20
    130e:	2a 50       	subi	r18, 0x0A	; 10
    1310:	82 2f       	mov	r24, r18
    1312:	6a e0       	ldi	r22, 0x0A	; 10
    1314:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    1318:	49 2f       	mov	r20, r25
    131a:	82 2f       	mov	r24, r18
    131c:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    1320:	98 2f       	mov	r25, r24
    1322:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1324:	80 91 c0 00 	lds	r24, 0x00C0
    1328:	85 ff       	sbrs	r24, 5
    132a:	fc cf       	rjmp	.-8      	; 0x1324 <ht_scroll_limit+0xd4>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    132c:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1330:	80 91 c0 00 	lds	r24, 0x00C0
    1334:	85 ff       	sbrs	r24, 5
    1336:	fc cf       	rjmp	.-8      	; 0x1330 <ht_scroll_limit+0xe0>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    1338:	40 5d       	subi	r20, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    133a:	40 93 c6 00 	sts	0x00C6, r20
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    133e:	80 91 c0 00 	lds	r24, 0x00C0
    1342:	85 ff       	sbrs	r24, 5
    1344:	fc cf       	rjmp	.-8      	; 0x133e <ht_scroll_limit+0xee>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1346:	82 e7       	ldi	r24, 0x72	; 114
    1348:	80 93 c6 00 	sts	0x00C6, r24
    
    usart_transmit_dec( start );            // Convert start line byte
    usart_transmit( ';' );
    usart_transmit_dec( end );              // Convert end line byte
    usart_transmit( 'r' );
}
    134c:	08 95       	ret
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    134e:	90 e3       	ldi	r25, 0x30	; 48
    1350:	9e cf       	rjmp	.-196    	; 0x128e <ht_scroll_limit+0x3e>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    1352:	90 e3       	ldi	r25, 0x30	; 48
    1354:	b1 cf       	rjmp	.-158    	; 0x12b8 <ht_scroll_limit+0x68>
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    1356:	90 e3       	ldi	r25, 0x30	; 48
    1358:	d1 cf       	rjmp	.-94     	; 0x12fc <ht_scroll_limit+0xac>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    135a:	90 e3       	ldi	r25, 0x30	; 48
    135c:	e3 cf       	rjmp	.-58     	; 0x1324 <ht_scroll_limit+0xd4>

0000135e <cursor_goto>:
	usart_transmit_dec(distance);
	usart_transmit(direction);
}

void cursor_goto(int x, int y)
{
    135e:	48 2f       	mov	r20, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1360:	80 91 c0 00 	lds	r24, 0x00C0
    1364:	85 ff       	sbrs	r24, 5
    1366:	fc cf       	rjmp	.-8      	; 0x1360 <cursor_goto+0x2>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1368:	8b e1       	ldi	r24, 0x1B	; 27
    136a:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    136e:	80 91 c0 00 	lds	r24, 0x00C0
    1372:	85 ff       	sbrs	r24, 5
    1374:	fc cf       	rjmp	.-8      	; 0x136e <cursor_goto+0x10>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1376:	8b e5       	ldi	r24, 0x5B	; 91
    1378:	80 93 c6 00 	sts	0x00C6, r24
void cursor_goto(int x, int y)
{
	usart_transmit('\x1b');
	usart_transmit('[');

	usart_transmit_dec(y);
    137c:	36 2f       	mov	r19, r22
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    137e:	64 36       	cpi	r22, 0x64	; 100
    1380:	08 f4       	brcc	.+2      	; 0x1384 <cursor_goto+0x26>
    1382:	6f c0       	rjmp	.+222    	; 0x1462 <cursor_goto+0x104>
	usart_transmit_dec(distance);
	usart_transmit(direction);
}

void cursor_goto(int x, int y)
{
    1384:	26 2f       	mov	r18, r22
    1386:	24 56       	subi	r18, 0x64	; 100
    1388:	82 2f       	mov	r24, r18
    138a:	64 e6       	ldi	r22, 0x64	; 100
    138c:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    1390:	9c e9       	ldi	r25, 0x9C	; 156
    1392:	89 9f       	mul	r24, r25
    1394:	30 2d       	mov	r19, r0
    1396:	11 24       	eor	r1, r1
    1398:	32 0f       	add	r19, r18
    139a:	98 2f       	mov	r25, r24
    139c:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    139e:	80 91 c0 00 	lds	r24, 0x00C0
    13a2:	85 ff       	sbrs	r24, 5
    13a4:	fc cf       	rjmp	.-8      	; 0x139e <cursor_goto+0x40>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    13a6:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    13aa:	3a 30       	cpi	r19, 0x0A	; 10
    13ac:	08 f4       	brcc	.+2      	; 0x13b0 <cursor_goto+0x52>
    13ae:	5b c0       	rjmp	.+182    	; 0x1466 <cursor_goto+0x108>
	usart_transmit_dec(distance);
	usart_transmit(direction);
}

void cursor_goto(int x, int y)
{
    13b0:	23 2f       	mov	r18, r19
    13b2:	2a 50       	subi	r18, 0x0A	; 10
    13b4:	82 2f       	mov	r24, r18
    13b6:	6a e0       	ldi	r22, 0x0A	; 10
    13b8:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    13bc:	39 2f       	mov	r19, r25
    13be:	82 2f       	mov	r24, r18
    13c0:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    13c4:	98 2f       	mov	r25, r24
    13c6:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    13c8:	80 91 c0 00 	lds	r24, 0x00C0
    13cc:	85 ff       	sbrs	r24, 5
    13ce:	fc cf       	rjmp	.-8      	; 0x13c8 <cursor_goto+0x6a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    13d0:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    13d4:	80 91 c0 00 	lds	r24, 0x00C0
    13d8:	85 ff       	sbrs	r24, 5
    13da:	fc cf       	rjmp	.-8      	; 0x13d4 <cursor_goto+0x76>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    13dc:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    13de:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    13e2:	80 91 c0 00 	lds	r24, 0x00C0
    13e6:	85 ff       	sbrs	r24, 5
    13e8:	fc cf       	rjmp	.-8      	; 0x13e2 <cursor_goto+0x84>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    13ea:	8b e3       	ldi	r24, 0x3B	; 59
    13ec:	80 93 c6 00 	sts	0x00C6, r24
	usart_transmit('\x1b');
	usart_transmit('[');

	usart_transmit_dec(y);
	usart_transmit(';');
	usart_transmit_dec(x);
    13f0:	34 2f       	mov	r19, r20
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    13f2:	44 36       	cpi	r20, 0x64	; 100
    13f4:	d0 f1       	brcs	.+116    	; 0x146a <cursor_goto+0x10c>
	usart_transmit_dec(distance);
	usart_transmit(direction);
}

void cursor_goto(int x, int y)
{
    13f6:	24 2f       	mov	r18, r20
    13f8:	24 56       	subi	r18, 0x64	; 100
    13fa:	82 2f       	mov	r24, r18
    13fc:	64 e6       	ldi	r22, 0x64	; 100
    13fe:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    1402:	9c e9       	ldi	r25, 0x9C	; 156
    1404:	89 9f       	mul	r24, r25
    1406:	30 2d       	mov	r19, r0
    1408:	11 24       	eor	r1, r1
    140a:	32 0f       	add	r19, r18
    140c:	98 2f       	mov	r25, r24
    140e:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1410:	80 91 c0 00 	lds	r24, 0x00C0
    1414:	85 ff       	sbrs	r24, 5
    1416:	fc cf       	rjmp	.-8      	; 0x1410 <cursor_goto+0xb2>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1418:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    141c:	3a 30       	cpi	r19, 0x0A	; 10
    141e:	38 f1       	brcs	.+78     	; 0x146e <cursor_goto+0x110>
	usart_transmit_dec(distance);
	usart_transmit(direction);
}

void cursor_goto(int x, int y)
{
    1420:	23 2f       	mov	r18, r19
    1422:	2a 50       	subi	r18, 0x0A	; 10
    1424:	82 2f       	mov	r24, r18
    1426:	6a e0       	ldi	r22, 0x0A	; 10
    1428:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    142c:	39 2f       	mov	r19, r25
    142e:	82 2f       	mov	r24, r18
    1430:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    1434:	98 2f       	mov	r25, r24
    1436:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1438:	80 91 c0 00 	lds	r24, 0x00C0
    143c:	85 ff       	sbrs	r24, 5
    143e:	fc cf       	rjmp	.-8      	; 0x1438 <cursor_goto+0xda>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1440:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1444:	80 91 c0 00 	lds	r24, 0x00C0
    1448:	85 ff       	sbrs	r24, 5
    144a:	fc cf       	rjmp	.-8      	; 0x1444 <cursor_goto+0xe6>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    144c:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    144e:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1452:	80 91 c0 00 	lds	r24, 0x00C0
    1456:	85 ff       	sbrs	r24, 5
    1458:	fc cf       	rjmp	.-8      	; 0x1452 <cursor_goto+0xf4>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    145a:	88 e4       	ldi	r24, 0x48	; 72
    145c:	80 93 c6 00 	sts	0x00C6, r24

	usart_transmit_dec(y);
	usart_transmit(';');
	usart_transmit_dec(x);
	usart_transmit('H');
}
    1460:	08 95       	ret
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    1462:	90 e3       	ldi	r25, 0x30	; 48
    1464:	9c cf       	rjmp	.-200    	; 0x139e <cursor_goto+0x40>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    1466:	90 e3       	ldi	r25, 0x30	; 48
    1468:	af cf       	rjmp	.-162    	; 0x13c8 <cursor_goto+0x6a>
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    146a:	90 e3       	ldi	r25, 0x30	; 48
    146c:	d1 cf       	rjmp	.-94     	; 0x1410 <cursor_goto+0xb2>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    146e:	90 e3       	ldi	r25, 0x30	; 48
    1470:	e3 cf       	rjmp	.-58     	; 0x1438 <cursor_goto+0xda>

00001472 <draw_horizontal_line>:
   
    usart_transmit( 'i' );
}

void draw_horizontal_line(int y, int startx, int endx) 
{
    1472:	98 2f       	mov	r25, r24
    1474:	fb 01       	movw	r30, r22
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1476:	80 91 c0 00 	lds	r24, 0x00C0
    147a:	85 ff       	sbrs	r24, 5
    147c:	fc cf       	rjmp	.-8      	; 0x1476 <draw_horizontal_line+0x4>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    147e:	8b e1       	ldi	r24, 0x1B	; 27
    1480:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1484:	80 91 c0 00 	lds	r24, 0x00C0
    1488:	85 ff       	sbrs	r24, 5
    148a:	fc cf       	rjmp	.-8      	; 0x1484 <draw_horizontal_line+0x12>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    148c:	8b e5       	ldi	r24, 0x5B	; 91
    148e:	80 93 c6 00 	sts	0x00C6, r24
void cursor_goto(int x, int y)
{
	usart_transmit('\x1b');
	usart_transmit('[');

	usart_transmit_dec(y);
    1492:	39 2f       	mov	r19, r25
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    1494:	94 36       	cpi	r25, 0x64	; 100
    1496:	08 f4       	brcc	.+2      	; 0x149a <draw_horizontal_line+0x28>
    1498:	b9 c0       	rjmp	.+370    	; 0x160c <draw_horizontal_line+0x19a>
   
    usart_transmit( 'i' );
}

void draw_horizontal_line(int y, int startx, int endx) 
{
    149a:	29 2f       	mov	r18, r25
    149c:	24 56       	subi	r18, 0x64	; 100
    149e:	82 2f       	mov	r24, r18
    14a0:	64 e6       	ldi	r22, 0x64	; 100
    14a2:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    14a6:	9c e9       	ldi	r25, 0x9C	; 156
    14a8:	89 9f       	mul	r24, r25
    14aa:	30 2d       	mov	r19, r0
    14ac:	11 24       	eor	r1, r1
    14ae:	32 0f       	add	r19, r18
    14b0:	98 2f       	mov	r25, r24
    14b2:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    14b4:	80 91 c0 00 	lds	r24, 0x00C0
    14b8:	85 ff       	sbrs	r24, 5
    14ba:	fc cf       	rjmp	.-8      	; 0x14b4 <draw_horizontal_line+0x42>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    14bc:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    14c0:	3a 30       	cpi	r19, 0x0A	; 10
    14c2:	08 f4       	brcc	.+2      	; 0x14c6 <draw_horizontal_line+0x54>
    14c4:	a5 c0       	rjmp	.+330    	; 0x1610 <draw_horizontal_line+0x19e>
   
    usart_transmit( 'i' );
}

void draw_horizontal_line(int y, int startx, int endx) 
{
    14c6:	23 2f       	mov	r18, r19
    14c8:	2a 50       	subi	r18, 0x0A	; 10
    14ca:	82 2f       	mov	r24, r18
    14cc:	6a e0       	ldi	r22, 0x0A	; 10
    14ce:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    14d2:	39 2f       	mov	r19, r25
    14d4:	82 2f       	mov	r24, r18
    14d6:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    14da:	98 2f       	mov	r25, r24
    14dc:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    14de:	80 91 c0 00 	lds	r24, 0x00C0
    14e2:	85 ff       	sbrs	r24, 5
    14e4:	fc cf       	rjmp	.-8      	; 0x14de <draw_horizontal_line+0x6c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    14e6:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    14ea:	80 91 c0 00 	lds	r24, 0x00C0
    14ee:	85 ff       	sbrs	r24, 5
    14f0:	fc cf       	rjmp	.-8      	; 0x14ea <draw_horizontal_line+0x78>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    14f2:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    14f4:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    14f8:	80 91 c0 00 	lds	r24, 0x00C0
    14fc:	85 ff       	sbrs	r24, 5
    14fe:	fc cf       	rjmp	.-8      	; 0x14f8 <draw_horizontal_line+0x86>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1500:	8b e3       	ldi	r24, 0x3B	; 59
    1502:	80 93 c6 00 	sts	0x00C6, r24
	usart_transmit('\x1b');
	usart_transmit('[');

	usart_transmit_dec(y);
	usart_transmit(';');
	usart_transmit_dec(x);
    1506:	3e 2f       	mov	r19, r30
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    1508:	e4 36       	cpi	r30, 0x64	; 100
    150a:	08 f4       	brcc	.+2      	; 0x150e <draw_horizontal_line+0x9c>
    150c:	83 c0       	rjmp	.+262    	; 0x1614 <draw_horizontal_line+0x1a2>
   
    usart_transmit( 'i' );
}

void draw_horizontal_line(int y, int startx, int endx) 
{
    150e:	2e 2f       	mov	r18, r30
    1510:	24 56       	subi	r18, 0x64	; 100
    1512:	82 2f       	mov	r24, r18
    1514:	64 e6       	ldi	r22, 0x64	; 100
    1516:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    151a:	9c e9       	ldi	r25, 0x9C	; 156
    151c:	89 9f       	mul	r24, r25
    151e:	30 2d       	mov	r19, r0
    1520:	11 24       	eor	r1, r1
    1522:	32 0f       	add	r19, r18
    1524:	98 2f       	mov	r25, r24
    1526:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1528:	80 91 c0 00 	lds	r24, 0x00C0
    152c:	85 ff       	sbrs	r24, 5
    152e:	fc cf       	rjmp	.-8      	; 0x1528 <draw_horizontal_line+0xb6>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1530:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    1534:	3a 30       	cpi	r19, 0x0A	; 10
    1536:	08 f4       	brcc	.+2      	; 0x153a <draw_horizontal_line+0xc8>
    1538:	6f c0       	rjmp	.+222    	; 0x1618 <draw_horizontal_line+0x1a6>
   
    usart_transmit( 'i' );
}

void draw_horizontal_line(int y, int startx, int endx) 
{
    153a:	23 2f       	mov	r18, r19
    153c:	2a 50       	subi	r18, 0x0A	; 10
    153e:	82 2f       	mov	r24, r18
    1540:	6a e0       	ldi	r22, 0x0A	; 10
    1542:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    1546:	39 2f       	mov	r19, r25
    1548:	82 2f       	mov	r24, r18
    154a:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    154e:	98 2f       	mov	r25, r24
    1550:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1552:	80 91 c0 00 	lds	r24, 0x00C0
    1556:	85 ff       	sbrs	r24, 5
    1558:	fc cf       	rjmp	.-8      	; 0x1552 <draw_horizontal_line+0xe0>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    155a:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    155e:	80 91 c0 00 	lds	r24, 0x00C0
    1562:	85 ff       	sbrs	r24, 5
    1564:	fc cf       	rjmp	.-8      	; 0x155e <draw_horizontal_line+0xec>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    1566:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1568:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    156c:	80 91 c0 00 	lds	r24, 0x00C0
    1570:	85 ff       	sbrs	r24, 5
    1572:	fc cf       	rjmp	.-8      	; 0x156c <draw_horizontal_line+0xfa>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1574:	88 e4       	ldi	r24, 0x48	; 72
    1576:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    157a:	80 91 c0 00 	lds	r24, 0x00C0
    157e:	85 ff       	sbrs	r24, 5
    1580:	fc cf       	rjmp	.-8      	; 0x157a <draw_horizontal_line+0x108>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1582:	8b e1       	ldi	r24, 0x1B	; 27
    1584:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1588:	80 91 c0 00 	lds	r24, 0x00C0
    158c:	85 ff       	sbrs	r24, 5
    158e:	fc cf       	rjmp	.-8      	; 0x1588 <draw_horizontal_line+0x116>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1590:	8b e5       	ldi	r24, 0x5B	; 91
    1592:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1596:	80 91 c0 00 	lds	r24, 0x00C0
    159a:	85 ff       	sbrs	r24, 5
    159c:	fc cf       	rjmp	.-8      	; 0x1596 <draw_horizontal_line+0x124>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    159e:	87 e3       	ldi	r24, 0x37	; 55
    15a0:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    15a4:	80 91 c0 00 	lds	r24, 0x00C0
    15a8:	85 ff       	sbrs	r24, 5
    15aa:	fc cf       	rjmp	.-8      	; 0x15a4 <draw_horizontal_line+0x132>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    15ac:	8d e6       	ldi	r24, 0x6D	; 109
    15ae:	80 93 c6 00 	sts	0x00C6, r24
void draw_horizontal_line(int y, int startx, int endx) 
{
	int i;
	cursor_goto(startx, y);
	ht_set_display_attribute_mode(MODE_REVERSED);
	for(i=startx; i <= endx; i++) 
    15b2:	4e 17       	cp	r20, r30
    15b4:	5f 07       	cpc	r21, r31
    15b6:	6c f0       	brlt	.+26     	; 0x15d2 <draw_horizontal_line+0x160>
    15b8:	bf 01       	movw	r22, r30
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    15ba:	90 e2       	ldi	r25, 0x20	; 32
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    15bc:	80 91 c0 00 	lds	r24, 0x00C0
    15c0:	85 ff       	sbrs	r24, 5
    15c2:	fc cf       	rjmp	.-8      	; 0x15bc <draw_horizontal_line+0x14a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    15c4:	90 93 c6 00 	sts	0x00C6, r25
void draw_horizontal_line(int y, int startx, int endx) 
{
	int i;
	cursor_goto(startx, y);
	ht_set_display_attribute_mode(MODE_REVERSED);
	for(i=startx; i <= endx; i++) 
    15c8:	6f 5f       	subi	r22, 0xFF	; 255
    15ca:	7f 4f       	sbci	r23, 0xFF	; 255
    15cc:	46 17       	cp	r20, r22
    15ce:	57 07       	cpc	r21, r23
    15d0:	ac f7       	brge	.-22     	; 0x15bc <draw_horizontal_line+0x14a>
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    15d2:	80 91 c0 00 	lds	r24, 0x00C0
    15d6:	85 ff       	sbrs	r24, 5
    15d8:	fc cf       	rjmp	.-8      	; 0x15d2 <draw_horizontal_line+0x160>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    15da:	8b e1       	ldi	r24, 0x1B	; 27
    15dc:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    15e0:	80 91 c0 00 	lds	r24, 0x00C0
    15e4:	85 ff       	sbrs	r24, 5
    15e6:	fc cf       	rjmp	.-8      	; 0x15e0 <draw_horizontal_line+0x16e>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    15e8:	8b e5       	ldi	r24, 0x5B	; 91
    15ea:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    15ee:	80 91 c0 00 	lds	r24, 0x00C0
    15f2:	85 ff       	sbrs	r24, 5
    15f4:	fc cf       	rjmp	.-8      	; 0x15ee <draw_horizontal_line+0x17c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    15f6:	80 e3       	ldi	r24, 0x30	; 48
    15f8:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    15fc:	80 91 c0 00 	lds	r24, 0x00C0
    1600:	85 ff       	sbrs	r24, 5
    1602:	fc cf       	rjmp	.-8      	; 0x15fc <draw_horizontal_line+0x18a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1604:	8d e6       	ldi	r24, 0x6D	; 109
    1606:	80 93 c6 00 	sts	0x00C6, r24
	for(i=startx; i <= endx; i++) 
	{
		usart_transmit(' ');
	}
	ht_set_display_attribute_mode(MODE_NONE);
}
    160a:	08 95       	ret
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    160c:	90 e3       	ldi	r25, 0x30	; 48
    160e:	52 cf       	rjmp	.-348    	; 0x14b4 <draw_horizontal_line+0x42>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    1610:	90 e3       	ldi	r25, 0x30	; 48
    1612:	65 cf       	rjmp	.-310    	; 0x14de <draw_horizontal_line+0x6c>
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    1614:	90 e3       	ldi	r25, 0x30	; 48
    1616:	88 cf       	rjmp	.-240    	; 0x1528 <draw_horizontal_line+0xb6>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    1618:	90 e3       	ldi	r25, 0x30	; 48
    161a:	9b cf       	rjmp	.-202    	; 0x1552 <draw_horizontal_line+0xe0>

0000161c <draw_vertical_line>:
	}
	ht_set_display_attribute_mode(MODE_NONE);
}

void draw_vertical_line(int x, int starty, int endy) 
{
    161c:	a8 2f       	mov	r26, r24
    161e:	fb 01       	movw	r30, r22
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1620:	80 91 c0 00 	lds	r24, 0x00C0
    1624:	85 ff       	sbrs	r24, 5
    1626:	fc cf       	rjmp	.-8      	; 0x1620 <draw_vertical_line+0x4>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1628:	8b e1       	ldi	r24, 0x1B	; 27
    162a:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    162e:	80 91 c0 00 	lds	r24, 0x00C0
    1632:	85 ff       	sbrs	r24, 5
    1634:	fc cf       	rjmp	.-8      	; 0x162e <draw_vertical_line+0x12>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1636:	8b e5       	ldi	r24, 0x5B	; 91
    1638:	80 93 c6 00 	sts	0x00C6, r24
void cursor_goto(int x, int y)
{
	usart_transmit('\x1b');
	usart_transmit('[');

	usart_transmit_dec(y);
    163c:	3e 2f       	mov	r19, r30
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    163e:	e4 36       	cpi	r30, 0x64	; 100
    1640:	08 f4       	brcc	.+2      	; 0x1644 <draw_vertical_line+0x28>
    1642:	10 c1       	rjmp	.+544    	; 0x1864 <draw_vertical_line+0x248>
	}
	ht_set_display_attribute_mode(MODE_NONE);
}

void draw_vertical_line(int x, int starty, int endy) 
{
    1644:	2e 2f       	mov	r18, r30
    1646:	24 56       	subi	r18, 0x64	; 100
    1648:	82 2f       	mov	r24, r18
    164a:	64 e6       	ldi	r22, 0x64	; 100
    164c:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    1650:	9c e9       	ldi	r25, 0x9C	; 156
    1652:	89 9f       	mul	r24, r25
    1654:	30 2d       	mov	r19, r0
    1656:	11 24       	eor	r1, r1
    1658:	32 0f       	add	r19, r18
    165a:	98 2f       	mov	r25, r24
    165c:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    165e:	80 91 c0 00 	lds	r24, 0x00C0
    1662:	85 ff       	sbrs	r24, 5
    1664:	fc cf       	rjmp	.-8      	; 0x165e <draw_vertical_line+0x42>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1666:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    166a:	3a 30       	cpi	r19, 0x0A	; 10
    166c:	08 f4       	brcc	.+2      	; 0x1670 <draw_vertical_line+0x54>
    166e:	fc c0       	rjmp	.+504    	; 0x1868 <draw_vertical_line+0x24c>
	}
	ht_set_display_attribute_mode(MODE_NONE);
}

void draw_vertical_line(int x, int starty, int endy) 
{
    1670:	23 2f       	mov	r18, r19
    1672:	2a 50       	subi	r18, 0x0A	; 10
    1674:	82 2f       	mov	r24, r18
    1676:	6a e0       	ldi	r22, 0x0A	; 10
    1678:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    167c:	39 2f       	mov	r19, r25
    167e:	82 2f       	mov	r24, r18
    1680:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    1684:	98 2f       	mov	r25, r24
    1686:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1688:	80 91 c0 00 	lds	r24, 0x00C0
    168c:	85 ff       	sbrs	r24, 5
    168e:	fc cf       	rjmp	.-8      	; 0x1688 <draw_vertical_line+0x6c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1690:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1694:	80 91 c0 00 	lds	r24, 0x00C0
    1698:	85 ff       	sbrs	r24, 5
    169a:	fc cf       	rjmp	.-8      	; 0x1694 <draw_vertical_line+0x78>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    169c:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    169e:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    16a2:	80 91 c0 00 	lds	r24, 0x00C0
    16a6:	85 ff       	sbrs	r24, 5
    16a8:	fc cf       	rjmp	.-8      	; 0x16a2 <draw_vertical_line+0x86>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    16aa:	8b e3       	ldi	r24, 0x3B	; 59
    16ac:	80 93 c6 00 	sts	0x00C6, r24
	usart_transmit('\x1b');
	usart_transmit('[');

	usart_transmit_dec(y);
	usart_transmit(';');
	usart_transmit_dec(x);
    16b0:	3a 2f       	mov	r19, r26
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    16b2:	a4 36       	cpi	r26, 0x64	; 100
    16b4:	08 f4       	brcc	.+2      	; 0x16b8 <draw_vertical_line+0x9c>
    16b6:	da c0       	rjmp	.+436    	; 0x186c <draw_vertical_line+0x250>
	}
	ht_set_display_attribute_mode(MODE_NONE);
}

void draw_vertical_line(int x, int starty, int endy) 
{
    16b8:	2a 2f       	mov	r18, r26
    16ba:	24 56       	subi	r18, 0x64	; 100
    16bc:	82 2f       	mov	r24, r18
    16be:	64 e6       	ldi	r22, 0x64	; 100
    16c0:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    16c4:	9c e9       	ldi	r25, 0x9C	; 156
    16c6:	89 9f       	mul	r24, r25
    16c8:	30 2d       	mov	r19, r0
    16ca:	11 24       	eor	r1, r1
    16cc:	32 0f       	add	r19, r18
    16ce:	98 2f       	mov	r25, r24
    16d0:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    16d2:	80 91 c0 00 	lds	r24, 0x00C0
    16d6:	85 ff       	sbrs	r24, 5
    16d8:	fc cf       	rjmp	.-8      	; 0x16d2 <draw_vertical_line+0xb6>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    16da:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    16de:	3a 30       	cpi	r19, 0x0A	; 10
    16e0:	08 f4       	brcc	.+2      	; 0x16e4 <draw_vertical_line+0xc8>
    16e2:	c6 c0       	rjmp	.+396    	; 0x1870 <draw_vertical_line+0x254>
	}
	ht_set_display_attribute_mode(MODE_NONE);
}

void draw_vertical_line(int x, int starty, int endy) 
{
    16e4:	23 2f       	mov	r18, r19
    16e6:	2a 50       	subi	r18, 0x0A	; 10
    16e8:	82 2f       	mov	r24, r18
    16ea:	6a e0       	ldi	r22, 0x0A	; 10
    16ec:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    16f0:	39 2f       	mov	r19, r25
    16f2:	82 2f       	mov	r24, r18
    16f4:	0e 94 48 20 	call	0x4090	; 0x4090 <__udivmodqi4>
    16f8:	98 2f       	mov	r25, r24
    16fa:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    16fc:	80 91 c0 00 	lds	r24, 0x00C0
    1700:	85 ff       	sbrs	r24, 5
    1702:	fc cf       	rjmp	.-8      	; 0x16fc <draw_vertical_line+0xe0>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1704:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1708:	80 91 c0 00 	lds	r24, 0x00C0
    170c:	85 ff       	sbrs	r24, 5
    170e:	fc cf       	rjmp	.-8      	; 0x1708 <draw_vertical_line+0xec>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    1710:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1712:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1716:	80 91 c0 00 	lds	r24, 0x00C0
    171a:	85 ff       	sbrs	r24, 5
    171c:	fc cf       	rjmp	.-8      	; 0x1716 <draw_vertical_line+0xfa>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    171e:	88 e4       	ldi	r24, 0x48	; 72
    1720:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1724:	80 91 c0 00 	lds	r24, 0x00C0
    1728:	85 ff       	sbrs	r24, 5
    172a:	fc cf       	rjmp	.-8      	; 0x1724 <draw_vertical_line+0x108>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    172c:	8b e1       	ldi	r24, 0x1B	; 27
    172e:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1732:	80 91 c0 00 	lds	r24, 0x00C0
    1736:	85 ff       	sbrs	r24, 5
    1738:	fc cf       	rjmp	.-8      	; 0x1732 <draw_vertical_line+0x116>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    173a:	8b e5       	ldi	r24, 0x5B	; 91
    173c:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1740:	80 91 c0 00 	lds	r24, 0x00C0
    1744:	85 ff       	sbrs	r24, 5
    1746:	fc cf       	rjmp	.-8      	; 0x1740 <draw_vertical_line+0x124>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1748:	87 e3       	ldi	r24, 0x37	; 55
    174a:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    174e:	80 91 c0 00 	lds	r24, 0x00C0
    1752:	85 ff       	sbrs	r24, 5
    1754:	fc cf       	rjmp	.-8      	; 0x174e <draw_vertical_line+0x132>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1756:	8d e6       	ldi	r24, 0x6D	; 109
    1758:	80 93 c6 00 	sts	0x00C6, r24
void draw_vertical_line(int x, int starty, int endy) 
{
	int i;
	cursor_goto(x, starty);
	ht_set_display_attribute_mode(MODE_REVERSED);
	for(i=starty; i < endy; i++) 
    175c:	e4 17       	cp	r30, r20
    175e:	f5 07       	cpc	r31, r21
    1760:	0c f0       	brlt	.+2      	; 0x1764 <draw_vertical_line+0x148>
    1762:	5c c0       	rjmp	.+184    	; 0x181c <draw_vertical_line+0x200>
    1764:	bf 01       	movw	r22, r30
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1766:	b0 e2       	ldi	r27, 0x20	; 32
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1768:	eb e1       	ldi	r30, 0x1B	; 27
    176a:	2b e5       	ldi	r18, 0x5B	; 91
    176c:	90 e3       	ldi	r25, 0x30	; 48
    176e:	31 e3       	ldi	r19, 0x31	; 49
    1770:	f2 e4       	ldi	r31, 0x42	; 66
    1772:	a4 e4       	ldi	r26, 0x44	; 68
    1774:	80 91 c0 00 	lds	r24, 0x00C0
    1778:	85 ff       	sbrs	r24, 5
    177a:	fc cf       	rjmp	.-8      	; 0x1774 <draw_vertical_line+0x158>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    177c:	b0 93 c6 00 	sts	0x00C6, r27
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1780:	80 91 c0 00 	lds	r24, 0x00C0
    1784:	85 ff       	sbrs	r24, 5
    1786:	fc cf       	rjmp	.-8      	; 0x1780 <draw_vertical_line+0x164>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1788:	e0 93 c6 00 	sts	0x00C6, r30
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    178c:	80 91 c0 00 	lds	r24, 0x00C0
    1790:	85 ff       	sbrs	r24, 5
    1792:	fc cf       	rjmp	.-8      	; 0x178c <draw_vertical_line+0x170>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1794:	20 93 c6 00 	sts	0x00C6, r18
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1798:	80 91 c0 00 	lds	r24, 0x00C0
    179c:	85 ff       	sbrs	r24, 5
    179e:	fc cf       	rjmp	.-8      	; 0x1798 <draw_vertical_line+0x17c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    17a0:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    17a4:	80 91 c0 00 	lds	r24, 0x00C0
    17a8:	85 ff       	sbrs	r24, 5
    17aa:	fc cf       	rjmp	.-8      	; 0x17a4 <draw_vertical_line+0x188>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    17ac:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    17b0:	80 91 c0 00 	lds	r24, 0x00C0
    17b4:	85 ff       	sbrs	r24, 5
    17b6:	fc cf       	rjmp	.-8      	; 0x17b0 <draw_vertical_line+0x194>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    17b8:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    17bc:	80 91 c0 00 	lds	r24, 0x00C0
    17c0:	85 ff       	sbrs	r24, 5
    17c2:	fc cf       	rjmp	.-8      	; 0x17bc <draw_vertical_line+0x1a0>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    17c4:	f0 93 c6 00 	sts	0x00C6, r31
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    17c8:	80 91 c0 00 	lds	r24, 0x00C0
    17cc:	85 ff       	sbrs	r24, 5
    17ce:	fc cf       	rjmp	.-8      	; 0x17c8 <draw_vertical_line+0x1ac>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    17d0:	e0 93 c6 00 	sts	0x00C6, r30
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    17d4:	80 91 c0 00 	lds	r24, 0x00C0
    17d8:	85 ff       	sbrs	r24, 5
    17da:	fc cf       	rjmp	.-8      	; 0x17d4 <draw_vertical_line+0x1b8>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    17dc:	20 93 c6 00 	sts	0x00C6, r18
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    17e0:	80 91 c0 00 	lds	r24, 0x00C0
    17e4:	85 ff       	sbrs	r24, 5
    17e6:	fc cf       	rjmp	.-8      	; 0x17e0 <draw_vertical_line+0x1c4>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    17e8:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    17ec:	80 91 c0 00 	lds	r24, 0x00C0
    17f0:	85 ff       	sbrs	r24, 5
    17f2:	fc cf       	rjmp	.-8      	; 0x17ec <draw_vertical_line+0x1d0>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    17f4:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    17f8:	80 91 c0 00 	lds	r24, 0x00C0
    17fc:	85 ff       	sbrs	r24, 5
    17fe:	fc cf       	rjmp	.-8      	; 0x17f8 <draw_vertical_line+0x1dc>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1800:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1804:	80 91 c0 00 	lds	r24, 0x00C0
    1808:	85 ff       	sbrs	r24, 5
    180a:	fc cf       	rjmp	.-8      	; 0x1804 <draw_vertical_line+0x1e8>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    180c:	a0 93 c6 00 	sts	0x00C6, r26
void draw_vertical_line(int x, int starty, int endy) 
{
	int i;
	cursor_goto(x, starty);
	ht_set_display_attribute_mode(MODE_REVERSED);
	for(i=starty; i < endy; i++) 
    1810:	6f 5f       	subi	r22, 0xFF	; 255
    1812:	7f 4f       	sbci	r23, 0xFF	; 255
    1814:	64 17       	cp	r22, r20
    1816:	75 07       	cpc	r23, r21
    1818:	0c f4       	brge	.+2      	; 0x181c <draw_vertical_line+0x200>
    181a:	ac cf       	rjmp	.-168    	; 0x1774 <draw_vertical_line+0x158>
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    181c:	80 91 c0 00 	lds	r24, 0x00C0
    1820:	85 ff       	sbrs	r24, 5
    1822:	fc cf       	rjmp	.-8      	; 0x181c <draw_vertical_line+0x200>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1824:	80 e2       	ldi	r24, 0x20	; 32
    1826:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    182a:	80 91 c0 00 	lds	r24, 0x00C0
    182e:	85 ff       	sbrs	r24, 5
    1830:	fc cf       	rjmp	.-8      	; 0x182a <draw_vertical_line+0x20e>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1832:	8b e1       	ldi	r24, 0x1B	; 27
    1834:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1838:	80 91 c0 00 	lds	r24, 0x00C0
    183c:	85 ff       	sbrs	r24, 5
    183e:	fc cf       	rjmp	.-8      	; 0x1838 <draw_vertical_line+0x21c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1840:	8b e5       	ldi	r24, 0x5B	; 91
    1842:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1846:	80 91 c0 00 	lds	r24, 0x00C0
    184a:	85 ff       	sbrs	r24, 5
    184c:	fc cf       	rjmp	.-8      	; 0x1846 <draw_vertical_line+0x22a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    184e:	80 e3       	ldi	r24, 0x30	; 48
    1850:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1854:	80 91 c0 00 	lds	r24, 0x00C0
    1858:	85 ff       	sbrs	r24, 5
    185a:	fc cf       	rjmp	.-8      	; 0x1854 <draw_vertical_line+0x238>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    185c:	8d e6       	ldi	r24, 0x6D	; 109
    185e:	80 93 c6 00 	sts	0x00C6, r24
		move_cursor(1,MOVE_DOWN);
		move_cursor(1,MOVE_LEFT);
	}
	usart_transmit(' ');
	ht_set_display_attribute_mode(MODE_NONE);
}
    1862:	08 95       	ret
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    1864:	90 e3       	ldi	r25, 0x30	; 48
    1866:	fb ce       	rjmp	.-522    	; 0x165e <draw_vertical_line+0x42>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    1868:	90 e3       	ldi	r25, 0x30	; 48
    186a:	0e cf       	rjmp	.-484    	; 0x1688 <draw_vertical_line+0x6c>
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    186c:	90 e3       	ldi	r25, 0x30	; 48
    186e:	31 cf       	rjmp	.-414    	; 0x16d2 <draw_vertical_line+0xb6>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    1870:	90 e3       	ldi	r25, 0x30	; 48
    1872:	44 cf       	rjmp	.-376    	; 0x16fc <draw_vertical_line+0xe0>

00001874 <ymodem_send>:

   return (crc);
}
// ******************************************************************************************************
uint8_t ymodem_send(uint8_t(*buffer_func)(unsigned char*, uint16_t), char * filename, uint32_t fileSize) 
{
    1874:	2f 92       	push	r2
    1876:	3f 92       	push	r3
    1878:	4f 92       	push	r4
    187a:	5f 92       	push	r5
    187c:	6f 92       	push	r6
    187e:	7f 92       	push	r7
    1880:	8f 92       	push	r8
    1882:	9f 92       	push	r9
    1884:	af 92       	push	r10
    1886:	bf 92       	push	r11
    1888:	cf 92       	push	r12
    188a:	df 92       	push	r13
    188c:	ef 92       	push	r14
    188e:	ff 92       	push	r15
    1890:	0f 93       	push	r16
    1892:	1f 93       	push	r17
    1894:	df 93       	push	r29
    1896:	cf 93       	push	r28
    1898:	cd b7       	in	r28, 0x3d	; 61
    189a:	de b7       	in	r29, 0x3e	; 62
    189c:	2b 97       	sbiw	r28, 0x0b	; 11
    189e:	0f b6       	in	r0, 0x3f	; 63
    18a0:	f8 94       	cli
    18a2:	de bf       	out	0x3e, r29	; 62
    18a4:	0f be       	out	0x3f, r0	; 63
    18a6:	cd bf       	out	0x3d, r28	; 61
    18a8:	3c 01       	movw	r6, r24
    18aa:	8b 01       	movw	r16, r22
    18ac:	19 01       	movw	r2, r18
    18ae:	2a 01       	movw	r4, r20
  uint8_t packetNum = 1;
  ymodemSentPackets = 0;
    18b0:	10 92 55 01 	sts	0x0155, r1
    18b4:	10 92 54 01 	sts	0x0154, r1
  uint16_t bufferPos = 3;
  uint32_t bytesToSend = fileSize;

  // Wait for the starting 'C' character
  while(c != 'C') {
    c = usart_receive();
    18b8:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  uint8_t c = 0;
  uint16_t bufferPos = 3;
  uint32_t bytesToSend = fileSize;

  // Wait for the starting 'C' character
  while(c != 'C') {
    18bc:	83 34       	cpi	r24, 0x43	; 67
    18be:	e1 f7       	brne	.-8      	; 0x18b8 <ymodem_send+0x44>
    c = usart_receive();
  }

  // First packet is all about filename and filesize
  for(uint8_t i = 0; filename[i] != '\0'; i++, bufferPos++) {
    18c0:	d8 01       	movw	r26, r16
    18c2:	8c 91       	ld	r24, X
    18c4:	88 23       	and	r24, r24
    18c6:	09 f4       	brne	.+2      	; 0x18ca <ymodem_send+0x56>
    18c8:	18 c2       	rjmp	.+1072   	; 0x1cfa <ymodem_send+0x486>
    18ca:	a3 e0       	ldi	r26, 0x03	; 3
    18cc:	b0 e0       	ldi	r27, 0x00	; 0
    ymodemBuffer[bufferPos] = filename[i];
    18ce:	fd 01       	movw	r30, r26
    18d0:	ea 5a       	subi	r30, 0xAA	; 170
    18d2:	fe 4f       	sbci	r31, 0xFE	; 254
    18d4:	80 83       	st	Z, r24
    18d6:	8a 2f       	mov	r24, r26
    18d8:	82 50       	subi	r24, 0x02	; 2
  while(c != 'C') {
    c = usart_receive();
  }

  // First packet is all about filename and filesize
  for(uint8_t i = 0; filename[i] != '\0'; i++, bufferPos++) {
    18da:	11 96       	adiw	r26, 0x01	; 1
    18dc:	f8 01       	movw	r30, r16
    18de:	e8 0f       	add	r30, r24
    18e0:	f1 1d       	adc	r31, r1
    18e2:	80 81       	ld	r24, Z
    18e4:	88 23       	and	r24, r24
    18e6:	99 f7       	brne	.-26     	; 0x18ce <ymodem_send+0x5a>
    18e8:	4d 01       	movw	r8, r26
    18ea:	08 94       	sec
    18ec:	81 1c       	adc	r8, r1
    18ee:	91 1c       	adc	r9, r1
    ymodemBuffer[bufferPos] = filename[i];
  }
  ymodemBuffer[bufferPos++] = '\0';
    18f0:	aa 5a       	subi	r26, 0xAA	; 170
    18f2:	be 4f       	sbci	r27, 0xFE	; 254
    18f4:	1c 92       	st	X, r1
  
  // Need to add the file size in decimal format
  char fileSizeStr[11];
  uint16_t i = 0;
  fileSizeStr[0] = '0';
    18f6:	80 e3       	ldi	r24, 0x30	; 48
    18f8:	89 83       	std	Y+1, r24	; 0x01
    18fa:	cc 24       	eor	r12, r12
    18fc:	dd 24       	eor	r13, r13
    18fe:	21 14       	cp	r2, r1
    1900:	31 04       	cpc	r3, r1
    1902:	41 04       	cpc	r4, r1
    1904:	51 04       	cpc	r5, r1
    1906:	09 f0       	breq	.+2      	; 0x190a <ymodem_send+0x96>
    1908:	cd c1       	rjmp	.+922    	; 0x1ca4 <ymodem_send+0x430>
    190a:	31 e0       	ldi	r19, 0x01	; 1
    190c:	c3 2e       	mov	r12, r19
    190e:	d1 2c       	mov	r13, r1
    bytesToSend /= 10;
    i++;
  }
  bytesToSend = fileSize;
  // Now we've converted it in reverse, pump it back out correctly
  for(; i > 0; i--, bufferPos++) {
    1910:	fe 01       	movw	r30, r28
    1912:	ec 0d       	add	r30, r12
    1914:	fd 1d       	adc	r31, r13
    1916:	d4 01       	movw	r26, r8
    1918:	aa 5a       	subi	r26, 0xAA	; 170
    191a:	be 4f       	sbci	r27, 0xFE	; 254
    ymodemBuffer[bufferPos] = fileSizeStr[i - 1];
    191c:	80 81       	ld	r24, Z
    191e:	8d 93       	st	X+, r24
    1920:	31 97       	sbiw	r30, 0x01	; 1
    bytesToSend /= 10;
    i++;
  }
  bytesToSend = fileSize;
  // Now we've converted it in reverse, pump it back out correctly
  for(; i > 0; i--, bufferPos++) {
    1922:	ec 17       	cp	r30, r28
    1924:	fd 07       	cpc	r31, r29
    1926:	d1 f7       	brne	.-12     	; 0x191c <ymodem_send+0xa8>
    1928:	8c 0c       	add	r8, r12
    192a:	9d 1c       	adc	r9, r13
    ymodemBuffer[bufferPos] = fileSizeStr[i - 1];
  }
  ymodemBuffer[bufferPos++] = '\0';
    192c:	f4 01       	movw	r30, r8
    192e:	ea 5a       	subi	r30, 0xAA	; 170
    1930:	fe 4f       	sbci	r31, 0xFE	; 254
    1932:	10 82       	st	Z, r1
    1934:	f4 01       	movw	r30, r8
    1936:	31 96       	adiw	r30, 0x01	; 1

  for(; bufferPos < BYTES_PER_PACKET; bufferPos++) {
    1938:	e5 38       	cpi	r30, 0x85	; 133
    193a:	f1 05       	cpc	r31, r1
    193c:	38 f4       	brcc	.+14     	; 0x194c <ymodem_send+0xd8>
    193e:	ea 5a       	subi	r30, 0xAA	; 170
    1940:	fe 4f       	sbci	r31, 0xFE	; 254
    // Make the remaining characters nulls
    ymodemBuffer[bufferPos] = 0;
    1942:	11 92       	st	Z+, r1
  for(; i > 0; i--, bufferPos++) {
    ymodemBuffer[bufferPos] = fileSizeStr[i - 1];
  }
  ymodemBuffer[bufferPos++] = '\0';

  for(; bufferPos < BYTES_PER_PACKET; bufferPos++) {
    1944:	81 e0       	ldi	r24, 0x01	; 1
    1946:	eb 3d       	cpi	r30, 0xDB	; 219
    1948:	f8 07       	cpc	r31, r24
    194a:	d9 f7       	brne	.-10     	; 0x1942 <ymodem_send+0xce>
    194c:	29 e5       	ldi	r18, 0x59	; 89
    194e:	e2 2e       	mov	r14, r18
    1950:	21 e0       	ldi	r18, 0x01	; 1
    1952:	f2 2e       	mov	r15, r18
    1954:	20 e0       	ldi	r18, 0x00	; 0
    1956:	30 e0       	ldi	r19, 0x00	; 0
static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    crc = _crc_xmodem_update(crc, *ptr++);
    1958:	d7 01       	movw	r26, r14
    195a:	8d 91       	ld	r24, X+
    195c:	7d 01       	movw	r14, r26
    uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
    uint8_t __tmp1;             /* %1 */
    uint8_t __tmp2;             /* %2 */
                                /* %3  __data */

    __asm__ __volatile__ (
    195e:	38 27       	eor	r19, r24
    1960:	03 2e       	mov	r0, r19
    1962:	02 94       	swap	r0
    1964:	90 2d       	mov	r25, r0
    1966:	9f 70       	andi	r25, 0x0F	; 15
    1968:	93 27       	eor	r25, r19
    196a:	83 2f       	mov	r24, r19
    196c:	80 25       	eor	r24, r0
    196e:	88 0f       	add	r24, r24
    1970:	80 7e       	andi	r24, 0xE0	; 224
    1972:	98 27       	eor	r25, r24
    1974:	80 2d       	mov	r24, r0
    1976:	83 27       	eor	r24, r19
    1978:	80 7f       	andi	r24, 0xF0	; 240
    197a:	86 95       	lsr	r24
    197c:	03 2e       	mov	r0, r19
    197e:	00 0c       	add	r0, r0
    1980:	88 1f       	adc	r24, r24
    1982:	36 95       	lsr	r19
    1984:	36 95       	lsr	r19
    1986:	36 95       	lsr	r19
    1988:	3f 71       	andi	r19, 0x1F	; 31
    198a:	38 27       	eor	r19, r24
    198c:	32 27       	eor	r19, r18
    198e:	29 2f       	mov	r18, r25

static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    1990:	b9 ed       	ldi	r27, 0xD9	; 217
    1992:	eb 16       	cp	r14, r27
    1994:	b1 e0       	ldi	r27, 0x01	; 1
    1996:	fb 06       	cpc	r15, r27
    1998:	f9 f6       	brne	.-66     	; 0x1958 <ymodem_send+0xe4>
    // Make the remaining characters nulls
    ymodemBuffer[bufferPos] = 0;
  }

  crc = ymodem_calcrc((&ymodemBuffer[3]), 128);
  ymodemBuffer[0] = YMODEM_SOH_128;
    199a:	81 e0       	ldi	r24, 0x01	; 1
    199c:	80 93 56 01 	sts	0x0156, r24
  ymodemBuffer[1] = 0;
    19a0:	10 92 57 01 	sts	0x0157, r1
  ymodemBuffer[2] = 0xFF;
    19a4:	8f ef       	ldi	r24, 0xFF	; 255
    19a6:	80 93 58 01 	sts	0x0158, r24
  ymodemBuffer[131] = (uint8_t)(crc >> 8);
    19aa:	f7 01       	movw	r30, r14
    19ac:	30 83       	st	Z, r19
  ymodemBuffer[132] = (uint8_t) crc;
    19ae:	20 93 da 01 	sts	0x01DA, r18
    19b2:	00 e0       	ldi	r16, 0x00	; 0
    19b4:	10 e0       	ldi	r17, 0x00	; 0
  
  // Send the header packet out until we get an ACK
  do {
    for(i = 0; i<BYTES_PER_PACKET; i++) {
    19b6:	05 38       	cpi	r16, 0x85	; 133
    19b8:	11 05       	cpc	r17, r1
    19ba:	48 f0       	brcs	.+18     	; 0x19ce <ymodem_send+0x15a>
      usart_transmit(ymodemBuffer[i]);
    }

    c = usart_receive();
    19bc:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>

  } while(c != ACK);
    19c0:	86 30       	cpi	r24, 0x06	; 6
    19c2:	71 f0       	breq	.+28     	; 0x19e0 <ymodem_send+0x16c>
    19c4:	00 e0       	ldi	r16, 0x00	; 0
    19c6:	10 e0       	ldi	r17, 0x00	; 0
  ymodemBuffer[131] = (uint8_t)(crc >> 8);
  ymodemBuffer[132] = (uint8_t) crc;
  
  // Send the header packet out until we get an ACK
  do {
    for(i = 0; i<BYTES_PER_PACKET; i++) {
    19c8:	05 38       	cpi	r16, 0x85	; 133
    19ca:	11 05       	cpc	r17, r1
    19cc:	b8 f7       	brcc	.-18     	; 0x19bc <ymodem_send+0x148>
      usart_transmit(ymodemBuffer[i]);
    19ce:	f8 01       	movw	r30, r16
    19d0:	ea 5a       	subi	r30, 0xAA	; 170
    19d2:	fe 4f       	sbci	r31, 0xFE	; 254
    19d4:	80 81       	ld	r24, Z
    19d6:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  ymodemBuffer[131] = (uint8_t)(crc >> 8);
  ymodemBuffer[132] = (uint8_t) crc;
  
  // Send the header packet out until we get an ACK
  do {
    for(i = 0; i<BYTES_PER_PACKET; i++) {
    19da:	0f 5f       	subi	r16, 0xFF	; 255
    19dc:	1f 4f       	sbci	r17, 0xFF	; 255
    19de:	eb cf       	rjmp	.-42     	; 0x19b6 <ymodem_send+0x142>

  } while(c != ACK);

  // Wait for the starting 'C' character
  while(c != 'C') {
    c = usart_receive();
    19e0:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
    c = usart_receive();

  } while(c != ACK);

  // Wait for the starting 'C' character
  while(c != 'C') {
    19e4:	83 34       	cpi	r24, 0x43	; 67
    19e6:	e1 f7       	brne	.-8      	; 0x19e0 <ymodem_send+0x16c>
    c = usart_receive();
  }

  // Okay, now onto the data 
  while(bytesToSend > 0) {
    19e8:	21 14       	cp	r2, r1
    19ea:	31 04       	cpc	r3, r1
    19ec:	41 04       	cpc	r4, r1
    19ee:	51 04       	cpc	r5, r1
    19f0:	09 f4       	brne	.+2      	; 0x19f4 <ymodem_send+0x180>
    19f2:	6f c0       	rjmp	.+222    	; 0x1ad2 <ymodem_send+0x25e>
    19f4:	62 01       	movw	r12, r4
    19f6:	51 01       	movw	r10, r2
    19f8:	88 24       	eor	r8, r8
    19fa:	83 94       	inc	r8
        
        bytesToSend = 0;

      } 
      
      ymodemBuffer[0] = YMODEM_SOH_128;
    19fc:	55 24       	eor	r5, r5
    19fe:	53 94       	inc	r5
  
      } else {
        // Leftovers (<128)
        (buffer_func)(&ymodemBuffer[3], bytesToSend);
        for(i = bytesToSend; i < BYTES_PER_PACKET;i++) {
          ymodemBuffer[3+i] = CTRLZ;
    1a00:	9a e1       	ldi	r25, 0x1A	; 26
    1a02:	99 2e       	mov	r9, r25
      (buffer_func)(&ymodemBuffer[3], 1024);
      crc = ymodem_calcrc(&ymodemBuffer[3], 1024);
      ymodemBuffer[1027] = (uint8_t) (crc >> 8);
      ymodemBuffer[1028] = (uint8_t) crc;
      bytesToSend -= 1024;
      ymodemBuffer[0] = YMODEM_STX_1K;
    1a04:	82 e0       	ldi	r24, 0x02	; 2
    1a06:	48 2e       	mov	r4, r24
  }

  // Okay, now onto the data 
  while(bytesToSend > 0) {
    
    if(bytesToSend > 1024) {
    1a08:	f1 e0       	ldi	r31, 0x01	; 1
    1a0a:	af 16       	cp	r10, r31
    1a0c:	f4 e0       	ldi	r31, 0x04	; 4
    1a0e:	bf 06       	cpc	r11, r31
    1a10:	f0 e0       	ldi	r31, 0x00	; 0
    1a12:	cf 06       	cpc	r12, r31
    1a14:	f0 e0       	ldi	r31, 0x00	; 0
    1a16:	df 06       	cpc	r13, r31
    1a18:	08 f0       	brcs	.+2      	; 0x1a1c <ymodem_send+0x1a8>
    1a1a:	de c0       	rjmp	.+444    	; 0x1bd8 <ymodem_send+0x364>

      } while(c != ACK);

    } else {
    
      if (bytesToSend > 128) {
    1a1c:	91 e8       	ldi	r25, 0x81	; 129
    1a1e:	a9 16       	cp	r10, r25
    1a20:	b1 04       	cpc	r11, r1
    1a22:	c1 04       	cpc	r12, r1
    1a24:	d1 04       	cpc	r13, r1
    1a26:	08 f4       	brcc	.+2      	; 0x1a2a <ymodem_send+0x1b6>
    1a28:	c4 c0       	rjmp	.+392    	; 0x1bb2 <ymodem_send+0x33e>
        (buffer_func)(&ymodemBuffer[3], 128);
    1a2a:	89 e5       	ldi	r24, 0x59	; 89
    1a2c:	91 e0       	ldi	r25, 0x01	; 1
    1a2e:	60 e8       	ldi	r22, 0x80	; 128
    1a30:	70 e0       	ldi	r23, 0x00	; 0
    1a32:	f3 01       	movw	r30, r6
    1a34:	09 95       	icall
        
        bytesToSend -= 128;
    1a36:	80 e8       	ldi	r24, 0x80	; 128
    1a38:	9f ef       	ldi	r25, 0xFF	; 255
    1a3a:	af ef       	ldi	r26, 0xFF	; 255
    1a3c:	bf ef       	ldi	r27, 0xFF	; 255
    1a3e:	a8 0e       	add	r10, r24
    1a40:	b9 1e       	adc	r11, r25
    1a42:	ca 1e       	adc	r12, r26
    1a44:	db 1e       	adc	r13, r27
        
        bytesToSend = 0;

      } 
      
      ymodemBuffer[0] = YMODEM_SOH_128;
    1a46:	50 92 56 01 	sts	0x0156, r5
      ymodemBuffer[1] = packetNum;
    1a4a:	80 92 57 01 	sts	0x0157, r8
      ymodemBuffer[2] = ~packetNum;
    1a4e:	88 2d       	mov	r24, r8
    1a50:	80 95       	com	r24
    1a52:	80 93 58 01 	sts	0x0158, r24
    1a56:	e9 e5       	ldi	r30, 0x59	; 89
    1a58:	f1 e0       	ldi	r31, 0x01	; 1
    1a5a:	20 e0       	ldi	r18, 0x00	; 0
    1a5c:	30 e0       	ldi	r19, 0x00	; 0
static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    crc = _crc_xmodem_update(crc, *ptr++);
    1a5e:	81 91       	ld	r24, Z+
    1a60:	38 27       	eor	r19, r24
    1a62:	03 2e       	mov	r0, r19
    1a64:	02 94       	swap	r0
    1a66:	90 2d       	mov	r25, r0
    1a68:	9f 70       	andi	r25, 0x0F	; 15
    1a6a:	93 27       	eor	r25, r19
    1a6c:	83 2f       	mov	r24, r19
    1a6e:	80 25       	eor	r24, r0
    1a70:	88 0f       	add	r24, r24
    1a72:	80 7e       	andi	r24, 0xE0	; 224
    1a74:	98 27       	eor	r25, r24
    1a76:	80 2d       	mov	r24, r0
    1a78:	83 27       	eor	r24, r19
    1a7a:	80 7f       	andi	r24, 0xF0	; 240
    1a7c:	86 95       	lsr	r24
    1a7e:	03 2e       	mov	r0, r19
    1a80:	00 0c       	add	r0, r0
    1a82:	88 1f       	adc	r24, r24
    1a84:	36 95       	lsr	r19
    1a86:	36 95       	lsr	r19
    1a88:	36 95       	lsr	r19
    1a8a:	3f 71       	andi	r19, 0x1F	; 31
    1a8c:	38 27       	eor	r19, r24
    1a8e:	32 27       	eor	r19, r18
    1a90:	29 2f       	mov	r18, r25

static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    1a92:	91 e0       	ldi	r25, 0x01	; 1
    1a94:	e9 3d       	cpi	r30, 0xD9	; 217
    1a96:	f9 07       	cpc	r31, r25
    1a98:	11 f7       	brne	.-60     	; 0x1a5e <ymodem_send+0x1ea>
      
      ymodemBuffer[0] = YMODEM_SOH_128;
      ymodemBuffer[1] = packetNum;
      ymodemBuffer[2] = ~packetNum;
      crc = ymodem_calcrc((&ymodemBuffer[3]), 128);
      ymodemBuffer[131] = (uint8_t) (crc >> 8);
    1a9a:	30 93 d9 01 	sts	0x01D9, r19
      ymodemBuffer[132] = (uint8_t) crc;
    1a9e:	20 93 da 01 	sts	0x01DA, r18
    1aa2:	00 e0       	ldi	r16, 0x00	; 0
    1aa4:	10 e0       	ldi	r17, 0x00	; 0

      do {
        for(i = 0; i<BYTES_PER_PACKET; i++) {
    1aa6:	05 38       	cpi	r16, 0x85	; 133
    1aa8:	11 05       	cpc	r17, r1
    1aaa:	50 f0       	brcs	.+20     	; 0x1ac0 <ymodem_send+0x24c>
          usart_transmit(ymodemBuffer[i]);

        }

        c = usart_receive();
    1aac:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>

      } while(c != ACK);
    1ab0:	86 30       	cpi	r24, 0x06	; 6
    1ab2:	09 f4       	brne	.+2      	; 0x1ab6 <ymodem_send+0x242>
    1ab4:	6d c0       	rjmp	.+218    	; 0x1b90 <ymodem_send+0x31c>
    1ab6:	00 e0       	ldi	r16, 0x00	; 0
    1ab8:	10 e0       	ldi	r17, 0x00	; 0
      crc = ymodem_calcrc((&ymodemBuffer[3]), 128);
      ymodemBuffer[131] = (uint8_t) (crc >> 8);
      ymodemBuffer[132] = (uint8_t) crc;

      do {
        for(i = 0; i<BYTES_PER_PACKET; i++) {
    1aba:	05 38       	cpi	r16, 0x85	; 133
    1abc:	11 05       	cpc	r17, r1
    1abe:	b0 f7       	brcc	.-20     	; 0x1aac <ymodem_send+0x238>
          usart_transmit(ymodemBuffer[i]);
    1ac0:	f8 01       	movw	r30, r16
    1ac2:	ea 5a       	subi	r30, 0xAA	; 170
    1ac4:	fe 4f       	sbci	r31, 0xFE	; 254
    1ac6:	80 81       	ld	r24, Z
    1ac8:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
      crc = ymodem_calcrc((&ymodemBuffer[3]), 128);
      ymodemBuffer[131] = (uint8_t) (crc >> 8);
      ymodemBuffer[132] = (uint8_t) crc;

      do {
        for(i = 0; i<BYTES_PER_PACKET; i++) {
    1acc:	0f 5f       	subi	r16, 0xFF	; 255
    1ace:	1f 4f       	sbci	r17, 0xFF	; 255
    1ad0:	ea cf       	rjmp	.-44     	; 0x1aa6 <ymodem_send+0x232>
    packetNum++;
  }

  do {
    // Send an EOT
    usart_transmit(EOT);
    1ad2:	84 e0       	ldi	r24, 0x04	; 4
    1ad4:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    
    // Wait for ACK
    c = usart_receive();
    1ad8:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while (c != ACK);
    1adc:	86 30       	cpi	r24, 0x06	; 6
    1ade:	c9 f7       	brne	.-14     	; 0x1ad2 <ymodem_send+0x25e>

  // Wait for a 'C' character
  do {
    c = usart_receive();
    1ae0:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while (c != 'C');
    1ae4:	83 34       	cpi	r24, 0x43	; 67
    1ae6:	e1 f7       	brne	.-8      	; 0x1ae0 <ymodem_send+0x26c>
    1ae8:	e6 e5       	ldi	r30, 0x56	; 86
    1aea:	f1 e0       	ldi	r31, 0x01	; 1

  // Send a null filename file
  for(i = 0; i < BYTES_PER_PACKET; i++) {
    ymodemBuffer[i] = 0;
    1aec:	11 92       	st	Z+, r1
  do {
    c = usart_receive();
  } while (c != 'C');

  // Send a null filename file
  for(i = 0; i < BYTES_PER_PACKET; i++) {
    1aee:	a1 e0       	ldi	r26, 0x01	; 1
    1af0:	eb 3d       	cpi	r30, 0xDB	; 219
    1af2:	fa 07       	cpc	r31, r26
    1af4:	d9 f7       	brne	.-10     	; 0x1aec <ymodem_send+0x278>
    1af6:	e9 e5       	ldi	r30, 0x59	; 89
    1af8:	f1 e0       	ldi	r31, 0x01	; 1
    1afa:	20 e0       	ldi	r18, 0x00	; 0
    1afc:	30 e0       	ldi	r19, 0x00	; 0
static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    crc = _crc_xmodem_update(crc, *ptr++);
    1afe:	81 91       	ld	r24, Z+
    1b00:	38 27       	eor	r19, r24
    1b02:	03 2e       	mov	r0, r19
    1b04:	02 94       	swap	r0
    1b06:	90 2d       	mov	r25, r0
    1b08:	9f 70       	andi	r25, 0x0F	; 15
    1b0a:	93 27       	eor	r25, r19
    1b0c:	83 2f       	mov	r24, r19
    1b0e:	80 25       	eor	r24, r0
    1b10:	88 0f       	add	r24, r24
    1b12:	80 7e       	andi	r24, 0xE0	; 224
    1b14:	98 27       	eor	r25, r24
    1b16:	80 2d       	mov	r24, r0
    1b18:	83 27       	eor	r24, r19
    1b1a:	80 7f       	andi	r24, 0xF0	; 240
    1b1c:	86 95       	lsr	r24
    1b1e:	03 2e       	mov	r0, r19
    1b20:	00 0c       	add	r0, r0
    1b22:	88 1f       	adc	r24, r24
    1b24:	36 95       	lsr	r19
    1b26:	36 95       	lsr	r19
    1b28:	36 95       	lsr	r19
    1b2a:	3f 71       	andi	r19, 0x1F	; 31
    1b2c:	38 27       	eor	r19, r24
    1b2e:	32 27       	eor	r19, r18
    1b30:	29 2f       	mov	r18, r25

static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    1b32:	ee 16       	cp	r14, r30
    1b34:	ff 06       	cpc	r15, r31
    1b36:	19 f7       	brne	.-58     	; 0x1afe <ymodem_send+0x28a>
  for(i = 0; i < BYTES_PER_PACKET; i++) {
    ymodemBuffer[i] = 0;
  }
  crc = ymodem_calcrc((&ymodemBuffer[3]), 128);
  
  ymodemBuffer[0] = YMODEM_SOH_128;
    1b38:	81 e0       	ldi	r24, 0x01	; 1
    1b3a:	80 93 56 01 	sts	0x0156, r24
  ymodemBuffer[1] = 0;
    1b3e:	10 92 57 01 	sts	0x0157, r1
  ymodemBuffer[2] = 0xFF;
    1b42:	8f ef       	ldi	r24, 0xFF	; 255
    1b44:	80 93 58 01 	sts	0x0158, r24
  ymodemBuffer[131] = (uint8_t) (crc >> 8);
    1b48:	30 93 d9 01 	sts	0x01D9, r19
  ymodemBuffer[132] = (uint8_t) crc;
    1b4c:	20 93 da 01 	sts	0x01DA, r18
    1b50:	00 e0       	ldi	r16, 0x00	; 0
    1b52:	10 e0       	ldi	r17, 0x00	; 0

  do {
    for(i = 0; i<BYTES_PER_PACKET; i++) {
    1b54:	05 38       	cpi	r16, 0x85	; 133
    1b56:	11 05       	cpc	r17, r1
    1b58:	50 f0       	brcs	.+20     	; 0x1b6e <ymodem_send+0x2fa>
      usart_transmit(ymodemBuffer[i]);
    }

    c = usart_receive();
    1b5a:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(c != ACK);
    1b5e:	86 30       	cpi	r24, 0x06	; 6
    1b60:	09 f4       	brne	.+2      	; 0x1b64 <ymodem_send+0x2f0>
    1b62:	86 c0       	rjmp	.+268    	; 0x1c70 <ymodem_send+0x3fc>
    1b64:	00 e0       	ldi	r16, 0x00	; 0
    1b66:	10 e0       	ldi	r17, 0x00	; 0
  ymodemBuffer[2] = 0xFF;
  ymodemBuffer[131] = (uint8_t) (crc >> 8);
  ymodemBuffer[132] = (uint8_t) crc;

  do {
    for(i = 0; i<BYTES_PER_PACKET; i++) {
    1b68:	05 38       	cpi	r16, 0x85	; 133
    1b6a:	11 05       	cpc	r17, r1
    1b6c:	b0 f7       	brcc	.-20     	; 0x1b5a <ymodem_send+0x2e6>
      usart_transmit(ymodemBuffer[i]);
    1b6e:	f8 01       	movw	r30, r16
    1b70:	ea 5a       	subi	r30, 0xAA	; 170
    1b72:	fe 4f       	sbci	r31, 0xFE	; 254
    1b74:	80 81       	ld	r24, Z
    1b76:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  ymodemBuffer[2] = 0xFF;
  ymodemBuffer[131] = (uint8_t) (crc >> 8);
  ymodemBuffer[132] = (uint8_t) crc;

  do {
    for(i = 0; i<BYTES_PER_PACKET; i++) {
    1b7a:	0f 5f       	subi	r16, 0xFF	; 255
    1b7c:	1f 4f       	sbci	r17, 0xFF	; 255
    1b7e:	ea cf       	rjmp	.-44     	; 0x1b54 <ymodem_send+0x2e0>

      (buffer_func)(&ymodemBuffer[3], 1024);
      crc = ymodem_calcrc(&ymodemBuffer[3], 1024);
      ymodemBuffer[1027] = (uint8_t) (crc >> 8);
      ymodemBuffer[1028] = (uint8_t) crc;
      bytesToSend -= 1024;
    1b80:	80 e0       	ldi	r24, 0x00	; 0
    1b82:	9c ef       	ldi	r25, 0xFC	; 252
    1b84:	af ef       	ldi	r26, 0xFF	; 255
    1b86:	bf ef       	ldi	r27, 0xFF	; 255
    1b88:	a8 0e       	add	r10, r24
    1b8a:	b9 1e       	adc	r11, r25
    1b8c:	ca 1e       	adc	r12, r26
    1b8e:	db 1e       	adc	r13, r27
        c = usart_receive();

      } while(c != ACK);
    }
    
    ymodemSentPackets++;
    1b90:	80 91 54 01 	lds	r24, 0x0154
    1b94:	90 91 55 01 	lds	r25, 0x0155
    1b98:	01 96       	adiw	r24, 0x01	; 1
    1b9a:	90 93 55 01 	sts	0x0155, r25
    1b9e:	80 93 54 01 	sts	0x0154, r24
  while(c != 'C') {
    c = usart_receive();
  }

  // Okay, now onto the data 
  while(bytesToSend > 0) {
    1ba2:	a1 14       	cp	r10, r1
    1ba4:	b1 04       	cpc	r11, r1
    1ba6:	c1 04       	cpc	r12, r1
    1ba8:	d1 04       	cpc	r13, r1
    1baa:	09 f4       	brne	.+2      	; 0x1bae <ymodem_send+0x33a>
    1bac:	92 cf       	rjmp	.-220    	; 0x1ad2 <ymodem_send+0x25e>

      } while(c != ACK);
    }
    
    ymodemSentPackets++;
    packetNum++;
    1bae:	83 94       	inc	r8
    1bb0:	2b cf       	rjmp	.-426    	; 0x1a08 <ymodem_send+0x194>
        bytesToSend -= 128;

  
      } else {
        // Leftovers (<128)
        (buffer_func)(&ymodemBuffer[3], bytesToSend);
    1bb2:	85 01       	movw	r16, r10
    1bb4:	89 e5       	ldi	r24, 0x59	; 89
    1bb6:	91 e0       	ldi	r25, 0x01	; 1
    1bb8:	b5 01       	movw	r22, r10
    1bba:	f3 01       	movw	r30, r6
    1bbc:	09 95       	icall
    1bbe:	f5 01       	movw	r30, r10
    1bc0:	e7 5a       	subi	r30, 0xA7	; 167
    1bc2:	fe 4f       	sbci	r31, 0xFE	; 254
        for(i = bytesToSend; i < BYTES_PER_PACKET;i++) {
          ymodemBuffer[3+i] = CTRLZ;
    1bc4:	91 92       	st	Z+, r9

  
      } else {
        // Leftovers (<128)
        (buffer_func)(&ymodemBuffer[3], bytesToSend);
        for(i = bytesToSend; i < BYTES_PER_PACKET;i++) {
    1bc6:	0f 5f       	subi	r16, 0xFF	; 255
    1bc8:	1f 4f       	sbci	r17, 0xFF	; 255
    1bca:	05 38       	cpi	r16, 0x85	; 133
    1bcc:	11 05       	cpc	r17, r1
    1bce:	d0 f3       	brcs	.-12     	; 0x1bc4 <ymodem_send+0x350>
    1bd0:	aa 24       	eor	r10, r10
    1bd2:	bb 24       	eor	r11, r11
    1bd4:	65 01       	movw	r12, r10
    1bd6:	37 cf       	rjmp	.-402    	; 0x1a46 <ymodem_send+0x1d2>
  // Okay, now onto the data 
  while(bytesToSend > 0) {
    
    if(bytesToSend > 1024) {

      (buffer_func)(&ymodemBuffer[3], 1024);
    1bd8:	89 e5       	ldi	r24, 0x59	; 89
    1bda:	91 e0       	ldi	r25, 0x01	; 1
    1bdc:	60 e0       	ldi	r22, 0x00	; 0
    1bde:	74 e0       	ldi	r23, 0x04	; 4
    1be0:	f3 01       	movw	r30, r6
    1be2:	09 95       	icall
    1be4:	e9 e5       	ldi	r30, 0x59	; 89
    1be6:	f1 e0       	ldi	r31, 0x01	; 1
    1be8:	20 e0       	ldi	r18, 0x00	; 0
    1bea:	30 e0       	ldi	r19, 0x00	; 0
static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    crc = _crc_xmodem_update(crc, *ptr++);
    1bec:	81 91       	ld	r24, Z+
    1bee:	38 27       	eor	r19, r24
    1bf0:	03 2e       	mov	r0, r19
    1bf2:	02 94       	swap	r0
    1bf4:	90 2d       	mov	r25, r0
    1bf6:	9f 70       	andi	r25, 0x0F	; 15
    1bf8:	93 27       	eor	r25, r19
    1bfa:	83 2f       	mov	r24, r19
    1bfc:	80 25       	eor	r24, r0
    1bfe:	88 0f       	add	r24, r24
    1c00:	80 7e       	andi	r24, 0xE0	; 224
    1c02:	98 27       	eor	r25, r24
    1c04:	80 2d       	mov	r24, r0
    1c06:	83 27       	eor	r24, r19
    1c08:	80 7f       	andi	r24, 0xF0	; 240
    1c0a:	86 95       	lsr	r24
    1c0c:	03 2e       	mov	r0, r19
    1c0e:	00 0c       	add	r0, r0
    1c10:	88 1f       	adc	r24, r24
    1c12:	36 95       	lsr	r19
    1c14:	36 95       	lsr	r19
    1c16:	36 95       	lsr	r19
    1c18:	3f 71       	andi	r19, 0x1F	; 31
    1c1a:	38 27       	eor	r19, r24
    1c1c:	32 27       	eor	r19, r18
    1c1e:	29 2f       	mov	r18, r25

static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    1c20:	85 e0       	ldi	r24, 0x05	; 5
    1c22:	e9 35       	cpi	r30, 0x59	; 89
    1c24:	f8 07       	cpc	r31, r24
    1c26:	11 f7       	brne	.-60     	; 0x1bec <ymodem_send+0x378>
    
    if(bytesToSend > 1024) {

      (buffer_func)(&ymodemBuffer[3], 1024);
      crc = ymodem_calcrc(&ymodemBuffer[3], 1024);
      ymodemBuffer[1027] = (uint8_t) (crc >> 8);
    1c28:	30 83       	st	Z, r19
      ymodemBuffer[1028] = (uint8_t) crc;
    1c2a:	21 83       	std	Z+1, r18	; 0x01
      bytesToSend -= 1024;
      ymodemBuffer[0] = YMODEM_STX_1K;
    1c2c:	40 92 56 01 	sts	0x0156, r4
      ymodemBuffer[1] = packetNum;
    1c30:	80 92 57 01 	sts	0x0157, r8
      ymodemBuffer[2] = ~packetNum;
    1c34:	88 2d       	mov	r24, r8
    1c36:	80 95       	com	r24
    1c38:	80 93 58 01 	sts	0x0158, r24
    1c3c:	00 e0       	ldi	r16, 0x00	; 0
    1c3e:	10 e0       	ldi	r17, 0x00	; 0

      do {
        for(i = 0; i<BYTES_PER_PACKET_1K; i++) {
    1c40:	94 e0       	ldi	r25, 0x04	; 4
    1c42:	05 30       	cpi	r16, 0x05	; 5
    1c44:	19 07       	cpc	r17, r25
    1c46:	58 f0       	brcs	.+22     	; 0x1c5e <ymodem_send+0x3ea>
          usart_transmit(ymodemBuffer[i]);
        }

        c = usart_receive();
    1c48:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>

      } while(c != ACK);
    1c4c:	86 30       	cpi	r24, 0x06	; 6
    1c4e:	09 f4       	brne	.+2      	; 0x1c52 <ymodem_send+0x3de>
    1c50:	97 cf       	rjmp	.-210    	; 0x1b80 <ymodem_send+0x30c>
    1c52:	00 e0       	ldi	r16, 0x00	; 0
    1c54:	10 e0       	ldi	r17, 0x00	; 0
      ymodemBuffer[0] = YMODEM_STX_1K;
      ymodemBuffer[1] = packetNum;
      ymodemBuffer[2] = ~packetNum;

      do {
        for(i = 0; i<BYTES_PER_PACKET_1K; i++) {
    1c56:	94 e0       	ldi	r25, 0x04	; 4
    1c58:	05 30       	cpi	r16, 0x05	; 5
    1c5a:	19 07       	cpc	r17, r25
    1c5c:	a8 f7       	brcc	.-22     	; 0x1c48 <ymodem_send+0x3d4>
          usart_transmit(ymodemBuffer[i]);
    1c5e:	f8 01       	movw	r30, r16
    1c60:	ea 5a       	subi	r30, 0xAA	; 170
    1c62:	fe 4f       	sbci	r31, 0xFE	; 254
    1c64:	80 81       	ld	r24, Z
    1c66:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
      ymodemBuffer[0] = YMODEM_STX_1K;
      ymodemBuffer[1] = packetNum;
      ymodemBuffer[2] = ~packetNum;

      do {
        for(i = 0; i<BYTES_PER_PACKET_1K; i++) {
    1c6a:	0f 5f       	subi	r16, 0xFF	; 255
    1c6c:	1f 4f       	sbci	r17, 0xFF	; 255
    1c6e:	e8 cf       	rjmp	.-48     	; 0x1c40 <ymodem_send+0x3cc>
    c = usart_receive();
  } while(c != ACK);

  return 0;

}
    1c70:	80 e0       	ldi	r24, 0x00	; 0
    1c72:	2b 96       	adiw	r28, 0x0b	; 11
    1c74:	0f b6       	in	r0, 0x3f	; 63
    1c76:	f8 94       	cli
    1c78:	de bf       	out	0x3e, r29	; 62
    1c7a:	0f be       	out	0x3f, r0	; 63
    1c7c:	cd bf       	out	0x3d, r28	; 61
    1c7e:	cf 91       	pop	r28
    1c80:	df 91       	pop	r29
    1c82:	1f 91       	pop	r17
    1c84:	0f 91       	pop	r16
    1c86:	ff 90       	pop	r15
    1c88:	ef 90       	pop	r14
    1c8a:	df 90       	pop	r13
    1c8c:	cf 90       	pop	r12
    1c8e:	bf 90       	pop	r11
    1c90:	af 90       	pop	r10
    1c92:	9f 90       	pop	r9
    1c94:	8f 90       	pop	r8
    1c96:	7f 90       	pop	r7
    1c98:	6f 90       	pop	r6
    1c9a:	5f 90       	pop	r5
    1c9c:	4f 90       	pop	r4
    1c9e:	3f 90       	pop	r3
    1ca0:	2f 90       	pop	r2
    1ca2:	08 95       	ret
  uint16_t i = 0;
  fileSizeStr[0] = '0';
  if(bytesToSend == 0) {
    i = 1; // Need to push at least one value out
  }
  while(bytesToSend > 0) {
    1ca4:	5e 01       	movw	r10, r28
    1ca6:	08 94       	sec
    1ca8:	a1 1c       	adc	r10, r1
    1caa:	b1 1c       	adc	r11, r1
    1cac:	82 01       	movw	r16, r4
    1cae:	71 01       	movw	r14, r2
    fileSizeStr[i] = bytesToSend % 10 + '0';
    1cb0:	c8 01       	movw	r24, r16
    1cb2:	b7 01       	movw	r22, r14
    1cb4:	2a e0       	ldi	r18, 0x0A	; 10
    1cb6:	30 e0       	ldi	r19, 0x00	; 0
    1cb8:	40 e0       	ldi	r20, 0x00	; 0
    1cba:	50 e0       	ldi	r21, 0x00	; 0
    1cbc:	0e 94 68 20 	call	0x40d0	; 0x40d0 <__udivmodsi4>
    1cc0:	60 5d       	subi	r22, 0xD0	; 208
    1cc2:	f5 01       	movw	r30, r10
    1cc4:	61 93       	st	Z+, r22
    1cc6:	5f 01       	movw	r10, r30
    bytesToSend /= 10;
    1cc8:	c8 01       	movw	r24, r16
    1cca:	b7 01       	movw	r22, r14
    1ccc:	2a e0       	ldi	r18, 0x0A	; 10
    1cce:	30 e0       	ldi	r19, 0x00	; 0
    1cd0:	40 e0       	ldi	r20, 0x00	; 0
    1cd2:	50 e0       	ldi	r21, 0x00	; 0
    1cd4:	0e 94 68 20 	call	0x40d0	; 0x40d0 <__udivmodsi4>
    1cd8:	c9 01       	movw	r24, r18
    1cda:	da 01       	movw	r26, r20
    1cdc:	7c 01       	movw	r14, r24
    1cde:	8d 01       	movw	r16, r26
    i++;
    1ce0:	08 94       	sec
    1ce2:	c1 1c       	adc	r12, r1
    1ce4:	d1 1c       	adc	r13, r1
  uint16_t i = 0;
  fileSizeStr[0] = '0';
  if(bytesToSend == 0) {
    i = 1; // Need to push at least one value out
  }
  while(bytesToSend > 0) {
    1ce6:	e1 14       	cp	r14, r1
    1ce8:	f1 04       	cpc	r15, r1
    1cea:	01 05       	cpc	r16, r1
    1cec:	11 05       	cpc	r17, r1
    1cee:	01 f7       	brne	.-64     	; 0x1cb0 <ymodem_send+0x43c>
    bytesToSend /= 10;
    i++;
  }
  bytesToSend = fileSize;
  // Now we've converted it in reverse, pump it back out correctly
  for(; i > 0; i--, bufferPos++) {
    1cf0:	c1 14       	cp	r12, r1
    1cf2:	d1 04       	cpc	r13, r1
    1cf4:	09 f0       	breq	.+2      	; 0x1cf8 <ymodem_send+0x484>
    1cf6:	0c ce       	rjmp	.-1000   	; 0x1910 <ymodem_send+0x9c>
    1cf8:	19 ce       	rjmp	.-974    	; 0x192c <ymodem_send+0xb8>
  while(c != 'C') {
    c = usart_receive();
  }

  // First packet is all about filename and filesize
  for(uint8_t i = 0; filename[i] != '\0'; i++, bufferPos++) {
    1cfa:	a3 e0       	ldi	r26, 0x03	; 3
    1cfc:	b0 e0       	ldi	r27, 0x00	; 0
    1cfe:	44 e0       	ldi	r20, 0x04	; 4
    1d00:	84 2e       	mov	r8, r20
    1d02:	91 2c       	mov	r9, r1
    1d04:	f5 cd       	rjmp	.-1046   	; 0x18f0 <ymodem_send+0x7c>

00001d06 <ymodem_receive>:
uint8_t ymodem_receive(void(*buffer_func)(unsigned char*, uint16_t), uint32_t *fileSize);
static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count);
uint8_t ymodem_send(uint8_t(*buffer_func)(unsigned char*, uint16_t), char * filename, uint32_t fileSize);

uint8_t ymodem_receive(void(*buffer_func)(unsigned char*, uint16_t), uint32_t *fileSize)
{
    1d06:	3f 92       	push	r3
    1d08:	4f 92       	push	r4
    1d0a:	5f 92       	push	r5
    1d0c:	6f 92       	push	r6
    1d0e:	7f 92       	push	r7
    1d10:	8f 92       	push	r8
    1d12:	9f 92       	push	r9
    1d14:	af 92       	push	r10
    1d16:	bf 92       	push	r11
    1d18:	cf 92       	push	r12
    1d1a:	df 92       	push	r13
    1d1c:	ef 92       	push	r14
    1d1e:	ff 92       	push	r15
    1d20:	0f 93       	push	r16
    1d22:	1f 93       	push	r17
    1d24:	cf 93       	push	r28
    1d26:	df 93       	push	r29
    1d28:	2c 01       	movw	r4, r24
    1d2a:	3b 01       	movw	r6, r22
  ymodemReceivedPackets = 0;
    1d2c:	10 92 60 05 	sts	0x0560, r1
    1d30:	10 92 5f 05 	sts	0x055F, r1
  uint8_t canAttempts = 0;
  uint8_t resendPacket = 0;
  uint8_t lastPacketNum = 0; // =0 is a hack so that packet num 0 is not caught by accident - actually maybe not...
  
  // Send 'C' to initiate header transfer with CRC-16 
  usart_transmit('C');
    1d34:	83 e4       	ldi	r24, 0x43	; 67
    1d36:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    1d3a:	88 24       	eor	r8, r8
    1d3c:	99 24       	eor	r9, r9
    1d3e:	54 01       	movw	r10, r8
    1d40:	ee 24       	eor	r14, r14
    1d42:	33 24       	eor	r3, r3
    1d44:	ff 24       	eor	r15, r15
    1d46:	00 e0       	ldi	r16, 0x00	; 0
    1d48:	10 e0       	ldi	r17, 0x00	; 0
      if(shortPacketMode && (i >= BYTES_PER_PACKET)) {
        // This is a short packet! Don't read over 133 bytes
        break;
      }
      
      uint8_t c = usart_receive();
    1d4a:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>

      ymodemBuffer[i] = c;
    1d4e:	f8 01       	movw	r30, r16
    1d50:	ea 5a       	subi	r30, 0xAA	; 170
    1d52:	fe 4f       	sbci	r31, 0xFE	; 254
    1d54:	80 83       	st	Z, r24

      if(i==0) {
    1d56:	01 15       	cp	r16, r1
    1d58:	11 05       	cpc	r17, r1
    1d5a:	09 f0       	breq	.+2      	; 0x1d5e <ymodem_receive+0x58>
    1d5c:	55 c0       	rjmp	.+170    	; 0x1e08 <ymodem_receive+0x102>
        if(ymodemBuffer[i] == YMODEM_SOH_128) {
    1d5e:	81 30       	cpi	r24, 0x01	; 1
    1d60:	09 f4       	brne	.+2      	; 0x1d64 <ymodem_receive+0x5e>
    1d62:	4f c0       	rjmp	.+158    	; 0x1e02 <ymodem_receive+0xfc>
          shortPacketMode = 1;
          canAttempts = 0;

        } else if (ymodemBuffer[i] == YMODEM_STX_1K) {       
    1d64:	82 30       	cpi	r24, 0x02	; 2
    1d66:	09 f4       	brne	.+2      	; 0x1d6a <ymodem_receive+0x64>
    1d68:	7d c0       	rjmp	.+250    	; 0x1e64 <ymodem_receive+0x15e>
          shortPacketMode = 0;
          canAttempts = 0;

        } else if(ymodemBuffer[i] == EOT) {
    1d6a:	84 30       	cpi	r24, 0x04	; 4
    1d6c:	09 f4       	brne	.+2      	; 0x1d70 <ymodem_receive+0x6a>
    1d6e:	1b c1       	rjmp	.+566    	; 0x1fa6 <ymodem_receive+0x2a0>
          // Maybe should have a timeout here if the final ACK is lost and the sender fires EOT through again
          return 0;

        } else if(!((ymodemBuffer[i] == EOT) || (ymodemBuffer[i] == YMODEM_SOH_128) || (ymodemBuffer[i] == YMODEM_STX_1K))) {
          // Don't know what that was. Increment the cancellation counter and send a CAN
          usart_transmit(NACK);
    1d70:	85 e1       	ldi	r24, 0x15	; 21
    1d72:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
          canAttempts++;
    1d76:	e3 94       	inc	r14

          if(canAttempts > YMODEM_MAX_RETRIES) { 
    1d78:	93 e0       	ldi	r25, 0x03	; 3
    1d7a:	9e 15       	cp	r25, r14
    1d7c:	08 f4       	brcc	.+2      	; 0x1d80 <ymodem_receive+0x7a>
    1d7e:	9a c1       	rjmp	.+820    	; 0x20b4 <ymodem_receive+0x3ae>
  uint8_t canAttempts = 0;
  uint8_t resendPacket = 0;
  uint8_t lastPacketNum = 0; // =0 is a hack so that packet num 0 is not caught by accident - actually maybe not...
  
  // Send 'C' to initiate header transfer with CRC-16 
  usart_transmit('C');
    1d80:	01 e0       	ldi	r16, 0x01	; 1
    1d82:	10 e0       	ldi	r17, 0x00	; 0

    uint8_t shortPacketMode = 0;

    for(uint16_t i=0; i<BYTES_PER_PACKET_1K;i++) {

      if(shortPacketMode && (i >= BYTES_PER_PACKET)) {
    1d84:	ff 20       	and	r15, r15
    1d86:	09 f3       	breq	.-62     	; 0x1d4a <ymodem_receive+0x44>
    1d88:	05 38       	cpi	r16, 0x85	; 133
    1d8a:	11 05       	cpc	r17, r1
    1d8c:	f0 f2       	brcs	.-68     	; 0x1d4a <ymodem_receive+0x44>
    1d8e:	41 e0       	ldi	r20, 0x01	; 1
        }
      }
    }

    // Data is in. Check the packet number and CRC
    if (shortPacketMode) {
    1d90:	e9 e5       	ldi	r30, 0x59	; 89
    1d92:	f1 e0       	ldi	r31, 0x01	; 1
    1d94:	20 e0       	ldi	r18, 0x00	; 0
    1d96:	30 e0       	ldi	r19, 0x00	; 0
static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    crc = _crc_xmodem_update(crc, *ptr++);
    1d98:	81 91       	ld	r24, Z+
    1d9a:	38 27       	eor	r19, r24
    1d9c:	03 2e       	mov	r0, r19
    1d9e:	02 94       	swap	r0
    1da0:	90 2d       	mov	r25, r0
    1da2:	9f 70       	andi	r25, 0x0F	; 15
    1da4:	93 27       	eor	r25, r19
    1da6:	83 2f       	mov	r24, r19
    1da8:	80 25       	eor	r24, r0
    1daa:	88 0f       	add	r24, r24
    1dac:	80 7e       	andi	r24, 0xE0	; 224
    1dae:	98 27       	eor	r25, r24
    1db0:	80 2d       	mov	r24, r0
    1db2:	83 27       	eor	r24, r19
    1db4:	80 7f       	andi	r24, 0xF0	; 240
    1db6:	86 95       	lsr	r24
    1db8:	03 2e       	mov	r0, r19
    1dba:	00 0c       	add	r0, r0
    1dbc:	88 1f       	adc	r24, r24
    1dbe:	36 95       	lsr	r19
    1dc0:	36 95       	lsr	r19
    1dc2:	36 95       	lsr	r19
    1dc4:	3f 71       	andi	r19, 0x1F	; 31
    1dc6:	38 27       	eor	r19, r24
    1dc8:	32 27       	eor	r19, r18
    1dca:	29 2f       	mov	r18, r25

static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    1dcc:	b1 e0       	ldi	r27, 0x01	; 1
    1dce:	e9 3d       	cpi	r30, 0xD9	; 217
    1dd0:	fb 07       	cpc	r31, r27
    1dd2:	11 f7       	brne	.-60     	; 0x1d98 <ymodem_receive+0x92>

      resendPacket = 1;
      canAttempts++;
      usart_transmit(NACK);
    
    } else if (shortPacketMode && ((ymodemBuffer[131] != (unsigned char)(crc >> 8)) || (ymodemBuffer[132] != (unsigned char)(crc)))) {
    1dd4:	80 81       	ld	r24, Z
    1dd6:	83 17       	cp	r24, r19
    1dd8:	21 f4       	brne	.+8      	; 0x1de2 <ymodem_receive+0xdc>
    1dda:	81 81       	ldd	r24, Z+1	; 0x01
    1ddc:	82 17       	cp	r24, r18
    1dde:	09 f4       	brne	.+2      	; 0x1de2 <ymodem_receive+0xdc>
    1de0:	4b c0       	rjmp	.+150    	; 0x1e78 <ymodem_receive+0x172>
    
    } else if(ymodemBuffer[1] + ymodemBuffer[2] != 0xFF) { //(ymodemReceivedPackets + 1 != ymodemBuffer[1]) ||
      // Packet number not correct, could be a bad packet no. if it passed the above test

      resendPacket = 1;
      canAttempts++;
    1de2:	e3 94       	inc	r14
      usart_transmit(NACK);
    1de4:	85 e1       	ldi	r24, 0x15	; 21
    1de6:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
      canAttempts = 0;
      usart_transmit(ACK);

    }

    if(canAttempts > YMODEM_MAX_RETRIES) {
    1dea:	f3 e0       	ldi	r31, 0x03	; 3
    1dec:	fe 15       	cp	r31, r14
    1dee:	08 f0       	brcs	.+2      	; 0x1df2 <ymodem_receive+0xec>
    1df0:	a9 cf       	rjmp	.-174    	; 0x1d44 <ymodem_receive+0x3e>
      usart_transmit(YMODEM_CAN);
    1df2:	88 e1       	ldi	r24, 0x18	; 24
    1df4:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
      usart_transmit(YMODEM_CAN);
    1df8:	88 e1       	ldi	r24, 0x18	; 24
    1dfa:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    1dfe:	82 e0       	ldi	r24, 0x02	; 2
    1e00:	e9 c0       	rjmp	.+466    	; 0x1fd4 <ymodem_receive+0x2ce>
          if(canAttempts > YMODEM_MAX_RETRIES) { 
            // Something's not working. Cancel by returning.
            usart_transmit(YMODEM_CAN);
            usart_transmit(YMODEM_CAN);

            return 1;
    1e02:	ee 24       	eor	r14, r14
    1e04:	ff 24       	eor	r15, r15
    1e06:	f3 94       	inc	r15
  // Receive data till end of transmission is received
  do {

    uint8_t shortPacketMode = 0;

    for(uint16_t i=0; i<BYTES_PER_PACKET_1K;i++) {
    1e08:	0f 5f       	subi	r16, 0xFF	; 255
    1e0a:	1f 4f       	sbci	r17, 0xFF	; 255
    1e0c:	a4 e0       	ldi	r26, 0x04	; 4
    1e0e:	05 30       	cpi	r16, 0x05	; 5
    1e10:	1a 07       	cpc	r17, r26
    1e12:	08 f4       	brcc	.+2      	; 0x1e16 <ymodem_receive+0x110>
    1e14:	b7 cf       	rjmp	.-146    	; 0x1d84 <ymodem_receive+0x7e>
    1e16:	4f 2d       	mov	r20, r15
        }
      }
    }

    // Data is in. Check the packet number and CRC
    if (shortPacketMode) {
    1e18:	ff 20       	and	r15, r15
    1e1a:	09 f0       	breq	.+2      	; 0x1e1e <ymodem_receive+0x118>
    1e1c:	b9 cf       	rjmp	.-142    	; 0x1d90 <ymodem_receive+0x8a>

static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    1e1e:	e9 e5       	ldi	r30, 0x59	; 89
    1e20:	f1 e0       	ldi	r31, 0x01	; 1
    1e22:	20 e0       	ldi	r18, 0x00	; 0
    1e24:	30 e0       	ldi	r19, 0x00	; 0
    crc = _crc_xmodem_update(crc, *ptr++);
    1e26:	81 91       	ld	r24, Z+
    1e28:	38 27       	eor	r19, r24
    1e2a:	03 2e       	mov	r0, r19
    1e2c:	02 94       	swap	r0
    1e2e:	90 2d       	mov	r25, r0
    1e30:	9f 70       	andi	r25, 0x0F	; 15
    1e32:	93 27       	eor	r25, r19
    1e34:	83 2f       	mov	r24, r19
    1e36:	80 25       	eor	r24, r0
    1e38:	88 0f       	add	r24, r24
    1e3a:	80 7e       	andi	r24, 0xE0	; 224
    1e3c:	98 27       	eor	r25, r24
    1e3e:	80 2d       	mov	r24, r0
    1e40:	83 27       	eor	r24, r19
    1e42:	80 7f       	andi	r24, 0xF0	; 240
    1e44:	86 95       	lsr	r24
    1e46:	03 2e       	mov	r0, r19
    1e48:	00 0c       	add	r0, r0
    1e4a:	88 1f       	adc	r24, r24
    1e4c:	36 95       	lsr	r19
    1e4e:	36 95       	lsr	r19
    1e50:	36 95       	lsr	r19
    1e52:	3f 71       	andi	r19, 0x1F	; 31
    1e54:	38 27       	eor	r19, r24
    1e56:	32 27       	eor	r19, r18
    1e58:	29 2f       	mov	r18, r25

static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    1e5a:	85 e0       	ldi	r24, 0x05	; 5
    1e5c:	e9 35       	cpi	r30, 0x59	; 89
    1e5e:	f8 07       	cpc	r31, r24
    1e60:	11 f7       	brne	.-60     	; 0x1e26 <ymodem_receive+0x120>
    1e62:	b8 cf       	rjmp	.-144    	; 0x1dd4 <ymodem_receive+0xce>
      if(i==0) {
        if(ymodemBuffer[i] == YMODEM_SOH_128) {
          shortPacketMode = 1;
          canAttempts = 0;

        } else if (ymodemBuffer[i] == YMODEM_STX_1K) {       
    1e64:	ee 24       	eor	r14, r14
    1e66:	ff 24       	eor	r15, r15
  // Receive data till end of transmission is received
  do {

    uint8_t shortPacketMode = 0;

    for(uint16_t i=0; i<BYTES_PER_PACKET_1K;i++) {
    1e68:	0f 5f       	subi	r16, 0xFF	; 255
    1e6a:	1f 4f       	sbci	r17, 0xFF	; 255
    1e6c:	a4 e0       	ldi	r26, 0x04	; 4
    1e6e:	05 30       	cpi	r16, 0x05	; 5
    1e70:	1a 07       	cpc	r17, r26
    1e72:	08 f4       	brcc	.+2      	; 0x1e76 <ymodem_receive+0x170>
    1e74:	87 cf       	rjmp	.-242    	; 0x1d84 <ymodem_receive+0x7e>
    1e76:	cf cf       	rjmp	.-98     	; 0x1e16 <ymodem_receive+0x110>

      resendPacket = 1;
      canAttempts++;
      usart_transmit(NACK);
    
    } else if(ymodemBuffer[1] + ymodemBuffer[2] != 0xFF) { //(ymodemReceivedPackets + 1 != ymodemBuffer[1]) ||
    1e78:	30 91 57 01 	lds	r19, 0x0157
    1e7c:	20 91 58 01 	lds	r18, 0x0158
    1e80:	83 2f       	mov	r24, r19
    1e82:	90 e0       	ldi	r25, 0x00	; 0
    1e84:	82 0f       	add	r24, r18
    1e86:	91 1d       	adc	r25, r1
    1e88:	8f 3f       	cpi	r24, 0xFF	; 255
    1e8a:	91 05       	cpc	r25, r1
    1e8c:	09 f0       	breq	.+2      	; 0x1e90 <ymodem_receive+0x18a>
    1e8e:	a9 cf       	rjmp	.-174    	; 0x1de2 <ymodem_receive+0xdc>

      resendPacket = 1;
      canAttempts++;
      usart_transmit(NACK);
    
    } else if (ymodemReceivedPackets == 0 && ymodemBuffer[1] == 0) {
    1e90:	80 91 5f 05 	lds	r24, 0x055F
    1e94:	90 91 60 05 	lds	r25, 0x0560
    1e98:	89 2b       	or	r24, r25
    1e9a:	09 f0       	breq	.+2      	; 0x1e9e <ymodem_receive+0x198>
    1e9c:	ad c0       	rjmp	.+346    	; 0x1ff8 <ymodem_receive+0x2f2>
    1e9e:	33 23       	and	r19, r19
    1ea0:	09 f0       	breq	.+2      	; 0x1ea4 <ymodem_receive+0x19e>
    1ea2:	aa c0       	rjmp	.+340    	; 0x1ff8 <ymodem_receive+0x2f2>
    1ea4:	23 e0       	ldi	r18, 0x03	; 3
    1ea6:	30 e0       	ldi	r19, 0x00	; 0
    1ea8:	06 c0       	rjmp	.+12     	; 0x1eb6 <ymodem_receive+0x1b0>
               * we have a NULL filename and the first few digits of
               * the file length are zero, we'll call it empty.
               */
      // Find the filename length
      uint16_t fileDatPos = 0;
      for (fileDatPos = 3; fileDatPos < 1026; fileDatPos++) {
    1eaa:	2f 5f       	subi	r18, 0xFF	; 255
    1eac:	3f 4f       	sbci	r19, 0xFF	; 255
    1eae:	94 e0       	ldi	r25, 0x04	; 4
    1eb0:	22 30       	cpi	r18, 0x02	; 2
    1eb2:	39 07       	cpc	r19, r25
    1eb4:	51 f0       	breq	.+20     	; 0x1eca <ymodem_receive+0x1c4>
        if (ymodemBuffer[fileDatPos] == '\0') {
    1eb6:	f9 01       	movw	r30, r18
    1eb8:	ea 5a       	subi	r30, 0xAA	; 170
    1eba:	fe 4f       	sbci	r31, 0xFE	; 254
    1ebc:	80 81       	ld	r24, Z
    1ebe:	88 23       	and	r24, r24
    1ec0:	a1 f7       	brne	.-24     	; 0x1eaa <ymodem_receive+0x1a4>
          break;
        }
      }

      if(fileDatPos < 7) {
    1ec2:	27 30       	cpi	r18, 0x07	; 7
    1ec4:	31 05       	cpc	r19, r1
    1ec6:	08 f4       	brcc	.+2      	; 0x1eca <ymodem_receive+0x1c4>
    1ec8:	10 c1       	rjmp	.+544    	; 0x20ea <ymodem_receive+0x3e4>
      }
      
      // To tell you the truth, I really don't care what the incoming filename is
      // No parsing of the filename done here.

      fileDatPos++; // Need one more increment to get away from the last NULL
    1eca:	e9 01       	movw	r28, r18
    1ecc:	21 96       	adiw	r28, 0x01	; 1

      // strip leading spaces if any
    	while(ymodemBuffer[fileDatPos] == ' ' && fileDatPos < 1026) {
    1ece:	fe 01       	movw	r30, r28
    1ed0:	ea 5a       	subi	r30, 0xAA	; 170
    1ed2:	fe 4f       	sbci	r31, 0xFE	; 254
    1ed4:	80 81       	ld	r24, Z
    1ed6:	80 32       	cpi	r24, 0x20	; 32
    1ed8:	a1 f4       	brne	.+40     	; 0x1f02 <ymodem_receive+0x1fc>
    1eda:	a4 e0       	ldi	r26, 0x04	; 4
    1edc:	c2 30       	cpi	r28, 0x02	; 2
    1ede:	da 07       	cpc	r29, r26
    1ee0:	80 f4       	brcc	.+32     	; 0x1f02 <ymodem_receive+0x1fc>
    1ee2:	f9 01       	movw	r30, r18
    1ee4:	e8 5a       	subi	r30, 0xA8	; 168
    1ee6:	fe 4f       	sbci	r31, 0xFE	; 254
    1ee8:	05 c0       	rjmp	.+10     	; 0x1ef4 <ymodem_receive+0x1ee>
    1eea:	31 96       	adiw	r30, 0x01	; 1
    1eec:	b4 e0       	ldi	r27, 0x04	; 4
    1eee:	c2 30       	cpi	r28, 0x02	; 2
    1ef0:	db 07       	cpc	r29, r27
    1ef2:	20 f4       	brcc	.+8      	; 0x1efc <ymodem_receive+0x1f6>
        fileDatPos++;
    1ef4:	21 96       	adiw	r28, 0x01	; 1
      // No parsing of the filename done here.

      fileDatPos++; // Need one more increment to get away from the last NULL

      // strip leading spaces if any
    	while(ymodemBuffer[fileDatPos] == ' ' && fileDatPos < 1026) {
    1ef6:	80 81       	ld	r24, Z
    1ef8:	80 32       	cpi	r24, 0x20	; 32
    1efa:	b9 f3       	breq	.-18     	; 0x1eea <ymodem_receive+0x1e4>
    1efc:	fe 01       	movw	r30, r28
    1efe:	ea 5a       	subi	r30, 0xAA	; 170
    1f00:	fe 4f       	sbci	r31, 0xFE	; 254
        fileDatPos++;
      }

      *fileSize = 0;
    1f02:	d3 01       	movw	r26, r6
    1f04:	1d 92       	st	X+, r1
    1f06:	1d 92       	st	X+, r1
    1f08:	1d 92       	st	X+, r1
    1f0a:	1c 92       	st	X, r1
    1f0c:	13 97       	sbiw	r26, 0x03	; 3
      while((ymodemBuffer[fileDatPos] != ' ' && ymodemBuffer[fileDatPos] != '\0') && fileDatPos < 1026) {
    1f0e:	80 81       	ld	r24, Z
    1f10:	80 32       	cpi	r24, 0x20	; 32
    1f12:	09 f4       	brne	.+2      	; 0x1f16 <ymodem_receive+0x210>
    1f14:	f2 c0       	rjmp	.+484    	; 0x20fa <ymodem_receive+0x3f4>
    1f16:	88 23       	and	r24, r24
    1f18:	09 f4       	brne	.+2      	; 0x1f1c <ymodem_receive+0x216>
    1f1a:	ef c0       	rjmp	.+478    	; 0x20fa <ymodem_receive+0x3f4>
    1f1c:	b4 e0       	ldi	r27, 0x04	; 4
    1f1e:	c2 30       	cpi	r28, 0x02	; 2
    1f20:	db 07       	cpc	r29, r27
    1f22:	08 f0       	brcs	.+2      	; 0x1f26 <ymodem_receive+0x220>
    1f24:	ea c0       	rjmp	.+468    	; 0x20fa <ymodem_receive+0x3f4>
    1f26:	6f 01       	movw	r12, r30
    1f28:	ee 24       	eor	r14, r14
    1f2a:	ff 24       	eor	r15, r15
    1f2c:	87 01       	movw	r16, r14
    1f2e:	09 c0       	rjmp	.+18     	; 0x1f42 <ymodem_receive+0x23c>
    1f30:	88 23       	and	r24, r24
    1f32:	59 f1       	breq	.+86     	; 0x1f8a <ymodem_receive+0x284>
    1f34:	08 94       	sec
    1f36:	c1 1c       	adc	r12, r1
    1f38:	d1 1c       	adc	r13, r1
    1f3a:	f4 e0       	ldi	r31, 0x04	; 4
    1f3c:	c2 30       	cpi	r28, 0x02	; 2
    1f3e:	df 07       	cpc	r29, r31
    1f40:	20 f5       	brcc	.+72     	; 0x1f8a <ymodem_receive+0x284>
        // Find the end of the file size! It's in decimal format, so convert as we go

        *fileSize *= 10;
    1f42:	c8 01       	movw	r24, r16
    1f44:	b7 01       	movw	r22, r14
    1f46:	2a e0       	ldi	r18, 0x0A	; 10
    1f48:	30 e0       	ldi	r19, 0x00	; 0
    1f4a:	40 e0       	ldi	r20, 0x00	; 0
    1f4c:	50 e0       	ldi	r21, 0x00	; 0
    1f4e:	0e 94 29 20 	call	0x4052	; 0x4052 <__mulsi3>
    1f52:	f3 01       	movw	r30, r6
    1f54:	60 83       	st	Z, r22
    1f56:	71 83       	std	Z+1, r23	; 0x01
    1f58:	82 83       	std	Z+2, r24	; 0x02
    1f5a:	93 83       	std	Z+3, r25	; 0x03
        *fileSize += (ymodemBuffer[fileDatPos] - '0');
    1f5c:	d6 01       	movw	r26, r12
    1f5e:	2c 91       	ld	r18, X
    1f60:	30 e0       	ldi	r19, 0x00	; 0
    1f62:	20 53       	subi	r18, 0x30	; 48
    1f64:	30 40       	sbci	r19, 0x00	; 0
    1f66:	79 01       	movw	r14, r18
    1f68:	00 27       	eor	r16, r16
    1f6a:	f7 fc       	sbrc	r15, 7
    1f6c:	00 95       	com	r16
    1f6e:	10 2f       	mov	r17, r16
    1f70:	e6 0e       	add	r14, r22
    1f72:	f7 1e       	adc	r15, r23
    1f74:	08 1f       	adc	r16, r24
    1f76:	19 1f       	adc	r17, r25
    1f78:	e0 82       	st	Z, r14
    1f7a:	f1 82       	std	Z+1, r15	; 0x01
    1f7c:	02 83       	std	Z+2, r16	; 0x02
    1f7e:	13 83       	std	Z+3, r17	; 0x03

        fileDatPos++;
    1f80:	21 96       	adiw	r28, 0x01	; 1
    	while(ymodemBuffer[fileDatPos] == ' ' && fileDatPos < 1026) {
        fileDatPos++;
      }

      *fileSize = 0;
      while((ymodemBuffer[fileDatPos] != ' ' && ymodemBuffer[fileDatPos] != '\0') && fileDatPos < 1026) {
    1f82:	11 96       	adiw	r26, 0x01	; 1
    1f84:	8c 91       	ld	r24, X
    1f86:	80 32       	cpi	r24, 0x20	; 32
    1f88:	99 f6       	brne	.-90     	; 0x1f30 <ymodem_receive+0x22a>
        *fileSize += (ymodemBuffer[fileDatPos] - '0');

        fileDatPos++;
      }

      if(*fileSize == 0) {
    1f8a:	e1 14       	cp	r14, r1
    1f8c:	f1 04       	cpc	r15, r1
    1f8e:	01 05       	cpc	r16, r1
    1f90:	11 05       	cpc	r17, r1
    1f92:	09 f4       	brne	.+2      	; 0x1f96 <ymodem_receive+0x290>
    1f94:	b2 c0       	rjmp	.+356    	; 0x20fa <ymodem_receive+0x3f4>
        return 4;
      }

      resendPacket = 0;
      canAttempts = 0;
      usart_transmit(ACK);
    1f96:	86 e0       	ldi	r24, 0x06	; 6
    1f98:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
      usart_transmit('C');
    1f9c:	83 e4       	ldi	r24, 0x43	; 67
    1f9e:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>

    }

    if(canAttempts > YMODEM_MAX_RETRIES) {
      usart_transmit(YMODEM_CAN);
      usart_transmit(YMODEM_CAN);
    1fa2:	ee 24       	eor	r14, r14
    1fa4:	cf ce       	rjmp	.-610    	; 0x1d44 <ymodem_receive+0x3e>
          shortPacketMode = 0;
          canAttempts = 0;

        } else if(ymodemBuffer[i] == EOT) {
          // Download complete
          usart_transmit(ACK);
    1fa6:	86 e0       	ldi	r24, 0x06	; 6
    1fa8:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>

          // To gracefully finish a Ymodem program, should confirm null filename, but I'll blindly consider it done

          usart_transmit('C');
    1fac:	83 e4       	ldi	r24, 0x43	; 67
    1fae:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    1fb2:	20 e0       	ldi	r18, 0x00	; 0
    1fb4:	30 e0       	ldi	r19, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1fb6:	45 e8       	ldi	r20, 0x85	; 133
    1fb8:	52 e0       	ldi	r21, 0x02	; 2
    1fba:	ca 01       	movw	r24, r20
    1fbc:	01 97       	sbiw	r24, 0x01	; 1
    1fbe:	f1 f7       	brne	.-4      	; 0x1fbc <ymodem_receive+0x2b6>
    1fc0:	2f 5f       	subi	r18, 0xFF	; 255
    1fc2:	3f 4f       	sbci	r19, 0xFF	; 255
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1fc4:	89 e0       	ldi	r24, 0x09	; 9
    1fc6:	24 3c       	cpi	r18, 0xC4	; 196
    1fc8:	38 07       	cpc	r19, r24
    1fca:	b9 f7       	brne	.-18     	; 0x1fba <ymodem_receive+0x2b4>
          _delay_ms(250); // is there a better way to delay here?
          usart_transmit(ACK);
    1fcc:	86 e0       	ldi	r24, 0x06	; 6
    1fce:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    1fd2:	80 e0       	ldi	r24, 0x00	; 0
  } while(1);

  /* Should wait here to make sure no additional data is sent. If it is, then
  the ACK probably got garbled and the EOT has been sent again. */
  return 0;
}
    1fd4:	df 91       	pop	r29
    1fd6:	cf 91       	pop	r28
    1fd8:	1f 91       	pop	r17
    1fda:	0f 91       	pop	r16
    1fdc:	ff 90       	pop	r15
    1fde:	ef 90       	pop	r14
    1fe0:	df 90       	pop	r13
    1fe2:	cf 90       	pop	r12
    1fe4:	bf 90       	pop	r11
    1fe6:	af 90       	pop	r10
    1fe8:	9f 90       	pop	r9
    1fea:	8f 90       	pop	r8
    1fec:	7f 90       	pop	r7
    1fee:	6f 90       	pop	r6
    1ff0:	5f 90       	pop	r5
    1ff2:	4f 90       	pop	r4
    1ff4:	3f 90       	pop	r3
    1ff6:	08 95       	ret
      resendPacket = 0;
      canAttempts = 0;
      usart_transmit(ACK);
      usart_transmit('C');

    } else if (lastPacketNum == ymodemBuffer[1]) {
    1ff8:	33 16       	cp	r3, r19
    1ffa:	09 f4       	brne	.+2      	; 0x1ffe <ymodem_receive+0x2f8>
    1ffc:	6a c0       	rjmp	.+212    	; 0x20d2 <ymodem_receive+0x3cc>
    
    } else {
      // That was a good packet

      // First, see how many bytes should be passed to the buff_func, then process them
      if(shortPacketMode) {
    1ffe:	44 23       	and	r20, r20
    2000:	a9 f5       	brne	.+106    	; 0x206c <ymodem_receive+0x366>
          (buffer_func)(&ymodemBuffer[3], 128);
          recdBytes += 128;

        }
      } else {
        if(recdBytes + 1024 > *fileSize) {
    2002:	e1 2c       	mov	r14, r1
    2004:	54 e0       	ldi	r21, 0x04	; 4
    2006:	f5 2e       	mov	r15, r21
    2008:	01 2d       	mov	r16, r1
    200a:	11 2d       	mov	r17, r1
    200c:	e8 0c       	add	r14, r8
    200e:	f9 1c       	adc	r15, r9
    2010:	0a 1d       	adc	r16, r10
    2012:	1b 1d       	adc	r17, r11
    2014:	f3 01       	movw	r30, r6
    2016:	80 81       	ld	r24, Z
    2018:	91 81       	ldd	r25, Z+1	; 0x01
    201a:	a2 81       	ldd	r26, Z+2	; 0x02
    201c:	b3 81       	ldd	r27, Z+3	; 0x03
    201e:	8e 15       	cp	r24, r14
    2020:	9f 05       	cpc	r25, r15
    2022:	a0 07       	cpc	r26, r16
    2024:	b1 07       	cpc	r27, r17
    2026:	08 f0       	brcs	.+2      	; 0x202a <ymodem_receive+0x324>
    2028:	4d c0       	rjmp	.+154    	; 0x20c4 <ymodem_receive+0x3be>
          // Must be a half packet, do buffer_func accordingly
          uint16_t j = *fileSize - recdBytes;
    202a:	8c 01       	movw	r16, r24
    202c:	08 19       	sub	r16, r8
    202e:	19 09       	sbc	r17, r9
          (buffer_func)(&ymodemBuffer[3], j);
    2030:	89 e5       	ldi	r24, 0x59	; 89
    2032:	91 e0       	ldi	r25, 0x01	; 1
    2034:	b8 01       	movw	r22, r16
    2036:	f2 01       	movw	r30, r4
    2038:	09 95       	icall
          recdBytes += j;
    203a:	78 01       	movw	r14, r16
    203c:	00 e0       	ldi	r16, 0x00	; 0
    203e:	10 e0       	ldi	r17, 0x00	; 0
    2040:	e8 0c       	add	r14, r8
    2042:	f9 1c       	adc	r15, r9
    2044:	0a 1d       	adc	r16, r10
    2046:	1b 1d       	adc	r17, r11

        }
      }

      // Update some values so we are good for the next run
      lastPacketNum = ymodemBuffer[1];
    2048:	30 90 57 01 	lds	r3, 0x0157
      resendPacket = 0;
      ymodemReceivedPackets++;
    204c:	80 91 5f 05 	lds	r24, 0x055F
    2050:	90 91 60 05 	lds	r25, 0x0560
    2054:	01 96       	adiw	r24, 0x01	; 1
    2056:	90 93 60 05 	sts	0x0560, r25
    205a:	80 93 5f 05 	sts	0x055F, r24
      canAttempts = 0;
      usart_transmit(ACK);
    205e:	86 e0       	ldi	r24, 0x06	; 6
    2060:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    2064:	47 01       	movw	r8, r14
    2066:	58 01       	movw	r10, r16

    }

    if(canAttempts > YMODEM_MAX_RETRIES) {
      usart_transmit(YMODEM_CAN);
      usart_transmit(YMODEM_CAN);
    2068:	ee 24       	eor	r14, r14
    206a:	6c ce       	rjmp	.-808    	; 0x1d44 <ymodem_receive+0x3e>
    } else {
      // That was a good packet

      // First, see how many bytes should be passed to the buff_func, then process them
      if(shortPacketMode) {
        if(recdBytes + 128 > *fileSize) {
    206c:	60 e8       	ldi	r22, 0x80	; 128
    206e:	e6 2e       	mov	r14, r22
    2070:	f1 2c       	mov	r15, r1
    2072:	01 2d       	mov	r16, r1
    2074:	11 2d       	mov	r17, r1
    2076:	e8 0c       	add	r14, r8
    2078:	f9 1c       	adc	r15, r9
    207a:	0a 1d       	adc	r16, r10
    207c:	1b 1d       	adc	r17, r11
    207e:	f3 01       	movw	r30, r6
    2080:	80 81       	ld	r24, Z
    2082:	91 81       	ldd	r25, Z+1	; 0x01
    2084:	a2 81       	ldd	r26, Z+2	; 0x02
    2086:	b3 81       	ldd	r27, Z+3	; 0x03
    2088:	8e 15       	cp	r24, r14
    208a:	9f 05       	cpc	r25, r15
    208c:	a0 07       	cpc	r26, r16
    208e:	b1 07       	cpc	r27, r17
    2090:	28 f5       	brcc	.+74     	; 0x20dc <ymodem_receive+0x3d6>
          // Must be a half packet, do buffer_func accordingly
          uint8_t j = *fileSize - recdBytes;
    2092:	18 2f       	mov	r17, r24
    2094:	18 19       	sub	r17, r8
          (buffer_func)(&ymodemBuffer[3], j);
    2096:	89 e5       	ldi	r24, 0x59	; 89
    2098:	91 e0       	ldi	r25, 0x01	; 1
    209a:	61 2f       	mov	r22, r17
    209c:	70 e0       	ldi	r23, 0x00	; 0
    209e:	f2 01       	movw	r30, r4
    20a0:	09 95       	icall
          recdBytes += j;
    20a2:	d5 01       	movw	r26, r10
    20a4:	c4 01       	movw	r24, r8
    20a6:	81 0f       	add	r24, r17
    20a8:	91 1d       	adc	r25, r1
    20aa:	a1 1d       	adc	r26, r1
    20ac:	b1 1d       	adc	r27, r1
    20ae:	7c 01       	movw	r14, r24
    20b0:	8d 01       	movw	r16, r26
    20b2:	ca cf       	rjmp	.-108    	; 0x2048 <ymodem_receive+0x342>
          usart_transmit(NACK);
          canAttempts++;

          if(canAttempts > YMODEM_MAX_RETRIES) { 
            // Something's not working. Cancel by returning.
            usart_transmit(YMODEM_CAN);
    20b4:	88 e1       	ldi	r24, 0x18	; 24
    20b6:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
            usart_transmit(YMODEM_CAN);
    20ba:	88 e1       	ldi	r24, 0x18	; 24
    20bc:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    20c0:	81 e0       	ldi	r24, 0x01	; 1
    20c2:	88 cf       	rjmp	.-240    	; 0x1fd4 <ymodem_receive+0x2ce>
          (buffer_func)(&ymodemBuffer[3], j);
          recdBytes += j;

        } else {
          // Do a 1k byte buffer func
          (buffer_func)(&ymodemBuffer[3], 1024);
    20c4:	89 e5       	ldi	r24, 0x59	; 89
    20c6:	91 e0       	ldi	r25, 0x01	; 1
    20c8:	60 e0       	ldi	r22, 0x00	; 0
    20ca:	74 e0       	ldi	r23, 0x04	; 4
    20cc:	f2 01       	movw	r30, r4
    20ce:	09 95       	icall
    20d0:	bb cf       	rjmp	.-138    	; 0x2048 <ymodem_receive+0x342>

    } else if (lastPacketNum == ymodemBuffer[1]) {
      // It's a repeated packet. We've already received it successfully though

      resendPacket = 0;
      canAttempts++;
    20d2:	e3 94       	inc	r14
      usart_transmit(ACK);
    20d4:	86 e0       	ldi	r24, 0x06	; 6
    20d6:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    20da:	87 ce       	rjmp	.-754    	; 0x1dea <ymodem_receive+0xe4>
          (buffer_func)(&ymodemBuffer[3], j);
          recdBytes += j;

        } else {
          // Do a 128 byte buffer func
          (buffer_func)(&ymodemBuffer[3], 128);
    20dc:	89 e5       	ldi	r24, 0x59	; 89
    20de:	91 e0       	ldi	r25, 0x01	; 1
    20e0:	60 e8       	ldi	r22, 0x80	; 128
    20e2:	70 e0       	ldi	r23, 0x00	; 0
    20e4:	f2 01       	movw	r30, r4
    20e6:	09 95       	icall
    20e8:	af cf       	rjmp	.-162    	; 0x2048 <ymodem_receive+0x342>
      }

      if(fileDatPos < 7) {
        // Null filename?
        // May have to be careful here. Ymodem may use this to indicate no further files are coming. This may not be an error...
        usart_transmit(YMODEM_CAN);
    20ea:	88 e1       	ldi	r24, 0x18	; 24
    20ec:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
        usart_transmit(YMODEM_CAN);
    20f0:	88 e1       	ldi	r24, 0x18	; 24
    20f2:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    20f6:	83 e0       	ldi	r24, 0x03	; 3
    20f8:	6d cf       	rjmp	.-294    	; 0x1fd4 <ymodem_receive+0x2ce>
        fileDatPos++;
      }

      if(*fileSize == 0) {
        // 0 byte file. Hmmm...
        usart_transmit(YMODEM_CAN);
    20fa:	88 e1       	ldi	r24, 0x18	; 24
    20fc:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
        usart_transmit(YMODEM_CAN);
    2100:	88 e1       	ldi	r24, 0x18	; 24
    2102:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    2106:	84 e0       	ldi	r24, 0x04	; 4
    2108:	65 cf       	rjmp	.-310    	; 0x1fd4 <ymodem_receive+0x2ce>

0000210a <memory_init>:
FLASHADDR flashAddress;

void memory_init(void) {

  // Set up all of the pins
  MEMORY_DATA_DDR = 0xFF; // Data - don't assert the bus in case we're wrong about the mode
    210a:	8f ef       	ldi	r24, 0xFF	; 255
    210c:	87 b9       	out	0x07, r24	; 7
  FLASH_HI5_DDR = FLASH_HI5_MASK; // MA address lines. 
    210e:	8f e7       	ldi	r24, 0x7F	; 127
    2110:	84 b9       	out	0x04, r24	; 4

  MAC_CS_DDR |= (1 << MAC_CS);
    2112:	57 9a       	sbi	0x0a, 7	; 10
  MAC_OE_DDR |= (1 << MAC_OE);
    2114:	54 9a       	sbi	0x0a, 4	; 10
  MAC_WE_DDR |= (1 << MAC_WE);
    2116:	0c 9a       	sbi	0x01, 4	; 1

  LATCH_OE_DDR |= (1 << LATCH_OE);
    2118:	0d 9a       	sbi	0x01, 5	; 1
  LATCH_CLK_LO8_DDR |= (1 << LATCH_CLK_LO8); 
    211a:	52 9a       	sbi	0x0a, 2	; 10
  LATCH_CLK_MID6_DDR |= (1 << LATCH_CLK_MID6);
    211c:	0a 9a       	sbi	0x01, 2	; 1

  SRAM_ADDR13_14_DDR |= SRAM_ADDR13_14_MASK;
    211e:	81 b1       	in	r24, 0x01	; 1
    2120:	83 60       	ori	r24, 0x03	; 3
    2122:	81 b9       	out	0x01, r24	; 1
  SRAM_CS_DDR |= (1 << SRAM_CS);
    2124:	0f 9a       	sbi	0x01, 7	; 1
  SRAM_WE_DDR |= (1 << SRAM_WE);
    2126:	53 9a       	sbi	0x0a, 3	; 10
  SRAM_OE_DDR |= (1 << SRAM_OE);
    2128:	54 9a       	sbi	0x0a, 4	; 10

  // Pull up inverted control pins
  MAC_CS_PORT |= (1 << MAC_CS);
    212a:	5f 9a       	sbi	0x0b, 7	; 11
  MAC_OE_PORT |= (1 << MAC_OE);
    212c:	5c 9a       	sbi	0x0b, 4	; 11
  MAC_WE_PORT |= (1 << MAC_WE);
    212e:	14 9a       	sbi	0x02, 4	; 2
  LATCH_OE_PORT |= (1 << LATCH_OE);
    2130:	15 9a       	sbi	0x02, 5	; 2
  SRAM_CS_PORT |= (1 << SRAM_CS);
    2132:	17 9a       	sbi	0x02, 7	; 2
  SRAM_WE_PORT |= (1 << SRAM_WE);
    2134:	5b 9a       	sbi	0x0b, 3	; 11
  SRAM_OE_PORT |= (1 << SRAM_OE);
    2136:	5c 9a       	sbi	0x0b, 4	; 11

  FLASH_MUX_DDR |= (1 << FLASH_MUX);
    2138:	56 9a       	sbi	0x0a, 6	; 10
  FLASH_MUX_PORT |= (1 << FLASH_MUX);
    213a:	5e 9a       	sbi	0x0b, 6	; 11
}
    213c:	08 95       	ret

0000213e <mac_flash_read_byte>:

uint8_t mac_flash_read_byte(FLASHADDR address, uint8_t *returnData) {
    213e:	fa 01       	movw	r30, r20

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2140:	68 b9       	out	0x08, r22	; 8
  _NOP();
    2142:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2144:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2146:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2148:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    214a:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    214c:	78 b9       	out	0x08, r23	; 8
  _NOP();
    214e:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2150:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2152:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2154:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    2156:	00 00       	nop

  // Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2158:	2e e0       	ldi	r18, 0x0E	; 14
    215a:	96 95       	lsr	r25
    215c:	87 95       	ror	r24
    215e:	77 95       	ror	r23
    2160:	67 95       	ror	r22
    2162:	2a 95       	dec	r18
    2164:	d1 f7       	brne	.-12     	; 0x215a <mac_flash_read_byte+0x1c>
    2166:	65 b9       	out	0x05, r22	; 5
  _NOP();
    2168:	00 00       	nop

  // Set read mode by pulling OE and CS low, after making data pins an input!
  MEMORY_DATA_DDR = 0x00; // Make data lines an input
    216a:	17 b8       	out	0x07, r1	; 7
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    216c:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    216e:	00 00       	nop
  MAC_CS_PORT &= ~(1 << MAC_CS);
    2170:	5f 98       	cbi	0x0b, 7	; 11
  MAC_OE_PORT &= ~(1 << MAC_OE);
    2172:	5c 98       	cbi	0x0b, 4	; 11
	...
  _NOP();
  _NOP();
  _NOP();

  // Read the data in!
  *returnData = MEMORY_DATA_PIN;
    217c:	86 b1       	in	r24, 0x06	; 6
    217e:	80 83       	st	Z, r24

  // Pull OE and CS up again, and make PORTB outputs again
  MAC_OE_PORT |= (1 << MAC_OE);
    2180:	5c 9a       	sbi	0x0b, 4	; 11
  MAC_CS_PORT |= (1 << MAC_CS);
    2182:	5f 9a       	sbi	0x0b, 7	; 11
  LATCH_OE_PORT |= (1 << LATCH_OE);
    2184:	15 9a       	sbi	0x02, 5	; 2
  MEMORY_DATA_DDR = 0xFF;
    2186:	8f ef       	ldi	r24, 0xFF	; 255
    2188:	87 b9       	out	0x07, r24	; 7

  return 0;
}
    218a:	80 e0       	ldi	r24, 0x00	; 0
    218c:	08 95       	ret

0000218e <mac_flash_write_sub_byte>:

uint8_t mac_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    218e:	68 b9       	out	0x08, r22	; 8
  _NOP();
    2190:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2192:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2194:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2196:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2198:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    219a:	78 b9       	out	0x08, r23	; 8
  _NOP();
    219c:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    219e:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    21a0:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    21a2:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    21a4:	00 00       	nop

// Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    21a6:	3e e0       	ldi	r19, 0x0E	; 14
    21a8:	96 95       	lsr	r25
    21aa:	87 95       	ror	r24
    21ac:	77 95       	ror	r23
    21ae:	67 95       	ror	r22
    21b0:	3a 95       	dec	r19
    21b2:	d1 f7       	brne	.-12     	; 0x21a8 <mac_flash_write_sub_byte+0x1a>
    21b4:	65 b9       	out	0x05, r22	; 5
  _NOP();
    21b6:	00 00       	nop
  _NOP();
    21b8:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    21ba:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    21bc:	00 00       	nop
  _NOP();
    21be:	00 00       	nop

  // Set the data byte for the rising edge
  MEMORY_DATA_PORT = writeData;
    21c0:	48 b9       	out	0x08, r20	; 8
  _NOP();
    21c2:	00 00       	nop
  _NOP();
    21c4:	00 00       	nop
  _NOP();
    21c6:	00 00       	nop
  
  MAC_WE_PORT &= ~(1 << MAC_WE);
    21c8:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    21ca:	00 00       	nop
  _NOP();
    21cc:	00 00       	nop
  _NOP();
    21ce:	00 00       	nop

  MAC_WE_PORT |= (1 << MAC_WE);
    21d0:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    21d2:	00 00       	nop
  _NOP();
    21d4:	00 00       	nop
  _NOP();
    21d6:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    21d8:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    21da:	00 00       	nop
  _NOP();
    21dc:	00 00       	nop
  _NOP();
    21de:	00 00       	nop

  return 0;
}
    21e0:	80 e0       	ldi	r24, 0x00	; 0
    21e2:	08 95       	ret

000021e4 <sram_read_byte>:
  return chipID;
}

// *********************************** SRAM funcs ************************************************

uint8_t sram_read_byte(uint16_t address, uint8_t *returnData) {
    21e4:	fb 01       	movw	r30, r22

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = (uint8_t)(address);
    21e6:	88 b9       	out	0x08, r24	; 8
  _NOP();
    21e8:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    21ea:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    21ec:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    21ee:	5a 98       	cbi	0x0b, 2	; 11

  MEMORY_DATA_PORT = (uint8_t)(address >> 8);
    21f0:	98 b9       	out	0x08, r25	; 8
  _NOP();
    21f2:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    21f4:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    21f6:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    21f8:	12 98       	cbi	0x02, 2	; 2

  SRAM_ADDR13_14_PORT = (SRAM_ADDR13_14_PORT & (~SRAM_ADDR13_14_MASK)) | ((uint8_t)(address >> 13) & SRAM_ADDR13_14_MASK);
    21fa:	82 b1       	in	r24, 0x02	; 2
    21fc:	92 95       	swap	r25
    21fe:	96 95       	lsr	r25
    2200:	93 70       	andi	r25, 0x03	; 3
    2202:	8c 7f       	andi	r24, 0xFC	; 252
    2204:	89 2b       	or	r24, r25
    2206:	82 b9       	out	0x02, r24	; 2

  // Set read mode by pulling OE and CS low, after making data pins an input!
  MEMORY_DATA_DDR = 0x00; // Make data lines an input
    2208:	17 b8       	out	0x07, r1	; 7
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    220a:	15 98       	cbi	0x02, 5	; 2

  SRAM_CS_PORT &= ~(1 << SRAM_CS);
    220c:	17 98       	cbi	0x02, 7	; 2
  SRAM_OE_PORT &= ~(1 << SRAM_OE);
    220e:	5c 98       	cbi	0x0b, 4	; 11
	...
  // 2 x NOP required to meet the 55ns data retrieval period
  _NOP();
  _NOP();

  // Read the data in!
  *returnData = MEMORY_DATA_PIN;
    2218:	86 b1       	in	r24, 0x06	; 6
    221a:	80 83       	st	Z, r24

  // Pull OE and CS up again, and make PORTB outputs again
  SRAM_OE_PORT |= (1 << SRAM_OE);
    221c:	5c 9a       	sbi	0x0b, 4	; 11
  SRAM_CS_PORT |= (1 << SRAM_CS);
    221e:	17 9a       	sbi	0x02, 7	; 2
  LATCH_OE_PORT |= (1 << LATCH_OE);
    2220:	15 9a       	sbi	0x02, 5	; 2
  MEMORY_DATA_DDR = 0xFF;
    2222:	8f ef       	ldi	r24, 0xFF	; 255
    2224:	87 b9       	out	0x07, r24	; 7

  return 0;
}
    2226:	80 e0       	ldi	r24, 0x00	; 0
    2228:	08 95       	ret

0000222a <sram_write_byte>:

uint8_t sram_write_byte(uint16_t address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = (uint8_t)(address);
    222a:	88 b9       	out	0x08, r24	; 8
  _NOP();
    222c:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    222e:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2230:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2232:	5a 98       	cbi	0x0b, 2	; 11

  MEMORY_DATA_PORT = (uint8_t)(address >> 8);
    2234:	98 b9       	out	0x08, r25	; 8
  _NOP();
    2236:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2238:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    223a:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    223c:	12 98       	cbi	0x02, 2	; 2

  SRAM_ADDR13_14_PORT = (SRAM_ADDR13_14_PORT & (~SRAM_ADDR13_14_MASK)) | ((uint8_t)(address >> 13) & SRAM_ADDR13_14_MASK);
    223e:	82 b1       	in	r24, 0x02	; 2
    2240:	92 95       	swap	r25
    2242:	96 95       	lsr	r25
    2244:	93 70       	andi	r25, 0x03	; 3
    2246:	8c 7f       	andi	r24, 0xFC	; 252
    2248:	89 2b       	or	r24, r25
    224a:	82 b9       	out	0x02, r24	; 2

  MEMORY_DATA_PORT = writeData;
    224c:	68 b9       	out	0x08, r22	; 8

  // Set read mode by pulling OE and CS low, after making data pins an input!
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    224e:	15 98       	cbi	0x02, 5	; 2
_NOP(); // Test NOPS to find out why writing isn't working
    2250:	00 00       	nop
_NOP();
    2252:	00 00       	nop
SRAM_OE_PORT |= (1 << SRAM_OE);
    2254:	5c 9a       	sbi	0x0b, 4	; 11
_NOP();
    2256:	00 00       	nop
_NOP();
    2258:	00 00       	nop
  SRAM_CS_PORT &= ~(1 << SRAM_CS);
    225a:	17 98       	cbi	0x02, 7	; 2
_NOP(); // Test NOPS to find out why writing isn't working
    225c:	00 00       	nop
_NOP();
    225e:	00 00       	nop
  SRAM_WE_PORT &= ~(1 << SRAM_WE);
    2260:	5b 98       	cbi	0x0b, 3	; 11
	...
  _NOP();
  _NOP();
_NOP(); // Test NOPS to find out why writing isn't working
_NOP();
  // Pull OE and CS up again, and make PORTB outputs again
  SRAM_WE_PORT |= (1 << SRAM_WE);
    226e:	5b 9a       	sbi	0x0b, 3	; 11
  SRAM_CS_PORT |= (1 << SRAM_CS);
    2270:	17 9a       	sbi	0x02, 7	; 2
_NOP(); // Test NOPS to find out why writing isn't working
    2272:	00 00       	nop
_NOP();
    2274:	00 00       	nop
  LATCH_OE_PORT |= (1 << LATCH_OE);
    2276:	15 9a       	sbi	0x02, 5	; 2

  return 0;
}
    2278:	80 e0       	ldi	r24, 0x00	; 0
    227a:	08 95       	ret

0000227c <mac_read_softwareID>:
}

/*
  Returns the hex byte ID of the SST chip
*/
uint8_t mac_read_softwareID(uint8_t chipNum) {
    227c:	0f 93       	push	r16
    227e:	1f 93       	push	r17

  uint8_t chipID;
  FLASHADDR address;
  address.address32 = 2;
    2280:	42 e0       	ldi	r20, 0x02	; 2
    2282:	50 e0       	ldi	r21, 0x00	; 0
    2284:	60 e0       	ldi	r22, 0x00	; 0
    2286:	70 e0       	ldi	r23, 0x00	; 0
  address.address8[2] = chipNum << 4;
    2288:	68 2f       	mov	r22, r24
    228a:	62 95       	swap	r22
    228c:	60 7f       	andi	r22, 0xF0	; 240

  // Put the chip into ID mode. We'll use the /WE control method

  MAC_CS_PORT &= ~(1 << MAC_CS);
    228e:	5f 98       	cbi	0x0b, 7	; 11

static void mac_flash_command_sequence(uint8_t chipNum, uint8_t mode) {

  FLASHADDR address;
  // First 0xAAA, 0xAA
  address.address32 = 0xAAA;
    2290:	0a ea       	ldi	r16, 0xAA	; 170
    2292:	1a e0       	ldi	r17, 0x0A	; 10
    2294:	20 e0       	ldi	r18, 0x00	; 0
    2296:	30 e0       	ldi	r19, 0x00	; 0
  address.address8[2] |= (chipNum << 4);
    2298:	90 e0       	ldi	r25, 0x00	; 0
    229a:	82 95       	swap	r24
    229c:	92 95       	swap	r25
    229e:	90 7f       	andi	r25, 0xF0	; 240
    22a0:	98 27       	eor	r25, r24
    22a2:	80 7f       	andi	r24, 0xF0	; 240
    22a4:	98 27       	eor	r25, r24
    22a6:	28 2f       	mov	r18, r24

uint8_t mac_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    22a8:	08 b9       	out	0x08, r16	; 8
  _NOP();
    22aa:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    22ac:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    22ae:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    22b0:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    22b2:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    22b4:	18 b9       	out	0x08, r17	; 8
  _NOP();
    22b6:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    22b8:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    22ba:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    22bc:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    22be:	00 00       	nop

// Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    22c0:	ae e0       	ldi	r26, 0x0E	; 14
    22c2:	36 95       	lsr	r19
    22c4:	27 95       	ror	r18
    22c6:	17 95       	ror	r17
    22c8:	07 95       	ror	r16
    22ca:	aa 95       	dec	r26
    22cc:	d1 f7       	brne	.-12     	; 0x22c2 <mac_read_softwareID+0x46>
    22ce:	05 b9       	out	0x05, r16	; 5
  _NOP();
    22d0:	00 00       	nop
  _NOP();
    22d2:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    22d4:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    22d6:	00 00       	nop
  _NOP();
    22d8:	00 00       	nop

  // Set the data byte for the rising edge
  MEMORY_DATA_PORT = writeData;
    22da:	2a ea       	ldi	r18, 0xAA	; 170
    22dc:	28 b9       	out	0x08, r18	; 8
  _NOP();
    22de:	00 00       	nop
  _NOP();
    22e0:	00 00       	nop
  _NOP();
    22e2:	00 00       	nop
  
  MAC_WE_PORT &= ~(1 << MAC_WE);
    22e4:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    22e6:	00 00       	nop
  _NOP();
    22e8:	00 00       	nop
  _NOP();
    22ea:	00 00       	nop

  MAC_WE_PORT |= (1 << MAC_WE);
    22ec:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    22ee:	00 00       	nop
  _NOP();
    22f0:	00 00       	nop
  _NOP();
    22f2:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    22f4:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    22f6:	00 00       	nop
  _NOP();
    22f8:	00 00       	nop
  _NOP();
    22fa:	00 00       	nop
  address.address32 = 0xAAA;
  address.address8[2] |= (chipNum << 4);
  mac_flash_write_sub_byte(address, 0xAA);

  // Now 0x555,0x55
  address.address32 = 0x555;
    22fc:	05 e5       	ldi	r16, 0x55	; 85
    22fe:	15 e0       	ldi	r17, 0x05	; 5
    2300:	20 e0       	ldi	r18, 0x00	; 0
    2302:	30 e0       	ldi	r19, 0x00	; 0
  address.address8[2] |= (chipNum << 4);
    2304:	28 2f       	mov	r18, r24

uint8_t mac_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2306:	08 b9       	out	0x08, r16	; 8
  _NOP();
    2308:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    230a:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    230c:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    230e:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2310:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2312:	18 b9       	out	0x08, r17	; 8
  _NOP();
    2314:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2316:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2318:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    231a:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    231c:	00 00       	nop

// Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    231e:	fe e0       	ldi	r31, 0x0E	; 14
    2320:	36 95       	lsr	r19
    2322:	27 95       	ror	r18
    2324:	17 95       	ror	r17
    2326:	07 95       	ror	r16
    2328:	fa 95       	dec	r31
    232a:	d1 f7       	brne	.-12     	; 0x2320 <mac_read_softwareID+0xa4>
    232c:	05 b9       	out	0x05, r16	; 5
  _NOP();
    232e:	00 00       	nop
  _NOP();
    2330:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2332:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2334:	00 00       	nop
  _NOP();
    2336:	00 00       	nop

  // Set the data byte for the rising edge
  MEMORY_DATA_PORT = writeData;
    2338:	25 e5       	ldi	r18, 0x55	; 85
    233a:	28 b9       	out	0x08, r18	; 8
  _NOP();
    233c:	00 00       	nop
  _NOP();
    233e:	00 00       	nop
  _NOP();
    2340:	00 00       	nop
  
  MAC_WE_PORT &= ~(1 << MAC_WE);
    2342:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    2344:	00 00       	nop
  _NOP();
    2346:	00 00       	nop
  _NOP();
    2348:	00 00       	nop

  MAC_WE_PORT |= (1 << MAC_WE);
    234a:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    234c:	00 00       	nop
  _NOP();
    234e:	00 00       	nop
  _NOP();
    2350:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    2352:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    2354:	00 00       	nop
  _NOP();
    2356:	00 00       	nop
  _NOP();
    2358:	00 00       	nop
  address.address32 = 0x555;
  address.address8[2] |= (chipNum << 4);
  mac_flash_write_sub_byte(address, 0x55);

  // Now 0xAAA again
  address.address32 = 0xAAA;
    235a:	0a ea       	ldi	r16, 0xAA	; 170
    235c:	1a e0       	ldi	r17, 0x0A	; 10
    235e:	20 e0       	ldi	r18, 0x00	; 0
    2360:	30 e0       	ldi	r19, 0x00	; 0
  address.address8[2] |= (chipNum << 4);
    2362:	28 2f       	mov	r18, r24

uint8_t mac_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2364:	08 b9       	out	0x08, r16	; 8
  _NOP();
    2366:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2368:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    236a:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    236c:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    236e:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2370:	18 b9       	out	0x08, r17	; 8
  _NOP();
    2372:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2374:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2376:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2378:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    237a:	00 00       	nop

// Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    237c:	ee e0       	ldi	r30, 0x0E	; 14
    237e:	36 95       	lsr	r19
    2380:	27 95       	ror	r18
    2382:	17 95       	ror	r17
    2384:	07 95       	ror	r16
    2386:	ea 95       	dec	r30
    2388:	d1 f7       	brne	.-12     	; 0x237e <mac_read_softwareID+0x102>
    238a:	05 b9       	out	0x05, r16	; 5
  _NOP();
    238c:	00 00       	nop
  _NOP();
    238e:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2390:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2392:	00 00       	nop
  _NOP();
    2394:	00 00       	nop

  // Set the data byte for the rising edge
  MEMORY_DATA_PORT = writeData;
    2396:	80 e9       	ldi	r24, 0x90	; 144
    2398:	88 b9       	out	0x08, r24	; 8
  _NOP();
    239a:	00 00       	nop
  _NOP();
    239c:	00 00       	nop
  _NOP();
    239e:	00 00       	nop
  
  MAC_WE_PORT &= ~(1 << MAC_WE);
    23a0:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    23a2:	00 00       	nop
  _NOP();
    23a4:	00 00       	nop
  _NOP();
    23a6:	00 00       	nop

  MAC_WE_PORT |= (1 << MAC_WE);
    23a8:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    23aa:	00 00       	nop
  _NOP();
    23ac:	00 00       	nop
  _NOP();
    23ae:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    23b0:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    23b2:	00 00       	nop
  _NOP();
    23b4:	00 00       	nop
  _NOP();
    23b6:	00 00       	nop

  // Put the chip into ID mode. We'll use the /WE control method

  MAC_CS_PORT &= ~(1 << MAC_CS);
  mac_flash_command_sequence(chipNum, MAC_CMDMODE_ID_READ);
  MAC_CS_PORT |= (1 << MAC_CS);
    23b8:	5f 9a       	sbi	0x0b, 7	; 11

uint8_t mac_flash_read_byte(FLASHADDR address, uint8_t *returnData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    23ba:	48 b9       	out	0x08, r20	; 8
  _NOP();
    23bc:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    23be:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    23c0:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    23c2:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    23c4:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    23c6:	58 b9       	out	0x08, r21	; 8
  _NOP();
    23c8:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    23ca:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    23cc:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    23ce:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    23d0:	00 00       	nop

  // Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    23d2:	8a 01       	movw	r16, r20
    23d4:	9b 01       	movw	r18, r22
    23d6:	6e e0       	ldi	r22, 0x0E	; 14
    23d8:	36 95       	lsr	r19
    23da:	27 95       	ror	r18
    23dc:	17 95       	ror	r17
    23de:	07 95       	ror	r16
    23e0:	6a 95       	dec	r22
    23e2:	d1 f7       	brne	.-12     	; 0x23d8 <mac_read_softwareID+0x15c>
    23e4:	05 b9       	out	0x05, r16	; 5
  _NOP();
    23e6:	00 00       	nop

  // Set read mode by pulling OE and CS low, after making data pins an input!
  MEMORY_DATA_DDR = 0x00; // Make data lines an input
    23e8:	17 b8       	out	0x07, r1	; 7
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    23ea:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    23ec:	00 00       	nop
  MAC_CS_PORT &= ~(1 << MAC_CS);
    23ee:	5f 98       	cbi	0x0b, 7	; 11
  MAC_OE_PORT &= ~(1 << MAC_OE);
    23f0:	5c 98       	cbi	0x0b, 4	; 11
	...
  _NOP();
  _NOP();
  _NOP();

  // Read the data in!
  *returnData = MEMORY_DATA_PIN;
    23fa:	86 b1       	in	r24, 0x06	; 6

  // Pull OE and CS up again, and make PORTB outputs again
  MAC_OE_PORT |= (1 << MAC_OE);
    23fc:	5c 9a       	sbi	0x0b, 4	; 11
  MAC_CS_PORT |= (1 << MAC_CS);
    23fe:	5f 9a       	sbi	0x0b, 7	; 11
  LATCH_OE_PORT |= (1 << LATCH_OE);
    2400:	15 9a       	sbi	0x02, 5	; 2
  MEMORY_DATA_DDR = 0xFF;
    2402:	9f ef       	ldi	r25, 0xFF	; 255
    2404:	97 b9       	out	0x07, r25	; 7

  mac_flash_read_byte(address, &chipID);

  // Exit ID mode. We'll use the /WE control method

  MAC_CS_PORT &= ~(1 << MAC_CS);
    2406:	5f 98       	cbi	0x0b, 7	; 11

uint8_t mac_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2408:	48 b9       	out	0x08, r20	; 8
  _NOP();
    240a:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    240c:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    240e:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2410:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2412:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2414:	58 b9       	out	0x08, r21	; 8
  _NOP();
    2416:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2418:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    241a:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    241c:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    241e:	00 00       	nop

// Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2420:	05 b9       	out	0x05, r16	; 5
  _NOP();
    2422:	00 00       	nop
  _NOP();
    2424:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2426:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2428:	00 00       	nop
  _NOP();
    242a:	00 00       	nop

  // Set the data byte for the rising edge
  MEMORY_DATA_PORT = writeData;
    242c:	90 ef       	ldi	r25, 0xF0	; 240
    242e:	98 b9       	out	0x08, r25	; 8
  _NOP();
    2430:	00 00       	nop
  _NOP();
    2432:	00 00       	nop
  _NOP();
    2434:	00 00       	nop
  
  MAC_WE_PORT &= ~(1 << MAC_WE);
    2436:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    2438:	00 00       	nop
  _NOP();
    243a:	00 00       	nop
  _NOP();
    243c:	00 00       	nop

  MAC_WE_PORT |= (1 << MAC_WE);
    243e:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    2440:	00 00       	nop
  _NOP();
    2442:	00 00       	nop
  _NOP();
    2444:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    2446:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    2448:	00 00       	nop
  _NOP();
    244a:	00 00       	nop
  _NOP();
    244c:	00 00       	nop

  MAC_CS_PORT &= ~(1 << MAC_CS);
  //mac_flash_reset_mode(chipID);
  //mac_flash_command_sequence(chipNum, MAC_CMDMODE_MODE_RESET);
  mac_flash_write_sub_byte(address, MAC_CMDMODE_MODE_RESET);
  MAC_CS_PORT |= (1 << MAC_CS);
    244e:	5f 9a       	sbi	0x0b, 7	; 11

  return chipID;
}
    2450:	1f 91       	pop	r17
    2452:	0f 91       	pop	r16
    2454:	08 95       	ret

00002456 <mac_flash_write_byte>:
  MEMORY_DATA_DDR = 0xFF;

  return 0;
}

uint8_t mac_flash_write_byte(FLASHADDR address, uint8_t writeData) {
    2456:	df 93       	push	r29
    2458:	cf 93       	push	r28
    245a:	00 d0       	rcall	.+0      	; 0x245c <mac_flash_write_byte+0x6>
    245c:	00 d0       	rcall	.+0      	; 0x245e <mac_flash_write_byte+0x8>
    245e:	cd b7       	in	r28, 0x3d	; 61
    2460:	de b7       	in	r29, 0x3e	; 62
    2462:	69 83       	std	Y+1, r22	; 0x01
    2464:	7a 83       	std	Y+2, r23	; 0x02
    2466:	8b 83       	std	Y+3, r24	; 0x03
    2468:	9c 83       	std	Y+4, r25	; 0x04

  // Select the correct chip  & put the chip into write mode. We'll use the /WE control method
//  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
//  _NOP();
  MAC_CS_PORT &= ~(1 << MAC_CS);
    246a:	5f 98       	cbi	0x0b, 7	; 11

  mac_flash_command_sequence((address.address8[2] >> 4), MAC_CMDMODE_BYTE);
    246c:	2b 81       	ldd	r18, Y+3	; 0x03
    246e:	22 95       	swap	r18
    2470:	2f 70       	andi	r18, 0x0F	; 15

static void mac_flash_command_sequence(uint8_t chipNum, uint8_t mode) {

  FLASHADDR address;
  // First 0xAAA, 0xAA
  address.address32 = 0xAAA;
    2472:	8a ea       	ldi	r24, 0xAA	; 170
    2474:	9a e0       	ldi	r25, 0x0A	; 10
    2476:	a0 e0       	ldi	r26, 0x00	; 0
    2478:	b0 e0       	ldi	r27, 0x00	; 0
  address.address8[2] |= (chipNum << 4);
    247a:	30 e0       	ldi	r19, 0x00	; 0
    247c:	22 95       	swap	r18
    247e:	32 95       	swap	r19
    2480:	30 7f       	andi	r19, 0xF0	; 240
    2482:	32 27       	eor	r19, r18
    2484:	20 7f       	andi	r18, 0xF0	; 240
    2486:	32 27       	eor	r19, r18
    2488:	a2 2f       	mov	r26, r18

uint8_t mac_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    248a:	88 b9       	out	0x08, r24	; 8
  _NOP();
    248c:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    248e:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2490:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2492:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2494:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2496:	98 b9       	out	0x08, r25	; 8
  _NOP();
    2498:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    249a:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    249c:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    249e:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    24a0:	00 00       	nop

// Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    24a2:	ee e0       	ldi	r30, 0x0E	; 14
    24a4:	b6 95       	lsr	r27
    24a6:	a7 95       	ror	r26
    24a8:	97 95       	ror	r25
    24aa:	87 95       	ror	r24
    24ac:	ea 95       	dec	r30
    24ae:	d1 f7       	brne	.-12     	; 0x24a4 <mac_flash_write_byte+0x4e>
    24b0:	85 b9       	out	0x05, r24	; 5
  _NOP();
    24b2:	00 00       	nop
  _NOP();
    24b4:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    24b6:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    24b8:	00 00       	nop
  _NOP();
    24ba:	00 00       	nop

  // Set the data byte for the rising edge
  MEMORY_DATA_PORT = writeData;
    24bc:	8a ea       	ldi	r24, 0xAA	; 170
    24be:	88 b9       	out	0x08, r24	; 8
  _NOP();
    24c0:	00 00       	nop
  _NOP();
    24c2:	00 00       	nop
  _NOP();
    24c4:	00 00       	nop
  
  MAC_WE_PORT &= ~(1 << MAC_WE);
    24c6:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    24c8:	00 00       	nop
  _NOP();
    24ca:	00 00       	nop
  _NOP();
    24cc:	00 00       	nop

  MAC_WE_PORT |= (1 << MAC_WE);
    24ce:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    24d0:	00 00       	nop
  _NOP();
    24d2:	00 00       	nop
  _NOP();
    24d4:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    24d6:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    24d8:	00 00       	nop
  _NOP();
    24da:	00 00       	nop
  _NOP();
    24dc:	00 00       	nop
  address.address32 = 0xAAA;
  address.address8[2] |= (chipNum << 4);
  mac_flash_write_sub_byte(address, 0xAA);

  // Now 0x555,0x55
  address.address32 = 0x555;
    24de:	85 e5       	ldi	r24, 0x55	; 85
    24e0:	95 e0       	ldi	r25, 0x05	; 5
    24e2:	a0 e0       	ldi	r26, 0x00	; 0
    24e4:	b0 e0       	ldi	r27, 0x00	; 0
  address.address8[2] |= (chipNum << 4);
    24e6:	a2 2f       	mov	r26, r18

uint8_t mac_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    24e8:	88 b9       	out	0x08, r24	; 8
  _NOP();
    24ea:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    24ec:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    24ee:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    24f0:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    24f2:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    24f4:	98 b9       	out	0x08, r25	; 8
  _NOP();
    24f6:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    24f8:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    24fa:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    24fc:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    24fe:	00 00       	nop

// Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2500:	7e e0       	ldi	r23, 0x0E	; 14
    2502:	b6 95       	lsr	r27
    2504:	a7 95       	ror	r26
    2506:	97 95       	ror	r25
    2508:	87 95       	ror	r24
    250a:	7a 95       	dec	r23
    250c:	d1 f7       	brne	.-12     	; 0x2502 <mac_flash_write_byte+0xac>
    250e:	85 b9       	out	0x05, r24	; 5
  _NOP();
    2510:	00 00       	nop
  _NOP();
    2512:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2514:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2516:	00 00       	nop
  _NOP();
    2518:	00 00       	nop

  // Set the data byte for the rising edge
  MEMORY_DATA_PORT = writeData;
    251a:	85 e5       	ldi	r24, 0x55	; 85
    251c:	88 b9       	out	0x08, r24	; 8
  _NOP();
    251e:	00 00       	nop
  _NOP();
    2520:	00 00       	nop
  _NOP();
    2522:	00 00       	nop
  
  MAC_WE_PORT &= ~(1 << MAC_WE);
    2524:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    2526:	00 00       	nop
  _NOP();
    2528:	00 00       	nop
  _NOP();
    252a:	00 00       	nop

  MAC_WE_PORT |= (1 << MAC_WE);
    252c:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    252e:	00 00       	nop
  _NOP();
    2530:	00 00       	nop
  _NOP();
    2532:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    2534:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    2536:	00 00       	nop
  _NOP();
    2538:	00 00       	nop
  _NOP();
    253a:	00 00       	nop
  address.address32 = 0x555;
  address.address8[2] |= (chipNum << 4);
  mac_flash_write_sub_byte(address, 0x55);

  // Now 0xAAA again
  address.address32 = 0xAAA;
    253c:	8a ea       	ldi	r24, 0xAA	; 170
    253e:	9a e0       	ldi	r25, 0x0A	; 10
    2540:	a0 e0       	ldi	r26, 0x00	; 0
    2542:	b0 e0       	ldi	r27, 0x00	; 0
  address.address8[2] |= (chipNum << 4);
    2544:	a2 2f       	mov	r26, r18

uint8_t mac_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2546:	88 b9       	out	0x08, r24	; 8
  _NOP();
    2548:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    254a:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    254c:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    254e:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2550:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2552:	98 b9       	out	0x08, r25	; 8
  _NOP();
    2554:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2556:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2558:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    255a:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    255c:	00 00       	nop

// Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    255e:	6e e0       	ldi	r22, 0x0E	; 14
    2560:	b6 95       	lsr	r27
    2562:	a7 95       	ror	r26
    2564:	97 95       	ror	r25
    2566:	87 95       	ror	r24
    2568:	6a 95       	dec	r22
    256a:	d1 f7       	brne	.-12     	; 0x2560 <mac_flash_write_byte+0x10a>
    256c:	85 b9       	out	0x05, r24	; 5
  _NOP();
    256e:	00 00       	nop
  _NOP();
    2570:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2572:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2574:	00 00       	nop
  _NOP();
    2576:	00 00       	nop

  // Set the data byte for the rising edge
  MEMORY_DATA_PORT = writeData;
    2578:	80 ea       	ldi	r24, 0xA0	; 160
    257a:	88 b9       	out	0x08, r24	; 8
  _NOP();
    257c:	00 00       	nop
  _NOP();
    257e:	00 00       	nop
  _NOP();
    2580:	00 00       	nop
  
  MAC_WE_PORT &= ~(1 << MAC_WE);
    2582:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    2584:	00 00       	nop
  _NOP();
    2586:	00 00       	nop
  _NOP();
    2588:	00 00       	nop

  MAC_WE_PORT |= (1 << MAC_WE);
    258a:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    258c:	00 00       	nop
  _NOP();
    258e:	00 00       	nop
  _NOP();
    2590:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    2592:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    2594:	00 00       	nop
  _NOP();
    2596:	00 00       	nop
  _NOP();
    2598:	00 00       	nop
  MAC_CS_PORT &= ~(1 << MAC_CS);

  mac_flash_command_sequence((address.address8[2] >> 4), MAC_CMDMODE_BYTE);

  // Now finally! The data!
  mac_flash_write_sub_byte(address, writeData);
    259a:	89 81       	ldd	r24, Y+1	; 0x01
    259c:	9a 81       	ldd	r25, Y+2	; 0x02
    259e:	ab 81       	ldd	r26, Y+3	; 0x03
    25a0:	bc 81       	ldd	r27, Y+4	; 0x04

uint8_t mac_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    25a2:	88 b9       	out	0x08, r24	; 8
  _NOP();
    25a4:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    25a6:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    25a8:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    25aa:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    25ac:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    25ae:	98 b9       	out	0x08, r25	; 8
  _NOP();
    25b0:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    25b2:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    25b4:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    25b6:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    25b8:	00 00       	nop

// Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    25ba:	5e e0       	ldi	r21, 0x0E	; 14
    25bc:	b6 95       	lsr	r27
    25be:	a7 95       	ror	r26
    25c0:	97 95       	ror	r25
    25c2:	87 95       	ror	r24
    25c4:	5a 95       	dec	r21
    25c6:	d1 f7       	brne	.-12     	; 0x25bc <mac_flash_write_byte+0x166>
    25c8:	85 b9       	out	0x05, r24	; 5
  _NOP();
    25ca:	00 00       	nop
  _NOP();
    25cc:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    25ce:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    25d0:	00 00       	nop
  _NOP();
    25d2:	00 00       	nop

  // Set the data byte for the rising edge
  MEMORY_DATA_PORT = writeData;
    25d4:	48 b9       	out	0x08, r20	; 8
  _NOP();
    25d6:	00 00       	nop
  _NOP();
    25d8:	00 00       	nop
  _NOP();
    25da:	00 00       	nop
  
  MAC_WE_PORT &= ~(1 << MAC_WE);
    25dc:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    25de:	00 00       	nop
  _NOP();
    25e0:	00 00       	nop
  _NOP();
    25e2:	00 00       	nop

  MAC_WE_PORT |= (1 << MAC_WE);
    25e4:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    25e6:	00 00       	nop
  _NOP();
    25e8:	00 00       	nop
  _NOP();
    25ea:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    25ec:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    25ee:	00 00       	nop
  _NOP();
    25f0:	00 00       	nop
  _NOP();
    25f2:	00 00       	nop

  // Now finally! The data!
  mac_flash_write_sub_byte(address, writeData);

  // Move to #DATA polling by pulling CS high again
  MAC_CS_PORT |= (1 << MAC_CS);
    25f4:	5f 9a       	sbi	0x0b, 7	; 11
    25f6:	50 e0       	ldi	r21, 0x00	; 0
    25f8:	40 95       	com	r20
    25fa:	50 95       	com	r21

  // Pull OE and CS up again, and make PORTB outputs again
  MAC_OE_PORT |= (1 << MAC_OE);
  MAC_CS_PORT |= (1 << MAC_CS);
  LATCH_OE_PORT |= (1 << LATCH_OE);
  MEMORY_DATA_DDR = 0xFF;
    25fc:	6f ef       	ldi	r22, 0xFF	; 255
  MAC_CS_PORT |= (1 << MAC_CS);

  // #DATA polling, as per P37 of datasheet
  do {
    uint8_t i;
    mac_flash_read_byte(address, &i);
    25fe:	89 81       	ldd	r24, Y+1	; 0x01
    2600:	9a 81       	ldd	r25, Y+2	; 0x02
    2602:	ab 81       	ldd	r26, Y+3	; 0x03
    2604:	bc 81       	ldd	r27, Y+4	; 0x04

uint8_t mac_flash_read_byte(FLASHADDR address, uint8_t *returnData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2606:	88 b9       	out	0x08, r24	; 8
  _NOP();
    2608:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    260a:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    260c:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    260e:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2610:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2612:	98 b9       	out	0x08, r25	; 8
  _NOP();
    2614:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2616:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2618:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    261a:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    261c:	00 00       	nop

  // Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    261e:	3e e0       	ldi	r19, 0x0E	; 14
    2620:	b6 95       	lsr	r27
    2622:	a7 95       	ror	r26
    2624:	97 95       	ror	r25
    2626:	87 95       	ror	r24
    2628:	3a 95       	dec	r19
    262a:	d1 f7       	brne	.-12     	; 0x2620 <mac_flash_write_byte+0x1ca>
    262c:	85 b9       	out	0x05, r24	; 5
  _NOP();
    262e:	00 00       	nop

  // Set read mode by pulling OE and CS low, after making data pins an input!
  MEMORY_DATA_DDR = 0x00; // Make data lines an input
    2630:	17 b8       	out	0x07, r1	; 7
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2632:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2634:	00 00       	nop
  MAC_CS_PORT &= ~(1 << MAC_CS);
    2636:	5f 98       	cbi	0x0b, 7	; 11
  MAC_OE_PORT &= ~(1 << MAC_OE);
    2638:	5c 98       	cbi	0x0b, 4	; 11
	...
  _NOP();
  _NOP();
  _NOP();

  // Read the data in!
  *returnData = MEMORY_DATA_PIN;
    2642:	86 b1       	in	r24, 0x06	; 6

  // Pull OE and CS up again, and make PORTB outputs again
  MAC_OE_PORT |= (1 << MAC_OE);
    2644:	5c 9a       	sbi	0x0b, 4	; 11
  MAC_CS_PORT |= (1 << MAC_CS);
    2646:	5f 9a       	sbi	0x0b, 7	; 11
  LATCH_OE_PORT |= (1 << LATCH_OE);
    2648:	15 9a       	sbi	0x02, 5	; 2
  MEMORY_DATA_DDR = 0xFF;
    264a:	67 b9       	out	0x07, r22	; 7
  // #DATA polling, as per P37 of datasheet
  do {
    uint8_t i;
    mac_flash_read_byte(address, &i);

    if((i & 0x80) != ((~writeData) & 0x80)) {
    264c:	28 2f       	mov	r18, r24
    264e:	30 e0       	ldi	r19, 0x00	; 0
    2650:	ca 01       	movw	r24, r20
    2652:	82 27       	eor	r24, r18
    2654:	93 27       	eor	r25, r19
    2656:	87 fd       	sbrc	r24, 7
    2658:	2a c0       	rjmp	.+84     	; 0x26ae <mac_flash_write_byte+0x258>
      break;
    }

    if((i & 0x20) != 0x20) {
    265a:	25 ff       	sbrs	r18, 5
    265c:	d0 cf       	rjmp	.-96     	; 0x25fe <mac_flash_write_byte+0x1a8>
      continue;
    }

    mac_flash_read_byte(address, &i);
    265e:	89 81       	ldd	r24, Y+1	; 0x01
    2660:	9a 81       	ldd	r25, Y+2	; 0x02
    2662:	ab 81       	ldd	r26, Y+3	; 0x03
    2664:	bc 81       	ldd	r27, Y+4	; 0x04

uint8_t mac_flash_read_byte(FLASHADDR address, uint8_t *returnData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2666:	88 b9       	out	0x08, r24	; 8
  _NOP();
    2668:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    266a:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    266c:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    266e:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2670:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2672:	98 b9       	out	0x08, r25	; 8
  _NOP();
    2674:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2676:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2678:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    267a:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    267c:	00 00       	nop

  // Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    267e:	2e e0       	ldi	r18, 0x0E	; 14
    2680:	b6 95       	lsr	r27
    2682:	a7 95       	ror	r26
    2684:	97 95       	ror	r25
    2686:	87 95       	ror	r24
    2688:	2a 95       	dec	r18
    268a:	d1 f7       	brne	.-12     	; 0x2680 <mac_flash_write_byte+0x22a>
    268c:	85 b9       	out	0x05, r24	; 5
  _NOP();
    268e:	00 00       	nop

  // Set read mode by pulling OE and CS low, after making data pins an input!
  MEMORY_DATA_DDR = 0x00; // Make data lines an input
    2690:	17 b8       	out	0x07, r1	; 7
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2692:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2694:	00 00       	nop
  MAC_CS_PORT &= ~(1 << MAC_CS);
    2696:	5f 98       	cbi	0x0b, 7	; 11
  MAC_OE_PORT &= ~(1 << MAC_OE);
    2698:	5c 98       	cbi	0x0b, 4	; 11
	...
  _NOP();
  _NOP();
  _NOP();

  // Read the data in!
  *returnData = MEMORY_DATA_PIN;
    26a2:	86 b1       	in	r24, 0x06	; 6

  // Pull OE and CS up again, and make PORTB outputs again
  MAC_OE_PORT |= (1 << MAC_OE);
    26a4:	5c 9a       	sbi	0x0b, 4	; 11
  MAC_CS_PORT |= (1 << MAC_CS);
    26a6:	5f 9a       	sbi	0x0b, 7	; 11
  LATCH_OE_PORT |= (1 << LATCH_OE);
    26a8:	15 9a       	sbi	0x02, 5	; 2
  MEMORY_DATA_DDR = 0xFF;
    26aa:	8f ef       	ldi	r24, 0xFF	; 255
    26ac:	87 b9       	out	0x07, r24	; 7
    mac_flash_read_byte(address, &i);
    i &= 0x40;
  } while(i != j);*/

  return 0;
}
    26ae:	80 e0       	ldi	r24, 0x00	; 0
    26b0:	0f 90       	pop	r0
    26b2:	0f 90       	pop	r0
    26b4:	0f 90       	pop	r0
    26b6:	0f 90       	pop	r0
    26b8:	cf 91       	pop	r28
    26ba:	df 91       	pop	r29
    26bc:	08 95       	ret

000026be <mac_flash_chip_erase>:
  _NOP();

  return 0;
}

uint8_t mac_flash_chip_erase(uint8_t chipNum) {
    26be:	ef 92       	push	r14
    26c0:	ff 92       	push	r15
    26c2:	0f 93       	push	r16
    26c4:	1f 93       	push	r17
    26c6:	df 93       	push	r29
    26c8:	cf 93       	push	r28
    26ca:	00 d0       	rcall	.+0      	; 0x26cc <mac_flash_chip_erase+0xe>
    26cc:	00 d0       	rcall	.+0      	; 0x26ce <mac_flash_chip_erase+0x10>
    26ce:	cd b7       	in	r28, 0x3d	; 61
    26d0:	de b7       	in	r29, 0x3e	; 62

  // Select the correct chip  & put the chip into write mode. We'll use the /WE control method
  MAC_CS_PORT &= ~(1 << MAC_CS);
    26d2:	5f 98       	cbi	0x0b, 7	; 11

static void mac_flash_command_sequence(uint8_t chipNum, uint8_t mode) {

  FLASHADDR address;
  // First 0xAAA, 0xAA
  address.address32 = 0xAAA;
    26d4:	fa ea       	ldi	r31, 0xAA	; 170
    26d6:	ef 2e       	mov	r14, r31
    26d8:	fa e0       	ldi	r31, 0x0A	; 10
    26da:	ff 2e       	mov	r15, r31
    26dc:	01 2d       	mov	r16, r1
    26de:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 4);
    26e0:	28 2f       	mov	r18, r24
    26e2:	30 e0       	ldi	r19, 0x00	; 0
    26e4:	22 95       	swap	r18
    26e6:	32 95       	swap	r19
    26e8:	30 7f       	andi	r19, 0xF0	; 240
    26ea:	32 27       	eor	r19, r18
    26ec:	20 7f       	andi	r18, 0xF0	; 240
    26ee:	32 27       	eor	r19, r18
    26f0:	02 2f       	mov	r16, r18

uint8_t mac_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    26f2:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    26f4:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    26f6:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    26f8:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    26fa:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    26fc:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    26fe:	f8 b8       	out	0x08, r15	; 8
  _NOP();
    2700:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2702:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2704:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2706:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    2708:	00 00       	nop

// Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    270a:	7e e0       	ldi	r23, 0x0E	; 14
    270c:	16 95       	lsr	r17
    270e:	07 95       	ror	r16
    2710:	f7 94       	ror	r15
    2712:	e7 94       	ror	r14
    2714:	7a 95       	dec	r23
    2716:	d1 f7       	brne	.-12     	; 0x270c <mac_flash_chip_erase+0x4e>
    2718:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    271a:	00 00       	nop
  _NOP();
    271c:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    271e:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2720:	00 00       	nop
  _NOP();
    2722:	00 00       	nop

  // Set the data byte for the rising edge
  MEMORY_DATA_PORT = writeData;
    2724:	4a ea       	ldi	r20, 0xAA	; 170
    2726:	48 b9       	out	0x08, r20	; 8
  _NOP();
    2728:	00 00       	nop
  _NOP();
    272a:	00 00       	nop
  _NOP();
    272c:	00 00       	nop
  
  MAC_WE_PORT &= ~(1 << MAC_WE);
    272e:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    2730:	00 00       	nop
  _NOP();
    2732:	00 00       	nop
  _NOP();
    2734:	00 00       	nop

  MAC_WE_PORT |= (1 << MAC_WE);
    2736:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    2738:	00 00       	nop
  _NOP();
    273a:	00 00       	nop
  _NOP();
    273c:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    273e:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    2740:	00 00       	nop
  _NOP();
    2742:	00 00       	nop
  _NOP();
    2744:	00 00       	nop
  address.address32 = 0xAAA;
  address.address8[2] |= (chipNum << 4);
  mac_flash_write_sub_byte(address, 0xAA);

  // Now 0x555,0x55
  address.address32 = 0x555;
    2746:	65 e5       	ldi	r22, 0x55	; 85
    2748:	e6 2e       	mov	r14, r22
    274a:	65 e0       	ldi	r22, 0x05	; 5
    274c:	f6 2e       	mov	r15, r22
    274e:	01 2d       	mov	r16, r1
    2750:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 4);
    2752:	02 2f       	mov	r16, r18

uint8_t mac_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2754:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    2756:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2758:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    275a:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    275c:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    275e:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2760:	f8 b8       	out	0x08, r15	; 8
  _NOP();
    2762:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2764:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2766:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2768:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    276a:	00 00       	nop

// Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    276c:	5e e0       	ldi	r21, 0x0E	; 14
    276e:	16 95       	lsr	r17
    2770:	07 95       	ror	r16
    2772:	f7 94       	ror	r15
    2774:	e7 94       	ror	r14
    2776:	5a 95       	dec	r21
    2778:	d1 f7       	brne	.-12     	; 0x276e <mac_flash_chip_erase+0xb0>
    277a:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    277c:	00 00       	nop
  _NOP();
    277e:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2780:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2782:	00 00       	nop
  _NOP();
    2784:	00 00       	nop

  // Set the data byte for the rising edge
  MEMORY_DATA_PORT = writeData;
    2786:	55 e5       	ldi	r21, 0x55	; 85
    2788:	58 b9       	out	0x08, r21	; 8
  _NOP();
    278a:	00 00       	nop
  _NOP();
    278c:	00 00       	nop
  _NOP();
    278e:	00 00       	nop
  
  MAC_WE_PORT &= ~(1 << MAC_WE);
    2790:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    2792:	00 00       	nop
  _NOP();
    2794:	00 00       	nop
  _NOP();
    2796:	00 00       	nop

  MAC_WE_PORT |= (1 << MAC_WE);
    2798:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    279a:	00 00       	nop
  _NOP();
    279c:	00 00       	nop
  _NOP();
    279e:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    27a0:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    27a2:	00 00       	nop
  _NOP();
    27a4:	00 00       	nop
  _NOP();
    27a6:	00 00       	nop
  address.address32 = 0x555;
  address.address8[2] |= (chipNum << 4);
  mac_flash_write_sub_byte(address, 0x55);

  // Now 0xAAA again
  address.address32 = 0xAAA;
    27a8:	3a ea       	ldi	r19, 0xAA	; 170
    27aa:	e3 2e       	mov	r14, r19
    27ac:	3a e0       	ldi	r19, 0x0A	; 10
    27ae:	f3 2e       	mov	r15, r19
    27b0:	01 2d       	mov	r16, r1
    27b2:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 4);
    27b4:	02 2f       	mov	r16, r18

uint8_t mac_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    27b6:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    27b8:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    27ba:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    27bc:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    27be:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    27c0:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    27c2:	f8 b8       	out	0x08, r15	; 8
  _NOP();
    27c4:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    27c6:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    27c8:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    27ca:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    27cc:	00 00       	nop

// Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    27ce:	9e e0       	ldi	r25, 0x0E	; 14
    27d0:	16 95       	lsr	r17
    27d2:	07 95       	ror	r16
    27d4:	f7 94       	ror	r15
    27d6:	e7 94       	ror	r14
    27d8:	9a 95       	dec	r25
    27da:	d1 f7       	brne	.-12     	; 0x27d0 <mac_flash_chip_erase+0x112>
    27dc:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    27de:	00 00       	nop
  _NOP();
    27e0:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    27e2:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    27e4:	00 00       	nop
  _NOP();
    27e6:	00 00       	nop

  // Set the data byte for the rising edge
  MEMORY_DATA_PORT = writeData;
    27e8:	90 e8       	ldi	r25, 0x80	; 128
    27ea:	98 b9       	out	0x08, r25	; 8
  _NOP();
    27ec:	00 00       	nop
  _NOP();
    27ee:	00 00       	nop
  _NOP();
    27f0:	00 00       	nop
  
  MAC_WE_PORT &= ~(1 << MAC_WE);
    27f2:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    27f4:	00 00       	nop
  _NOP();
    27f6:	00 00       	nop
  _NOP();
    27f8:	00 00       	nop

  MAC_WE_PORT |= (1 << MAC_WE);
    27fa:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    27fc:	00 00       	nop
  _NOP();
    27fe:	00 00       	nop
  _NOP();
    2800:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    2802:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    2804:	00 00       	nop
  _NOP();
    2806:	00 00       	nop
  _NOP();
    2808:	00 00       	nop

static void mac_flash_command_sequence(uint8_t chipNum, uint8_t mode) {

  FLASHADDR address;
  // First 0xAAA, 0xAA
  address.address32 = 0xAAA;
    280a:	ba ea       	ldi	r27, 0xAA	; 170
    280c:	eb 2e       	mov	r14, r27
    280e:	ba e0       	ldi	r27, 0x0A	; 10
    2810:	fb 2e       	mov	r15, r27
    2812:	01 2d       	mov	r16, r1
    2814:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 4);
    2816:	02 2f       	mov	r16, r18

uint8_t mac_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2818:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    281a:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    281c:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    281e:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2820:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2822:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2824:	f8 b8       	out	0x08, r15	; 8
  _NOP();
    2826:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2828:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    282a:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    282c:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    282e:	00 00       	nop

// Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2830:	ae e0       	ldi	r26, 0x0E	; 14
    2832:	16 95       	lsr	r17
    2834:	07 95       	ror	r16
    2836:	f7 94       	ror	r15
    2838:	e7 94       	ror	r14
    283a:	aa 95       	dec	r26
    283c:	d1 f7       	brne	.-12     	; 0x2832 <mac_flash_chip_erase+0x174>
    283e:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    2840:	00 00       	nop
  _NOP();
    2842:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2844:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2846:	00 00       	nop
  _NOP();
    2848:	00 00       	nop

  // Set the data byte for the rising edge
  MEMORY_DATA_PORT = writeData;
    284a:	48 b9       	out	0x08, r20	; 8
  _NOP();
    284c:	00 00       	nop
  _NOP();
    284e:	00 00       	nop
  _NOP();
    2850:	00 00       	nop
  
  MAC_WE_PORT &= ~(1 << MAC_WE);
    2852:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    2854:	00 00       	nop
  _NOP();
    2856:	00 00       	nop
  _NOP();
    2858:	00 00       	nop

  MAC_WE_PORT |= (1 << MAC_WE);
    285a:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    285c:	00 00       	nop
  _NOP();
    285e:	00 00       	nop
  _NOP();
    2860:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    2862:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    2864:	00 00       	nop
  _NOP();
    2866:	00 00       	nop
  _NOP();
    2868:	00 00       	nop
  address.address32 = 0xAAA;
  address.address8[2] |= (chipNum << 4);
  mac_flash_write_sub_byte(address, 0xAA);

  // Now 0x555,0x55
  address.address32 = 0x555;
    286a:	f5 e5       	ldi	r31, 0x55	; 85
    286c:	ef 2e       	mov	r14, r31
    286e:	f5 e0       	ldi	r31, 0x05	; 5
    2870:	ff 2e       	mov	r15, r31
    2872:	01 2d       	mov	r16, r1
    2874:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 4);
    2876:	02 2f       	mov	r16, r18

uint8_t mac_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2878:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    287a:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    287c:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    287e:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2880:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2882:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2884:	f8 b8       	out	0x08, r15	; 8
  _NOP();
    2886:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2888:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    288a:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    288c:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    288e:	00 00       	nop

// Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2890:	ee e0       	ldi	r30, 0x0E	; 14
    2892:	16 95       	lsr	r17
    2894:	07 95       	ror	r16
    2896:	f7 94       	ror	r15
    2898:	e7 94       	ror	r14
    289a:	ea 95       	dec	r30
    289c:	d1 f7       	brne	.-12     	; 0x2892 <mac_flash_chip_erase+0x1d4>
    289e:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    28a0:	00 00       	nop
  _NOP();
    28a2:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    28a4:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    28a6:	00 00       	nop
  _NOP();
    28a8:	00 00       	nop

  // Set the data byte for the rising edge
  MEMORY_DATA_PORT = writeData;
    28aa:	58 b9       	out	0x08, r21	; 8
  _NOP();
    28ac:	00 00       	nop
  _NOP();
    28ae:	00 00       	nop
  _NOP();
    28b0:	00 00       	nop
  
  MAC_WE_PORT &= ~(1 << MAC_WE);
    28b2:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    28b4:	00 00       	nop
  _NOP();
    28b6:	00 00       	nop
  _NOP();
    28b8:	00 00       	nop

  MAC_WE_PORT |= (1 << MAC_WE);
    28ba:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    28bc:	00 00       	nop
  _NOP();
    28be:	00 00       	nop
  _NOP();
    28c0:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    28c2:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    28c4:	00 00       	nop
  _NOP();
    28c6:	00 00       	nop
  _NOP();
    28c8:	00 00       	nop
  address.address32 = 0x555;
  address.address8[2] |= (chipNum << 4);
  mac_flash_write_sub_byte(address, 0x55);

  // Now 0xAAA again
  address.address32 = 0xAAA;
    28ca:	7a ea       	ldi	r23, 0xAA	; 170
    28cc:	e7 2e       	mov	r14, r23
    28ce:	7a e0       	ldi	r23, 0x0A	; 10
    28d0:	f7 2e       	mov	r15, r23
    28d2:	01 2d       	mov	r16, r1
    28d4:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 4);
    28d6:	02 2f       	mov	r16, r18

uint8_t mac_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    28d8:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    28da:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    28dc:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    28de:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    28e0:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    28e2:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    28e4:	f8 b8       	out	0x08, r15	; 8
  _NOP();
    28e6:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    28e8:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    28ea:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    28ec:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    28ee:	00 00       	nop

// Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    28f0:	6e e0       	ldi	r22, 0x0E	; 14
    28f2:	16 95       	lsr	r17
    28f4:	07 95       	ror	r16
    28f6:	f7 94       	ror	r15
    28f8:	e7 94       	ror	r14
    28fa:	6a 95       	dec	r22
    28fc:	d1 f7       	brne	.-12     	; 0x28f2 <mac_flash_chip_erase+0x234>
    28fe:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    2900:	00 00       	nop
  _NOP();
    2902:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2904:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2906:	00 00       	nop
  _NOP();
    2908:	00 00       	nop

  // Set the data byte for the rising edge
  MEMORY_DATA_PORT = writeData;
    290a:	90 e1       	ldi	r25, 0x10	; 16
    290c:	98 b9       	out	0x08, r25	; 8
  _NOP();
    290e:	00 00       	nop
  _NOP();
    2910:	00 00       	nop
  _NOP();
    2912:	00 00       	nop
  
  MAC_WE_PORT &= ~(1 << MAC_WE);
    2914:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    2916:	00 00       	nop
  _NOP();
    2918:	00 00       	nop
  _NOP();
    291a:	00 00       	nop

  MAC_WE_PORT |= (1 << MAC_WE);
    291c:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    291e:	00 00       	nop
  _NOP();
    2920:	00 00       	nop
  _NOP();
    2922:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    2924:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    2926:	00 00       	nop
  _NOP();
    2928:	00 00       	nop
  _NOP();
    292a:	00 00       	nop

  mac_flash_command_sequence(chipNum, MAC_CMDMODE_CHIP1);
  mac_flash_command_sequence(chipNum, MAC_CMDMODE_CHIP2);

  // Exit chip erase mode.
  MAC_CS_PORT |= (1 << MAC_CS);
    292c:	5f 9a       	sbi	0x0b, 7	; 11

  // Put a bit toggle check here to look for the end of the erase cycle instead of the current delay
  uint8_t i,j;
  FLASHADDR address;
  address.address8[2] = chipNum << 4;
    292e:	82 95       	swap	r24
    2930:	80 7f       	andi	r24, 0xF0	; 240
    2932:	8b 83       	std	Y+3, r24	; 0x03
  
  mac_flash_read_byte(address, &i);
    2934:	89 81       	ldd	r24, Y+1	; 0x01
    2936:	9a 81       	ldd	r25, Y+2	; 0x02
    2938:	ab 81       	ldd	r26, Y+3	; 0x03
    293a:	bc 81       	ldd	r27, Y+4	; 0x04

uint8_t mac_flash_read_byte(FLASHADDR address, uint8_t *returnData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    293c:	88 b9       	out	0x08, r24	; 8
  _NOP();
    293e:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2940:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2942:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2944:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2946:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2948:	98 b9       	out	0x08, r25	; 8
  _NOP();
    294a:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    294c:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    294e:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2950:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    2952:	00 00       	nop

  // Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2954:	5e e0       	ldi	r21, 0x0E	; 14
    2956:	b6 95       	lsr	r27
    2958:	a7 95       	ror	r26
    295a:	97 95       	ror	r25
    295c:	87 95       	ror	r24
    295e:	5a 95       	dec	r21
    2960:	d1 f7       	brne	.-12     	; 0x2956 <mac_flash_chip_erase+0x298>
    2962:	85 b9       	out	0x05, r24	; 5
  _NOP();
    2964:	00 00       	nop

  // Set read mode by pulling OE and CS low, after making data pins an input!
  MEMORY_DATA_DDR = 0x00; // Make data lines an input
    2966:	17 b8       	out	0x07, r1	; 7
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2968:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    296a:	00 00       	nop
  MAC_CS_PORT &= ~(1 << MAC_CS);
    296c:	5f 98       	cbi	0x0b, 7	; 11
  MAC_OE_PORT &= ~(1 << MAC_OE);
    296e:	5c 98       	cbi	0x0b, 4	; 11
	...
  _NOP();
  _NOP();
  _NOP();

  // Read the data in!
  *returnData = MEMORY_DATA_PIN;
    2978:	26 b1       	in	r18, 0x06	; 6

  // Pull OE and CS up again, and make PORTB outputs again
  MAC_OE_PORT |= (1 << MAC_OE);
    297a:	5c 9a       	sbi	0x0b, 4	; 11
  MAC_CS_PORT |= (1 << MAC_CS);
    297c:	5f 9a       	sbi	0x0b, 7	; 11
  LATCH_OE_PORT |= (1 << LATCH_OE);
    297e:	15 9a       	sbi	0x02, 5	; 2
  MEMORY_DATA_DDR = 0xFF;
    2980:	8f ef       	ldi	r24, 0xFF	; 255
    2982:	87 b9       	out	0x07, r24	; 7
  uint8_t i,j;
  FLASHADDR address;
  address.address8[2] = chipNum << 4;
  
  mac_flash_read_byte(address, &i);
  i &= 0x40;
    2984:	20 74       	andi	r18, 0x40	; 64

  // Pull OE and CS up again, and make PORTB outputs again
  MAC_OE_PORT |= (1 << MAC_OE);
  MAC_CS_PORT |= (1 << MAC_CS);
  LATCH_OE_PORT |= (1 << LATCH_OE);
  MEMORY_DATA_DDR = 0xFF;
    2986:	3f ef       	ldi	r19, 0xFF	; 255
    2988:	01 c0       	rjmp	.+2      	; 0x298c <mac_flash_chip_erase+0x2ce>
  i &= 0x40;
  do {
    j = i;
    mac_flash_read_byte(address, &i);
    i &= 0x40;
  } while(i != j);
    298a:	28 2f       	mov	r18, r24
  
  mac_flash_read_byte(address, &i);
  i &= 0x40;
  do {
    j = i;
    mac_flash_read_byte(address, &i);
    298c:	89 81       	ldd	r24, Y+1	; 0x01
    298e:	9a 81       	ldd	r25, Y+2	; 0x02
    2990:	ab 81       	ldd	r26, Y+3	; 0x03
    2992:	bc 81       	ldd	r27, Y+4	; 0x04

uint8_t mac_flash_read_byte(FLASHADDR address, uint8_t *returnData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2994:	88 b9       	out	0x08, r24	; 8
  _NOP();
    2996:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2998:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    299a:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    299c:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    299e:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    29a0:	98 b9       	out	0x08, r25	; 8
  _NOP();
    29a2:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    29a4:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    29a6:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    29a8:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    29aa:	00 00       	nop

  // Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    29ac:	4e e0       	ldi	r20, 0x0E	; 14
    29ae:	b6 95       	lsr	r27
    29b0:	a7 95       	ror	r26
    29b2:	97 95       	ror	r25
    29b4:	87 95       	ror	r24
    29b6:	4a 95       	dec	r20
    29b8:	d1 f7       	brne	.-12     	; 0x29ae <mac_flash_chip_erase+0x2f0>
    29ba:	85 b9       	out	0x05, r24	; 5
  _NOP();
    29bc:	00 00       	nop

  // Set read mode by pulling OE and CS low, after making data pins an input!
  MEMORY_DATA_DDR = 0x00; // Make data lines an input
    29be:	17 b8       	out	0x07, r1	; 7
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    29c0:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    29c2:	00 00       	nop
  MAC_CS_PORT &= ~(1 << MAC_CS);
    29c4:	5f 98       	cbi	0x0b, 7	; 11
  MAC_OE_PORT &= ~(1 << MAC_OE);
    29c6:	5c 98       	cbi	0x0b, 4	; 11
	...
  _NOP();
  _NOP();
  _NOP();

  // Read the data in!
  *returnData = MEMORY_DATA_PIN;
    29d0:	86 b1       	in	r24, 0x06	; 6

  // Pull OE and CS up again, and make PORTB outputs again
  MAC_OE_PORT |= (1 << MAC_OE);
    29d2:	5c 9a       	sbi	0x0b, 4	; 11
  MAC_CS_PORT |= (1 << MAC_CS);
    29d4:	5f 9a       	sbi	0x0b, 7	; 11
  LATCH_OE_PORT |= (1 << LATCH_OE);
    29d6:	15 9a       	sbi	0x02, 5	; 2
  MEMORY_DATA_DDR = 0xFF;
    29d8:	37 b9       	out	0x07, r19	; 7
  mac_flash_read_byte(address, &i);
  i &= 0x40;
  do {
    j = i;
    mac_flash_read_byte(address, &i);
    i &= 0x40;
    29da:	80 74       	andi	r24, 0x40	; 64
  } while(i != j);
    29dc:	82 17       	cp	r24, r18
    29de:	a9 f6       	brne	.-86     	; 0x298a <mac_flash_chip_erase+0x2cc>

  // Do this twice in case the last time was a fluke...
  mac_flash_read_byte(address, &i);
    29e0:	89 81       	ldd	r24, Y+1	; 0x01
    29e2:	9a 81       	ldd	r25, Y+2	; 0x02
    29e4:	ab 81       	ldd	r26, Y+3	; 0x03
    29e6:	bc 81       	ldd	r27, Y+4	; 0x04

uint8_t mac_flash_read_byte(FLASHADDR address, uint8_t *returnData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    29e8:	88 b9       	out	0x08, r24	; 8
  _NOP();
    29ea:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    29ec:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    29ee:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    29f0:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    29f2:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    29f4:	98 b9       	out	0x08, r25	; 8
  _NOP();
    29f6:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    29f8:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    29fa:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    29fc:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    29fe:	00 00       	nop

  // Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2a00:	0e e0       	ldi	r16, 0x0E	; 14
    2a02:	b6 95       	lsr	r27
    2a04:	a7 95       	ror	r26
    2a06:	97 95       	ror	r25
    2a08:	87 95       	ror	r24
    2a0a:	0a 95       	dec	r16
    2a0c:	d1 f7       	brne	.-12     	; 0x2a02 <mac_flash_chip_erase+0x344>
    2a0e:	85 b9       	out	0x05, r24	; 5
  _NOP();
    2a10:	00 00       	nop

  // Set read mode by pulling OE and CS low, after making data pins an input!
  MEMORY_DATA_DDR = 0x00; // Make data lines an input
    2a12:	17 b8       	out	0x07, r1	; 7
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2a14:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2a16:	00 00       	nop
  MAC_CS_PORT &= ~(1 << MAC_CS);
    2a18:	5f 98       	cbi	0x0b, 7	; 11
  MAC_OE_PORT &= ~(1 << MAC_OE);
    2a1a:	5c 98       	cbi	0x0b, 4	; 11
	...
  _NOP();
  _NOP();
  _NOP();

  // Read the data in!
  *returnData = MEMORY_DATA_PIN;
    2a24:	26 b1       	in	r18, 0x06	; 6

  // Pull OE and CS up again, and make PORTB outputs again
  MAC_OE_PORT |= (1 << MAC_OE);
    2a26:	5c 9a       	sbi	0x0b, 4	; 11
  MAC_CS_PORT |= (1 << MAC_CS);
    2a28:	5f 9a       	sbi	0x0b, 7	; 11
  LATCH_OE_PORT |= (1 << LATCH_OE);
    2a2a:	15 9a       	sbi	0x02, 5	; 2
  MEMORY_DATA_DDR = 0xFF;
    2a2c:	8f ef       	ldi	r24, 0xFF	; 255
    2a2e:	87 b9       	out	0x07, r24	; 7
    i &= 0x40;
  } while(i != j);

  // Do this twice in case the last time was a fluke...
  mac_flash_read_byte(address, &i);
  i &= 0x40;
    2a30:	20 74       	andi	r18, 0x40	; 64

  // Pull OE and CS up again, and make PORTB outputs again
  MAC_OE_PORT |= (1 << MAC_OE);
  MAC_CS_PORT |= (1 << MAC_CS);
  LATCH_OE_PORT |= (1 << LATCH_OE);
  MEMORY_DATA_DDR = 0xFF;
    2a32:	3f ef       	ldi	r19, 0xFF	; 255
    2a34:	01 c0       	rjmp	.+2      	; 0x2a38 <mac_flash_chip_erase+0x37a>
  i &= 0x40;
  do {
    j = i;
    mac_flash_read_byte(address, &i);
    i &= 0x40;
  } while(i != j);
    2a36:	28 2f       	mov	r18, r24
  // Do this twice in case the last time was a fluke...
  mac_flash_read_byte(address, &i);
  i &= 0x40;
  do {
    j = i;
    mac_flash_read_byte(address, &i);
    2a38:	89 81       	ldd	r24, Y+1	; 0x01
    2a3a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a3c:	ab 81       	ldd	r26, Y+3	; 0x03
    2a3e:	bc 81       	ldd	r27, Y+4	; 0x04

uint8_t mac_flash_read_byte(FLASHADDR address, uint8_t *returnData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2a40:	88 b9       	out	0x08, r24	; 8
  _NOP();
    2a42:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2a44:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2a46:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2a48:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2a4a:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2a4c:	98 b9       	out	0x08, r25	; 8
  _NOP();
    2a4e:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2a50:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2a52:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2a54:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    2a56:	00 00       	nop

  // Address for ADDR14-21
  FLASH_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2a58:	1e e0       	ldi	r17, 0x0E	; 14
    2a5a:	b6 95       	lsr	r27
    2a5c:	a7 95       	ror	r26
    2a5e:	97 95       	ror	r25
    2a60:	87 95       	ror	r24
    2a62:	1a 95       	dec	r17
    2a64:	d1 f7       	brne	.-12     	; 0x2a5a <mac_flash_chip_erase+0x39c>
    2a66:	85 b9       	out	0x05, r24	; 5
  _NOP();
    2a68:	00 00       	nop

  // Set read mode by pulling OE and CS low, after making data pins an input!
  MEMORY_DATA_DDR = 0x00; // Make data lines an input
    2a6a:	17 b8       	out	0x07, r1	; 7
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2a6c:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2a6e:	00 00       	nop
  MAC_CS_PORT &= ~(1 << MAC_CS);
    2a70:	5f 98       	cbi	0x0b, 7	; 11
  MAC_OE_PORT &= ~(1 << MAC_OE);
    2a72:	5c 98       	cbi	0x0b, 4	; 11
	...
  _NOP();
  _NOP();
  _NOP();

  // Read the data in!
  *returnData = MEMORY_DATA_PIN;
    2a7c:	86 b1       	in	r24, 0x06	; 6

  // Pull OE and CS up again, and make PORTB outputs again
  MAC_OE_PORT |= (1 << MAC_OE);
    2a7e:	5c 9a       	sbi	0x0b, 4	; 11
  MAC_CS_PORT |= (1 << MAC_CS);
    2a80:	5f 9a       	sbi	0x0b, 7	; 11
  LATCH_OE_PORT |= (1 << LATCH_OE);
    2a82:	15 9a       	sbi	0x02, 5	; 2
  MEMORY_DATA_DDR = 0xFF;
    2a84:	37 b9       	out	0x07, r19	; 7
  mac_flash_read_byte(address, &i);
  i &= 0x40;
  do {
    j = i;
    mac_flash_read_byte(address, &i);
    i &= 0x40;
    2a86:	80 74       	andi	r24, 0x40	; 64
  } while(i != j);
    2a88:	82 17       	cp	r24, r18
    2a8a:	a9 f6       	brne	.-86     	; 0x2a36 <mac_flash_chip_erase+0x378>
//  _delay_ms(32000); // Max wait period for a whole chip erase

  return 0;
}
    2a8c:	80 e0       	ldi	r24, 0x00	; 0
    2a8e:	0f 90       	pop	r0
    2a90:	0f 90       	pop	r0
    2a92:	0f 90       	pop	r0
    2a94:	0f 90       	pop	r0
    2a96:	cf 91       	pop	r28
    2a98:	df 91       	pop	r29
    2a9a:	1f 91       	pop	r17
    2a9c:	0f 91       	pop	r16
    2a9e:	ff 90       	pop	r15
    2aa0:	ef 90       	pop	r14
    2aa2:	08 95       	ret

00002aa4 <sram_buff_send>:
    sram_write_byte(RAMaddress, buffer[i]);
  }

}

uint8_t sram_buff_send(unsigned char* buffer, uint16_t byteCnt) {
    2aa4:	ef 92       	push	r14
    2aa6:	ff 92       	push	r15
    2aa8:	0f 93       	push	r16
    2aaa:	1f 93       	push	r17
    2aac:	cf 93       	push	r28
    2aae:	df 93       	push	r29
    2ab0:	7c 01       	movw	r14, r24
    2ab2:	8b 01       	movw	r16, r22
   for(uint16_t i = 0; i<byteCnt; i++, RAMaddress++) {
    2ab4:	61 15       	cp	r22, r1
    2ab6:	71 05       	cpc	r23, r1
    2ab8:	11 f1       	breq	.+68     	; 0x2afe <sram_buff_send+0x5a>
    2aba:	c0 e0       	ldi	r28, 0x00	; 0
    2abc:	d0 e0       	ldi	r29, 0x00	; 0
     sram_read_byte(RAMaddress, &(buffer[i]));
    2abe:	b7 01       	movw	r22, r14
    2ac0:	6c 0f       	add	r22, r28
    2ac2:	7d 1f       	adc	r23, r29
    2ac4:	80 91 4e 01 	lds	r24, 0x014E
    2ac8:	90 91 4f 01 	lds	r25, 0x014F
    2acc:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <sram_read_byte>
  }

}

uint8_t sram_buff_send(unsigned char* buffer, uint16_t byteCnt) {
   for(uint16_t i = 0; i<byteCnt; i++, RAMaddress++) {
    2ad0:	21 96       	adiw	r28, 0x01	; 1
    2ad2:	80 91 4e 01 	lds	r24, 0x014E
    2ad6:	90 91 4f 01 	lds	r25, 0x014F
    2ada:	a0 91 50 01 	lds	r26, 0x0150
    2ade:	b0 91 51 01 	lds	r27, 0x0151
    2ae2:	01 96       	adiw	r24, 0x01	; 1
    2ae4:	a1 1d       	adc	r26, r1
    2ae6:	b1 1d       	adc	r27, r1
    2ae8:	80 93 4e 01 	sts	0x014E, r24
    2aec:	90 93 4f 01 	sts	0x014F, r25
    2af0:	a0 93 50 01 	sts	0x0150, r26
    2af4:	b0 93 51 01 	sts	0x0151, r27
    2af8:	c0 17       	cp	r28, r16
    2afa:	d1 07       	cpc	r29, r17
    2afc:	00 f3       	brcs	.-64     	; 0x2abe <sram_buff_send+0x1a>
     sram_read_byte(RAMaddress, &(buffer[i]));
  }
  return 0;
}
    2afe:	80 e0       	ldi	r24, 0x00	; 0
    2b00:	df 91       	pop	r29
    2b02:	cf 91       	pop	r28
    2b04:	1f 91       	pop	r17
    2b06:	0f 91       	pop	r16
    2b08:	ff 90       	pop	r15
    2b0a:	ef 90       	pop	r14
    2b0c:	08 95       	ret

00002b0e <sram_buff_receive>:
  }

  return 0;
}

void sram_buff_receive(unsigned char* buffer, uint16_t byteCnt) {
    2b0e:	ef 92       	push	r14
    2b10:	ff 92       	push	r15
    2b12:	0f 93       	push	r16
    2b14:	1f 93       	push	r17
    2b16:	cf 93       	push	r28
    2b18:	df 93       	push	r29
    2b1a:	7c 01       	movw	r14, r24
    2b1c:	8b 01       	movw	r16, r22
  for(uint16_t i = 0; i<byteCnt; i++, RAMaddress++) {
    2b1e:	61 15       	cp	r22, r1
    2b20:	71 05       	cpc	r23, r1
    2b22:	19 f1       	breq	.+70     	; 0x2b6a <sram_buff_receive+0x5c>
    2b24:	c0 e0       	ldi	r28, 0x00	; 0
    2b26:	d0 e0       	ldi	r29, 0x00	; 0
    sram_write_byte(RAMaddress, buffer[i]);
    2b28:	f7 01       	movw	r30, r14
    2b2a:	ec 0f       	add	r30, r28
    2b2c:	fd 1f       	adc	r31, r29
    2b2e:	80 91 4e 01 	lds	r24, 0x014E
    2b32:	90 91 4f 01 	lds	r25, 0x014F
    2b36:	60 81       	ld	r22, Z
    2b38:	0e 94 15 11 	call	0x222a	; 0x222a <sram_write_byte>

  return 0;
}

void sram_buff_receive(unsigned char* buffer, uint16_t byteCnt) {
  for(uint16_t i = 0; i<byteCnt; i++, RAMaddress++) {
    2b3c:	21 96       	adiw	r28, 0x01	; 1
    2b3e:	80 91 4e 01 	lds	r24, 0x014E
    2b42:	90 91 4f 01 	lds	r25, 0x014F
    2b46:	a0 91 50 01 	lds	r26, 0x0150
    2b4a:	b0 91 51 01 	lds	r27, 0x0151
    2b4e:	01 96       	adiw	r24, 0x01	; 1
    2b50:	a1 1d       	adc	r26, r1
    2b52:	b1 1d       	adc	r27, r1
    2b54:	80 93 4e 01 	sts	0x014E, r24
    2b58:	90 93 4f 01 	sts	0x014F, r25
    2b5c:	a0 93 50 01 	sts	0x0150, r26
    2b60:	b0 93 51 01 	sts	0x0151, r27
    2b64:	c0 17       	cp	r28, r16
    2b66:	d1 07       	cpc	r29, r17
    2b68:	f8 f2       	brcs	.-66     	; 0x2b28 <sram_buff_receive+0x1a>
    sram_write_byte(RAMaddress, buffer[i]);
  }

}
    2b6a:	df 91       	pop	r29
    2b6c:	cf 91       	pop	r28
    2b6e:	1f 91       	pop	r17
    2b70:	0f 91       	pop	r16
    2b72:	ff 90       	pop	r15
    2b74:	ef 90       	pop	r14
    2b76:	08 95       	ret

00002b78 <flash_buff_send>:
    FLASH_WRITE_BYTE(flashAddress, buffer[i]);
  }
}

uint8_t flash_buff_send(unsigned char* buffer, uint16_t byteCnt)
{
    2b78:	ef 92       	push	r14
    2b7a:	ff 92       	push	r15
    2b7c:	0f 93       	push	r16
    2b7e:	1f 93       	push	r17
    2b80:	cf 93       	push	r28
    2b82:	df 93       	push	r29
    2b84:	7c 01       	movw	r14, r24
    2b86:	8b 01       	movw	r16, r22
  for(uint16_t i = 0; i<byteCnt; i++, flashAddress.address32++) {
    2b88:	61 15       	cp	r22, r1
    2b8a:	71 05       	cpc	r23, r1
    2b8c:	31 f1       	breq	.+76     	; 0x2bda <flash_buff_send+0x62>
    2b8e:	c0 e0       	ldi	r28, 0x00	; 0
    2b90:	d0 e0       	ldi	r29, 0x00	; 0
     FLASH_READ_BYTE(flashAddress, &(buffer[i]));
    2b92:	60 91 61 05 	lds	r22, 0x0561
    2b96:	70 91 62 05 	lds	r23, 0x0562
    2b9a:	80 91 63 05 	lds	r24, 0x0563
    2b9e:	90 91 64 05 	lds	r25, 0x0564
    2ba2:	a7 01       	movw	r20, r14
    2ba4:	4c 0f       	add	r20, r28
    2ba6:	5d 1f       	adc	r21, r29
    2ba8:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>
  }
}

uint8_t flash_buff_send(unsigned char* buffer, uint16_t byteCnt)
{
  for(uint16_t i = 0; i<byteCnt; i++, flashAddress.address32++) {
    2bac:	21 96       	adiw	r28, 0x01	; 1
    2bae:	80 91 61 05 	lds	r24, 0x0561
    2bb2:	90 91 62 05 	lds	r25, 0x0562
    2bb6:	a0 91 63 05 	lds	r26, 0x0563
    2bba:	b0 91 64 05 	lds	r27, 0x0564
    2bbe:	01 96       	adiw	r24, 0x01	; 1
    2bc0:	a1 1d       	adc	r26, r1
    2bc2:	b1 1d       	adc	r27, r1
    2bc4:	80 93 61 05 	sts	0x0561, r24
    2bc8:	90 93 62 05 	sts	0x0562, r25
    2bcc:	a0 93 63 05 	sts	0x0563, r26
    2bd0:	b0 93 64 05 	sts	0x0564, r27
    2bd4:	c0 17       	cp	r28, r16
    2bd6:	d1 07       	cpc	r29, r17
    2bd8:	e0 f2       	brcs	.-72     	; 0x2b92 <flash_buff_send+0x1a>
     FLASH_READ_BYTE(flashAddress, &(buffer[i]));
  }

  return 0;
}
    2bda:	80 e0       	ldi	r24, 0x00	; 0
    2bdc:	df 91       	pop	r29
    2bde:	cf 91       	pop	r28
    2be0:	1f 91       	pop	r17
    2be2:	0f 91       	pop	r16
    2be4:	ff 90       	pop	r15
    2be6:	ef 90       	pop	r14
    2be8:	08 95       	ret

00002bea <flash_buff_receive>:
}

// ******************************* Buffer functions *****************************************************************

void flash_buff_receive(unsigned char* buffer, uint16_t byteCnt)
{
    2bea:	ef 92       	push	r14
    2bec:	ff 92       	push	r15
    2bee:	0f 93       	push	r16
    2bf0:	1f 93       	push	r17
    2bf2:	cf 93       	push	r28
    2bf4:	df 93       	push	r29
    2bf6:	7c 01       	movw	r14, r24
    2bf8:	8b 01       	movw	r16, r22
  for(uint16_t i = 0; i<byteCnt; i++, flashAddress.address32++) {
    2bfa:	61 15       	cp	r22, r1
    2bfc:	71 05       	cpc	r23, r1
    2bfe:	39 f1       	breq	.+78     	; 0x2c4e <flash_buff_receive+0x64>
    2c00:	c0 e0       	ldi	r28, 0x00	; 0
    2c02:	d0 e0       	ldi	r29, 0x00	; 0
    FLASH_WRITE_BYTE(flashAddress, buffer[i]);
    2c04:	60 91 61 05 	lds	r22, 0x0561
    2c08:	70 91 62 05 	lds	r23, 0x0562
    2c0c:	80 91 63 05 	lds	r24, 0x0563
    2c10:	90 91 64 05 	lds	r25, 0x0564
    2c14:	f7 01       	movw	r30, r14
    2c16:	ec 0f       	add	r30, r28
    2c18:	fd 1f       	adc	r31, r29
    2c1a:	40 81       	ld	r20, Z
    2c1c:	0e 94 2b 12 	call	0x2456	; 0x2456 <mac_flash_write_byte>

// ******************************* Buffer functions *****************************************************************

void flash_buff_receive(unsigned char* buffer, uint16_t byteCnt)
{
  for(uint16_t i = 0; i<byteCnt; i++, flashAddress.address32++) {
    2c20:	21 96       	adiw	r28, 0x01	; 1
    2c22:	80 91 61 05 	lds	r24, 0x0561
    2c26:	90 91 62 05 	lds	r25, 0x0562
    2c2a:	a0 91 63 05 	lds	r26, 0x0563
    2c2e:	b0 91 64 05 	lds	r27, 0x0564
    2c32:	01 96       	adiw	r24, 0x01	; 1
    2c34:	a1 1d       	adc	r26, r1
    2c36:	b1 1d       	adc	r27, r1
    2c38:	80 93 61 05 	sts	0x0561, r24
    2c3c:	90 93 62 05 	sts	0x0562, r25
    2c40:	a0 93 63 05 	sts	0x0563, r26
    2c44:	b0 93 64 05 	sts	0x0564, r27
    2c48:	c0 17       	cp	r28, r16
    2c4a:	d1 07       	cpc	r29, r17
    2c4c:	d8 f2       	brcs	.-74     	; 0x2c04 <flash_buff_receive+0x1a>
    FLASH_WRITE_BYTE(flashAddress, buffer[i]);
  }
}
    2c4e:	df 91       	pop	r29
    2c50:	cf 91       	pop	r28
    2c52:	1f 91       	pop	r17
    2c54:	0f 91       	pop	r16
    2c56:	ff 90       	pop	r15
    2c58:	ef 90       	pop	r14
    2c5a:	08 95       	ret

00002c5c <launch_mbc_mode>:
void launch_mbc_mode(void) {

  // Init ports first
  // Should be common inputs and outputs for all MBC modes, even if functions are different

  DDRA = (1 << PA0) | (1 << PA1) | (1 << PA3) | (1 << PA4) | (1 << PA5) | (1 << PA6) | (1 << PA7); // not PA2 because it's GB_CS
    2c5c:	8b ef       	ldi	r24, 0xFB	; 251
    2c5e:	81 b9       	out	0x01, r24	; 1
  DDRB = 0x7F; // All outputs except PB7, which is GB_A8
    2c60:	8f e7       	ldi	r24, 0x7F	; 127
    2c62:	84 b9       	out	0x04, r24	; 4
  DDRC = 0; // PORTC is the data port
    2c64:	17 b8       	out	0x07, r1	; 7
  DDRD = 0;
    2c66:	1a b8       	out	0x0a, r1	; 10

  PORTA = (1 << PA4) | (1 << PA5) | (1 << PA7); // FLASH, OE, INTRA hi. Also PA6 for LED?
    2c68:	80 eb       	ldi	r24, 0xB0	; 176
    2c6a:	82 b9       	out	0x02, r24	; 2
  PORTB = 0;
    2c6c:	15 b8       	out	0x05, r1	; 5
  PORTC = 0;
    2c6e:	18 b8       	out	0x08, r1	; 8
  PORTD = (1 << PD0) | (1 << PD1); // Set UART pins hi
    2c70:	83 e0       	ldi	r24, 0x03	; 3
    2c72:	8b b9       	out	0x0b, r24	; 11

  // Hmmm. Will need to read EEPROM first to decide which is the correct mode...
  uint8_t mode = read_MBC_mode_only();
    2c74:	0e 94 66 1f 	call	0x3ecc	; 0x3ecc <read_MBC_mode_only>

  if(mode == CART_MODE_MBC1_16M) {
    2c78:	80 34       	cpi	r24, 0x40	; 64
    2c7a:	41 f0       	breq	.+16     	; 0x2c8c <launch_mbc_mode+0x30>
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC1_16M8k();

  } else if (mode == CART_MODE_MBC1_4M) {
    2c7c:	81 34       	cpi	r24, 0x41	; 65
    2c7e:	91 f0       	breq	.+36     	; 0x2ca4 <launch_mbc_mode+0x48>
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC1_4M32k();

  } else if (mode == CART_MODE_MBC2) {
    2c80:	85 34       	cpi	r24, 0x45	; 69
    2c82:	b1 f0       	breq	.+44     	; 0x2cb0 <launch_mbc_mode+0x54>
    PRR = 0xFF; // Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC2();

  } else if (mode == CART_MODE_MBC3) {
    2c84:	83 34       	cpi	r24, 0x43	; 67
    2c86:	d1 f0       	breq	.+52     	; 0x2cbc <launch_mbc_mode+0x60>
    PRR = 0xF7;// Turn off everything except timer1! We want a pseudo RTC!
    MBC_mode_MBC3();

  } else if (mode == CART_MODE_MBC5) {
    2c88:	82 34       	cpi	r24, 0x42	; 66
    2c8a:	31 f0       	breq	.+12     	; 0x2c98 <launch_mbc_mode+0x3c>
    PRR = 0xFF; // Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC5();

  } else {
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    2c8c:	8f ef       	ldi	r24, 0xFF	; 255
    2c8e:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC1_16M8k();
    2c92:	0e 94 00 3f 	call	0x7e00	; 0x7e00 <MBC_mode_MBC1_16M8k>
    2c96:	08 95       	ret
  } else if (mode == CART_MODE_MBC3) {
    PRR = 0xF7;// Turn off everything except timer1! We want a pseudo RTC!
    MBC_mode_MBC3();

  } else if (mode == CART_MODE_MBC5) {
    PRR = 0xFF; // Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    2c98:	8f ef       	ldi	r24, 0xFF	; 255
    2c9a:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC5();
    2c9e:	0e 94 28 3f 	call	0x7e50	; 0x7e50 <MBC_mode_MBC5>
    2ca2:	08 95       	ret
  if(mode == CART_MODE_MBC1_16M) {
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC1_16M8k();

  } else if (mode == CART_MODE_MBC1_4M) {
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    2ca4:	8f ef       	ldi	r24, 0xFF	; 255
    2ca6:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC1_4M32k();
    2caa:	0e 94 14 3f 	call	0x7e28	; 0x7e28 <MBC_mode_MBC1_4M32k>
    2cae:	08 95       	ret

  } else if (mode == CART_MODE_MBC2) {
    PRR = 0xFF; // Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    2cb0:	8f ef       	ldi	r24, 0xFF	; 255
    2cb2:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC2();
    2cb6:	0e 94 72 3f 	call	0x7ee4	; 0x7ee4 <MBC_mode_MBC2>
    2cba:	08 95       	ret

  } else if (mode == CART_MODE_MBC3) {
    PRR = 0xF7;// Turn off everything except timer1! We want a pseudo RTC!
    2cbc:	87 ef       	ldi	r24, 0xF7	; 247
    2cbe:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC3();
    2cc2:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <MBC_mode_MBC3>
    2cc6:	08 95       	ret

00002cc8 <wait_for_continue>:
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    2cc8:	86 e3       	ldi	r24, 0x36	; 54
    2cca:	91 e0       	ldi	r25, 0x01	; 1
    2ccc:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    2cd0:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    2cd4:	80 32       	cpi	r24, 0x20	; 32
    2cd6:	e1 f7       	brne	.-8      	; 0x2cd0 <wait_for_continue+0x8>
}
    2cd8:	08 95       	ret

00002cda <wait_for_confirm_cancel>:

uint8_t wait_for_confirm_cancel() {
  
  char input; 
  do {
    input = usart_receive();
    2cda:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while((input != 'Y') && (input != 'N') && (input != 'y') && (input != 'n'));
    2cde:	89 35       	cpi	r24, 0x59	; 89
    2ce0:	41 f0       	breq	.+16     	; 0x2cf2 <wait_for_confirm_cancel+0x18>
    2ce2:	8e 34       	cpi	r24, 0x4E	; 78
    2ce4:	21 f0       	breq	.+8      	; 0x2cee <wait_for_confirm_cancel+0x14>
    2ce6:	89 37       	cpi	r24, 0x79	; 121
    2ce8:	21 f0       	breq	.+8      	; 0x2cf2 <wait_for_confirm_cancel+0x18>
    2cea:	8e 36       	cpi	r24, 0x6E	; 110
    2cec:	b1 f7       	brne	.-20     	; 0x2cda <wait_for_confirm_cancel>
    2cee:	81 e0       	ldi	r24, 0x01	; 1
    2cf0:	08 95       	ret
    2cf2:	80 e0       	ldi	r24, 0x00	; 0
  if((input == 'N') || (input == 'n')) {
    return 1;
  }

  return 0;
}
    2cf4:	08 95       	ret

00002cf6 <debug_option>:
  return 0;
}

void debug_option() {

  usart_transmit_str_P(PSTR("Nothing to see here!\r\n"));
    2cf6:	82 e9       	ldi	r24, 0x92	; 146
    2cf8:	91 e0       	ldi	r25, 0x01	; 1
    2cfa:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    2cfe:	86 e3       	ldi	r24, 0x36	; 54
    2d00:	91 e0       	ldi	r25, 0x01	; 1
    2d02:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    2d06:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    2d0a:	80 32       	cpi	r24, 0x20	; 32
    2d0c:	e1 f7       	brne	.-8      	; 0x2d06 <debug_option+0x10>

  _delay_ms(250);

  launch_mbc_mode();*/

}
    2d0e:	08 95       	ret

00002d10 <show_ROM_info>:
  }

  return 0;
}

uint8_t show_ROM_info() {
    2d10:	ef 92       	push	r14
    2d12:	ff 92       	push	r15
    2d14:	0f 93       	push	r16
    2d16:	1f 93       	push	r17
    2d18:	df 93       	push	r29
    2d1a:	cf 93       	push	r28
    2d1c:	cd b7       	in	r28, 0x3d	; 61
    2d1e:	de b7       	in	r29, 0x3e	; 62
    2d20:	65 97       	sbiw	r28, 0x15	; 21
    2d22:	0f b6       	in	r0, 0x3f	; 63
    2d24:	f8 94       	cli
    2d26:	de bf       	out	0x3e, r29	; 62
    2d28:	0f be       	out	0x3f, r0	; 63
    2d2a:	cd bf       	out	0x3d, r28	; 61
  
//  char dateP[12] PROGMEM = __DATE__;
  char dateP[12] = __DATE__;
    2d2c:	8e 01       	movw	r16, r28
    2d2e:	06 5f       	subi	r16, 0xF6	; 246
    2d30:	1f 4f       	sbci	r17, 0xFF	; 255
    2d32:	d8 01       	movw	r26, r16
    2d34:	e5 e1       	ldi	r30, 0x15	; 21
    2d36:	f1 e0       	ldi	r31, 0x01	; 1
    2d38:	8c e0       	ldi	r24, 0x0C	; 12
    2d3a:	01 90       	ld	r0, Z+
    2d3c:	0d 92       	st	X+, r0
    2d3e:	81 50       	subi	r24, 0x01	; 1
    2d40:	e1 f7       	brne	.-8      	; 0x2d3a <show_ROM_info+0x2a>
  char timeP[9] = __TIME__;
    2d42:	7e 01       	movw	r14, r28
    2d44:	08 94       	sec
    2d46:	e1 1c       	adc	r14, r1
    2d48:	f1 1c       	adc	r15, r1
    2d4a:	d7 01       	movw	r26, r14
    2d4c:	e1 e2       	ldi	r30, 0x21	; 33
    2d4e:	f1 e0       	ldi	r31, 0x01	; 1
    2d50:	89 e0       	ldi	r24, 0x09	; 9
    2d52:	01 90       	ld	r0, Z+
    2d54:	0d 92       	st	X+, r0
    2d56:	81 50       	subi	r24, 0x01	; 1
    2d58:	e1 f7       	brne	.-8      	; 0x2d52 <show_ROM_info+0x42>
  dateP[11] = '\0';
    2d5a:	1d 8a       	std	Y+21, r1	; 0x15
  timeP[8] = '\0';
    2d5c:	19 86       	std	Y+9, r1	; 0x09

  get_GBROM_info(&gbRomData);
    2d5e:	8b e6       	ldi	r24, 0x6B	; 107
    2d60:	95 e0       	ldi	r25, 0x05	; 5
    2d62:	0e 94 10 1c 	call	0x3820	; 0x3820 <get_GBROM_info>

  usart_transmit_str_P(PSTR("Gameboy ROM info (from flash):\r\n"));
    2d66:	82 ea       	ldi	r24, 0xA2	; 162
    2d68:	96 e0       	ldi	r25, 0x06	; 6
    2d6a:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit_str_P(PSTR("ROM name:         "));
    2d6e:	8f e8       	ldi	r24, 0x8F	; 143
    2d70:	96 e0       	ldi	r25, 0x06	; 6
    2d72:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit_str(gbRomData.name);
    2d76:	8b e6       	ldi	r24, 0x6B	; 107
    2d78:	95 e0       	ldi	r25, 0x05	; 5
    2d7a:	0e 94 00 06 	call	0xc00	; 0xc00 <usart_transmit_str>
  usart_newline();
    2d7e:	8a e0       	ldi	r24, 0x0A	; 10
    2d80:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    2d84:	8d e0       	ldi	r24, 0x0D	; 13
    2d86:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit_str_P(PSTR("ROM size:         0x"));
    2d8a:	8a e7       	ldi	r24, 0x7A	; 122
    2d8c:	96 e0       	ldi	r25, 0x06	; 6
    2d8e:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit(nibble_to_hex(gbRomData.ROMsize >> 4));
    2d92:	80 91 7c 05 	lds	r24, 0x057C
    2d96:	82 95       	swap	r24
    2d98:	8f 70       	andi	r24, 0x0F	; 15
    2d9a:	0e 94 4f 08 	call	0x109e	; 0x109e <nibble_to_hex>
    2d9e:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit(nibble_to_hex(gbRomData.ROMsize));
    2da2:	80 91 7c 05 	lds	r24, 0x057C
    2da6:	0e 94 4f 08 	call	0x109e	; 0x109e <nibble_to_hex>
    2daa:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit(' ');
    2dae:	80 e2       	ldi	r24, 0x20	; 32
    2db0:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit_int32(gbRomData.ROMsizeBytes);
    2db4:	60 91 7d 05 	lds	r22, 0x057D
    2db8:	70 91 7e 05 	lds	r23, 0x057E
    2dbc:	80 91 7f 05 	lds	r24, 0x057F
    2dc0:	90 91 80 05 	lds	r25, 0x0580
    2dc4:	0e 94 25 06 	call	0xc4a	; 0xc4a <usart_transmit_int32>
  usart_newline();
    2dc8:	8a e0       	ldi	r24, 0x0A	; 10
    2dca:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    2dce:	8d e0       	ldi	r24, 0x0D	; 13
    2dd0:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit_str_P(PSTR("SRAM size:        0x"));
    2dd4:	85 e6       	ldi	r24, 0x65	; 101
    2dd6:	96 e0       	ldi	r25, 0x06	; 6
    2dd8:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit(nibble_to_hex(gbRomData.RAMsize >> 4));
    2ddc:	80 91 81 05 	lds	r24, 0x0581
    2de0:	82 95       	swap	r24
    2de2:	8f 70       	andi	r24, 0x0F	; 15
    2de4:	0e 94 4f 08 	call	0x109e	; 0x109e <nibble_to_hex>
    2de8:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit(nibble_to_hex(gbRomData.RAMsize));
    2dec:	80 91 81 05 	lds	r24, 0x0581
    2df0:	0e 94 4f 08 	call	0x109e	; 0x109e <nibble_to_hex>
    2df4:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit(' ');
    2df8:	80 e2       	ldi	r24, 0x20	; 32
    2dfa:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit_int32(gbRomData.RAMsizeBytes);
    2dfe:	60 91 82 05 	lds	r22, 0x0582
    2e02:	70 91 83 05 	lds	r23, 0x0583
    2e06:	80 e0       	ldi	r24, 0x00	; 0
    2e08:	90 e0       	ldi	r25, 0x00	; 0
    2e0a:	0e 94 25 06 	call	0xc4a	; 0xc4a <usart_transmit_int32>
  usart_newline();
    2e0e:	8a e0       	ldi	r24, 0x0A	; 10
    2e10:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    2e14:	8d e0       	ldi	r24, 0x0D	; 13
    2e16:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit_str_P(PSTR("MBC type:         0x"));
    2e1a:	80 e5       	ldi	r24, 0x50	; 80
    2e1c:	96 e0       	ldi	r25, 0x06	; 6
    2e1e:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit(nibble_to_hex(gbRomData.MBCtype >> 4));
    2e22:	80 91 84 05 	lds	r24, 0x0584
    2e26:	82 95       	swap	r24
    2e28:	8f 70       	andi	r24, 0x0F	; 15
    2e2a:	0e 94 4f 08 	call	0x109e	; 0x109e <nibble_to_hex>
    2e2e:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit(nibble_to_hex(gbRomData.MBCtype));
    2e32:	80 91 84 05 	lds	r24, 0x0584
    2e36:	0e 94 4f 08 	call	0x109e	; 0x109e <nibble_to_hex>
    2e3a:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit(' ');
    2e3e:	80 e2       	ldi	r24, 0x20	; 32
    2e40:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit_str(gbRomData.MBCname);
    2e44:	85 e8       	ldi	r24, 0x85	; 133
    2e46:	95 e0       	ldi	r25, 0x05	; 5
    2e48:	0e 94 00 06 	call	0xc00	; 0xc00 <usart_transmit_str>
  usart_newline();
    2e4c:	8a e0       	ldi	r24, 0x0A	; 10
    2e4e:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    2e52:	8d e0       	ldi	r24, 0x0D	; 13
    2e54:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit_str_P(PSTR("CGB support?:     0x"));
    2e58:	8b e3       	ldi	r24, 0x3B	; 59
    2e5a:	96 e0       	ldi	r25, 0x06	; 6
    2e5c:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit(nibble_to_hex(gbRomData.CGBsupport >> 4));
    2e60:	80 91 9a 05 	lds	r24, 0x059A
    2e64:	82 95       	swap	r24
    2e66:	8f 70       	andi	r24, 0x0F	; 15
    2e68:	0e 94 4f 08 	call	0x109e	; 0x109e <nibble_to_hex>
    2e6c:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit(nibble_to_hex(gbRomData.CGBsupport));
    2e70:	80 91 9a 05 	lds	r24, 0x059A
    2e74:	0e 94 4f 08 	call	0x109e	; 0x109e <nibble_to_hex>
    2e78:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit(' ');
    2e7c:	80 e2       	ldi	r24, 0x20	; 32
    2e7e:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit_str(gbRomData.CGBsupportText);
    2e82:	8b e9       	ldi	r24, 0x9B	; 155
    2e84:	95 e0       	ldi	r25, 0x05	; 5
    2e86:	0e 94 00 06 	call	0xc00	; 0xc00 <usart_transmit_str>
  usart_newline();
    2e8a:	8a e0       	ldi	r24, 0x0A	; 10
    2e8c:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    2e90:	8d e0       	ldi	r24, 0x0D	; 13
    2e92:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit_str_P(PSTR("\r\nMBC mode on boot (From EEPROM)\r\n"));
    2e96:	88 e1       	ldi	r24, 0x18	; 24
    2e98:	96 e0       	ldi	r25, 0x06	; 6
    2e9a:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit_str_P(PSTR("MBC mode:         "));
    2e9e:	85 e0       	ldi	r24, 0x05	; 5
    2ea0:	96 e0       	ldi	r25, 0x06	; 6
    2ea2:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit(nibble_to_hex(eepData.MBCMode >> 4));
    2ea6:	80 91 a4 05 	lds	r24, 0x05A4
    2eaa:	82 95       	swap	r24
    2eac:	8f 70       	andi	r24, 0x0F	; 15
    2eae:	0e 94 4f 08 	call	0x109e	; 0x109e <nibble_to_hex>
    2eb2:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit(nibble_to_hex(eepData.MBCMode));
    2eb6:	80 91 a4 05 	lds	r24, 0x05A4
    2eba:	0e 94 4f 08 	call	0x109e	; 0x109e <nibble_to_hex>
    2ebe:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit(' ');
    2ec2:	80 e2       	ldi	r24, 0x20	; 32
    2ec4:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit_str(eepData.MBCName);
    2ec8:	85 ea       	ldi	r24, 0xA5	; 165
    2eca:	95 e0       	ldi	r25, 0x05	; 5
    2ecc:	0e 94 00 06 	call	0xc00	; 0xc00 <usart_transmit_str>
  usart_newline();
    2ed0:	8a e0       	ldi	r24, 0x0A	; 10
    2ed2:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    2ed6:	8d e0       	ldi	r24, 0x0D	; 13
    2ed8:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit_str_P(PSTR("\r\nFirmware rev.:    "));
    2edc:	80 ef       	ldi	r24, 0xF0	; 240
    2ede:	95 e0       	ldi	r25, 0x05	; 5
    2ee0:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit_str(timeP);
    2ee4:	c7 01       	movw	r24, r14
    2ee6:	0e 94 00 06 	call	0xc00	; 0xc00 <usart_transmit_str>
  usart_transmit(' ');
    2eea:	80 e2       	ldi	r24, 0x20	; 32
    2eec:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit_str(dateP);
    2ef0:	c8 01       	movw	r24, r16
    2ef2:	0e 94 00 06 	call	0xc00	; 0xc00 <usart_transmit_str>
  usart_newline();
    2ef6:	8a e0       	ldi	r24, 0x0A	; 10
    2ef8:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    2efc:	8d e0       	ldi	r24, 0x0D	; 13
    2efe:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    2f02:	86 e3       	ldi	r24, 0x36	; 54
    2f04:	91 e0       	ldi	r25, 0x01	; 1
    2f06:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    2f0a:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    2f0e:	80 32       	cpi	r24, 0x20	; 32
    2f10:	e1 f7       	brne	.-8      	; 0x2f0a <show_ROM_info+0x1fa>
  usart_transmit_str(dateP);
  usart_newline();

  wait_for_continue();
  return 0;
}
    2f12:	80 e0       	ldi	r24, 0x00	; 0
    2f14:	65 96       	adiw	r28, 0x15	; 21
    2f16:	0f b6       	in	r0, 0x3f	; 63
    2f18:	f8 94       	cli
    2f1a:	de bf       	out	0x3e, r29	; 62
    2f1c:	0f be       	out	0x3f, r0	; 63
    2f1e:	cd bf       	out	0x3d, r28	; 61
    2f20:	cf 91       	pop	r28
    2f22:	df 91       	pop	r29
    2f24:	1f 91       	pop	r17
    2f26:	0f 91       	pop	r16
    2f28:	ff 90       	pop	r15
    2f2a:	ef 90       	pop	r14
    2f2c:	08 95       	ret

00002f2e <flash_new_firmware>:
}

uint8_t flash_new_firmware() { 

  // Run the bootloader
  asm("jmp 0xE000");
    2f2e:	0c 94 00 70 	jmp	0xe000	; 0xe000 <MBC3_RTC_RTC_END5+0x5208>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    2f32:	86 e3       	ldi	r24, 0x36	; 54
    2f34:	91 e0       	ldi	r25, 0x01	; 1
    2f36:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    2f3a:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    2f3e:	80 32       	cpi	r24, 0x20	; 32
    2f40:	e1 f7       	brne	.-8      	; 0x2f3a <flash_new_firmware+0xc>
  // Run the bootloader
  asm("jmp 0xE000");

  wait_for_continue();
  return 0;
}
    2f42:	80 e0       	ldi	r24, 0x00	; 0
    2f44:	08 95       	ret

00002f46 <force_mbc_mode>:

uint8_t force_mbc_mode() {
    2f46:	1f 93       	push	r17

  // Show the user the menu options
  usart_transmit_str_P(PSTR("Select one of the MBC modes below:\r\n"));
    2f48:	86 e6       	ldi	r24, 0x66	; 102
    2f4a:	92 e0       	ldi	r25, 0x02	; 2
    2f4c:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit_str_P(PSTR("0 - MBC1 16Mb\r\n"));
    2f50:	86 e5       	ldi	r24, 0x56	; 86
    2f52:	92 e0       	ldi	r25, 0x02	; 2
    2f54:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit_str_P(PSTR("1 - MBC1 4Mb\r\n"));
    2f58:	87 e4       	ldi	r24, 0x47	; 71
    2f5a:	92 e0       	ldi	r25, 0x02	; 2
    2f5c:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit_str_P(PSTR("2 - MBC2\r\n"));
    2f60:	8c e3       	ldi	r24, 0x3C	; 60
    2f62:	92 e0       	ldi	r25, 0x02	; 2
    2f64:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit_str_P(PSTR("3 - MBC3\r\n"));
    2f68:	81 e3       	ldi	r24, 0x31	; 49
    2f6a:	92 e0       	ldi	r25, 0x02	; 2
    2f6c:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit_str_P(PSTR("4 - MBC5\r\n"));
    2f70:	86 e2       	ldi	r24, 0x26	; 38
    2f72:	92 e0       	ldi	r25, 0x02	; 2
    2f74:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit_str_P(PSTR("c - Cancel selection\r\n"));
    2f78:	8f e0       	ldi	r24, 0x0F	; 15
    2f7a:	92 e0       	ldi	r25, 0x02	; 2
    2f7c:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    2f80:	0f c0       	rjmp	.+30     	; 0x2fa0 <force_mbc_mode+0x5a>
  uint8_t c;

  do {
    c = usart_receive();

    if((c >= '0' && c <= '4') || (c == 'c')) {
    2f82:	13 36       	cpi	r17, 0x63	; 99
    2f84:	31 f1       	breq	.+76     	; 0x2fd2 <force_mbc_mode+0x8c>
      break;
    }

    usart_transmit_str_P(PSTR("Unknown selection:"));
    2f86:	8c ef       	ldi	r24, 0xFC	; 252
    2f88:	91 e0       	ldi	r25, 0x01	; 1
    2f8a:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    usart_transmit(c);
    2f8e:	81 2f       	mov	r24, r17
    2f90:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    usart_newline();
    2f94:	8a e0       	ldi	r24, 0x0A	; 10
    2f96:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    2f9a:	8d e0       	ldi	r24, 0x0D	; 13
    2f9c:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit_str_P(PSTR("c - Cancel selection\r\n"));

  uint8_t c;

  do {
    c = usart_receive();
    2fa0:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
    2fa4:	18 2f       	mov	r17, r24

    if((c >= '0' && c <= '4') || (c == 'c')) {
    2fa6:	80 53       	subi	r24, 0x30	; 48
    2fa8:	85 30       	cpi	r24, 0x05	; 5
    2faa:	58 f7       	brcc	.-42     	; 0x2f82 <force_mbc_mode+0x3c>
    usart_transmit(c);
    usart_newline();
  } while(1);

  // Set the new mode 
  if(c == '0') {
    2fac:	10 33       	cpi	r17, 0x30	; 48
    2fae:	99 f1       	breq	.+102    	; 0x3016 <force_mbc_mode+0xd0>
    // MBC1 or ROM only
    eepData.MBCMode = CART_MODE_MBC1_16M;
    strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
  } else if (c == '1') {
    2fb0:	11 33       	cpi	r17, 0x31	; 49
    2fb2:	09 f4       	brne	.+2      	; 0x2fb6 <force_mbc_mode+0x70>
    2fb4:	4e c0       	rjmp	.+156    	; 0x3052 <force_mbc_mode+0x10c>
    eepData.MBCMode = CART_MODE_MBC1_4M;
    strcpy_P(eepData.MBCName, PSTR("MBC1_4M "));
  } else if (c == '2') {
    2fb6:	12 33       	cpi	r17, 0x32	; 50
    2fb8:	c1 f1       	breq	.+112    	; 0x302a <force_mbc_mode+0xe4>
    eepData.MBCMode = CART_MODE_MBC2;
    strcpy_P(eepData.MBCName, PSTR("MBC2    "));
  } else if (c == '3') {
    2fba:	13 33       	cpi	r17, 0x33	; 51
    2fbc:	51 f4       	brne	.+20     	; 0x2fd2 <force_mbc_mode+0x8c>
    eepData.MBCMode = CART_MODE_MBC3;
    2fbe:	83 e4       	ldi	r24, 0x43	; 67
    2fc0:	80 93 a4 05 	sts	0x05A4, r24
    strcpy_P(eepData.MBCName, PSTR("MBC3    "));
    2fc4:	85 ea       	ldi	r24, 0xA5	; 165
    2fc6:	95 e0       	ldi	r25, 0x05	; 5
    2fc8:	68 ed       	ldi	r22, 0xD8	; 216
    2fca:	71 e0       	ldi	r23, 0x01	; 1
    2fcc:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    2fd0:	05 c0       	rjmp	.+10     	; 0x2fdc <force_mbc_mode+0x96>
  } else if (c == '4') {
    2fd2:	14 33       	cpi	r17, 0x34	; 52
    2fd4:	a1 f1       	breq	.+104    	; 0x303e <force_mbc_mode+0xf8>
    eepData.MBCMode = CART_MODE_MBC5;
    strcpy_P(eepData.MBCName, PSTR("MBC5    "));
  } else if (c == 'c') {
    2fd6:	13 36       	cpi	r17, 0x63	; 99
    2fd8:	09 f4       	brne	.+2      	; 0x2fdc <force_mbc_mode+0x96>
    2fda:	45 c0       	rjmp	.+138    	; 0x3066 <force_mbc_mode+0x120>
    usart_transmit_str_P(PSTR("Cancel selection.\r\n"));
  }

  // EEPROM WRITE CYCLE GOES HERE IF DATA IS DIFFERENT!
  write_update_gbeepromdat(&eepData);
    2fdc:	84 ea       	ldi	r24, 0xA4	; 164
    2fde:	95 e0       	ldi	r25, 0x05	; 5
    2fe0:	0e 94 a7 1f 	call	0x3f4e	; 0x3f4e <write_update_gbeepromdat>

  usart_transmit_str_P(PSTR("MBC mode is now: "));
    2fe4:	89 ea       	ldi	r24, 0xA9	; 169
    2fe6:	91 e0       	ldi	r25, 0x01	; 1
    2fe8:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit_str(eepData.MBCName);
    2fec:	85 ea       	ldi	r24, 0xA5	; 165
    2fee:	95 e0       	ldi	r25, 0x05	; 5
    2ff0:	0e 94 00 06 	call	0xc00	; 0xc00 <usart_transmit_str>
  usart_newline();
    2ff4:	8a e0       	ldi	r24, 0x0A	; 10
    2ff6:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    2ffa:	8d e0       	ldi	r24, 0x0D	; 13
    2ffc:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    3000:	86 e3       	ldi	r24, 0x36	; 54
    3002:	91 e0       	ldi	r25, 0x01	; 1
    3004:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    3008:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    300c:	80 32       	cpi	r24, 0x20	; 32
    300e:	e1 f7       	brne	.-8      	; 0x3008 <force_mbc_mode+0xc2>
  usart_transmit_str(eepData.MBCName);
  usart_newline();

  wait_for_continue();
  return 0;
}
    3010:	80 e0       	ldi	r24, 0x00	; 0
    3012:	1f 91       	pop	r17
    3014:	08 95       	ret
  } while(1);

  // Set the new mode 
  if(c == '0') {
    // MBC1 or ROM only
    eepData.MBCMode = CART_MODE_MBC1_16M;
    3016:	80 e4       	ldi	r24, 0x40	; 64
    3018:	80 93 a4 05 	sts	0x05A4, r24
    strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
    301c:	85 ea       	ldi	r24, 0xA5	; 165
    301e:	95 e0       	ldi	r25, 0x05	; 5
    3020:	63 ef       	ldi	r22, 0xF3	; 243
    3022:	71 e0       	ldi	r23, 0x01	; 1
    3024:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3028:	d9 cf       	rjmp	.-78     	; 0x2fdc <force_mbc_mode+0x96>
  } else if (c == '1') {
    eepData.MBCMode = CART_MODE_MBC1_4M;
    strcpy_P(eepData.MBCName, PSTR("MBC1_4M "));
  } else if (c == '2') {
    eepData.MBCMode = CART_MODE_MBC2;
    302a:	85 e4       	ldi	r24, 0x45	; 69
    302c:	80 93 a4 05 	sts	0x05A4, r24
    strcpy_P(eepData.MBCName, PSTR("MBC2    "));
    3030:	85 ea       	ldi	r24, 0xA5	; 165
    3032:	95 e0       	ldi	r25, 0x05	; 5
    3034:	61 ee       	ldi	r22, 0xE1	; 225
    3036:	71 e0       	ldi	r23, 0x01	; 1
    3038:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    303c:	cf cf       	rjmp	.-98     	; 0x2fdc <force_mbc_mode+0x96>
  } else if (c == '3') {
    eepData.MBCMode = CART_MODE_MBC3;
    strcpy_P(eepData.MBCName, PSTR("MBC3    "));
  } else if (c == '4') {
    eepData.MBCMode = CART_MODE_MBC5;
    303e:	82 e4       	ldi	r24, 0x42	; 66
    3040:	80 93 a4 05 	sts	0x05A4, r24
    strcpy_P(eepData.MBCName, PSTR("MBC5    "));
    3044:	85 ea       	ldi	r24, 0xA5	; 165
    3046:	95 e0       	ldi	r25, 0x05	; 5
    3048:	6f ec       	ldi	r22, 0xCF	; 207
    304a:	71 e0       	ldi	r23, 0x01	; 1
    304c:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3050:	c5 cf       	rjmp	.-118    	; 0x2fdc <force_mbc_mode+0x96>
  if(c == '0') {
    // MBC1 or ROM only
    eepData.MBCMode = CART_MODE_MBC1_16M;
    strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
  } else if (c == '1') {
    eepData.MBCMode = CART_MODE_MBC1_4M;
    3052:	81 e4       	ldi	r24, 0x41	; 65
    3054:	80 93 a4 05 	sts	0x05A4, r24
    strcpy_P(eepData.MBCName, PSTR("MBC1_4M "));
    3058:	85 ea       	ldi	r24, 0xA5	; 165
    305a:	95 e0       	ldi	r25, 0x05	; 5
    305c:	6a ee       	ldi	r22, 0xEA	; 234
    305e:	71 e0       	ldi	r23, 0x01	; 1
    3060:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3064:	bb cf       	rjmp	.-138    	; 0x2fdc <force_mbc_mode+0x96>
    strcpy_P(eepData.MBCName, PSTR("MBC3    "));
  } else if (c == '4') {
    eepData.MBCMode = CART_MODE_MBC5;
    strcpy_P(eepData.MBCName, PSTR("MBC5    "));
  } else if (c == 'c') {
    usart_transmit_str_P(PSTR("Cancel selection.\r\n"));
    3066:	8b eb       	ldi	r24, 0xBB	; 187
    3068:	91 e0       	ldi	r25, 0x01	; 1
    306a:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    306e:	b6 cf       	rjmp	.-148    	; 0x2fdc <force_mbc_mode+0x96>

00003070 <flash_diagnostic>:

  wait_for_continue();
  return 0;
}

uint8_t flash_diagnostic() {
    3070:	1f 93       	push	r17

  uint8_t flashID = FLASH_READ_ID(0);
    3072:	80 e0       	ldi	r24, 0x00	; 0
    3074:	0e 94 3e 11 	call	0x227c	; 0x227c <mac_read_softwareID>
    3078:	18 2f       	mov	r17, r24

  usart_transmit_str_P(PSTR("Flash chip ID (expecting 0xD6 for Macronix)\r\n0: 0x"));
    307a:	81 e9       	ldi	r24, 0x91	; 145
    307c:	92 e0       	ldi	r25, 0x02	; 2
    307e:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit(nibble_to_hex(flashID >> 4));
    3082:	81 2f       	mov	r24, r17
    3084:	82 95       	swap	r24
    3086:	8f 70       	andi	r24, 0x0F	; 15
    3088:	0e 94 4f 08 	call	0x109e	; 0x109e <nibble_to_hex>
    308c:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit(nibble_to_hex(flashID));
    3090:	81 2f       	mov	r24, r17
    3092:	0e 94 4f 08 	call	0x109e	; 0x109e <nibble_to_hex>
    3096:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_newline();
    309a:	8a e0       	ldi	r24, 0x0A	; 10
    309c:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    30a0:	8d e0       	ldi	r24, 0x0D	; 13
    30a2:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  flashID = FLASH_READ_ID(1);
    30a6:	81 e0       	ldi	r24, 0x01	; 1
    30a8:	0e 94 3e 11 	call	0x227c	; 0x227c <mac_read_softwareID>
    30ac:	18 2f       	mov	r17, r24
  usart_transmit_str_P(PSTR("1: 0x"));
    30ae:	8b e8       	ldi	r24, 0x8B	; 139
    30b0:	92 e0       	ldi	r25, 0x02	; 2
    30b2:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit(nibble_to_hex(flashID >> 4));
    30b6:	81 2f       	mov	r24, r17
    30b8:	82 95       	swap	r24
    30ba:	8f 70       	andi	r24, 0x0F	; 15
    30bc:	0e 94 4f 08 	call	0x109e	; 0x109e <nibble_to_hex>
    30c0:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_transmit(nibble_to_hex(flashID));
    30c4:	81 2f       	mov	r24, r17
    30c6:	0e 94 4f 08 	call	0x109e	; 0x109e <nibble_to_hex>
    30ca:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  usart_newline();
    30ce:	8a e0       	ldi	r24, 0x0A	; 10
    30d0:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    30d4:	8d e0       	ldi	r24, 0x0D	; 13
    30d6:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    30da:	86 e3       	ldi	r24, 0x36	; 54
    30dc:	91 e0       	ldi	r25, 0x01	; 1
    30de:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    30e2:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    30e6:	80 32       	cpi	r24, 0x20	; 32
    30e8:	e1 f7       	brne	.-8      	; 0x30e2 <flash_diagnostic+0x72>
  usart_transmit(nibble_to_hex(flashID));
  usart_newline();

  wait_for_continue();
  return 0;
}
    30ea:	80 e0       	ldi	r24, 0x00	; 0
    30ec:	1f 91       	pop	r17
    30ee:	08 95       	ret

000030f0 <dump_save>:
  return 0;
}

uint8_t dump_save() {

  usart_transmit_str_P(PSTR("Confirm you wish to dump the current save file (Y/N)\r\n"));
    30f0:	8b e1       	ldi	r24, 0x1B	; 27
    30f2:	93 e0       	ldi	r25, 0x03	; 3
    30f4:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

uint8_t wait_for_confirm_cancel() {
  
  char input; 
  do {
    input = usart_receive();
    30f8:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while((input != 'Y') && (input != 'N') && (input != 'y') && (input != 'n'));
    30fc:	89 35       	cpi	r24, 0x59	; 89
    30fe:	a1 f0       	breq	.+40     	; 0x3128 <dump_save+0x38>
    3100:	8e 34       	cpi	r24, 0x4E	; 78
    3102:	21 f0       	breq	.+8      	; 0x310c <dump_save+0x1c>
    3104:	89 37       	cpi	r24, 0x79	; 121
    3106:	81 f0       	breq	.+32     	; 0x3128 <dump_save+0x38>
    3108:	8e 36       	cpi	r24, 0x6E	; 110
    310a:	b1 f7       	brne	.-20     	; 0x30f8 <dump_save+0x8>

  usart_transmit_str_P(PSTR("Confirm you wish to dump the current save file (Y/N)\r\n"));

  if(wait_for_confirm_cancel()) {
    // Abort
    usart_transmit_str_P(commonAbort);
    310c:	82 e6       	ldi	r24, 0x62	; 98
    310e:	91 e0       	ldi	r25, 0x01	; 1
    3110:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    3114:	86 e3       	ldi	r24, 0x36	; 54
    3116:	91 e0       	ldi	r25, 0x01	; 1
    3118:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    311c:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    3120:	80 32       	cpi	r24, 0x20	; 32
    3122:	e1 f7       	brne	.-8      	; 0x311c <dump_save+0x2c>
    3124:	81 e0       	ldi	r24, 0x01	; 1
    3126:	08 95       	ret
    usart_transmit_str_P(commonAbort);
    wait_for_continue();
    return 1;
  }

  usart_transmit_str_P(PSTR("Select YMODEM receive on your terminal to download. AVR will be waiting\r\n"));
    3128:	81 ed       	ldi	r24, 0xD1	; 209
    312a:	92 e0       	ldi	r25, 0x02	; 2
    312c:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  RAMaddress = 0;
    3130:	10 92 4e 01 	sts	0x014E, r1
    3134:	10 92 4f 01 	sts	0x014F, r1
    3138:	10 92 50 01 	sts	0x0150, r1
    313c:	10 92 51 01 	sts	0x0151, r1
  ymodem_send(sram_buff_send, "GBDump.sav", gbRomData.RAMsizeBytes);
    3140:	20 91 82 05 	lds	r18, 0x0582
    3144:	30 91 83 05 	lds	r19, 0x0583
    3148:	40 e0       	ldi	r20, 0x00	; 0
    314a:	50 e0       	ldi	r21, 0x00	; 0
    314c:	82 e5       	ldi	r24, 0x52	; 82
    314e:	95 e1       	ldi	r25, 0x15	; 21
    3150:	6a e2       	ldi	r22, 0x2A	; 42
    3152:	71 e0       	ldi	r23, 0x01	; 1
    3154:	0e 94 3a 0c 	call	0x1874	; 0x1874 <ymodem_send>

  usart_transmit_str_P(PSTR("File sent!\r\n"));
    3158:	84 ec       	ldi	r24, 0xC4	; 196
    315a:	92 e0       	ldi	r25, 0x02	; 2
    315c:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    3160:	86 e3       	ldi	r24, 0x36	; 54
    3162:	91 e0       	ldi	r25, 0x01	; 1
    3164:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    3168:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    316c:	80 32       	cpi	r24, 0x20	; 32
    316e:	e1 f7       	brne	.-8      	; 0x3168 <dump_save+0x78>
    3170:	80 e0       	ldi	r24, 0x00	; 0

  usart_transmit_str_P(PSTR("File sent!\r\n"));

  wait_for_continue();
  return 0;
}
    3172:	08 95       	ret

00003174 <receive_ROM>:

  wait_for_continue();
  return 0;
}

uint8_t receive_ROM() {
    3174:	0f 93       	push	r16
    3176:	1f 93       	push	r17
    3178:	cf 93       	push	r28
    317a:	df 93       	push	r29

  usart_transmit_str_P(PSTR("Confirm you wish to erase and flash a new ROM (Y/N)\r\n"));
    317c:	8a eb       	ldi	r24, 0xBA	; 186
    317e:	95 e0       	ldi	r25, 0x05	; 5
    3180:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

uint8_t wait_for_confirm_cancel() {
  
  char input; 
  do {
    input = usart_receive();
    3184:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while((input != 'Y') && (input != 'N') && (input != 'y') && (input != 'n'));
    3188:	89 35       	cpi	r24, 0x59	; 89
    318a:	c1 f0       	breq	.+48     	; 0x31bc <receive_ROM+0x48>
    318c:	8e 34       	cpi	r24, 0x4E	; 78
    318e:	21 f0       	breq	.+8      	; 0x3198 <receive_ROM+0x24>
    3190:	89 37       	cpi	r24, 0x79	; 121
    3192:	a1 f0       	breq	.+40     	; 0x31bc <receive_ROM+0x48>
    3194:	8e 36       	cpi	r24, 0x6E	; 110
    3196:	b1 f7       	brne	.-20     	; 0x3184 <receive_ROM+0x10>
uint8_t receive_ROM() {

  usart_transmit_str_P(PSTR("Confirm you wish to erase and flash a new ROM (Y/N)\r\n"));

  if(wait_for_confirm_cancel()) {
    usart_transmit_str_P(commonAbort);
    3198:	82 e6       	ldi	r24, 0x62	; 98
    319a:	91 e0       	ldi	r25, 0x01	; 1
    319c:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    31a0:	86 e3       	ldi	r24, 0x36	; 54
    31a2:	91 e0       	ldi	r25, 0x01	; 1
    31a4:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    31a8:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    31ac:	80 32       	cpi	r24, 0x20	; 32
    31ae:	e1 f7       	brne	.-8      	; 0x31a8 <receive_ROM+0x34>
    31b0:	81 e0       	ldi	r24, 0x01	; 1
  // EEPROM WRITE CYCLE GOES HERE IF DATA IS DIFFERENT!
  write_update_gbeepromdat(&eepData);

  wait_for_continue();
  return 0;
}
    31b2:	df 91       	pop	r29
    31b4:	cf 91       	pop	r28
    31b6:	1f 91       	pop	r17
    31b8:	0f 91       	pop	r16
    31ba:	08 95       	ret
    usart_transmit_str_P(commonAbort);
    wait_for_continue();
    return 1;
  }

  usart_transmit_str_P(PSTR("Erasing chip(s)\r\n"));
    31bc:	88 ea       	ldi	r24, 0xA8	; 168
    31be:	95 e0       	ldi	r25, 0x05	; 5
    31c0:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  FLASH_ERASE_CHIP(0);
    31c4:	80 e0       	ldi	r24, 0x00	; 0
    31c6:	0e 94 5f 13 	call	0x26be	; 0x26be <mac_flash_chip_erase>
  FLASH_ERASE_CHIP(1);
    31ca:	81 e0       	ldi	r24, 0x01	; 1
    31cc:	0e 94 5f 13 	call	0x26be	; 0x26be <mac_flash_chip_erase>
  
  usart_transmit_str_P(PSTR("10 second delay. Quick, select the file to download via YMODEM protocol\r\n"));
    31d0:	8e e5       	ldi	r24, 0x5E	; 94
    31d2:	95 e0       	ldi	r25, 0x05	; 5
    31d4:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    31d8:	10 e3       	ldi	r17, 0x30	; 48
    31da:	c5 e8       	ldi	r28, 0x85	; 133
    31dc:	d2 e0       	ldi	r29, 0x02	; 2

  for(uint8_t i=0; i<10; i++) {
    usart_transmit(i+'0');
    31de:	81 2f       	mov	r24, r17
    31e0:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    31e4:	20 e0       	ldi	r18, 0x00	; 0
    31e6:	30 e0       	ldi	r19, 0x00	; 0
    31e8:	ce 01       	movw	r24, r28
    31ea:	01 97       	sbiw	r24, 0x01	; 1
    31ec:	f1 f7       	brne	.-4      	; 0x31ea <receive_ROM+0x76>
    31ee:	2f 5f       	subi	r18, 0xFF	; 255
    31f0:	3f 4f       	sbci	r19, 0xFF	; 255
    31f2:	87 e2       	ldi	r24, 0x27	; 39
    31f4:	20 31       	cpi	r18, 0x10	; 16
    31f6:	38 07       	cpc	r19, r24
    31f8:	b9 f7       	brne	.-18     	; 0x31e8 <receive_ROM+0x74>
    31fa:	1f 5f       	subi	r17, 0xFF	; 255
  FLASH_ERASE_CHIP(0);
  FLASH_ERASE_CHIP(1);
  
  usart_transmit_str_P(PSTR("10 second delay. Quick, select the file to download via YMODEM protocol\r\n"));

  for(uint8_t i=0; i<10; i++) {
    31fc:	1a 33       	cpi	r17, 0x3A	; 58
    31fe:	79 f7       	brne	.-34     	; 0x31de <receive_ROM+0x6a>
    usart_transmit(i+'0');
    _delay_ms(1000);
  }
  usart_newline();
    3200:	8a e0       	ldi	r24, 0x0A	; 10
    3202:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    3206:	8d e0       	ldi	r24, 0x0D	; 13
    3208:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>

  flashAddress.address32 = 0; // = 0 normally, change this to debug storing at a high address
    320c:	10 92 61 05 	sts	0x0561, r1
    3210:	10 92 62 05 	sts	0x0562, r1
    3214:	10 92 63 05 	sts	0x0563, r1
    3218:	10 92 64 05 	sts	0x0564, r1
  uint8_t retVal = ymodem_receive(flash_buff_receive, &fileSize);
    321c:	85 ef       	ldi	r24, 0xF5	; 245
    321e:	95 e1       	ldi	r25, 0x15	; 21
    3220:	6a e4       	ldi	r22, 0x4A	; 74
    3222:	71 e0       	ldi	r23, 0x01	; 1
    3224:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <ymodem_receive>
    3228:	08 2f       	mov	r16, r24
    322a:	20 e0       	ldi	r18, 0x00	; 0
    322c:	30 e0       	ldi	r19, 0x00	; 0
    322e:	45 e8       	ldi	r20, 0x85	; 133
    3230:	52 e0       	ldi	r21, 0x02	; 2
    3232:	ca 01       	movw	r24, r20
    3234:	01 97       	sbiw	r24, 0x01	; 1
    3236:	f1 f7       	brne	.-4      	; 0x3234 <receive_ROM+0xc0>
    3238:	2f 5f       	subi	r18, 0xFF	; 255
    323a:	3f 4f       	sbci	r19, 0xFF	; 255
    323c:	89 e0       	ldi	r24, 0x09	; 9
    323e:	24 3c       	cpi	r18, 0xC4	; 196
    3240:	38 07       	cpc	r19, r24
    3242:	b9 f7       	brne	.-18     	; 0x3232 <receive_ROM+0xbe>
  
  _delay_ms(250);

  if (retVal) {
    3244:	00 23       	and	r16, r16
    3246:	f1 f0       	breq	.+60     	; 0x3284 <receive_ROM+0x110>
    3248:	10 e3       	ldi	r17, 0x30	; 48
    324a:	c5 e8       	ldi	r28, 0x85	; 133
    324c:	d2 e0       	ldi	r29, 0x02	; 2
    for(uint8_t i=0; i<10; i++) {
      usart_transmit(i+'0');
    324e:	81 2f       	mov	r24, r17
    3250:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    3254:	20 e0       	ldi	r18, 0x00	; 0
    3256:	30 e0       	ldi	r19, 0x00	; 0
    3258:	ce 01       	movw	r24, r28
    325a:	01 97       	sbiw	r24, 0x01	; 1
    325c:	f1 f7       	brne	.-4      	; 0x325a <receive_ROM+0xe6>
    325e:	2f 5f       	subi	r18, 0xFF	; 255
    3260:	3f 4f       	sbci	r19, 0xFF	; 255
    3262:	87 e2       	ldi	r24, 0x27	; 39
    3264:	20 31       	cpi	r18, 0x10	; 16
    3266:	38 07       	cpc	r19, r24
    3268:	b9 f7       	brne	.-18     	; 0x3258 <receive_ROM+0xe4>
    326a:	1f 5f       	subi	r17, 0xFF	; 255
  uint8_t retVal = ymodem_receive(flash_buff_receive, &fileSize);
  
  _delay_ms(250);

  if (retVal) {
    for(uint8_t i=0; i<10; i++) {
    326c:	1a 33       	cpi	r17, 0x3A	; 58
    326e:	79 f7       	brne	.-34     	; 0x324e <receive_ROM+0xda>
      usart_transmit(i+'0');
      _delay_ms(1000);
    }
    usart_transmit_str_P(PSTR("\r\nError: "));
    3270:	84 e5       	ldi	r24, 0x54	; 84
    3272:	95 e0       	ldi	r25, 0x05	; 5
    3274:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    usart_transmit_int32(retVal);
    3278:	60 2f       	mov	r22, r16
    327a:	70 e0       	ldi	r23, 0x00	; 0
    327c:	80 e0       	ldi	r24, 0x00	; 0
    327e:	90 e0       	ldi	r25, 0x00	; 0
    3280:	0e 94 25 06 	call	0xc4a	; 0xc4a <usart_transmit_int32>
  } 

  usart_transmit_str_P(PSTR("\r\nFile received! Size: "));
    3284:	8c e3       	ldi	r24, 0x3C	; 60
    3286:	95 e0       	ldi	r25, 0x05	; 5
    3288:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit_int32(fileSize);
    328c:	60 91 4a 01 	lds	r22, 0x014A
    3290:	70 91 4b 01 	lds	r23, 0x014B
    3294:	80 91 4c 01 	lds	r24, 0x014C
    3298:	90 91 4d 01 	lds	r25, 0x014D
    329c:	0e 94 25 06 	call	0xc4a	; 0xc4a <usart_transmit_int32>
  usart_transmit_str_P(PSTR("\r\nMax address        : "));
    32a0:	84 e2       	ldi	r24, 0x24	; 36
    32a2:	95 e0       	ldi	r25, 0x05	; 5
    32a4:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit_int32(flashAddress.address32);
    32a8:	60 91 61 05 	lds	r22, 0x0561
    32ac:	70 91 62 05 	lds	r23, 0x0562
    32b0:	80 91 63 05 	lds	r24, 0x0563
    32b4:	90 91 64 05 	lds	r25, 0x0564
    32b8:	0e 94 25 06 	call	0xc4a	; 0xc4a <usart_transmit_int32>
  usart_newline();
    32bc:	8a e0       	ldi	r24, 0x0A	; 10
    32be:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    32c2:	8d e0       	ldi	r24, 0x0D	; 13
    32c4:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  

  // Must update the EEPROM information too!
  get_GBROM_info(&gbRomData);
    32c8:	8b e6       	ldi	r24, 0x6B	; 107
    32ca:	95 e0       	ldi	r25, 0x05	; 5
    32cc:	0e 94 10 1c 	call	0x3820	; 0x3820 <get_GBROM_info>
  
  // Set the new mode 
  if(gbRomData.MBCtype < 0x04) {
    32d0:	90 91 84 05 	lds	r25, 0x0584
    32d4:	94 30       	cpi	r25, 0x04	; 4
    32d6:	b8 f0       	brcs	.+46     	; 0x3306 <receive_ROM+0x192>
    } else {
      eepData.MBCMode = CART_MODE_MBC1_16M;
      strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
    }
  
  } else if(gbRomData.MBCtype == 0x05 || gbRomData.MBCtype == 0x06) {
    32d8:	89 2f       	mov	r24, r25
    32da:	85 50       	subi	r24, 0x05	; 5
    32dc:	82 30       	cpi	r24, 0x02	; 2
    32de:	08 f4       	brcc	.+2      	; 0x32e2 <receive_ROM+0x16e>
    32e0:	6d c0       	rjmp	.+218    	; 0x33bc <receive_ROM+0x248>
    // MBC2
    eepData.MBCMode = CART_MODE_MBC2;
    strcpy_P(eepData.MBCName, PSTR("MBC2    "));

  } else if(gbRomData.MBCtype >= 0x0F && gbRomData.MBCtype <= 0x13) {
    32e2:	89 2f       	mov	r24, r25
    32e4:	8f 50       	subi	r24, 0x0F	; 15
    32e6:	85 30       	cpi	r24, 0x05	; 5
    32e8:	08 f4       	brcc	.+2      	; 0x32ec <receive_ROM+0x178>
    32ea:	5e c0       	rjmp	.+188    	; 0x33a8 <receive_ROM+0x234>
    // MBC3
    eepData.MBCMode = CART_MODE_MBC3;
    strcpy_P(eepData.MBCName, PSTR("MBC3    "));

  } else if(gbRomData.MBCtype >= 0x19) {
    32ec:	99 31       	cpi	r25, 0x19	; 25
    32ee:	08 f4       	brcc	.+2      	; 0x32f2 <receive_ROM+0x17e>
    32f0:	47 c0       	rjmp	.+142    	; 0x3380 <receive_ROM+0x20c>
    // MBC5
    eepData.MBCMode = CART_MODE_MBC5;
    32f2:	82 e4       	ldi	r24, 0x42	; 66
    32f4:	80 93 a4 05 	sts	0x05A4, r24
    strcpy_P(eepData.MBCName, PSTR("MBC5    "));
    32f8:	85 ea       	ldi	r24, 0xA5	; 165
    32fa:	95 e0       	ldi	r25, 0x05	; 5
    32fc:	62 ea       	ldi	r22, 0xA2	; 162
    32fe:	74 e0       	ldi	r23, 0x04	; 4
    3300:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3304:	21 c0       	rjmp	.+66     	; 0x3348 <receive_ROM+0x1d4>
  
  // Set the new mode 
  if(gbRomData.MBCtype < 0x04) {
    // MBC1 or ROM only
    
    if(gbRomData.RAMsizeBytes > 8192 && gbRomData.ROMsizeBytes <= 524288) {
    3306:	80 91 82 05 	lds	r24, 0x0582
    330a:	90 91 83 05 	lds	r25, 0x0583
    330e:	81 50       	subi	r24, 0x01	; 1
    3310:	90 42       	sbci	r25, 0x20	; 32
    3312:	60 f1       	brcs	.+88     	; 0x336c <receive_ROM+0x1f8>
    3314:	80 91 7d 05 	lds	r24, 0x057D
    3318:	90 91 7e 05 	lds	r25, 0x057E
    331c:	a0 91 7f 05 	lds	r26, 0x057F
    3320:	b0 91 80 05 	lds	r27, 0x0580
    3324:	81 50       	subi	r24, 0x01	; 1
    3326:	90 40       	sbci	r25, 0x00	; 0
    3328:	a8 40       	sbci	r26, 0x08	; 8
    332a:	b0 40       	sbci	r27, 0x00	; 0
    332c:	98 f1       	brcs	.+102    	; 0x3394 <receive_ROM+0x220>
      eepData.MBCMode = CART_MODE_MBC1_4M;
      strcpy_P(eepData.MBCName, PSTR("MBC1_4M "));
    } else if(gbRomData.RAMsizeBytes > 8192 && gbRomData.ROMsizeBytes > 524288) {
      eepData.MBCMode = CART_MODE_MBC3;
    332e:	83 e4       	ldi	r24, 0x43	; 67
    3330:	80 93 a4 05 	sts	0x05A4, r24
      strcpy_P(eepData.MBCName, PSTR("MBC3    "));
    3334:	85 ea       	ldi	r24, 0xA5	; 165
    3336:	95 e0       	ldi	r25, 0x05	; 5
    3338:	62 e1       	ldi	r22, 0x12	; 18
    333a:	75 e0       	ldi	r23, 0x05	; 5
    333c:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
      usart_transmit_str_P(PSTR("WARNING: ROM and RAM size both exceed MBC1 mode sizes. Assuming MBC3 mode\r\n"));
    3340:	86 ec       	ldi	r24, 0xC6	; 198
    3342:	94 e0       	ldi	r25, 0x04	; 4
    3344:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    eepData.MBCMode = CART_MODE_MBC1_16M;
    strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
  }

  // EEPROM WRITE CYCLE GOES HERE IF DATA IS DIFFERENT!
  write_update_gbeepromdat(&eepData);
    3348:	84 ea       	ldi	r24, 0xA4	; 164
    334a:	95 e0       	ldi	r25, 0x05	; 5
    334c:	0e 94 a7 1f 	call	0x3f4e	; 0x3f4e <write_update_gbeepromdat>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    3350:	86 e3       	ldi	r24, 0x36	; 54
    3352:	91 e0       	ldi	r25, 0x01	; 1
    3354:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    3358:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    335c:	80 32       	cpi	r24, 0x20	; 32
    335e:	e1 f7       	brne	.-8      	; 0x3358 <receive_ROM+0x1e4>
    3360:	80 e0       	ldi	r24, 0x00	; 0
  // EEPROM WRITE CYCLE GOES HERE IF DATA IS DIFFERENT!
  write_update_gbeepromdat(&eepData);

  wait_for_continue();
  return 0;
}
    3362:	df 91       	pop	r29
    3364:	cf 91       	pop	r28
    3366:	1f 91       	pop	r17
    3368:	0f 91       	pop	r16
    336a:	08 95       	ret
    } else if(gbRomData.RAMsizeBytes > 8192 && gbRomData.ROMsizeBytes > 524288) {
      eepData.MBCMode = CART_MODE_MBC3;
      strcpy_P(eepData.MBCName, PSTR("MBC3    "));
      usart_transmit_str_P(PSTR("WARNING: ROM and RAM size both exceed MBC1 mode sizes. Assuming MBC3 mode\r\n"));
    } else {
      eepData.MBCMode = CART_MODE_MBC1_16M;
    336c:	80 e4       	ldi	r24, 0x40	; 64
    336e:	80 93 a4 05 	sts	0x05A4, r24
      strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
    3372:	85 ea       	ldi	r24, 0xA5	; 165
    3374:	95 e0       	ldi	r25, 0x05	; 5
    3376:	6d eb       	ldi	r22, 0xBD	; 189
    3378:	74 e0       	ldi	r23, 0x04	; 4
    337a:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    337e:	e4 cf       	rjmp	.-56     	; 0x3348 <receive_ROM+0x1d4>
    // MBC5
    eepData.MBCMode = CART_MODE_MBC5;
    strcpy_P(eepData.MBCName, PSTR("MBC5    "));
  } else {
    // default to MBC116M8k unless someone else says...
    eepData.MBCMode = CART_MODE_MBC1_16M;
    3380:	80 e4       	ldi	r24, 0x40	; 64
    3382:	80 93 a4 05 	sts	0x05A4, r24
    strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
    3386:	85 ea       	ldi	r24, 0xA5	; 165
    3388:	95 e0       	ldi	r25, 0x05	; 5
    338a:	69 e9       	ldi	r22, 0x99	; 153
    338c:	74 e0       	ldi	r23, 0x04	; 4
    338e:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3392:	da cf       	rjmp	.-76     	; 0x3348 <receive_ROM+0x1d4>
  // Set the new mode 
  if(gbRomData.MBCtype < 0x04) {
    // MBC1 or ROM only
    
    if(gbRomData.RAMsizeBytes > 8192 && gbRomData.ROMsizeBytes <= 524288) {
      eepData.MBCMode = CART_MODE_MBC1_4M;
    3394:	81 e4       	ldi	r24, 0x41	; 65
    3396:	80 93 a4 05 	sts	0x05A4, r24
      strcpy_P(eepData.MBCName, PSTR("MBC1_4M "));
    339a:	85 ea       	ldi	r24, 0xA5	; 165
    339c:	95 e0       	ldi	r25, 0x05	; 5
    339e:	6b e1       	ldi	r22, 0x1B	; 27
    33a0:	75 e0       	ldi	r23, 0x05	; 5
    33a2:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    33a6:	d0 cf       	rjmp	.-96     	; 0x3348 <receive_ROM+0x1d4>
    eepData.MBCMode = CART_MODE_MBC2;
    strcpy_P(eepData.MBCName, PSTR("MBC2    "));

  } else if(gbRomData.MBCtype >= 0x0F && gbRomData.MBCtype <= 0x13) {
    // MBC3
    eepData.MBCMode = CART_MODE_MBC3;
    33a8:	83 e4       	ldi	r24, 0x43	; 67
    33aa:	80 93 a4 05 	sts	0x05A4, r24
    strcpy_P(eepData.MBCName, PSTR("MBC3    "));
    33ae:	85 ea       	ldi	r24, 0xA5	; 165
    33b0:	95 e0       	ldi	r25, 0x05	; 5
    33b2:	6b ea       	ldi	r22, 0xAB	; 171
    33b4:	74 e0       	ldi	r23, 0x04	; 4
    33b6:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    33ba:	c6 cf       	rjmp	.-116    	; 0x3348 <receive_ROM+0x1d4>
      strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
    }
  
  } else if(gbRomData.MBCtype == 0x05 || gbRomData.MBCtype == 0x06) {
    // MBC2
    eepData.MBCMode = CART_MODE_MBC2;
    33bc:	85 e4       	ldi	r24, 0x45	; 69
    33be:	80 93 a4 05 	sts	0x05A4, r24
    strcpy_P(eepData.MBCName, PSTR("MBC2    "));
    33c2:	85 ea       	ldi	r24, 0xA5	; 165
    33c4:	95 e0       	ldi	r25, 0x05	; 5
    33c6:	64 eb       	ldi	r22, 0xB4	; 180
    33c8:	74 e0       	ldi	r23, 0x04	; 4
    33ca:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    33ce:	bc cf       	rjmp	.-136    	; 0x3348 <receive_ROM+0x1d4>

000033d0 <dump_ROM>:
  return 0;
}

uint8_t dump_ROM() {

  usart_transmit_str_P(PSTR("Confirm you wish to dump the current ROM (Y/N)\r\n"));
    33d0:	88 e6       	ldi	r24, 0x68	; 104
    33d2:	94 e0       	ldi	r25, 0x04	; 4
    33d4:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

uint8_t wait_for_confirm_cancel() {
  
  char input; 
  do {
    input = usart_receive();
    33d8:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while((input != 'Y') && (input != 'N') && (input != 'y') && (input != 'n'));
    33dc:	89 35       	cpi	r24, 0x59	; 89
    33de:	a1 f0       	breq	.+40     	; 0x3408 <dump_ROM+0x38>
    33e0:	8e 34       	cpi	r24, 0x4E	; 78
    33e2:	21 f0       	breq	.+8      	; 0x33ec <dump_ROM+0x1c>
    33e4:	89 37       	cpi	r24, 0x79	; 121
    33e6:	81 f0       	breq	.+32     	; 0x3408 <dump_ROM+0x38>
    33e8:	8e 36       	cpi	r24, 0x6E	; 110
    33ea:	b1 f7       	brne	.-20     	; 0x33d8 <dump_ROM+0x8>

  usart_transmit_str_P(PSTR("Confirm you wish to dump the current ROM (Y/N)\r\n"));

  if(wait_for_confirm_cancel()) {
    // Abort
    usart_transmit_str_P(commonAbort);
    33ec:	82 e6       	ldi	r24, 0x62	; 98
    33ee:	91 e0       	ldi	r25, 0x01	; 1
    33f0:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    33f4:	86 e3       	ldi	r24, 0x36	; 54
    33f6:	91 e0       	ldi	r25, 0x01	; 1
    33f8:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    33fc:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    3400:	80 32       	cpi	r24, 0x20	; 32
    3402:	e1 f7       	brne	.-8      	; 0x33fc <dump_ROM+0x2c>
    3404:	81 e0       	ldi	r24, 0x01	; 1
    3406:	08 95       	ret
    usart_transmit_str_P(commonAbort);
    wait_for_continue();
    return 1;
  }

  usart_transmit_str_P(PSTR("Select YMODEM receive on your terminal to download. AVR will be waiting\r\n"));
    3408:	8e e1       	ldi	r24, 0x1E	; 30
    340a:	94 e0       	ldi	r25, 0x04	; 4
    340c:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  flashAddress.address32 = 0; // Reset the address again
    3410:	10 92 61 05 	sts	0x0561, r1
    3414:	10 92 62 05 	sts	0x0562, r1
    3418:	10 92 63 05 	sts	0x0563, r1
    341c:	10 92 64 05 	sts	0x0564, r1

  // Two different cases here for naming convention at the other end!
  // Might change this later to take the game name from the ROM and send that through
  if(gbRomData.CGBsupport != GB_PRE_CGB) {
    3420:	80 91 9a 05 	lds	r24, 0x059A
    3424:	88 23       	and	r24, r24
    3426:	e1 f4       	brne	.+56     	; 0x3460 <dump_ROM+0x90>
    ymodem_send(flash_buff_send, "GBDump.gbc", gbRomData.ROMsizeBytes);
  } else {
    ymodem_send(flash_buff_send, "GBDump.gb", gbRomData.ROMsizeBytes);
    3428:	20 91 7d 05 	lds	r18, 0x057D
    342c:	30 91 7e 05 	lds	r19, 0x057E
    3430:	40 91 7f 05 	lds	r20, 0x057F
    3434:	50 91 80 05 	lds	r21, 0x0580
    3438:	8c eb       	ldi	r24, 0xBC	; 188
    343a:	95 e1       	ldi	r25, 0x15	; 21
    343c:	60 e4       	ldi	r22, 0x40	; 64
    343e:	71 e0       	ldi	r23, 0x01	; 1
    3440:	0e 94 3a 0c 	call	0x1874	; 0x1874 <ymodem_send>
  }
  
  usart_transmit_str_P(PSTR("File sent!\r\n"));
    3444:	81 e1       	ldi	r24, 0x11	; 17
    3446:	94 e0       	ldi	r25, 0x04	; 4
    3448:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    344c:	86 e3       	ldi	r24, 0x36	; 54
    344e:	91 e0       	ldi	r25, 0x01	; 1
    3450:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    3454:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    3458:	80 32       	cpi	r24, 0x20	; 32
    345a:	e1 f7       	brne	.-8      	; 0x3454 <dump_ROM+0x84>
    345c:	80 e0       	ldi	r24, 0x00	; 0
  
  usart_transmit_str_P(PSTR("File sent!\r\n"));

  wait_for_continue();
  return 0;
}
    345e:	08 95       	ret
  flashAddress.address32 = 0; // Reset the address again

  // Two different cases here for naming convention at the other end!
  // Might change this later to take the game name from the ROM and send that through
  if(gbRomData.CGBsupport != GB_PRE_CGB) {
    ymodem_send(flash_buff_send, "GBDump.gbc", gbRomData.ROMsizeBytes);
    3460:	20 91 7d 05 	lds	r18, 0x057D
    3464:	30 91 7e 05 	lds	r19, 0x057E
    3468:	40 91 7f 05 	lds	r20, 0x057F
    346c:	50 91 80 05 	lds	r21, 0x0580
    3470:	8c eb       	ldi	r24, 0xBC	; 188
    3472:	95 e1       	ldi	r25, 0x15	; 21
    3474:	65 e3       	ldi	r22, 0x35	; 53
    3476:	71 e0       	ldi	r23, 0x01	; 1
    3478:	0e 94 3a 0c 	call	0x1874	; 0x1874 <ymodem_send>
    347c:	e3 cf       	rjmp	.-58     	; 0x3444 <dump_ROM+0x74>

0000347e <receive_save>:

  wait_for_continue();
  return 0;
}

uint8_t receive_save() {
    347e:	1f 93       	push	r17
    3480:	cf 93       	push	r28
    3482:	df 93       	push	r29

  usart_transmit_str_P(PSTR("Confirm you wish to download a save file (Y/N)\r\n"));
    3484:	80 ee       	ldi	r24, 0xE0	; 224
    3486:	93 e0       	ldi	r25, 0x03	; 3
    3488:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

uint8_t wait_for_confirm_cancel() {
  
  char input; 
  do {
    input = usart_receive();
    348c:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while((input != 'Y') && (input != 'N') && (input != 'y') && (input != 'n'));
    3490:	89 35       	cpi	r24, 0x59	; 89
    3492:	b9 f0       	breq	.+46     	; 0x34c2 <receive_save+0x44>
    3494:	8e 34       	cpi	r24, 0x4E	; 78
    3496:	21 f0       	breq	.+8      	; 0x34a0 <receive_save+0x22>
    3498:	89 37       	cpi	r24, 0x79	; 121
    349a:	99 f0       	breq	.+38     	; 0x34c2 <receive_save+0x44>
    349c:	8e 36       	cpi	r24, 0x6E	; 110
    349e:	b1 f7       	brne	.-20     	; 0x348c <receive_save+0xe>
uint8_t receive_save() {

  usart_transmit_str_P(PSTR("Confirm you wish to download a save file (Y/N)\r\n"));

  if(wait_for_confirm_cancel()) {
    usart_transmit_str_P(commonAbort);
    34a0:	82 e6       	ldi	r24, 0x62	; 98
    34a2:	91 e0       	ldi	r25, 0x01	; 1
    34a4:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    34a8:	86 e3       	ldi	r24, 0x36	; 54
    34aa:	91 e0       	ldi	r25, 0x01	; 1
    34ac:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    34b0:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    34b4:	80 32       	cpi	r24, 0x20	; 32
    34b6:	e1 f7       	brne	.-8      	; 0x34b0 <receive_save+0x32>
    34b8:	81 e0       	ldi	r24, 0x01	; 1
    usart_newline();
  }

  wait_for_continue();
  return 0;
}
    34ba:	df 91       	pop	r29
    34bc:	cf 91       	pop	r28
    34be:	1f 91       	pop	r17
    34c0:	08 95       	ret
    usart_transmit_str_P(commonAbort);
    wait_for_continue();
    return 1;
  }
  
  usart_transmit_str_P(PSTR("10 second delay. Quick, select the file to download via YMODEM protocol\r\n"));
    34c2:	86 e9       	ldi	r24, 0x96	; 150
    34c4:	93 e0       	ldi	r25, 0x03	; 3
    34c6:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    34ca:	10 e3       	ldi	r17, 0x30	; 48
    34cc:	c5 e8       	ldi	r28, 0x85	; 133
    34ce:	d2 e0       	ldi	r29, 0x02	; 2

  for(uint8_t i=0; i<10; i++) {
    usart_transmit(i+'0');
    34d0:	81 2f       	mov	r24, r17
    34d2:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    34d6:	20 e0       	ldi	r18, 0x00	; 0
    34d8:	30 e0       	ldi	r19, 0x00	; 0
    34da:	ce 01       	movw	r24, r28
    34dc:	01 97       	sbiw	r24, 0x01	; 1
    34de:	f1 f7       	brne	.-4      	; 0x34dc <receive_save+0x5e>
    34e0:	2f 5f       	subi	r18, 0xFF	; 255
    34e2:	3f 4f       	sbci	r19, 0xFF	; 255
    34e4:	87 e2       	ldi	r24, 0x27	; 39
    34e6:	20 31       	cpi	r18, 0x10	; 16
    34e8:	38 07       	cpc	r19, r24
    34ea:	b9 f7       	brne	.-18     	; 0x34da <receive_save+0x5c>
    34ec:	1f 5f       	subi	r17, 0xFF	; 255
    return 1;
  }
  
  usart_transmit_str_P(PSTR("10 second delay. Quick, select the file to download via YMODEM protocol\r\n"));

  for(uint8_t i=0; i<10; i++) {
    34ee:	1a 33       	cpi	r17, 0x3A	; 58
    34f0:	79 f7       	brne	.-34     	; 0x34d0 <receive_save+0x52>
    usart_transmit(i+'0');
    _delay_ms(1000);
  }
  usart_newline();
    34f2:	8a e0       	ldi	r24, 0x0A	; 10
    34f4:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    34f8:	8d e0       	ldi	r24, 0x0D	; 13
    34fa:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
  
  RAMaddress = 0;
    34fe:	10 92 4e 01 	sts	0x014E, r1
    3502:	10 92 4f 01 	sts	0x014F, r1
    3506:	10 92 50 01 	sts	0x0150, r1
    350a:	10 92 51 01 	sts	0x0151, r1
  RAMWriteErrors = 0;
    350e:	10 92 6a 05 	sts	0x056A, r1
    3512:	10 92 69 05 	sts	0x0569, r1
  ymodem_receive(sram_buff_receive, &fileSize);
    3516:	87 e8       	ldi	r24, 0x87	; 135
    3518:	95 e1       	ldi	r25, 0x15	; 21
    351a:	6a e4       	ldi	r22, 0x4A	; 74
    351c:	71 e0       	ldi	r23, 0x01	; 1
    351e:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <ymodem_receive>

  usart_transmit_str_P(PSTR("\r\nFile received! Size: "));
    3522:	8e e7       	ldi	r24, 0x7E	; 126
    3524:	93 e0       	ldi	r25, 0x03	; 3
    3526:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  usart_transmit_int32(fileSize);
    352a:	60 91 4a 01 	lds	r22, 0x014A
    352e:	70 91 4b 01 	lds	r23, 0x014B
    3532:	80 91 4c 01 	lds	r24, 0x014C
    3536:	90 91 4d 01 	lds	r25, 0x014D
    353a:	0e 94 25 06 	call	0xc4a	; 0xc4a <usart_transmit_int32>
  usart_newline();
    353e:	8a e0       	ldi	r24, 0x0A	; 10
    3540:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    3544:	8d e0       	ldi	r24, 0x0D	; 13
    3546:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>

  if(RAMWriteErrors) {
    354a:	80 91 69 05 	lds	r24, 0x0569
    354e:	90 91 6a 05 	lds	r25, 0x056A
    3552:	89 2b       	or	r24, r25
    3554:	69 f4       	brne	.+26     	; 0x3570 <receive_save+0xf2>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    3556:	86 e3       	ldi	r24, 0x36	; 54
    3558:	91 e0       	ldi	r25, 0x01	; 1
    355a:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    355e:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    3562:	80 32       	cpi	r24, 0x20	; 32
    3564:	e1 f7       	brne	.-8      	; 0x355e <receive_save+0xe0>
    3566:	80 e0       	ldi	r24, 0x00	; 0
    usart_newline();
  }

  wait_for_continue();
  return 0;
}
    3568:	df 91       	pop	r29
    356a:	cf 91       	pop	r28
    356c:	1f 91       	pop	r17
    356e:	08 95       	ret
  usart_transmit_str_P(PSTR("\r\nFile received! Size: "));
  usart_transmit_int32(fileSize);
  usart_newline();

  if(RAMWriteErrors) {
    usart_transmit_str_P(PSTR("RAM write errors: "));
    3570:	8b e6       	ldi	r24, 0x6B	; 107
    3572:	93 e0       	ldi	r25, 0x03	; 3
    3574:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    usart_transmit_int32(RAMWriteErrors);
    3578:	60 91 69 05 	lds	r22, 0x0569
    357c:	70 91 6a 05 	lds	r23, 0x056A
    3580:	80 e0       	ldi	r24, 0x00	; 0
    3582:	90 e0       	ldi	r25, 0x00	; 0
    3584:	0e 94 25 06 	call	0xc4a	; 0xc4a <usart_transmit_int32>
    usart_newline();
    3588:	8a e0       	ldi	r24, 0x0A	; 10
    358a:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    358e:	8d e0       	ldi	r24, 0x0D	; 13
    3590:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    usart_transmit_str_P(PSTR("First Addr: "));
    3594:	8e e5       	ldi	r24, 0x5E	; 94
    3596:	93 e0       	ldi	r25, 0x03	; 3
    3598:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    usart_transmit_int32(RAMWriteErrorsAddrFirst);
    359c:	60 91 67 05 	lds	r22, 0x0567
    35a0:	70 91 68 05 	lds	r23, 0x0568
    35a4:	80 e0       	ldi	r24, 0x00	; 0
    35a6:	90 e0       	ldi	r25, 0x00	; 0
    35a8:	0e 94 25 06 	call	0xc4a	; 0xc4a <usart_transmit_int32>
    usart_newline();
    35ac:	8a e0       	ldi	r24, 0x0A	; 10
    35ae:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    35b2:	8d e0       	ldi	r24, 0x0D	; 13
    35b4:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    usart_transmit_str_P(PSTR("Last Addr: "));
    35b8:	82 e5       	ldi	r24, 0x52	; 82
    35ba:	93 e0       	ldi	r25, 0x03	; 3
    35bc:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    usart_transmit_int32(RAMWriteErrorsAddrLast);
    35c0:	60 91 65 05 	lds	r22, 0x0565
    35c4:	70 91 66 05 	lds	r23, 0x0566
    35c8:	80 e0       	ldi	r24, 0x00	; 0
    35ca:	90 e0       	ldi	r25, 0x00	; 0
    35cc:	0e 94 25 06 	call	0xc4a	; 0xc4a <usart_transmit_int32>
    usart_newline();
    35d0:	8a e0       	ldi	r24, 0x0A	; 10
    35d2:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    35d6:	8d e0       	ldi	r24, 0x0D	; 13
    35d8:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    35dc:	bc cf       	rjmp	.-136    	; 0x3556 <receive_save+0xd8>

000035de <show_menu>:
  4 - Dump a SRAM save to the PC
  5 - Flash diagnostic (confirm present)
  6 - UART settings (change BAUD)

*/
uint8_t show_menu(void) {
    35de:	1f 93       	push	r17

  uint8_t menuVal;
  
  while(1) {

    usart_clear_ht();
    35e0:	0e 94 74 08 	call	0x10e8	; 0x10e8 <usart_clear_ht>
    usart_transmit_str_P(PSTR("Welcome to Blake's GB flash cart\r\nChoose one of the following options\r\n\r\n"));
    35e4:	88 e9       	ldi	r24, 0x98	; 152
    35e6:	98 e0       	ldi	r25, 0x08	; 8
    35e8:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("0 - Show system and ROM information\r\n"));
    35ec:	82 e7       	ldi	r24, 0x72	; 114
    35ee:	98 e0       	ldi	r25, 0x08	; 8
    35f0:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("1 - Download new ROM to cart\r\n"));
    35f4:	83 e5       	ldi	r24, 0x53	; 83
    35f6:	98 e0       	ldi	r25, 0x08	; 8
    35f8:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("2 - Dump ROM to PC\r\n"));
    35fc:	8e e3       	ldi	r24, 0x3E	; 62
    35fe:	98 e0       	ldi	r25, 0x08	; 8
    3600:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("3 - Download save file to cart\r\n"));
    3604:	8d e1       	ldi	r24, 0x1D	; 29
    3606:	98 e0       	ldi	r25, 0x08	; 8
    3608:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("4 - Dump save file to PC\r\n"));
    360c:	82 e0       	ldi	r24, 0x02	; 2
    360e:	98 e0       	ldi	r25, 0x08	; 8
    3610:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("5 - View flash IC detection\r\n"));
    3614:	84 ee       	ldi	r24, 0xE4	; 228
    3616:	97 e0       	ldi	r25, 0x07	; 7
    3618:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("6 - Force MBC mode (for incorrect cartridge header or compatibility tests)\r\n"));
    361c:	87 e9       	ldi	r24, 0x97	; 151
    361e:	97 e0       	ldi	r25, 0x07	; 7
    3620:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("7 - Flash new cart firmware (must be <56KB due to placement of bootloader)\r\n"));
    3624:	8a e4       	ldi	r24, 0x4A	; 74
    3626:	97 e0       	ldi	r25, 0x07	; 7
    3628:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("8 - Debug option for testing stuff\r\n"));
    362c:	85 e2       	ldi	r24, 0x25	; 37
    362e:	97 e0       	ldi	r25, 0x07	; 7
    3630:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("\r\nDisconnect the cable before using the cart in a Gameboy!\r\n"));
    3634:	88 ee       	ldi	r24, 0xE8	; 232
    3636:	96 e0       	ldi	r25, 0x06	; 6
    3638:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

    usart_transmit_str_P(PSTR("\r\nUser selection: "));
    363c:	85 ed       	ldi	r24, 0xD5	; 213
    363e:	96 e0       	ldi	r25, 0x06	; 6
    3640:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
    
    menuVal = usart_receive() - '0';
    3644:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
    3648:	18 2f       	mov	r17, r24
    364a:	10 53       	subi	r17, 0x30	; 48
    usart_transmit(menuVal + '0');
    364c:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    usart_newline();
    3650:	8a e0       	ldi	r24, 0x0A	; 10
    3652:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>
    3656:	8d e0       	ldi	r24, 0x0D	; 13
    3658:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <usart_transmit>

    if(menuVal == MENU_ROM_INFO) {
    365c:	11 23       	and	r17, r17
    365e:	09 f1       	breq	.+66     	; 0x36a2 <show_menu+0xc4>
      show_ROM_info();

    } else if (menuVal == MENU_RX_ROM) {
    3660:	11 30       	cpi	r17, 0x01	; 1
    3662:	11 f1       	breq	.+68     	; 0x36a8 <show_menu+0xca>
      receive_ROM();

    } else if(menuVal == MENU_DUMP_ROM) {
    3664:	12 30       	cpi	r17, 0x02	; 2
    3666:	19 f1       	breq	.+70     	; 0x36ae <show_menu+0xd0>
      dump_ROM();

    } else if(menuVal == MENU_RX_SAVE) {
    3668:	13 30       	cpi	r17, 0x03	; 3
    366a:	e1 f1       	breq	.+120    	; 0x36e4 <show_menu+0x106>
      receive_save();
    
    } else if(menuVal == MENU_DUMP_SAVE) {
    366c:	14 30       	cpi	r17, 0x04	; 4
    366e:	e9 f1       	breq	.+122    	; 0x36ea <show_menu+0x10c>
      dump_save();
    
    } else if(menuVal == MENU_FLASH_DIAG) {
    3670:	15 30       	cpi	r17, 0x05	; 5
    3672:	09 f4       	brne	.+2      	; 0x3676 <show_menu+0x98>
    3674:	57 c0       	rjmp	.+174    	; 0x3724 <show_menu+0x146>
      flash_diagnostic();
    
    } else if(menuVal == MENU_FORCE_MBC) {
    3676:	16 30       	cpi	r17, 0x06	; 6
    3678:	09 f4       	brne	.+2      	; 0x367c <show_menu+0x9e>
    367a:	83 c0       	rjmp	.+262    	; 0x3782 <show_menu+0x1a4>
      force_mbc_mode();

    } else if(menuVal == MENU_NEW_FW) {
    367c:	17 30       	cpi	r17, 0x07	; 7
    367e:	09 f4       	brne	.+2      	; 0x3682 <show_menu+0xa4>
    3680:	83 c0       	rjmp	.+262    	; 0x3788 <show_menu+0x1aa>
      flash_new_firmware();

    } else if(menuVal == MENU_DEBUG) {
    3682:	18 30       	cpi	r17, 0x08	; 8
    3684:	09 f4       	brne	.+2      	; 0x3688 <show_menu+0xaa>
    3686:	b0 c0       	rjmp	.+352    	; 0x37e8 <show_menu+0x20a>
      debug_option();      

    } else {

      usart_transmit_str_P(PSTR("Unknown request\r\n"));
    3688:	83 ec       	ldi	r24, 0xC3	; 195
    368a:	96 e0       	ldi	r25, 0x06	; 6
    368c:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    3690:	86 e3       	ldi	r24, 0x36	; 54
    3692:	91 e0       	ldi	r25, 0x01	; 1
    3694:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    3698:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    369c:	80 32       	cpi	r24, 0x20	; 32
    369e:	e1 f7       	brne	.-8      	; 0x3698 <show_menu+0xba>
    36a0:	9f cf       	rjmp	.-194    	; 0x35e0 <show_menu+0x2>
    menuVal = usart_receive() - '0';
    usart_transmit(menuVal + '0');
    usart_newline();

    if(menuVal == MENU_ROM_INFO) {
      show_ROM_info();
    36a2:	0e 94 88 16 	call	0x2d10	; 0x2d10 <show_ROM_info>
    36a6:	9c cf       	rjmp	.-200    	; 0x35e0 <show_menu+0x2>

    } else if (menuVal == MENU_RX_ROM) {
      receive_ROM();
    36a8:	0e 94 ba 18 	call	0x3174	; 0x3174 <receive_ROM>
    36ac:	99 cf       	rjmp	.-206    	; 0x35e0 <show_menu+0x2>
  return 0;
}

uint8_t dump_ROM() {

  usart_transmit_str_P(PSTR("Confirm you wish to dump the current ROM (Y/N)\r\n"));
    36ae:	88 e6       	ldi	r24, 0x68	; 104
    36b0:	94 e0       	ldi	r25, 0x04	; 4
    36b2:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

uint8_t wait_for_confirm_cancel() {
  
  char input; 
  do {
    input = usart_receive();
    36b6:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while((input != 'Y') && (input != 'N') && (input != 'y') && (input != 'n'));
    36ba:	89 35       	cpi	r24, 0x59	; 89
    36bc:	b1 f1       	breq	.+108    	; 0x372a <show_menu+0x14c>
    36be:	8e 34       	cpi	r24, 0x4E	; 78
    36c0:	21 f0       	breq	.+8      	; 0x36ca <show_menu+0xec>
    36c2:	89 37       	cpi	r24, 0x79	; 121
    36c4:	91 f1       	breq	.+100    	; 0x372a <show_menu+0x14c>
    36c6:	8e 36       	cpi	r24, 0x6E	; 110
    36c8:	b1 f7       	brne	.-20     	; 0x36b6 <show_menu+0xd8>

  usart_transmit_str_P(PSTR("Confirm you wish to dump the current ROM (Y/N)\r\n"));

  if(wait_for_confirm_cancel()) {
    // Abort
    usart_transmit_str_P(commonAbort);
    36ca:	82 e6       	ldi	r24, 0x62	; 98
    36cc:	91 e0       	ldi	r25, 0x01	; 1
    36ce:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    36d2:	86 e3       	ldi	r24, 0x36	; 54
    36d4:	91 e0       	ldi	r25, 0x01	; 1
    36d6:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    36da:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    36de:	80 32       	cpi	r24, 0x20	; 32
    36e0:	e1 f7       	brne	.-8      	; 0x36da <show_menu+0xfc>
    36e2:	7e cf       	rjmp	.-260    	; 0x35e0 <show_menu+0x2>

    } else if(menuVal == MENU_DUMP_ROM) {
      dump_ROM();

    } else if(menuVal == MENU_RX_SAVE) {
      receive_save();
    36e4:	0e 94 3f 1a 	call	0x347e	; 0x347e <receive_save>
    36e8:	7b cf       	rjmp	.-266    	; 0x35e0 <show_menu+0x2>
  return 0;
}

uint8_t dump_save() {

  usart_transmit_str_P(PSTR("Confirm you wish to dump the current save file (Y/N)\r\n"));
    36ea:	8b e1       	ldi	r24, 0x1B	; 27
    36ec:	93 e0       	ldi	r25, 0x03	; 3
    36ee:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

uint8_t wait_for_confirm_cancel() {
  
  char input; 
  do {
    input = usart_receive();
    36f2:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while((input != 'Y') && (input != 'N') && (input != 'y') && (input != 'n'));
    36f6:	89 35       	cpi	r24, 0x59	; 89
    36f8:	09 f4       	brne	.+2      	; 0x36fc <show_menu+0x11e>
    36fa:	51 c0       	rjmp	.+162    	; 0x379e <show_menu+0x1c0>
    36fc:	8e 34       	cpi	r24, 0x4E	; 78
    36fe:	29 f0       	breq	.+10     	; 0x370a <show_menu+0x12c>
    3700:	89 37       	cpi	r24, 0x79	; 121
    3702:	09 f4       	brne	.+2      	; 0x3706 <show_menu+0x128>
    3704:	4c c0       	rjmp	.+152    	; 0x379e <show_menu+0x1c0>
    3706:	8e 36       	cpi	r24, 0x6E	; 110
    3708:	a1 f7       	brne	.-24     	; 0x36f2 <show_menu+0x114>

  usart_transmit_str_P(PSTR("Confirm you wish to dump the current save file (Y/N)\r\n"));

  if(wait_for_confirm_cancel()) {
    // Abort
    usart_transmit_str_P(commonAbort);
    370a:	82 e6       	ldi	r24, 0x62	; 98
    370c:	91 e0       	ldi	r25, 0x01	; 1
    370e:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    3712:	86 e3       	ldi	r24, 0x36	; 54
    3714:	91 e0       	ldi	r25, 0x01	; 1
    3716:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    371a:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    371e:	80 32       	cpi	r24, 0x20	; 32
    3720:	e1 f7       	brne	.-8      	; 0x371a <show_menu+0x13c>
    3722:	5e cf       	rjmp	.-324    	; 0x35e0 <show_menu+0x2>
    
    } else if(menuVal == MENU_DUMP_SAVE) {
      dump_save();
    
    } else if(menuVal == MENU_FLASH_DIAG) {
      flash_diagnostic();
    3724:	0e 94 38 18 	call	0x3070	; 0x3070 <flash_diagnostic>
    3728:	5b cf       	rjmp	.-330    	; 0x35e0 <show_menu+0x2>
    usart_transmit_str_P(commonAbort);
    wait_for_continue();
    return 1;
  }

  usart_transmit_str_P(PSTR("Select YMODEM receive on your terminal to download. AVR will be waiting\r\n"));
    372a:	8e e1       	ldi	r24, 0x1E	; 30
    372c:	94 e0       	ldi	r25, 0x04	; 4
    372e:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  flashAddress.address32 = 0; // Reset the address again
    3732:	10 92 61 05 	sts	0x0561, r1
    3736:	10 92 62 05 	sts	0x0562, r1
    373a:	10 92 63 05 	sts	0x0563, r1
    373e:	10 92 64 05 	sts	0x0564, r1

  // Two different cases here for naming convention at the other end!
  // Might change this later to take the game name from the ROM and send that through
  if(gbRomData.CGBsupport != GB_PRE_CGB) {
    3742:	80 91 9a 05 	lds	r24, 0x059A
    3746:	88 23       	and	r24, r24
    3748:	09 f4       	brne	.+2      	; 0x374c <show_menu+0x16e>
    374a:	5b c0       	rjmp	.+182    	; 0x3802 <show_menu+0x224>
    ymodem_send(flash_buff_send, "GBDump.gbc", gbRomData.ROMsizeBytes);
    374c:	20 91 7d 05 	lds	r18, 0x057D
    3750:	30 91 7e 05 	lds	r19, 0x057E
    3754:	40 91 7f 05 	lds	r20, 0x057F
    3758:	50 91 80 05 	lds	r21, 0x0580
    375c:	8c eb       	ldi	r24, 0xBC	; 188
    375e:	95 e1       	ldi	r25, 0x15	; 21
    3760:	65 e3       	ldi	r22, 0x35	; 53
    3762:	71 e0       	ldi	r23, 0x01	; 1
    3764:	0e 94 3a 0c 	call	0x1874	; 0x1874 <ymodem_send>
  } else {
    ymodem_send(flash_buff_send, "GBDump.gb", gbRomData.ROMsizeBytes);
  }
  
  usart_transmit_str_P(PSTR("File sent!\r\n"));
    3768:	81 e1       	ldi	r24, 0x11	; 17
    376a:	94 e0       	ldi	r25, 0x04	; 4
    376c:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    3770:	86 e3       	ldi	r24, 0x36	; 54
    3772:	91 e0       	ldi	r25, 0x01	; 1
    3774:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    3778:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    377c:	80 32       	cpi	r24, 0x20	; 32
    377e:	e1 f7       	brne	.-8      	; 0x3778 <show_menu+0x19a>
    3780:	2f cf       	rjmp	.-418    	; 0x35e0 <show_menu+0x2>
    
    } else if(menuVal == MENU_FLASH_DIAG) {
      flash_diagnostic();
    
    } else if(menuVal == MENU_FORCE_MBC) {
      force_mbc_mode();
    3782:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <force_mbc_mode>
    3786:	2c cf       	rjmp	.-424    	; 0x35e0 <show_menu+0x2>
}

uint8_t flash_new_firmware() { 

  // Run the bootloader
  asm("jmp 0xE000");
    3788:	0c 94 00 70 	jmp	0xe000	; 0xe000 <MBC3_RTC_RTC_END5+0x5208>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    378c:	86 e3       	ldi	r24, 0x36	; 54
    378e:	91 e0       	ldi	r25, 0x01	; 1
    3790:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    3794:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    3798:	80 32       	cpi	r24, 0x20	; 32
    379a:	e1 f7       	brne	.-8      	; 0x3794 <show_menu+0x1b6>
    379c:	21 cf       	rjmp	.-446    	; 0x35e0 <show_menu+0x2>
    usart_transmit_str_P(commonAbort);
    wait_for_continue();
    return 1;
  }

  usart_transmit_str_P(PSTR("Select YMODEM receive on your terminal to download. AVR will be waiting\r\n"));
    379e:	81 ed       	ldi	r24, 0xD1	; 209
    37a0:	92 e0       	ldi	r25, 0x02	; 2
    37a2:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  RAMaddress = 0;
    37a6:	10 92 4e 01 	sts	0x014E, r1
    37aa:	10 92 4f 01 	sts	0x014F, r1
    37ae:	10 92 50 01 	sts	0x0150, r1
    37b2:	10 92 51 01 	sts	0x0151, r1
  ymodem_send(sram_buff_send, "GBDump.sav", gbRomData.RAMsizeBytes);
    37b6:	20 91 82 05 	lds	r18, 0x0582
    37ba:	30 91 83 05 	lds	r19, 0x0583
    37be:	40 e0       	ldi	r20, 0x00	; 0
    37c0:	50 e0       	ldi	r21, 0x00	; 0
    37c2:	82 e5       	ldi	r24, 0x52	; 82
    37c4:	95 e1       	ldi	r25, 0x15	; 21
    37c6:	6a e2       	ldi	r22, 0x2A	; 42
    37c8:	71 e0       	ldi	r23, 0x01	; 1
    37ca:	0e 94 3a 0c 	call	0x1874	; 0x1874 <ymodem_send>

  usart_transmit_str_P(PSTR("File sent!\r\n"));
    37ce:	84 ec       	ldi	r24, 0xC4	; 196
    37d0:	92 e0       	ldi	r25, 0x02	; 2
    37d2:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    37d6:	86 e3       	ldi	r24, 0x36	; 54
    37d8:	91 e0       	ldi	r25, 0x01	; 1
    37da:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    37de:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    37e2:	80 32       	cpi	r24, 0x20	; 32
    37e4:	e1 f7       	brne	.-8      	; 0x37de <show_menu+0x200>
    37e6:	fc ce       	rjmp	.-520    	; 0x35e0 <show_menu+0x2>
  return 0;
}

void debug_option() {

  usart_transmit_str_P(PSTR("Nothing to see here!\r\n"));
    37e8:	82 e9       	ldi	r24, 0x92	; 146
    37ea:	91 e0       	ldi	r25, 0x01	; 1
    37ec:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    37f0:	86 e3       	ldi	r24, 0x36	; 54
    37f2:	91 e0       	ldi	r25, 0x01	; 1
    37f4:	0e 94 0f 06 	call	0xc1e	; 0xc1e <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    37f8:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <usart_receive>
  } while(input != ' ');
    37fc:	80 32       	cpi	r24, 0x20	; 32
    37fe:	e1 f7       	brne	.-8      	; 0x37f8 <show_menu+0x21a>
    3800:	ef ce       	rjmp	.-546    	; 0x35e0 <show_menu+0x2>
  // Two different cases here for naming convention at the other end!
  // Might change this later to take the game name from the ROM and send that through
  if(gbRomData.CGBsupport != GB_PRE_CGB) {
    ymodem_send(flash_buff_send, "GBDump.gbc", gbRomData.ROMsizeBytes);
  } else {
    ymodem_send(flash_buff_send, "GBDump.gb", gbRomData.ROMsizeBytes);
    3802:	20 91 7d 05 	lds	r18, 0x057D
    3806:	30 91 7e 05 	lds	r19, 0x057E
    380a:	40 91 7f 05 	lds	r20, 0x057F
    380e:	50 91 80 05 	lds	r21, 0x0580
    3812:	8c eb       	ldi	r24, 0xBC	; 188
    3814:	95 e1       	ldi	r25, 0x15	; 21
    3816:	60 e4       	ldi	r22, 0x40	; 64
    3818:	71 e0       	ldi	r23, 0x01	; 1
    381a:	0e 94 3a 0c 	call	0x1874	; 0x1874 <ymodem_send>
    381e:	a4 cf       	rjmp	.-184    	; 0x3768 <show_menu+0x18a>

00003820 <get_GBROM_info>:
#define READ_FLASH_BYTE_FUNCTION  mac_flash_read_byte

// Gameboy global variables
GBROMDATA gbRomData;

void get_GBROM_info(GBROMDATA *gbromData) {
    3820:	cf 93       	push	r28
    3822:	df 93       	push	r29
    3824:	ec 01       	movw	r28, r24

  flashAddress.address32 = 0x0134; // Offset to filename
    3826:	84 e3       	ldi	r24, 0x34	; 52
    3828:	91 e0       	ldi	r25, 0x01	; 1
    382a:	a0 e0       	ldi	r26, 0x00	; 0
    382c:	b0 e0       	ldi	r27, 0x00	; 0
    382e:	80 93 61 05 	sts	0x0561, r24
    3832:	90 93 62 05 	sts	0x0562, r25
    3836:	a0 93 63 05 	sts	0x0563, r26
    383a:	b0 93 64 05 	sts	0x0564, r27
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    383e:	64 e3       	ldi	r22, 0x34	; 52
    3840:	71 e0       	ldi	r23, 0x01	; 1
    3842:	80 e0       	ldi	r24, 0x00	; 0
    3844:	90 e0       	ldi	r25, 0x00	; 0
    3846:	ae 01       	movw	r20, r28
    3848:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    384c:	60 91 61 05 	lds	r22, 0x0561
    3850:	70 91 62 05 	lds	r23, 0x0562
    3854:	80 91 63 05 	lds	r24, 0x0563
    3858:	90 91 64 05 	lds	r25, 0x0564
    385c:	6f 5f       	subi	r22, 0xFF	; 255
    385e:	7f 4f       	sbci	r23, 0xFF	; 255
    3860:	8f 4f       	sbci	r24, 0xFF	; 255
    3862:	9f 4f       	sbci	r25, 0xFF	; 255
    3864:	60 93 61 05 	sts	0x0561, r22
    3868:	70 93 62 05 	sts	0x0562, r23
    386c:	80 93 63 05 	sts	0x0563, r24
    3870:	90 93 64 05 	sts	0x0564, r25
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    3874:	ae 01       	movw	r20, r28
    3876:	4f 5f       	subi	r20, 0xFF	; 255
    3878:	5f 4f       	sbci	r21, 0xFF	; 255
    387a:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    387e:	60 91 61 05 	lds	r22, 0x0561
    3882:	70 91 62 05 	lds	r23, 0x0562
    3886:	80 91 63 05 	lds	r24, 0x0563
    388a:	90 91 64 05 	lds	r25, 0x0564
    388e:	6f 5f       	subi	r22, 0xFF	; 255
    3890:	7f 4f       	sbci	r23, 0xFF	; 255
    3892:	8f 4f       	sbci	r24, 0xFF	; 255
    3894:	9f 4f       	sbci	r25, 0xFF	; 255
    3896:	60 93 61 05 	sts	0x0561, r22
    389a:	70 93 62 05 	sts	0x0562, r23
    389e:	80 93 63 05 	sts	0x0563, r24
    38a2:	90 93 64 05 	sts	0x0564, r25
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    38a6:	ae 01       	movw	r20, r28
    38a8:	4e 5f       	subi	r20, 0xFE	; 254
    38aa:	5f 4f       	sbci	r21, 0xFF	; 255
    38ac:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    38b0:	60 91 61 05 	lds	r22, 0x0561
    38b4:	70 91 62 05 	lds	r23, 0x0562
    38b8:	80 91 63 05 	lds	r24, 0x0563
    38bc:	90 91 64 05 	lds	r25, 0x0564
    38c0:	6f 5f       	subi	r22, 0xFF	; 255
    38c2:	7f 4f       	sbci	r23, 0xFF	; 255
    38c4:	8f 4f       	sbci	r24, 0xFF	; 255
    38c6:	9f 4f       	sbci	r25, 0xFF	; 255
    38c8:	60 93 61 05 	sts	0x0561, r22
    38cc:	70 93 62 05 	sts	0x0562, r23
    38d0:	80 93 63 05 	sts	0x0563, r24
    38d4:	90 93 64 05 	sts	0x0564, r25
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    38d8:	ae 01       	movw	r20, r28
    38da:	4d 5f       	subi	r20, 0xFD	; 253
    38dc:	5f 4f       	sbci	r21, 0xFF	; 255
    38de:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    38e2:	60 91 61 05 	lds	r22, 0x0561
    38e6:	70 91 62 05 	lds	r23, 0x0562
    38ea:	80 91 63 05 	lds	r24, 0x0563
    38ee:	90 91 64 05 	lds	r25, 0x0564
    38f2:	6f 5f       	subi	r22, 0xFF	; 255
    38f4:	7f 4f       	sbci	r23, 0xFF	; 255
    38f6:	8f 4f       	sbci	r24, 0xFF	; 255
    38f8:	9f 4f       	sbci	r25, 0xFF	; 255
    38fa:	60 93 61 05 	sts	0x0561, r22
    38fe:	70 93 62 05 	sts	0x0562, r23
    3902:	80 93 63 05 	sts	0x0563, r24
    3906:	90 93 64 05 	sts	0x0564, r25
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    390a:	ae 01       	movw	r20, r28
    390c:	4c 5f       	subi	r20, 0xFC	; 252
    390e:	5f 4f       	sbci	r21, 0xFF	; 255
    3910:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3914:	60 91 61 05 	lds	r22, 0x0561
    3918:	70 91 62 05 	lds	r23, 0x0562
    391c:	80 91 63 05 	lds	r24, 0x0563
    3920:	90 91 64 05 	lds	r25, 0x0564
    3924:	6f 5f       	subi	r22, 0xFF	; 255
    3926:	7f 4f       	sbci	r23, 0xFF	; 255
    3928:	8f 4f       	sbci	r24, 0xFF	; 255
    392a:	9f 4f       	sbci	r25, 0xFF	; 255
    392c:	60 93 61 05 	sts	0x0561, r22
    3930:	70 93 62 05 	sts	0x0562, r23
    3934:	80 93 63 05 	sts	0x0563, r24
    3938:	90 93 64 05 	sts	0x0564, r25
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    393c:	ae 01       	movw	r20, r28
    393e:	4b 5f       	subi	r20, 0xFB	; 251
    3940:	5f 4f       	sbci	r21, 0xFF	; 255
    3942:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3946:	60 91 61 05 	lds	r22, 0x0561
    394a:	70 91 62 05 	lds	r23, 0x0562
    394e:	80 91 63 05 	lds	r24, 0x0563
    3952:	90 91 64 05 	lds	r25, 0x0564
    3956:	6f 5f       	subi	r22, 0xFF	; 255
    3958:	7f 4f       	sbci	r23, 0xFF	; 255
    395a:	8f 4f       	sbci	r24, 0xFF	; 255
    395c:	9f 4f       	sbci	r25, 0xFF	; 255
    395e:	60 93 61 05 	sts	0x0561, r22
    3962:	70 93 62 05 	sts	0x0562, r23
    3966:	80 93 63 05 	sts	0x0563, r24
    396a:	90 93 64 05 	sts	0x0564, r25
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    396e:	ae 01       	movw	r20, r28
    3970:	4a 5f       	subi	r20, 0xFA	; 250
    3972:	5f 4f       	sbci	r21, 0xFF	; 255
    3974:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3978:	60 91 61 05 	lds	r22, 0x0561
    397c:	70 91 62 05 	lds	r23, 0x0562
    3980:	80 91 63 05 	lds	r24, 0x0563
    3984:	90 91 64 05 	lds	r25, 0x0564
    3988:	6f 5f       	subi	r22, 0xFF	; 255
    398a:	7f 4f       	sbci	r23, 0xFF	; 255
    398c:	8f 4f       	sbci	r24, 0xFF	; 255
    398e:	9f 4f       	sbci	r25, 0xFF	; 255
    3990:	60 93 61 05 	sts	0x0561, r22
    3994:	70 93 62 05 	sts	0x0562, r23
    3998:	80 93 63 05 	sts	0x0563, r24
    399c:	90 93 64 05 	sts	0x0564, r25
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    39a0:	ae 01       	movw	r20, r28
    39a2:	49 5f       	subi	r20, 0xF9	; 249
    39a4:	5f 4f       	sbci	r21, 0xFF	; 255
    39a6:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    39aa:	60 91 61 05 	lds	r22, 0x0561
    39ae:	70 91 62 05 	lds	r23, 0x0562
    39b2:	80 91 63 05 	lds	r24, 0x0563
    39b6:	90 91 64 05 	lds	r25, 0x0564
    39ba:	6f 5f       	subi	r22, 0xFF	; 255
    39bc:	7f 4f       	sbci	r23, 0xFF	; 255
    39be:	8f 4f       	sbci	r24, 0xFF	; 255
    39c0:	9f 4f       	sbci	r25, 0xFF	; 255
    39c2:	60 93 61 05 	sts	0x0561, r22
    39c6:	70 93 62 05 	sts	0x0562, r23
    39ca:	80 93 63 05 	sts	0x0563, r24
    39ce:	90 93 64 05 	sts	0x0564, r25
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    39d2:	ae 01       	movw	r20, r28
    39d4:	48 5f       	subi	r20, 0xF8	; 248
    39d6:	5f 4f       	sbci	r21, 0xFF	; 255
    39d8:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    39dc:	60 91 61 05 	lds	r22, 0x0561
    39e0:	70 91 62 05 	lds	r23, 0x0562
    39e4:	80 91 63 05 	lds	r24, 0x0563
    39e8:	90 91 64 05 	lds	r25, 0x0564
    39ec:	6f 5f       	subi	r22, 0xFF	; 255
    39ee:	7f 4f       	sbci	r23, 0xFF	; 255
    39f0:	8f 4f       	sbci	r24, 0xFF	; 255
    39f2:	9f 4f       	sbci	r25, 0xFF	; 255
    39f4:	60 93 61 05 	sts	0x0561, r22
    39f8:	70 93 62 05 	sts	0x0562, r23
    39fc:	80 93 63 05 	sts	0x0563, r24
    3a00:	90 93 64 05 	sts	0x0564, r25
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    3a04:	ae 01       	movw	r20, r28
    3a06:	47 5f       	subi	r20, 0xF7	; 247
    3a08:	5f 4f       	sbci	r21, 0xFF	; 255
    3a0a:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3a0e:	60 91 61 05 	lds	r22, 0x0561
    3a12:	70 91 62 05 	lds	r23, 0x0562
    3a16:	80 91 63 05 	lds	r24, 0x0563
    3a1a:	90 91 64 05 	lds	r25, 0x0564
    3a1e:	6f 5f       	subi	r22, 0xFF	; 255
    3a20:	7f 4f       	sbci	r23, 0xFF	; 255
    3a22:	8f 4f       	sbci	r24, 0xFF	; 255
    3a24:	9f 4f       	sbci	r25, 0xFF	; 255
    3a26:	60 93 61 05 	sts	0x0561, r22
    3a2a:	70 93 62 05 	sts	0x0562, r23
    3a2e:	80 93 63 05 	sts	0x0563, r24
    3a32:	90 93 64 05 	sts	0x0564, r25
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    3a36:	ae 01       	movw	r20, r28
    3a38:	46 5f       	subi	r20, 0xF6	; 246
    3a3a:	5f 4f       	sbci	r21, 0xFF	; 255
    3a3c:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3a40:	60 91 61 05 	lds	r22, 0x0561
    3a44:	70 91 62 05 	lds	r23, 0x0562
    3a48:	80 91 63 05 	lds	r24, 0x0563
    3a4c:	90 91 64 05 	lds	r25, 0x0564
    3a50:	6f 5f       	subi	r22, 0xFF	; 255
    3a52:	7f 4f       	sbci	r23, 0xFF	; 255
    3a54:	8f 4f       	sbci	r24, 0xFF	; 255
    3a56:	9f 4f       	sbci	r25, 0xFF	; 255
    3a58:	60 93 61 05 	sts	0x0561, r22
    3a5c:	70 93 62 05 	sts	0x0562, r23
    3a60:	80 93 63 05 	sts	0x0563, r24
    3a64:	90 93 64 05 	sts	0x0564, r25
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    3a68:	ae 01       	movw	r20, r28
    3a6a:	45 5f       	subi	r20, 0xF5	; 245
    3a6c:	5f 4f       	sbci	r21, 0xFF	; 255
    3a6e:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3a72:	60 91 61 05 	lds	r22, 0x0561
    3a76:	70 91 62 05 	lds	r23, 0x0562
    3a7a:	80 91 63 05 	lds	r24, 0x0563
    3a7e:	90 91 64 05 	lds	r25, 0x0564
    3a82:	6f 5f       	subi	r22, 0xFF	; 255
    3a84:	7f 4f       	sbci	r23, 0xFF	; 255
    3a86:	8f 4f       	sbci	r24, 0xFF	; 255
    3a88:	9f 4f       	sbci	r25, 0xFF	; 255
    3a8a:	60 93 61 05 	sts	0x0561, r22
    3a8e:	70 93 62 05 	sts	0x0562, r23
    3a92:	80 93 63 05 	sts	0x0563, r24
    3a96:	90 93 64 05 	sts	0x0564, r25
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    3a9a:	ae 01       	movw	r20, r28
    3a9c:	44 5f       	subi	r20, 0xF4	; 244
    3a9e:	5f 4f       	sbci	r21, 0xFF	; 255
    3aa0:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3aa4:	60 91 61 05 	lds	r22, 0x0561
    3aa8:	70 91 62 05 	lds	r23, 0x0562
    3aac:	80 91 63 05 	lds	r24, 0x0563
    3ab0:	90 91 64 05 	lds	r25, 0x0564
    3ab4:	6f 5f       	subi	r22, 0xFF	; 255
    3ab6:	7f 4f       	sbci	r23, 0xFF	; 255
    3ab8:	8f 4f       	sbci	r24, 0xFF	; 255
    3aba:	9f 4f       	sbci	r25, 0xFF	; 255
    3abc:	60 93 61 05 	sts	0x0561, r22
    3ac0:	70 93 62 05 	sts	0x0562, r23
    3ac4:	80 93 63 05 	sts	0x0563, r24
    3ac8:	90 93 64 05 	sts	0x0564, r25
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    3acc:	ae 01       	movw	r20, r28
    3ace:	43 5f       	subi	r20, 0xF3	; 243
    3ad0:	5f 4f       	sbci	r21, 0xFF	; 255
    3ad2:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3ad6:	60 91 61 05 	lds	r22, 0x0561
    3ada:	70 91 62 05 	lds	r23, 0x0562
    3ade:	80 91 63 05 	lds	r24, 0x0563
    3ae2:	90 91 64 05 	lds	r25, 0x0564
    3ae6:	6f 5f       	subi	r22, 0xFF	; 255
    3ae8:	7f 4f       	sbci	r23, 0xFF	; 255
    3aea:	8f 4f       	sbci	r24, 0xFF	; 255
    3aec:	9f 4f       	sbci	r25, 0xFF	; 255
    3aee:	60 93 61 05 	sts	0x0561, r22
    3af2:	70 93 62 05 	sts	0x0562, r23
    3af6:	80 93 63 05 	sts	0x0563, r24
    3afa:	90 93 64 05 	sts	0x0564, r25
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    3afe:	ae 01       	movw	r20, r28
    3b00:	42 5f       	subi	r20, 0xF2	; 242
    3b02:	5f 4f       	sbci	r21, 0xFF	; 255
    3b04:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3b08:	60 91 61 05 	lds	r22, 0x0561
    3b0c:	70 91 62 05 	lds	r23, 0x0562
    3b10:	80 91 63 05 	lds	r24, 0x0563
    3b14:	90 91 64 05 	lds	r25, 0x0564
    3b18:	6f 5f       	subi	r22, 0xFF	; 255
    3b1a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b1c:	8f 4f       	sbci	r24, 0xFF	; 255
    3b1e:	9f 4f       	sbci	r25, 0xFF	; 255
    3b20:	60 93 61 05 	sts	0x0561, r22
    3b24:	70 93 62 05 	sts	0x0562, r23
    3b28:	80 93 63 05 	sts	0x0563, r24
    3b2c:	90 93 64 05 	sts	0x0564, r25
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    3b30:	ae 01       	movw	r20, r28
    3b32:	41 5f       	subi	r20, 0xF1	; 241
    3b34:	5f 4f       	sbci	r21, 0xFF	; 255
    3b36:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3b3a:	60 91 61 05 	lds	r22, 0x0561
    3b3e:	70 91 62 05 	lds	r23, 0x0562
    3b42:	80 91 63 05 	lds	r24, 0x0563
    3b46:	90 91 64 05 	lds	r25, 0x0564
    3b4a:	6f 5f       	subi	r22, 0xFF	; 255
    3b4c:	7f 4f       	sbci	r23, 0xFF	; 255
    3b4e:	8f 4f       	sbci	r24, 0xFF	; 255
    3b50:	9f 4f       	sbci	r25, 0xFF	; 255
    3b52:	60 93 61 05 	sts	0x0561, r22
    3b56:	70 93 62 05 	sts	0x0562, r23
    3b5a:	80 93 63 05 	sts	0x0563, r24
    3b5e:	90 93 64 05 	sts	0x0564, r25
    READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).name[i]));
    3b62:	ae 01       	movw	r20, r28
    3b64:	40 5f       	subi	r20, 0xF0	; 240
    3b66:	5f 4f       	sbci	r21, 0xFF	; 255
    3b68:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>
  }
  (*gbromData).name[16] = '\0';
    3b6c:	18 8a       	std	Y+16, r1	; 0x10

  flashAddress.address32 = 0x0148;
    3b6e:	88 e4       	ldi	r24, 0x48	; 72
    3b70:	91 e0       	ldi	r25, 0x01	; 1
    3b72:	a0 e0       	ldi	r26, 0x00	; 0
    3b74:	b0 e0       	ldi	r27, 0x00	; 0
    3b76:	80 93 61 05 	sts	0x0561, r24
    3b7a:	90 93 62 05 	sts	0x0562, r25
    3b7e:	a0 93 63 05 	sts	0x0563, r26
    3b82:	b0 93 64 05 	sts	0x0564, r27
  READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).ROMsize));
    3b86:	ae 01       	movw	r20, r28
    3b88:	4f 5e       	subi	r20, 0xEF	; 239
    3b8a:	5f 4f       	sbci	r21, 0xFF	; 255
    3b8c:	68 e4       	ldi	r22, 0x48	; 72
    3b8e:	71 e0       	ldi	r23, 0x01	; 1
    3b90:	80 e0       	ldi	r24, 0x00	; 0
    3b92:	90 e0       	ldi	r25, 0x00	; 0
    3b94:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

  flashAddress.address32 = 0x0149;
    3b98:	89 e4       	ldi	r24, 0x49	; 73
    3b9a:	91 e0       	ldi	r25, 0x01	; 1
    3b9c:	a0 e0       	ldi	r26, 0x00	; 0
    3b9e:	b0 e0       	ldi	r27, 0x00	; 0
    3ba0:	80 93 61 05 	sts	0x0561, r24
    3ba4:	90 93 62 05 	sts	0x0562, r25
    3ba8:	a0 93 63 05 	sts	0x0563, r26
    3bac:	b0 93 64 05 	sts	0x0564, r27
  READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).RAMsize));
    3bb0:	ae 01       	movw	r20, r28
    3bb2:	4a 5e       	subi	r20, 0xEA	; 234
    3bb4:	5f 4f       	sbci	r21, 0xFF	; 255
    3bb6:	69 e4       	ldi	r22, 0x49	; 73
    3bb8:	71 e0       	ldi	r23, 0x01	; 1
    3bba:	80 e0       	ldi	r24, 0x00	; 0
    3bbc:	90 e0       	ldi	r25, 0x00	; 0
    3bbe:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

  flashAddress.address32 = 0x0147;
    3bc2:	87 e4       	ldi	r24, 0x47	; 71
    3bc4:	91 e0       	ldi	r25, 0x01	; 1
    3bc6:	a0 e0       	ldi	r26, 0x00	; 0
    3bc8:	b0 e0       	ldi	r27, 0x00	; 0
    3bca:	80 93 61 05 	sts	0x0561, r24
    3bce:	90 93 62 05 	sts	0x0562, r25
    3bd2:	a0 93 63 05 	sts	0x0563, r26
    3bd6:	b0 93 64 05 	sts	0x0564, r27
  READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).MBCtype));
    3bda:	ae 01       	movw	r20, r28
    3bdc:	47 5e       	subi	r20, 0xE7	; 231
    3bde:	5f 4f       	sbci	r21, 0xFF	; 255
    3be0:	67 e4       	ldi	r22, 0x47	; 71
    3be2:	71 e0       	ldi	r23, 0x01	; 1
    3be4:	80 e0       	ldi	r24, 0x00	; 0
    3be6:	90 e0       	ldi	r25, 0x00	; 0
    3be8:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

  flashAddress.address32 = 0x0143;
    3bec:	83 e4       	ldi	r24, 0x43	; 67
    3bee:	91 e0       	ldi	r25, 0x01	; 1
    3bf0:	a0 e0       	ldi	r26, 0x00	; 0
    3bf2:	b0 e0       	ldi	r27, 0x00	; 0
    3bf4:	80 93 61 05 	sts	0x0561, r24
    3bf8:	90 93 62 05 	sts	0x0562, r25
    3bfc:	a0 93 63 05 	sts	0x0563, r26
    3c00:	b0 93 64 05 	sts	0x0564, r27
  READ_FLASH_BYTE_FUNCTION(flashAddress, &((*gbromData).CGBsupport));
    3c04:	ae 01       	movw	r20, r28
    3c06:	41 5d       	subi	r20, 0xD1	; 209
    3c08:	5f 4f       	sbci	r21, 0xFF	; 255
    3c0a:	63 e4       	ldi	r22, 0x43	; 67
    3c0c:	71 e0       	ldi	r23, 0x01	; 1
    3c0e:	80 e0       	ldi	r24, 0x00	; 0
    3c10:	90 e0       	ldi	r25, 0x00	; 0
    3c12:	0e 94 9f 10 	call	0x213e	; 0x213e <mac_flash_read_byte>

  // Now fill out the additional GBROMDATA fields
  // Convert hex ROM size to bytes ROM size
  if((*gbromData).ROMsize == GBROM_32k) {
    3c16:	89 89       	ldd	r24, Y+17	; 0x11
    3c18:	88 23       	and	r24, r24
    3c1a:	09 f0       	breq	.+2      	; 0x3c1e <get_GBROM_info+0x3fe>
    3c1c:	52 c0       	rjmp	.+164    	; 0x3cc2 <get_GBROM_info+0x4a2>
    (*gbromData).ROMsizeBytes = 32768;
    3c1e:	80 e0       	ldi	r24, 0x00	; 0
    3c20:	90 e8       	ldi	r25, 0x80	; 128
    3c22:	a0 e0       	ldi	r26, 0x00	; 0
    3c24:	b0 e0       	ldi	r27, 0x00	; 0
    3c26:	8a 8b       	std	Y+18, r24	; 0x12
    3c28:	9b 8b       	std	Y+19, r25	; 0x13
    3c2a:	ac 8b       	std	Y+20, r26	; 0x14
    3c2c:	bd 8b       	std	Y+21, r27	; 0x15
  } else {
    (*gbromData).ROMsizeBytes = 0;
  }

  // Convert the RAM size
  if((*gbromData).RAMsize == GBRAM_0k) {
    3c2e:	8e 89       	ldd	r24, Y+22	; 0x16
    3c30:	88 23       	and	r24, r24
    3c32:	51 f0       	breq	.+20     	; 0x3c48 <get_GBROM_info+0x428>
    (*gbromData).RAMsizeBytes = 0;
  } else if((*gbromData).RAMsize == GBRAM_2k) {
    3c34:	81 30       	cpi	r24, 0x01	; 1
    3c36:	09 f4       	brne	.+2      	; 0x3c3a <get_GBROM_info+0x41a>
    3c38:	7a c0       	rjmp	.+244    	; 0x3d2e <get_GBROM_info+0x50e>
    (*gbromData).RAMsizeBytes = 2048;
  } else if((*gbromData).RAMsize == GBRAM_8k) {
    3c3a:	82 30       	cpi	r24, 0x02	; 2
    3c3c:	09 f4       	brne	.+2      	; 0x3c40 <get_GBROM_info+0x420>
    3c3e:	b3 c0       	rjmp	.+358    	; 0x3da6 <get_GBROM_info+0x586>
    (*gbromData).RAMsizeBytes = 8192;
  } else if((*gbromData).RAMsize == GBRAM_32k) {
    3c40:	83 30       	cpi	r24, 0x03	; 3
    3c42:	09 f4       	brne	.+2      	; 0x3c46 <get_GBROM_info+0x426>
    3c44:	89 c0       	rjmp	.+274    	; 0x3d58 <get_GBROM_info+0x538>
    (*gbromData).RAMsizeBytes = 32768;
  } else if((*gbromData).RAMsize == GBRAM_64k) {
    3c46:	85 30       	cpi	r24, 0x05	; 5
    (*gbromData).RAMsizeBytes = (uint32_t) 65536;
  } else if((*gbromData).RAMsize == GBRAM_128k) {
    (*gbromData).RAMsizeBytes = 131072UL;
  } else {
    (*gbromData).RAMsizeBytes = 0;
    3c48:	18 8e       	std	Y+24, r1	; 0x18
    3c4a:	1f 8a       	std	Y+23, r1	; 0x17
  }

  // Get the MBC mode name
  if((*gbromData).MBCtype == GBCART_ROM_ONLY) {
    3c4c:	89 8d       	ldd	r24, Y+25	; 0x19
    3c4e:	88 23       	and	r24, r24
    3c50:	09 f4       	brne	.+2      	; 0x3c54 <get_GBROM_info+0x434>
    3c52:	4d c0       	rjmp	.+154    	; 0x3cee <get_GBROM_info+0x4ce>
    strcpy_P((*gbromData).MBCname,PSTR("ROM only"));
  } else if((*gbromData).MBCtype == GBCART_MBC1) {
    3c54:	81 30       	cpi	r24, 0x01	; 1
    3c56:	09 f4       	brne	.+2      	; 0x3c5a <get_GBROM_info+0x43a>
    3c58:	96 c0       	rjmp	.+300    	; 0x3d86 <get_GBROM_info+0x566>
    strcpy_P((*gbromData).MBCname,PSTR("MBC1"));
  } else if((*gbromData).MBCtype == GBCART_MBC1_RAM) {
    3c5a:	82 30       	cpi	r24, 0x02	; 2
    3c5c:	09 f4       	brne	.+2      	; 0x3c60 <get_GBROM_info+0x440>
    3c5e:	75 c0       	rjmp	.+234    	; 0x3d4a <get_GBROM_info+0x52a>
    strcpy_P((*gbromData).MBCname,PSTR("MBC1 RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC1_RAM_BATT) {
    3c60:	83 30       	cpi	r24, 0x03	; 3
    3c62:	09 f4       	brne	.+2      	; 0x3c66 <get_GBROM_info+0x446>
    3c64:	ae c0       	rjmp	.+348    	; 0x3dc2 <get_GBROM_info+0x5a2>
    strcpy_P((*gbromData).MBCname,PSTR("MBC1 RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC5) {
    3c66:	89 31       	cpi	r24, 0x19	; 25
    3c68:	09 f4       	brne	.+2      	; 0x3c6c <get_GBROM_info+0x44c>
    3c6a:	b2 c0       	rjmp	.+356    	; 0x3dd0 <get_GBROM_info+0x5b0>
    strcpy_P((*gbromData).MBCname,PSTR("MBC5"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RAM) {
    3c6c:	8a 31       	cpi	r24, 0x1A	; 26
    3c6e:	09 f4       	brne	.+2      	; 0x3c72 <get_GBROM_info+0x452>
    3c70:	b6 c0       	rjmp	.+364    	; 0x3dde <get_GBROM_info+0x5be>
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RAM_BATT) {
    3c72:	8b 31       	cpi	r24, 0x1B	; 27
    3c74:	09 f4       	brne	.+2      	; 0x3c78 <get_GBROM_info+0x458>
    3c76:	d5 c0       	rjmp	.+426    	; 0x3e22 <get_GBROM_info+0x602>
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE) {
    3c78:	8c 31       	cpi	r24, 0x1C	; 28
    3c7a:	09 f4       	brne	.+2      	; 0x3c7e <get_GBROM_info+0x45e>
    3c7c:	c0 c0       	rjmp	.+384    	; 0x3dfe <get_GBROM_info+0x5de>
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE_RAM) {
    3c7e:	8d 31       	cpi	r24, 0x1D	; 29
    3c80:	09 f4       	brne	.+2      	; 0x3c84 <get_GBROM_info+0x464>
    3c82:	df c0       	rjmp	.+446    	; 0x3e42 <get_GBROM_info+0x622>
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE_RAM_BATT) {
    3c84:	8e 31       	cpi	r24, 0x1E	; 30
    3c86:	09 f4       	brne	.+2      	; 0x3c8a <get_GBROM_info+0x46a>
    3c88:	e3 c0       	rjmp	.+454    	; 0x3e50 <get_GBROM_info+0x630>
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC3_RTC_BATT) {
    3c8a:	8f 30       	cpi	r24, 0x0F	; 15
    3c8c:	09 f4       	brne	.+2      	; 0x3c90 <get_GBROM_info+0x470>
    3c8e:	f0 c0       	rjmp	.+480    	; 0x3e70 <get_GBROM_info+0x650>
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RTC BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC3_RTC_RAM_BATT) {
    3c90:	80 31       	cpi	r24, 0x10	; 16
    3c92:	09 f4       	brne	.+2      	; 0x3c96 <get_GBROM_info+0x476>
    3c94:	f4 c0       	rjmp	.+488    	; 0x3e7e <get_GBROM_info+0x65e>
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RTC RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC3) {
    3c96:	81 31       	cpi	r24, 0x11	; 17
    3c98:	09 f4       	brne	.+2      	; 0x3c9c <get_GBROM_info+0x47c>
    3c9a:	f8 c0       	rjmp	.+496    	; 0x3e8c <get_GBROM_info+0x66c>
    strcpy_P((*gbromData).MBCname,PSTR("MBC3"));
  } else if((*gbromData).MBCtype == GBCART_MBC3_RAM) {
    3c9c:	82 31       	cpi	r24, 0x12	; 18
    3c9e:	09 f4       	brne	.+2      	; 0x3ca2 <get_GBROM_info+0x482>
    3ca0:	07 c1       	rjmp	.+526    	; 0x3eb0 <get_GBROM_info+0x690>
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC3_RAM_BATT) {
    3ca2:	83 31       	cpi	r24, 0x13	; 19
    3ca4:	09 f4       	brne	.+2      	; 0x3ca8 <get_GBROM_info+0x488>
    3ca6:	0b c1       	rjmp	.+534    	; 0x3ebe <get_GBROM_info+0x69e>
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC2) {
    3ca8:	85 30       	cpi	r24, 0x05	; 5
    3caa:	09 f4       	brne	.+2      	; 0x3cae <get_GBROM_info+0x48e>
    3cac:	af c0       	rjmp	.+350    	; 0x3e0c <get_GBROM_info+0x5ec>
    strcpy_P((*gbromData).MBCname,PSTR("MBC2"));
    (*gbromData).RAMsizeBytes = 512; // Special case here, as MBC2 header may not disclose internal MBC RAM
  } else if((*gbromData).MBCtype == GBCART_MBC2_BATT) {
    3cae:	86 30       	cpi	r24, 0x06	; 6
    3cb0:	09 f4       	brne	.+2      	; 0x3cb4 <get_GBROM_info+0x494>
    3cb2:	f3 c0       	rjmp	.+486    	; 0x3e9a <get_GBROM_info+0x67a>
    strcpy_P((*gbromData).MBCname,PSTR("MBC2 BATT"));
    (*gbromData).RAMsizeBytes = 512; // Special case here, as MBC2 header may not disclose internal MBC RAM
  } else {
    strcpy_P((*gbromData).MBCname,PSTR("Unsupported MBC type"));
    3cb4:	ce 01       	movw	r24, r28
    3cb6:	4a 96       	adiw	r24, 0x1a	; 26
    3cb8:	64 e0       	ldi	r22, 0x04	; 4
    3cba:	79 e0       	ldi	r23, 0x09	; 9
    3cbc:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3cc0:	1c c0       	rjmp	.+56     	; 0x3cfa <get_GBROM_info+0x4da>

  // Now fill out the additional GBROMDATA fields
  // Convert hex ROM size to bytes ROM size
  if((*gbromData).ROMsize == GBROM_32k) {
    (*gbromData).ROMsizeBytes = 32768;
  } else if ((*gbromData).ROMsize == GBROM_64k) {
    3cc2:	81 30       	cpi	r24, 0x01	; 1
    3cc4:	c9 f1       	breq	.+114    	; 0x3d38 <get_GBROM_info+0x518>
    (*gbromData).ROMsizeBytes = 65536;
  } else if ((*gbromData).ROMsize == GBROM_128k) {
    3cc6:	82 30       	cpi	r24, 0x02	; 2
    3cc8:	09 f4       	brne	.+2      	; 0x3ccc <get_GBROM_info+0x4ac>
    3cca:	72 c0       	rjmp	.+228    	; 0x3db0 <get_GBROM_info+0x590>
    (*gbromData).ROMsizeBytes = 131072;
  } else if ((*gbromData).ROMsize == GBROM_256k) {
    3ccc:	83 30       	cpi	r24, 0x03	; 3
    3cce:	09 f4       	brne	.+2      	; 0x3cd2 <get_GBROM_info+0x4b2>
    3cd0:	48 c0       	rjmp	.+144    	; 0x3d62 <get_GBROM_info+0x542>
    (*gbromData).ROMsizeBytes = 262144;
  } else if ((*gbromData).ROMsize == GBROM_512k) {
    3cd2:	84 30       	cpi	r24, 0x04	; 4
    3cd4:	09 f4       	brne	.+2      	; 0x3cd8 <get_GBROM_info+0x4b8>
    3cd6:	8a c0       	rjmp	.+276    	; 0x3dec <get_GBROM_info+0x5cc>
    (*gbromData).ROMsizeBytes = 524288;
  } else if ((*gbromData).ROMsize == GBROM_1M) {
    3cd8:	85 30       	cpi	r24, 0x05	; 5
    3cda:	09 f4       	brne	.+2      	; 0x3cde <get_GBROM_info+0x4be>
    3cdc:	a9 c0       	rjmp	.+338    	; 0x3e30 <get_GBROM_info+0x610>
    (*gbromData).ROMsizeBytes = 1048576;
  } else if ((*gbromData).ROMsize == GBROM_2M) {
    3cde:	86 30       	cpi	r24, 0x06	; 6
    3ce0:	09 f4       	brne	.+2      	; 0x3ce4 <get_GBROM_info+0x4c4>
    3ce2:	bd c0       	rjmp	.+378    	; 0x3e5e <get_GBROM_info+0x63e>
    (*gbromData).ROMsizeBytes = 2097152;
  } else {
    (*gbromData).ROMsizeBytes = 0;
    3ce4:	1a 8a       	std	Y+18, r1	; 0x12
    3ce6:	1b 8a       	std	Y+19, r1	; 0x13
    3ce8:	1c 8a       	std	Y+20, r1	; 0x14
    3cea:	1d 8a       	std	Y+21, r1	; 0x15
    3cec:	a0 cf       	rjmp	.-192    	; 0x3c2e <get_GBROM_info+0x40e>
    (*gbromData).RAMsizeBytes = 0;
  }

  // Get the MBC mode name
  if((*gbromData).MBCtype == GBCART_ROM_ONLY) {
    strcpy_P((*gbromData).MBCname,PSTR("ROM only"));
    3cee:	ce 01       	movw	r24, r28
    3cf0:	4a 96       	adiw	r24, 0x1a	; 26
    3cf2:	6d ec       	ldi	r22, 0xCD	; 205
    3cf4:	79 e0       	ldi	r23, 0x09	; 9
    3cf6:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    (*gbromData).RAMsizeBytes = 512; // Special case here, as MBC2 header may not disclose internal MBC RAM
  } else {
    strcpy_P((*gbromData).MBCname,PSTR("Unsupported MBC type"));
  }
  
  if((*gbromData).CGBsupport == GB_PRE_CGB) {
    3cfa:	8f a5       	ldd	r24, Y+47	; 0x2f
    3cfc:	88 23       	and	r24, r24
    3cfe:	71 f0       	breq	.+28     	; 0x3d1c <get_GBROM_info+0x4fc>
    strcpy_P((*gbromData).CGBsupportText, PSTR("Pre-CGB"));
  } else if ((*gbromData).CGBsupport == GB_AND_CGB) {
    3d00:	80 38       	cpi	r24, 0x80	; 128
    3d02:	09 f4       	brne	.+2      	; 0x3d06 <get_GBROM_info+0x4e6>
    3d04:	47 c0       	rjmp	.+142    	; 0x3d94 <get_GBROM_info+0x574>
    strcpy_P((*gbromData).CGBsupportText, PSTR("GB & CGB"));
  } else if ((*gbromData).CGBsupport == CGB_ONLY) {
    3d06:	80 3c       	cpi	r24, 0xC0	; 192
    3d08:	a9 f1       	breq	.+106    	; 0x3d74 <get_GBROM_info+0x554>
    strcpy_P((*gbromData).CGBsupportText, PSTR("CGB only"));
  } else {
    strcpy_P((*gbromData).CGBsupportText, PSTR("UNK VAL"));
    3d0a:	ce 01       	movw	r24, r28
    3d0c:	c0 96       	adiw	r24, 0x30	; 48
    3d0e:	62 ee       	ldi	r22, 0xE2	; 226
    3d10:	78 e0       	ldi	r23, 0x08	; 8
    3d12:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
  }
}
    3d16:	df 91       	pop	r29
    3d18:	cf 91       	pop	r28
    3d1a:	08 95       	ret
  } else {
    strcpy_P((*gbromData).MBCname,PSTR("Unsupported MBC type"));
  }
  
  if((*gbromData).CGBsupport == GB_PRE_CGB) {
    strcpy_P((*gbromData).CGBsupportText, PSTR("Pre-CGB"));
    3d1c:	ce 01       	movw	r24, r28
    3d1e:	c0 96       	adiw	r24, 0x30	; 48
    3d20:	6c ef       	ldi	r22, 0xFC	; 252
    3d22:	78 e0       	ldi	r23, 0x08	; 8
    3d24:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
  } else if ((*gbromData).CGBsupport == CGB_ONLY) {
    strcpy_P((*gbromData).CGBsupportText, PSTR("CGB only"));
  } else {
    strcpy_P((*gbromData).CGBsupportText, PSTR("UNK VAL"));
  }
}
    3d28:	df 91       	pop	r29
    3d2a:	cf 91       	pop	r28
    3d2c:	08 95       	ret

  // Convert the RAM size
  if((*gbromData).RAMsize == GBRAM_0k) {
    (*gbromData).RAMsizeBytes = 0;
  } else if((*gbromData).RAMsize == GBRAM_2k) {
    (*gbromData).RAMsizeBytes = 2048;
    3d2e:	80 e0       	ldi	r24, 0x00	; 0
    3d30:	98 e0       	ldi	r25, 0x08	; 8
    3d32:	98 8f       	std	Y+24, r25	; 0x18
    3d34:	8f 8b       	std	Y+23, r24	; 0x17
    3d36:	8a cf       	rjmp	.-236    	; 0x3c4c <get_GBROM_info+0x42c>
  // Now fill out the additional GBROMDATA fields
  // Convert hex ROM size to bytes ROM size
  if((*gbromData).ROMsize == GBROM_32k) {
    (*gbromData).ROMsizeBytes = 32768;
  } else if ((*gbromData).ROMsize == GBROM_64k) {
    (*gbromData).ROMsizeBytes = 65536;
    3d38:	80 e0       	ldi	r24, 0x00	; 0
    3d3a:	90 e0       	ldi	r25, 0x00	; 0
    3d3c:	a1 e0       	ldi	r26, 0x01	; 1
    3d3e:	b0 e0       	ldi	r27, 0x00	; 0
    3d40:	8a 8b       	std	Y+18, r24	; 0x12
    3d42:	9b 8b       	std	Y+19, r25	; 0x13
    3d44:	ac 8b       	std	Y+20, r26	; 0x14
    3d46:	bd 8b       	std	Y+21, r27	; 0x15
    3d48:	72 cf       	rjmp	.-284    	; 0x3c2e <get_GBROM_info+0x40e>
  if((*gbromData).MBCtype == GBCART_ROM_ONLY) {
    strcpy_P((*gbromData).MBCname,PSTR("ROM only"));
  } else if((*gbromData).MBCtype == GBCART_MBC1) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC1"));
  } else if((*gbromData).MBCtype == GBCART_MBC1_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC1 RAM"));
    3d4a:	ce 01       	movw	r24, r28
    3d4c:	4a 96       	adiw	r24, 0x1a	; 26
    3d4e:	6f eb       	ldi	r22, 0xBF	; 191
    3d50:	79 e0       	ldi	r23, 0x09	; 9
    3d52:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3d56:	d1 cf       	rjmp	.-94     	; 0x3cfa <get_GBROM_info+0x4da>
  } else if((*gbromData).RAMsize == GBRAM_2k) {
    (*gbromData).RAMsizeBytes = 2048;
  } else if((*gbromData).RAMsize == GBRAM_8k) {
    (*gbromData).RAMsizeBytes = 8192;
  } else if((*gbromData).RAMsize == GBRAM_32k) {
    (*gbromData).RAMsizeBytes = 32768;
    3d58:	80 e0       	ldi	r24, 0x00	; 0
    3d5a:	90 e8       	ldi	r25, 0x80	; 128
    3d5c:	98 8f       	std	Y+24, r25	; 0x18
    3d5e:	8f 8b       	std	Y+23, r24	; 0x17
    3d60:	75 cf       	rjmp	.-278    	; 0x3c4c <get_GBROM_info+0x42c>
  } else if ((*gbromData).ROMsize == GBROM_64k) {
    (*gbromData).ROMsizeBytes = 65536;
  } else if ((*gbromData).ROMsize == GBROM_128k) {
    (*gbromData).ROMsizeBytes = 131072;
  } else if ((*gbromData).ROMsize == GBROM_256k) {
    (*gbromData).ROMsizeBytes = 262144;
    3d62:	80 e0       	ldi	r24, 0x00	; 0
    3d64:	90 e0       	ldi	r25, 0x00	; 0
    3d66:	a4 e0       	ldi	r26, 0x04	; 4
    3d68:	b0 e0       	ldi	r27, 0x00	; 0
    3d6a:	8a 8b       	std	Y+18, r24	; 0x12
    3d6c:	9b 8b       	std	Y+19, r25	; 0x13
    3d6e:	ac 8b       	std	Y+20, r26	; 0x14
    3d70:	bd 8b       	std	Y+21, r27	; 0x15
    3d72:	5d cf       	rjmp	.-326    	; 0x3c2e <get_GBROM_info+0x40e>
  if((*gbromData).CGBsupport == GB_PRE_CGB) {
    strcpy_P((*gbromData).CGBsupportText, PSTR("Pre-CGB"));
  } else if ((*gbromData).CGBsupport == GB_AND_CGB) {
    strcpy_P((*gbromData).CGBsupportText, PSTR("GB & CGB"));
  } else if ((*gbromData).CGBsupport == CGB_ONLY) {
    strcpy_P((*gbromData).CGBsupportText, PSTR("CGB only"));
    3d74:	ce 01       	movw	r24, r28
    3d76:	c0 96       	adiw	r24, 0x30	; 48
    3d78:	6a ee       	ldi	r22, 0xEA	; 234
    3d7a:	78 e0       	ldi	r23, 0x08	; 8
    3d7c:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
  } else {
    strcpy_P((*gbromData).CGBsupportText, PSTR("UNK VAL"));
  }
}
    3d80:	df 91       	pop	r29
    3d82:	cf 91       	pop	r28
    3d84:	08 95       	ret

  // Get the MBC mode name
  if((*gbromData).MBCtype == GBCART_ROM_ONLY) {
    strcpy_P((*gbromData).MBCname,PSTR("ROM only"));
  } else if((*gbromData).MBCtype == GBCART_MBC1) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC1"));
    3d86:	ce 01       	movw	r24, r28
    3d88:	4a 96       	adiw	r24, 0x1a	; 26
    3d8a:	68 ec       	ldi	r22, 0xC8	; 200
    3d8c:	79 e0       	ldi	r23, 0x09	; 9
    3d8e:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3d92:	b3 cf       	rjmp	.-154    	; 0x3cfa <get_GBROM_info+0x4da>
  }
  
  if((*gbromData).CGBsupport == GB_PRE_CGB) {
    strcpy_P((*gbromData).CGBsupportText, PSTR("Pre-CGB"));
  } else if ((*gbromData).CGBsupport == GB_AND_CGB) {
    strcpy_P((*gbromData).CGBsupportText, PSTR("GB & CGB"));
    3d94:	ce 01       	movw	r24, r28
    3d96:	c0 96       	adiw	r24, 0x30	; 48
    3d98:	63 ef       	ldi	r22, 0xF3	; 243
    3d9a:	78 e0       	ldi	r23, 0x08	; 8
    3d9c:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
  } else if ((*gbromData).CGBsupport == CGB_ONLY) {
    strcpy_P((*gbromData).CGBsupportText, PSTR("CGB only"));
  } else {
    strcpy_P((*gbromData).CGBsupportText, PSTR("UNK VAL"));
  }
}
    3da0:	df 91       	pop	r29
    3da2:	cf 91       	pop	r28
    3da4:	08 95       	ret
  if((*gbromData).RAMsize == GBRAM_0k) {
    (*gbromData).RAMsizeBytes = 0;
  } else if((*gbromData).RAMsize == GBRAM_2k) {
    (*gbromData).RAMsizeBytes = 2048;
  } else if((*gbromData).RAMsize == GBRAM_8k) {
    (*gbromData).RAMsizeBytes = 8192;
    3da6:	80 e0       	ldi	r24, 0x00	; 0
    3da8:	90 e2       	ldi	r25, 0x20	; 32
    3daa:	98 8f       	std	Y+24, r25	; 0x18
    3dac:	8f 8b       	std	Y+23, r24	; 0x17
    3dae:	4e cf       	rjmp	.-356    	; 0x3c4c <get_GBROM_info+0x42c>
  if((*gbromData).ROMsize == GBROM_32k) {
    (*gbromData).ROMsizeBytes = 32768;
  } else if ((*gbromData).ROMsize == GBROM_64k) {
    (*gbromData).ROMsizeBytes = 65536;
  } else if ((*gbromData).ROMsize == GBROM_128k) {
    (*gbromData).ROMsizeBytes = 131072;
    3db0:	80 e0       	ldi	r24, 0x00	; 0
    3db2:	90 e0       	ldi	r25, 0x00	; 0
    3db4:	a2 e0       	ldi	r26, 0x02	; 2
    3db6:	b0 e0       	ldi	r27, 0x00	; 0
    3db8:	8a 8b       	std	Y+18, r24	; 0x12
    3dba:	9b 8b       	std	Y+19, r25	; 0x13
    3dbc:	ac 8b       	std	Y+20, r26	; 0x14
    3dbe:	bd 8b       	std	Y+21, r27	; 0x15
    3dc0:	36 cf       	rjmp	.-404    	; 0x3c2e <get_GBROM_info+0x40e>
  } else if((*gbromData).MBCtype == GBCART_MBC1) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC1"));
  } else if((*gbromData).MBCtype == GBCART_MBC1_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC1 RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC1_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC1 RAM BATT"));
    3dc2:	ce 01       	movw	r24, r28
    3dc4:	4a 96       	adiw	r24, 0x1a	; 26
    3dc6:	61 eb       	ldi	r22, 0xB1	; 177
    3dc8:	79 e0       	ldi	r23, 0x09	; 9
    3dca:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3dce:	95 cf       	rjmp	.-214    	; 0x3cfa <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC5) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5"));
    3dd0:	ce 01       	movw	r24, r28
    3dd2:	4a 96       	adiw	r24, 0x1a	; 26
    3dd4:	6c ea       	ldi	r22, 0xAC	; 172
    3dd6:	79 e0       	ldi	r23, 0x09	; 9
    3dd8:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3ddc:	8e cf       	rjmp	.-228    	; 0x3cfa <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC5_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RAM"));
    3dde:	ce 01       	movw	r24, r28
    3de0:	4a 96       	adiw	r24, 0x1a	; 26
    3de2:	63 ea       	ldi	r22, 0xA3	; 163
    3de4:	79 e0       	ldi	r23, 0x09	; 9
    3de6:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3dea:	87 cf       	rjmp	.-242    	; 0x3cfa <get_GBROM_info+0x4da>
  } else if ((*gbromData).ROMsize == GBROM_128k) {
    (*gbromData).ROMsizeBytes = 131072;
  } else if ((*gbromData).ROMsize == GBROM_256k) {
    (*gbromData).ROMsizeBytes = 262144;
  } else if ((*gbromData).ROMsize == GBROM_512k) {
    (*gbromData).ROMsizeBytes = 524288;
    3dec:	80 e0       	ldi	r24, 0x00	; 0
    3dee:	90 e0       	ldi	r25, 0x00	; 0
    3df0:	a8 e0       	ldi	r26, 0x08	; 8
    3df2:	b0 e0       	ldi	r27, 0x00	; 0
    3df4:	8a 8b       	std	Y+18, r24	; 0x12
    3df6:	9b 8b       	std	Y+19, r25	; 0x13
    3df8:	ac 8b       	std	Y+20, r26	; 0x14
    3dfa:	bd 8b       	std	Y+21, r27	; 0x15
    3dfc:	18 cf       	rjmp	.-464    	; 0x3c2e <get_GBROM_info+0x40e>
  } else if((*gbromData).MBCtype == GBCART_MBC5_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE"));
    3dfe:	ce 01       	movw	r24, r28
    3e00:	4a 96       	adiw	r24, 0x1a	; 26
    3e02:	69 e8       	ldi	r22, 0x89	; 137
    3e04:	79 e0       	ldi	r23, 0x09	; 9
    3e06:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3e0a:	77 cf       	rjmp	.-274    	; 0x3cfa <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC3_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC3_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC2) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC2"));
    3e0c:	ce 01       	movw	r24, r28
    3e0e:	4a 96       	adiw	r24, 0x1a	; 26
    3e10:	63 e2       	ldi	r22, 0x23	; 35
    3e12:	79 e0       	ldi	r23, 0x09	; 9
    3e14:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    (*gbromData).RAMsizeBytes = 512; // Special case here, as MBC2 header may not disclose internal MBC RAM
    3e18:	80 e0       	ldi	r24, 0x00	; 0
    3e1a:	92 e0       	ldi	r25, 0x02	; 2
    3e1c:	98 8f       	std	Y+24, r25	; 0x18
    3e1e:	8f 8b       	std	Y+23, r24	; 0x17
    3e20:	6c cf       	rjmp	.-296    	; 0x3cfa <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC5) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RAM BATT"));
    3e22:	ce 01       	movw	r24, r28
    3e24:	4a 96       	adiw	r24, 0x1a	; 26
    3e26:	65 e9       	ldi	r22, 0x95	; 149
    3e28:	79 e0       	ldi	r23, 0x09	; 9
    3e2a:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3e2e:	65 cf       	rjmp	.-310    	; 0x3cfa <get_GBROM_info+0x4da>
  } else if ((*gbromData).ROMsize == GBROM_256k) {
    (*gbromData).ROMsizeBytes = 262144;
  } else if ((*gbromData).ROMsize == GBROM_512k) {
    (*gbromData).ROMsizeBytes = 524288;
  } else if ((*gbromData).ROMsize == GBROM_1M) {
    (*gbromData).ROMsizeBytes = 1048576;
    3e30:	80 e0       	ldi	r24, 0x00	; 0
    3e32:	90 e0       	ldi	r25, 0x00	; 0
    3e34:	a0 e1       	ldi	r26, 0x10	; 16
    3e36:	b0 e0       	ldi	r27, 0x00	; 0
    3e38:	8a 8b       	std	Y+18, r24	; 0x12
    3e3a:	9b 8b       	std	Y+19, r25	; 0x13
    3e3c:	ac 8b       	std	Y+20, r26	; 0x14
    3e3e:	bd 8b       	std	Y+21, r27	; 0x15
    3e40:	f6 ce       	rjmp	.-532    	; 0x3c2e <get_GBROM_info+0x40e>
  } else if((*gbromData).MBCtype == GBCART_MBC5_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE RAM"));
    3e42:	ce 01       	movw	r24, r28
    3e44:	4a 96       	adiw	r24, 0x1a	; 26
    3e46:	69 e7       	ldi	r22, 0x79	; 121
    3e48:	79 e0       	ldi	r23, 0x09	; 9
    3e4a:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3e4e:	55 cf       	rjmp	.-342    	; 0x3cfa <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE RAM BATT"));
    3e50:	ce 01       	movw	r24, r28
    3e52:	4a 96       	adiw	r24, 0x1a	; 26
    3e54:	64 e6       	ldi	r22, 0x64	; 100
    3e56:	79 e0       	ldi	r23, 0x09	; 9
    3e58:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3e5c:	4e cf       	rjmp	.-356    	; 0x3cfa <get_GBROM_info+0x4da>
  } else if ((*gbromData).ROMsize == GBROM_512k) {
    (*gbromData).ROMsizeBytes = 524288;
  } else if ((*gbromData).ROMsize == GBROM_1M) {
    (*gbromData).ROMsizeBytes = 1048576;
  } else if ((*gbromData).ROMsize == GBROM_2M) {
    (*gbromData).ROMsizeBytes = 2097152;
    3e5e:	80 e0       	ldi	r24, 0x00	; 0
    3e60:	90 e0       	ldi	r25, 0x00	; 0
    3e62:	a0 e2       	ldi	r26, 0x20	; 32
    3e64:	b0 e0       	ldi	r27, 0x00	; 0
    3e66:	8a 8b       	std	Y+18, r24	; 0x12
    3e68:	9b 8b       	std	Y+19, r25	; 0x13
    3e6a:	ac 8b       	std	Y+20, r26	; 0x14
    3e6c:	bd 8b       	std	Y+21, r27	; 0x15
    3e6e:	df ce       	rjmp	.-578    	; 0x3c2e <get_GBROM_info+0x40e>
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC3_RTC_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RTC BATT"));
    3e70:	ce 01       	movw	r24, r28
    3e72:	4a 96       	adiw	r24, 0x1a	; 26
    3e74:	66 e5       	ldi	r22, 0x56	; 86
    3e76:	79 e0       	ldi	r23, 0x09	; 9
    3e78:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3e7c:	3e cf       	rjmp	.-388    	; 0x3cfa <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC3_RTC_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RTC RAM BATT"));
    3e7e:	ce 01       	movw	r24, r28
    3e80:	4a 96       	adiw	r24, 0x1a	; 26
    3e82:	64 e4       	ldi	r22, 0x44	; 68
    3e84:	79 e0       	ldi	r23, 0x09	; 9
    3e86:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3e8a:	37 cf       	rjmp	.-402    	; 0x3cfa <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC3) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3"));
    3e8c:	ce 01       	movw	r24, r28
    3e8e:	4a 96       	adiw	r24, 0x1a	; 26
    3e90:	6f e3       	ldi	r22, 0x3F	; 63
    3e92:	79 e0       	ldi	r23, 0x09	; 9
    3e94:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3e98:	30 cf       	rjmp	.-416    	; 0x3cfa <get_GBROM_info+0x4da>
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC2) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC2"));
    (*gbromData).RAMsizeBytes = 512; // Special case here, as MBC2 header may not disclose internal MBC RAM
  } else if((*gbromData).MBCtype == GBCART_MBC2_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC2 BATT"));
    3e9a:	ce 01       	movw	r24, r28
    3e9c:	4a 96       	adiw	r24, 0x1a	; 26
    3e9e:	69 e1       	ldi	r22, 0x19	; 25
    3ea0:	79 e0       	ldi	r23, 0x09	; 9
    3ea2:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    (*gbromData).RAMsizeBytes = 512; // Special case here, as MBC2 header may not disclose internal MBC RAM
    3ea6:	80 e0       	ldi	r24, 0x00	; 0
    3ea8:	92 e0       	ldi	r25, 0x02	; 2
    3eaa:	98 8f       	std	Y+24, r25	; 0x18
    3eac:	8f 8b       	std	Y+23, r24	; 0x17
    3eae:	25 cf       	rjmp	.-438    	; 0x3cfa <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC3_RTC_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RTC RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC3) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3"));
  } else if((*gbromData).MBCtype == GBCART_MBC3_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RAM"));
    3eb0:	ce 01       	movw	r24, r28
    3eb2:	4a 96       	adiw	r24, 0x1a	; 26
    3eb4:	66 e3       	ldi	r22, 0x36	; 54
    3eb6:	79 e0       	ldi	r23, 0x09	; 9
    3eb8:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3ebc:	1e cf       	rjmp	.-452    	; 0x3cfa <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC3_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RAM BATT"));
    3ebe:	ce 01       	movw	r24, r28
    3ec0:	4a 96       	adiw	r24, 0x1a	; 26
    3ec2:	68 e2       	ldi	r22, 0x28	; 40
    3ec4:	79 e0       	ldi	r23, 0x09	; 9
    3ec6:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    3eca:	17 cf       	rjmp	.-466    	; 0x3cfa <get_GBROM_info+0x4da>

00003ecc <read_MBC_mode_only>:

  return 0;
}

uint8_t read_MBC_mode_only() {
  return eeprom_read_byte(0x00);
    3ecc:	80 e0       	ldi	r24, 0x00	; 0
    3ece:	90 e0       	ldi	r25, 0x00	; 0
    3ed0:	0e 94 91 20 	call	0x4122	; 0x4122 <__eerd_byte_m644>
}
    3ed4:	08 95       	ret

00003ed6 <program_initial_gbeepromdat>:
  } 

  return 0;
}

uint8_t program_initial_gbeepromdat(uint8_t MBCmode) {
    3ed6:	68 2f       	mov	r22, r24

  eeprom_write_byte(0x00, MBCmode);
    3ed8:	80 e0       	ldi	r24, 0x00	; 0
    3eda:	90 e0       	ldi	r25, 0x00	; 0
    3edc:	0e 94 c9 20 	call	0x4192	; 0x4192 <__eewr_byte_m644>
  eeprom_write_dword((uint32_t*)0x0A, 115200UL);
    3ee0:	8a e0       	ldi	r24, 0x0A	; 10
    3ee2:	90 e0       	ldi	r25, 0x00	; 0
    3ee4:	40 e0       	ldi	r20, 0x00	; 0
    3ee6:	52 ec       	ldi	r21, 0xC2	; 194
    3ee8:	61 e0       	ldi	r22, 0x01	; 1
    3eea:	70 e0       	ldi	r23, 0x00	; 0
    3eec:	0e 94 d7 20 	call	0x41ae	; 0x41ae <__eewr_dword_m644>
  eeprom_write_word((uint16_t*)0x0E, 1);
    3ef0:	8e e0       	ldi	r24, 0x0E	; 14
    3ef2:	90 e0       	ldi	r25, 0x00	; 0
    3ef4:	61 e0       	ldi	r22, 0x01	; 1
    3ef6:	70 e0       	ldi	r23, 0x00	; 0
    3ef8:	0e 94 df 20 	call	0x41be	; 0x41be <__eewr_word_m644>

  return 0;
}
    3efc:	80 e0       	ldi	r24, 0x00	; 0
    3efe:	08 95       	ret

00003f00 <compare_gbeepromdat>:
//clock_prescale_set(clock_div_1);

  return 0;
}

uint8_t compare_gbeepromdat(GBEEPROMDATA *eepData) {
    3f00:	1f 93       	push	r17
    3f02:	cf 93       	push	r28
    3f04:	df 93       	push	r29
    3f06:	ec 01       	movw	r28, r24
  
  GBEEPROMDATA temp;
  temp.MBCMode = eeprom_read_byte(0x00); // Address 0
    3f08:	80 e0       	ldi	r24, 0x00	; 0
    3f0a:	90 e0       	ldi	r25, 0x00	; 0
    3f0c:	0e 94 91 20 	call	0x4122	; 0x4122 <__eerd_byte_m644>
    3f10:	18 2f       	mov	r17, r24
  temp.uartBaud = eeprom_read_dword((uint32_t*)0x0A);
    3f12:	8a e0       	ldi	r24, 0x0A	; 10
    3f14:	90 e0       	ldi	r25, 0x00	; 0
    3f16:	0e 94 99 20 	call	0x4132	; 0x4132 <__eerd_dword_m644>
    3f1a:	9b 01       	movw	r18, r22
    3f1c:	ac 01       	movw	r20, r24

  if (temp.MBCMode != (*eepData).MBCMode) {
    3f1e:	88 81       	ld	r24, Y
    3f20:	18 17       	cp	r17, r24
    3f22:	31 f0       	breq	.+12     	; 0x3f30 <compare_gbeepromdat+0x30>
    3f24:	61 e0       	ldi	r22, 0x01	; 1
  } else if (temp.uartBaud != (*eepData).uartBaud){
    return 1;
  } 

  return 0;
}
    3f26:	86 2f       	mov	r24, r22
    3f28:	df 91       	pop	r29
    3f2a:	cf 91       	pop	r28
    3f2c:	1f 91       	pop	r17
    3f2e:	08 95       	ret
  
  GBEEPROMDATA temp;
  temp.MBCMode = eeprom_read_byte(0x00); // Address 0
  temp.uartBaud = eeprom_read_dword((uint32_t*)0x0A);

  if (temp.MBCMode != (*eepData).MBCMode) {
    3f30:	60 e0       	ldi	r22, 0x00	; 0
    3f32:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f34:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f36:	ac 85       	ldd	r26, Y+12	; 0x0c
    3f38:	bd 85       	ldd	r27, Y+13	; 0x0d
    3f3a:	28 17       	cp	r18, r24
    3f3c:	39 07       	cpc	r19, r25
    3f3e:	4a 07       	cpc	r20, r26
    3f40:	5b 07       	cpc	r21, r27
    3f42:	81 f7       	brne	.-32     	; 0x3f24 <compare_gbeepromdat+0x24>
  } else if (temp.uartBaud != (*eepData).uartBaud){
    return 1;
  } 

  return 0;
}
    3f44:	86 2f       	mov	r24, r22
    3f46:	df 91       	pop	r29
    3f48:	cf 91       	pop	r28
    3f4a:	1f 91       	pop	r17
    3f4c:	08 95       	ret

00003f4e <write_update_gbeepromdat>:
  }

  return 0;
}

uint8_t write_update_gbeepromdat(GBEEPROMDATA *eepData) {
    3f4e:	0f 93       	push	r16
    3f50:	1f 93       	push	r17
    3f52:	8c 01       	movw	r16, r24
  
  

  (*eepData).writeCount++;
    3f54:	fc 01       	movw	r30, r24
    3f56:	86 85       	ldd	r24, Z+14	; 0x0e
    3f58:	97 85       	ldd	r25, Z+15	; 0x0f
    3f5a:	01 96       	adiw	r24, 0x01	; 1
    3f5c:	97 87       	std	Z+15, r25	; 0x0f
    3f5e:	86 87       	std	Z+14, r24	; 0x0e
// Removed system CLK prescaling as it introduced more errors than it fixed
//clock_prescale_set(clock_div_2);
  eeprom_update_byte(0x00, (*eepData).MBCMode);
    3f60:	80 e0       	ldi	r24, 0x00	; 0
    3f62:	90 e0       	ldi	r25, 0x00	; 0
    3f64:	60 81       	ld	r22, Z
    3f66:	0e 94 a5 20 	call	0x414a	; 0x414a <__eeupd_byte_m644>
  eeprom_update_dword((uint32_t*)0x0A, (*eepData).uartBaud);
    3f6a:	f8 01       	movw	r30, r16
    3f6c:	42 85       	ldd	r20, Z+10	; 0x0a
    3f6e:	53 85       	ldd	r21, Z+11	; 0x0b
    3f70:	64 85       	ldd	r22, Z+12	; 0x0c
    3f72:	75 85       	ldd	r23, Z+13	; 0x0d
    3f74:	8a e0       	ldi	r24, 0x0A	; 10
    3f76:	90 e0       	ldi	r25, 0x00	; 0
    3f78:	0e 94 b7 20 	call	0x416e	; 0x416e <__eeupd_dword_m644>
  eeprom_update_word((uint16_t*)0x0E, (*eepData).writeCount);
    3f7c:	f8 01       	movw	r30, r16
    3f7e:	66 85       	ldd	r22, Z+14	; 0x0e
    3f80:	77 85       	ldd	r23, Z+15	; 0x0f
    3f82:	8e e0       	ldi	r24, 0x0E	; 14
    3f84:	90 e0       	ldi	r25, 0x00	; 0
    3f86:	0e 94 c3 20 	call	0x4186	; 0x4186 <__eeupd_word_m644>

//clock_prescale_set(clock_div_1);

  return 0;
}
    3f8a:	80 e0       	ldi	r24, 0x00	; 0
    3f8c:	1f 91       	pop	r17
    3f8e:	0f 91       	pop	r16
    3f90:	08 95       	ret

00003f92 <read_gbeepromdat>:
0x01-09 MBCName
0x0A-0D uartBaud
0x0E-0F writeCount
*/

uint8_t read_gbeepromdat(GBEEPROMDATA *eepData) {
    3f92:	1f 93       	push	r17
    3f94:	cf 93       	push	r28
    3f96:	df 93       	push	r29
    3f98:	ec 01       	movw	r28, r24
  
  (*eepData).MBCMode = eeprom_read_byte(0x00); // Address 0
    3f9a:	80 e0       	ldi	r24, 0x00	; 0
    3f9c:	90 e0       	ldi	r25, 0x00	; 0
    3f9e:	0e 94 91 20 	call	0x4122	; 0x4122 <__eerd_byte_m644>
    3fa2:	18 2f       	mov	r17, r24
    3fa4:	88 83       	st	Y, r24
  (*eepData).uartBaud = eeprom_read_dword((uint32_t*)0x0A);
    3fa6:	8a e0       	ldi	r24, 0x0A	; 10
    3fa8:	90 e0       	ldi	r25, 0x00	; 0
    3faa:	0e 94 99 20 	call	0x4132	; 0x4132 <__eerd_dword_m644>
    3fae:	6a 87       	std	Y+10, r22	; 0x0a
    3fb0:	7b 87       	std	Y+11, r23	; 0x0b
    3fb2:	8c 87       	std	Y+12, r24	; 0x0c
    3fb4:	9d 87       	std	Y+13, r25	; 0x0d
  (*eepData).writeCount = eeprom_read_word((uint16_t*)0x0E);
    3fb6:	8e e0       	ldi	r24, 0x0E	; 14
    3fb8:	90 e0       	ldi	r25, 0x00	; 0
    3fba:	0e 94 9f 20 	call	0x413e	; 0x413e <__eerd_word_m644>
    3fbe:	9f 87       	std	Y+15, r25	; 0x0f
    3fc0:	8e 87       	std	Y+14, r24	; 0x0e

  if((*eepData).MBCMode == CART_MODE_MBC1_16M) {
    3fc2:	10 34       	cpi	r17, 0x40	; 64
    3fc4:	f1 f0       	breq	.+60     	; 0x4002 <read_gbeepromdat+0x70>
    strcpy_P((*eepData).MBCName, PSTR("MBC1_16M"));
  } else if((*eepData).MBCMode == CART_MODE_MBC1_4M) {
    3fc6:	11 34       	cpi	r17, 0x41	; 65
    3fc8:	39 f1       	breq	.+78     	; 0x4018 <read_gbeepromdat+0x86>
    strcpy_P((*eepData).MBCName, PSTR("MBC1_4M "));
  } else if((*eepData).MBCMode == CART_MODE_MBC2) {
    3fca:	15 34       	cpi	r17, 0x45	; 69
    3fcc:	81 f1       	breq	.+96     	; 0x402e <read_gbeepromdat+0x9c>
    strcpy_P((*eepData).MBCName, PSTR("MBC2    "));
  } else if((*eepData).MBCMode == CART_MODE_MBC3) {
    3fce:	13 34       	cpi	r17, 0x43	; 67
    3fd0:	c9 f1       	breq	.+114    	; 0x4044 <read_gbeepromdat+0xb2>
    strcpy_P((*eepData).MBCName, PSTR("MBC3    "));
  } else if((*eepData).MBCMode == CART_MODE_MBC5) {
    3fd2:	12 34       	cpi	r17, 0x42	; 66
    3fd4:	59 f0       	breq	.+22     	; 0x3fec <read_gbeepromdat+0x5a>
    strcpy_P((*eepData).MBCName, PSTR("MBC5    "));
  } else {
    strcpy_P((*eepData).MBCName, PSTR("MODE UNK"));
    3fd6:	ce 01       	movw	r24, r28
    3fd8:	01 96       	adiw	r24, 0x01	; 1
    3fda:	66 ed       	ldi	r22, 0xD6	; 214
    3fdc:	79 e0       	ldi	r23, 0x09	; 9
    3fde:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
  }

  return 0;
}
    3fe2:	80 e0       	ldi	r24, 0x00	; 0
    3fe4:	df 91       	pop	r29
    3fe6:	cf 91       	pop	r28
    3fe8:	1f 91       	pop	r17
    3fea:	08 95       	ret
  } else if((*eepData).MBCMode == CART_MODE_MBC2) {
    strcpy_P((*eepData).MBCName, PSTR("MBC2    "));
  } else if((*eepData).MBCMode == CART_MODE_MBC3) {
    strcpy_P((*eepData).MBCName, PSTR("MBC3    "));
  } else if((*eepData).MBCMode == CART_MODE_MBC5) {
    strcpy_P((*eepData).MBCName, PSTR("MBC5    "));
    3fec:	ce 01       	movw	r24, r28
    3fee:	01 96       	adiw	r24, 0x01	; 1
    3ff0:	6f ed       	ldi	r22, 0xDF	; 223
    3ff2:	79 e0       	ldi	r23, 0x09	; 9
    3ff4:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
  } else {
    strcpy_P((*eepData).MBCName, PSTR("MODE UNK"));
  }

  return 0;
}
    3ff8:	80 e0       	ldi	r24, 0x00	; 0
    3ffa:	df 91       	pop	r29
    3ffc:	cf 91       	pop	r28
    3ffe:	1f 91       	pop	r17
    4000:	08 95       	ret
  (*eepData).MBCMode = eeprom_read_byte(0x00); // Address 0
  (*eepData).uartBaud = eeprom_read_dword((uint32_t*)0x0A);
  (*eepData).writeCount = eeprom_read_word((uint16_t*)0x0E);

  if((*eepData).MBCMode == CART_MODE_MBC1_16M) {
    strcpy_P((*eepData).MBCName, PSTR("MBC1_16M"));
    4002:	ce 01       	movw	r24, r28
    4004:	01 96       	adiw	r24, 0x01	; 1
    4006:	63 e0       	ldi	r22, 0x03	; 3
    4008:	7a e0       	ldi	r23, 0x0A	; 10
    400a:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
  } else {
    strcpy_P((*eepData).MBCName, PSTR("MODE UNK"));
  }

  return 0;
}
    400e:	80 e0       	ldi	r24, 0x00	; 0
    4010:	df 91       	pop	r29
    4012:	cf 91       	pop	r28
    4014:	1f 91       	pop	r17
    4016:	08 95       	ret
  (*eepData).writeCount = eeprom_read_word((uint16_t*)0x0E);

  if((*eepData).MBCMode == CART_MODE_MBC1_16M) {
    strcpy_P((*eepData).MBCName, PSTR("MBC1_16M"));
  } else if((*eepData).MBCMode == CART_MODE_MBC1_4M) {
    strcpy_P((*eepData).MBCName, PSTR("MBC1_4M "));
    4018:	ce 01       	movw	r24, r28
    401a:	01 96       	adiw	r24, 0x01	; 1
    401c:	6a ef       	ldi	r22, 0xFA	; 250
    401e:	79 e0       	ldi	r23, 0x09	; 9
    4020:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
  } else {
    strcpy_P((*eepData).MBCName, PSTR("MODE UNK"));
  }

  return 0;
}
    4024:	80 e0       	ldi	r24, 0x00	; 0
    4026:	df 91       	pop	r29
    4028:	cf 91       	pop	r28
    402a:	1f 91       	pop	r17
    402c:	08 95       	ret
  if((*eepData).MBCMode == CART_MODE_MBC1_16M) {
    strcpy_P((*eepData).MBCName, PSTR("MBC1_16M"));
  } else if((*eepData).MBCMode == CART_MODE_MBC1_4M) {
    strcpy_P((*eepData).MBCName, PSTR("MBC1_4M "));
  } else if((*eepData).MBCMode == CART_MODE_MBC2) {
    strcpy_P((*eepData).MBCName, PSTR("MBC2    "));
    402e:	ce 01       	movw	r24, r28
    4030:	01 96       	adiw	r24, 0x01	; 1
    4032:	61 ef       	ldi	r22, 0xF1	; 241
    4034:	79 e0       	ldi	r23, 0x09	; 9
    4036:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
  } else {
    strcpy_P((*eepData).MBCName, PSTR("MODE UNK"));
  }

  return 0;
}
    403a:	80 e0       	ldi	r24, 0x00	; 0
    403c:	df 91       	pop	r29
    403e:	cf 91       	pop	r28
    4040:	1f 91       	pop	r17
    4042:	08 95       	ret
  } else if((*eepData).MBCMode == CART_MODE_MBC1_4M) {
    strcpy_P((*eepData).MBCName, PSTR("MBC1_4M "));
  } else if((*eepData).MBCMode == CART_MODE_MBC2) {
    strcpy_P((*eepData).MBCName, PSTR("MBC2    "));
  } else if((*eepData).MBCMode == CART_MODE_MBC3) {
    strcpy_P((*eepData).MBCName, PSTR("MBC3    "));
    4044:	ce 01       	movw	r24, r28
    4046:	01 96       	adiw	r24, 0x01	; 1
    4048:	68 ee       	ldi	r22, 0xE8	; 232
    404a:	79 e0       	ldi	r23, 0x09	; 9
    404c:	0e 94 8a 20 	call	0x4114	; 0x4114 <strcpy_P>
    4050:	c8 cf       	rjmp	.-112    	; 0x3fe2 <read_gbeepromdat+0x50>

00004052 <__mulsi3>:
    4052:	62 9f       	mul	r22, r18
    4054:	d0 01       	movw	r26, r0
    4056:	73 9f       	mul	r23, r19
    4058:	f0 01       	movw	r30, r0
    405a:	82 9f       	mul	r24, r18
    405c:	e0 0d       	add	r30, r0
    405e:	f1 1d       	adc	r31, r1
    4060:	64 9f       	mul	r22, r20
    4062:	e0 0d       	add	r30, r0
    4064:	f1 1d       	adc	r31, r1
    4066:	92 9f       	mul	r25, r18
    4068:	f0 0d       	add	r31, r0
    406a:	83 9f       	mul	r24, r19
    406c:	f0 0d       	add	r31, r0
    406e:	74 9f       	mul	r23, r20
    4070:	f0 0d       	add	r31, r0
    4072:	65 9f       	mul	r22, r21
    4074:	f0 0d       	add	r31, r0
    4076:	99 27       	eor	r25, r25
    4078:	72 9f       	mul	r23, r18
    407a:	b0 0d       	add	r27, r0
    407c:	e1 1d       	adc	r30, r1
    407e:	f9 1f       	adc	r31, r25
    4080:	63 9f       	mul	r22, r19
    4082:	b0 0d       	add	r27, r0
    4084:	e1 1d       	adc	r30, r1
    4086:	f9 1f       	adc	r31, r25
    4088:	bd 01       	movw	r22, r26
    408a:	cf 01       	movw	r24, r30
    408c:	11 24       	eor	r1, r1
    408e:	08 95       	ret

00004090 <__udivmodqi4>:
    4090:	99 1b       	sub	r25, r25
    4092:	79 e0       	ldi	r23, 0x09	; 9
    4094:	04 c0       	rjmp	.+8      	; 0x409e <__udivmodqi4_ep>

00004096 <__udivmodqi4_loop>:
    4096:	99 1f       	adc	r25, r25
    4098:	96 17       	cp	r25, r22
    409a:	08 f0       	brcs	.+2      	; 0x409e <__udivmodqi4_ep>
    409c:	96 1b       	sub	r25, r22

0000409e <__udivmodqi4_ep>:
    409e:	88 1f       	adc	r24, r24
    40a0:	7a 95       	dec	r23
    40a2:	c9 f7       	brne	.-14     	; 0x4096 <__udivmodqi4_loop>
    40a4:	80 95       	com	r24
    40a6:	08 95       	ret

000040a8 <__udivmodhi4>:
    40a8:	aa 1b       	sub	r26, r26
    40aa:	bb 1b       	sub	r27, r27
    40ac:	51 e1       	ldi	r21, 0x11	; 17
    40ae:	07 c0       	rjmp	.+14     	; 0x40be <__udivmodhi4_ep>

000040b0 <__udivmodhi4_loop>:
    40b0:	aa 1f       	adc	r26, r26
    40b2:	bb 1f       	adc	r27, r27
    40b4:	a6 17       	cp	r26, r22
    40b6:	b7 07       	cpc	r27, r23
    40b8:	10 f0       	brcs	.+4      	; 0x40be <__udivmodhi4_ep>
    40ba:	a6 1b       	sub	r26, r22
    40bc:	b7 0b       	sbc	r27, r23

000040be <__udivmodhi4_ep>:
    40be:	88 1f       	adc	r24, r24
    40c0:	99 1f       	adc	r25, r25
    40c2:	5a 95       	dec	r21
    40c4:	a9 f7       	brne	.-22     	; 0x40b0 <__udivmodhi4_loop>
    40c6:	80 95       	com	r24
    40c8:	90 95       	com	r25
    40ca:	bc 01       	movw	r22, r24
    40cc:	cd 01       	movw	r24, r26
    40ce:	08 95       	ret

000040d0 <__udivmodsi4>:
    40d0:	a1 e2       	ldi	r26, 0x21	; 33
    40d2:	1a 2e       	mov	r1, r26
    40d4:	aa 1b       	sub	r26, r26
    40d6:	bb 1b       	sub	r27, r27
    40d8:	fd 01       	movw	r30, r26
    40da:	0d c0       	rjmp	.+26     	; 0x40f6 <__udivmodsi4_ep>

000040dc <__udivmodsi4_loop>:
    40dc:	aa 1f       	adc	r26, r26
    40de:	bb 1f       	adc	r27, r27
    40e0:	ee 1f       	adc	r30, r30
    40e2:	ff 1f       	adc	r31, r31
    40e4:	a2 17       	cp	r26, r18
    40e6:	b3 07       	cpc	r27, r19
    40e8:	e4 07       	cpc	r30, r20
    40ea:	f5 07       	cpc	r31, r21
    40ec:	20 f0       	brcs	.+8      	; 0x40f6 <__udivmodsi4_ep>
    40ee:	a2 1b       	sub	r26, r18
    40f0:	b3 0b       	sbc	r27, r19
    40f2:	e4 0b       	sbc	r30, r20
    40f4:	f5 0b       	sbc	r31, r21

000040f6 <__udivmodsi4_ep>:
    40f6:	66 1f       	adc	r22, r22
    40f8:	77 1f       	adc	r23, r23
    40fa:	88 1f       	adc	r24, r24
    40fc:	99 1f       	adc	r25, r25
    40fe:	1a 94       	dec	r1
    4100:	69 f7       	brne	.-38     	; 0x40dc <__udivmodsi4_loop>
    4102:	60 95       	com	r22
    4104:	70 95       	com	r23
    4106:	80 95       	com	r24
    4108:	90 95       	com	r25
    410a:	9b 01       	movw	r18, r22
    410c:	ac 01       	movw	r20, r24
    410e:	bd 01       	movw	r22, r26
    4110:	cf 01       	movw	r24, r30
    4112:	08 95       	ret

00004114 <strcpy_P>:
    4114:	fb 01       	movw	r30, r22
    4116:	dc 01       	movw	r26, r24
    4118:	05 90       	lpm	r0, Z+
    411a:	0d 92       	st	X+, r0
    411c:	00 20       	and	r0, r0
    411e:	e1 f7       	brne	.-8      	; 0x4118 <strcpy_P+0x4>
    4120:	08 95       	ret

00004122 <__eerd_byte_m644>:
    4122:	f9 99       	sbic	0x1f, 1	; 31
    4124:	fe cf       	rjmp	.-4      	; 0x4122 <__eerd_byte_m644>
    4126:	92 bd       	out	0x22, r25	; 34
    4128:	81 bd       	out	0x21, r24	; 33
    412a:	f8 9a       	sbi	0x1f, 0	; 31
    412c:	99 27       	eor	r25, r25
    412e:	80 b5       	in	r24, 0x20	; 32
    4130:	08 95       	ret

00004132 <__eerd_dword_m644>:
    4132:	a6 e1       	ldi	r26, 0x16	; 22
    4134:	b0 e0       	ldi	r27, 0x00	; 0
    4136:	44 e0       	ldi	r20, 0x04	; 4
    4138:	50 e0       	ldi	r21, 0x00	; 0
    413a:	0c 94 e6 20 	jmp	0x41cc	; 0x41cc <__eerd_blraw_m644>

0000413e <__eerd_word_m644>:
    413e:	a8 e1       	ldi	r26, 0x18	; 24
    4140:	b0 e0       	ldi	r27, 0x00	; 0
    4142:	42 e0       	ldi	r20, 0x02	; 2
    4144:	50 e0       	ldi	r21, 0x00	; 0
    4146:	0c 94 e6 20 	jmp	0x41cc	; 0x41cc <__eerd_blraw_m644>

0000414a <__eeupd_byte_m644>:
    414a:	26 2f       	mov	r18, r22

0000414c <__eeupd_r18_m644>:
    414c:	f9 99       	sbic	0x1f, 1	; 31
    414e:	fe cf       	rjmp	.-4      	; 0x414c <__eeupd_r18_m644>
    4150:	92 bd       	out	0x22, r25	; 34
    4152:	81 bd       	out	0x21, r24	; 33
    4154:	f8 9a       	sbi	0x1f, 0	; 31
    4156:	01 97       	sbiw	r24, 0x01	; 1
    4158:	00 b4       	in	r0, 0x20	; 32
    415a:	02 16       	cp	r0, r18
    415c:	39 f0       	breq	.+14     	; 0x416c <__eeupd_r18_m644+0x20>
    415e:	1f ba       	out	0x1f, r1	; 31
    4160:	20 bd       	out	0x20, r18	; 32
    4162:	0f b6       	in	r0, 0x3f	; 63
    4164:	f8 94       	cli
    4166:	fa 9a       	sbi	0x1f, 2	; 31
    4168:	f9 9a       	sbi	0x1f, 1	; 31
    416a:	0f be       	out	0x3f, r0	; 63
    416c:	08 95       	ret

0000416e <__eeupd_dword_m644>:
    416e:	03 96       	adiw	r24, 0x03	; 3
    4170:	27 2f       	mov	r18, r23
    4172:	0e 94 a6 20 	call	0x414c	; 0x414c <__eeupd_r18_m644>
    4176:	0e 94 a5 20 	call	0x414a	; 0x414a <__eeupd_byte_m644>
    417a:	25 2f       	mov	r18, r21
    417c:	0e 94 a6 20 	call	0x414c	; 0x414c <__eeupd_r18_m644>
    4180:	24 2f       	mov	r18, r20
    4182:	0c 94 a6 20 	jmp	0x414c	; 0x414c <__eeupd_r18_m644>

00004186 <__eeupd_word_m644>:
    4186:	01 96       	adiw	r24, 0x01	; 1
    4188:	27 2f       	mov	r18, r23
    418a:	0e 94 a6 20 	call	0x414c	; 0x414c <__eeupd_r18_m644>
    418e:	0c 94 a5 20 	jmp	0x414a	; 0x414a <__eeupd_byte_m644>

00004192 <__eewr_byte_m644>:
    4192:	26 2f       	mov	r18, r22

00004194 <__eewr_r18_m644>:
    4194:	f9 99       	sbic	0x1f, 1	; 31
    4196:	fe cf       	rjmp	.-4      	; 0x4194 <__eewr_r18_m644>
    4198:	1f ba       	out	0x1f, r1	; 31
    419a:	92 bd       	out	0x22, r25	; 34
    419c:	81 bd       	out	0x21, r24	; 33
    419e:	20 bd       	out	0x20, r18	; 32
    41a0:	0f b6       	in	r0, 0x3f	; 63
    41a2:	f8 94       	cli
    41a4:	fa 9a       	sbi	0x1f, 2	; 31
    41a6:	f9 9a       	sbi	0x1f, 1	; 31
    41a8:	0f be       	out	0x3f, r0	; 63
    41aa:	01 96       	adiw	r24, 0x01	; 1
    41ac:	08 95       	ret

000041ae <__eewr_dword_m644>:
    41ae:	24 2f       	mov	r18, r20
    41b0:	0e 94 ca 20 	call	0x4194	; 0x4194 <__eewr_r18_m644>
    41b4:	25 2f       	mov	r18, r21
    41b6:	0e 94 ca 20 	call	0x4194	; 0x4194 <__eewr_r18_m644>
    41ba:	0c 94 df 20 	jmp	0x41be	; 0x41be <__eewr_word_m644>

000041be <__eewr_word_m644>:
    41be:	0e 94 c9 20 	call	0x4192	; 0x4192 <__eewr_byte_m644>
    41c2:	27 2f       	mov	r18, r23
    41c4:	0c 94 ca 20 	jmp	0x4194	; 0x4194 <__eewr_r18_m644>

000041c8 <__eerd_block_m644>:
    41c8:	dc 01       	movw	r26, r24
    41ca:	cb 01       	movw	r24, r22

000041cc <__eerd_blraw_m644>:
    41cc:	fc 01       	movw	r30, r24
    41ce:	f9 99       	sbic	0x1f, 1	; 31
    41d0:	fe cf       	rjmp	.-4      	; 0x41ce <__eerd_blraw_m644+0x2>
    41d2:	06 c0       	rjmp	.+12     	; 0x41e0 <__eerd_blraw_m644+0x14>
    41d4:	f2 bd       	out	0x22, r31	; 34
    41d6:	e1 bd       	out	0x21, r30	; 33
    41d8:	f8 9a       	sbi	0x1f, 0	; 31
    41da:	31 96       	adiw	r30, 0x01	; 1
    41dc:	00 b4       	in	r0, 0x20	; 32
    41de:	0d 92       	st	X+, r0
    41e0:	41 50       	subi	r20, 0x01	; 1
    41e2:	50 40       	sbci	r21, 0x00	; 0
    41e4:	b8 f7       	brcc	.-18     	; 0x41d4 <__eerd_blraw_m644+0x8>
    41e6:	08 95       	ret

000041e8 <_exit>:
    41e8:	f8 94       	cli

000041ea <__stop_program>:
    41ea:	ff cf       	rjmp	.-2      	; 0x41ea <__stop_program>

Disassembly of section .MBC1_16M_0000:

00008000 <.MBC1_16M_0000>:
; **********************************************************************************
; ************* MBC1 16M8k MODE JUMP TABLE *****************************************
; **********************************************************************************
; ************************* READ JUMP TABLE (Read is low)
.section .MBC1_16M_0000,"ax",@progbits ;0x4000 ROM bank 0
  out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
    8000:	15 b8       	out	0x05, r1	; 5
  rjmp  MBC1_16M_CLK; Finished setting up the lines for a read :)
    8002:	08 cf       	rjmp	.-496    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_0010:

00008040 <.MBC1_16M_0010>:

.section .MBC1_16M_0010,"ax",@progbits ;0x4020 ROM bank 0
  out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
    8040:	15 b8       	out	0x05, r1	; 5
  rjmp  MBC1_16M_CLK; Finished setting up the lines for a read :);
    8042:	e8 ce       	rjmp	.-560    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_0100:

00008080 <.MBC1_16M_0100>:

.section .MBC1_16M_0100,"ax",@progbits ;0x4040 ROM bank XX
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    8080:	65 b9       	out	0x05, r22	; 5
  rjmp  MBC1_16M_CLK; Finished setting up the lines for a read :)
    8082:	c8 ce       	rjmp	.-624    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_0110:

000080c0 <.MBC1_16M_0110>:

.section .MBC1_16M_0110,"ax",@progbits ;0x4060 ROM bank XX
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    80c0:	65 b9       	out	0x05, r22	; 5
  rjmp  MBC1_16M_CLK; Finished setting up the lines for a read :)
    80c2:	a8 ce       	rjmp	.-688    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_1000:

00008100 <.MBC1_16M_1000>:

.section .MBC1_16M_1000,"ax",@progbits ;0x4080 Reserved. Do nothing
  rjmp  MBC1_16M_CLK;
    8100:	89 ce       	rjmp	.-750    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_1010:

00008140 <.MBC1_16M_1010>:
;  andi  r16, 0xC0; RAM_/EN & GB_/CS flag pin check <- consider changing this to a register
;  brbc  1, MBC1_16M_RAM_DIS; branch without enabling RAM if zero flag is not set in SREG
;  cbi   _SFR_IO_ADDR(PORTA), PA2;SRAM_CS_PIN - Pull SRAM_CS low
;MBC1_16M_RAM_DIS:
  ; don't think I need to do anything with access controlled in hardware (OR gate)
  rjmp  MBC1_16M_CLK;
    8140:	69 ce       	rjmp	.-814    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_1100:

00008180 <.MBC1_16M_1100>:

.section .MBC1_16M_1100,"ax",@progbits ;0x40C0 Reserved. Do nothing
  rjmp  MBC1_16M_CLK;
    8180:	49 ce       	rjmp	.-878    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_1110:

000081c0 <.MBC1_16M_1110>:

.section .MBC1_16M_1110,"ax",@progbits ;0x40E0 Reserved. Do nothing
  rjmp  MBC1_16M_CLK;
    81c0:	29 ce       	rjmp	.-942    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_0001:

00008020 <MBC1_16M_RAM_FLG_DIS-0x10>:

; ************************* WRITE JUMP TABLE (Read is hi)
.section .MBC1_16M_0001,"ax",@progbits ;0x4010 Ram enable/disable
  nop; This many NOPS may be needed to as data isn't good until WR is asserted
    8020:	00 00       	nop
  nop;
    8022:	00 00       	nop
  in    r17, _SFR_IO_ADDR(DATA_PIN)
    8024:	16 b1       	in	r17, 0x06	; 6
  andi  r17, 0x1F ; Mask D0-4. I don't want to add this, but we'll see if MBC data is corrupted otherwise
    8026:	1f 71       	andi	r17, 0x1F	; 31
  cpi   r17, 0x0A; 0x0A is an enable command
    8028:	1a 30       	cpi	r17, 0x0A	; 10
  brne  MBC1_16M_RAM_FLG_DIS
    802a:	11 f4       	brne	.+4      	; 0x8030 <MBC1_16M_RAM_FLG_DIS>
  cbi   _SFR_IO_ADDR(PORTA), PA7;
    802c:	17 98       	cbi	0x02, 7	; 2
  rjmp  MBC1_16M_CLK
    802e:	f2 ce       	rjmp	.-540    	; 0x7e14 <MBC1_16M_CLK>

00008030 <MBC1_16M_RAM_FLG_DIS>:
MBC1_16M_RAM_FLG_DIS:
  sbi   _SFR_IO_ADDR(PORTA), PA7
    8030:	17 9a       	sbi	0x02, 7	; 2
  rjmp  MBC1_16M_CLK
    8032:	f0 ce       	rjmp	.-544    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_0011:

00008060 <MBC1_16M_NZERO-0xe>:

.section .MBC1_16M_0011,"ax",@progbits ;0x4030 ROM bank numbers
  andi  r22, 0xE0;REG_MA14_18, MA19_21_MASK ; Mask only hi bits to ditch the old low bits
    8060:	60 7e       	andi	r22, 0xE0	; 224
  nop; Need a NOP here for DATA to be valid... without this, this is 13-16 cycles in, so it should be safe...
    8062:	00 00       	nop
  in    r17, _SFR_IO_ADDR(DATA_PIN);GB_DAT_REG, GB_DAT_R ;Read in DATA_PIN data for use in each write mode
    8064:	16 b1       	in	r17, 0x06	; 6
  andi  r17, 0x1F ; Mask D0-4. I don't want to add this, but we'll see if MBC data is corrupted otherwise
    8066:	1f 71       	andi	r17, 0x1F	; 31
  tst   r17
    8068:	11 23       	and	r17, r17
  brne  MBC1_16M_NZERO
    806a:	09 f4       	brne	.+2      	; 0x806e <MBC1_16M_NZERO>
  inc   r17
    806c:	13 95       	inc	r17

0000806e <MBC1_16M_NZERO>:
MBC1_16M_NZERO:
  or    r22, r17;REG_MA14_18, GB_DAT_REG
    806e:	61 2b       	or	r22, r17
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the MA mask value. Probably don't need to OUT this here for a WRITE command
    8070:	65 b9       	out	0x05, r22	; 5
  rjmp  MBC1_16M_CLK;
    8072:	d0 ce       	rjmp	.-608    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_0101:

000080a0 <.MBC1_16M_0101>:

.section .MBC1_16M_0101,"ax",@progbits ;0x4050 ROM bank number high bits
  andi  r22, 0x1F ;REG_MA14_21, 0x1F; CLR the older data
    80a0:	6f 71       	andi	r22, 0x1F	; 31
  nop; This many NOPS may be needed to as data isn't good until WR is asserted
    80a2:	00 00       	nop
  sbic  _SFR_IO_ADDR(DATA_PIN), 0
    80a4:	30 99       	sbic	0x06, 0	; 6
  sbr   r22, 5;REG_MA14_21, 5; Set bit 5, MA19
    80a6:	65 60       	ori	r22, 0x05	; 5
  sbic  _SFR_IO_ADDR(DATA_PIN), 1
    80a8:	31 99       	sbic	0x06, 1	; 6
  sbr   r22, 6;REG_MA14_21, 6; Set bit 6, MA20
    80aa:	66 60       	ori	r22, 0x06	; 6
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER ;R_MA14_21, REG_MA14_21
    80ac:	65 b9       	out	0x05, r22	; 5
  rjmp MBC1_16M_CLK;
    80ae:	b2 ce       	rjmp	.-668    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_0111:

000080e0 <.MBC1_16M_0111>:

.section .MBC1_16M_0111,"ax",@progbits ;0x4070 ROM/RAM mode select
  ; Figure out if we need a mode change
  nop; This many NOPS may be needed to as data isn't good until WR is asserted
    80e0:	00 00       	nop
  nop;
    80e2:	00 00       	nop
  sbis  _SFR_IO_ADDR(DATA_PIN), 0 ; Skip if Data bit 0 is set - we need a mode change
    80e4:	30 9b       	sbis	0x06, 0	; 6
  rjmp  MBC1_16M_CLK; Stay in our own lane
    80e6:	96 ce       	rjmp	.-724    	; 0x7e14 <MBC1_16M_CLK>
/*  sbrc  r22, 5; lo hi bit (decipher that!) ; I took this part out because TCAGBD said this is zeroed. Should I save it in case this mode comes back?
  sbi   _SFR_IO_ADDR(PORTA), 0
  sbrc  r22, 6; hi hi bit
  sbi   _SFR_IO_ADDR(PORTA), 1*/

  andi  r22, 0x1F;REG_MA14_21, remove the high bits as we're mode switching
    80e8:	6f 71       	andi	r22, 0x1F	; 31
  out   _SFR_IO_ADDR(MA_PORT), r22; Update the MA address bits before we switch modes
    80ea:	65 b9       	out	0x05, r22	; 5
  rjmp  MBC1_4M_CLK ; Mode switch jump!
    80ec:	a7 ce       	rjmp	.-690    	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_16M_1001:

00008120 <.MBC1_16M_1001>:

.section .MBC1_16M_1001,"ax",@progbits ;0x4090 Reserved. Do nothing
  rjmp  MBC1_16M_CLK;
    8120:	79 ce       	rjmp	.-782    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_1011:

00008160 <.MBC1_16M_1011>:
;  andi  r16, 0xC0; RAM_/EN & GB_/CS flag pin check <- consider changing this to a register
;  brbc  1, MBC1_16M_RAM_DIS2; branch without enabling RAM if zero flag is not set in SREG
;  cbi   _SFR_IO_ADDR(PORTA), PA2;SRAM_CS_PIN - Pull SRAM_CS low
;MBC1_16M_RAM_DIS2:
; May not need anything here with SRAM being controlled by the OR gate (and INTERNAL_RAM pin)
  rjmp  MBC1_16M_CLK;
    8160:	59 ce       	rjmp	.-846    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_1101:

000081a0 <.MBC1_16M_1101>:

.section .MBC1_16M_1101,"ax",@progbits ;0x40D0 Reserved. Do nothing
  rjmp  MBC1_16M_CLK;
    81a0:	39 ce       	rjmp	.-910    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_1111:

000081e0 <.MBC1_16M_1111>:

.section .MBC1_16M_1111,"ax",@progbits ;0x40F0 Reserved. Do nothing
  rjmp  MBC1_16M_CLK;
    81e0:	19 ce       	rjmp	.-974    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_4M_0000:

00008200 <.MBC1_4M_0000>:
; **********************************************************************************
; ************* MBC1 2M32k MODE JUMP TABLE *****************************************
; **********************************************************************************
; ************************* READ JUMP TABLE (Read is low)
.section .MBC1_4M_0000,"ax",@progbits ;0x4100 ROM bank 0
  out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
    8200:	15 b8       	out	0x05, r1	; 5
  rjmp  MBC1_4M_CLK;
    8202:	1c ce       	rjmp	.-968    	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_0010:

00008240 <.MBC1_4M_0010>:

.section .MBC1_4M_0010,"ax",@progbits ;0x4120 ROM bank 0
  out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
    8240:	15 b8       	out	0x05, r1	; 5
  rjmp  MBC1_4M_CLK;
    8242:	fc cd       	rjmp	.-1032   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_0100:

00008280 <.MBC1_4M_0100>:

.section .MBC1_4M_0100,"ax",@progbits ;0x4140 ROM bank XX
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    8280:	65 b9       	out	0x05, r22	; 5
  rjmp  MBC1_4M_CLK;
    8282:	dc cd       	rjmp	.-1096   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_0110:

000082c0 <.MBC1_4M_0110>:

.section .MBC1_4M_0110,"ax",@progbits ;0x4160 ROM bank XX
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    82c0:	65 b9       	out	0x05, r22	; 5
  rjmp  MBC1_4M_CLK;
    82c2:	bc cd       	rjmp	.-1160   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_1000:

00008300 <.MBC1_4M_1000>:

.section .MBC1_4M_1000,"ax",@progbits ;0x4180 Reserved. Do nothing
  rjmp  MBC1_4M_CLK;
    8300:	9d cd       	rjmp	.-1222   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_1010:

00008340 <.MBC1_4M_1010>:

.section .MBC1_4M_1010,"ax",@progbits ;0x41A0 RAM read
  ; Do nothing, this is handled in hardware (OR gate)
  rjmp  MBC1_4M_CLK;
    8340:	7d cd       	rjmp	.-1286   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_1100:

00008380 <.MBC1_4M_1100>:

.section .MBC1_4M_1100,"ax",@progbits ;0x41C0 Reserved. Do nothing
  rjmp  MBC1_4M_CLK;
    8380:	5d cd       	rjmp	.-1350   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_1110:

000083c0 <.MBC1_4M_1110>:

.section .MBC1_4M_1110,"ax",@progbits ;0x41E0 Reserved. Do nothing
  rjmp  MBC1_4M_CLK;
    83c0:	3d cd       	rjmp	.-1414   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_0001:

00008220 <MBC1_4M_RAM_FLG_DIS-0x10>:

; ************************* WRITE JUMP TABLE (Read is hi)
.section .MBC1_4M_0001,"ax",@progbits ;0x4110 Ram enable
  nop; This many NOPS may be needed to as data isn't good until WR is asserted
    8220:	00 00       	nop
  nop;
    8222:	00 00       	nop
  in    r17, _SFR_IO_ADDR(DATA_PIN)
    8224:	16 b1       	in	r17, 0x06	; 6
  andi  r17, 0x1F ; Mask D0-4. I don't want to add this, but we'll see if MBC data is corrupted otherwise
    8226:	1f 71       	andi	r17, 0x1F	; 31
  cpi   r17, 0x0A; 0x0A is an enable command
    8228:	1a 30       	cpi	r17, 0x0A	; 10
  brne  MBC1_4M_RAM_FLG_DIS
    822a:	11 f4       	brne	.+4      	; 0x8230 <MBC1_4M_RAM_FLG_DIS>
  cbi   _SFR_IO_ADDR(PORTA), PA7;
    822c:	17 98       	cbi	0x02, 7	; 2
  rjmp  MBC1_4M_CLK
    822e:	06 ce       	rjmp	.-1012   	; 0x7e3c <MBC1_4M_CLK>

00008230 <MBC1_4M_RAM_FLG_DIS>:
MBC1_4M_RAM_FLG_DIS:
  sbi   _SFR_IO_ADDR(PORTA), PA7
    8230:	17 9a       	sbi	0x02, 7	; 2
  rjmp  MBC1_4M_CLK;
    8232:	04 ce       	rjmp	.-1016   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_0011:

00008260 <MBC1_4M_NZERO-0xe>:

.section .MBC1_4M_0011,"ax",@progbits ;0x4130 ROM bank numbers
  andi  r22, 0xE0;REG_MA14_18, MA19_21_MASK ; Mask only hi bits to ditch the old low bits
    8260:	60 7e       	andi	r22, 0xE0	; 224
  nop; Need a NOP here for DATA to be valid... without this, this is 13-16 cycles in, so it should be safe...
    8262:	00 00       	nop
  in    r17, _SFR_IO_ADDR(DATA_PIN);GB_DAT_REG, GB_DAT_R ;Read in DATA_PIN data for use in each write mode
    8264:	16 b1       	in	r17, 0x06	; 6
  andi  r17, 0x1F ; Mask D0-4. I don't want to add this, but we'll see if MBC data is corrupted otherwise
    8266:	1f 71       	andi	r17, 0x1F	; 31
  tst   r17
    8268:	11 23       	and	r17, r17
  brne  MBC1_4M_NZERO
    826a:	09 f4       	brne	.+2      	; 0x826e <MBC1_4M_NZERO>
  inc   r17
    826c:	13 95       	inc	r17

0000826e <MBC1_4M_NZERO>:
MBC1_4M_NZERO:
  or    r22, r17;REG_MA14_18, GB_DAT_REG
    826e:	61 2b       	or	r22, r17
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the MA mask value. Probably don't need to OUT this here for a WRITE command
    8270:	65 b9       	out	0x05, r22	; 5
  rjmp  MBC1_4M_CLK;
    8272:	e4 cd       	rjmp	.-1080   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_0101:

000082a0 <.MBC1_4M_0101>:

.section .MBC1_4M_0101,"ax",@progbits ;0x4150 RAM bank number
  in    r18, _SFR_IO_ADDR(PORTA) ;Prep for changing the RAM bank number
    82a0:	22 b1       	in	r18, 0x02	; 2
  andi  r18, 0xFC ; CLR the old bits
    82a2:	2c 7f       	andi	r18, 0xFC	; 252
  in    r17, _SFR_IO_ADDR(DATA_PIN);Read in DATA_PIN data
    82a4:	16 b1       	in	r17, 0x06	; 6
  andi  r17, 0x03; Mask the RAM bank number (in case of rubbish in)
    82a6:	13 70       	andi	r17, 0x03	; 3
  or    r18, r17 ; Put it together and whaddaya got?
    82a8:	21 2b       	or	r18, r17
  out   _SFR_IO_ADDR(PORTA), r18 
    82aa:	22 b9       	out	0x02, r18	; 2
  rjmp  MBC1_4M_CLK;
    82ac:	c7 cd       	rjmp	.-1138   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_0111:

000082e0 <.MBC1_4M_0111>:

.section .MBC1_4M_0111,"ax",@progbits ;0x4170 ROM/RAM mode select 
;*** Something I hadn't considered here, what if these bits should be translated across ROM and RAM when switching? ***
; This might be the way the chip operates, rather than discarding them when clearing before a mode switch. Should I even
; clear the old bits? Guess time will tell what I should do here
  in    r18, _SFR_IO_ADDR(PORTA); This many NOPS may be needed to as data isn't good until WR is asserted
    82e0:	22 b1       	in	r18, 0x02	; 2
  andi  r18, 0xFC; In preparation for mode switch, get rid of the RAM bank bits
    82e2:	2c 7f       	andi	r18, 0xFC	; 252
  sbic  _SFR_IO_ADDR(DATA_PIN), 0 ; Skip if Data bit 0 is set - we need a mode change
    82e4:	30 99       	sbic	0x06, 0	; 6
  rjmp  MBC1_4M_CLK; Stay in our own lane
    82e6:	aa cd       	rjmp	.-1196   	; 0x7e3c <MBC1_4M_CLK>
  sbr   r22, 5;REG_MA14_21, 5; Set bit 5, MA19
  sbic  _SFR_IO_ADDR(PORTA), 1
  sbr   r22, 6;REG_MA14_21, 6; Set bit 6, MA20
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER ;R_MA14_21, REG_MA14_21*/

  out   _SFR_IO_ADDR(PORTA), r18; Update the RAM bank bits before we switch modes
    82e8:	22 b9       	out	0x02, r18	; 2
  rjmp  MBC1_16M_CLK ; Mode switch jump!
    82ea:	94 cd       	rjmp	.-1240   	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_4M_1001:

00008320 <.MBC1_4M_1001>:

.section .MBC1_4M_1001,"ax",@progbits ;0x4190 Reserved. Do nothing
  rjmp  MBC1_4M_CLK;
    8320:	8d cd       	rjmp	.-1254   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_1011:

00008360 <.MBC1_4M_1011>:

.section .MBC1_4M_1011,"ax",@progbits ;0x41B0 RAM write
  ; Do nothing, this is handled in hardware (OR gate)
  rjmp  MBC1_4M_CLK;
    8360:	6d cd       	rjmp	.-1318   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_1101:

000083a0 <.MBC1_4M_1101>:

.section .MBC1_4M_1101,"ax",@progbits ;0x41D0 Reserved. Do nothing
  rjmp  MBC1_4M_CLK;
    83a0:	4d cd       	rjmp	.-1382   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_1111:

000083e0 <.MBC1_4M_1111>:

.section .MBC1_4M_1111,"ax",@progbits ;0x41F0 Reserved. Do nothing
  rjmp  MBC1_4M_CLK;
    83e0:	2d cd       	rjmp	.-1446   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC5_0000:

00008400 <.MBC5_0000>:
; **********************************************************************************
; ************* MBC5 MODE JUMP TABLE *********************************************** 8 cycles to JMP table
; **********************************************************************************
; ************************* READ JUMP TABLE (Read is low)
.section .MBC5_0000,"ax",@progbits ;0x4200
  out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
    8400:	15 b8       	out	0x05, r1	; 5
  sbrs  r25, 2; Check CLK pin that was read pre-jmp. If it's low, then we're in DSM
    8402:	92 ff       	sbrs	r25, 2
  ldi   ZH, r31_MBC5_DSM
    8404:	f4 e4       	ldi	r31, 0x44	; 68
  rjmp  MBC5_CLK;
    8406:	2f cd       	rjmp	.-1442   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_0010:

00008440 <.MBC5_0010>:

.section .MBC5_0010,"ax",@progbits ;0x4220 ROM bank 0
  out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
    8440:	15 b8       	out	0x05, r1	; 5
  sbrs  r25, 2; Check CLK pin that was read pre-jmp. If it's low, then we're in DSM
    8442:	92 ff       	sbrs	r25, 2
  ldi   ZH, r31_MBC5_DSM
    8444:	f4 e4       	ldi	r31, 0x44	; 68
  rjmp  MBC5_CLK;
    8446:	0f cd       	rjmp	.-1506   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_0100:

00008480 <.MBC5_0100>:

.section .MBC5_0100,"ax",@progbits ;0x4240 ROM bank XX
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    8480:	65 b9       	out	0x05, r22	; 5
  sbrs  r25, 2; Check CLK pin that was read pre-jmp. If it's low, then we're in DSM
    8482:	92 ff       	sbrs	r25, 2
  ldi   ZH, r31_MBC5_DSM
    8484:	f4 e4       	ldi	r31, 0x44	; 68
  rjmp  MBC5_CLK;
    8486:	ef cc       	rjmp	.-1570   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_0110:

000084c0 <.MBC5_0110>:

.section .MBC5_0110,"ax",@progbits ;0x4260 ROM bank XX
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    84c0:	65 b9       	out	0x05, r22	; 5
  sbrs  r25, 2; Check CLK pin that was read pre-jmp. If it's low, then we're in DSM
    84c2:	92 ff       	sbrs	r25, 2
  ldi   ZH, r31_MBC5_DSM
    84c4:	f4 e4       	ldi	r31, 0x44	; 68
  rjmp  MBC5_CLK;
    84c6:	cf cc       	rjmp	.-1634   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_1000:

00008500 <.MBC5_1000>:

.section .MBC5_1000,"ax",@progbits ;0x4280 Reserved. Do nothing
out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
    8500:	15 b8       	out	0x05, r1	; 5
sbrs  r25, 2; Check CLK pin that was read pre-jmp. If it's low, then we're in DSM
    8502:	92 ff       	sbrs	r25, 2
ldi   ZH, r31_MBC5_DSM
    8504:	f4 e4       	ldi	r31, 0x44	; 68
  rjmp  MBC5_CLK;
    8506:	af cc       	rjmp	.-1698   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_1010:

00008540 <.MBC5_1010>:

.section .MBC5_1010,"ax",@progbits ;0x42A0 RAM read
  ; Do nothing. RAM is handled in HW :)
out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
    8540:	15 b8       	out	0x05, r1	; 5
sbrs  r25, 2; Check CLK pin that was read pre-jmp. If it's low, then we're in DSM
    8542:	92 ff       	sbrs	r25, 2
ldi   ZH, r31_MBC5_DSM
    8544:	f4 e4       	ldi	r31, 0x44	; 68
  rjmp  MBC5_CLK;
    8546:	8f cc       	rjmp	.-1762   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_1100:

00008580 <.MBC5_1100>:

.section .MBC5_1100,"ax",@progbits ;0x42C0 Reserved. Do nothing
out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    8580:	65 b9       	out	0x05, r22	; 5
sbrs  r25, 2; Check CLK pin that was read pre-jmp. If it's low, then we're in DSM
    8582:	92 ff       	sbrs	r25, 2
ldi   ZH, r31_MBC5_DSM
    8584:	f4 e4       	ldi	r31, 0x44	; 68
  rjmp  MBC5_CLK;
    8586:	6f cc       	rjmp	.-1826   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_1110:

000085c0 <.MBC5_1110>:

.section .MBC5_1110,"ax",@progbits ;0x42E0 Reserved. Do nothing
out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    85c0:	65 b9       	out	0x05, r22	; 5
sbrs  r25, 2; Check CLK pin that was read pre-jmp. If it's low, then we're in DSM
    85c2:	92 ff       	sbrs	r25, 2
ldi   ZH, r31_MBC5_DSM
    85c4:	f4 e4       	ldi	r31, 0x44	; 68
  rjmp  MBC5_CLK;
    85c6:	4f cc       	rjmp	.-1890   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_0001:

00008420 <MBC5_0001>:

; ************************* WRITE JUMP TABLE (Read is hi)
.section .MBC5_0001,"ax",@progbits ;0x4210 Ram enable
MBC5_0001:
; Shouldn't beed an extra NOP like MBC3 because this mode already has an extra instruction before IJMP
  nop; This many NOPS may be needed to as data isn't good until WR is asserted
    8420:	00 00       	nop
  nop;
    8422:	00 00       	nop

  in    r17, _SFR_IO_ADDR(DATA_PIN)
    8424:	16 b1       	in	r17, 0x06	; 6
  cpi   r17, 0x0A; 0x0A is an enable command
    8426:	1a 30       	cpi	r17, 0x0A	; 10
  brne  MBC5_RAM_FLG_DIS
    8428:	11 f4       	brne	.+4      	; 0x842e <MBC5_RAM_FLG_DIS>
  cbi   _SFR_IO_ADDR(PORTA), PA7;
    842a:	17 98       	cbi	0x02, 7	; 2
  rjmp  MBC5_CLK
    842c:	1c cd       	rjmp	.-1480   	; 0x7e66 <MBC5_CLK>

0000842e <MBC5_RAM_FLG_DIS>:
MBC5_RAM_FLG_DIS:
  sbi   _SFR_IO_ADDR(PORTA), PA7
    842e:	17 9a       	sbi	0x02, 7	; 2
  rjmp  MBC5_CLK;
    8430:	1a cd       	rjmp	.-1484   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_0011:

00008460 <MBC5_0011>:
; 0x20-2F and 0x30-3F, instead of using a block address of 0x20-3F like in other MBC modes. The only 
; reason I am ignoring this is because I don't have 8MB of flash, and therefore should have absolutely
; no reason for anyone to access the 9th bit in the upper half of the address space! If they did, I 
; would need to connect ADDR12 to RUMBLE (and change this pin to be an input) and monitor it in this loop
MBC5_0011:
  nop
    8460:	00 00       	nop
  nop; Need a NOP here for DATA to be valid... without this, this is 13-16 cycles in, so it should be safe...
    8462:	00 00       	nop

  in    r22, _SFR_IO_ADDR(DATA_PIN); 8 lo bits of ROM address. Easy! Too bad you can't copy port to port
    8464:	66 b1       	in	r22, 0x06	; 6
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the MA mask value. Probably don't need to OUT this here for a WRITE command
    8466:	65 b9       	out	0x05, r22	; 5
  rjmp  MBC5_CLK;
    8468:	fe cc       	rjmp	.-1540   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_0101:

000084a0 <MBC5_0101>:

.section .MBC5_0101,"ax",@progbits ;0x4250 RAM bank number  - Rumble doesn't need to be masked anymore - rewired the prototype board.
MBC5_0101:
  in    r18, _SFR_IO_ADDR(PORTA) ;Prep for changing the RAM bank number
    84a0:	22 b1       	in	r18, 0x02	; 2
  andi  r18, 0xF4 ; CLR the old bits
    84a2:	24 7f       	andi	r18, 0xF4	; 244

  in    r17, _SFR_IO_ADDR(DATA_PIN);Read in DATA_PIN data
    84a4:	16 b1       	in	r17, 0x06	; 6
  andi  r17, 0x0B; Mask the RAM bank number (because we share a two bit value on the PORT)
    84a6:	1b 70       	andi	r17, 0x0B	; 11
  or    r18, r17 ; Put it together and whaddaya got?
    84a8:	21 2b       	or	r18, r17
  out   _SFR_IO_ADDR(PORTA), r18 
    84aa:	22 b9       	out	0x02, r18	; 2
  rjmp  MBC5_CLK;
    84ac:	dc cc       	rjmp	.-1608   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_0111:

000084e0 <.MBC5_0111>:

.section .MBC5_0111,"ax",@progbits ;0x4270 Not used in MBC5
  rjmp  MBC5_CLK;
    84e0:	c2 cc       	rjmp	.-1660   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_1001:

00008520 <.MBC5_1001>:

.section .MBC5_1001,"ax",@progbits ;0x4290 Reserved. Do nothing
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip if set
    8520:	4f 9b       	sbis	0x09, 7	; 9
  rjmp  MBC5_0001;
    8522:	7e cf       	rjmp	.-260    	; 0x8420 <MBC5_0001>

  rjmp  MBC5_CLK;
    8524:	a0 cc       	rjmp	.-1728   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_1011:

00008560 <.MBC5_1011>:

.section .MBC5_1011,"ax",@progbits ;0x42B0 RAM write
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip if set
    8560:	4f 9b       	sbis	0x09, 7	; 9
  rjmp  MBC5_0011;
    8562:	7e cf       	rjmp	.-260    	; 0x8460 <MBC5_0011>
  rjmp  MBC5_CLK;
    8564:	80 cc       	rjmp	.-1792   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_1101:

000085a0 <.MBC5_1101>:

.section .MBC5_1101,"ax",@progbits ;0x42D0 Reserved. Do nothing
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip if cleared
    85a0:	4f 9b       	sbis	0x09, 7	; 9
  rjmp  MBC5_0101;
    85a2:	7e cf       	rjmp	.-260    	; 0x84a0 <MBC5_0101>
  rjmp  MBC5_CLK;
    85a4:	60 cc       	rjmp	.-1856   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_1111:

000085e0 <.MBC5_1111>:

.section .MBC5_1111,"ax",@progbits ;0x42F0 Reserved. Do nothing
  rjmp  MBC5_CLK;
    85e0:	42 cc       	rjmp	.-1916   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC_BASE:

00007e00 <MBC_mode_MBC1_16M8k>:

.section .MBC_BASE,"ax",@progbits ;0x3F00
; **********************************************************************************
MBC_mode_MBC1_16M8k:
  ; Set up the external interrupt on PD2 for the interrupt
  ldi   r16, 0x03; set rising edge mask for EICRA
    7e00:	03 e0       	ldi	r16, 0x03	; 3
  sts   EICRA, r16; Set EICRA
    7e02:	00 93 69 00 	sts	0x0069, r16
  ldi   r16, 0x01
    7e06:	01 e0       	ldi	r16, 0x01	; 1
  out   _SFR_IO_ADDR(EIMSK), r16; set EIMSK to enable the rising edge INT0 interrupt
    7e08:	0d bb       	out	0x1d, r16	; 29
  clr   r0; Make r0 0x01 for use clearing interrupt flags later - r1 is always 0
    7e0a:	00 24       	eor	r0, r0
  inc   r0; r0 = 0x01
    7e0c:	03 94       	inc	r0
  clr   r1; Make sure this is zero, and leave it at zero!
    7e0e:	11 24       	eor	r1, r1

  ldi   r22, 0x01; MA14-18 must start as 0x01 to meet the MBC1 read spec (can't be bank 0)
    7e10:	61 e0       	ldi	r22, 0x01	; 1
  ldi   ZH, r31_MBC1_16M; Set high byte for MBC mode for IJMP call to 1 (can't be 0)
    7e12:	f0 e4       	ldi	r31, 0x40	; 64

00007e14 <MBC1_16M_CLK>:
  
MBC1_16M_CLK:; Wait for a CLK pulse
  sbis  _SFR_IO_ADDR(EIFR), INT0; See if the interrupt flag is set in EIFR, if so, continue, else loop
    7e14:	e0 9b       	sbis	0x1c, 0	; 28
  rjmp  MBC1_16M_CLK
    7e16:	fe cf       	rjmp	.-4      	; 0x7e14 <MBC1_16M_CLK>
  
  ; These NOPs are required because ADDR15 is set AFTER all of the other address bits. Min 5 cycles after the rjmp above
  out   _SFR_IO_ADDR(EIFR), r0; EIFR, clear the interrupt flag
    7e18:	0c ba       	out	0x1c, r0	; 28
	...
  nop 
  nop
  nop
  nop

  in    ZL, _SFR_IO_ADDR(PIND)
    7e22:	e9 b1       	in	r30, 0x09	; 9
  andi  ZL, 0xF0
    7e24:	e0 7f       	andi	r30, 0xF0	; 240
  ijmp
    7e26:	09 94       	ijmp

00007e28 <MBC_mode_MBC1_4M32k>:


; **************************************
MBC_mode_MBC1_4M32k:
  ; Set up the external interrupt on PD2 for the interrupt
  ldi   r16, 0x03; set rising edge mask for EICRA
    7e28:	03 e0       	ldi	r16, 0x03	; 3
  sts   EICRA, r16; Set EICRA
    7e2a:	00 93 69 00 	sts	0x0069, r16
  ldi   r16, 0x01
    7e2e:	01 e0       	ldi	r16, 0x01	; 1
  out   _SFR_IO_ADDR(EIMSK), r16; set EIMSK to enable the rising edge INT0 interrupt
    7e30:	0d bb       	out	0x1d, r16	; 29
  clr   r0; Make r0 0x01 for use clearing interrupt flags later - r1 is always 0
    7e32:	00 24       	eor	r0, r0
  inc   r0; r0 = 0x01
    7e34:	03 94       	inc	r0
  clr   r1; Make sure this is zero, and leave it at zero!
    7e36:	11 24       	eor	r1, r1

  ldi   r22, 0x01; MA14-18 must start as 0x01 to meet the MBC1 read spec (can't be bank 0)
    7e38:	61 e0       	ldi	r22, 0x01	; 1
  ldi   ZH, r31_MBC1_4M; Set high byte for MBC mode for IJMP call to 1 (can't be 0)
    7e3a:	f1 e4       	ldi	r31, 0x41	; 65

00007e3c <MBC1_4M_CLK>:
  
MBC1_4M_CLK:; Wait for a CLK pulse
  sbis  _SFR_IO_ADDR(EIFR), INT0; See if the interrupt flag is set in EIFR, if so, continue, else loop
    7e3c:	e0 9b       	sbis	0x1c, 0	; 28
  rjmp  MBC1_4M_CLK
    7e3e:	fe cf       	rjmp	.-4      	; 0x7e3c <MBC1_4M_CLK>
  
  ; These NOPs are required because ADDR15 is set AFTER all of the other address bits. Min 5 cycles after the rjmp above
  out   _SFR_IO_ADDR(EIFR), r0; EIFR, clear the interrupt flag
    7e40:	0c ba       	out	0x1c, r0	; 28
	...
  nop
  nop
  nop
  nop

  in    ZL, _SFR_IO_ADDR(PIND)
    7e4a:	e9 b1       	in	r30, 0x09	; 9
  andi  ZL, 0xF0
    7e4c:	e0 7f       	andi	r30, 0xF0	; 240
  ijmp
    7e4e:	09 94       	ijmp

00007e50 <MBC_mode_MBC5>:


; **********************************************************************************
MBC_mode_MBC5:
  ; Set up the external interrupt on PD2 for the interrupt
  ldi   r16, 0x03; set rising edge mask for EICRA
    7e50:	03 e0       	ldi	r16, 0x03	; 3
  sts   EICRA, r16; Set EICRA
    7e52:	00 93 69 00 	sts	0x0069, r16
  ldi   r16, 0x01
    7e56:	01 e0       	ldi	r16, 0x01	; 1
  out   _SFR_IO_ADDR(EIMSK), r16; set EIMSK to enable the rising edge INT0 interrupt
    7e58:	0d bb       	out	0x1d, r16	; 29
  clr   r0; Make r0 0x01 for use clearing interrupt flags later - r1 is always 0
    7e5a:	00 24       	eor	r0, r0
  inc   r0; r0 = 0x01
    7e5c:	03 94       	inc	r0
  clr   r1; Make sure this is zero, and leave it at zero!
    7e5e:	11 24       	eor	r1, r1

  ldi   r22, 0x01; Other code looks like it preloads this to bank 1, even though 0x00 is a valid bank for MBC5
    7e60:	61 e0       	ldi	r22, 0x01	; 1
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA14_18_21 value (r22)
    7e62:	65 b9       	out	0x05, r22	; 5
  ldi   r31, r31_MBC5; Set high byte for MBC mode for IJMP call to 1 (can't be 0)
    7e64:	f2 e4       	ldi	r31, 0x42	; 66

00007e66 <MBC5_CLK>:

MBC5_CLK:; Wait for a CLK pulse
  sbis  _SFR_IO_ADDR(EIFR), INT0; See if the interrupt flag is set in EIFR, if so, continue, else loop
    7e66:	e0 9b       	sbis	0x1c, 0	; 28
  rjmp  MBC5_CLK
    7e68:	fe cf       	rjmp	.-4      	; 0x7e66 <MBC5_CLK>
  
  ; These NOPs are required because ADDR15 is set AFTER all of the other address bits. Min 5 cycles after the rjmp above
  out   _SFR_IO_ADDR(EIFR), r0; EIFR, clear the interrupt flag
    7e6a:	0c ba       	out	0x1c, r0	; 28
  in    ZL, _SFR_IO_ADDR(PIND)
    7e6c:	e9 b1       	in	r30, 0x09	; 9
  andi  ZL, 0xF0
    7e6e:	e0 7f       	andi	r30, 0xF0	; 240
  in    r25, _SFR_IO_ADDR(PIND) ; Take this in to check CLK during READ cycles to go into double speed mode...
    7e70:	99 b1       	in	r25, 0x09	; 9
  ijmp
    7e72:	09 94       	ijmp

00007e74 <MBC5_DSM_CLK>:
 

MBC5_DSM_CLK:; Wait for a CLK pulse
  sbis  _SFR_IO_ADDR(EIFR), INT0; See if the interrupt flag is set in EIFR, if so, continue, else loop
    7e74:	e0 9b       	sbis	0x1c, 0	; 28
  rjmp  MBC5_DSM_CLK
    7e76:	fe cf       	rjmp	.-4      	; 0x7e74 <MBC5_DSM_CLK>
  out   _SFR_IO_ADDR(EIFR), r0; EIFR, clear the interrupt flag
    7e78:	0c ba       	out	0x1c, r0	; 28
  
  ; ADDR15 is set AFTER all of the other address bits. Guess 3 cycles in DSM - will have to test
  in    ZL, _SFR_IO_ADDR(PIND)
    7e7a:	e9 b1       	in	r30, 0x09	; 9
  andi  ZL, 0xF0 ; Would be nice to do away with this. But CLK is always going to be hi, UART lines are probably pulled up too as will WE. It may be better to invert these lines in HW instead...
    7e7c:	e0 7f       	andi	r30, 0xF0	; 240
  ijmp
    7e7e:	09 94       	ijmp

00007e80 <MBC_mode_MBC3>:


; **********************************************************************************
MBC_mode_MBC3:
  ; Set up the external interrupt on PD2 for the interrupt
  ldi   r16, 0x03; set rising edge mask for EICRA
    7e80:	03 e0       	ldi	r16, 0x03	; 3
  sts   EICRA, r16; Set EICRA
    7e82:	00 93 69 00 	sts	0x0069, r16
  ldi   r16, 0x01
    7e86:	01 e0       	ldi	r16, 0x01	; 1
  out   _SFR_IO_ADDR(EIMSK), r16; set EIMSK to enable the rising edge INT0 interrupt
    7e88:	0d bb       	out	0x1d, r16	; 29
  clr   r0; Make r0 0x01 for use clearing interrupt flags later - r1 is always 0
    7e8a:	00 24       	eor	r0, r0
  inc   r0; r0 = 0x01
    7e8c:	03 94       	inc	r0
  clr   r1; Make sure this is zero, and leave it at zero!
    7e8e:	11 24       	eor	r1, r1
  clr   r2; Clear r2 so that 1's complement will be 0xFF
    7e90:	22 24       	eor	r2, r2
  com   r2; set r2 as 0xFF for changing DDR for outputting RTC values
    7e92:	20 94       	com	r2
  clr   r3
    7e94:	33 24       	eor	r3, r3
  inc   r3
    7e96:	33 94       	inc	r3
  inc   r3; set r3=2 (0x02) to clear TIFR1 OCF1A flag
    7e98:	33 94       	inc	r3

  ; Set up timer1 to overflow ~1 sec
  ldi   r16, 0x62 ; This is high byte for timer 1. Total value of H and L register is 25200 (25804800 / 1024 = 25200 counts/sec)
    7e9a:	02 e6       	ldi	r16, 0x62	; 98
  sts   OCR1AH, r16
    7e9c:	00 93 89 00 	sts	0x0089, r16
  ldi   r16, 0x70 ; low byte for output compare
    7ea0:	00 e7       	ldi	r16, 0x70	; 112
  sts   OCR1AL, r16
    7ea2:	00 93 88 00 	sts	0x0088, r16
  ldi   r16, (1 << OCIE1A);
    7ea6:	02 e0       	ldi	r16, 0x02	; 2
  sts   TIMSK1, r16
    7ea8:	00 93 6f 00 	sts	0x006F, r16
  ldi   r16, (1 << WGM12) | (1 << CS12) | (1 << CS10) 
    7eac:	0d e0       	ldi	r16, 0x0D	; 13
  sts   TCCR1B, r16 ; CTC mode, OCR1A is TOP, prescaler=1024
    7eae:	00 93 81 00 	sts	0x0081, r16

  ldi   r22, 0x01; MA14-18 must start as 0x01 to meet the MBC1 read spec (can't be bank 0)
    7eb2:	61 e0       	ldi	r22, 0x01	; 1
  ldi   ZH, r31_MBC3; Set high byte for MBC mode for IJMP call to 1 (can't be 0)
    7eb4:	f3 e4       	ldi	r31, 0x43	; 67
; jump table.)

  ;r28 bit 7 will be used for RAM enable in MBC3 because of the need to disable RAM when reading/writing RTC registers
  ; Hmmm... might need to set up some timers too to act as a fake RTC
  ;r28 low nibble will be the RAM/RTC bank number. Need to save this for later when using INTRAMEN. 
  ldi   YL, 0x88 ; Sets bank 0 by default. The C setup code already pulled SRAM_CS hi
    7eb6:	c8 e8       	ldi	r28, 0x88	; 136
  // Because I don't use RAM in MBC modes (generally), I will use RAM for RTC values so I can use an indirect load instruction (from Y register)
  ldi   YH, 0x01; SRAM starts at 0x0100
    7eb8:	d1 e0       	ldi	r29, 0x01	; 1
  ; r20   hours
  ; r21   day counter lo8
  ; r23:0 day counter hi1
  ; r23:6 start (0) /stop (1)
  ; r23:7 day counter carry
  ldi   r18, 0 ; Need to think how I want to set default values for the RTC here
    7eba:	20 e0       	ldi	r18, 0x00	; 0
  ldi   r19, 30
    7ebc:	3e e1       	ldi	r19, 0x1E	; 30
  ldi   r20, 9
    7ebe:	49 e0       	ldi	r20, 0x09	; 9
  ldi   r21, 0
    7ec0:	50 e0       	ldi	r21, 0x00	; 0
  ldi   r23, 0
    7ec2:	70 e0       	ldi	r23, 0x00	; 0
  sts   0x188, r18
    7ec4:	20 93 88 01 	sts	0x0188, r18
  sts   0x189, r19
    7ec8:	30 93 89 01 	sts	0x0189, r19
  sts   0x18A, r20
    7ecc:	40 93 8a 01 	sts	0x018A, r20
  sts   0x18B, r21
    7ed0:	50 93 8b 01 	sts	0x018B, r21
  sts   0x18C, r23
    7ed4:	70 93 8c 01 	sts	0x018C, r23

00007ed8 <MBC3_CLK>:
  
MBC3_CLK:; Wait for a CLK pulse
  sbis  _SFR_IO_ADDR(EIFR), INT0; See if the interrupt flag is set in EIFR, if so, continue, else loop
    7ed8:	e0 9b       	sbis	0x1c, 0	; 28
  rjmp  MBC3_CLK
    7eda:	fe cf       	rjmp	.-4      	; 0x7ed8 <MBC3_CLK>

/*  ; These NOPs are required because ADDR15 is set AFTER all of the other address bits. Min 5 cycles after the rjmp above*/
  ; For this revision, data is (mostly) good to read after OUT. Replace the 5 NOP cycles 
  out   _SFR_IO_ADDR(EIFR), r0; EIFR, clear the interrupt flag
    7edc:	0c ba       	out	0x1c, r0	; 28
  in    ZL, _SFR_IO_ADDR(PIND)
    7ede:	e9 b1       	in	r30, 0x09	; 9
  andi  ZL, 0xF0
    7ee0:	e0 7f       	andi	r30, 0xF0	; 240
  ijmp
    7ee2:	09 94       	ijmp

00007ee4 <MBC_mode_MBC2>:
 

; **********************************************************************************
MBC_mode_MBC2:
  ; Set up the external interrupt on PD2 for the interrupt
  ldi   r16, 0x03; set rising edge mask for EICRA
    7ee4:	03 e0       	ldi	r16, 0x03	; 3
  sts   EICRA, r16; Set EICRA
    7ee6:	00 93 69 00 	sts	0x0069, r16
  ldi   r16, 0x01
    7eea:	01 e0       	ldi	r16, 0x01	; 1
  out   _SFR_IO_ADDR(EIMSK), r16; set EIMSK to enable the rising edge INT0 interrupt
    7eec:	0d bb       	out	0x1d, r16	; 29
  clr   r0; Make r0 0x01 for use clearing interrupt flags later - r1 is always 0
    7eee:	00 24       	eor	r0, r0
  inc   r0; r0 = 0x01
    7ef0:	03 94       	inc	r0
  clr   r1; Make sure this is zero, and leave it at zero!
    7ef2:	11 24       	eor	r1, r1

  ldi   r22, 0x01; MA14-17 must start as 0x01 to meet the MBC2 read spec (can't be bank 0)
    7ef4:	61 e0       	ldi	r22, 0x01	; 1
  ldi   ZH, r31_MBC2; Set high byte for MBC mode for IJMP call to 1 (can't be 0)
    7ef6:	f5 e4       	ldi	r31, 0x45	; 69

00007ef8 <MBC2_CLK>:

MBC2_CLK:; Wait for a CLK pulse
  sbis  _SFR_IO_ADDR(EIFR), INT0; See if the interrupt flag is set in EIFR, if so, continue, else loop
    7ef8:	e0 9b       	sbis	0x1c, 0	; 28
  rjmp  MBC2_CLK
    7efa:	fe cf       	rjmp	.-4      	; 0x7ef8 <MBC2_CLK>
  
  ; These NOPs are required because ADDR15 is set AFTER all of the other address bits. Min 5 cycles after the rjmp above
  out   _SFR_IO_ADDR(EIFR), r0; EIFR, clear the interrupt flag
    7efc:	0c ba       	out	0x1c, r0	; 28
  in    ZL, _SFR_IO_ADDR(PIND)
    7efe:	e9 b1       	in	r30, 0x09	; 9
  andi  ZL, 0xD0  ; NOTE: This mask is different to the other MBC modes as MBC2 does not have A13 connected
    7f00:	e0 7d       	andi	r30, 0xD0	; 208
                  ; Because of this difference, the jump table is half the size (take out A13=1!)
  ijmp
    7f02:	09 94       	ijmp

Disassembly of section .MBC3_0000:

00008600 <MBC3_0000>:
; ************* MBC3 MODE JUMP TABLE ***********************************************
; **********************************************************************************
; ************************* READ JUMP TABLE (Read is low)
.section .MBC3_0000,"ax",@progbits ;0x4300 ROM bank 0
MBC3_0000:
  out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
    8600:	15 b8       	out	0x05, r1	; 5

  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8602:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8604:	69 cc       	rjmp	.-1838   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8606:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8608:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    860a:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_0000_OUT              ; branch if not
    860c:	10 f0       	brcs	.+4      	; 0x8612 <MBC3_0000_OUT>
  inc   r19                        ; increment minutes
    860e:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8610:	22 27       	eor	r18, r18

00008612 <MBC3_0000_OUT>:
MBC3_0000_OUT:
  rjmp  MBC3_CLK;
    8612:	62 cc       	rjmp	.-1852   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_0010:

00008640 <MBC3_0010>:

.section .MBC3_0010,"ax",@progbits ;0x4320 ROM bank 0
MBC3_0010:
  out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
    8640:	15 b8       	out	0x05, r1	; 5

  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8642:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8644:	49 cc       	rjmp	.-1902   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8646:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8648:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    864a:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_0010_OUT              ; branch if not
    864c:	10 f0       	brcs	.+4      	; 0x8652 <MBC3_0010_OUT>
  inc   r19                        ; increment minutes
    864e:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8650:	22 27       	eor	r18, r18

00008652 <MBC3_0010_OUT>:
MBC3_0010_OUT:
  rjmp  MBC3_CLK;
    8652:	42 cc       	rjmp	.-1916   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_0100:

00008680 <MBC3_0100>:

.section .MBC3_0100,"ax",@progbits ;0x4340 ROM bank XX
MBC3_0100:
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    8680:	65 b9       	out	0x05, r22	; 5

  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8682:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8684:	29 cc       	rjmp	.-1966   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8686:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8688:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    868a:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_0100_OUT              ; branch if not
    868c:	10 f0       	brcs	.+4      	; 0x8692 <MBC3_0100_OUT>
  inc   r19                        ; increment minutes
    868e:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8690:	22 27       	eor	r18, r18

00008692 <MBC3_0100_OUT>:
MBC3_0100_OUT:
  rjmp  MBC3_CLK;
    8692:	22 cc       	rjmp	.-1980   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_0110:

000086c0 <MBC3_0110>:

.section .MBC3_0110,"ax",@progbits ;0x4360 ROM bank XX
MBC3_0110:
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    86c0:	65 b9       	out	0x05, r22	; 5
  
  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    86c2:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    86c4:	09 cc       	rjmp	.-2030   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    86c6:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    86c8:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    86ca:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_0110_OUT              ; branch if not
    86cc:	10 f0       	brcs	.+4      	; 0x86d2 <MBC3_0110_OUT>
  inc   r19                        ; increment minutes
    86ce:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    86d0:	22 27       	eor	r18, r18

000086d2 <MBC3_0110_OUT>:
MBC3_0110_OUT:
  rjmp  MBC3_CLK;
    86d2:	02 cc       	rjmp	.-2044   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_1000:

00008700 <MBC3_RTC_END-0x1a>:

.section .MBC3_1000,"ax",@progbits ;0x4380 Reserved. Do nothing
/*sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip is set
rjmp  MBC3_0000 ; ROM bank 0*/ ;This mode is reserved. It shouldn't care if we change things
out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
    8700:	15 b8       	out	0x05, r1	; 5

  ; Probably have about 12-13 cycles to do RTC updates where out is the only instruction, 9-10 where RJMPS occur (by my raw count :S)
  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8702:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8704:	e9 cb       	rjmp	.-2094   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8706:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8708:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    870a:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_RTC_END              ; branch if not
    870c:	30 f0       	brcs	.+12     	; 0x871a <MBC3_RTC_END>
  inc   r19                        ; increment minutes
    870e:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8710:	22 27       	eor	r18, r18
  cpi   r19, 60                    ; is minutes = 60
    8712:	3c 33       	cpi	r19, 0x3C	; 60
  brlo  MBC3_RTC_END              ; branch if not
    8714:	10 f0       	brcs	.+4      	; 0x871a <MBC3_RTC_END>
  inc   r20                       ; increment hours
    8716:	43 95       	inc	r20
  clr   r19                        ; clear minutes ; bah, this is 12 cycles here, and I haven't done a day check yet... I'll have to break it up unfortunately
    8718:	33 27       	eor	r19, r19

0000871a <MBC3_RTC_END>:
MBC3_RTC_END:
  rjmp  MBC3_CLK;
    871a:	de cb       	rjmp	.-2116   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_1010:

00008740 <MBC3_RTC_STUFF-0x4>:
.section .MBC3_1010,"ax",@progbits ;0x43A0 RAM/RTC read
;sbic  _SFR_IO_ADDR(PIND), 7; Check A15, skip is cleared - by combining these sections, I save 2 cycles for read
;rjmp  MBC3_RTC_STUFF ; ROM bank 0 ; This might cause us problems. Any chance we can swap it with RAM/RTC read?
;out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
;rjmp  MBC3_CLK;
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip if set - by combining these sections, I save 1 cycle for read
    8740:	4f 9b       	sbis	0x09, 7	; 9
rjmp  MBC3_0010
    8742:	7e cf       	rjmp	.-260    	; 0x8640 <MBC3_0010>

00008744 <MBC3_RTC_STUFF>:
  nop
;  nop ; might fit an extra one in. See if the RTC fails first,I think it would fail because I set the output too late first though
MBC3_NOT_RTC_RD:
  out   _SFR_IO_ADDR(DATA_DDR), r1 ; Revert or leave DATA_PIN as inputs
  out   _SFR_IO_ADDR(DATA_PORT), r1; Make 0 again, disable all pullups*/
  rjmp  MBC3_CLK;
    8744:	c9 cb       	rjmp	.-2158   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_1100:

00008780 <MBC3_RTC_END2-0x1a>:

.section .MBC3_1100,"ax",@progbits ;0x43C0 Reserved. Do nothing
/*sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip is set
rjmp  MBC3_0100 ; ROM bank XX*/ ;This mode is reserved. It shouldn't care if we change things
out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    8780:	65 b9       	out	0x05, r22	; 5

; Probably have about 12-13 cycles to do RTC updates where out is the only instruction, 9-10 where RJMPS occur (by my raw count :S)
  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8782:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8784:	a9 cb       	rjmp	.-2222   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8786:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8788:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    878a:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_RTC_END2             ; branch if not
    878c:	30 f0       	brcs	.+12     	; 0x879a <MBC3_RTC_END2>
  inc   r19                        ; increment minutes
    878e:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8790:	22 27       	eor	r18, r18
  cpi   r19, 60                    ; is minutes = 60
    8792:	3c 33       	cpi	r19, 0x3C	; 60
  brlo  MBC3_RTC_END2             ; branch if not
    8794:	10 f0       	brcs	.+4      	; 0x879a <MBC3_RTC_END2>
  inc   r20                       ; increment hours
    8796:	43 95       	inc	r20
  clr   r19                        ; clear minutes ; bah, this is 12 cycles here, and I haven't done a day check yet... I'll have to break it up unfortunately
    8798:	33 27       	eor	r19, r19

0000879a <MBC3_RTC_END2>:
MBC3_RTC_END2:
  rjmp  MBC3_CLK;
    879a:	9e cb       	rjmp	.-2244   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_1110:

000087c0 <MBC3_RTC_END3-0x1a>:

.section .MBC3_1110,"ax",@progbits ;0x43E0 Reserved. Do nothing
/*sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip is set
rjmp  MBC3_0110 ; ROM bank XX*/ ;This mode is reserved. It shouldn't care if we change things
out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    87c0:	65 b9       	out	0x05, r22	; 5

; Probably have about 12-13 cycles to do RTC updates where out is the only instruction, 9-10 where RJMPS occur (by my raw count :S)
  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    87c2:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    87c4:	89 cb       	rjmp	.-2286   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    87c6:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    87c8:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    87ca:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_RTC_END3              ; branch if not
    87cc:	30 f0       	brcs	.+12     	; 0x87da <MBC3_RTC_END3>
  inc   r19                        ; increment minutes
    87ce:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    87d0:	22 27       	eor	r18, r18
  cpi   r19, 60                    ; is minutes = 60
    87d2:	3c 33       	cpi	r19, 0x3C	; 60
  brlo  MBC3_RTC_END3              ; branch if not
    87d4:	10 f0       	brcs	.+4      	; 0x87da <MBC3_RTC_END3>
  inc   r20                       ; increment hours
    87d6:	43 95       	inc	r20
  clr   r19                        ; clear minutes ; bah, this is 12 cycles here, and I haven't done a day check yet... I'll have to break it up unfortunately
    87d8:	33 27       	eor	r19, r19

000087da <MBC3_RTC_END3>:
MBC3_RTC_END3:
  rjmp  MBC3_CLK;
    87da:	7e cb       	rjmp	.-2308   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_0001:

00008620 <MBC3_0001>:
MBC3_0001:
; Replacing 3 nops here with a hairbrained work around to load r7 with correct RTC value. Force Y to be enabled because code will fix it anyway!
;nop
;  nop
;  nop
  sbr   YL, 7; pretends RAM is enabled, even if it's not because it'll be fixed below!
    8620:	c7 60       	ori	r28, 0x07	; 7
  ld    r7, Y
    8622:	78 80       	ld	r7, Y

  in    r17, _SFR_IO_ADDR(DATA_PIN) ; No need to mask in MBC3 mode as it has D0-7 inputs
    8624:	16 b1       	in	r17, 0x06	; 6
  cpi   r17, 0x0A; 0x0A is an enable command
    8626:	1a 30       	cpi	r17, 0x0A	; 10
  brne  MBC3_RAM_FLG_DIS
    8628:	11 f4       	brne	.+4      	; 0x862e <MBC3_RAM_FLG_DIS>
;  sbr   YL, 7; Enable RAM/RTC
  cbi   _SFR_IO_ADDR(PORTA), PA7;
    862a:	17 98       	cbi	0x02, 7	; 2
  rjmp  MBC3_CLK
    862c:	55 cc       	rjmp	.-1878   	; 0x7ed8 <MBC3_CLK>

0000862e <MBC3_RAM_FLG_DIS>:
MBC3_RAM_FLG_DIS:
  cbr   YL, 7; Disable RTC
    862e:	c8 7f       	andi	r28, 0xF8	; 248
  sbi   _SFR_IO_ADDR(PORTA), PA7; Disable RAM
    8630:	17 9a       	sbi	0x02, 7	; 2
  rjmp  MBC3_CLK;
    8632:	52 cc       	rjmp	.-1884   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_0011:

00008660 <MBC3_0011>:

.section .MBC3_0011,"ax",@progbits ;0x4330 ROM bank numbers
MBC3_0011:
  nop;
    8660:	00 00       	nop
  nop; Need a NOP here for DATA to be valid... without this, this is 13-16 cycles in, so it should be safe...
    8662:	00 00       	nop
nop
    8664:	00 00       	nop
  in    r22, _SFR_IO_ADDR(DATA_PIN); We can read r22 directly in MBC3 mode because there are no other hi ROM bits to worry about
    8666:	66 b1       	in	r22, 0x06	; 6
  andi  r22, 0x7F ; Mask D0-6. I don't want to add this, but I haven't tested if MBC data is corrupted otherwise
    8668:	6f 77       	andi	r22, 0x7F	; 127
  tst   r22
    866a:	66 23       	and	r22, r22
  brne  MBC3_NZERO
    866c:	09 f4       	brne	.+2      	; 0x8670 <MBC3_NZERO>
  inc   r22; MBC3 still doesn't put bank 0 at location 1.
    866e:	63 95       	inc	r22

00008670 <MBC3_NZERO>:
MBC3_NZERO:
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the MA mask value. Probably don't need to OUT this here for a WRITE command
    8670:	65 b9       	out	0x05, r22	; 5
  rjmp  MBC3_CLK;
    8672:	32 cc       	rjmp	.-1948   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_0101:

000086a0 <MBC3_0101>:

.section .MBC3_0101,"ax",@progbits ;0x4350 RAM/RTC bank number
MBC3_0101:
  in    r24, _SFR_IO_ADDR(PORTA) ;Prep for changing the RAM bank number
    86a0:	82 b1       	in	r24, 0x02	; 2
  andi  r24, 0xFC ; CLR the old bits on the PORT 
    86a2:	8c 7f       	andi	r24, 0xFC	; 252
;nop
  andi  YL, 0x80; Clear the old register value, except for RTC enable/disable
    86a4:	c0 78       	andi	r28, 0x80	; 128
  in    r17, _SFR_IO_ADDR(DATA_PIN);Read in DATA_PIN data
    86a6:	16 b1       	in	r17, 0x06	; 6
  or    YL, r17; Save the bank number for later - Need this to stop READ and WRITE commands from reading RTC values when physical RAM is mapped
    86a8:	c1 2b       	or	r28, r17
  
  cpi   r17, 0x04 ; Valid physical RAM banks are 0-3. Anything higher disables physical RAM
    86aa:	14 30       	cpi	r17, 0x04	; 4
  brsh  MBC3_RTC_REGS; Branch if same or higher
    86ac:	28 f4       	brcc	.+10     	; 0x86b8 <MBC3_RTC_REGS>
  ; It's a physical bank here 
  or    r24, r17 ; Put the new value into PORTA temp value
    86ae:	81 2b       	or	r24, r17
  out   _SFR_IO_ADDR(PORTA), r24 ; Push PORTA back out
    86b0:	82 b9       	out	0x02, r24	; 2
  sbrc  YL, 7; If bit 7 in r28 is cleared, then RAM isn't enabled. Don't enable RAM!
    86b2:	c7 fd       	sbrc	r28, 7
  cbi   _SFR_IO_ADDR(PORTA), PA7;
    86b4:	17 98       	cbi	0x02, 7	; 2
  rjmp  MBC3_CLK;
    86b6:	10 cc       	rjmp	.-2016   	; 0x7ed8 <MBC3_CLK>

000086b8 <MBC3_RTC_REGS>:
MBC3_RTC_REGS:
  sbi   _SFR_IO_ADDR(PORTA), PA7; Disable RAM
    86b8:	17 9a       	sbi	0x02, 7	; 2
  ld    r7, Y ; Load r7 with the RTC value pointed to by the Y register. WARNING! THIS CODE READS INCORRECT LCOATION IF RAM IS DISABLED AS r28 BIT 7 = 0!
    86ba:	78 80       	ld	r7, Y
  ldi   ZH, r31_MBC3_RTC ; Change the jump table value!
    86bc:	f6 e4       	ldi	r31, 0x46	; 70
  rjmp  MBC3_CLK;
    86be:	0c cc       	rjmp	.-2024   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_0111:

000086e0 <MBC3_0111>:

.section .MBC3_0111,"ax",@progbits ;0x4370 Latch RTC data
MBC3_0111:
  ; To latch data, send it to RAM! (this simplifies retrieval later on). This isn't quite in the MBC3 spec, but it's easier than write sequences
  sts   0x188, r18
    86e0:	20 93 88 01 	sts	0x0188, r18
  sts   0x189, r19
    86e4:	30 93 89 01 	sts	0x0189, r19
  sts   0x18A, r20
    86e8:	40 93 8a 01 	sts	0x018A, r20
  sts   0x18B, r21
    86ec:	50 93 8b 01 	sts	0x018B, r21
  sts   0x18C, r23
    86f0:	70 93 8c 01 	sts	0x018C, r23
  rjmp  MBC3_CLK;
    86f4:	f1 cb       	rjmp	.-2078   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_1001:

00008720 <MBC3_RTC_END4-0x18>:

.section .MBC3_1001,"ax",@progbits ;0x4390 Reserved. Do nothing
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip if set
    8720:	4f 9b       	sbis	0x09, 7	; 9
rjmp  MBC3_0001 ; Jump to RAM/RTC enable
    8722:	7e cf       	rjmp	.-260    	; 0x8620 <MBC3_0001>

  ; Do day counting here
  cpi   r20, 24                   ; is hours = 24
    8724:	48 31       	cpi	r20, 0x18	; 24
  brlo  MBC3_RTC_END4             ; branch if not
    8726:	40 f0       	brcs	.+16     	; 0x8738 <MBC3_RTC_END4>
  clr   r20                       ; clear hours
    8728:	44 27       	eor	r20, r20
  inc   r21                       ; increment days - swapped the order here because I want to do an overflow check to increment 
    872a:	53 95       	inc	r21
  tst   r21                       ; Is r11 now 0? If so, it's an overflow (or someone stopped the counter beautifully...)
    872c:	55 23       	and	r21, r21
  brne  MBC3_RTC_END4             ; branch if not
    872e:	21 f4       	brne	.+8      	; 0x8738 <MBC3_RTC_END4>
  sbrc  r23, 0                    ; Check if hi bit of day counter is already set
    8730:	70 fd       	sbrc	r23, 0
  sbr   r23, 7                    ; Set the overflow bit
    8732:	77 60       	ori	r23, 0x07	; 7
  inc   r23                       ; inc r12, because 1+1 = 2! (which we can then mask out - nothing uses bit 1 of this register I believe)
    8734:	73 95       	inc	r23
  andi  r23, 0xC1                 ; keep bit 0, 6 and 7. Clear all others
    8736:	71 7c       	andi	r23, 0xC1	; 193

00008738 <MBC3_RTC_END4>:
MBC3_RTC_END4:
  rjmp  MBC3_CLK;
    8738:	cf cb       	rjmp	.-2146   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_1011:

00008760 <MBC3_RTC_SRG-0x12>:

.section .MBC3_1011,"ax",@progbits ;0x43B0 RAM/RTC write
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip is set
    8760:	4f 9b       	sbis	0x09, 7	; 9
rjmp  MBC3_0011 ; Jump to ROM bank numbers
    8762:	7e cf       	rjmp	.-260    	; 0x8660 <MBC3_0011>

  ;  cpi   YL, 0x88; If r28 is >=0x88, RTC is enabled and bank 8-C are selected. Do an RTC write
  cpi   YL, 0x8C; NOTE: I'm running too low on cycles to update seconds and minutes, so I'm only doing hours and days. Who cares about hours anyway?
    8764:	cc 38       	cpi	r28, 0x8C	; 140
  breq  MBC3_RTC_SRG
    8766:	29 f0       	breq	.+10     	; 0x8772 <MBC3_RTC_SRG>
  cpi   YL, 0x8B; NOTE: I'm running too low on cycles to update seconds and minutes, so I'm only doing hours and days. Who cares about hours anyway?
    8768:	cb 38       	cpi	r28, 0x8B	; 139
  breq  MBC3_RTC_DAY
    876a:	31 f0       	breq	.+12     	; 0x8778 <MBC3_RTC_DAY>
  cpi   YL, 0x8A; NOTE: I'm running too low on cycles to update seconds and minutes, so I'm only doing hours and days. Who cares about hours anyway?
    876c:	ca 38       	cpi	r28, 0x8A	; 138
  breq  MBC3_RTC_HRS
    876e:	31 f0       	breq	.+12     	; 0x877c <MBC3_RTC_HRS>
  rjmp  MBC3_CLK;
    8770:	b3 cb       	rjmp	.-2202   	; 0x7ed8 <MBC3_CLK>

00008772 <MBC3_RTC_SRG>:

MBC3_RTC_SRG: 
  nop;
    8772:	00 00       	nop
  in    r23, _SFR_IO_ADDR(DATA_PIN);Read in DATA_PIN data
    8774:	76 b1       	in	r23, 0x06	; 6
  rjmp  MBC3_CLK
    8776:	b0 cb       	rjmp	.-2208   	; 0x7ed8 <MBC3_CLK>

00008778 <MBC3_RTC_DAY>:
MBC3_RTC_DAY:
  in    r21, _SFR_IO_ADDR(DATA_PIN);Read in DATA_PIN data
    8778:	56 b1       	in	r21, 0x06	; 6
  rjmp  MBC3_CLK
    877a:	ae cb       	rjmp	.-2212   	; 0x7ed8 <MBC3_CLK>

0000877c <MBC3_RTC_HRS>:
MBC3_RTC_HRS:
  in    r20, _SFR_IO_ADDR(DATA_PIN);Read in DATA_PIN data
    877c:	46 b1       	in	r20, 0x06	; 6
  rjmp  MBC3_CLK
    877e:	ac cb       	rjmp	.-2216   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_1101:

000087a0 <.MBC3_1101>:

.section .MBC3_1101,"ax",@progbits ;0x43D0 Reserved. Do nothing
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip if set
    87a0:	4f 9b       	sbis	0x09, 7	; 9
rjmp  MBC3_0101 ; Jump to RAM/RTC bank number. Or do it here and make the above SBIC
    87a2:	7e cf       	rjmp	.-260    	; 0x86a0 <MBC3_0101>

  rjmp  MBC3_CLK;
    87a4:	99 cb       	rjmp	.-2254   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_1111:

000087e0 <MBC3_RTC_END5-0x18>:

.section .MBC3_1111,"ax",@progbits ;0x43F0 Reserved. Do nothing
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip is set
    87e0:	4f 9b       	sbis	0x09, 7	; 9
rjmp  MBC3_0111 ; Jump to Latch RTC. Or do it here and make the above SBIC
    87e2:	7e cf       	rjmp	.-260    	; 0x86e0 <MBC3_0111>

  ; Do day counting here
  cpi   r20, 24                   ; is hours = 24
    87e4:	48 31       	cpi	r20, 0x18	; 24
  brlo  MBC3_RTC_END5             ; branch if not
    87e6:	40 f0       	brcs	.+16     	; 0x87f8 <MBC3_RTC_END5>
  clr   r20                       ; clear hours
    87e8:	44 27       	eor	r20, r20
  inc   r21                       ; increment days - swapped the order here because I want to do an overflow check to increment 
    87ea:	53 95       	inc	r21
  tst   r21                       ; Is r11 now 0? If so, it's an overflow (or someone stopped the counter beautifully...)
    87ec:	55 23       	and	r21, r21
  brne  MBC3_RTC_END5             ; branch if not
    87ee:	21 f4       	brne	.+8      	; 0x87f8 <MBC3_RTC_END5>
  sbrc  r23, 0                    ; Check if hi bit of day counter is already set
    87f0:	70 fd       	sbrc	r23, 0
  sbr   r23, 7                    ; Set the overflow bit
    87f2:	77 60       	ori	r23, 0x07	; 7
  inc   r23                       ; inc r12, because 1+1 = 2! (which we can then mask out - nothing uses bit 1 of this register I believe)
    87f4:	73 95       	inc	r23
  andi  r23, 0xC1                 ; keep bit 0, 6 and 7. Clear all others
    87f6:	71 7c       	andi	r23, 0xC1	; 193

000087f8 <MBC3_RTC_END5>:
MBC3_RTC_END5:
  rjmp  MBC3_CLK;
    87f8:	6f cb       	rjmp	.-2338   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC5_DSM_0000:

00008800 <.MBC5_DSM_0000>:
; **********************************************************************************
; ************* MBC5 DOUBLE SPEED MODE JUMP TABLE **********************************
; **********************************************************************************
; ************************* READ JUMP TABLE (Read is low)
.section .MBC5_DSM_0000,"ax",@progbits ;0x4400 ROM bank 0
  sbic  _SFR_IO_ADDR(PIND), 2; If CLK is hi here, then we're not in DSM. Change the jump table!
    8800:	4a 99       	sbic	0x09, 2	; 9
  ldi   ZH, r31_MBC5
    8802:	f2 e4       	ldi	r31, 0x42	; 66
  rjmp  MBC5_DSM_CLK;
    8804:	37 cb       	rjmp	.-2450   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_0010:

00008840 <.MBC5_DSM_0010>:

.section .MBC5_DSM_0010,"ax",@progbits ;0x4420 ROM bank 0
  sbic  _SFR_IO_ADDR(PIND), 2; If CLK is hi here, then we're not in DSM. Change the jump table!
    8840:	4a 99       	sbic	0x09, 2	; 9
  ldi   ZH, r31_MBC5
    8842:	f2 e4       	ldi	r31, 0x42	; 66
  rjmp  MBC5_DSM_CLK;
    8844:	17 cb       	rjmp	.-2514   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_0100:

00008880 <.MBC5_DSM_0100>:

.section .MBC5_DSM_0100,"ax",@progbits ;0x4440 ROM bank XX
  sbic  _SFR_IO_ADDR(PIND), 2; If CLK is hi here, then we're not in DSM. Change the jump table!
    8880:	4a 99       	sbic	0x09, 2	; 9
  ldi   ZH, r31_MBC5
    8882:	f2 e4       	ldi	r31, 0x42	; 66
  rjmp  MBC5_DSM_CLK;
    8884:	f7 ca       	rjmp	.-2578   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_0110:

000088c0 <.MBC5_DSM_0110>:

.section .MBC5_DSM_0110,"ax",@progbits ;0x4460 ROM bank XX
  sbic  _SFR_IO_ADDR(PIND), 2; If CLK is hi here, then we're not in DSM. Change the jump table!
    88c0:	4a 99       	sbic	0x09, 2	; 9
  ldi   ZH, r31_MBC5
    88c2:	f2 e4       	ldi	r31, 0x42	; 66
  rjmp  MBC5_DSM_CLK;
    88c4:	d7 ca       	rjmp	.-2642   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_1000:

00008900 <.MBC5_DSM_1000>:

.section .MBC5_DSM_1000,"ax",@progbits ;0x4480 Reserved. Do nothing
  in    r23, _SFR_IO_ADDR(PORTA) ; Doing stuff in here to try and compensate for a lack of cycles elsewhere. Don't even know if this is useful.
    8900:	72 b1       	in	r23, 0x02	; 2
  ori   r23, 0x80; I think I overstep CLK boundaries by adding a fourth instruction here, but I need it...
    8902:	70 68       	ori	r23, 0x80	; 128
  rjmp  MBC5_DSM_CLK;
    8904:	b7 ca       	rjmp	.-2706   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_1010:

00008940 <.MBC5_DSM_1010>:
  ; in calling this code. May be a flawed assumption which could break things.
;  in    r23, _SFR_IO_ADDR(PORTA)
;  mov   r24, r23 ; Make a copy
;  cbr   r24, 0x03; CLR the RAM bank bits in prep for ORing it later
;  ori   r23, 0x80; I think I overstep CLK boundaries by adding a fourth instruction here, but I need it...
  rjmp  MBC5_DSM_CLK;
    8940:	99 ca       	rjmp	.-2766   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_1100:

00008980 <.MBC5_DSM_1100>:

.section .MBC5_DSM_1100,"ax",@progbits ;0x44C0 Reserved. Do nothing
  in    r24, _SFR_IO_ADDR(PORTA); Doing stuff in here to try and compensate for a lack of cycles elsewhere. Don't even know if this is useful.
    8980:	82 b1       	in	r24, 0x02	; 2
  cbr   r24, 0x03; CLR the RAM bank bits in prep for ORing it later
    8982:	8c 7f       	andi	r24, 0xFC	; 252
  rjmp  MBC5_DSM_CLK;
    8984:	77 ca       	rjmp	.-2834   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_1110:

000089c0 <.MBC5_DSM_1110>:

.section .MBC5_DSM_1110,"ax",@progbits ;0x44E0 Reserved. Do nothing
  in    r23, _SFR_IO_ADDR(PORTA) ; Doing stuff in here to try and compensate for a lack of cycles elsewhere. Don't even know if this is useful.
    89c0:	72 b1       	in	r23, 0x02	; 2
  ori   r23, 0x80; I think I overstep CLK boundaries by adding a fourth instruction here, but I need it...
    89c2:	70 68       	ori	r23, 0x80	; 128
  rjmp  MBC5_DSM_CLK;
    89c4:	57 ca       	rjmp	.-2898   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_0001:

00008820 <.MBC5_DSM_0001>:
; No NOPs in DSM. Assume WR is asserted already
; We're going to play dangerously for DSM. Just check for 0x08 instead of 0x0A to save cycles
;  out   _SFR_IO_ADDR(PORTA), r23  ; Immediately disable RAM (should have already OR'd this)
;  sbic  _SFR_IO_ADDR(DATA_PIN), 3     ; Check for 0x08
; *** UNSAFE SAVE GAME TEST! - RAM IS ALWAYS ENABLED HERE TO TEST WHY SAVEGAMES DON'T WORK IN POKTRDCRDGME! ***
  cbi   _SFR_IO_ADDR(PORTA), PA7  ; Eugh, this is a 2 cycle instruction, it may break things...
    8820:	17 98       	cbi	0x02, 7	; 2
in    r24, _SFR_IO_ADDR(PORTA); Doing stuff in here to try and compensate for a lack of cycles elsewhere. Don't even know if this is useful.
    8822:	82 b1       	in	r24, 0x02	; 2
cbr   r24, 0x0F; CLR the RAM bank bits in prep for ORing it later
    8824:	80 7f       	andi	r24, 0xF0	; 240
  rjmp  MBC5_DSM_CLK
    8826:	26 cb       	rjmp	.-2484   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_0011:

00008860 <.MBC5_DSM_0011>:
; Technically I cheat in this loop. This address space is actually broken up into lo8 and hi1 across 
; 0x20-2F and 0x30-3F, instead of using a block address of 0x20-3F like in other MBC modes. The only 
; reason I am ignoring this is because I don't have 8MB of flash, and therefore should have absolutely
; no reason for anyone to access the 9th bit in the upper half of the address space! If they did, I 
; would need to connect ADDR12 to RUMBLE (and change this pin to be an input) and monitor it in this loop
  in    r22, _SFR_IO_ADDR(DATA_PIN); 8 lo bits of ROM address. Easy! Too bad you can't copy port to port
    8860:	66 b1       	in	r22, 0x06	; 6
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the MA mask value. Probably don't need to OUT this here for a WRITE command
    8862:	65 b9       	out	0x05, r22	; 5
  rjmp  MBC5_DSM_CLK;
    8864:	07 cb       	rjmp	.-2546   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_0101:

000088a0 <.MBC5_DSM_0101>:

.section .MBC5_DSM_0101,"ax",@progbits ;0x4450 RAM bank number  - NEED TO CHANGE THE PINOUT TO LET THE RUMBLE PIN BE MASKED EASILY!
  in    r17, _SFR_IO_ADDR(DATA_PIN);Read in DATA_PIN data, no mask because speed... Very dangerous.
    88a0:	16 b1       	in	r17, 0x06	; 6
cbr   r24, 0x0F; CLR the RAM bank bits in prep for ORing it later
    88a2:	80 7f       	andi	r24, 0xF0	; 240
  or    r24, r17 ; This is dangerous if RAM bank is changed consecutively without reading or writing, because r24 isn't cleared!
    88a4:	81 2b       	or	r24, r17
  out   _SFR_IO_ADDR(PORTA), r24
    88a6:	82 b9       	out	0x02, r24	; 2
  rjmp  MBC5_DSM_CLK;
    88a8:	e5 ca       	rjmp	.-2614   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_0111:

000088e0 <.MBC5_DSM_0111>:

.section .MBC5_DSM_0111,"ax",@progbits ;0x4470 Not used in MBC5
;  in    r24, _SFR_IO_ADDR(PORTA); Doing stuff in here to try and compensate for a lack of cycles elsewhere. Don't even know if this is useful.
;  cbr   r24, 0x03; CLR the RAM bank bits in prep for ORing it later
  rjmp  MBC5_DSM_CLK;
    88e0:	c9 ca       	rjmp	.-2670   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_1001:

00008920 <.MBC5_DSM_1001>:

.section .MBC5_DSM_1001,"ax",@progbits ;0x4490 Reserved. Do nothing
;  in    r23, _SFR_IO_ADDR(PORTA) ; Doing stuff in here to try and compensate for a lack of cycles elsewhere. Don't even know if this is useful.
;  ori   r23, 0x80; I think I overstep CLK boundaries by adding a fourth instruction here, but I need it...
  rjmp  MBC5_DSM_CLK;
    8920:	a9 ca       	rjmp	.-2734   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_1011:

00008960 <.MBC5_DSM_1011>:
  ; in calling this code. May be a flawed assumption which could break things.
;  in    r23, _SFR_IO_ADDR(PORTA)
;  mov   r24, r23 ; Make a copy
;  cbr   r24, 0x03; CLR the RAM bank bits in prep for ORing it later
;  ori   r23, 0x80; I think I overstep CLK boundaries by adding a fourth instruction here, but I need it...
  rjmp  MBC5_DSM_CLK;
    8960:	89 ca       	rjmp	.-2798   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_1101:

000089a0 <.MBC5_DSM_1101>:

.section .MBC5_DSM_1101,"ax",@progbits ;0x44D0 Reserved. Do nothing
;  in    r24, _SFR_IO_ADDR(PORTA); Doing stuff in here to try and compensate for a lack of cycles elsewhere. Don't even know if this is useful.
;  cbr   r24, 0x03; CLR the RAM bank bits in prep for ORing it later
  rjmp  MBC5_DSM_CLK;
    89a0:	69 ca       	rjmp	.-2862   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_1111:

000089e0 <.MBC5_DSM_1111>:

.section .MBC5_DSM_1111,"ax",@progbits ;0x44F0 Reserved. Do nothing
;  in    r24, _SFR_IO_ADDR(PORTA); Doing stuff in here to try and compensate for a lack of cycles elsewhere. Don't even know if this is useful.
;  cbr   r24, 0x03; CLR the RAM bank bits in prep for ORing it later
  rjmp  MBC5_DSM_CLK;
    89e0:	49 ca       	rjmp	.-2926   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC2_0000:

00008a00 <.MBC2_0000>:
; **********************************************************************************
; ************* MBC2 MODE JUMP TABLE ***********************************************
; **********************************************************************************
; ************************* READ JUMP TABLE (Read is low)
.section .MBC2_0000,"ax",@progbits ;0x4500 ROM bank 0
  out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
    8a00:	15 b8       	out	0x05, r1	; 5
  rjmp  MBC2_CLK; Finished setting up the lines for a read :)
    8a02:	7a ca       	rjmp	.-2828   	; 0x7ef8 <MBC2_CLK>

Disassembly of section .MBC2_0100:

00008a80 <.MBC2_0100>:

.section .MBC2_0100,"ax",@progbits ;0x4540 ROM bank XX
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    8a80:	65 b9       	out	0x05, r22	; 5
  rjmp  MBC2_CLK; Finished setting up the lines for a read :)
    8a82:	3a ca       	rjmp	.-2956   	; 0x7ef8 <MBC2_CLK>

Disassembly of section .MBC2_1000:

00008b00 <.MBC2_1000>:


.section .MBC2_1000,"ax",@progbits ;0x4580 Reserved. Do nothing
out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
    8b00:	15 b8       	out	0x05, r1	; 5
  rjmp  MBC2_CLK;
    8b02:	fa c9       	rjmp	.-3084   	; 0x7ef8 <MBC2_CLK>

Disassembly of section .MBC2_1100:

00008b80 <.MBC2_1100>:

.section .MBC2_1100,"ax",@progbits ;0x45C0 Reserved. Do nothing
out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    8b80:	65 b9       	out	0x05, r22	; 5
  rjmp  MBC2_CLK;
    8b82:	ba c9       	rjmp	.-3212   	; 0x7ef8 <MBC2_CLK>

Disassembly of section .MBC2_0001:

00008a20 <MBC2_RAM_FLG_DIS-0x12>:

; ************************* WRITE JUMP TABLE (Read is hi)
.section .MBC2_0001,"ax",@progbits ;0x4510 Ram enable/disable OR ROM bank numbers. Need to read A8!!!
; Read A8 here, JMP to ROM bank numbers if A8=1, else continue
  sbic  _SFR_IO_ADDR(PINC), 7; Using MA21 as A8 (in theory)
    8a20:	37 99       	sbic	0x06, 7	; 6
  rjmp  MBC2_ROM_BANKING
    8a22:	09 c0       	rjmp	.+18     	; 0x8a36 <MBC2_ROM_BANKING>

  nop
    8a24:	00 00       	nop
  in    r17, _SFR_IO_ADDR(DATA_PIN)
    8a26:	16 b1       	in	r17, 0x06	; 6
  andi  r17, 0x0F ; Mask D0-4. I don't want to add this, but we'll see if MBC data is corrupted otherwise
    8a28:	1f 70       	andi	r17, 0x0F	; 15
  cpi   r17, 0x0A; 0x0A is an enable command - Is this valid for MBC2? It's not specific on the gbdev wiki
    8a2a:	1a 30       	cpi	r17, 0x0A	; 10
  brne  MBC2_RAM_FLG_DIS
    8a2c:	11 f4       	brne	.+4      	; 0x8a32 <MBC2_RAM_FLG_DIS>
  cbi   _SFR_IO_ADDR(PORTA), PA7;
    8a2e:	17 98       	cbi	0x02, 7	; 2
  rjmp  MBC2_CLK
    8a30:	63 ca       	rjmp	.-2874   	; 0x7ef8 <MBC2_CLK>

00008a32 <MBC2_RAM_FLG_DIS>:
MBC2_RAM_FLG_DIS:
  sbi   _SFR_IO_ADDR(PORTA), PA7
    8a32:	17 9a       	sbi	0x02, 7	; 2
  rjmp  MBC2_CLK
    8a34:	61 ca       	rjmp	.-2878   	; 0x7ef8 <MBC2_CLK>

00008a36 <MBC2_ROM_BANKING>:

MBC2_ROM_BANKING:
  andi  r22, 0xF0;REG_MA14_18, MA19_21_MASK ; Mask only hi bits to ditch the old low bits
    8a36:	60 7f       	andi	r22, 0xF0	; 240
;  nop; Need a NOP here for DATA to be valid... without this, this is 13-16 cycles in, so it should be safe...
  in    r17, _SFR_IO_ADDR(DATA_PIN);GB_DAT_REG, GB_DAT_R ;Read in DATA_PIN data for use in each write mode
    8a38:	16 b1       	in	r17, 0x06	; 6
  andi  r17, 0x0F ; Mask D0-3.
    8a3a:	1f 70       	andi	r17, 0x0F	; 15
  tst   r17
    8a3c:	11 23       	and	r17, r17
  brne  MBC2_NZERO
    8a3e:	09 f4       	brne	.+2      	; 0x8a42 <MBC2_NZERO>
  inc   r17
    8a40:	13 95       	inc	r17

00008a42 <MBC2_NZERO>:
MBC2_NZERO:
  or    r22, r17;REG_MA14_18, GB_DAT_REG
    8a42:	61 2b       	or	r22, r17
;  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the MA mask value. Probably don't need to OUT this here for a WRITE command
  rjmp  MBC2_CLK;
    8a44:	59 ca       	rjmp	.-2894   	; 0x7ef8 <MBC2_CLK>

Disassembly of section .MBC2_0101:

00008aa0 <.MBC2_0101>:

.section .MBC2_0101,"ax",@progbits ;0x4550 Not used for MBC2
  rjmp MBC2_CLK;
    8aa0:	2b ca       	rjmp	.-2986   	; 0x7ef8 <MBC2_CLK>

Disassembly of section .MBC2_1001:

00008b20 <MBC2_RAM_FLG_DIS2-0x16>:

.section .MBC2_1001,"ax",@progbits ;0x4590 Reserved. Do nothing
sbic  _SFR_IO_ADDR(PIND), 7; Check A15, skip is cleared - by combining these sections, I save 2 cycles for read
    8b20:	4f 99       	sbic	0x09, 7	; 9
  rjmp  MBC2_CLK;
    8b22:	ea c9       	rjmp	.-3116   	; 0x7ef8 <MBC2_CLK>
; Do RAM enable/ROM read here (A15=0)
; Read A8 here, JMP to ROM bank numbers if A8=1, else continue
  sbic  _SFR_IO_ADDR(PINC), 7; Using MA21 as A8 (in theory)
    8b24:	37 99       	sbic	0x06, 7	; 6
  rjmp  MBC2_ROM_BANKING2
    8b26:	09 c0       	rjmp	.+18     	; 0x8b3a <MBC2_ROM_BANKING2>

  nop
    8b28:	00 00       	nop
  in    r17, _SFR_IO_ADDR(DATA_PIN)
    8b2a:	16 b1       	in	r17, 0x06	; 6
  andi  r17, 0x0F ; Mask D0-4. I don't want to add this, but we'll see if MBC data is corrupted otherwise
    8b2c:	1f 70       	andi	r17, 0x0F	; 15
  cpi   r17, 0x0A; 0x0A is an enable command - Is this valid for MBC2? It's not specific on the gbdev wiki
    8b2e:	1a 30       	cpi	r17, 0x0A	; 10
  brne  MBC2_RAM_FLG_DIS2
    8b30:	11 f4       	brne	.+4      	; 0x8b36 <MBC2_RAM_FLG_DIS2>
  cbi   _SFR_IO_ADDR(PORTA), PA7;
    8b32:	17 98       	cbi	0x02, 7	; 2
  rjmp  MBC2_CLK
    8b34:	e1 c9       	rjmp	.-3134   	; 0x7ef8 <MBC2_CLK>

00008b36 <MBC2_RAM_FLG_DIS2>:
MBC2_RAM_FLG_DIS2:
  sbi   _SFR_IO_ADDR(PORTA), PA7
    8b36:	17 9a       	sbi	0x02, 7	; 2
  rjmp  MBC2_CLK
    8b38:	df c9       	rjmp	.-3138   	; 0x7ef8 <MBC2_CLK>

00008b3a <MBC2_ROM_BANKING2>:

MBC2_ROM_BANKING2:
  andi  r22, 0xF0;REG_MA14_18, MA19_21_MASK ; Mask only hi bits to ditch the old low bits
    8b3a:	60 7f       	andi	r22, 0xF0	; 240
;  nop; Need a NOP here for DATA to be valid... without this, this is 13-16 cycles in, so it should be safe...
  in    r17, _SFR_IO_ADDR(DATA_PIN);GB_DAT_REG, GB_DAT_R ;Read in DATA_PIN data for use in each write mode
    8b3c:	16 b1       	in	r17, 0x06	; 6
  andi  r17, 0x0F ; Mask D0-3.
    8b3e:	1f 70       	andi	r17, 0x0F	; 15
  tst   r17
    8b40:	11 23       	and	r17, r17
  brne  MBC2_NZERO2
    8b42:	09 f4       	brne	.+2      	; 0x8b46 <MBC2_NZERO2>
  inc   r17
    8b44:	13 95       	inc	r17

00008b46 <MBC2_NZERO2>:
MBC2_NZERO2:
  or    r22, r17;REG_MA14_18, GB_DAT_REG
    8b46:	61 2b       	or	r22, r17
;  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the MA mask value. Probably don't need to OUT this here for a WRITE command
  rjmp  MBC2_CLK;
    8b48:	d7 c9       	rjmp	.-3154   	; 0x7ef8 <MBC2_CLK>

Disassembly of section .MBC2_1101:

00008ba0 <.MBC2_1101>:

.section .MBC2_1101,"ax",@progbits ;0x45D0 Reserved. Do nothing
  rjmp  MBC2_CLK;
    8ba0:	ab c9       	rjmp	.-3242   	; 0x7ef8 <MBC2_CLK>

Disassembly of section .MBC3_RTC_0000:

00008c00 <MBC3_RTC_0000>:
; ************* MBC3 RTC MODE JUMP TABLE *******************************************
; **********************************************************************************
; ************************* READ JUMP TABLE (Read is low)
.section .MBC3_RTC_0000,"ax",@progbits ;0x4600 ROM bank 0
MBC3_RTC_0000:
  out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
    8c00:	15 b8       	out	0x05, r1	; 5

  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8c02:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8c04:	69 c9       	rjmp	.-3374   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8c06:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8c08:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    8c0a:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_RTC_0000_OUT              ; branch if not
    8c0c:	10 f0       	brcs	.+4      	; 0x8c12 <MBC3_RTC_0000_OUT>
  inc   r19                        ; increment minutes
    8c0e:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8c10:	22 27       	eor	r18, r18

00008c12 <MBC3_RTC_0000_OUT>:
MBC3_RTC_0000_OUT:
  rjmp  MBC3_CLK;
    8c12:	62 c9       	rjmp	.-3388   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_RTC_0010:

00008c40 <MBC3_RTC_0010>:

.section .MBC3_RTC_0010,"ax",@progbits ;0x4620 ROM bank 0
MBC3_RTC_0010:
  out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
    8c40:	15 b8       	out	0x05, r1	; 5

  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8c42:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8c44:	49 c9       	rjmp	.-3438   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8c46:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8c48:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    8c4a:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_RTC_0010_OUT              ; branch if not
    8c4c:	10 f0       	brcs	.+4      	; 0x8c52 <MBC3_RTC_0010_OUT>
  inc   r19                        ; increment minutes
    8c4e:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8c50:	22 27       	eor	r18, r18

00008c52 <MBC3_RTC_0010_OUT>:
MBC3_RTC_0010_OUT:
  rjmp  MBC3_CLK;
    8c52:	42 c9       	rjmp	.-3452   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_RTC_0100:

00008c80 <MBC3_RTC_0100>:

.section .MBC3_RTC_0100,"ax",@progbits ;0x4640 ROM bank XX
MBC3_RTC_0100:
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    8c80:	65 b9       	out	0x05, r22	; 5

  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8c82:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8c84:	29 c9       	rjmp	.-3502   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8c86:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8c88:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    8c8a:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_RTC_0100_OUT              ; branch if not
    8c8c:	10 f0       	brcs	.+4      	; 0x8c92 <MBC3_RTC_0100_OUT>
  inc   r19                        ; increment minutes
    8c8e:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8c90:	22 27       	eor	r18, r18

00008c92 <MBC3_RTC_0100_OUT>:
MBC3_RTC_0100_OUT:
  rjmp  MBC3_CLK;
    8c92:	22 c9       	rjmp	.-3516   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_RTC_0110:

00008cc0 <MBC3_RTC_0110>:

.section .MBC3_RTC_0110,"ax",@progbits ;0x4660 ROM bank XX
MBC3_RTC_0110:
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    8cc0:	65 b9       	out	0x05, r22	; 5
  
  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8cc2:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8cc4:	09 c9       	rjmp	.-3566   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8cc6:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8cc8:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    8cca:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_RTC_0110_OUT              ; branch if not
    8ccc:	10 f0       	brcs	.+4      	; 0x8cd2 <MBC3_RTC_0110_OUT>
  inc   r19                        ; increment minutes
    8cce:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8cd0:	22 27       	eor	r18, r18

00008cd2 <MBC3_RTC_0110_OUT>:
MBC3_RTC_0110_OUT:
  rjmp  MBC3_CLK;
    8cd2:	02 c9       	rjmp	.-3580   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_RTC_1000:

00008d00 <MBC3_RTC_RTC_END-0x1a>:

.section .MBC3_RTC_1000,"ax",@progbits ;0x4680 Reserved. Do nothing
/*sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip is set
rjmp  MBC3_0000 ; ROM bank 0*/ ;This mode is reserved. It shouldn't care if we change things
out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
    8d00:	15 b8       	out	0x05, r1	; 5

  ; Probably have about 12-13 cycles to do RTC updates where out is the only instruction, 9-10 where RJMPS occur (by my raw count :S)
  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8d02:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8d04:	e9 c8       	rjmp	.-3630   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8d06:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8d08:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    8d0a:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_RTC_RTC_END              ; branch if not
    8d0c:	30 f0       	brcs	.+12     	; 0x8d1a <MBC3_RTC_RTC_END>
  inc   r19                        ; increment minutes
    8d0e:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8d10:	22 27       	eor	r18, r18
  cpi   r19, 60                    ; is minutes = 60
    8d12:	3c 33       	cpi	r19, 0x3C	; 60
  brlo  MBC3_RTC_RTC_END              ; branch if not
    8d14:	10 f0       	brcs	.+4      	; 0x8d1a <MBC3_RTC_RTC_END>
  inc   r20                       ; increment hours
    8d16:	43 95       	inc	r20
  clr   r19                        ; clear minutes ; bah, this is 12 cycles here, and I haven't done a day check yet... I'll have to break it up unfortunately
    8d18:	33 27       	eor	r19, r19

00008d1a <MBC3_RTC_RTC_END>:
MBC3_RTC_RTC_END:
  rjmp  MBC3_CLK;
    8d1a:	de c8       	rjmp	.-3652   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_RTC_1010:

00008d40 <MBC3_RTC_RTC_STUFF-0x4>:
.section .MBC3_RTC_1010,"ax",@progbits ;0x46A0 RAM/RTC read
;sbic  _SFR_IO_ADDR(PIND), 7; Check A15, skip is cleared - by combining these sections, I save 2 cycles for read
;rjmp  MBC3_RTC_STUFF ; ROM bank 0 ; This might cause us problems. Any chance we can swap it with RAM/RTC read?
;out   _SFR_IO_ADDR(MA_PORT), r1; Set MA_PORT to 0x00
;rjmp  MBC3_CLK;
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip if set - by combining these sections, I save 1 cycle for read
    8d40:	4f 9b       	sbis	0x09, 7	; 9
rjmp  MBC3_0010
    8d42:	7e cc       	rjmp	.-1796   	; 0x8640 <MBC3_0010>

00008d44 <MBC3_RTC_RTC_STUFF>:
MBC3_RTC_RTC_STUFF:
  ; RAM is enabled in hardware. Only RTC code needs be here
  ; 10th (13th) cycle is next line?
; This loop may be too slow for a read cycle. Not sure if I can do this
; DATA_DDR output would be hard though. How do I make them an input again without stuffing the timing?
  out   _SFR_IO_ADDR(DATA_PORT), r7 ; r7 will be the temporary register to store RTC values to be pushed out 
    8d44:	78 b8       	out	0x08, r7	; 8
  out   _SFR_IO_ADDR(DATA_DDR), r2 ;-> pre-load r2 with 0xFF to make all outputs
    8d46:	27 b8       	out	0x07, r2	; 7
	...
  nop ; Eh, trying to add some nops here and hoping the GB reads at the right time!
  nop
  nop
  nop
;  nop ; might fit an extra one in. See if the RTC fails first,I think it would fail because I set the output too late first though
  out   _SFR_IO_ADDR(DATA_DDR), r1 ; Revert or leave DATA_PIN as inputs
    8d50:	17 b8       	out	0x07, r1	; 7
  out   _SFR_IO_ADDR(DATA_PORT), r1; Make 0 again, disable all pullups
    8d52:	18 b8       	out	0x08, r1	; 8
  rjmp  MBC3_CLK;
    8d54:	c1 c8       	rjmp	.-3710   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_RTC_1100:

00008d80 <MBC3_RTC_RTC_END2-0x1a>:

.section .MBC3_RTC_1100,"ax",@progbits ;0x46C0 Reserved. Do nothing
/*sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip is set
rjmp  MBC3_0100 ; ROM bank XX*/ ;This mode is reserved. It shouldn't care if we change things
out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    8d80:	65 b9       	out	0x05, r22	; 5

; Probably have about 12-13 cycles to do RTC updates where out is the only instruction, 9-10 where RJMPS occur (by my raw count :S)
  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8d82:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8d84:	a9 c8       	rjmp	.-3758   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8d86:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8d88:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    8d8a:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_RTC_RTC_END2             ; branch if not
    8d8c:	30 f0       	brcs	.+12     	; 0x8d9a <MBC3_RTC_RTC_END2>
  inc   r19                        ; increment minutes
    8d8e:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8d90:	22 27       	eor	r18, r18
  cpi   r19, 60                    ; is minutes = 60
    8d92:	3c 33       	cpi	r19, 0x3C	; 60
  brlo  MBC3_RTC_RTC_END2             ; branch if not
    8d94:	10 f0       	brcs	.+4      	; 0x8d9a <MBC3_RTC_RTC_END2>
  inc   r20                       ; increment hours
    8d96:	43 95       	inc	r20
  clr   r19                        ; clear minutes ; bah, this is 12 cycles here, and I haven't done a day check yet... I'll have to break it up unfortunately
    8d98:	33 27       	eor	r19, r19

00008d9a <MBC3_RTC_RTC_END2>:
MBC3_RTC_RTC_END2:
  rjmp  MBC3_CLK;
    8d9a:	9e c8       	rjmp	.-3780   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_RTC_1110:

00008dc0 <MBC3_RTC_RTC_END3-0x1a>:

.section .MBC3_RTC_1110,"ax",@progbits ;0x46E0 Reserved. Do nothing
/*sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip is set
rjmp  MBC3_0110 ; ROM bank XX*/ ;This mode is reserved. It shouldn't care if we change things
out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the stored MA14_18_21 value (r22)
    8dc0:	65 b9       	out	0x05, r22	; 5

; Probably have about 12-13 cycles to do RTC updates where out is the only instruction, 9-10 where RJMPS occur (by my raw count :S)
  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8dc2:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8dc4:	89 c8       	rjmp	.-3822   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8dc6:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8dc8:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    8dca:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_RTC_RTC_END3              ; branch if not
    8dcc:	30 f0       	brcs	.+12     	; 0x8dda <MBC3_RTC_RTC_END3>
  inc   r19                        ; increment minutes
    8dce:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8dd0:	22 27       	eor	r18, r18
  cpi   r19, 60                    ; is minutes = 60
    8dd2:	3c 33       	cpi	r19, 0x3C	; 60
  brlo  MBC3_RTC_RTC_END3              ; branch if not
    8dd4:	10 f0       	brcs	.+4      	; 0x8dda <MBC3_RTC_RTC_END3>
  inc   r20                       ; increment hours
    8dd6:	43 95       	inc	r20
  clr   r19                        ; clear minutes ; bah, this is 12 cycles here, and I haven't done a day check yet... I'll have to break it up unfortunately
    8dd8:	33 27       	eor	r19, r19

00008dda <MBC3_RTC_RTC_END3>:
MBC3_RTC_RTC_END3:
  rjmp  MBC3_CLK;
    8dda:	7e c8       	rjmp	.-3844   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_RTC_0001:

00008c20 <MBC3_RTC_0001>:
MBC3_RTC_0001:
; Replacing 3 nops here with a hairbrained work around to load r7 with correct RTC value. Force Y to be enabled because code will fix it anyway!
;nop
;  nop
;  nop
  sbr   YL, 7; pretends RAM is enabled, even if it's not because it'll be fixed below!
    8c20:	c7 60       	ori	r28, 0x07	; 7
  ld    r7, Y
    8c22:	78 80       	ld	r7, Y

  in    r17, _SFR_IO_ADDR(DATA_PIN) ; No need to mask in MBC3 mode as it has D0-7 inputs
    8c24:	16 b1       	in	r17, 0x06	; 6
  cpi   r17, 0x0A; 0x0A is an enable command
    8c26:	1a 30       	cpi	r17, 0x0A	; 10
  brne  MBC3_RTC_RAM_FLG_DIS
    8c28:	09 f4       	brne	.+2      	; 0x8c2c <MBC3_RTC_RAM_FLG_DIS>
;  sbr   YL, 7; Enable RAM/RTC
;  cbi   _SFR_IO_ADDR(PORTA), PA7;
  rjmp  MBC3_CLK
    8c2a:	56 c9       	rjmp	.-3412   	; 0x7ed8 <MBC3_CLK>

00008c2c <MBC3_RTC_RAM_FLG_DIS>:
MBC3_RTC_RAM_FLG_DIS:
  cbr   YL, 7; Disable RTC
    8c2c:	c8 7f       	andi	r28, 0xF8	; 248
;  sbi   _SFR_IO_ADDR(PORTA), PA7; Disable RAM
  rjmp  MBC3_CLK;
    8c2e:	54 c9       	rjmp	.-3416   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_RTC_0011:

00008c60 <MBC3_RTC_0011>:

.section .MBC3_RTC_0011,"ax",@progbits ;0x4630 ROM bank numbers
MBC3_RTC_0011:
  nop;
    8c60:	00 00       	nop
  nop; Need a NOP here for DATA to be valid... without this, this is 13-16 cycles in, so it should be safe...
    8c62:	00 00       	nop
nop
    8c64:	00 00       	nop
  in    r22, _SFR_IO_ADDR(DATA_PIN); We can read r22 directly in MBC3 mode because there are no other hi ROM bits to worry about
    8c66:	66 b1       	in	r22, 0x06	; 6
  andi  r22, 0x7F ; Mask D0-6. I don't want to add this, but I haven't tested if MBC data is corrupted otherwise
    8c68:	6f 77       	andi	r22, 0x7F	; 127
  tst   r22
    8c6a:	66 23       	and	r22, r22
  brne  MBC3_RTC_NZERO
    8c6c:	09 f4       	brne	.+2      	; 0x8c70 <MBC3_RTC_NZERO>
  inc   r22; MBC3 still doesn't put bank 0 at location 1.
    8c6e:	63 95       	inc	r22

00008c70 <MBC3_RTC_NZERO>:
MBC3_RTC_NZERO:
  out   _SFR_IO_ADDR(MA_PORT), MA14_18_21_REGISTER; Set MA_PORT to the MA mask value. Probably don't need to OUT this here for a WRITE command
    8c70:	65 b9       	out	0x05, r22	; 5
  rjmp  MBC3_CLK;
    8c72:	32 c9       	rjmp	.-3484   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_RTC_0101:

00008ca0 <MBC3_RTC_0101>:

.section .MBC3_RTC_0101,"ax",@progbits ;0x4650 RAM/RTC bank number
MBC3_RTC_0101:
  in    r24, _SFR_IO_ADDR(PORTA) ;Prep for changing the RAM bank number
    8ca0:	82 b1       	in	r24, 0x02	; 2
  andi  r24, 0xFC ; CLR the old bits on the PORT 
    8ca2:	8c 7f       	andi	r24, 0xFC	; 252

  andi  YL, 0x80; Clear the old register value, except for RTC enable/disable
    8ca4:	c0 78       	andi	r28, 0x80	; 128
  in    r17, _SFR_IO_ADDR(DATA_PIN);Read in DATA_PIN data
    8ca6:	16 b1       	in	r17, 0x06	; 6
  or    YL, r17; Save the bank number for later - Need this to stop READ and WRITE commands from reading RTC values when physical RAM is mapped
    8ca8:	c1 2b       	or	r28, r17
  
  cpi   r17, 0x04 ; Valid physical RAM banks are 0-3. Anything higher disables physical RAM
    8caa:	14 30       	cpi	r17, 0x04	; 4
  brsh  MBC3_RTC_RTC_REGS; Branch if same or higher
    8cac:	30 f4       	brcc	.+12     	; 0x8cba <MBC3_RTC_RTC_REGS>
  ; It's a physical bank here 
  or    r24, r17 ; Put the new value into PORTA temp value
    8cae:	81 2b       	or	r24, r17
  out   _SFR_IO_ADDR(PORTA), r24 ; Push PORTA back out
    8cb0:	82 b9       	out	0x02, r24	; 2
  sbrc  YL, 7; If bit 7 in r28 is cleared, then RAM isn't enabled. Don't enable RAM!
    8cb2:	c7 fd       	sbrc	r28, 7
  cbi   _SFR_IO_ADDR(PORTA), PA7;
    8cb4:	17 98       	cbi	0x02, 7	; 2
  ldi   ZH, r31_MBC3 ; - RAM enabled instead of RTC
    8cb6:	f3 e4       	ldi	r31, 0x43	; 67
  rjmp  MBC3_CLK;
    8cb8:	0f c9       	rjmp	.-3554   	; 0x7ed8 <MBC3_CLK>

00008cba <MBC3_RTC_RTC_REGS>:
MBC3_RTC_RTC_REGS:
  ld    r7, Y ; Load r7 with the RTC value pointed to by the Y register. WARNING! THIS CODE READS INCORRECT LCOATION IF RAM IS DISABLED AS r28 BIT 7 = 0!
    8cba:	78 80       	ld	r7, Y
  rjmp  MBC3_CLK;
    8cbc:	0d c9       	rjmp	.-3558   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_RTC_0111:

00008ce0 <MBC3_RTC_0111>:

.section .MBC3_RTC_0111,"ax",@progbits ;0x4670 Latch RTC data
MBC3_RTC_0111:
  ; To latch data, send it to RAM! (this simplifies retrieval later on). This isn't quite in the MBC3 spec, but it's easier than write sequences
  sts   0x188, r18
    8ce0:	20 93 88 01 	sts	0x0188, r18
  sts   0x189, r19
    8ce4:	30 93 89 01 	sts	0x0189, r19
  sts   0x18A, r20
    8ce8:	40 93 8a 01 	sts	0x018A, r20
  sts   0x18B, r21
    8cec:	50 93 8b 01 	sts	0x018B, r21
  sts   0x18C, r23
    8cf0:	70 93 8c 01 	sts	0x018C, r23
  rjmp  MBC3_CLK;
    8cf4:	f1 c8       	rjmp	.-3614   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_RTC_1001:

00008d20 <MBC3_RTC_RTC_END4-0x18>:

.section .MBC3_RTC_1001,"ax",@progbits ;0x4690 Reserved. Do nothing
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip if set
    8d20:	4f 9b       	sbis	0x09, 7	; 9
rjmp  MBC3_RTC_0001 ; Jump to RAM/RTC enable
    8d22:	7e cf       	rjmp	.-260    	; 0x8c20 <MBC3_RTC_0001>

  ; Do day counting here
  cpi   r20, 24                   ; is hours = 24
    8d24:	48 31       	cpi	r20, 0x18	; 24
  brlo  MBC3_RTC_RTC_END4             ; branch if not
    8d26:	40 f0       	brcs	.+16     	; 0x8d38 <MBC3_RTC_RTC_END4>
  clr   r20                       ; clear hours
    8d28:	44 27       	eor	r20, r20
  inc   r21                       ; increment days - swapped the order here because I want to do an overflow check to increment 
    8d2a:	53 95       	inc	r21
  tst   r21                       ; Is r11 now 0? If so, it's an overflow (or someone stopped the counter beautifully...)
    8d2c:	55 23       	and	r21, r21
  brne  MBC3_RTC_RTC_END4             ; branch if not
    8d2e:	21 f4       	brne	.+8      	; 0x8d38 <MBC3_RTC_RTC_END4>
  sbrc  r23, 0                    ; Check if hi bit of day counter is already set
    8d30:	70 fd       	sbrc	r23, 0
  sbr   r23, 7                    ; Set the overflow bit
    8d32:	77 60       	ori	r23, 0x07	; 7
  inc   r23                       ; inc r12, because 1+1 = 2! (which we can then mask out - nothing uses bit 1 of this register I believe)
    8d34:	73 95       	inc	r23
  andi  r23, 0xC1                 ; keep bit 0, 6 and 7. Clear all others
    8d36:	71 7c       	andi	r23, 0xC1	; 193

00008d38 <MBC3_RTC_RTC_END4>:
MBC3_RTC_RTC_END4:
  rjmp  MBC3_CLK;
    8d38:	cf c8       	rjmp	.-3682   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_RTC_1011:

00008d60 <MBC3_RTC_RTC_SRG-0x12>:

.section .MBC3_RTC_1011,"ax",@progbits ;0x46B0 RAM/RTC write
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip is set
    8d60:	4f 9b       	sbis	0x09, 7	; 9
rjmp  MBC3_RTC_0011 ; Jump to ROM bank numbers
    8d62:	7e cf       	rjmp	.-260    	; 0x8c60 <MBC3_RTC_0011>

  ;  cpi   YL, 0x88; If r28 is >=0x88, RTC is enabled and bank 8-C are selected. Do an RTC write
  cpi   YL, 0x8C; NOTE: I'm running too low on cycles to update seconds and minutes, so I'm only doing hours and days. Who cares about hours anyway?
    8d64:	cc 38       	cpi	r28, 0x8C	; 140
  breq  MBC3_RTC_RTC_SRG
    8d66:	29 f0       	breq	.+10     	; 0x8d72 <MBC3_RTC_RTC_SRG>
  cpi   YL, 0x8B; NOTE: I'm running too low on cycles to update seconds and minutes, so I'm only doing hours and days. Who cares about hours anyway?
    8d68:	cb 38       	cpi	r28, 0x8B	; 139
  breq  MBC3_RTC_RTC_DAY
    8d6a:	31 f0       	breq	.+12     	; 0x8d78 <MBC3_RTC_RTC_DAY>
  cpi   YL, 0x8A; NOTE: I'm running too low on cycles to update seconds and minutes, so I'm only doing hours and days. Who cares about hours anyway?
    8d6c:	ca 38       	cpi	r28, 0x8A	; 138
  breq  MBC3_RTC_RTC_HRS
    8d6e:	31 f0       	breq	.+12     	; 0x8d7c <MBC3_RTC_RTC_HRS>
  rjmp  MBC3_CLK;
    8d70:	b3 c8       	rjmp	.-3738   	; 0x7ed8 <MBC3_CLK>

00008d72 <MBC3_RTC_RTC_SRG>:

MBC3_RTC_RTC_SRG: 
  nop;
    8d72:	00 00       	nop
  in    r23, _SFR_IO_ADDR(DATA_PIN);Read in DATA_PIN data
    8d74:	76 b1       	in	r23, 0x06	; 6
  rjmp  MBC3_CLK
    8d76:	b0 c8       	rjmp	.-3744   	; 0x7ed8 <MBC3_CLK>

00008d78 <MBC3_RTC_RTC_DAY>:
MBC3_RTC_RTC_DAY:
  in    r21, _SFR_IO_ADDR(DATA_PIN);Read in DATA_PIN data
    8d78:	56 b1       	in	r21, 0x06	; 6
  rjmp  MBC3_CLK
    8d7a:	ae c8       	rjmp	.-3748   	; 0x7ed8 <MBC3_CLK>

00008d7c <MBC3_RTC_RTC_HRS>:
MBC3_RTC_RTC_HRS:
  in    r20, _SFR_IO_ADDR(DATA_PIN);Read in DATA_PIN data
    8d7c:	46 b1       	in	r20, 0x06	; 6
  rjmp  MBC3_CLK
    8d7e:	ac c8       	rjmp	.-3752   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_RTC_1101:

00008da0 <.MBC3_RTC_1101>:

.section .MBC3_RTC_1101,"ax",@progbits ;0x46D0 Reserved. Do nothing
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip if set ; -> I'd love to take this out and make it SBIC, but I need the instructions...
    8da0:	4f 9b       	sbis	0x09, 7	; 9
rjmp  MBC3_RTC_0101 ; Jump to RAM/RTC bank number. Or do it here and make the above SBIC
    8da2:	7e cf       	rjmp	.-260    	; 0x8ca0 <MBC3_RTC_0101>

  rjmp  MBC3_CLK;
    8da4:	99 c8       	rjmp	.-3790   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_RTC_1111:

00008de0 <MBC3_RTC_RTC_END5-0x18>:

.section .MBC3_RTC_1111,"ax",@progbits ;0x46F0 Reserved. Do nothing
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip is set
    8de0:	4f 9b       	sbis	0x09, 7	; 9
rjmp  MBC3_RTC_0111 ; Jump to Latch RTC. Or do it here and make the above SBIC
    8de2:	7e cf       	rjmp	.-260    	; 0x8ce0 <MBC3_RTC_0111>

  ; Do day counting here
  cpi   r20, 24                   ; is hours = 24
    8de4:	48 31       	cpi	r20, 0x18	; 24
  brlo  MBC3_RTC_RTC_END5             ; branch if not
    8de6:	40 f0       	brcs	.+16     	; 0x8df8 <MBC3_RTC_RTC_END5>
  clr   r20                       ; clear hours
    8de8:	44 27       	eor	r20, r20
  inc   r21                       ; increment days - swapped the order here because I want to do an overflow check to increment 
    8dea:	53 95       	inc	r21
  tst   r21                       ; Is r11 now 0? If so, it's an overflow (or someone stopped the counter beautifully...)
    8dec:	55 23       	and	r21, r21
  brne  MBC3_RTC_RTC_END5             ; branch if not
    8dee:	21 f4       	brne	.+8      	; 0x8df8 <MBC3_RTC_RTC_END5>
  sbrc  r23, 0                    ; Check if hi bit of day counter is already set
    8df0:	70 fd       	sbrc	r23, 0
  sbr   r23, 7                    ; Set the overflow bit
    8df2:	77 60       	ori	r23, 0x07	; 7
  inc   r23                       ; inc r12, because 1+1 = 2! (which we can then mask out - nothing uses bit 1 of this register I believe)
    8df4:	73 95       	inc	r23
  andi  r23, 0xC1                 ; keep bit 0, 6 and 7. Clear all others
    8df6:	71 7c       	andi	r23, 0xC1	; 193

00008df8 <MBC3_RTC_RTC_END5>:
MBC3_RTC_RTC_END5:
  rjmp  MBC3_CLK;
    8df8:	6f c8       	rjmp	.-3874   	; 0x7ed8 <MBC3_CLK>
