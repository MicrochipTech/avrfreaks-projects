
M644_512KB_FLASH_PROTO.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000036  00800100  000043f0  00004f64  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000043f0  00000000  00000000  00000b74  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .MBC1_16M_0000 00000004  00008000  00008000  0000509e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .MBC1_16M_0010 00000004  00008040  00008040  000050b6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .MBC1_16M_0100 00000004  00008080  00008080  000050ce  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .MBC1_16M_0110 00000004  000080c0  000080c0  000050e2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .MBC1_16M_1000 00000002  00008100  00008100  000050f4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .MBC1_16M_1010 00000002  00008140  00008140  000050f8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .MBC1_16M_1100 00000002  00008180  00008180  000050fc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .MBC1_16M_1110 00000002  000081c0  000081c0  00005100  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .MBC1_16M_0001 00000014  00008020  00008020  000050a2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .MBC1_16M_0011 00000014  00008060  00008060  000050ba  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .MBC1_16M_0101 00000010  000080a0  000080a0  000050d2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .MBC1_16M_0111 0000000e  000080e0  000080e0  000050e6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .MBC1_16M_1001 00000002  00008120  00008120  000050f6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .MBC1_16M_1011 00000002  00008160  00008160  000050fa  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .MBC1_16M_1101 00000002  000081a0  000081a0  000050fe  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .MBC1_16M_1111 00000002  000081e0  000081e0  00005102  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .MBC1_4M_0000 00000004  00008200  00008200  00005104  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .MBC1_4M_0010 00000004  00008240  00008240  0000511c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .MBC1_4M_0100 00000004  00008280  00008280  00005134  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .MBC1_4M_0110 00000004  000082c0  000082c0  00005146  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .MBC1_4M_1000 00000002  00008300  00008300  00005156  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .MBC1_4M_1010 00000002  00008340  00008340  0000515a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .MBC1_4M_1100 00000002  00008380  00008380  0000515e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .MBC1_4M_1110 00000002  000083c0  000083c0  00005162  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .MBC1_4M_0001 00000014  00008220  00008220  00005108  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .MBC1_4M_0011 00000014  00008260  00008260  00005120  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .MBC1_4M_0101 0000000e  000082a0  000082a0  00005138  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .MBC1_4M_0111 0000000c  000082e0  000082e0  0000514a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .MBC1_4M_1001 00000002  00008320  00008320  00005158  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .MBC1_4M_1011 00000002  00008360  00008360  0000515c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .MBC1_4M_1101 00000002  000083a0  000083a0  00005160  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .MBC1_4M_1111 00000002  000083e0  000083e0  00005164  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .MBC5_0000    00000008  00008400  00008400  00005166  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .MBC5_0010    00000008  00008440  00008440  00005180  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .MBC5_0100    00000008  00008480  00008480  00005192  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .MBC5_0110    00000008  000084c0  000084c0  000051a8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .MBC5_1000    00000008  00008500  00008500  000051b2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 39 .MBC5_1010    00000008  00008540  00008540  000051c0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 40 .MBC5_1100    00000008  00008580  00008580  000051ce  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .MBC5_1110    00000008  000085c0  000085c0  000051dc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .MBC5_0001    00000012  00008420  00008420  0000516e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .MBC5_0011    0000000a  00008460  00008460  00005188  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .MBC5_0101    0000000e  000084a0  000084a0  0000519a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 45 .MBC5_0111    00000002  000084e0  000084e0  000051b0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 46 .MBC5_1001    00000006  00008520  00008520  000051ba  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 47 .MBC5_1011    00000006  00008560  00008560  000051c8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 48 .MBC5_1101    00000006  000085a0  000085a0  000051d6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .MBC5_1111    00000002  000085e0  000085e0  000051e4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .MBC_BASE     00000104  00007e00  00007e00  00004f9a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 51 .MBC3_0000    00000014  00008600  00008600  000051e6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .MBC3_0010    00000014  00008640  00008640  0000520e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .MBC3_0100    00000014  00008680  00008680  00005236  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .MBC3_0110    00000014  000086c0  000086c0  0000526a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 55 .MBC3_1000    0000001c  00008700  00008700  00005294  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 56 .MBC3_1010    0000001a  00008740  00008740  000052ca  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 57 .MBC3_1100    0000001c  00008780  00008780  00005304  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 58 .MBC3_1110    0000001c  000087c0  000087c0  00005326  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 59 .MBC3_0001    00000014  00008620  00008620  000051fa  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 60 .MBC3_0011    00000014  00008660  00008660  00005222  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 61 .MBC3_0101    00000020  000086a0  000086a0  0000524a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 62 .MBC3_0111    00000016  000086e0  000086e0  0000527e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 63 .MBC3_1001    0000001a  00008720  00008720  000052b0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 64 .MBC3_1011    00000020  00008760  00008760  000052e4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 65 .MBC3_1101    00000006  000087a0  000087a0  00005320  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 66 .MBC3_1111    0000001a  000087e0  000087e0  00005342  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 67 .MBC5_DSM_0000 00000006  00008800  00008800  0000535c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 68 .MBC5_DSM_0010 00000006  00008840  00008840  0000536a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 69 .MBC5_DSM_0100 00000006  00008880  00008880  00005376  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 70 .MBC5_DSM_0110 00000006  000088c0  000088c0  00005384  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 71 .MBC5_DSM_1000 00000006  00008900  00008900  00005390  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 72 .MBC5_DSM_1010 0000000a  00008940  00008940  0000539c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 73 .MBC5_DSM_1100 00000006  00008980  00008980  000053b0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 74 .MBC5_DSM_1110 00000006  000089c0  000089c0  000053bc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 75 .MBC5_DSM_0001 00000008  00008820  00008820  00005362  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 76 .MBC5_DSM_0011 00000006  00008860  00008860  00005370  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 77 .MBC5_DSM_0101 00000008  000088a0  000088a0  0000537c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 78 .MBC5_DSM_0111 00000006  000088e0  000088e0  0000538a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 79 .MBC5_DSM_1001 00000006  00008920  00008920  00005396  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 80 .MBC5_DSM_1011 0000000a  00008960  00008960  000053a6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 81 .MBC5_DSM_1101 00000006  000089a0  000089a0  000053b6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 82 .MBC5_DSM_1111 00000006  000089e0  000089e0  000053c2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 83 .MBC2_0000    00000004  00008a00  00008a00  000053c8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 84 .MBC2_0100    00000004  00008a80  00008a80  000053f2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 85 .MBC2_1000    00000004  00008b00  00008b00  000053f8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 86 .MBC2_1100    00000004  00008b80  00008b80  00005426  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 87 .MBC2_0001    00000026  00008a20  00008a20  000053cc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 88 .MBC2_0101    00000002  00008aa0  00008aa0  000053f6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 89 .MBC2_1001    0000002a  00008b20  00008b20  000053fc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 90 .MBC2_1101    00000002  00008ba0  00008ba0  0000542a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 91 .bss          0000046a  00800136  00800136  0000542c  2**0
                  ALLOC
 92 .debug_aranges 000003c0  00000000  00000000  00005430  2**3
                  CONTENTS, READONLY, DEBUGGING
 93 .debug_pubnames 0000074f  00000000  00000000  000057f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 94 .debug_info   00004334  00000000  00000000  00005f3f  2**0
                  CONTENTS, READONLY, DEBUGGING
 95 .debug_abbrev 00000d78  00000000  00000000  0000a273  2**0
                  CONTENTS, READONLY, DEBUGGING
 96 .debug_line   0000542e  00000000  00000000  0000afeb  2**0
                  CONTENTS, READONLY, DEBUGGING
 97 .debug_frame  000004b0  00000000  00000000  0001041c  2**2
                  CONTENTS, READONLY, DEBUGGING
 98 .debug_str    00000985  00000000  00000000  000108cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 99 .debug_loc    0000199d  00000000  00000000  00011251  2**0
                  CONTENTS, READONLY, DEBUGGING
100 .debug_ranges 00000b70  00000000  00000000  00012bf0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 30 05 	jmp	0xa60	; 0xa60 <__ctors_end>
       4:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
       8:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
       c:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      10:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      14:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      18:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      1c:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      20:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      24:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      28:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      2c:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      30:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      34:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      38:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      3c:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      40:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      44:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      48:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      4c:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      50:	0c 94 50 08 	jmp	0x10a0	; 0x10a0 <__vector_20>
      54:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      58:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      5c:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      60:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      64:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      68:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>
      6c:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__bad_interrupt>

00000070 <__c.1513>:
      70:	4d 42 43 31 5f 31 36 4d 00                          MBC1_16M.

00000079 <__c.1511>:
      79:	4d 42 43 35 20 20 20 20 00                          MBC5    .

00000082 <__c.1509>:
      82:	4d 42 43 33 20 20 20 20 00                          MBC3    .

0000008b <__c.1507>:
      8b:	4d 42 43 32 20 20 20 20 00                          MBC2    .

00000094 <__c.1505>:
      94:	4d 42 43 31 5f 31 36 4d 00                          MBC1_16M.

0000009d <__c.1503>:
      9d:	57 41 52 4e 49 4e 47 3a 20 52 4f 4d 20 61 6e 64     WARNING: ROM and
      ad:	20 52 41 4d 20 73 69 7a 65 20 62 6f 74 68 20 65      RAM size both e
      bd:	78 63 65 65 64 20 4d 42 43 31 20 6d 6f 64 65 20     xceed MBC1 mode 
      cd:	73 69 7a 65 73 2e 20 41 73 73 75 6d 69 6e 67 20     sizes. Assuming 
      dd:	4d 42 43 33 20 6d 6f 64 65 0d 0a 00                 MBC3 mode...

000000e9 <__c.1501>:
      e9:	4d 42 43 33 20 20 20 20 00                          MBC3    .

000000f2 <__c.1499>:
      f2:	4d 42 43 31 5f 34 4d 20 00                          MBC1_4M .

000000fb <__c.1497>:
      fb:	0d 0a 49 6e 76 61 6c 69 64 20 45 45 50 52 4f 4d     ..Invalid EEPROM
     10b:	20 76 61 6c 75 65 73 20 64 65 74 65 63 74 65 64      values detected
     11b:	2e 20 57 72 69 74 69 6e 67 20 64 65 66 61 75 6c     . Writing defaul
     12b:	74 20 76 61 6c 75 65 73 0d 0a 00                    t values...

00000136 <commonReturn>:
     136:	50 72 65 73 73 20 53 50 41 43 45 42 41 52 20 74     Press SPACEBAR t
     146:	6f 20 72 65 74 75 72 6e 20 74 6f 20 74 68 65 20     o return to the 
     156:	6d 61 69 6e 20 6d 65 6e 75 0d 0a 00                 main menu...

00000162 <commonAbort>:
     162:	27 4e 27 20 72 65 63 65 69 76 65 64 2e 20 41 62     'N' received. Ab
     172:	6f 72 74 69 6e 67 2e 0d 0a 00                       orting....

0000017c <commonEmpty>:
     17c:	4e 6f 74 20 69 6d 70 6c 65 6d 65 6e 74 65 64 20     Not implemented 
     18c:	79 65 74 0d 0a 00                                   yet...

00000192 <__c.1799>:
     192:	42 79 65 21 0d 0a 00                                Bye!...

00000199 <__c.1797>:
     199:	43 6f 6e 66 69 72 6d 20 79 6f 75 20 77 69 73 68     Confirm you wish
     1a9:	20 74 6f 20 64 69 73 61 62 6c 65 20 63 6f 6d 6d      to disable comm
     1b9:	75 6e 69 63 61 74 69 6f 6e 20 61 6e 64 20 65 6e     unication and en
     1c9:	74 65 72 20 4d 42 43 20 6d 6f 64 65 20 28 59 2f     ter MBC mode (Y/
     1d9:	4e 29 0d 0a 00                                      N)...

000001de <__c.1790>:
     1de:	4d 42 43 20 6d 6f 64 65 20 69 73 20 6e 6f 77 3a     MBC mode is now:
     1ee:	20 00                                                .

000001f0 <__c.1788>:
     1f0:	43 61 6e 63 65 6c 20 73 65 6c 65 63 74 69 6f 6e     Cancel selection
     200:	2e 0d 0a 00                                         ....

00000204 <__c.1786>:
     204:	4d 42 43 35 20 20 20 20 00                          MBC5    .

0000020d <__c.1784>:
     20d:	4d 42 43 33 20 20 20 20 00                          MBC3    .

00000216 <__c.1782>:
     216:	4d 42 43 32 20 20 20 20 00                          MBC2    .

0000021f <__c.1780>:
     21f:	4d 42 43 31 5f 34 4d 20 00                          MBC1_4M .

00000228 <__c.1778>:
     228:	4d 42 43 31 5f 31 36 4d 00                          MBC1_16M.

00000231 <__c.1775>:
     231:	55 6e 6b 6e 6f 77 6e 20 73 65 6c 65 63 74 69 6f     Unknown selectio
     241:	6e 3a 00                                            n:.

00000244 <__c.1771>:
     244:	63 20 2d 20 43 61 6e 63 65 6c 20 73 65 6c 65 63     c - Cancel selec
     254:	74 69 6f 6e 0d 0a 00                                tion...

0000025b <__c.1769>:
     25b:	34 20 2d 20 4d 42 43 35 0d 0a 00                    4 - MBC5...

00000266 <__c.1767>:
     266:	33 20 2d 20 4d 42 43 33 0d 0a 00                    3 - MBC3...

00000271 <__c.1765>:
     271:	32 20 2d 20 4d 42 43 32 0d 0a 00                    2 - MBC2...

0000027c <__c.1763>:
     27c:	31 20 2d 20 4d 42 43 31 20 34 4d 62 0d 0a 00        1 - MBC1 4Mb...

0000028b <__c.1761>:
     28b:	30 20 2d 20 4d 42 43 31 20 31 36 4d 62 0d 0a 00     0 - MBC1 16Mb...

0000029b <__c.1759>:
     29b:	53 65 6c 65 63 74 20 6f 6e 65 20 6f 66 20 74 68     Select one of th
     2ab:	65 20 4d 42 43 20 6d 6f 64 65 73 20 62 65 6c 6f     e MBC modes belo
     2bb:	77 3a 0d 0a 00                                      w:...

000002c0 <__c.1738>:
     2c0:	33 3a 20 30 78 00                                   3: 0x.

000002c6 <__c.1736>:
     2c6:	32 3a 20 30 78 00                                   2: 0x.

000002cc <__c.1734>:
     2cc:	31 3a 20 30 78 00                                   1: 0x.

000002d2 <__c.1732>:
     2d2:	46 6c 61 73 68 20 63 68 69 70 20 49 44 20 28 65     Flash chip ID (e
     2e2:	78 70 65 63 74 69 6e 67 20 30 78 42 37 29 0d 0a     xpecting 0xB7)..
     2f2:	30 3a 20 30 78 00                                   0: 0x.

000002f8 <__c.1723>:
     2f8:	46 69 6c 65 20 73 65 6e 74 21 0d 0a 00              File sent!...

00000305 <__c.1721>:
     305:	53 65 6c 65 63 74 20 59 4d 4f 44 45 4d 20 72 65     Select YMODEM re
     315:	63 65 69 76 65 20 6f 6e 20 79 6f 75 72 20 74 65     ceive on your te
     325:	72 6d 69 6e 61 6c 20 74 6f 20 64 6f 77 6e 6c 6f     rminal to downlo
     335:	61 64 2e 20 41 56 52 20 77 69 6c 6c 20 62 65 20     ad. AVR will be 
     345:	77 61 69 74 69 6e 67 0d 0a 00                       waiting...

0000034f <__c.1719>:
     34f:	43 6f 6e 66 69 72 6d 20 79 6f 75 20 77 69 73 68     Confirm you wish
     35f:	20 74 6f 20 64 75 6d 70 20 74 68 65 20 63 75 72      to dump the cur
     36f:	72 65 6e 74 20 73 61 76 65 20 66 69 6c 65 20 28     rent save file (
     37f:	59 2f 4e 29 0d 0a 00                                Y/N)...

00000386 <__c.1705>:
     386:	4c 61 73 74 20 41 64 64 72 3a 20 00                 Last Addr: .

00000392 <__c.1703>:
     392:	46 69 72 73 74 20 41 64 64 72 3a 20 00              First Addr: .

0000039f <__c.1701>:
     39f:	52 41 4d 20 77 72 69 74 65 20 65 72 72 6f 72 73     RAM write errors
     3af:	3a 20 00                                            : .

000003b2 <__c.1699>:
     3b2:	0d 0a 46 69 6c 65 20 72 65 63 65 69 76 65 64 21     ..File received!
     3c2:	20 53 69 7a 65 3a 20 00                              Size: .

000003ca <__c.1693>:
     3ca:	31 30 20 73 65 63 6f 6e 64 20 64 65 6c 61 79 2e     10 second delay.
     3da:	20 51 75 69 63 6b 2c 20 73 65 6c 65 63 74 20 74      Quick, select t
     3ea:	68 65 20 66 69 6c 65 20 74 6f 20 64 6f 77 6e 6c     he file to downl
     3fa:	6f 61 64 20 76 69 61 20 59 4d 4f 44 45 4d 20 70     oad via YMODEM p
     40a:	72 6f 74 6f 63 6f 6c 0d 0a 00                       rotocol...

00000414 <__c.1691>:
     414:	43 6f 6e 66 69 72 6d 20 79 6f 75 20 77 69 73 68     Confirm you wish
     424:	20 74 6f 20 64 6f 77 6e 6c 6f 61 64 20 61 20 73      to download a s
     434:	61 76 65 20 66 69 6c 65 20 28 59 2f 4e 29 0d 0a     ave file (Y/N)..
	...

00000445 <__c.1683>:
     445:	46 69 6c 65 20 73 65 6e 74 21 0d 0a 00              File sent!...

00000452 <__c.1681>:
     452:	53 65 6c 65 63 74 20 59 4d 4f 44 45 4d 20 72 65     Select YMODEM re
     462:	63 65 69 76 65 20 6f 6e 20 79 6f 75 72 20 74 65     ceive on your te
     472:	72 6d 69 6e 61 6c 20 74 6f 20 64 6f 77 6e 6c 6f     rminal to downlo
     482:	61 64 2e 20 41 56 52 20 77 69 6c 6c 20 62 65 20     ad. AVR will be 
     492:	77 61 69 74 69 6e 67 0d 0a 00                       waiting...

0000049c <__c.1679>:
     49c:	43 6f 6e 66 69 72 6d 20 79 6f 75 20 77 69 73 68     Confirm you wish
     4ac:	20 74 6f 20 64 75 6d 70 20 74 68 65 20 63 75 72      to dump the cur
     4bc:	72 65 6e 74 20 52 4f 4d 20 28 59 2f 4e 29 0d 0a     rent ROM (Y/N)..
	...

000004cd <__c.1658>:
     4cd:	4d 42 43 31 5f 31 36 4d 00                          MBC1_16M.

000004d6 <__c.1656>:
     4d6:	4d 42 43 35 20 20 20 20 00                          MBC5    .

000004df <__c.1654>:
     4df:	4d 42 43 33 20 20 20 20 00                          MBC3    .

000004e8 <__c.1652>:
     4e8:	4d 42 43 32 20 20 20 20 00                          MBC2    .

000004f1 <__c.1650>:
     4f1:	4d 42 43 31 5f 31 36 4d 00                          MBC1_16M.

000004fa <__c.1648>:
     4fa:	57 41 52 4e 49 4e 47 3a 20 52 4f 4d 20 61 6e 64     WARNING: ROM and
     50a:	20 52 41 4d 20 73 69 7a 65 20 62 6f 74 68 20 65      RAM size both e
     51a:	78 63 65 65 64 20 4d 42 43 31 20 6d 6f 64 65 20     xceed MBC1 mode 
     52a:	73 69 7a 65 73 2e 20 41 73 73 75 6d 69 6e 67 20     sizes. Assuming 
     53a:	4d 42 43 33 20 6d 6f 64 65 0d 0a 00                 MBC3 mode...

00000546 <__c.1646>:
     546:	4d 42 43 33 20 20 20 20 00                          MBC3    .

0000054f <__c.1644>:
     54f:	4d 42 43 31 5f 34 4d 20 00                          MBC1_4M .

00000558 <__c.1642>:
     558:	0d 0a 4d 61 78 20 61 64 64 72 65 73 73 20 20 20     ..Max address   
     568:	20 20 20 20 20 3a 20 00                                  : .

00000570 <__c.1640>:
     570:	0d 0a 46 69 6c 65 20 72 65 63 65 69 76 65 64 21     ..File received!
     580:	20 53 69 7a 65 3a 20 00                              Size: .

00000588 <__c.1638>:
     588:	0d 0a 45 72 72 6f 72 3a 20 00                       ..Error: .

00000592 <__c.1627>:
     592:	31 30 20 73 65 63 6f 6e 64 20 64 65 6c 61 79 2e     10 second delay.
     5a2:	20 51 75 69 63 6b 2c 20 73 65 6c 65 63 74 20 74      Quick, select t
     5b2:	68 65 20 66 69 6c 65 20 74 6f 20 64 6f 77 6e 6c     he file to downl
     5c2:	6f 61 64 20 76 69 61 20 59 4d 4f 44 45 4d 20 70     oad via YMODEM p
     5d2:	72 6f 74 6f 63 6f 6c 0d 0a 00                       rotocol...

000005dc <__c.1625>:
     5dc:	45 72 61 73 69 6e 67 20 63 68 69 70 28 73 29 0d     Erasing chip(s).
     5ec:	0a 00                                               ..

000005ee <__c.1623>:
     5ee:	43 6f 6e 66 69 72 6d 20 79 6f 75 20 77 69 73 68     Confirm you wish
     5fe:	20 74 6f 20 65 72 61 73 65 20 61 6e 64 20 66 6c      to erase and fl
     60e:	61 73 68 20 61 20 6e 65 77 20 52 4f 4d 20 28 59     ash a new ROM (Y
     61e:	2f 4e 29 0d 0a 00                                   /N)...

00000624 <__c.1595>:
     624:	0d 0a 46 69 72 6d 77 61 72 65 20 72 65 76 2e 3a     ..Firmware rev.:
     634:	20 20 20 20 31 2e 30 20 32 36 20 4a 61 6e 20 31         1.0 26 Jan 1
     644:	39 0d 0a 0a 00                                      9....

00000649 <__c.1593>:
     649:	4d 42 43 20 6d 6f 64 65 3a 20 20 20 20 20 20 20     MBC mode:       
     659:	20 20 00                                              .

0000065c <__c.1591>:
     65c:	0d 0a 4d 42 43 20 6d 6f 64 65 20 6f 6e 20 62 6f     ..MBC mode on bo
     66c:	6f 74 20 28 46 72 6f 6d 20 45 45 50 52 4f 4d 29     ot (From EEPROM)
     67c:	0d 0a 00                                            ...

0000067f <__c.1589>:
     67f:	43 47 42 20 73 75 70 70 6f 72 74 3f 3a 20 20 20     CGB support?:   
     68f:	20 20 30 78 00                                        0x.

00000694 <__c.1587>:
     694:	4d 42 43 20 74 79 70 65 3a 20 20 20 20 20 20 20     MBC type:       
     6a4:	20 20 30 78 00                                        0x.

000006a9 <__c.1585>:
     6a9:	53 52 41 4d 20 73 69 7a 65 3a 20 20 20 20 20 20     SRAM size:      
     6b9:	20 20 30 78 00                                        0x.

000006be <__c.1583>:
     6be:	52 4f 4d 20 73 69 7a 65 3a 20 20 20 20 20 20 20     ROM size:       
     6ce:	20 20 30 78 00                                        0x.

000006d3 <__c.1581>:
     6d3:	52 4f 4d 20 6e 61 6d 65 3a 20 20 20 20 20 20 20     ROM name:       
     6e3:	20 20 00                                              .

000006e6 <__c.1579>:
     6e6:	47 61 6d 65 62 6f 79 20 52 4f 4d 20 69 6e 66 6f     Gameboy ROM info
     6f6:	20 28 66 72 6f 6d 20 66 6c 61 73 68 29 3a 0d 0a      (from flash):..
	...

00000707 <__c.1571>:
     707:	55 6e 6b 6e 6f 77 6e 20 72 65 71 75 65 73 74 0d     Unknown request.
     717:	0a 00                                               ..

00000719 <__c.1569>:
     719:	0d 0a 55 73 65 72 20 73 65 6c 65 63 74 69 6f 6e     ..User selection
     729:	3a 20 00                                            : .

0000072c <__c.1567>:
     72c:	0d 0a 44 69 73 63 6f 6e 6e 65 63 74 20 74 68 65     ..Disconnect the
     73c:	20 63 61 62 6c 65 20 62 65 66 6f 72 65 20 75 73      cable before us
     74c:	69 6e 67 20 74 68 65 20 63 61 72 74 20 69 6e 20     ing the cart in 
     75c:	61 20 47 61 6d 65 62 6f 79 21 0d 0a 00              a Gameboy!...

00000769 <__c.1565>:
     769:	38 20 2d 20 45 6e 74 65 72 20 47 61 6d 65 62 6f     8 - Enter Gamebo
     779:	79 20 6d 6f 64 65 20 2d 20 57 41 52 4e 49 4e 47     y mode - WARNING
     789:	21 20 44 49 53 43 4f 4e 4e 45 43 54 20 55 41 52     ! DISCONNECT UAR
     799:	54 21 0d 0a 00                                      T!...

0000079e <__c.1563>:
     79e:	37 20 2d 20 46 6c 61 73 68 20 6e 65 77 20 63 61     7 - Flash new ca
     7ae:	72 74 20 66 69 72 6d 77 61 72 65 20 28 6d 75 73     rt firmware (mus
     7be:	74 20 62 65 20 3c 35 36 4b 42 20 64 75 65 20 74     t be <56KB due t
     7ce:	6f 20 70 6c 61 63 65 6d 65 6e 74 20 6f 66 20 62     o placement of b
     7de:	6f 6f 74 6c 6f 61 64 65 72 29 0d 0a 00              ootloader)...

000007eb <__c.1561>:
     7eb:	36 20 2d 20 46 6f 72 63 65 20 4d 42 43 20 6d 6f     6 - Force MBC mo
     7fb:	64 65 20 28 66 6f 72 20 69 6e 63 6f 72 72 65 63     de (for incorrec
     80b:	74 20 63 61 72 74 72 69 64 67 65 20 68 65 61 64     t cartridge head
     81b:	65 72 20 6f 72 20 63 6f 6d 70 61 74 69 62 69 6c     er or compatibil
     82b:	69 74 79 20 74 65 73 74 73 29 0d 0a 00              ity tests)...

00000838 <__c.1559>:
     838:	35 20 2d 20 56 69 65 77 20 66 6c 61 73 68 20 49     5 - View flash I
     848:	43 20 64 65 74 65 63 74 69 6f 6e 0d 0a 00           C detection...

00000856 <__c.1557>:
     856:	34 20 2d 20 44 75 6d 70 20 73 61 76 65 20 66 69     4 - Dump save fi
     866:	6c 65 20 74 6f 20 50 43 0d 0a 00                    le to PC...

00000871 <__c.1555>:
     871:	33 20 2d 20 44 6f 77 6e 6c 6f 61 64 20 73 61 76     3 - Download sav
     881:	65 20 66 69 6c 65 20 74 6f 20 63 61 72 74 0d 0a     e file to cart..
	...

00000892 <__c.1553>:
     892:	32 20 2d 20 44 75 6d 70 20 52 4f 4d 20 74 6f 20     2 - Dump ROM to 
     8a2:	50 43 0d 0a 00                                      PC...

000008a7 <__c.1551>:
     8a7:	31 20 2d 20 44 6f 77 6e 6c 6f 61 64 20 6e 65 77     1 - Download new
     8b7:	20 52 4f 4d 20 74 6f 20 63 61 72 74 0d 0a 00         ROM to cart...

000008c6 <__c.1549>:
     8c6:	30 20 2d 20 53 68 6f 77 20 73 79 73 74 65 6d 20     0 - Show system 
     8d6:	61 6e 64 20 52 4f 4d 20 69 6e 66 6f 72 6d 61 74     and ROM informat
     8e6:	69 6f 6e 0d 0a 00                                   ion...

000008ec <__c.1547>:
     8ec:	57 65 6c 63 6f 6d 65 20 74 6f 20 42 6c 61 6b 65     Welcome to Blake
     8fc:	27 73 20 47 42 20 66 6c 61 73 68 20 63 61 72 74     's GB flash cart
     90c:	0d 0a 43 68 6f 6f 73 65 20 6f 6e 65 20 6f 66 20     ..Choose one of 
     91c:	74 68 65 20 66 6f 6c 6c 6f 77 69 6e 67 20 6f 70     the following op
     92c:	74 69 6f 6e 73 0d 0a 0d 0a 00                       tions.....

00000936 <__c.1413>:
     936:	55 4e 4b 20 56 41 4c 00                             UNK VAL.

0000093e <__c.1411>:
     93e:	43 47 42 20 6f 6e 6c 79 00                          CGB only.

00000947 <__c.1409>:
     947:	47 42 20 26 20 43 47 42 00                          GB & CGB.

00000950 <__c.1407>:
     950:	50 72 65 2d 43 47 42 00                             Pre-CGB.

00000958 <__c.1405>:
     958:	55 6e 73 75 70 70 6f 72 74 65 64 20 4d 42 43 20     Unsupported MBC 
     968:	74 79 70 65 00                                      type.

0000096d <__c.1403>:
     96d:	4d 42 43 32 20 42 41 54 54 00                       MBC2 BATT.

00000977 <__c.1401>:
     977:	4d 42 43 32 00                                      MBC2.

0000097c <__c.1399>:
     97c:	4d 42 43 33 20 52 41 4d 20 42 41 54 54 00           MBC3 RAM BATT.

0000098a <__c.1397>:
     98a:	4d 42 43 33 20 52 41 4d 00                          MBC3 RAM.

00000993 <__c.1395>:
     993:	4d 42 43 33 00                                      MBC3.

00000998 <__c.1393>:
     998:	4d 42 43 33 20 52 54 43 20 52 41 4d 20 42 41 54     MBC3 RTC RAM BAT
     9a8:	54 00                                               T.

000009aa <__c.1391>:
     9aa:	4d 42 43 33 20 52 54 43 20 42 41 54 54 00           MBC3 RTC BATT.

000009b8 <__c.1389>:
     9b8:	4d 42 43 35 20 52 55 4d 42 4c 45 20 52 41 4d 20     MBC5 RUMBLE RAM 
     9c8:	42 41 54 54 00                                      BATT.

000009cd <__c.1387>:
     9cd:	4d 42 43 35 20 52 55 4d 42 4c 45 20 52 41 4d 00     MBC5 RUMBLE RAM.

000009dd <__c.1385>:
     9dd:	4d 42 43 35 20 52 55 4d 42 4c 45 00                 MBC5 RUMBLE.

000009e9 <__c.1383>:
     9e9:	4d 42 43 35 20 52 41 4d 20 42 41 54 54 00           MBC5 RAM BATT.

000009f7 <__c.1381>:
     9f7:	4d 42 43 35 20 52 41 4d 00                          MBC5 RAM.

00000a00 <__c.1379>:
     a00:	4d 42 43 35 00                                      MBC5.

00000a05 <__c.1377>:
     a05:	4d 42 43 31 20 52 41 4d 20 42 41 54 54 00           MBC1 RAM BATT.

00000a13 <__c.1375>:
     a13:	4d 42 43 31 20 52 41 4d 00                          MBC1 RAM.

00000a1c <__c.1373>:
     a1c:	4d 42 43 31 00                                      MBC1.

00000a21 <__c.1371>:
     a21:	52 4f 4d 20 6f 6e 6c 79 00                          ROM only.

00000a2a <__c.1413>:
     a2a:	4d 4f 44 45 20 55 4e 4b 00                          MODE UNK.

00000a33 <__c.1411>:
     a33:	4d 42 43 35 20 20 20 20 00                          MBC5    .

00000a3c <__c.1409>:
     a3c:	4d 42 43 33 20 20 20 20 00                          MBC3    .

00000a45 <__c.1407>:
     a45:	4d 42 43 32 20 20 20 20 00                          MBC2    .

00000a4e <__c.1405>:
     a4e:	4d 42 43 31 5f 34 4d 20 00                          MBC1_4M .

00000a57 <__c.1403>:
     a57:	4d 42 43 31 5f 31 36 4d 00                          MBC1_16M.

00000a60 <__ctors_end>:
     a60:	11 24       	eor	r1, r1
     a62:	1f be       	out	0x3f, r1	; 63
     a64:	cf ef       	ldi	r28, 0xFF	; 255
     a66:	d0 e1       	ldi	r29, 0x10	; 16
     a68:	de bf       	out	0x3e, r29	; 62
     a6a:	cd bf       	out	0x3d, r28	; 61

00000a6c <__do_copy_data>:
     a6c:	11 e0       	ldi	r17, 0x01	; 1
     a6e:	a0 e0       	ldi	r26, 0x00	; 0
     a70:	b1 e0       	ldi	r27, 0x01	; 1
     a72:	e0 ef       	ldi	r30, 0xF0	; 240
     a74:	f3 e4       	ldi	r31, 0x43	; 67
     a76:	02 c0       	rjmp	.+4      	; 0xa7c <.do_copy_data_start>

00000a78 <.do_copy_data_loop>:
     a78:	05 90       	lpm	r0, Z+
     a7a:	0d 92       	st	X+, r0

00000a7c <.do_copy_data_start>:
     a7c:	a6 33       	cpi	r26, 0x36	; 54
     a7e:	b1 07       	cpc	r27, r17
     a80:	d9 f7       	brne	.-10     	; 0xa78 <.do_copy_data_loop>

00000a82 <__do_clear_bss>:
     a82:	15 e0       	ldi	r17, 0x05	; 5
     a84:	a6 e3       	ldi	r26, 0x36	; 54
     a86:	b1 e0       	ldi	r27, 0x01	; 1
     a88:	01 c0       	rjmp	.+2      	; 0xa8c <.do_clear_bss_start>

00000a8a <.do_clear_bss_loop>:
     a8a:	1d 92       	st	X+, r1

00000a8c <.do_clear_bss_start>:
     a8c:	a0 3a       	cpi	r26, 0xA0	; 160
     a8e:	b1 07       	cpc	r27, r17
     a90:	e1 f7       	brne	.-8      	; 0xa8a <.do_clear_bss_loop>
     a92:	0e 94 4f 05 	call	0xa9e	; 0xa9e <main>
     a96:	0c 94 f6 21 	jmp	0x43ec	; 0x43ec <_exit>

00000a9a <__bad_interrupt>:
     a9a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000a9e <main>:

*/

int main() {

  PORTA |= (1 << PA7); // Pull up INTRAMEN ASAP - may be the reason save files are corrupting without this. Need to test
     a9e:	17 9a       	sbi	0x02, 7	; 2

//  uint8_t startMode = PINA & (1 << PA6); // Mode detect!
  uint8_t startMode = PIND & (1 << PD0); // Mode detect!

  if(startMode) {
     aa0:	48 9b       	sbis	0x09, 0	; 9
     aa2:	5a c0       	rjmp	.+180    	; 0xb58 <main+0xba>

    // Set up the flash and SRAM chip port pins
    memory_init();
     aa4:	0e 94 af 10 	call	0x215e	; 0x215e <memory_init>

    // Set up the UART
    usart_init_Xlarge(115200); 
     aa8:	60 e0       	ldi	r22, 0x00	; 0
     aaa:	72 ec       	ldi	r23, 0xC2	; 194
     aac:	81 e0       	ldi	r24, 0x01	; 1
     aae:	90 e0       	ldi	r25, 0x00	; 0
     ab0:	0e 94 11 08 	call	0x1022	; 0x1022 <usart_init_Xlarge>
          checks until afterwards though. Also, I'm doing a whole chip erase atm when writing, so how would
          I fix this if a CRC error appeared as I haven't got the byte-write program correct!
    */

    // Initialise values
    flashAddress.address32 = 0;
     ab4:	10 92 4d 05 	sts	0x054D, r1
     ab8:	10 92 4e 05 	sts	0x054E, r1
     abc:	10 92 4f 05 	sts	0x054F, r1
     ac0:	10 92 50 05 	sts	0x0550, r1
    get_GBROM_info(&gbRomData);
     ac4:	87 e5       	ldi	r24, 0x57	; 87
     ac6:	95 e0       	ldi	r25, 0x05	; 5
     ac8:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <get_GBROM_info>
    read_gbeepromdat(&eepData);
     acc:	80 e9       	ldi	r24, 0x90	; 144
     ace:	95 e0       	ldi	r25, 0x05	; 5
     ad0:	0e 94 cb 20 	call	0x4196	; 0x4196 <read_gbeepromdat>

    if((eepData.MBCMode != CART_MODE_MBC1_16M) && 
     ad4:	90 91 90 05 	lds	r25, 0x0590
     ad8:	89 2f       	mov	r24, r25
     ada:	80 54       	subi	r24, 0x40	; 64
     adc:	83 30       	cpi	r24, 0x03	; 3
     ade:	a0 f1       	brcs	.+104    	; 0xb48 <main+0xaa>
     ae0:	95 34       	cpi	r25, 0x45	; 69
     ae2:	91 f1       	breq	.+100    	; 0xb48 <main+0xaa>
     ae4:	93 34       	cpi	r25, 0x43	; 67
     ae6:	81 f1       	breq	.+96     	; 0xb48 <main+0xaa>
       (eepData.MBCMode != CART_MODE_MBC5) && 
       (eepData.MBCMode != CART_MODE_MBC2) && 
       (eepData.MBCMode != CART_MODE_MBC3)) {

      // Default values are incorrect. Require writing EEPROM values
      usart_transmit_str_P(PSTR("\r\nInvalid EEPROM values detected. Writing default values\r\n"));
     ae8:	8b ef       	ldi	r24, 0xFB	; 251
     aea:	90 e0       	ldi	r25, 0x00	; 0
     aec:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

      // Set the default mode 
      if(gbRomData.MBCtype < 0x04) {
     af0:	90 91 70 05 	lds	r25, 0x0570
     af4:	94 30       	cpi	r25, 0x04	; 4
     af6:	08 f0       	brcs	.+2      	; 0xafa <main+0x5c>
     af8:	46 c0       	rjmp	.+140    	; 0xb86 <main+0xe8>
        // MBC1 or ROM only
    
        if(gbRomData.RAMsizeBytes > 8192 && gbRomData.ROMsizeBytes <= 524288) {
     afa:	80 91 6e 05 	lds	r24, 0x056E
     afe:	90 91 6f 05 	lds	r25, 0x056F
     b02:	81 50       	subi	r24, 0x01	; 1
     b04:	90 42       	sbci	r25, 0x20	; 32
     b06:	a8 f1       	brcs	.+106    	; 0xb72 <main+0xd4>
     b08:	80 91 69 05 	lds	r24, 0x0569
     b0c:	90 91 6a 05 	lds	r25, 0x056A
     b10:	a0 91 6b 05 	lds	r26, 0x056B
     b14:	b0 91 6c 05 	lds	r27, 0x056C
     b18:	81 50       	subi	r24, 0x01	; 1
     b1a:	90 40       	sbci	r25, 0x00	; 0
     b1c:	a8 40       	sbci	r26, 0x08	; 8
     b1e:	b0 40       	sbci	r27, 0x00	; 0
     b20:	f0 f0       	brcs	.+60     	; 0xb5e <main+0xc0>
          eepData.MBCMode = CART_MODE_MBC1_4M;
          strcpy_P(eepData.MBCName, PSTR("MBC1_4M "));
        } else if(gbRomData.RAMsizeBytes > 8192 && gbRomData.ROMsizeBytes > 524288) {
          eepData.MBCMode = CART_MODE_MBC3;
     b22:	83 e4       	ldi	r24, 0x43	; 67
     b24:	80 93 90 05 	sts	0x0590, r24
          strcpy_P(eepData.MBCName, PSTR("MBC3    "));
     b28:	81 e9       	ldi	r24, 0x91	; 145
     b2a:	95 e0       	ldi	r25, 0x05	; 5
     b2c:	69 ee       	ldi	r22, 0xE9	; 233
     b2e:	70 e0       	ldi	r23, 0x00	; 0
     b30:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
          usart_transmit_str_P(PSTR("WARNING: ROM and RAM size both exceed MBC1 mode sizes. Assuming MBC3 mode\r\n"));
     b34:	8d e9       	ldi	r24, 0x9D	; 157
     b36:	90 e0       	ldi	r25, 0x00	; 0
     b38:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
      } else {
        // default to MBC116M8k unless someone else says...
        eepData.MBCMode = CART_MODE_MBC1_16M;
        strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
      }
      program_initial_gbeepromdat(eepData.MBCMode);
     b3c:	80 91 90 05 	lds	r24, 0x0590
     b40:	0e 94 6d 20 	call	0x40da	; 0x40da <program_initial_gbeepromdat>
      wait_for_continue();
     b44:	0e 94 c2 16 	call	0x2d84	; 0x2d84 <wait_for_continue>
    }

    // Turn off unnecessary peripherals
    PRR |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRTIM2)|(1<<PRTWI));
     b48:	80 91 64 00 	lds	r24, 0x0064
     b4c:	8d 6e       	ori	r24, 0xED	; 237
     b4e:	80 93 64 00 	sts	0x0064, r24

    show_menu(); // Loops in here. Don't expect to come out.
     b52:	0e 94 38 1b 	call	0x3670	; 0x3670 <show_menu>
     b56:	ff cf       	rjmp	.-2      	; 0xb56 <main+0xb8>
  
  } else {
    // MBC mode. Jump to the correct handler

    launch_mbc_mode();
     b58:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <launch_mbc_mode>
     b5c:	fc cf       	rjmp	.-8      	; 0xb56 <main+0xb8>
      // Set the default mode 
      if(gbRomData.MBCtype < 0x04) {
        // MBC1 or ROM only
    
        if(gbRomData.RAMsizeBytes > 8192 && gbRomData.ROMsizeBytes <= 524288) {
          eepData.MBCMode = CART_MODE_MBC1_4M;
     b5e:	81 e4       	ldi	r24, 0x41	; 65
     b60:	80 93 90 05 	sts	0x0590, r24
          strcpy_P(eepData.MBCName, PSTR("MBC1_4M "));
     b64:	81 e9       	ldi	r24, 0x91	; 145
     b66:	95 e0       	ldi	r25, 0x05	; 5
     b68:	62 ef       	ldi	r22, 0xF2	; 242
     b6a:	70 e0       	ldi	r23, 0x00	; 0
     b6c:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
     b70:	e5 cf       	rjmp	.-54     	; 0xb3c <main+0x9e>
        } else if(gbRomData.RAMsizeBytes > 8192 && gbRomData.ROMsizeBytes > 524288) {
          eepData.MBCMode = CART_MODE_MBC3;
          strcpy_P(eepData.MBCName, PSTR("MBC3    "));
          usart_transmit_str_P(PSTR("WARNING: ROM and RAM size both exceed MBC1 mode sizes. Assuming MBC3 mode\r\n"));
        } else {
          eepData.MBCMode = CART_MODE_MBC1_16M;
     b72:	80 e4       	ldi	r24, 0x40	; 64
     b74:	80 93 90 05 	sts	0x0590, r24
          strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
     b78:	81 e9       	ldi	r24, 0x91	; 145
     b7a:	95 e0       	ldi	r25, 0x05	; 5
     b7c:	64 e9       	ldi	r22, 0x94	; 148
     b7e:	70 e0       	ldi	r23, 0x00	; 0
     b80:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
     b84:	db cf       	rjmp	.-74     	; 0xb3c <main+0x9e>
        }

      } else if(gbRomData.MBCtype == 0x05 || gbRomData.MBCtype == 0x06) {
     b86:	89 2f       	mov	r24, r25
     b88:	85 50       	subi	r24, 0x05	; 5
     b8a:	82 30       	cpi	r24, 0x02	; 2
     b8c:	80 f0       	brcs	.+32     	; 0xbae <main+0x110>
        // MBC2
        eepData.MBCMode = CART_MODE_MBC2;
        strcpy_P(eepData.MBCName, PSTR("MBC2    "));
      
      } else if(gbRomData.MBCtype >= 0x0F && gbRomData.MBCtype <= 0x13) {
     b8e:	89 2f       	mov	r24, r25
     b90:	8f 50       	subi	r24, 0x0F	; 15
     b92:	85 30       	cpi	r24, 0x05	; 5
     b94:	00 f1       	brcs	.+64     	; 0xbd6 <main+0x138>
        // MBC3
        eepData.MBCMode = CART_MODE_MBC3;
        strcpy_P(eepData.MBCName, PSTR("MBC3    "));

      } else if(gbRomData.MBCtype >= 0x19) {
     b96:	99 31       	cpi	r25, 0x19	; 25
     b98:	a0 f0       	brcs	.+40     	; 0xbc2 <main+0x124>
        // MBC5
        eepData.MBCMode = CART_MODE_MBC5;
     b9a:	82 e4       	ldi	r24, 0x42	; 66
     b9c:	80 93 90 05 	sts	0x0590, r24
        strcpy_P(eepData.MBCName, PSTR("MBC5    "));
     ba0:	81 e9       	ldi	r24, 0x91	; 145
     ba2:	95 e0       	ldi	r25, 0x05	; 5
     ba4:	69 e7       	ldi	r22, 0x79	; 121
     ba6:	70 e0       	ldi	r23, 0x00	; 0
     ba8:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
     bac:	c7 cf       	rjmp	.-114    	; 0xb3c <main+0x9e>
          strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
        }

      } else if(gbRomData.MBCtype == 0x05 || gbRomData.MBCtype == 0x06) {
        // MBC2
        eepData.MBCMode = CART_MODE_MBC2;
     bae:	85 e4       	ldi	r24, 0x45	; 69
     bb0:	80 93 90 05 	sts	0x0590, r24
        strcpy_P(eepData.MBCName, PSTR("MBC2    "));
     bb4:	81 e9       	ldi	r24, 0x91	; 145
     bb6:	95 e0       	ldi	r25, 0x05	; 5
     bb8:	6b e8       	ldi	r22, 0x8B	; 139
     bba:	70 e0       	ldi	r23, 0x00	; 0
     bbc:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
     bc0:	bd cf       	rjmp	.-134    	; 0xb3c <main+0x9e>
        // MBC5
        eepData.MBCMode = CART_MODE_MBC5;
        strcpy_P(eepData.MBCName, PSTR("MBC5    "));
      } else {
        // default to MBC116M8k unless someone else says...
        eepData.MBCMode = CART_MODE_MBC1_16M;
     bc2:	80 e4       	ldi	r24, 0x40	; 64
     bc4:	80 93 90 05 	sts	0x0590, r24
        strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
     bc8:	81 e9       	ldi	r24, 0x91	; 145
     bca:	95 e0       	ldi	r25, 0x05	; 5
     bcc:	60 e7       	ldi	r22, 0x70	; 112
     bce:	70 e0       	ldi	r23, 0x00	; 0
     bd0:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
     bd4:	b3 cf       	rjmp	.-154    	; 0xb3c <main+0x9e>
        eepData.MBCMode = CART_MODE_MBC2;
        strcpy_P(eepData.MBCName, PSTR("MBC2    "));
      
      } else if(gbRomData.MBCtype >= 0x0F && gbRomData.MBCtype <= 0x13) {
        // MBC3
        eepData.MBCMode = CART_MODE_MBC3;
     bd6:	83 e4       	ldi	r24, 0x43	; 67
     bd8:	80 93 90 05 	sts	0x0590, r24
        strcpy_P(eepData.MBCName, PSTR("MBC3    "));
     bdc:	81 e9       	ldi	r24, 0x91	; 145
     bde:	95 e0       	ldi	r25, 0x05	; 5
     be0:	62 e8       	ldi	r22, 0x82	; 130
     be2:	70 e0       	ldi	r23, 0x00	; 0
     be4:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
     be8:	a9 cf       	rjmp	.-174    	; 0xb3c <main+0x9e>

00000bea <usart_init>:
	// Set baud rate: 19200bps when @ 8Mhz
	UBRR0H = (unsigned char)(25>>8);
	UBRR0L = (unsigned char)25;
*/
	// Calculate the baud value
	uint16_t num = (uint32_t)F_CPU / (16 * (uint32_t)baud) - 1;
     bea:	9c 01       	movw	r18, r24
     bec:	40 e0       	ldi	r20, 0x00	; 0
     bee:	50 e0       	ldi	r21, 0x00	; 0
     bf0:	22 0f       	add	r18, r18
     bf2:	33 1f       	adc	r19, r19
     bf4:	44 1f       	adc	r20, r20
     bf6:	55 1f       	adc	r21, r21
     bf8:	22 0f       	add	r18, r18
     bfa:	33 1f       	adc	r19, r19
     bfc:	44 1f       	adc	r20, r20
     bfe:	55 1f       	adc	r21, r21
     c00:	22 0f       	add	r18, r18
     c02:	33 1f       	adc	r19, r19
     c04:	44 1f       	adc	r20, r20
     c06:	55 1f       	adc	r21, r21
     c08:	22 0f       	add	r18, r18
     c0a:	33 1f       	adc	r19, r19
     c0c:	44 1f       	adc	r20, r20
     c0e:	55 1f       	adc	r21, r21
     c10:	60 e0       	ldi	r22, 0x00	; 0
     c12:	70 ec       	ldi	r23, 0xC0	; 192
     c14:	89 e8       	ldi	r24, 0x89	; 137
     c16:	91 e0       	ldi	r25, 0x01	; 1
     c18:	0e 94 6a 21 	call	0x42d4	; 0x42d4 <__udivmodsi4>
     c1c:	21 50       	subi	r18, 0x01	; 1
     c1e:	30 40       	sbci	r19, 0x00	; 0
	
	// Set baud rate 
	UBRR0H = (unsigned char)(num>>8);
     c20:	30 93 c5 00 	sts	0x00C5, r19
	UBRR0L = (unsigned char)num;
     c24:	20 93 c4 00 	sts	0x00C4, r18
	/* Enable receiver and transmitter */
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
     c28:	88 e1       	ldi	r24, 0x18	; 24
     c2a:	80 93 c1 00 	sts	0x00C1, r24
	/* Set frame format: 8data, 1stop bit */
	UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
     c2e:	86 e0       	ldi	r24, 0x06	; 6
     c30:	80 93 c2 00 	sts	0x00C2, r24
}
     c34:	08 95       	ret

00000c36 <usart_transmit>:

void usart_transmit(unsigned char data)
{
     c36:	98 2f       	mov	r25, r24
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     c38:	80 91 c0 00 	lds	r24, 0x00C0
     c3c:	85 ff       	sbrs	r24, 5
     c3e:	fc cf       	rjmp	.-8      	; 0xc38 <usart_transmit+0x2>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     c40:	90 93 c6 00 	sts	0x00C6, r25
}
     c44:	08 95       	ret

00000c46 <usart_receive>:

char usart_receive(void)
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
     c46:	80 91 c0 00 	lds	r24, 0x00C0
     c4a:	87 ff       	sbrs	r24, 7
     c4c:	fc cf       	rjmp	.-8      	; 0xc46 <usart_receive>
	{
	}
	/* Get and return received data from buffer */
	return UDR0;
     c4e:	80 91 c6 00 	lds	r24, 0x00C6
}
     c52:	08 95       	ret

00000c54 <usart_transmit_str>:

void usart_transmit_str(const char* data)
{
     c54:	fc 01       	movw	r30, r24
	// There's still data to go so keep sending it until it ends
	while(*data)
     c56:	90 81       	ld	r25, Z
     c58:	99 23       	and	r25, r25
     c5a:	51 f0       	breq	.+20     	; 0xc70 <usart_transmit_str+0x1c>
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     c5c:	80 91 c0 00 	lds	r24, 0x00C0
     c60:	85 ff       	sbrs	r24, 5
     c62:	fc cf       	rjmp	.-8      	; 0xc5c <usart_transmit_str+0x8>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     c64:	90 93 c6 00 	sts	0x00C6, r25
{
	// There's still data to go so keep sending it until it ends
	while(*data)
	{
		usart_transmit(*data);
        data++;
     c68:	31 96       	adiw	r30, 0x01	; 1
}

void usart_transmit_str(const char* data)
{
	// There's still data to go so keep sending it until it ends
	while(*data)
     c6a:	90 81       	ld	r25, Z
     c6c:	99 23       	and	r25, r25
     c6e:	b1 f7       	brne	.-20     	; 0xc5c <usart_transmit_str+0x8>
     c70:	08 95       	ret

00000c72 <usart_transmit_str_P>:
        data++;
	}
}

void usart_transmit_str_P(const char* data)
{
     c72:	ac 01       	movw	r20, r24
  while (pgm_read_byte(data) != 0x00) {
     c74:	9a 01       	movw	r18, r20
     c76:	fa 01       	movw	r30, r20
     c78:	84 91       	lpm	r24, Z+
     c7a:	88 23       	and	r24, r24
     c7c:	79 f0       	breq	.+30     	; 0xc9c <usart_transmit_str_P+0x2a>
	  usart_transmit(pgm_read_byte(data++));
     c7e:	4f 5f       	subi	r20, 0xFF	; 255
     c80:	5f 4f       	sbci	r21, 0xFF	; 255
     c82:	f9 01       	movw	r30, r18
     c84:	94 91       	lpm	r25, Z+
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     c86:	80 91 c0 00 	lds	r24, 0x00C0
     c8a:	85 ff       	sbrs	r24, 5
     c8c:	fc cf       	rjmp	.-8      	; 0xc86 <usart_transmit_str_P+0x14>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     c8e:	90 93 c6 00 	sts	0x00C6, r25
	}
}

void usart_transmit_str_P(const char* data)
{
  while (pgm_read_byte(data) != 0x00) {
     c92:	9a 01       	movw	r18, r20
     c94:	fa 01       	movw	r30, r20
     c96:	84 91       	lpm	r24, Z+
     c98:	88 23       	and	r24, r24
     c9a:	89 f7       	brne	.-30     	; 0xc7e <usart_transmit_str_P+0xc>
     c9c:	08 95       	ret

00000c9e <usart_transmit_int32>:
    usart_transmit_str(buffer);

}

void usart_transmit_int32(uint32_t num)
{
     c9e:	af 92       	push	r10
     ca0:	bf 92       	push	r11
     ca2:	cf 92       	push	r12
     ca4:	df 92       	push	r13
     ca6:	ef 92       	push	r14
     ca8:	ff 92       	push	r15
     caa:	0f 93       	push	r16
     cac:	df 93       	push	r29
     cae:	cf 93       	push	r28
     cb0:	cd b7       	in	r28, 0x3d	; 61
     cb2:	de b7       	in	r29, 0x3e	; 62
     cb4:	2d 97       	sbiw	r28, 0x0d	; 13
     cb6:	0f b6       	in	r0, 0x3f	; 63
     cb8:	f8 94       	cli
     cba:	de bf       	out	0x3e, r29	; 62
     cbc:	0f be       	out	0x3f, r0	; 63
     cbe:	cd bf       	out	0x3d, r28	; 61
     cc0:	6b 01       	movw	r12, r22
     cc2:	7c 01       	movw	r14, r24
	char buffer[11];
  uint8_t i = 0;

  buffer[0] = '0';
     cc4:	80 e3       	ldi	r24, 0x30	; 48
     cc6:	89 83       	std	Y+1, r24	; 0x01
     cc8:	00 e0       	ldi	r16, 0x00	; 0
     cca:	c1 14       	cp	r12, r1
     ccc:	d1 04       	cpc	r13, r1
     cce:	e1 04       	cpc	r14, r1
     cd0:	f1 04       	cpc	r15, r1
     cd2:	21 f5       	brne	.+72     	; 0xd1c <usart_transmit_int32+0x7e>
     cd4:	01 e0       	ldi	r16, 0x01	; 1
    i++;
  }

  // Now we've converted it in reverse, pump it back out correctly
  for(; i > 0; i--) {
    usart_transmit(buffer[i - 1]);
     cd6:	fe 01       	movw	r30, r28
     cd8:	e0 0f       	add	r30, r16
     cda:	f1 1d       	adc	r31, r1
     cdc:	e0 81       	ld	r30, Z
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     cde:	80 91 c0 00 	lds	r24, 0x00C0
     ce2:	85 ff       	sbrs	r24, 5
     ce4:	fc cf       	rjmp	.-8      	; 0xcde <usart_transmit_int32+0x40>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     ce6:	e0 93 c6 00 	sts	0x00C6, r30
    num /= 10;
    i++;
  }

  // Now we've converted it in reverse, pump it back out correctly
  for(; i > 0; i--) {
     cea:	01 50       	subi	r16, 0x01	; 1
     cec:	00 23       	and	r16, r16
     cee:	99 f7       	brne	.-26     	; 0xcd6 <usart_transmit_int32+0x38>
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     cf0:	80 91 c0 00 	lds	r24, 0x00C0
     cf4:	85 ff       	sbrs	r24, 5
     cf6:	fc cf       	rjmp	.-8      	; 0xcf0 <usart_transmit_int32+0x52>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     cf8:	10 92 c6 00 	sts	0x00C6, r1
  // Now we've converted it in reverse, pump it back out correctly
  for(; i > 0; i--) {
    usart_transmit(buffer[i - 1]);
  }
  usart_transmit('\0');
}
     cfc:	2d 96       	adiw	r28, 0x0d	; 13
     cfe:	0f b6       	in	r0, 0x3f	; 63
     d00:	f8 94       	cli
     d02:	de bf       	out	0x3e, r29	; 62
     d04:	0f be       	out	0x3f, r0	; 63
     d06:	cd bf       	out	0x3d, r28	; 61
     d08:	cf 91       	pop	r28
     d0a:	df 91       	pop	r29
     d0c:	0f 91       	pop	r16
     d0e:	ff 90       	pop	r15
     d10:	ef 90       	pop	r14
     d12:	df 90       	pop	r13
     d14:	cf 90       	pop	r12
     d16:	bf 90       	pop	r11
     d18:	af 90       	pop	r10
     d1a:	08 95       	ret
     d1c:	5e 01       	movw	r10, r28
     d1e:	08 94       	sec
     d20:	a1 1c       	adc	r10, r1
     d22:	b1 1c       	adc	r11, r1
  if(num == 0) {
    i = 1; // Need to push at least one value out
  }

  while(num > 0) {
    buffer[i] = num % 10 + '0';
     d24:	c5 01       	movw	r24, r10
     d26:	80 0f       	add	r24, r16
     d28:	91 1d       	adc	r25, r1
     d2a:	9d 87       	std	Y+13, r25	; 0x0d
     d2c:	8c 87       	std	Y+12, r24	; 0x0c
     d2e:	c7 01       	movw	r24, r14
     d30:	b6 01       	movw	r22, r12
     d32:	2a e0       	ldi	r18, 0x0A	; 10
     d34:	30 e0       	ldi	r19, 0x00	; 0
     d36:	40 e0       	ldi	r20, 0x00	; 0
     d38:	50 e0       	ldi	r21, 0x00	; 0
     d3a:	0e 94 6a 21 	call	0x42d4	; 0x42d4 <__udivmodsi4>
     d3e:	60 5d       	subi	r22, 0xD0	; 208
     d40:	ec 85       	ldd	r30, Y+12	; 0x0c
     d42:	fd 85       	ldd	r31, Y+13	; 0x0d
     d44:	60 83       	st	Z, r22
    num /= 10;
     d46:	c7 01       	movw	r24, r14
     d48:	b6 01       	movw	r22, r12
     d4a:	2a e0       	ldi	r18, 0x0A	; 10
     d4c:	30 e0       	ldi	r19, 0x00	; 0
     d4e:	40 e0       	ldi	r20, 0x00	; 0
     d50:	50 e0       	ldi	r21, 0x00	; 0
     d52:	0e 94 6a 21 	call	0x42d4	; 0x42d4 <__udivmodsi4>
     d56:	c9 01       	movw	r24, r18
     d58:	da 01       	movw	r26, r20
     d5a:	6c 01       	movw	r12, r24
     d5c:	7d 01       	movw	r14, r26
    i++;
     d5e:	0f 5f       	subi	r16, 0xFF	; 255

  if(num == 0) {
    i = 1; // Need to push at least one value out
  }

  while(num > 0) {
     d60:	c1 14       	cp	r12, r1
     d62:	d1 04       	cpc	r13, r1
     d64:	e1 04       	cpc	r14, r1
     d66:	f1 04       	cpc	r15, r1
     d68:	e9 f6       	brne	.-70     	; 0xd24 <usart_transmit_int32+0x86>
     d6a:	c0 cf       	rjmp	.-128    	; 0xcec <usart_transmit_int32+0x4e>

00000d6c <usart_rec_disable>:
  usart_transmit('\0');
}

void usart_rec_disable(void)
{
	UCSR0B |= (0<<RXEN0);
     d6c:	e1 ec       	ldi	r30, 0xC1	; 193
     d6e:	f0 e0       	ldi	r31, 0x00	; 0
     d70:	80 81       	ld	r24, Z
     d72:	80 83       	st	Z, r24
}
     d74:	08 95       	ret

00000d76 <usart_rec_enable>:

void usart_rec_enable(void)
{
	UCSR0B |= (1<<RXEN0);
     d76:	e1 ec       	ldi	r30, 0xC1	; 193
     d78:	f0 e0       	ldi	r31, 0x00	; 0
     d7a:	80 81       	ld	r24, Z
     d7c:	80 61       	ori	r24, 0x10	; 16
     d7e:	80 83       	st	Z, r24
}
     d80:	08 95       	ret

00000d82 <save_cursor_pos>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     d82:	80 91 c0 00 	lds	r24, 0x00C0
     d86:	85 ff       	sbrs	r24, 5
     d88:	fc cf       	rjmp	.-8      	; 0xd82 <save_cursor_pos>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     d8a:	8b e1       	ldi	r24, 0x1B	; 27
     d8c:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     d90:	80 91 c0 00 	lds	r24, 0x00C0
     d94:	85 ff       	sbrs	r24, 5
     d96:	fc cf       	rjmp	.-8      	; 0xd90 <save_cursor_pos+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     d98:	8b e5       	ldi	r24, 0x5B	; 91
     d9a:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     d9e:	80 91 c0 00 	lds	r24, 0x00C0
     da2:	85 ff       	sbrs	r24, 5
     da4:	fc cf       	rjmp	.-8      	; 0xd9e <save_cursor_pos+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     da6:	83 e7       	ldi	r24, 0x73	; 115
     da8:	80 93 c6 00 	sts	0x00C6, r24
{
    usart_transmit('\x1b');
	usart_transmit('[');

    usart_transmit( 's' );
}
     dac:	08 95       	ret

00000dae <restore_cursor_pos>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     dae:	80 91 c0 00 	lds	r24, 0x00C0
     db2:	85 ff       	sbrs	r24, 5
     db4:	fc cf       	rjmp	.-8      	; 0xdae <restore_cursor_pos>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     db6:	8b e1       	ldi	r24, 0x1B	; 27
     db8:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     dbc:	80 91 c0 00 	lds	r24, 0x00C0
     dc0:	85 ff       	sbrs	r24, 5
     dc2:	fc cf       	rjmp	.-8      	; 0xdbc <restore_cursor_pos+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     dc4:	8b e5       	ldi	r24, 0x5B	; 91
     dc6:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     dca:	80 91 c0 00 	lds	r24, 0x00C0
     dce:	85 ff       	sbrs	r24, 5
     dd0:	fc cf       	rjmp	.-8      	; 0xdca <restore_cursor_pos+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     dd2:	85 e7       	ldi	r24, 0x75	; 117
     dd4:	80 93 c6 00 	sts	0x00C6, r24
{
    usart_transmit('\x1b');
	usart_transmit('[');

    usart_transmit( 'u' );
}
     dd8:	08 95       	ret

00000dda <erase_screen_bottom>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     dda:	80 91 c0 00 	lds	r24, 0x00C0
     dde:	85 ff       	sbrs	r24, 5
     de0:	fc cf       	rjmp	.-8      	; 0xdda <erase_screen_bottom>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     de2:	8b e1       	ldi	r24, 0x1B	; 27
     de4:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     de8:	80 91 c0 00 	lds	r24, 0x00C0
     dec:	85 ff       	sbrs	r24, 5
     dee:	fc cf       	rjmp	.-8      	; 0xde8 <erase_screen_bottom+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     df0:	8b e5       	ldi	r24, 0x5B	; 91
     df2:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     df6:	80 91 c0 00 	lds	r24, 0x00C0
     dfa:	85 ff       	sbrs	r24, 5
     dfc:	fc cf       	rjmp	.-8      	; 0xdf6 <erase_screen_bottom+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     dfe:	8a e4       	ldi	r24, 0x4A	; 74
     e00:	80 93 c6 00 	sts	0x00C6, r24
{
    usart_transmit('\x1b');
	usart_transmit('[');

    usart_transmit( 'J' );
}
     e04:	08 95       	ret

00000e06 <erase_screen_top>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e06:	80 91 c0 00 	lds	r24, 0x00C0
     e0a:	85 ff       	sbrs	r24, 5
     e0c:	fc cf       	rjmp	.-8      	; 0xe06 <erase_screen_top>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e0e:	8b e1       	ldi	r24, 0x1B	; 27
     e10:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e14:	80 91 c0 00 	lds	r24, 0x00C0
     e18:	85 ff       	sbrs	r24, 5
     e1a:	fc cf       	rjmp	.-8      	; 0xe14 <erase_screen_top+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e1c:	8b e5       	ldi	r24, 0x5B	; 91
     e1e:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e22:	80 91 c0 00 	lds	r24, 0x00C0
     e26:	85 ff       	sbrs	r24, 5
     e28:	fc cf       	rjmp	.-8      	; 0xe22 <erase_screen_top+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e2a:	81 e3       	ldi	r24, 0x31	; 49
     e2c:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e30:	80 91 c0 00 	lds	r24, 0x00C0
     e34:	85 ff       	sbrs	r24, 5
     e36:	fc cf       	rjmp	.-8      	; 0xe30 <erase_screen_top+0x2a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e38:	8a e4       	ldi	r24, 0x4A	; 74
     e3a:	80 93 c6 00 	sts	0x00C6, r24
    usart_transmit('\x1b');
	usart_transmit('[');         
    
    usart_transmit( '1' );
    usart_transmit( 'J' );
}
     e3e:	08 95       	ret

00000e40 <erase_screen_endline>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e40:	80 91 c0 00 	lds	r24, 0x00C0
     e44:	85 ff       	sbrs	r24, 5
     e46:	fc cf       	rjmp	.-8      	; 0xe40 <erase_screen_endline>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e48:	8b e1       	ldi	r24, 0x1B	; 27
     e4a:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e4e:	80 91 c0 00 	lds	r24, 0x00C0
     e52:	85 ff       	sbrs	r24, 5
     e54:	fc cf       	rjmp	.-8      	; 0xe4e <erase_screen_endline+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e56:	8b e5       	ldi	r24, 0x5B	; 91
     e58:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e5c:	80 91 c0 00 	lds	r24, 0x00C0
     e60:	85 ff       	sbrs	r24, 5
     e62:	fc cf       	rjmp	.-8      	; 0xe5c <erase_screen_endline+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e64:	8b e4       	ldi	r24, 0x4B	; 75
     e66:	80 93 c6 00 	sts	0x00C6, r24
{
    usart_transmit('\x1b');
	usart_transmit('[');
    
    usart_transmit( 'K' );
}
     e6a:	08 95       	ret

00000e6c <erase_screen_startline>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e6c:	80 91 c0 00 	lds	r24, 0x00C0
     e70:	85 ff       	sbrs	r24, 5
     e72:	fc cf       	rjmp	.-8      	; 0xe6c <erase_screen_startline>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e74:	8b e1       	ldi	r24, 0x1B	; 27
     e76:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e7a:	80 91 c0 00 	lds	r24, 0x00C0
     e7e:	85 ff       	sbrs	r24, 5
     e80:	fc cf       	rjmp	.-8      	; 0xe7a <erase_screen_startline+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e82:	8b e5       	ldi	r24, 0x5B	; 91
     e84:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e88:	80 91 c0 00 	lds	r24, 0x00C0
     e8c:	85 ff       	sbrs	r24, 5
     e8e:	fc cf       	rjmp	.-8      	; 0xe88 <erase_screen_startline+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e90:	81 e3       	ldi	r24, 0x31	; 49
     e92:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     e96:	80 91 c0 00 	lds	r24, 0x00C0
     e9a:	85 ff       	sbrs	r24, 5
     e9c:	fc cf       	rjmp	.-8      	; 0xe96 <erase_screen_startline+0x2a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     e9e:	8b e4       	ldi	r24, 0x4B	; 75
     ea0:	80 93 c6 00 	sts	0x00C6, r24
    usart_transmit('\x1b');
	usart_transmit('[');
    
    usart_transmit( '1' );
    usart_transmit( 'K' );
}
     ea4:	08 95       	ret

00000ea6 <erase_screen_line>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     ea6:	80 91 c0 00 	lds	r24, 0x00C0
     eaa:	85 ff       	sbrs	r24, 5
     eac:	fc cf       	rjmp	.-8      	; 0xea6 <erase_screen_line>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     eae:	8b e1       	ldi	r24, 0x1B	; 27
     eb0:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     eb4:	80 91 c0 00 	lds	r24, 0x00C0
     eb8:	85 ff       	sbrs	r24, 5
     eba:	fc cf       	rjmp	.-8      	; 0xeb4 <erase_screen_line+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     ebc:	8b e5       	ldi	r24, 0x5B	; 91
     ebe:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     ec2:	80 91 c0 00 	lds	r24, 0x00C0
     ec6:	85 ff       	sbrs	r24, 5
     ec8:	fc cf       	rjmp	.-8      	; 0xec2 <erase_screen_line+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     eca:	82 e3       	ldi	r24, 0x32	; 50
     ecc:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     ed0:	80 91 c0 00 	lds	r24, 0x00C0
     ed4:	85 ff       	sbrs	r24, 5
     ed6:	fc cf       	rjmp	.-8      	; 0xed0 <erase_screen_line+0x2a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     ed8:	8b e4       	ldi	r24, 0x4B	; 75
     eda:	80 93 c6 00 	sts	0x00C6, r24
    usart_transmit('\x1b');
	usart_transmit('[');
    
    usart_transmit( '2' );
    usart_transmit( 'K' );
}
     ede:	08 95       	ret

00000ee0 <ht_set_display_colour>:

void ht_set_display_colour( unsigned char fg_bg, unsigned char colour )
{
     ee0:	98 2f       	mov	r25, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     ee2:	80 91 c0 00 	lds	r24, 0x00C0
     ee6:	85 ff       	sbrs	r24, 5
     ee8:	fc cf       	rjmp	.-8      	; 0xee2 <ht_set_display_colour+0x2>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     eea:	8b e1       	ldi	r24, 0x1B	; 27
     eec:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     ef0:	80 91 c0 00 	lds	r24, 0x00C0
     ef4:	85 ff       	sbrs	r24, 5
     ef6:	fc cf       	rjmp	.-8      	; 0xef0 <ht_set_display_colour+0x10>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     ef8:	8b e5       	ldi	r24, 0x5B	; 91
     efa:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     efe:	80 91 c0 00 	lds	r24, 0x00C0
     f02:	85 ff       	sbrs	r24, 5
     f04:	fc cf       	rjmp	.-8      	; 0xefe <ht_set_display_colour+0x1e>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f06:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f0a:	80 91 c0 00 	lds	r24, 0x00C0
     f0e:	85 ff       	sbrs	r24, 5
     f10:	fc cf       	rjmp	.-8      	; 0xf0a <ht_set_display_colour+0x2a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f12:	60 93 c6 00 	sts	0x00C6, r22
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f16:	80 91 c0 00 	lds	r24, 0x00C0
     f1a:	85 ff       	sbrs	r24, 5
     f1c:	fc cf       	rjmp	.-8      	; 0xf16 <ht_set_display_colour+0x36>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f1e:	8d e6       	ldi	r24, 0x6D	; 109
     f20:	80 93 c6 00 	sts	0x00C6, r24
	usart_transmit('[');
    
    usart_transmit( fg_bg );                 // Select foreground/background
    usart_transmit( colour );
    usart_transmit( 'm' );
}
     f24:	08 95       	ret

00000f26 <ht_set_display_attribute_mode>:

void ht_set_display_attribute_mode( unsigned char mode )
{
     f26:	98 2f       	mov	r25, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f28:	80 91 c0 00 	lds	r24, 0x00C0
     f2c:	85 ff       	sbrs	r24, 5
     f2e:	fc cf       	rjmp	.-8      	; 0xf28 <ht_set_display_attribute_mode+0x2>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f30:	8b e1       	ldi	r24, 0x1B	; 27
     f32:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f36:	80 91 c0 00 	lds	r24, 0x00C0
     f3a:	85 ff       	sbrs	r24, 5
     f3c:	fc cf       	rjmp	.-8      	; 0xf36 <ht_set_display_attribute_mode+0x10>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f3e:	8b e5       	ldi	r24, 0x5B	; 91
     f40:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f44:	80 91 c0 00 	lds	r24, 0x00C0
     f48:	85 ff       	sbrs	r24, 5
     f4a:	fc cf       	rjmp	.-8      	; 0xf44 <ht_set_display_attribute_mode+0x1e>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f4c:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f50:	80 91 c0 00 	lds	r24, 0x00C0
     f54:	85 ff       	sbrs	r24, 5
     f56:	fc cf       	rjmp	.-8      	; 0xf50 <ht_set_display_attribute_mode+0x2a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f58:	8d e6       	ldi	r24, 0x6D	; 109
     f5a:	80 93 c6 00 	sts	0x00C6, r24
    usart_transmit('\x1b');
	usart_transmit('[');
    
    usart_transmit( mode );
    usart_transmit( 'm' );
}
     f5e:	08 95       	ret

00000f60 <ht_scroll_all>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f60:	80 91 c0 00 	lds	r24, 0x00C0
     f64:	85 ff       	sbrs	r24, 5
     f66:	fc cf       	rjmp	.-8      	; 0xf60 <ht_scroll_all>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f68:	8b e1       	ldi	r24, 0x1B	; 27
     f6a:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f6e:	80 91 c0 00 	lds	r24, 0x00C0
     f72:	85 ff       	sbrs	r24, 5
     f74:	fc cf       	rjmp	.-8      	; 0xf6e <ht_scroll_all+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f76:	8b e5       	ldi	r24, 0x5B	; 91
     f78:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f7c:	80 91 c0 00 	lds	r24, 0x00C0
     f80:	85 ff       	sbrs	r24, 5
     f82:	fc cf       	rjmp	.-8      	; 0xf7c <ht_scroll_all+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f84:	82 e7       	ldi	r24, 0x72	; 114
     f86:	80 93 c6 00 	sts	0x00C6, r24
{
    usart_transmit('\x1b');
	usart_transmit('[');
    
    usart_transmit( 'r' );
}
     f8a:	08 95       	ret

00000f8c <ht_print_screen>:
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f8c:	80 91 c0 00 	lds	r24, 0x00C0
     f90:	85 ff       	sbrs	r24, 5
     f92:	fc cf       	rjmp	.-8      	; 0xf8c <ht_print_screen>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     f94:	8b e1       	ldi	r24, 0x1B	; 27
     f96:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     f9a:	80 91 c0 00 	lds	r24, 0x00C0
     f9e:	85 ff       	sbrs	r24, 5
     fa0:	fc cf       	rjmp	.-8      	; 0xf9a <ht_print_screen+0xe>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     fa2:	8b e5       	ldi	r24, 0x5B	; 91
     fa4:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     fa8:	80 91 c0 00 	lds	r24, 0x00C0
     fac:	85 ff       	sbrs	r24, 5
     fae:	fc cf       	rjmp	.-8      	; 0xfa8 <ht_print_screen+0x1c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     fb0:	89 e6       	ldi	r24, 0x69	; 105
     fb2:	80 93 c6 00 	sts	0x00C6, r24
{
    usart_transmit('\x1b');
	usart_transmit('[');                         // Send escape sequence start
   
    usart_transmit( 'i' );
}
     fb6:	08 95       	ret

00000fb8 <usart_transmit_dec>:

//***************************
// Convert byte to 3 ASCII digits and send
//***************************
void usart_transmit_dec( unsigned char value )
{
     fb8:	38 2f       	mov	r19, r24
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
     fba:	84 36       	cpi	r24, 0x64	; 100
     fbc:	70 f1       	brcs	.+92     	; 0x101a <usart_transmit_dec+0x62>

//***************************
// Convert byte to 3 ASCII digits and send
//***************************
void usart_transmit_dec( unsigned char value )
{
     fbe:	28 2f       	mov	r18, r24
     fc0:	24 56       	subi	r18, 0x64	; 100
     fc2:	82 2f       	mov	r24, r18
     fc4:	64 e6       	ldi	r22, 0x64	; 100
     fc6:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
     fca:	39 2f       	mov	r19, r25
     fcc:	82 2f       	mov	r24, r18
     fce:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
     fd2:	98 2f       	mov	r25, r24
     fd4:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     fd6:	80 91 c0 00 	lds	r24, 0x00C0
     fda:	85 ff       	sbrs	r24, 5
     fdc:	fc cf       	rjmp	.-8      	; 0xfd6 <usart_transmit_dec+0x1e>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
     fde:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
     fe2:	3a 30       	cpi	r19, 0x0A	; 10
     fe4:	e0 f0       	brcs	.+56     	; 0x101e <usart_transmit_dec+0x66>

//***************************
// Convert byte to 3 ASCII digits and send
//***************************
void usart_transmit_dec( unsigned char value )
{
     fe6:	23 2f       	mov	r18, r19
     fe8:	2a 50       	subi	r18, 0x0A	; 10
     fea:	82 2f       	mov	r24, r18
     fec:	6a e0       	ldi	r22, 0x0A	; 10
     fee:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
     ff2:	39 2f       	mov	r19, r25
     ff4:	82 2f       	mov	r24, r18
     ff6:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
     ffa:	98 2f       	mov	r25, r24
     ffc:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
     ffe:	80 91 c0 00 	lds	r24, 0x00C0
    1002:	85 ff       	sbrs	r24, 5
    1004:	fc cf       	rjmp	.-8      	; 0xffe <usart_transmit_dec+0x46>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1006:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    100a:	80 91 c0 00 	lds	r24, 0x00C0
    100e:	85 ff       	sbrs	r24, 5
    1010:	fc cf       	rjmp	.-8      	; 0x100a <usart_transmit_dec+0x52>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    1012:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1014:	30 93 c6 00 	sts	0x00C6, r19
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
}
    1018:	08 95       	ret
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    101a:	90 e3       	ldi	r25, 0x30	; 48
    101c:	dc cf       	rjmp	.-72     	; 0xfd6 <usart_transmit_dec+0x1e>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    101e:	90 e3       	ldi	r25, 0x30	; 48
    1020:	ee cf       	rjmp	.-36     	; 0xffe <usart_transmit_dec+0x46>

00001022 <usart_init_Xlarge>:
    usart_transmit( '0' + value );            // Send third digit
}


void usart_init_Xlarge(uint32_t baud)
{
    1022:	9b 01       	movw	r18, r22
    1024:	ac 01       	movw	r20, r24
	// Set baud rate: 19200bps when @ 8Mhz
	UBRR0H = (unsigned char)(25>>8);
	UBRR0L = (unsigned char)25;
*/
	// Calculate the baud value
	uint16_t num = (uint32_t)F_CPU / (16 * baud) - 1;
    1026:	22 0f       	add	r18, r18
    1028:	33 1f       	adc	r19, r19
    102a:	44 1f       	adc	r20, r20
    102c:	55 1f       	adc	r21, r21
    102e:	22 0f       	add	r18, r18
    1030:	33 1f       	adc	r19, r19
    1032:	44 1f       	adc	r20, r20
    1034:	55 1f       	adc	r21, r21
    1036:	22 0f       	add	r18, r18
    1038:	33 1f       	adc	r19, r19
    103a:	44 1f       	adc	r20, r20
    103c:	55 1f       	adc	r21, r21
    103e:	22 0f       	add	r18, r18
    1040:	33 1f       	adc	r19, r19
    1042:	44 1f       	adc	r20, r20
    1044:	55 1f       	adc	r21, r21
    1046:	60 e0       	ldi	r22, 0x00	; 0
    1048:	70 ec       	ldi	r23, 0xC0	; 192
    104a:	89 e8       	ldi	r24, 0x89	; 137
    104c:	91 e0       	ldi	r25, 0x01	; 1
    104e:	0e 94 6a 21 	call	0x42d4	; 0x42d4 <__udivmodsi4>
    1052:	21 50       	subi	r18, 0x01	; 1
    1054:	30 40       	sbci	r19, 0x00	; 0
	
	// Set baud rate 
	UBRR0H = (unsigned char)(num>>8);
    1056:	30 93 c5 00 	sts	0x00C5, r19
	UBRR0L = (unsigned char)num;
    105a:	20 93 c4 00 	sts	0x00C4, r18
	/* Enable receiver and transmitter */
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    105e:	88 e1       	ldi	r24, 0x18	; 24
    1060:	80 93 c1 00 	sts	0x00C1, r24
	/* Set frame format: 8data, 1stop bit */
	UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
    1064:	86 e0       	ldi	r24, 0x06	; 6
    1066:	80 93 c2 00 	sts	0x00C2, r24
}
    106a:	08 95       	ret

0000106c <usart_data_received>:

uint8_t usart_data_received(void)
{
	if(UCSR0A & (1<<RXC0))
    106c:	80 91 c0 00 	lds	r24, 0x00C0
	{
		return 1;
	}
	return 0;
}
    1070:	88 1f       	adc	r24, r24
    1072:	88 27       	eor	r24, r24
    1074:	88 1f       	adc	r24, r24
    1076:	08 95       	ret

00001078 <usart_int_enable>:

int usart_int_enable(int(*func)(unsigned char))
{
  UCSR0B |= (1 << RXCIE0);
    1078:	e1 ec       	ldi	r30, 0xC1	; 193
    107a:	f0 e0       	ldi	r31, 0x00	; 0
    107c:	20 81       	ld	r18, Z
    107e:	20 68       	ori	r18, 0x80	; 128
    1080:	20 83       	st	Z, r18
  
  _rx_func = func;
    1082:	90 93 3f 01 	sts	0x013F, r25
    1086:	80 93 3e 01 	sts	0x013E, r24

  return 0;
}
    108a:	80 e0       	ldi	r24, 0x00	; 0
    108c:	90 e0       	ldi	r25, 0x00	; 0
    108e:	08 95       	ret

00001090 <usart_int_disable>:

int usart_int_disable(int(*func)(unsigned char))
{
  UCSR0B &= ~(1 << RXCIE0);
    1090:	e1 ec       	ldi	r30, 0xC1	; 193
    1092:	f0 e0       	ldi	r31, 0x00	; 0
    1094:	80 81       	ld	r24, Z
    1096:	8f 77       	andi	r24, 0x7F	; 127
    1098:	80 83       	st	Z, r24

  return 0;
}
    109a:	80 e0       	ldi	r24, 0x00	; 0
    109c:	90 e0       	ldi	r25, 0x00	; 0
    109e:	08 95       	ret

000010a0 <__vector_20>:

ISR(USART0_RX_vect)
{
    10a0:	1f 92       	push	r1
    10a2:	0f 92       	push	r0
    10a4:	0f b6       	in	r0, 0x3f	; 63
    10a6:	0f 92       	push	r0
    10a8:	11 24       	eor	r1, r1
    10aa:	2f 93       	push	r18
    10ac:	3f 93       	push	r19
    10ae:	4f 93       	push	r20
    10b0:	5f 93       	push	r21
    10b2:	6f 93       	push	r22
    10b4:	7f 93       	push	r23
    10b6:	8f 93       	push	r24
    10b8:	9f 93       	push	r25
    10ba:	af 93       	push	r26
    10bc:	bf 93       	push	r27
    10be:	ef 93       	push	r30
    10c0:	ff 93       	push	r31
  (*_rx_func)(UDR0);
    10c2:	80 91 c6 00 	lds	r24, 0x00C6
    10c6:	e0 91 3e 01 	lds	r30, 0x013E
    10ca:	f0 91 3f 01 	lds	r31, 0x013F
    10ce:	09 95       	icall
}
    10d0:	ff 91       	pop	r31
    10d2:	ef 91       	pop	r30
    10d4:	bf 91       	pop	r27
    10d6:	af 91       	pop	r26
    10d8:	9f 91       	pop	r25
    10da:	8f 91       	pop	r24
    10dc:	7f 91       	pop	r23
    10de:	6f 91       	pop	r22
    10e0:	5f 91       	pop	r21
    10e2:	4f 91       	pop	r20
    10e4:	3f 91       	pop	r19
    10e6:	2f 91       	pop	r18
    10e8:	0f 90       	pop	r0
    10ea:	0f be       	out	0x3f, r0	; 63
    10ec:	0f 90       	pop	r0
    10ee:	1f 90       	pop	r1
    10f0:	18 95       	reti

000010f2 <nibble_to_hex>:

char nibble_to_hex(uint8_t value) {
    10f2:	df 93       	push	r29
    10f4:	cf 93       	push	r28
    10f6:	cd b7       	in	r28, 0x3d	; 61
    10f8:	de b7       	in	r29, 0x3e	; 62
    10fa:	60 97       	sbiw	r28, 0x10	; 16
    10fc:	0f b6       	in	r0, 0x3f	; 63
    10fe:	f8 94       	cli
    1100:	de bf       	out	0x3e, r29	; 62
    1102:	0f be       	out	0x3f, r0	; 63
    1104:	cd bf       	out	0x3d, r28	; 61

  char ASCII[] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46};
    1106:	ae 01       	movw	r20, r28
    1108:	4f 5f       	subi	r20, 0xFF	; 255
    110a:	5f 4f       	sbci	r21, 0xFF	; 255
    110c:	9a 01       	movw	r18, r20
    110e:	e5 e0       	ldi	r30, 0x05	; 5
    1110:	f1 e0       	ldi	r31, 0x01	; 1
    1112:	90 e1       	ldi	r25, 0x10	; 16
    1114:	01 90       	ld	r0, Z+
    1116:	d9 01       	movw	r26, r18
    1118:	0d 92       	st	X+, r0
    111a:	9d 01       	movw	r18, r26
    111c:	91 50       	subi	r25, 0x01	; 1
    111e:	d1 f7       	brne	.-12     	; 0x1114 <__stack+0x15>
    1120:	8f 70       	andi	r24, 0x0F	; 15
    1122:	48 0f       	add	r20, r24
    1124:	51 1d       	adc	r21, r1

  return ASCII[(value & 0x0F)];
}
    1126:	fa 01       	movw	r30, r20
    1128:	80 81       	ld	r24, Z
    112a:	60 96       	adiw	r28, 0x10	; 16
    112c:	0f b6       	in	r0, 0x3f	; 63
    112e:	f8 94       	cli
    1130:	de bf       	out	0x3e, r29	; 62
    1132:	0f be       	out	0x3f, r0	; 63
    1134:	cd bf       	out	0x3d, r28	; 61
    1136:	cf 91       	pop	r28
    1138:	df 91       	pop	r29
    113a:	08 95       	ret

0000113c <usart_clear_ht>:
{
	UCSR0B |= (1<<RXEN0);
}

void usart_clear_ht(void)
{
    113c:	e0 e0       	ldi	r30, 0x00	; 0
    113e:	f1 e0       	ldi	r31, 0x01	; 1
    1140:	9b e1       	ldi	r25, 0x1B	; 27
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1142:	80 91 c0 00 	lds	r24, 0x00C0
    1146:	85 ff       	sbrs	r24, 5
    1148:	fc cf       	rjmp	.-8      	; 0x1142 <usart_clear_ht+0x6>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    114a:	90 93 c6 00 	sts	0x00C6, r25
{
	// There's still data to go so keep sending it until it ends
	while(*data)
	{
		usart_transmit(*data);
        data++;
    114e:	31 96       	adiw	r30, 0x01	; 1
}

void usart_transmit_str(const char* data)
{
	// There's still data to go so keep sending it until it ends
	while(*data)
    1150:	90 81       	ld	r25, Z
    1152:	99 23       	and	r25, r25
    1154:	b1 f7       	brne	.-20     	; 0x1142 <usart_clear_ht+0x6>
}

void usart_clear_ht(void)
{
	usart_transmit_str("\x1b[2J");
}
    1156:	08 95       	ret

00001158 <usart_transmit_int>:
	  usart_transmit(pgm_read_byte(data++));
  }
}

void usart_transmit_int(int16_t num)
{
    1158:	df 93       	push	r29
    115a:	cf 93       	push	r28
    115c:	cd b7       	in	r28, 0x3d	; 61
    115e:	de b7       	in	r29, 0x3e	; 62
    1160:	2a 97       	sbiw	r28, 0x0a	; 10
    1162:	0f b6       	in	r0, 0x3f	; 63
    1164:	f8 94       	cli
    1166:	de bf       	out	0x3e, r29	; 62
    1168:	0f be       	out	0x3f, r0	; 63
    116a:	cd bf       	out	0x3d, r28	; 61
    116c:	9c 01       	movw	r18, r24
	char buffer[10];
    uint16_t n, i;
    for(n = 10000, i = 0; n > 0; n /= 10, i++)
    {
        buffer[i] = ((num / n) % 10) + '0';
    116e:	60 e1       	ldi	r22, 0x10	; 16
    1170:	77 e2       	ldi	r23, 0x27	; 39
    1172:	0e 94 56 21 	call	0x42ac	; 0x42ac <__udivmodhi4>
    1176:	cb 01       	movw	r24, r22
    1178:	6a e0       	ldi	r22, 0x0A	; 10
    117a:	70 e0       	ldi	r23, 0x00	; 0
    117c:	0e 94 56 21 	call	0x42ac	; 0x42ac <__udivmodhi4>
    1180:	48 2f       	mov	r20, r24
    1182:	40 5d       	subi	r20, 0xD0	; 208
    1184:	49 83       	std	Y+1, r20	; 0x01
    1186:	c9 01       	movw	r24, r18
    1188:	68 ee       	ldi	r22, 0xE8	; 232
    118a:	73 e0       	ldi	r23, 0x03	; 3
    118c:	0e 94 56 21 	call	0x42ac	; 0x42ac <__udivmodhi4>
    1190:	cb 01       	movw	r24, r22
    1192:	6a e0       	ldi	r22, 0x0A	; 10
    1194:	70 e0       	ldi	r23, 0x00	; 0
    1196:	0e 94 56 21 	call	0x42ac	; 0x42ac <__udivmodhi4>
    119a:	80 5d       	subi	r24, 0xD0	; 208
    119c:	8a 83       	std	Y+2, r24	; 0x02
    119e:	c9 01       	movw	r24, r18
    11a0:	64 e6       	ldi	r22, 0x64	; 100
    11a2:	70 e0       	ldi	r23, 0x00	; 0
    11a4:	0e 94 56 21 	call	0x42ac	; 0x42ac <__udivmodhi4>
    11a8:	cb 01       	movw	r24, r22
    11aa:	6a e0       	ldi	r22, 0x0A	; 10
    11ac:	70 e0       	ldi	r23, 0x00	; 0
    11ae:	0e 94 56 21 	call	0x42ac	; 0x42ac <__udivmodhi4>
    11b2:	80 5d       	subi	r24, 0xD0	; 208
    11b4:	8b 83       	std	Y+3, r24	; 0x03
    11b6:	c9 01       	movw	r24, r18
    11b8:	6a e0       	ldi	r22, 0x0A	; 10
    11ba:	70 e0       	ldi	r23, 0x00	; 0
    11bc:	0e 94 56 21 	call	0x42ac	; 0x42ac <__udivmodhi4>
    11c0:	cb 01       	movw	r24, r22
    11c2:	6a e0       	ldi	r22, 0x0A	; 10
    11c4:	70 e0       	ldi	r23, 0x00	; 0
    11c6:	0e 94 56 21 	call	0x42ac	; 0x42ac <__udivmodhi4>
    11ca:	80 5d       	subi	r24, 0xD0	; 208
    11cc:	8c 83       	std	Y+4, r24	; 0x04
    11ce:	c9 01       	movw	r24, r18
    11d0:	6a e0       	ldi	r22, 0x0A	; 10
    11d2:	70 e0       	ldi	r23, 0x00	; 0
    11d4:	0e 94 56 21 	call	0x42ac	; 0x42ac <__udivmodhi4>
    11d8:	80 5d       	subi	r24, 0xD0	; 208
    11da:	8d 83       	std	Y+5, r24	; 0x05
    }
    buffer[i] = '\0';
    11dc:	1e 82       	std	Y+6, r1	; 0x06
}

void usart_transmit_str(const char* data)
{
	// There's still data to go so keep sending it until it ends
	while(*data)
    11de:	44 23       	and	r20, r20
    11e0:	61 f0       	breq	.+24     	; 0x11fa <usart_transmit_int+0xa2>
    11e2:	fe 01       	movw	r30, r28
    11e4:	31 96       	adiw	r30, 0x01	; 1
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    11e6:	80 91 c0 00 	lds	r24, 0x00C0
    11ea:	85 ff       	sbrs	r24, 5
    11ec:	fc cf       	rjmp	.-8      	; 0x11e6 <usart_transmit_int+0x8e>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    11ee:	40 93 c6 00 	sts	0x00C6, r20
{
	// There's still data to go so keep sending it until it ends
	while(*data)
	{
		usart_transmit(*data);
        data++;
    11f2:	31 96       	adiw	r30, 0x01	; 1
}

void usart_transmit_str(const char* data)
{
	// There's still data to go so keep sending it until it ends
	while(*data)
    11f4:	40 81       	ld	r20, Z
    11f6:	44 23       	and	r20, r20
    11f8:	b1 f7       	brne	.-20     	; 0x11e6 <usart_transmit_int+0x8e>
        buffer[i] = ((num / n) % 10) + '0';
    }
    buffer[i] = '\0';
    usart_transmit_str(buffer);

}
    11fa:	2a 96       	adiw	r28, 0x0a	; 10
    11fc:	0f b6       	in	r0, 0x3f	; 63
    11fe:	f8 94       	cli
    1200:	de bf       	out	0x3e, r29	; 62
    1202:	0f be       	out	0x3f, r0	; 63
    1204:	cd bf       	out	0x3d, r28	; 61
    1206:	cf 91       	pop	r28
    1208:	df 91       	pop	r29
    120a:	08 95       	ret

0000120c <move_cursor>:
{
	usart_transmit_str("\x1b[2J");
}

void move_cursor(int distance, int direction) 
{
    120c:	98 2f       	mov	r25, r24
    120e:	46 2f       	mov	r20, r22
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1210:	80 91 c0 00 	lds	r24, 0x00C0
    1214:	85 ff       	sbrs	r24, 5
    1216:	fc cf       	rjmp	.-8      	; 0x1210 <move_cursor+0x4>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1218:	8b e1       	ldi	r24, 0x1B	; 27
    121a:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    121e:	80 91 c0 00 	lds	r24, 0x00C0
    1222:	85 ff       	sbrs	r24, 5
    1224:	fc cf       	rjmp	.-8      	; 0x121e <move_cursor+0x12>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1226:	8b e5       	ldi	r24, 0x5B	; 91
    1228:	80 93 c6 00 	sts	0x00C6, r24
void move_cursor(int distance, int direction) 
{
	usart_transmit('\x1b');
	usart_transmit('[');

	usart_transmit_dec(distance);
    122c:	39 2f       	mov	r19, r25
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    122e:	94 36       	cpi	r25, 0x64	; 100
    1230:	a8 f1       	brcs	.+106    	; 0x129c <move_cursor+0x90>
{
	usart_transmit_str("\x1b[2J");
}

void move_cursor(int distance, int direction) 
{
    1232:	29 2f       	mov	r18, r25
    1234:	24 56       	subi	r18, 0x64	; 100
    1236:	82 2f       	mov	r24, r18
    1238:	64 e6       	ldi	r22, 0x64	; 100
    123a:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    123e:	9c e9       	ldi	r25, 0x9C	; 156
    1240:	89 9f       	mul	r24, r25
    1242:	30 2d       	mov	r19, r0
    1244:	11 24       	eor	r1, r1
    1246:	32 0f       	add	r19, r18
    1248:	98 2f       	mov	r25, r24
    124a:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    124c:	80 91 c0 00 	lds	r24, 0x00C0
    1250:	85 ff       	sbrs	r24, 5
    1252:	fc cf       	rjmp	.-8      	; 0x124c <move_cursor+0x40>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1254:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    1258:	3a 30       	cpi	r19, 0x0A	; 10
    125a:	10 f1       	brcs	.+68     	; 0x12a0 <move_cursor+0x94>
{
	usart_transmit_str("\x1b[2J");
}

void move_cursor(int distance, int direction) 
{
    125c:	23 2f       	mov	r18, r19
    125e:	2a 50       	subi	r18, 0x0A	; 10
    1260:	82 2f       	mov	r24, r18
    1262:	6a e0       	ldi	r22, 0x0A	; 10
    1264:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    1268:	39 2f       	mov	r19, r25
    126a:	82 2f       	mov	r24, r18
    126c:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    1270:	98 2f       	mov	r25, r24
    1272:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1274:	80 91 c0 00 	lds	r24, 0x00C0
    1278:	85 ff       	sbrs	r24, 5
    127a:	fc cf       	rjmp	.-8      	; 0x1274 <move_cursor+0x68>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    127c:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1280:	80 91 c0 00 	lds	r24, 0x00C0
    1284:	85 ff       	sbrs	r24, 5
    1286:	fc cf       	rjmp	.-8      	; 0x1280 <move_cursor+0x74>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    1288:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    128a:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    128e:	80 91 c0 00 	lds	r24, 0x00C0
    1292:	85 ff       	sbrs	r24, 5
    1294:	fc cf       	rjmp	.-8      	; 0x128e <move_cursor+0x82>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1296:	40 93 c6 00 	sts	0x00C6, r20
	usart_transmit('\x1b');
	usart_transmit('[');

	usart_transmit_dec(distance);
	usart_transmit(direction);
}
    129a:	08 95       	ret
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    129c:	90 e3       	ldi	r25, 0x30	; 48
    129e:	d6 cf       	rjmp	.-84     	; 0x124c <move_cursor+0x40>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    12a0:	90 e3       	ldi	r25, 0x30	; 48
    12a2:	e8 cf       	rjmp	.-48     	; 0x1274 <move_cursor+0x68>

000012a4 <ht_scroll_limit>:
    
    usart_transmit( 'r' );
}

void ht_scroll_limit( unsigned char start, unsigned char end )
{
    12a4:	38 2f       	mov	r19, r24
    12a6:	46 2f       	mov	r20, r22
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    12a8:	80 91 c0 00 	lds	r24, 0x00C0
    12ac:	85 ff       	sbrs	r24, 5
    12ae:	fc cf       	rjmp	.-8      	; 0x12a8 <ht_scroll_limit+0x4>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    12b0:	8b e1       	ldi	r24, 0x1B	; 27
    12b2:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    12b6:	80 91 c0 00 	lds	r24, 0x00C0
    12ba:	85 ff       	sbrs	r24, 5
    12bc:	fc cf       	rjmp	.-8      	; 0x12b6 <ht_scroll_limit+0x12>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    12be:	8b e5       	ldi	r24, 0x5B	; 91
    12c0:	80 93 c6 00 	sts	0x00C6, r24
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    12c4:	34 36       	cpi	r19, 0x64	; 100
    12c6:	08 f4       	brcc	.+2      	; 0x12ca <ht_scroll_limit+0x26>
    12c8:	6c c0       	rjmp	.+216    	; 0x13a2 <ht_scroll_limit+0xfe>
    
    usart_transmit( 'r' );
}

void ht_scroll_limit( unsigned char start, unsigned char end )
{
    12ca:	23 2f       	mov	r18, r19
    12cc:	24 56       	subi	r18, 0x64	; 100
    12ce:	82 2f       	mov	r24, r18
    12d0:	64 e6       	ldi	r22, 0x64	; 100
    12d2:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    12d6:	39 2f       	mov	r19, r25
    12d8:	82 2f       	mov	r24, r18
    12da:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    12de:	98 2f       	mov	r25, r24
    12e0:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    12e2:	80 91 c0 00 	lds	r24, 0x00C0
    12e6:	85 ff       	sbrs	r24, 5
    12e8:	fc cf       	rjmp	.-8      	; 0x12e2 <ht_scroll_limit+0x3e>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    12ea:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    12ee:	3a 30       	cpi	r19, 0x0A	; 10
    12f0:	08 f4       	brcc	.+2      	; 0x12f4 <ht_scroll_limit+0x50>
    12f2:	59 c0       	rjmp	.+178    	; 0x13a6 <ht_scroll_limit+0x102>
    
    usart_transmit( 'r' );
}

void ht_scroll_limit( unsigned char start, unsigned char end )
{
    12f4:	23 2f       	mov	r18, r19
    12f6:	2a 50       	subi	r18, 0x0A	; 10
    12f8:	82 2f       	mov	r24, r18
    12fa:	6a e0       	ldi	r22, 0x0A	; 10
    12fc:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    1300:	39 2f       	mov	r19, r25
    1302:	82 2f       	mov	r24, r18
    1304:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    1308:	98 2f       	mov	r25, r24
    130a:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    130c:	80 91 c0 00 	lds	r24, 0x00C0
    1310:	85 ff       	sbrs	r24, 5
    1312:	fc cf       	rjmp	.-8      	; 0x130c <ht_scroll_limit+0x68>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1314:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1318:	80 91 c0 00 	lds	r24, 0x00C0
    131c:	85 ff       	sbrs	r24, 5
    131e:	fc cf       	rjmp	.-8      	; 0x1318 <ht_scroll_limit+0x74>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    1320:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1322:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1326:	80 91 c0 00 	lds	r24, 0x00C0
    132a:	85 ff       	sbrs	r24, 5
    132c:	fc cf       	rjmp	.-8      	; 0x1326 <ht_scroll_limit+0x82>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    132e:	8b e3       	ldi	r24, 0x3B	; 59
    1330:	80 93 c6 00 	sts	0x00C6, r24
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    1334:	44 36       	cpi	r20, 0x64	; 100
    1336:	c8 f1       	brcs	.+114    	; 0x13aa <ht_scroll_limit+0x106>
    
    usart_transmit( 'r' );
}

void ht_scroll_limit( unsigned char start, unsigned char end )
{
    1338:	24 2f       	mov	r18, r20
    133a:	24 56       	subi	r18, 0x64	; 100
    133c:	82 2f       	mov	r24, r18
    133e:	64 e6       	ldi	r22, 0x64	; 100
    1340:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    1344:	49 2f       	mov	r20, r25
    1346:	82 2f       	mov	r24, r18
    1348:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    134c:	98 2f       	mov	r25, r24
    134e:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1350:	80 91 c0 00 	lds	r24, 0x00C0
    1354:	85 ff       	sbrs	r24, 5
    1356:	fc cf       	rjmp	.-8      	; 0x1350 <ht_scroll_limit+0xac>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1358:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    135c:	4a 30       	cpi	r20, 0x0A	; 10
    135e:	38 f1       	brcs	.+78     	; 0x13ae <ht_scroll_limit+0x10a>
    
    usart_transmit( 'r' );
}

void ht_scroll_limit( unsigned char start, unsigned char end )
{
    1360:	24 2f       	mov	r18, r20
    1362:	2a 50       	subi	r18, 0x0A	; 10
    1364:	82 2f       	mov	r24, r18
    1366:	6a e0       	ldi	r22, 0x0A	; 10
    1368:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    136c:	49 2f       	mov	r20, r25
    136e:	82 2f       	mov	r24, r18
    1370:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    1374:	98 2f       	mov	r25, r24
    1376:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1378:	80 91 c0 00 	lds	r24, 0x00C0
    137c:	85 ff       	sbrs	r24, 5
    137e:	fc cf       	rjmp	.-8      	; 0x1378 <ht_scroll_limit+0xd4>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1380:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1384:	80 91 c0 00 	lds	r24, 0x00C0
    1388:	85 ff       	sbrs	r24, 5
    138a:	fc cf       	rjmp	.-8      	; 0x1384 <ht_scroll_limit+0xe0>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    138c:	40 5d       	subi	r20, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    138e:	40 93 c6 00 	sts	0x00C6, r20
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1392:	80 91 c0 00 	lds	r24, 0x00C0
    1396:	85 ff       	sbrs	r24, 5
    1398:	fc cf       	rjmp	.-8      	; 0x1392 <ht_scroll_limit+0xee>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    139a:	82 e7       	ldi	r24, 0x72	; 114
    139c:	80 93 c6 00 	sts	0x00C6, r24
    
    usart_transmit_dec( start );            // Convert start line byte
    usart_transmit( ';' );
    usart_transmit_dec( end );              // Convert end line byte
    usart_transmit( 'r' );
}
    13a0:	08 95       	ret
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    13a2:	90 e3       	ldi	r25, 0x30	; 48
    13a4:	9e cf       	rjmp	.-196    	; 0x12e2 <ht_scroll_limit+0x3e>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    13a6:	90 e3       	ldi	r25, 0x30	; 48
    13a8:	b1 cf       	rjmp	.-158    	; 0x130c <ht_scroll_limit+0x68>
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    13aa:	90 e3       	ldi	r25, 0x30	; 48
    13ac:	d1 cf       	rjmp	.-94     	; 0x1350 <ht_scroll_limit+0xac>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    13ae:	90 e3       	ldi	r25, 0x30	; 48
    13b0:	e3 cf       	rjmp	.-58     	; 0x1378 <ht_scroll_limit+0xd4>

000013b2 <cursor_goto>:
	usart_transmit_dec(distance);
	usart_transmit(direction);
}

void cursor_goto(int x, int y)
{
    13b2:	48 2f       	mov	r20, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    13b4:	80 91 c0 00 	lds	r24, 0x00C0
    13b8:	85 ff       	sbrs	r24, 5
    13ba:	fc cf       	rjmp	.-8      	; 0x13b4 <cursor_goto+0x2>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    13bc:	8b e1       	ldi	r24, 0x1B	; 27
    13be:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    13c2:	80 91 c0 00 	lds	r24, 0x00C0
    13c6:	85 ff       	sbrs	r24, 5
    13c8:	fc cf       	rjmp	.-8      	; 0x13c2 <cursor_goto+0x10>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    13ca:	8b e5       	ldi	r24, 0x5B	; 91
    13cc:	80 93 c6 00 	sts	0x00C6, r24
void cursor_goto(int x, int y)
{
	usart_transmit('\x1b');
	usart_transmit('[');

	usart_transmit_dec(y);
    13d0:	36 2f       	mov	r19, r22
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    13d2:	64 36       	cpi	r22, 0x64	; 100
    13d4:	08 f4       	brcc	.+2      	; 0x13d8 <cursor_goto+0x26>
    13d6:	6f c0       	rjmp	.+222    	; 0x14b6 <cursor_goto+0x104>
	usart_transmit_dec(distance);
	usart_transmit(direction);
}

void cursor_goto(int x, int y)
{
    13d8:	26 2f       	mov	r18, r22
    13da:	24 56       	subi	r18, 0x64	; 100
    13dc:	82 2f       	mov	r24, r18
    13de:	64 e6       	ldi	r22, 0x64	; 100
    13e0:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    13e4:	9c e9       	ldi	r25, 0x9C	; 156
    13e6:	89 9f       	mul	r24, r25
    13e8:	30 2d       	mov	r19, r0
    13ea:	11 24       	eor	r1, r1
    13ec:	32 0f       	add	r19, r18
    13ee:	98 2f       	mov	r25, r24
    13f0:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    13f2:	80 91 c0 00 	lds	r24, 0x00C0
    13f6:	85 ff       	sbrs	r24, 5
    13f8:	fc cf       	rjmp	.-8      	; 0x13f2 <cursor_goto+0x40>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    13fa:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    13fe:	3a 30       	cpi	r19, 0x0A	; 10
    1400:	08 f4       	brcc	.+2      	; 0x1404 <cursor_goto+0x52>
    1402:	5b c0       	rjmp	.+182    	; 0x14ba <cursor_goto+0x108>
	usart_transmit_dec(distance);
	usart_transmit(direction);
}

void cursor_goto(int x, int y)
{
    1404:	23 2f       	mov	r18, r19
    1406:	2a 50       	subi	r18, 0x0A	; 10
    1408:	82 2f       	mov	r24, r18
    140a:	6a e0       	ldi	r22, 0x0A	; 10
    140c:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    1410:	39 2f       	mov	r19, r25
    1412:	82 2f       	mov	r24, r18
    1414:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    1418:	98 2f       	mov	r25, r24
    141a:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    141c:	80 91 c0 00 	lds	r24, 0x00C0
    1420:	85 ff       	sbrs	r24, 5
    1422:	fc cf       	rjmp	.-8      	; 0x141c <cursor_goto+0x6a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1424:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1428:	80 91 c0 00 	lds	r24, 0x00C0
    142c:	85 ff       	sbrs	r24, 5
    142e:	fc cf       	rjmp	.-8      	; 0x1428 <cursor_goto+0x76>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    1430:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1432:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1436:	80 91 c0 00 	lds	r24, 0x00C0
    143a:	85 ff       	sbrs	r24, 5
    143c:	fc cf       	rjmp	.-8      	; 0x1436 <cursor_goto+0x84>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    143e:	8b e3       	ldi	r24, 0x3B	; 59
    1440:	80 93 c6 00 	sts	0x00C6, r24
	usart_transmit('\x1b');
	usart_transmit('[');

	usart_transmit_dec(y);
	usart_transmit(';');
	usart_transmit_dec(x);
    1444:	34 2f       	mov	r19, r20
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    1446:	44 36       	cpi	r20, 0x64	; 100
    1448:	d0 f1       	brcs	.+116    	; 0x14be <cursor_goto+0x10c>
	usart_transmit_dec(distance);
	usart_transmit(direction);
}

void cursor_goto(int x, int y)
{
    144a:	24 2f       	mov	r18, r20
    144c:	24 56       	subi	r18, 0x64	; 100
    144e:	82 2f       	mov	r24, r18
    1450:	64 e6       	ldi	r22, 0x64	; 100
    1452:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    1456:	9c e9       	ldi	r25, 0x9C	; 156
    1458:	89 9f       	mul	r24, r25
    145a:	30 2d       	mov	r19, r0
    145c:	11 24       	eor	r1, r1
    145e:	32 0f       	add	r19, r18
    1460:	98 2f       	mov	r25, r24
    1462:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1464:	80 91 c0 00 	lds	r24, 0x00C0
    1468:	85 ff       	sbrs	r24, 5
    146a:	fc cf       	rjmp	.-8      	; 0x1464 <cursor_goto+0xb2>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    146c:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    1470:	3a 30       	cpi	r19, 0x0A	; 10
    1472:	38 f1       	brcs	.+78     	; 0x14c2 <cursor_goto+0x110>
	usart_transmit_dec(distance);
	usart_transmit(direction);
}

void cursor_goto(int x, int y)
{
    1474:	23 2f       	mov	r18, r19
    1476:	2a 50       	subi	r18, 0x0A	; 10
    1478:	82 2f       	mov	r24, r18
    147a:	6a e0       	ldi	r22, 0x0A	; 10
    147c:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    1480:	39 2f       	mov	r19, r25
    1482:	82 2f       	mov	r24, r18
    1484:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    1488:	98 2f       	mov	r25, r24
    148a:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    148c:	80 91 c0 00 	lds	r24, 0x00C0
    1490:	85 ff       	sbrs	r24, 5
    1492:	fc cf       	rjmp	.-8      	; 0x148c <cursor_goto+0xda>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1494:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1498:	80 91 c0 00 	lds	r24, 0x00C0
    149c:	85 ff       	sbrs	r24, 5
    149e:	fc cf       	rjmp	.-8      	; 0x1498 <cursor_goto+0xe6>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    14a0:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    14a2:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    14a6:	80 91 c0 00 	lds	r24, 0x00C0
    14aa:	85 ff       	sbrs	r24, 5
    14ac:	fc cf       	rjmp	.-8      	; 0x14a6 <cursor_goto+0xf4>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    14ae:	88 e4       	ldi	r24, 0x48	; 72
    14b0:	80 93 c6 00 	sts	0x00C6, r24

	usart_transmit_dec(y);
	usart_transmit(';');
	usart_transmit_dec(x);
	usart_transmit('H');
}
    14b4:	08 95       	ret
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    14b6:	90 e3       	ldi	r25, 0x30	; 48
    14b8:	9c cf       	rjmp	.-200    	; 0x13f2 <cursor_goto+0x40>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    14ba:	90 e3       	ldi	r25, 0x30	; 48
    14bc:	af cf       	rjmp	.-162    	; 0x141c <cursor_goto+0x6a>
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    14be:	90 e3       	ldi	r25, 0x30	; 48
    14c0:	d1 cf       	rjmp	.-94     	; 0x1464 <cursor_goto+0xb2>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    14c2:	90 e3       	ldi	r25, 0x30	; 48
    14c4:	e3 cf       	rjmp	.-58     	; 0x148c <cursor_goto+0xda>

000014c6 <draw_horizontal_line>:
   
    usart_transmit( 'i' );
}

void draw_horizontal_line(int y, int startx, int endx) 
{
    14c6:	98 2f       	mov	r25, r24
    14c8:	fb 01       	movw	r30, r22
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    14ca:	80 91 c0 00 	lds	r24, 0x00C0
    14ce:	85 ff       	sbrs	r24, 5
    14d0:	fc cf       	rjmp	.-8      	; 0x14ca <draw_horizontal_line+0x4>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    14d2:	8b e1       	ldi	r24, 0x1B	; 27
    14d4:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    14d8:	80 91 c0 00 	lds	r24, 0x00C0
    14dc:	85 ff       	sbrs	r24, 5
    14de:	fc cf       	rjmp	.-8      	; 0x14d8 <draw_horizontal_line+0x12>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    14e0:	8b e5       	ldi	r24, 0x5B	; 91
    14e2:	80 93 c6 00 	sts	0x00C6, r24
void cursor_goto(int x, int y)
{
	usart_transmit('\x1b');
	usart_transmit('[');

	usart_transmit_dec(y);
    14e6:	39 2f       	mov	r19, r25
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    14e8:	94 36       	cpi	r25, 0x64	; 100
    14ea:	08 f4       	brcc	.+2      	; 0x14ee <draw_horizontal_line+0x28>
    14ec:	b9 c0       	rjmp	.+370    	; 0x1660 <draw_horizontal_line+0x19a>
   
    usart_transmit( 'i' );
}

void draw_horizontal_line(int y, int startx, int endx) 
{
    14ee:	29 2f       	mov	r18, r25
    14f0:	24 56       	subi	r18, 0x64	; 100
    14f2:	82 2f       	mov	r24, r18
    14f4:	64 e6       	ldi	r22, 0x64	; 100
    14f6:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    14fa:	9c e9       	ldi	r25, 0x9C	; 156
    14fc:	89 9f       	mul	r24, r25
    14fe:	30 2d       	mov	r19, r0
    1500:	11 24       	eor	r1, r1
    1502:	32 0f       	add	r19, r18
    1504:	98 2f       	mov	r25, r24
    1506:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1508:	80 91 c0 00 	lds	r24, 0x00C0
    150c:	85 ff       	sbrs	r24, 5
    150e:	fc cf       	rjmp	.-8      	; 0x1508 <draw_horizontal_line+0x42>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1510:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    1514:	3a 30       	cpi	r19, 0x0A	; 10
    1516:	08 f4       	brcc	.+2      	; 0x151a <draw_horizontal_line+0x54>
    1518:	a5 c0       	rjmp	.+330    	; 0x1664 <draw_horizontal_line+0x19e>
   
    usart_transmit( 'i' );
}

void draw_horizontal_line(int y, int startx, int endx) 
{
    151a:	23 2f       	mov	r18, r19
    151c:	2a 50       	subi	r18, 0x0A	; 10
    151e:	82 2f       	mov	r24, r18
    1520:	6a e0       	ldi	r22, 0x0A	; 10
    1522:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    1526:	39 2f       	mov	r19, r25
    1528:	82 2f       	mov	r24, r18
    152a:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    152e:	98 2f       	mov	r25, r24
    1530:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1532:	80 91 c0 00 	lds	r24, 0x00C0
    1536:	85 ff       	sbrs	r24, 5
    1538:	fc cf       	rjmp	.-8      	; 0x1532 <draw_horizontal_line+0x6c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    153a:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    153e:	80 91 c0 00 	lds	r24, 0x00C0
    1542:	85 ff       	sbrs	r24, 5
    1544:	fc cf       	rjmp	.-8      	; 0x153e <draw_horizontal_line+0x78>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    1546:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1548:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    154c:	80 91 c0 00 	lds	r24, 0x00C0
    1550:	85 ff       	sbrs	r24, 5
    1552:	fc cf       	rjmp	.-8      	; 0x154c <draw_horizontal_line+0x86>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1554:	8b e3       	ldi	r24, 0x3B	; 59
    1556:	80 93 c6 00 	sts	0x00C6, r24
	usart_transmit('\x1b');
	usart_transmit('[');

	usart_transmit_dec(y);
	usart_transmit(';');
	usart_transmit_dec(x);
    155a:	3e 2f       	mov	r19, r30
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    155c:	e4 36       	cpi	r30, 0x64	; 100
    155e:	08 f4       	brcc	.+2      	; 0x1562 <draw_horizontal_line+0x9c>
    1560:	83 c0       	rjmp	.+262    	; 0x1668 <draw_horizontal_line+0x1a2>
   
    usart_transmit( 'i' );
}

void draw_horizontal_line(int y, int startx, int endx) 
{
    1562:	2e 2f       	mov	r18, r30
    1564:	24 56       	subi	r18, 0x64	; 100
    1566:	82 2f       	mov	r24, r18
    1568:	64 e6       	ldi	r22, 0x64	; 100
    156a:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    156e:	9c e9       	ldi	r25, 0x9C	; 156
    1570:	89 9f       	mul	r24, r25
    1572:	30 2d       	mov	r19, r0
    1574:	11 24       	eor	r1, r1
    1576:	32 0f       	add	r19, r18
    1578:	98 2f       	mov	r25, r24
    157a:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    157c:	80 91 c0 00 	lds	r24, 0x00C0
    1580:	85 ff       	sbrs	r24, 5
    1582:	fc cf       	rjmp	.-8      	; 0x157c <draw_horizontal_line+0xb6>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1584:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    1588:	3a 30       	cpi	r19, 0x0A	; 10
    158a:	08 f4       	brcc	.+2      	; 0x158e <draw_horizontal_line+0xc8>
    158c:	6f c0       	rjmp	.+222    	; 0x166c <draw_horizontal_line+0x1a6>
   
    usart_transmit( 'i' );
}

void draw_horizontal_line(int y, int startx, int endx) 
{
    158e:	23 2f       	mov	r18, r19
    1590:	2a 50       	subi	r18, 0x0A	; 10
    1592:	82 2f       	mov	r24, r18
    1594:	6a e0       	ldi	r22, 0x0A	; 10
    1596:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    159a:	39 2f       	mov	r19, r25
    159c:	82 2f       	mov	r24, r18
    159e:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    15a2:	98 2f       	mov	r25, r24
    15a4:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    15a6:	80 91 c0 00 	lds	r24, 0x00C0
    15aa:	85 ff       	sbrs	r24, 5
    15ac:	fc cf       	rjmp	.-8      	; 0x15a6 <draw_horizontal_line+0xe0>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    15ae:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    15b2:	80 91 c0 00 	lds	r24, 0x00C0
    15b6:	85 ff       	sbrs	r24, 5
    15b8:	fc cf       	rjmp	.-8      	; 0x15b2 <draw_horizontal_line+0xec>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    15ba:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    15bc:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    15c0:	80 91 c0 00 	lds	r24, 0x00C0
    15c4:	85 ff       	sbrs	r24, 5
    15c6:	fc cf       	rjmp	.-8      	; 0x15c0 <draw_horizontal_line+0xfa>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    15c8:	88 e4       	ldi	r24, 0x48	; 72
    15ca:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    15ce:	80 91 c0 00 	lds	r24, 0x00C0
    15d2:	85 ff       	sbrs	r24, 5
    15d4:	fc cf       	rjmp	.-8      	; 0x15ce <draw_horizontal_line+0x108>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    15d6:	8b e1       	ldi	r24, 0x1B	; 27
    15d8:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    15dc:	80 91 c0 00 	lds	r24, 0x00C0
    15e0:	85 ff       	sbrs	r24, 5
    15e2:	fc cf       	rjmp	.-8      	; 0x15dc <draw_horizontal_line+0x116>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    15e4:	8b e5       	ldi	r24, 0x5B	; 91
    15e6:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    15ea:	80 91 c0 00 	lds	r24, 0x00C0
    15ee:	85 ff       	sbrs	r24, 5
    15f0:	fc cf       	rjmp	.-8      	; 0x15ea <draw_horizontal_line+0x124>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    15f2:	87 e3       	ldi	r24, 0x37	; 55
    15f4:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    15f8:	80 91 c0 00 	lds	r24, 0x00C0
    15fc:	85 ff       	sbrs	r24, 5
    15fe:	fc cf       	rjmp	.-8      	; 0x15f8 <draw_horizontal_line+0x132>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1600:	8d e6       	ldi	r24, 0x6D	; 109
    1602:	80 93 c6 00 	sts	0x00C6, r24
void draw_horizontal_line(int y, int startx, int endx) 
{
	int i;
	cursor_goto(startx, y);
	ht_set_display_attribute_mode(MODE_REVERSED);
	for(i=startx; i <= endx; i++) 
    1606:	4e 17       	cp	r20, r30
    1608:	5f 07       	cpc	r21, r31
    160a:	6c f0       	brlt	.+26     	; 0x1626 <draw_horizontal_line+0x160>
    160c:	bf 01       	movw	r22, r30
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    160e:	90 e2       	ldi	r25, 0x20	; 32
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1610:	80 91 c0 00 	lds	r24, 0x00C0
    1614:	85 ff       	sbrs	r24, 5
    1616:	fc cf       	rjmp	.-8      	; 0x1610 <draw_horizontal_line+0x14a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1618:	90 93 c6 00 	sts	0x00C6, r25
void draw_horizontal_line(int y, int startx, int endx) 
{
	int i;
	cursor_goto(startx, y);
	ht_set_display_attribute_mode(MODE_REVERSED);
	for(i=startx; i <= endx; i++) 
    161c:	6f 5f       	subi	r22, 0xFF	; 255
    161e:	7f 4f       	sbci	r23, 0xFF	; 255
    1620:	46 17       	cp	r20, r22
    1622:	57 07       	cpc	r21, r23
    1624:	ac f7       	brge	.-22     	; 0x1610 <draw_horizontal_line+0x14a>
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1626:	80 91 c0 00 	lds	r24, 0x00C0
    162a:	85 ff       	sbrs	r24, 5
    162c:	fc cf       	rjmp	.-8      	; 0x1626 <draw_horizontal_line+0x160>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    162e:	8b e1       	ldi	r24, 0x1B	; 27
    1630:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1634:	80 91 c0 00 	lds	r24, 0x00C0
    1638:	85 ff       	sbrs	r24, 5
    163a:	fc cf       	rjmp	.-8      	; 0x1634 <draw_horizontal_line+0x16e>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    163c:	8b e5       	ldi	r24, 0x5B	; 91
    163e:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1642:	80 91 c0 00 	lds	r24, 0x00C0
    1646:	85 ff       	sbrs	r24, 5
    1648:	fc cf       	rjmp	.-8      	; 0x1642 <draw_horizontal_line+0x17c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    164a:	80 e3       	ldi	r24, 0x30	; 48
    164c:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1650:	80 91 c0 00 	lds	r24, 0x00C0
    1654:	85 ff       	sbrs	r24, 5
    1656:	fc cf       	rjmp	.-8      	; 0x1650 <draw_horizontal_line+0x18a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1658:	8d e6       	ldi	r24, 0x6D	; 109
    165a:	80 93 c6 00 	sts	0x00C6, r24
	for(i=startx; i <= endx; i++) 
	{
		usart_transmit(' ');
	}
	ht_set_display_attribute_mode(MODE_NONE);
}
    165e:	08 95       	ret
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    1660:	90 e3       	ldi	r25, 0x30	; 48
    1662:	52 cf       	rjmp	.-348    	; 0x1508 <draw_horizontal_line+0x42>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    1664:	90 e3       	ldi	r25, 0x30	; 48
    1666:	65 cf       	rjmp	.-310    	; 0x1532 <draw_horizontal_line+0x6c>
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    1668:	90 e3       	ldi	r25, 0x30	; 48
    166a:	88 cf       	rjmp	.-240    	; 0x157c <draw_horizontal_line+0xb6>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    166c:	90 e3       	ldi	r25, 0x30	; 48
    166e:	9b cf       	rjmp	.-202    	; 0x15a6 <draw_horizontal_line+0xe0>

00001670 <draw_vertical_line>:
	}
	ht_set_display_attribute_mode(MODE_NONE);
}

void draw_vertical_line(int x, int starty, int endy) 
{
    1670:	a8 2f       	mov	r26, r24
    1672:	fb 01       	movw	r30, r22
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1674:	80 91 c0 00 	lds	r24, 0x00C0
    1678:	85 ff       	sbrs	r24, 5
    167a:	fc cf       	rjmp	.-8      	; 0x1674 <draw_vertical_line+0x4>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    167c:	8b e1       	ldi	r24, 0x1B	; 27
    167e:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1682:	80 91 c0 00 	lds	r24, 0x00C0
    1686:	85 ff       	sbrs	r24, 5
    1688:	fc cf       	rjmp	.-8      	; 0x1682 <draw_vertical_line+0x12>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    168a:	8b e5       	ldi	r24, 0x5B	; 91
    168c:	80 93 c6 00 	sts	0x00C6, r24
void cursor_goto(int x, int y)
{
	usart_transmit('\x1b');
	usart_transmit('[');

	usart_transmit_dec(y);
    1690:	3e 2f       	mov	r19, r30
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    1692:	e4 36       	cpi	r30, 0x64	; 100
    1694:	08 f4       	brcc	.+2      	; 0x1698 <draw_vertical_line+0x28>
    1696:	10 c1       	rjmp	.+544    	; 0x18b8 <draw_vertical_line+0x248>
	}
	ht_set_display_attribute_mode(MODE_NONE);
}

void draw_vertical_line(int x, int starty, int endy) 
{
    1698:	2e 2f       	mov	r18, r30
    169a:	24 56       	subi	r18, 0x64	; 100
    169c:	82 2f       	mov	r24, r18
    169e:	64 e6       	ldi	r22, 0x64	; 100
    16a0:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    16a4:	9c e9       	ldi	r25, 0x9C	; 156
    16a6:	89 9f       	mul	r24, r25
    16a8:	30 2d       	mov	r19, r0
    16aa:	11 24       	eor	r1, r1
    16ac:	32 0f       	add	r19, r18
    16ae:	98 2f       	mov	r25, r24
    16b0:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    16b2:	80 91 c0 00 	lds	r24, 0x00C0
    16b6:	85 ff       	sbrs	r24, 5
    16b8:	fc cf       	rjmp	.-8      	; 0x16b2 <draw_vertical_line+0x42>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    16ba:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    16be:	3a 30       	cpi	r19, 0x0A	; 10
    16c0:	08 f4       	brcc	.+2      	; 0x16c4 <draw_vertical_line+0x54>
    16c2:	fc c0       	rjmp	.+504    	; 0x18bc <draw_vertical_line+0x24c>
	}
	ht_set_display_attribute_mode(MODE_NONE);
}

void draw_vertical_line(int x, int starty, int endy) 
{
    16c4:	23 2f       	mov	r18, r19
    16c6:	2a 50       	subi	r18, 0x0A	; 10
    16c8:	82 2f       	mov	r24, r18
    16ca:	6a e0       	ldi	r22, 0x0A	; 10
    16cc:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    16d0:	39 2f       	mov	r19, r25
    16d2:	82 2f       	mov	r24, r18
    16d4:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    16d8:	98 2f       	mov	r25, r24
    16da:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    16dc:	80 91 c0 00 	lds	r24, 0x00C0
    16e0:	85 ff       	sbrs	r24, 5
    16e2:	fc cf       	rjmp	.-8      	; 0x16dc <draw_vertical_line+0x6c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    16e4:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    16e8:	80 91 c0 00 	lds	r24, 0x00C0
    16ec:	85 ff       	sbrs	r24, 5
    16ee:	fc cf       	rjmp	.-8      	; 0x16e8 <draw_vertical_line+0x78>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    16f0:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    16f2:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    16f6:	80 91 c0 00 	lds	r24, 0x00C0
    16fa:	85 ff       	sbrs	r24, 5
    16fc:	fc cf       	rjmp	.-8      	; 0x16f6 <draw_vertical_line+0x86>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    16fe:	8b e3       	ldi	r24, 0x3B	; 59
    1700:	80 93 c6 00 	sts	0x00C6, r24
	usart_transmit('\x1b');
	usart_transmit('[');

	usart_transmit_dec(y);
	usart_transmit(';');
	usart_transmit_dec(x);
    1704:	3a 2f       	mov	r19, r26
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    1706:	a4 36       	cpi	r26, 0x64	; 100
    1708:	08 f4       	brcc	.+2      	; 0x170c <draw_vertical_line+0x9c>
    170a:	da c0       	rjmp	.+436    	; 0x18c0 <draw_vertical_line+0x250>
	}
	ht_set_display_attribute_mode(MODE_NONE);
}

void draw_vertical_line(int x, int starty, int endy) 
{
    170c:	2a 2f       	mov	r18, r26
    170e:	24 56       	subi	r18, 0x64	; 100
    1710:	82 2f       	mov	r24, r18
    1712:	64 e6       	ldi	r22, 0x64	; 100
    1714:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    1718:	9c e9       	ldi	r25, 0x9C	; 156
    171a:	89 9f       	mul	r24, r25
    171c:	30 2d       	mov	r19, r0
    171e:	11 24       	eor	r1, r1
    1720:	32 0f       	add	r19, r18
    1722:	98 2f       	mov	r25, r24
    1724:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1726:	80 91 c0 00 	lds	r24, 0x00C0
    172a:	85 ff       	sbrs	r24, 5
    172c:	fc cf       	rjmp	.-8      	; 0x1726 <draw_vertical_line+0xb6>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    172e:	90 93 c6 00 	sts	0x00C6, r25
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    1732:	3a 30       	cpi	r19, 0x0A	; 10
    1734:	08 f4       	brcc	.+2      	; 0x1738 <draw_vertical_line+0xc8>
    1736:	c6 c0       	rjmp	.+396    	; 0x18c4 <draw_vertical_line+0x254>
	}
	ht_set_display_attribute_mode(MODE_NONE);
}

void draw_vertical_line(int x, int starty, int endy) 
{
    1738:	23 2f       	mov	r18, r19
    173a:	2a 50       	subi	r18, 0x0A	; 10
    173c:	82 2f       	mov	r24, r18
    173e:	6a e0       	ldi	r22, 0x0A	; 10
    1740:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    1744:	39 2f       	mov	r19, r25
    1746:	82 2f       	mov	r24, r18
    1748:	0e 94 4a 21 	call	0x4294	; 0x4294 <__udivmodqi4>
    174c:	98 2f       	mov	r25, r24
    174e:	9f 5c       	subi	r25, 0xCF	; 207
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1750:	80 91 c0 00 	lds	r24, 0x00C0
    1754:	85 ff       	sbrs	r24, 5
    1756:	fc cf       	rjmp	.-8      	; 0x1750 <draw_vertical_line+0xe0>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1758:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    175c:	80 91 c0 00 	lds	r24, 0x00C0
    1760:	85 ff       	sbrs	r24, 5
    1762:	fc cf       	rjmp	.-8      	; 0x175c <draw_vertical_line+0xec>
        value -= 10;
    }
    
    usart_transmit( digit );                  // Send second digit
    
    usart_transmit( '0' + value );            // Send third digit
    1764:	30 5d       	subi	r19, 0xD0	; 208
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1766:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    176a:	80 91 c0 00 	lds	r24, 0x00C0
    176e:	85 ff       	sbrs	r24, 5
    1770:	fc cf       	rjmp	.-8      	; 0x176a <draw_vertical_line+0xfa>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1772:	88 e4       	ldi	r24, 0x48	; 72
    1774:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1778:	80 91 c0 00 	lds	r24, 0x00C0
    177c:	85 ff       	sbrs	r24, 5
    177e:	fc cf       	rjmp	.-8      	; 0x1778 <draw_vertical_line+0x108>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1780:	8b e1       	ldi	r24, 0x1B	; 27
    1782:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1786:	80 91 c0 00 	lds	r24, 0x00C0
    178a:	85 ff       	sbrs	r24, 5
    178c:	fc cf       	rjmp	.-8      	; 0x1786 <draw_vertical_line+0x116>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    178e:	8b e5       	ldi	r24, 0x5B	; 91
    1790:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1794:	80 91 c0 00 	lds	r24, 0x00C0
    1798:	85 ff       	sbrs	r24, 5
    179a:	fc cf       	rjmp	.-8      	; 0x1794 <draw_vertical_line+0x124>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    179c:	87 e3       	ldi	r24, 0x37	; 55
    179e:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    17a2:	80 91 c0 00 	lds	r24, 0x00C0
    17a6:	85 ff       	sbrs	r24, 5
    17a8:	fc cf       	rjmp	.-8      	; 0x17a2 <draw_vertical_line+0x132>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    17aa:	8d e6       	ldi	r24, 0x6D	; 109
    17ac:	80 93 c6 00 	sts	0x00C6, r24
void draw_vertical_line(int x, int starty, int endy) 
{
	int i;
	cursor_goto(x, starty);
	ht_set_display_attribute_mode(MODE_REVERSED);
	for(i=starty; i < endy; i++) 
    17b0:	e4 17       	cp	r30, r20
    17b2:	f5 07       	cpc	r31, r21
    17b4:	0c f0       	brlt	.+2      	; 0x17b8 <draw_vertical_line+0x148>
    17b6:	5c c0       	rjmp	.+184    	; 0x1870 <draw_vertical_line+0x200>
    17b8:	bf 01       	movw	r22, r30
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    17ba:	b0 e2       	ldi	r27, 0x20	; 32
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    17bc:	eb e1       	ldi	r30, 0x1B	; 27
    17be:	2b e5       	ldi	r18, 0x5B	; 91
    17c0:	90 e3       	ldi	r25, 0x30	; 48
    17c2:	31 e3       	ldi	r19, 0x31	; 49
    17c4:	f2 e4       	ldi	r31, 0x42	; 66
    17c6:	a4 e4       	ldi	r26, 0x44	; 68
    17c8:	80 91 c0 00 	lds	r24, 0x00C0
    17cc:	85 ff       	sbrs	r24, 5
    17ce:	fc cf       	rjmp	.-8      	; 0x17c8 <draw_vertical_line+0x158>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    17d0:	b0 93 c6 00 	sts	0x00C6, r27
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    17d4:	80 91 c0 00 	lds	r24, 0x00C0
    17d8:	85 ff       	sbrs	r24, 5
    17da:	fc cf       	rjmp	.-8      	; 0x17d4 <draw_vertical_line+0x164>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    17dc:	e0 93 c6 00 	sts	0x00C6, r30
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    17e0:	80 91 c0 00 	lds	r24, 0x00C0
    17e4:	85 ff       	sbrs	r24, 5
    17e6:	fc cf       	rjmp	.-8      	; 0x17e0 <draw_vertical_line+0x170>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    17e8:	20 93 c6 00 	sts	0x00C6, r18
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    17ec:	80 91 c0 00 	lds	r24, 0x00C0
    17f0:	85 ff       	sbrs	r24, 5
    17f2:	fc cf       	rjmp	.-8      	; 0x17ec <draw_vertical_line+0x17c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    17f4:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    17f8:	80 91 c0 00 	lds	r24, 0x00C0
    17fc:	85 ff       	sbrs	r24, 5
    17fe:	fc cf       	rjmp	.-8      	; 0x17f8 <draw_vertical_line+0x188>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1800:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1804:	80 91 c0 00 	lds	r24, 0x00C0
    1808:	85 ff       	sbrs	r24, 5
    180a:	fc cf       	rjmp	.-8      	; 0x1804 <draw_vertical_line+0x194>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    180c:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1810:	80 91 c0 00 	lds	r24, 0x00C0
    1814:	85 ff       	sbrs	r24, 5
    1816:	fc cf       	rjmp	.-8      	; 0x1810 <draw_vertical_line+0x1a0>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1818:	f0 93 c6 00 	sts	0x00C6, r31
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    181c:	80 91 c0 00 	lds	r24, 0x00C0
    1820:	85 ff       	sbrs	r24, 5
    1822:	fc cf       	rjmp	.-8      	; 0x181c <draw_vertical_line+0x1ac>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1824:	e0 93 c6 00 	sts	0x00C6, r30
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1828:	80 91 c0 00 	lds	r24, 0x00C0
    182c:	85 ff       	sbrs	r24, 5
    182e:	fc cf       	rjmp	.-8      	; 0x1828 <draw_vertical_line+0x1b8>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1830:	20 93 c6 00 	sts	0x00C6, r18
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1834:	80 91 c0 00 	lds	r24, 0x00C0
    1838:	85 ff       	sbrs	r24, 5
    183a:	fc cf       	rjmp	.-8      	; 0x1834 <draw_vertical_line+0x1c4>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    183c:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1840:	80 91 c0 00 	lds	r24, 0x00C0
    1844:	85 ff       	sbrs	r24, 5
    1846:	fc cf       	rjmp	.-8      	; 0x1840 <draw_vertical_line+0x1d0>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1848:	90 93 c6 00 	sts	0x00C6, r25
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    184c:	80 91 c0 00 	lds	r24, 0x00C0
    1850:	85 ff       	sbrs	r24, 5
    1852:	fc cf       	rjmp	.-8      	; 0x184c <draw_vertical_line+0x1dc>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1854:	30 93 c6 00 	sts	0x00C6, r19
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1858:	80 91 c0 00 	lds	r24, 0x00C0
    185c:	85 ff       	sbrs	r24, 5
    185e:	fc cf       	rjmp	.-8      	; 0x1858 <draw_vertical_line+0x1e8>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1860:	a0 93 c6 00 	sts	0x00C6, r26
void draw_vertical_line(int x, int starty, int endy) 
{
	int i;
	cursor_goto(x, starty);
	ht_set_display_attribute_mode(MODE_REVERSED);
	for(i=starty; i < endy; i++) 
    1864:	6f 5f       	subi	r22, 0xFF	; 255
    1866:	7f 4f       	sbci	r23, 0xFF	; 255
    1868:	64 17       	cp	r22, r20
    186a:	75 07       	cpc	r23, r21
    186c:	0c f4       	brge	.+2      	; 0x1870 <draw_vertical_line+0x200>
    186e:	ac cf       	rjmp	.-168    	; 0x17c8 <draw_vertical_line+0x158>
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    1870:	80 91 c0 00 	lds	r24, 0x00C0
    1874:	85 ff       	sbrs	r24, 5
    1876:	fc cf       	rjmp	.-8      	; 0x1870 <draw_vertical_line+0x200>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1878:	80 e2       	ldi	r24, 0x20	; 32
    187a:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    187e:	80 91 c0 00 	lds	r24, 0x00C0
    1882:	85 ff       	sbrs	r24, 5
    1884:	fc cf       	rjmp	.-8      	; 0x187e <draw_vertical_line+0x20e>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1886:	8b e1       	ldi	r24, 0x1B	; 27
    1888:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    188c:	80 91 c0 00 	lds	r24, 0x00C0
    1890:	85 ff       	sbrs	r24, 5
    1892:	fc cf       	rjmp	.-8      	; 0x188c <draw_vertical_line+0x21c>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    1894:	8b e5       	ldi	r24, 0x5B	; 91
    1896:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    189a:	80 91 c0 00 	lds	r24, 0x00C0
    189e:	85 ff       	sbrs	r24, 5
    18a0:	fc cf       	rjmp	.-8      	; 0x189a <draw_vertical_line+0x22a>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    18a2:	80 e3       	ldi	r24, 0x30	; 48
    18a4:	80 93 c6 00 	sts	0x00C6, r24
}

void usart_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)))
    18a8:	80 91 c0 00 	lds	r24, 0x00C0
    18ac:	85 ff       	sbrs	r24, 5
    18ae:	fc cf       	rjmp	.-8      	; 0x18a8 <draw_vertical_line+0x238>
	{
	}
	/* Put data into buffer, sends the data */
	UDR0 = data;
    18b0:	8d e6       	ldi	r24, 0x6D	; 109
    18b2:	80 93 c6 00 	sts	0x00C6, r24
		move_cursor(1,MOVE_DOWN);
		move_cursor(1,MOVE_LEFT);
	}
	usart_transmit(' ');
	ht_set_display_attribute_mode(MODE_NONE);
}
    18b6:	08 95       	ret
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    18b8:	90 e3       	ldi	r25, 0x30	; 48
    18ba:	fb ce       	rjmp	.-522    	; 0x16b2 <draw_vertical_line+0x42>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    18bc:	90 e3       	ldi	r25, 0x30	; 48
    18be:	0e cf       	rjmp	.-484    	; 0x16dc <draw_vertical_line+0x6c>
void usart_transmit_dec( unsigned char value )
{
    unsigned char digit;
    
    digit = '0';
    while( value >= 100 )                // Still larger than 100 ?
    18c0:	90 e3       	ldi	r25, 0x30	; 48
    18c2:	31 cf       	rjmp	.-414    	; 0x1726 <draw_vertical_line+0xb6>
    }
    
    usart_transmit( digit );                  // Send first digit
    
    digit = '0';
    while( value >= 10 )                 // Still larger than 10 ?
    18c4:	90 e3       	ldi	r25, 0x30	; 48
    18c6:	44 cf       	rjmp	.-376    	; 0x1750 <draw_vertical_line+0xe0>

000018c8 <ymodem_send>:

   return (crc);
}
// ******************************************************************************************************
uint8_t ymodem_send(uint8_t(*buffer_func)(unsigned char*, uint16_t), char * filename, uint32_t fileSize) 
{
    18c8:	2f 92       	push	r2
    18ca:	3f 92       	push	r3
    18cc:	4f 92       	push	r4
    18ce:	5f 92       	push	r5
    18d0:	6f 92       	push	r6
    18d2:	7f 92       	push	r7
    18d4:	8f 92       	push	r8
    18d6:	9f 92       	push	r9
    18d8:	af 92       	push	r10
    18da:	bf 92       	push	r11
    18dc:	cf 92       	push	r12
    18de:	df 92       	push	r13
    18e0:	ef 92       	push	r14
    18e2:	ff 92       	push	r15
    18e4:	0f 93       	push	r16
    18e6:	1f 93       	push	r17
    18e8:	df 93       	push	r29
    18ea:	cf 93       	push	r28
    18ec:	cd b7       	in	r28, 0x3d	; 61
    18ee:	de b7       	in	r29, 0x3e	; 62
    18f0:	2b 97       	sbiw	r28, 0x0b	; 11
    18f2:	0f b6       	in	r0, 0x3f	; 63
    18f4:	f8 94       	cli
    18f6:	de bf       	out	0x3e, r29	; 62
    18f8:	0f be       	out	0x3f, r0	; 63
    18fa:	cd bf       	out	0x3d, r28	; 61
    18fc:	3c 01       	movw	r6, r24
    18fe:	8b 01       	movw	r16, r22
    1900:	19 01       	movw	r2, r18
    1902:	2a 01       	movw	r4, r20
  uint8_t packetNum = 1;
  ymodemSentPackets = 0;
    1904:	10 92 41 01 	sts	0x0141, r1
    1908:	10 92 40 01 	sts	0x0140, r1
  uint16_t bufferPos = 3;
  uint32_t bytesToSend = fileSize;

  // Wait for the starting 'C' character
  while(c != 'C') {
    c = usart_receive();
    190c:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  uint8_t c = 0;
  uint16_t bufferPos = 3;
  uint32_t bytesToSend = fileSize;

  // Wait for the starting 'C' character
  while(c != 'C') {
    1910:	83 34       	cpi	r24, 0x43	; 67
    1912:	e1 f7       	brne	.-8      	; 0x190c <ymodem_send+0x44>
    c = usart_receive();
  }

  // First packet is all about filename and filesize
  for(uint8_t i = 0; filename[i] != '\0'; i++, bufferPos++) {
    1914:	d8 01       	movw	r26, r16
    1916:	8c 91       	ld	r24, X
    1918:	88 23       	and	r24, r24
    191a:	09 f4       	brne	.+2      	; 0x191e <ymodem_send+0x56>
    191c:	18 c2       	rjmp	.+1072   	; 0x1d4e <ymodem_send+0x486>
    191e:	a3 e0       	ldi	r26, 0x03	; 3
    1920:	b0 e0       	ldi	r27, 0x00	; 0
    ymodemBuffer[bufferPos] = filename[i];
    1922:	fd 01       	movw	r30, r26
    1924:	ee 5b       	subi	r30, 0xBE	; 190
    1926:	fe 4f       	sbci	r31, 0xFE	; 254
    1928:	80 83       	st	Z, r24
    192a:	8a 2f       	mov	r24, r26
    192c:	82 50       	subi	r24, 0x02	; 2
  while(c != 'C') {
    c = usart_receive();
  }

  // First packet is all about filename and filesize
  for(uint8_t i = 0; filename[i] != '\0'; i++, bufferPos++) {
    192e:	11 96       	adiw	r26, 0x01	; 1
    1930:	f8 01       	movw	r30, r16
    1932:	e8 0f       	add	r30, r24
    1934:	f1 1d       	adc	r31, r1
    1936:	80 81       	ld	r24, Z
    1938:	88 23       	and	r24, r24
    193a:	99 f7       	brne	.-26     	; 0x1922 <ymodem_send+0x5a>
    193c:	4d 01       	movw	r8, r26
    193e:	08 94       	sec
    1940:	81 1c       	adc	r8, r1
    1942:	91 1c       	adc	r9, r1
    ymodemBuffer[bufferPos] = filename[i];
  }
  ymodemBuffer[bufferPos++] = '\0';
    1944:	ae 5b       	subi	r26, 0xBE	; 190
    1946:	be 4f       	sbci	r27, 0xFE	; 254
    1948:	1c 92       	st	X, r1
  
  // Need to add the file size in decimal format
  char fileSizeStr[11];
  uint16_t i = 0;
  fileSizeStr[0] = '0';
    194a:	80 e3       	ldi	r24, 0x30	; 48
    194c:	89 83       	std	Y+1, r24	; 0x01
    194e:	cc 24       	eor	r12, r12
    1950:	dd 24       	eor	r13, r13
    1952:	21 14       	cp	r2, r1
    1954:	31 04       	cpc	r3, r1
    1956:	41 04       	cpc	r4, r1
    1958:	51 04       	cpc	r5, r1
    195a:	09 f0       	breq	.+2      	; 0x195e <ymodem_send+0x96>
    195c:	cd c1       	rjmp	.+922    	; 0x1cf8 <ymodem_send+0x430>
    195e:	31 e0       	ldi	r19, 0x01	; 1
    1960:	c3 2e       	mov	r12, r19
    1962:	d1 2c       	mov	r13, r1
    bytesToSend /= 10;
    i++;
  }
  bytesToSend = fileSize;
  // Now we've converted it in reverse, pump it back out correctly
  for(; i > 0; i--, bufferPos++) {
    1964:	fe 01       	movw	r30, r28
    1966:	ec 0d       	add	r30, r12
    1968:	fd 1d       	adc	r31, r13
    196a:	d4 01       	movw	r26, r8
    196c:	ae 5b       	subi	r26, 0xBE	; 190
    196e:	be 4f       	sbci	r27, 0xFE	; 254
    ymodemBuffer[bufferPos] = fileSizeStr[i - 1];
    1970:	80 81       	ld	r24, Z
    1972:	8d 93       	st	X+, r24
    1974:	31 97       	sbiw	r30, 0x01	; 1
    bytesToSend /= 10;
    i++;
  }
  bytesToSend = fileSize;
  // Now we've converted it in reverse, pump it back out correctly
  for(; i > 0; i--, bufferPos++) {
    1976:	ec 17       	cp	r30, r28
    1978:	fd 07       	cpc	r31, r29
    197a:	d1 f7       	brne	.-12     	; 0x1970 <ymodem_send+0xa8>
    197c:	8c 0c       	add	r8, r12
    197e:	9d 1c       	adc	r9, r13
    ymodemBuffer[bufferPos] = fileSizeStr[i - 1];
  }
  ymodemBuffer[bufferPos++] = '\0';
    1980:	f4 01       	movw	r30, r8
    1982:	ee 5b       	subi	r30, 0xBE	; 190
    1984:	fe 4f       	sbci	r31, 0xFE	; 254
    1986:	10 82       	st	Z, r1
    1988:	f4 01       	movw	r30, r8
    198a:	31 96       	adiw	r30, 0x01	; 1

  for(; bufferPos < BYTES_PER_PACKET; bufferPos++) {
    198c:	e5 38       	cpi	r30, 0x85	; 133
    198e:	f1 05       	cpc	r31, r1
    1990:	38 f4       	brcc	.+14     	; 0x19a0 <ymodem_send+0xd8>
    1992:	ee 5b       	subi	r30, 0xBE	; 190
    1994:	fe 4f       	sbci	r31, 0xFE	; 254
    // Make the remaining characters nulls
    ymodemBuffer[bufferPos] = 0;
    1996:	11 92       	st	Z+, r1
  for(; i > 0; i--, bufferPos++) {
    ymodemBuffer[bufferPos] = fileSizeStr[i - 1];
  }
  ymodemBuffer[bufferPos++] = '\0';

  for(; bufferPos < BYTES_PER_PACKET; bufferPos++) {
    1998:	81 e0       	ldi	r24, 0x01	; 1
    199a:	e7 3c       	cpi	r30, 0xC7	; 199
    199c:	f8 07       	cpc	r31, r24
    199e:	d9 f7       	brne	.-10     	; 0x1996 <ymodem_send+0xce>
    19a0:	25 e4       	ldi	r18, 0x45	; 69
    19a2:	e2 2e       	mov	r14, r18
    19a4:	21 e0       	ldi	r18, 0x01	; 1
    19a6:	f2 2e       	mov	r15, r18
    19a8:	20 e0       	ldi	r18, 0x00	; 0
    19aa:	30 e0       	ldi	r19, 0x00	; 0
static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    crc = _crc_xmodem_update(crc, *ptr++);
    19ac:	d7 01       	movw	r26, r14
    19ae:	8d 91       	ld	r24, X+
    19b0:	7d 01       	movw	r14, r26
    uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
    uint8_t __tmp1;             /* %1 */
    uint8_t __tmp2;             /* %2 */
                                /* %3  __data */

    __asm__ __volatile__ (
    19b2:	38 27       	eor	r19, r24
    19b4:	03 2e       	mov	r0, r19
    19b6:	02 94       	swap	r0
    19b8:	90 2d       	mov	r25, r0
    19ba:	9f 70       	andi	r25, 0x0F	; 15
    19bc:	93 27       	eor	r25, r19
    19be:	83 2f       	mov	r24, r19
    19c0:	80 25       	eor	r24, r0
    19c2:	88 0f       	add	r24, r24
    19c4:	80 7e       	andi	r24, 0xE0	; 224
    19c6:	98 27       	eor	r25, r24
    19c8:	80 2d       	mov	r24, r0
    19ca:	83 27       	eor	r24, r19
    19cc:	80 7f       	andi	r24, 0xF0	; 240
    19ce:	86 95       	lsr	r24
    19d0:	03 2e       	mov	r0, r19
    19d2:	00 0c       	add	r0, r0
    19d4:	88 1f       	adc	r24, r24
    19d6:	36 95       	lsr	r19
    19d8:	36 95       	lsr	r19
    19da:	36 95       	lsr	r19
    19dc:	3f 71       	andi	r19, 0x1F	; 31
    19de:	38 27       	eor	r19, r24
    19e0:	32 27       	eor	r19, r18
    19e2:	29 2f       	mov	r18, r25

static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    19e4:	b5 ec       	ldi	r27, 0xC5	; 197
    19e6:	eb 16       	cp	r14, r27
    19e8:	b1 e0       	ldi	r27, 0x01	; 1
    19ea:	fb 06       	cpc	r15, r27
    19ec:	f9 f6       	brne	.-66     	; 0x19ac <ymodem_send+0xe4>
    // Make the remaining characters nulls
    ymodemBuffer[bufferPos] = 0;
  }

  crc = ymodem_calcrc((&ymodemBuffer[3]), 128);
  ymodemBuffer[0] = YMODEM_SOH_128;
    19ee:	81 e0       	ldi	r24, 0x01	; 1
    19f0:	80 93 42 01 	sts	0x0142, r24
  ymodemBuffer[1] = 0;
    19f4:	10 92 43 01 	sts	0x0143, r1
  ymodemBuffer[2] = 0xFF;
    19f8:	8f ef       	ldi	r24, 0xFF	; 255
    19fa:	80 93 44 01 	sts	0x0144, r24
  ymodemBuffer[131] = (uint8_t)(crc >> 8);
    19fe:	f7 01       	movw	r30, r14
    1a00:	30 83       	st	Z, r19
  ymodemBuffer[132] = (uint8_t) crc;
    1a02:	20 93 c6 01 	sts	0x01C6, r18
    1a06:	00 e0       	ldi	r16, 0x00	; 0
    1a08:	10 e0       	ldi	r17, 0x00	; 0
  
  // Send the header packet out until we get an ACK
  do {
    for(i = 0; i<BYTES_PER_PACKET; i++) {
    1a0a:	05 38       	cpi	r16, 0x85	; 133
    1a0c:	11 05       	cpc	r17, r1
    1a0e:	48 f0       	brcs	.+18     	; 0x1a22 <ymodem_send+0x15a>
      usart_transmit(ymodemBuffer[i]);
    }

    c = usart_receive();
    1a10:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>

  } while(c != ACK);
    1a14:	86 30       	cpi	r24, 0x06	; 6
    1a16:	71 f0       	breq	.+28     	; 0x1a34 <ymodem_send+0x16c>
    1a18:	00 e0       	ldi	r16, 0x00	; 0
    1a1a:	10 e0       	ldi	r17, 0x00	; 0
  ymodemBuffer[131] = (uint8_t)(crc >> 8);
  ymodemBuffer[132] = (uint8_t) crc;
  
  // Send the header packet out until we get an ACK
  do {
    for(i = 0; i<BYTES_PER_PACKET; i++) {
    1a1c:	05 38       	cpi	r16, 0x85	; 133
    1a1e:	11 05       	cpc	r17, r1
    1a20:	b8 f7       	brcc	.-18     	; 0x1a10 <ymodem_send+0x148>
      usart_transmit(ymodemBuffer[i]);
    1a22:	f8 01       	movw	r30, r16
    1a24:	ee 5b       	subi	r30, 0xBE	; 190
    1a26:	fe 4f       	sbci	r31, 0xFE	; 254
    1a28:	80 81       	ld	r24, Z
    1a2a:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  ymodemBuffer[131] = (uint8_t)(crc >> 8);
  ymodemBuffer[132] = (uint8_t) crc;
  
  // Send the header packet out until we get an ACK
  do {
    for(i = 0; i<BYTES_PER_PACKET; i++) {
    1a2e:	0f 5f       	subi	r16, 0xFF	; 255
    1a30:	1f 4f       	sbci	r17, 0xFF	; 255
    1a32:	eb cf       	rjmp	.-42     	; 0x1a0a <ymodem_send+0x142>

  } while(c != ACK);

  // Wait for the starting 'C' character
  while(c != 'C') {
    c = usart_receive();
    1a34:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
    c = usart_receive();

  } while(c != ACK);

  // Wait for the starting 'C' character
  while(c != 'C') {
    1a38:	83 34       	cpi	r24, 0x43	; 67
    1a3a:	e1 f7       	brne	.-8      	; 0x1a34 <ymodem_send+0x16c>
    c = usart_receive();
  }

  // Okay, now onto the data 
  while(bytesToSend > 0) {
    1a3c:	21 14       	cp	r2, r1
    1a3e:	31 04       	cpc	r3, r1
    1a40:	41 04       	cpc	r4, r1
    1a42:	51 04       	cpc	r5, r1
    1a44:	09 f4       	brne	.+2      	; 0x1a48 <ymodem_send+0x180>
    1a46:	6f c0       	rjmp	.+222    	; 0x1b26 <ymodem_send+0x25e>
    1a48:	62 01       	movw	r12, r4
    1a4a:	51 01       	movw	r10, r2
    1a4c:	88 24       	eor	r8, r8
    1a4e:	83 94       	inc	r8
        
        bytesToSend = 0;

      } 
      
      ymodemBuffer[0] = YMODEM_SOH_128;
    1a50:	55 24       	eor	r5, r5
    1a52:	53 94       	inc	r5
  
      } else {
        // Leftovers (<128)
        (buffer_func)(&ymodemBuffer[3], bytesToSend);
        for(i = bytesToSend; i < BYTES_PER_PACKET;i++) {
          ymodemBuffer[3+i] = CTRLZ;
    1a54:	9a e1       	ldi	r25, 0x1A	; 26
    1a56:	99 2e       	mov	r9, r25
      (buffer_func)(&ymodemBuffer[3], 1024);
      crc = ymodem_calcrc(&ymodemBuffer[3], 1024);
      ymodemBuffer[1027] = (uint8_t) (crc >> 8);
      ymodemBuffer[1028] = (uint8_t) crc;
      bytesToSend -= 1024;
      ymodemBuffer[0] = YMODEM_STX_1K;
    1a58:	82 e0       	ldi	r24, 0x02	; 2
    1a5a:	48 2e       	mov	r4, r24
  }

  // Okay, now onto the data 
  while(bytesToSend > 0) {
    
    if(bytesToSend > 1024) {
    1a5c:	f1 e0       	ldi	r31, 0x01	; 1
    1a5e:	af 16       	cp	r10, r31
    1a60:	f4 e0       	ldi	r31, 0x04	; 4
    1a62:	bf 06       	cpc	r11, r31
    1a64:	f0 e0       	ldi	r31, 0x00	; 0
    1a66:	cf 06       	cpc	r12, r31
    1a68:	f0 e0       	ldi	r31, 0x00	; 0
    1a6a:	df 06       	cpc	r13, r31
    1a6c:	08 f0       	brcs	.+2      	; 0x1a70 <ymodem_send+0x1a8>
    1a6e:	de c0       	rjmp	.+444    	; 0x1c2c <ymodem_send+0x364>

      } while(c != ACK);

    } else {
    
      if (bytesToSend > 128) {
    1a70:	91 e8       	ldi	r25, 0x81	; 129
    1a72:	a9 16       	cp	r10, r25
    1a74:	b1 04       	cpc	r11, r1
    1a76:	c1 04       	cpc	r12, r1
    1a78:	d1 04       	cpc	r13, r1
    1a7a:	08 f4       	brcc	.+2      	; 0x1a7e <ymodem_send+0x1b6>
    1a7c:	c4 c0       	rjmp	.+392    	; 0x1c06 <ymodem_send+0x33e>
        (buffer_func)(&ymodemBuffer[3], 128);
    1a7e:	85 e4       	ldi	r24, 0x45	; 69
    1a80:	91 e0       	ldi	r25, 0x01	; 1
    1a82:	60 e8       	ldi	r22, 0x80	; 128
    1a84:	70 e0       	ldi	r23, 0x00	; 0
    1a86:	f3 01       	movw	r30, r6
    1a88:	09 95       	icall
        
        bytesToSend -= 128;
    1a8a:	80 e8       	ldi	r24, 0x80	; 128
    1a8c:	9f ef       	ldi	r25, 0xFF	; 255
    1a8e:	af ef       	ldi	r26, 0xFF	; 255
    1a90:	bf ef       	ldi	r27, 0xFF	; 255
    1a92:	a8 0e       	add	r10, r24
    1a94:	b9 1e       	adc	r11, r25
    1a96:	ca 1e       	adc	r12, r26
    1a98:	db 1e       	adc	r13, r27
        
        bytesToSend = 0;

      } 
      
      ymodemBuffer[0] = YMODEM_SOH_128;
    1a9a:	50 92 42 01 	sts	0x0142, r5
      ymodemBuffer[1] = packetNum;
    1a9e:	80 92 43 01 	sts	0x0143, r8
      ymodemBuffer[2] = ~packetNum;
    1aa2:	88 2d       	mov	r24, r8
    1aa4:	80 95       	com	r24
    1aa6:	80 93 44 01 	sts	0x0144, r24
    1aaa:	e5 e4       	ldi	r30, 0x45	; 69
    1aac:	f1 e0       	ldi	r31, 0x01	; 1
    1aae:	20 e0       	ldi	r18, 0x00	; 0
    1ab0:	30 e0       	ldi	r19, 0x00	; 0
static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    crc = _crc_xmodem_update(crc, *ptr++);
    1ab2:	81 91       	ld	r24, Z+
    1ab4:	38 27       	eor	r19, r24
    1ab6:	03 2e       	mov	r0, r19
    1ab8:	02 94       	swap	r0
    1aba:	90 2d       	mov	r25, r0
    1abc:	9f 70       	andi	r25, 0x0F	; 15
    1abe:	93 27       	eor	r25, r19
    1ac0:	83 2f       	mov	r24, r19
    1ac2:	80 25       	eor	r24, r0
    1ac4:	88 0f       	add	r24, r24
    1ac6:	80 7e       	andi	r24, 0xE0	; 224
    1ac8:	98 27       	eor	r25, r24
    1aca:	80 2d       	mov	r24, r0
    1acc:	83 27       	eor	r24, r19
    1ace:	80 7f       	andi	r24, 0xF0	; 240
    1ad0:	86 95       	lsr	r24
    1ad2:	03 2e       	mov	r0, r19
    1ad4:	00 0c       	add	r0, r0
    1ad6:	88 1f       	adc	r24, r24
    1ad8:	36 95       	lsr	r19
    1ada:	36 95       	lsr	r19
    1adc:	36 95       	lsr	r19
    1ade:	3f 71       	andi	r19, 0x1F	; 31
    1ae0:	38 27       	eor	r19, r24
    1ae2:	32 27       	eor	r19, r18
    1ae4:	29 2f       	mov	r18, r25

static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    1ae6:	91 e0       	ldi	r25, 0x01	; 1
    1ae8:	e5 3c       	cpi	r30, 0xC5	; 197
    1aea:	f9 07       	cpc	r31, r25
    1aec:	11 f7       	brne	.-60     	; 0x1ab2 <ymodem_send+0x1ea>
      
      ymodemBuffer[0] = YMODEM_SOH_128;
      ymodemBuffer[1] = packetNum;
      ymodemBuffer[2] = ~packetNum;
      crc = ymodem_calcrc((&ymodemBuffer[3]), 128);
      ymodemBuffer[131] = (uint8_t) (crc >> 8);
    1aee:	30 93 c5 01 	sts	0x01C5, r19
      ymodemBuffer[132] = (uint8_t) crc;
    1af2:	20 93 c6 01 	sts	0x01C6, r18
    1af6:	00 e0       	ldi	r16, 0x00	; 0
    1af8:	10 e0       	ldi	r17, 0x00	; 0

      do {
        for(i = 0; i<BYTES_PER_PACKET; i++) {
    1afa:	05 38       	cpi	r16, 0x85	; 133
    1afc:	11 05       	cpc	r17, r1
    1afe:	50 f0       	brcs	.+20     	; 0x1b14 <ymodem_send+0x24c>
          usart_transmit(ymodemBuffer[i]);

        }

        c = usart_receive();
    1b00:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>

      } while(c != ACK);
    1b04:	86 30       	cpi	r24, 0x06	; 6
    1b06:	09 f4       	brne	.+2      	; 0x1b0a <ymodem_send+0x242>
    1b08:	6d c0       	rjmp	.+218    	; 0x1be4 <ymodem_send+0x31c>
    1b0a:	00 e0       	ldi	r16, 0x00	; 0
    1b0c:	10 e0       	ldi	r17, 0x00	; 0
      crc = ymodem_calcrc((&ymodemBuffer[3]), 128);
      ymodemBuffer[131] = (uint8_t) (crc >> 8);
      ymodemBuffer[132] = (uint8_t) crc;

      do {
        for(i = 0; i<BYTES_PER_PACKET; i++) {
    1b0e:	05 38       	cpi	r16, 0x85	; 133
    1b10:	11 05       	cpc	r17, r1
    1b12:	b0 f7       	brcc	.-20     	; 0x1b00 <ymodem_send+0x238>
          usart_transmit(ymodemBuffer[i]);
    1b14:	f8 01       	movw	r30, r16
    1b16:	ee 5b       	subi	r30, 0xBE	; 190
    1b18:	fe 4f       	sbci	r31, 0xFE	; 254
    1b1a:	80 81       	ld	r24, Z
    1b1c:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
      crc = ymodem_calcrc((&ymodemBuffer[3]), 128);
      ymodemBuffer[131] = (uint8_t) (crc >> 8);
      ymodemBuffer[132] = (uint8_t) crc;

      do {
        for(i = 0; i<BYTES_PER_PACKET; i++) {
    1b20:	0f 5f       	subi	r16, 0xFF	; 255
    1b22:	1f 4f       	sbci	r17, 0xFF	; 255
    1b24:	ea cf       	rjmp	.-44     	; 0x1afa <ymodem_send+0x232>
    packetNum++;
  }

  do {
    // Send an EOT
    usart_transmit(EOT);
    1b26:	84 e0       	ldi	r24, 0x04	; 4
    1b28:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    
    // Wait for ACK
    c = usart_receive();
    1b2c:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while (c != ACK);
    1b30:	86 30       	cpi	r24, 0x06	; 6
    1b32:	c9 f7       	brne	.-14     	; 0x1b26 <ymodem_send+0x25e>

  // Wait for a 'C' character
  do {
    c = usart_receive();
    1b34:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while (c != 'C');
    1b38:	83 34       	cpi	r24, 0x43	; 67
    1b3a:	e1 f7       	brne	.-8      	; 0x1b34 <ymodem_send+0x26c>
    1b3c:	e2 e4       	ldi	r30, 0x42	; 66
    1b3e:	f1 e0       	ldi	r31, 0x01	; 1

  // Send a null filename file
  for(i = 0; i < BYTES_PER_PACKET; i++) {
    ymodemBuffer[i] = 0;
    1b40:	11 92       	st	Z+, r1
  do {
    c = usart_receive();
  } while (c != 'C');

  // Send a null filename file
  for(i = 0; i < BYTES_PER_PACKET; i++) {
    1b42:	a1 e0       	ldi	r26, 0x01	; 1
    1b44:	e7 3c       	cpi	r30, 0xC7	; 199
    1b46:	fa 07       	cpc	r31, r26
    1b48:	d9 f7       	brne	.-10     	; 0x1b40 <ymodem_send+0x278>
    1b4a:	e5 e4       	ldi	r30, 0x45	; 69
    1b4c:	f1 e0       	ldi	r31, 0x01	; 1
    1b4e:	20 e0       	ldi	r18, 0x00	; 0
    1b50:	30 e0       	ldi	r19, 0x00	; 0
static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    crc = _crc_xmodem_update(crc, *ptr++);
    1b52:	81 91       	ld	r24, Z+
    1b54:	38 27       	eor	r19, r24
    1b56:	03 2e       	mov	r0, r19
    1b58:	02 94       	swap	r0
    1b5a:	90 2d       	mov	r25, r0
    1b5c:	9f 70       	andi	r25, 0x0F	; 15
    1b5e:	93 27       	eor	r25, r19
    1b60:	83 2f       	mov	r24, r19
    1b62:	80 25       	eor	r24, r0
    1b64:	88 0f       	add	r24, r24
    1b66:	80 7e       	andi	r24, 0xE0	; 224
    1b68:	98 27       	eor	r25, r24
    1b6a:	80 2d       	mov	r24, r0
    1b6c:	83 27       	eor	r24, r19
    1b6e:	80 7f       	andi	r24, 0xF0	; 240
    1b70:	86 95       	lsr	r24
    1b72:	03 2e       	mov	r0, r19
    1b74:	00 0c       	add	r0, r0
    1b76:	88 1f       	adc	r24, r24
    1b78:	36 95       	lsr	r19
    1b7a:	36 95       	lsr	r19
    1b7c:	36 95       	lsr	r19
    1b7e:	3f 71       	andi	r19, 0x1F	; 31
    1b80:	38 27       	eor	r19, r24
    1b82:	32 27       	eor	r19, r18
    1b84:	29 2f       	mov	r18, r25

static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    1b86:	ee 16       	cp	r14, r30
    1b88:	ff 06       	cpc	r15, r31
    1b8a:	19 f7       	brne	.-58     	; 0x1b52 <ymodem_send+0x28a>
  for(i = 0; i < BYTES_PER_PACKET; i++) {
    ymodemBuffer[i] = 0;
  }
  crc = ymodem_calcrc((&ymodemBuffer[3]), 128);
  
  ymodemBuffer[0] = YMODEM_SOH_128;
    1b8c:	81 e0       	ldi	r24, 0x01	; 1
    1b8e:	80 93 42 01 	sts	0x0142, r24
  ymodemBuffer[1] = 0;
    1b92:	10 92 43 01 	sts	0x0143, r1
  ymodemBuffer[2] = 0xFF;
    1b96:	8f ef       	ldi	r24, 0xFF	; 255
    1b98:	80 93 44 01 	sts	0x0144, r24
  ymodemBuffer[131] = (uint8_t) (crc >> 8);
    1b9c:	30 93 c5 01 	sts	0x01C5, r19
  ymodemBuffer[132] = (uint8_t) crc;
    1ba0:	20 93 c6 01 	sts	0x01C6, r18
    1ba4:	00 e0       	ldi	r16, 0x00	; 0
    1ba6:	10 e0       	ldi	r17, 0x00	; 0

  do {
    for(i = 0; i<BYTES_PER_PACKET; i++) {
    1ba8:	05 38       	cpi	r16, 0x85	; 133
    1baa:	11 05       	cpc	r17, r1
    1bac:	50 f0       	brcs	.+20     	; 0x1bc2 <ymodem_send+0x2fa>
      usart_transmit(ymodemBuffer[i]);
    }

    c = usart_receive();
    1bae:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(c != ACK);
    1bb2:	86 30       	cpi	r24, 0x06	; 6
    1bb4:	09 f4       	brne	.+2      	; 0x1bb8 <ymodem_send+0x2f0>
    1bb6:	86 c0       	rjmp	.+268    	; 0x1cc4 <ymodem_send+0x3fc>
    1bb8:	00 e0       	ldi	r16, 0x00	; 0
    1bba:	10 e0       	ldi	r17, 0x00	; 0
  ymodemBuffer[2] = 0xFF;
  ymodemBuffer[131] = (uint8_t) (crc >> 8);
  ymodemBuffer[132] = (uint8_t) crc;

  do {
    for(i = 0; i<BYTES_PER_PACKET; i++) {
    1bbc:	05 38       	cpi	r16, 0x85	; 133
    1bbe:	11 05       	cpc	r17, r1
    1bc0:	b0 f7       	brcc	.-20     	; 0x1bae <ymodem_send+0x2e6>
      usart_transmit(ymodemBuffer[i]);
    1bc2:	f8 01       	movw	r30, r16
    1bc4:	ee 5b       	subi	r30, 0xBE	; 190
    1bc6:	fe 4f       	sbci	r31, 0xFE	; 254
    1bc8:	80 81       	ld	r24, Z
    1bca:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  ymodemBuffer[2] = 0xFF;
  ymodemBuffer[131] = (uint8_t) (crc >> 8);
  ymodemBuffer[132] = (uint8_t) crc;

  do {
    for(i = 0; i<BYTES_PER_PACKET; i++) {
    1bce:	0f 5f       	subi	r16, 0xFF	; 255
    1bd0:	1f 4f       	sbci	r17, 0xFF	; 255
    1bd2:	ea cf       	rjmp	.-44     	; 0x1ba8 <ymodem_send+0x2e0>

      (buffer_func)(&ymodemBuffer[3], 1024);
      crc = ymodem_calcrc(&ymodemBuffer[3], 1024);
      ymodemBuffer[1027] = (uint8_t) (crc >> 8);
      ymodemBuffer[1028] = (uint8_t) crc;
      bytesToSend -= 1024;
    1bd4:	80 e0       	ldi	r24, 0x00	; 0
    1bd6:	9c ef       	ldi	r25, 0xFC	; 252
    1bd8:	af ef       	ldi	r26, 0xFF	; 255
    1bda:	bf ef       	ldi	r27, 0xFF	; 255
    1bdc:	a8 0e       	add	r10, r24
    1bde:	b9 1e       	adc	r11, r25
    1be0:	ca 1e       	adc	r12, r26
    1be2:	db 1e       	adc	r13, r27
        c = usart_receive();

      } while(c != ACK);
    }
    
    ymodemSentPackets++;
    1be4:	80 91 40 01 	lds	r24, 0x0140
    1be8:	90 91 41 01 	lds	r25, 0x0141
    1bec:	01 96       	adiw	r24, 0x01	; 1
    1bee:	90 93 41 01 	sts	0x0141, r25
    1bf2:	80 93 40 01 	sts	0x0140, r24
  while(c != 'C') {
    c = usart_receive();
  }

  // Okay, now onto the data 
  while(bytesToSend > 0) {
    1bf6:	a1 14       	cp	r10, r1
    1bf8:	b1 04       	cpc	r11, r1
    1bfa:	c1 04       	cpc	r12, r1
    1bfc:	d1 04       	cpc	r13, r1
    1bfe:	09 f4       	brne	.+2      	; 0x1c02 <ymodem_send+0x33a>
    1c00:	92 cf       	rjmp	.-220    	; 0x1b26 <ymodem_send+0x25e>

      } while(c != ACK);
    }
    
    ymodemSentPackets++;
    packetNum++;
    1c02:	83 94       	inc	r8
    1c04:	2b cf       	rjmp	.-426    	; 0x1a5c <ymodem_send+0x194>
        bytesToSend -= 128;

  
      } else {
        // Leftovers (<128)
        (buffer_func)(&ymodemBuffer[3], bytesToSend);
    1c06:	85 01       	movw	r16, r10
    1c08:	85 e4       	ldi	r24, 0x45	; 69
    1c0a:	91 e0       	ldi	r25, 0x01	; 1
    1c0c:	b5 01       	movw	r22, r10
    1c0e:	f3 01       	movw	r30, r6
    1c10:	09 95       	icall
    1c12:	f5 01       	movw	r30, r10
    1c14:	eb 5b       	subi	r30, 0xBB	; 187
    1c16:	fe 4f       	sbci	r31, 0xFE	; 254
        for(i = bytesToSend; i < BYTES_PER_PACKET;i++) {
          ymodemBuffer[3+i] = CTRLZ;
    1c18:	91 92       	st	Z+, r9

  
      } else {
        // Leftovers (<128)
        (buffer_func)(&ymodemBuffer[3], bytesToSend);
        for(i = bytesToSend; i < BYTES_PER_PACKET;i++) {
    1c1a:	0f 5f       	subi	r16, 0xFF	; 255
    1c1c:	1f 4f       	sbci	r17, 0xFF	; 255
    1c1e:	05 38       	cpi	r16, 0x85	; 133
    1c20:	11 05       	cpc	r17, r1
    1c22:	d0 f3       	brcs	.-12     	; 0x1c18 <ymodem_send+0x350>
    1c24:	aa 24       	eor	r10, r10
    1c26:	bb 24       	eor	r11, r11
    1c28:	65 01       	movw	r12, r10
    1c2a:	37 cf       	rjmp	.-402    	; 0x1a9a <ymodem_send+0x1d2>
  // Okay, now onto the data 
  while(bytesToSend > 0) {
    
    if(bytesToSend > 1024) {

      (buffer_func)(&ymodemBuffer[3], 1024);
    1c2c:	85 e4       	ldi	r24, 0x45	; 69
    1c2e:	91 e0       	ldi	r25, 0x01	; 1
    1c30:	60 e0       	ldi	r22, 0x00	; 0
    1c32:	74 e0       	ldi	r23, 0x04	; 4
    1c34:	f3 01       	movw	r30, r6
    1c36:	09 95       	icall
    1c38:	e5 e4       	ldi	r30, 0x45	; 69
    1c3a:	f1 e0       	ldi	r31, 0x01	; 1
    1c3c:	20 e0       	ldi	r18, 0x00	; 0
    1c3e:	30 e0       	ldi	r19, 0x00	; 0
static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    crc = _crc_xmodem_update(crc, *ptr++);
    1c40:	81 91       	ld	r24, Z+
    1c42:	38 27       	eor	r19, r24
    1c44:	03 2e       	mov	r0, r19
    1c46:	02 94       	swap	r0
    1c48:	90 2d       	mov	r25, r0
    1c4a:	9f 70       	andi	r25, 0x0F	; 15
    1c4c:	93 27       	eor	r25, r19
    1c4e:	83 2f       	mov	r24, r19
    1c50:	80 25       	eor	r24, r0
    1c52:	88 0f       	add	r24, r24
    1c54:	80 7e       	andi	r24, 0xE0	; 224
    1c56:	98 27       	eor	r25, r24
    1c58:	80 2d       	mov	r24, r0
    1c5a:	83 27       	eor	r24, r19
    1c5c:	80 7f       	andi	r24, 0xF0	; 240
    1c5e:	86 95       	lsr	r24
    1c60:	03 2e       	mov	r0, r19
    1c62:	00 0c       	add	r0, r0
    1c64:	88 1f       	adc	r24, r24
    1c66:	36 95       	lsr	r19
    1c68:	36 95       	lsr	r19
    1c6a:	36 95       	lsr	r19
    1c6c:	3f 71       	andi	r19, 0x1F	; 31
    1c6e:	38 27       	eor	r19, r24
    1c70:	32 27       	eor	r19, r18
    1c72:	29 2f       	mov	r18, r25

static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    1c74:	85 e0       	ldi	r24, 0x05	; 5
    1c76:	e5 34       	cpi	r30, 0x45	; 69
    1c78:	f8 07       	cpc	r31, r24
    1c7a:	11 f7       	brne	.-60     	; 0x1c40 <ymodem_send+0x378>
    
    if(bytesToSend > 1024) {

      (buffer_func)(&ymodemBuffer[3], 1024);
      crc = ymodem_calcrc(&ymodemBuffer[3], 1024);
      ymodemBuffer[1027] = (uint8_t) (crc >> 8);
    1c7c:	30 83       	st	Z, r19
      ymodemBuffer[1028] = (uint8_t) crc;
    1c7e:	21 83       	std	Z+1, r18	; 0x01
      bytesToSend -= 1024;
      ymodemBuffer[0] = YMODEM_STX_1K;
    1c80:	40 92 42 01 	sts	0x0142, r4
      ymodemBuffer[1] = packetNum;
    1c84:	80 92 43 01 	sts	0x0143, r8
      ymodemBuffer[2] = ~packetNum;
    1c88:	88 2d       	mov	r24, r8
    1c8a:	80 95       	com	r24
    1c8c:	80 93 44 01 	sts	0x0144, r24
    1c90:	00 e0       	ldi	r16, 0x00	; 0
    1c92:	10 e0       	ldi	r17, 0x00	; 0

      do {
        for(i = 0; i<BYTES_PER_PACKET_1K; i++) {
    1c94:	94 e0       	ldi	r25, 0x04	; 4
    1c96:	05 30       	cpi	r16, 0x05	; 5
    1c98:	19 07       	cpc	r17, r25
    1c9a:	58 f0       	brcs	.+22     	; 0x1cb2 <ymodem_send+0x3ea>
          usart_transmit(ymodemBuffer[i]);
        }

        c = usart_receive();
    1c9c:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>

      } while(c != ACK);
    1ca0:	86 30       	cpi	r24, 0x06	; 6
    1ca2:	09 f4       	brne	.+2      	; 0x1ca6 <ymodem_send+0x3de>
    1ca4:	97 cf       	rjmp	.-210    	; 0x1bd4 <ymodem_send+0x30c>
    1ca6:	00 e0       	ldi	r16, 0x00	; 0
    1ca8:	10 e0       	ldi	r17, 0x00	; 0
      ymodemBuffer[0] = YMODEM_STX_1K;
      ymodemBuffer[1] = packetNum;
      ymodemBuffer[2] = ~packetNum;

      do {
        for(i = 0; i<BYTES_PER_PACKET_1K; i++) {
    1caa:	94 e0       	ldi	r25, 0x04	; 4
    1cac:	05 30       	cpi	r16, 0x05	; 5
    1cae:	19 07       	cpc	r17, r25
    1cb0:	a8 f7       	brcc	.-22     	; 0x1c9c <ymodem_send+0x3d4>
          usart_transmit(ymodemBuffer[i]);
    1cb2:	f8 01       	movw	r30, r16
    1cb4:	ee 5b       	subi	r30, 0xBE	; 190
    1cb6:	fe 4f       	sbci	r31, 0xFE	; 254
    1cb8:	80 81       	ld	r24, Z
    1cba:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
      ymodemBuffer[0] = YMODEM_STX_1K;
      ymodemBuffer[1] = packetNum;
      ymodemBuffer[2] = ~packetNum;

      do {
        for(i = 0; i<BYTES_PER_PACKET_1K; i++) {
    1cbe:	0f 5f       	subi	r16, 0xFF	; 255
    1cc0:	1f 4f       	sbci	r17, 0xFF	; 255
    1cc2:	e8 cf       	rjmp	.-48     	; 0x1c94 <ymodem_send+0x3cc>
    c = usart_receive();
  } while(c != ACK);

  return 0;

}
    1cc4:	80 e0       	ldi	r24, 0x00	; 0
    1cc6:	2b 96       	adiw	r28, 0x0b	; 11
    1cc8:	0f b6       	in	r0, 0x3f	; 63
    1cca:	f8 94       	cli
    1ccc:	de bf       	out	0x3e, r29	; 62
    1cce:	0f be       	out	0x3f, r0	; 63
    1cd0:	cd bf       	out	0x3d, r28	; 61
    1cd2:	cf 91       	pop	r28
    1cd4:	df 91       	pop	r29
    1cd6:	1f 91       	pop	r17
    1cd8:	0f 91       	pop	r16
    1cda:	ff 90       	pop	r15
    1cdc:	ef 90       	pop	r14
    1cde:	df 90       	pop	r13
    1ce0:	cf 90       	pop	r12
    1ce2:	bf 90       	pop	r11
    1ce4:	af 90       	pop	r10
    1ce6:	9f 90       	pop	r9
    1ce8:	8f 90       	pop	r8
    1cea:	7f 90       	pop	r7
    1cec:	6f 90       	pop	r6
    1cee:	5f 90       	pop	r5
    1cf0:	4f 90       	pop	r4
    1cf2:	3f 90       	pop	r3
    1cf4:	2f 90       	pop	r2
    1cf6:	08 95       	ret
  uint16_t i = 0;
  fileSizeStr[0] = '0';
  if(bytesToSend == 0) {
    i = 1; // Need to push at least one value out
  }
  while(bytesToSend > 0) {
    1cf8:	5e 01       	movw	r10, r28
    1cfa:	08 94       	sec
    1cfc:	a1 1c       	adc	r10, r1
    1cfe:	b1 1c       	adc	r11, r1
    1d00:	82 01       	movw	r16, r4
    1d02:	71 01       	movw	r14, r2
    fileSizeStr[i] = bytesToSend % 10 + '0';
    1d04:	c8 01       	movw	r24, r16
    1d06:	b7 01       	movw	r22, r14
    1d08:	2a e0       	ldi	r18, 0x0A	; 10
    1d0a:	30 e0       	ldi	r19, 0x00	; 0
    1d0c:	40 e0       	ldi	r20, 0x00	; 0
    1d0e:	50 e0       	ldi	r21, 0x00	; 0
    1d10:	0e 94 6a 21 	call	0x42d4	; 0x42d4 <__udivmodsi4>
    1d14:	60 5d       	subi	r22, 0xD0	; 208
    1d16:	f5 01       	movw	r30, r10
    1d18:	61 93       	st	Z+, r22
    1d1a:	5f 01       	movw	r10, r30
    bytesToSend /= 10;
    1d1c:	c8 01       	movw	r24, r16
    1d1e:	b7 01       	movw	r22, r14
    1d20:	2a e0       	ldi	r18, 0x0A	; 10
    1d22:	30 e0       	ldi	r19, 0x00	; 0
    1d24:	40 e0       	ldi	r20, 0x00	; 0
    1d26:	50 e0       	ldi	r21, 0x00	; 0
    1d28:	0e 94 6a 21 	call	0x42d4	; 0x42d4 <__udivmodsi4>
    1d2c:	c9 01       	movw	r24, r18
    1d2e:	da 01       	movw	r26, r20
    1d30:	7c 01       	movw	r14, r24
    1d32:	8d 01       	movw	r16, r26
    i++;
    1d34:	08 94       	sec
    1d36:	c1 1c       	adc	r12, r1
    1d38:	d1 1c       	adc	r13, r1
  uint16_t i = 0;
  fileSizeStr[0] = '0';
  if(bytesToSend == 0) {
    i = 1; // Need to push at least one value out
  }
  while(bytesToSend > 0) {
    1d3a:	e1 14       	cp	r14, r1
    1d3c:	f1 04       	cpc	r15, r1
    1d3e:	01 05       	cpc	r16, r1
    1d40:	11 05       	cpc	r17, r1
    1d42:	01 f7       	brne	.-64     	; 0x1d04 <ymodem_send+0x43c>
    bytesToSend /= 10;
    i++;
  }
  bytesToSend = fileSize;
  // Now we've converted it in reverse, pump it back out correctly
  for(; i > 0; i--, bufferPos++) {
    1d44:	c1 14       	cp	r12, r1
    1d46:	d1 04       	cpc	r13, r1
    1d48:	09 f0       	breq	.+2      	; 0x1d4c <ymodem_send+0x484>
    1d4a:	0c ce       	rjmp	.-1000   	; 0x1964 <ymodem_send+0x9c>
    1d4c:	19 ce       	rjmp	.-974    	; 0x1980 <ymodem_send+0xb8>
  while(c != 'C') {
    c = usart_receive();
  }

  // First packet is all about filename and filesize
  for(uint8_t i = 0; filename[i] != '\0'; i++, bufferPos++) {
    1d4e:	a3 e0       	ldi	r26, 0x03	; 3
    1d50:	b0 e0       	ldi	r27, 0x00	; 0
    1d52:	44 e0       	ldi	r20, 0x04	; 4
    1d54:	84 2e       	mov	r8, r20
    1d56:	91 2c       	mov	r9, r1
    1d58:	f5 cd       	rjmp	.-1046   	; 0x1944 <ymodem_send+0x7c>

00001d5a <ymodem_receive>:
uint8_t ymodem_receive(void(*buffer_func)(unsigned char*, uint16_t), uint32_t *fileSize);
static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count);
uint8_t ymodem_send(uint8_t(*buffer_func)(unsigned char*, uint16_t), char * filename, uint32_t fileSize);

uint8_t ymodem_receive(void(*buffer_func)(unsigned char*, uint16_t), uint32_t *fileSize)
{
    1d5a:	3f 92       	push	r3
    1d5c:	4f 92       	push	r4
    1d5e:	5f 92       	push	r5
    1d60:	6f 92       	push	r6
    1d62:	7f 92       	push	r7
    1d64:	8f 92       	push	r8
    1d66:	9f 92       	push	r9
    1d68:	af 92       	push	r10
    1d6a:	bf 92       	push	r11
    1d6c:	cf 92       	push	r12
    1d6e:	df 92       	push	r13
    1d70:	ef 92       	push	r14
    1d72:	ff 92       	push	r15
    1d74:	0f 93       	push	r16
    1d76:	1f 93       	push	r17
    1d78:	cf 93       	push	r28
    1d7a:	df 93       	push	r29
    1d7c:	2c 01       	movw	r4, r24
    1d7e:	3b 01       	movw	r6, r22
  ymodemReceivedPackets = 0;
    1d80:	10 92 4c 05 	sts	0x054C, r1
    1d84:	10 92 4b 05 	sts	0x054B, r1
  uint8_t canAttempts = 0;
  uint8_t resendPacket = 0;
  uint8_t lastPacketNum = 0; // =0 is a hack so that packet num 0 is not caught by accident - actually maybe not...
  
  // Send 'C' to initiate header transfer with CRC-16 
  usart_transmit('C');
    1d88:	83 e4       	ldi	r24, 0x43	; 67
    1d8a:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    1d8e:	88 24       	eor	r8, r8
    1d90:	99 24       	eor	r9, r9
    1d92:	54 01       	movw	r10, r8
    1d94:	ee 24       	eor	r14, r14
    1d96:	33 24       	eor	r3, r3
    1d98:	ff 24       	eor	r15, r15
    1d9a:	00 e0       	ldi	r16, 0x00	; 0
    1d9c:	10 e0       	ldi	r17, 0x00	; 0
      if(shortPacketMode && (i >= BYTES_PER_PACKET)) {
        // This is a short packet! Don't read over 133 bytes
        break;
      }
      
      uint8_t c = usart_receive();
    1d9e:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>

      ymodemBuffer[i] = c;
    1da2:	f8 01       	movw	r30, r16
    1da4:	ee 5b       	subi	r30, 0xBE	; 190
    1da6:	fe 4f       	sbci	r31, 0xFE	; 254
    1da8:	80 83       	st	Z, r24

      if(i==0) {
    1daa:	01 15       	cp	r16, r1
    1dac:	11 05       	cpc	r17, r1
    1dae:	09 f0       	breq	.+2      	; 0x1db2 <ymodem_receive+0x58>
    1db0:	55 c0       	rjmp	.+170    	; 0x1e5c <ymodem_receive+0x102>
        if(ymodemBuffer[i] == YMODEM_SOH_128) {
    1db2:	81 30       	cpi	r24, 0x01	; 1
    1db4:	09 f4       	brne	.+2      	; 0x1db8 <ymodem_receive+0x5e>
    1db6:	4f c0       	rjmp	.+158    	; 0x1e56 <ymodem_receive+0xfc>
          shortPacketMode = 1;
          canAttempts = 0;

        } else if (ymodemBuffer[i] == YMODEM_STX_1K) {       
    1db8:	82 30       	cpi	r24, 0x02	; 2
    1dba:	09 f4       	brne	.+2      	; 0x1dbe <ymodem_receive+0x64>
    1dbc:	7d c0       	rjmp	.+250    	; 0x1eb8 <ymodem_receive+0x15e>
          shortPacketMode = 0;
          canAttempts = 0;

        } else if(ymodemBuffer[i] == EOT) {
    1dbe:	84 30       	cpi	r24, 0x04	; 4
    1dc0:	09 f4       	brne	.+2      	; 0x1dc4 <ymodem_receive+0x6a>
    1dc2:	1b c1       	rjmp	.+566    	; 0x1ffa <ymodem_receive+0x2a0>
          // Maybe should have a timeout here if the final ACK is lost and the sender fires EOT through again
          return 0;

        } else if(!((ymodemBuffer[i] == EOT) || (ymodemBuffer[i] == YMODEM_SOH_128) || (ymodemBuffer[i] == YMODEM_STX_1K))) {
          // Don't know what that was. Increment the cancellation counter and send a CAN
          usart_transmit(NACK);
    1dc4:	85 e1       	ldi	r24, 0x15	; 21
    1dc6:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
          canAttempts++;
    1dca:	e3 94       	inc	r14

          if(canAttempts > YMODEM_MAX_RETRIES) { 
    1dcc:	93 e0       	ldi	r25, 0x03	; 3
    1dce:	9e 15       	cp	r25, r14
    1dd0:	08 f4       	brcc	.+2      	; 0x1dd4 <ymodem_receive+0x7a>
    1dd2:	9a c1       	rjmp	.+820    	; 0x2108 <ymodem_receive+0x3ae>
  uint8_t canAttempts = 0;
  uint8_t resendPacket = 0;
  uint8_t lastPacketNum = 0; // =0 is a hack so that packet num 0 is not caught by accident - actually maybe not...
  
  // Send 'C' to initiate header transfer with CRC-16 
  usart_transmit('C');
    1dd4:	01 e0       	ldi	r16, 0x01	; 1
    1dd6:	10 e0       	ldi	r17, 0x00	; 0

    uint8_t shortPacketMode = 0;

    for(uint16_t i=0; i<BYTES_PER_PACKET_1K;i++) {

      if(shortPacketMode && (i >= BYTES_PER_PACKET)) {
    1dd8:	ff 20       	and	r15, r15
    1dda:	09 f3       	breq	.-62     	; 0x1d9e <ymodem_receive+0x44>
    1ddc:	05 38       	cpi	r16, 0x85	; 133
    1dde:	11 05       	cpc	r17, r1
    1de0:	f0 f2       	brcs	.-68     	; 0x1d9e <ymodem_receive+0x44>
    1de2:	41 e0       	ldi	r20, 0x01	; 1
        }
      }
    }

    // Data is in. Check the packet number and CRC
    if (shortPacketMode) {
    1de4:	e5 e4       	ldi	r30, 0x45	; 69
    1de6:	f1 e0       	ldi	r31, 0x01	; 1
    1de8:	20 e0       	ldi	r18, 0x00	; 0
    1dea:	30 e0       	ldi	r19, 0x00	; 0
static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    crc = _crc_xmodem_update(crc, *ptr++);
    1dec:	81 91       	ld	r24, Z+
    1dee:	38 27       	eor	r19, r24
    1df0:	03 2e       	mov	r0, r19
    1df2:	02 94       	swap	r0
    1df4:	90 2d       	mov	r25, r0
    1df6:	9f 70       	andi	r25, 0x0F	; 15
    1df8:	93 27       	eor	r25, r19
    1dfa:	83 2f       	mov	r24, r19
    1dfc:	80 25       	eor	r24, r0
    1dfe:	88 0f       	add	r24, r24
    1e00:	80 7e       	andi	r24, 0xE0	; 224
    1e02:	98 27       	eor	r25, r24
    1e04:	80 2d       	mov	r24, r0
    1e06:	83 27       	eor	r24, r19
    1e08:	80 7f       	andi	r24, 0xF0	; 240
    1e0a:	86 95       	lsr	r24
    1e0c:	03 2e       	mov	r0, r19
    1e0e:	00 0c       	add	r0, r0
    1e10:	88 1f       	adc	r24, r24
    1e12:	36 95       	lsr	r19
    1e14:	36 95       	lsr	r19
    1e16:	36 95       	lsr	r19
    1e18:	3f 71       	andi	r19, 0x1F	; 31
    1e1a:	38 27       	eor	r19, r24
    1e1c:	32 27       	eor	r19, r18
    1e1e:	29 2f       	mov	r18, r25

static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    1e20:	b1 e0       	ldi	r27, 0x01	; 1
    1e22:	e5 3c       	cpi	r30, 0xC5	; 197
    1e24:	fb 07       	cpc	r31, r27
    1e26:	11 f7       	brne	.-60     	; 0x1dec <ymodem_receive+0x92>

      resendPacket = 1;
      canAttempts++;
      usart_transmit(NACK);
    
    } else if (shortPacketMode && ((ymodemBuffer[131] != (unsigned char)(crc >> 8)) || (ymodemBuffer[132] != (unsigned char)(crc)))) {
    1e28:	80 81       	ld	r24, Z
    1e2a:	83 17       	cp	r24, r19
    1e2c:	21 f4       	brne	.+8      	; 0x1e36 <ymodem_receive+0xdc>
    1e2e:	81 81       	ldd	r24, Z+1	; 0x01
    1e30:	82 17       	cp	r24, r18
    1e32:	09 f4       	brne	.+2      	; 0x1e36 <ymodem_receive+0xdc>
    1e34:	4b c0       	rjmp	.+150    	; 0x1ecc <ymodem_receive+0x172>
    
    } else if(ymodemBuffer[1] + ymodemBuffer[2] != 0xFF) { //(ymodemReceivedPackets + 1 != ymodemBuffer[1]) ||
      // Packet number not correct, could be a bad packet no. if it passed the above test

      resendPacket = 1;
      canAttempts++;
    1e36:	e3 94       	inc	r14
      usart_transmit(NACK);
    1e38:	85 e1       	ldi	r24, 0x15	; 21
    1e3a:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
      canAttempts = 0;
      usart_transmit(ACK);

    }

    if(canAttempts > YMODEM_MAX_RETRIES) {
    1e3e:	f3 e0       	ldi	r31, 0x03	; 3
    1e40:	fe 15       	cp	r31, r14
    1e42:	08 f0       	brcs	.+2      	; 0x1e46 <ymodem_receive+0xec>
    1e44:	a9 cf       	rjmp	.-174    	; 0x1d98 <ymodem_receive+0x3e>
      usart_transmit(YMODEM_CAN);
    1e46:	88 e1       	ldi	r24, 0x18	; 24
    1e48:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
      usart_transmit(YMODEM_CAN);
    1e4c:	88 e1       	ldi	r24, 0x18	; 24
    1e4e:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    1e52:	82 e0       	ldi	r24, 0x02	; 2
    1e54:	e9 c0       	rjmp	.+466    	; 0x2028 <ymodem_receive+0x2ce>
          if(canAttempts > YMODEM_MAX_RETRIES) { 
            // Something's not working. Cancel by returning.
            usart_transmit(YMODEM_CAN);
            usart_transmit(YMODEM_CAN);

            return 1;
    1e56:	ee 24       	eor	r14, r14
    1e58:	ff 24       	eor	r15, r15
    1e5a:	f3 94       	inc	r15
  // Receive data till end of transmission is received
  do {

    uint8_t shortPacketMode = 0;

    for(uint16_t i=0; i<BYTES_PER_PACKET_1K;i++) {
    1e5c:	0f 5f       	subi	r16, 0xFF	; 255
    1e5e:	1f 4f       	sbci	r17, 0xFF	; 255
    1e60:	a4 e0       	ldi	r26, 0x04	; 4
    1e62:	05 30       	cpi	r16, 0x05	; 5
    1e64:	1a 07       	cpc	r17, r26
    1e66:	08 f4       	brcc	.+2      	; 0x1e6a <ymodem_receive+0x110>
    1e68:	b7 cf       	rjmp	.-146    	; 0x1dd8 <ymodem_receive+0x7e>
    1e6a:	4f 2d       	mov	r20, r15
        }
      }
    }

    // Data is in. Check the packet number and CRC
    if (shortPacketMode) {
    1e6c:	ff 20       	and	r15, r15
    1e6e:	09 f0       	breq	.+2      	; 0x1e72 <ymodem_receive+0x118>
    1e70:	b9 cf       	rjmp	.-142    	; 0x1de4 <ymodem_receive+0x8a>

static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    1e72:	e5 e4       	ldi	r30, 0x45	; 69
    1e74:	f1 e0       	ldi	r31, 0x01	; 1
    1e76:	20 e0       	ldi	r18, 0x00	; 0
    1e78:	30 e0       	ldi	r19, 0x00	; 0
    crc = _crc_xmodem_update(crc, *ptr++);
    1e7a:	81 91       	ld	r24, Z+
    1e7c:	38 27       	eor	r19, r24
    1e7e:	03 2e       	mov	r0, r19
    1e80:	02 94       	swap	r0
    1e82:	90 2d       	mov	r25, r0
    1e84:	9f 70       	andi	r25, 0x0F	; 15
    1e86:	93 27       	eor	r25, r19
    1e88:	83 2f       	mov	r24, r19
    1e8a:	80 25       	eor	r24, r0
    1e8c:	88 0f       	add	r24, r24
    1e8e:	80 7e       	andi	r24, 0xE0	; 224
    1e90:	98 27       	eor	r25, r24
    1e92:	80 2d       	mov	r24, r0
    1e94:	83 27       	eor	r24, r19
    1e96:	80 7f       	andi	r24, 0xF0	; 240
    1e98:	86 95       	lsr	r24
    1e9a:	03 2e       	mov	r0, r19
    1e9c:	00 0c       	add	r0, r0
    1e9e:	88 1f       	adc	r24, r24
    1ea0:	36 95       	lsr	r19
    1ea2:	36 95       	lsr	r19
    1ea4:	36 95       	lsr	r19
    1ea6:	3f 71       	andi	r19, 0x1F	; 31
    1ea8:	38 27       	eor	r19, r24
    1eaa:	32 27       	eor	r19, r18
    1eac:	29 2f       	mov	r18, r25

static uint16_t ymodem_calcrc(unsigned char *ptr, uint16_t count)
{
   uint16_t crc = 0;

  while (count > 0) { 
    1eae:	85 e0       	ldi	r24, 0x05	; 5
    1eb0:	e5 34       	cpi	r30, 0x45	; 69
    1eb2:	f8 07       	cpc	r31, r24
    1eb4:	11 f7       	brne	.-60     	; 0x1e7a <ymodem_receive+0x120>
    1eb6:	b8 cf       	rjmp	.-144    	; 0x1e28 <ymodem_receive+0xce>
      if(i==0) {
        if(ymodemBuffer[i] == YMODEM_SOH_128) {
          shortPacketMode = 1;
          canAttempts = 0;

        } else if (ymodemBuffer[i] == YMODEM_STX_1K) {       
    1eb8:	ee 24       	eor	r14, r14
    1eba:	ff 24       	eor	r15, r15
  // Receive data till end of transmission is received
  do {

    uint8_t shortPacketMode = 0;

    for(uint16_t i=0; i<BYTES_PER_PACKET_1K;i++) {
    1ebc:	0f 5f       	subi	r16, 0xFF	; 255
    1ebe:	1f 4f       	sbci	r17, 0xFF	; 255
    1ec0:	a4 e0       	ldi	r26, 0x04	; 4
    1ec2:	05 30       	cpi	r16, 0x05	; 5
    1ec4:	1a 07       	cpc	r17, r26
    1ec6:	08 f4       	brcc	.+2      	; 0x1eca <ymodem_receive+0x170>
    1ec8:	87 cf       	rjmp	.-242    	; 0x1dd8 <ymodem_receive+0x7e>
    1eca:	cf cf       	rjmp	.-98     	; 0x1e6a <ymodem_receive+0x110>

      resendPacket = 1;
      canAttempts++;
      usart_transmit(NACK);
    
    } else if(ymodemBuffer[1] + ymodemBuffer[2] != 0xFF) { //(ymodemReceivedPackets + 1 != ymodemBuffer[1]) ||
    1ecc:	30 91 43 01 	lds	r19, 0x0143
    1ed0:	20 91 44 01 	lds	r18, 0x0144
    1ed4:	83 2f       	mov	r24, r19
    1ed6:	90 e0       	ldi	r25, 0x00	; 0
    1ed8:	82 0f       	add	r24, r18
    1eda:	91 1d       	adc	r25, r1
    1edc:	8f 3f       	cpi	r24, 0xFF	; 255
    1ede:	91 05       	cpc	r25, r1
    1ee0:	09 f0       	breq	.+2      	; 0x1ee4 <ymodem_receive+0x18a>
    1ee2:	a9 cf       	rjmp	.-174    	; 0x1e36 <ymodem_receive+0xdc>

      resendPacket = 1;
      canAttempts++;
      usart_transmit(NACK);
    
    } else if (ymodemReceivedPackets == 0 && ymodemBuffer[1] == 0) {
    1ee4:	80 91 4b 05 	lds	r24, 0x054B
    1ee8:	90 91 4c 05 	lds	r25, 0x054C
    1eec:	89 2b       	or	r24, r25
    1eee:	09 f0       	breq	.+2      	; 0x1ef2 <ymodem_receive+0x198>
    1ef0:	ad c0       	rjmp	.+346    	; 0x204c <ymodem_receive+0x2f2>
    1ef2:	33 23       	and	r19, r19
    1ef4:	09 f0       	breq	.+2      	; 0x1ef8 <ymodem_receive+0x19e>
    1ef6:	aa c0       	rjmp	.+340    	; 0x204c <ymodem_receive+0x2f2>
    1ef8:	23 e0       	ldi	r18, 0x03	; 3
    1efa:	30 e0       	ldi	r19, 0x00	; 0
    1efc:	06 c0       	rjmp	.+12     	; 0x1f0a <ymodem_receive+0x1b0>
               * we have a NULL filename and the first few digits of
               * the file length are zero, we'll call it empty.
               */
      // Find the filename length
      uint16_t fileDatPos = 0;
      for (fileDatPos = 3; fileDatPos < 1026; fileDatPos++) {
    1efe:	2f 5f       	subi	r18, 0xFF	; 255
    1f00:	3f 4f       	sbci	r19, 0xFF	; 255
    1f02:	94 e0       	ldi	r25, 0x04	; 4
    1f04:	22 30       	cpi	r18, 0x02	; 2
    1f06:	39 07       	cpc	r19, r25
    1f08:	51 f0       	breq	.+20     	; 0x1f1e <ymodem_receive+0x1c4>
        if (ymodemBuffer[fileDatPos] == '\0') {
    1f0a:	f9 01       	movw	r30, r18
    1f0c:	ee 5b       	subi	r30, 0xBE	; 190
    1f0e:	fe 4f       	sbci	r31, 0xFE	; 254
    1f10:	80 81       	ld	r24, Z
    1f12:	88 23       	and	r24, r24
    1f14:	a1 f7       	brne	.-24     	; 0x1efe <ymodem_receive+0x1a4>
          break;
        }
      }

      if(fileDatPos < 7) {
    1f16:	27 30       	cpi	r18, 0x07	; 7
    1f18:	31 05       	cpc	r19, r1
    1f1a:	08 f4       	brcc	.+2      	; 0x1f1e <ymodem_receive+0x1c4>
    1f1c:	10 c1       	rjmp	.+544    	; 0x213e <ymodem_receive+0x3e4>
      }
      
      // To tell you the truth, I really don't care what the incoming filename is
      // No parsing of the filename done here.

      fileDatPos++; // Need one more increment to get away from the last NULL
    1f1e:	e9 01       	movw	r28, r18
    1f20:	21 96       	adiw	r28, 0x01	; 1

      // strip leading spaces if any
    	while(ymodemBuffer[fileDatPos] == ' ' && fileDatPos < 1026) {
    1f22:	fe 01       	movw	r30, r28
    1f24:	ee 5b       	subi	r30, 0xBE	; 190
    1f26:	fe 4f       	sbci	r31, 0xFE	; 254
    1f28:	80 81       	ld	r24, Z
    1f2a:	80 32       	cpi	r24, 0x20	; 32
    1f2c:	a1 f4       	brne	.+40     	; 0x1f56 <ymodem_receive+0x1fc>
    1f2e:	a4 e0       	ldi	r26, 0x04	; 4
    1f30:	c2 30       	cpi	r28, 0x02	; 2
    1f32:	da 07       	cpc	r29, r26
    1f34:	80 f4       	brcc	.+32     	; 0x1f56 <ymodem_receive+0x1fc>
    1f36:	f9 01       	movw	r30, r18
    1f38:	ec 5b       	subi	r30, 0xBC	; 188
    1f3a:	fe 4f       	sbci	r31, 0xFE	; 254
    1f3c:	05 c0       	rjmp	.+10     	; 0x1f48 <ymodem_receive+0x1ee>
    1f3e:	31 96       	adiw	r30, 0x01	; 1
    1f40:	b4 e0       	ldi	r27, 0x04	; 4
    1f42:	c2 30       	cpi	r28, 0x02	; 2
    1f44:	db 07       	cpc	r29, r27
    1f46:	20 f4       	brcc	.+8      	; 0x1f50 <ymodem_receive+0x1f6>
        fileDatPos++;
    1f48:	21 96       	adiw	r28, 0x01	; 1
      // No parsing of the filename done here.

      fileDatPos++; // Need one more increment to get away from the last NULL

      // strip leading spaces if any
    	while(ymodemBuffer[fileDatPos] == ' ' && fileDatPos < 1026) {
    1f4a:	80 81       	ld	r24, Z
    1f4c:	80 32       	cpi	r24, 0x20	; 32
    1f4e:	b9 f3       	breq	.-18     	; 0x1f3e <ymodem_receive+0x1e4>
    1f50:	fe 01       	movw	r30, r28
    1f52:	ee 5b       	subi	r30, 0xBE	; 190
    1f54:	fe 4f       	sbci	r31, 0xFE	; 254
        fileDatPos++;
      }

      *fileSize = 0;
    1f56:	d3 01       	movw	r26, r6
    1f58:	1d 92       	st	X+, r1
    1f5a:	1d 92       	st	X+, r1
    1f5c:	1d 92       	st	X+, r1
    1f5e:	1c 92       	st	X, r1
    1f60:	13 97       	sbiw	r26, 0x03	; 3
      while((ymodemBuffer[fileDatPos] != ' ' && ymodemBuffer[fileDatPos] != '\0') && fileDatPos < 1026) {
    1f62:	80 81       	ld	r24, Z
    1f64:	80 32       	cpi	r24, 0x20	; 32
    1f66:	09 f4       	brne	.+2      	; 0x1f6a <ymodem_receive+0x210>
    1f68:	f2 c0       	rjmp	.+484    	; 0x214e <ymodem_receive+0x3f4>
    1f6a:	88 23       	and	r24, r24
    1f6c:	09 f4       	brne	.+2      	; 0x1f70 <ymodem_receive+0x216>
    1f6e:	ef c0       	rjmp	.+478    	; 0x214e <ymodem_receive+0x3f4>
    1f70:	b4 e0       	ldi	r27, 0x04	; 4
    1f72:	c2 30       	cpi	r28, 0x02	; 2
    1f74:	db 07       	cpc	r29, r27
    1f76:	08 f0       	brcs	.+2      	; 0x1f7a <ymodem_receive+0x220>
    1f78:	ea c0       	rjmp	.+468    	; 0x214e <ymodem_receive+0x3f4>
    1f7a:	6f 01       	movw	r12, r30
    1f7c:	ee 24       	eor	r14, r14
    1f7e:	ff 24       	eor	r15, r15
    1f80:	87 01       	movw	r16, r14
    1f82:	09 c0       	rjmp	.+18     	; 0x1f96 <ymodem_receive+0x23c>
    1f84:	88 23       	and	r24, r24
    1f86:	59 f1       	breq	.+86     	; 0x1fde <ymodem_receive+0x284>
    1f88:	08 94       	sec
    1f8a:	c1 1c       	adc	r12, r1
    1f8c:	d1 1c       	adc	r13, r1
    1f8e:	f4 e0       	ldi	r31, 0x04	; 4
    1f90:	c2 30       	cpi	r28, 0x02	; 2
    1f92:	df 07       	cpc	r29, r31
    1f94:	20 f5       	brcc	.+72     	; 0x1fde <ymodem_receive+0x284>
        // Find the end of the file size! It's in decimal format, so convert as we go

        *fileSize *= 10;
    1f96:	c8 01       	movw	r24, r16
    1f98:	b7 01       	movw	r22, r14
    1f9a:	2a e0       	ldi	r18, 0x0A	; 10
    1f9c:	30 e0       	ldi	r19, 0x00	; 0
    1f9e:	40 e0       	ldi	r20, 0x00	; 0
    1fa0:	50 e0       	ldi	r21, 0x00	; 0
    1fa2:	0e 94 2b 21 	call	0x4256	; 0x4256 <__mulsi3>
    1fa6:	f3 01       	movw	r30, r6
    1fa8:	60 83       	st	Z, r22
    1faa:	71 83       	std	Z+1, r23	; 0x01
    1fac:	82 83       	std	Z+2, r24	; 0x02
    1fae:	93 83       	std	Z+3, r25	; 0x03
        *fileSize += (ymodemBuffer[fileDatPos] - '0');
    1fb0:	d6 01       	movw	r26, r12
    1fb2:	2c 91       	ld	r18, X
    1fb4:	30 e0       	ldi	r19, 0x00	; 0
    1fb6:	20 53       	subi	r18, 0x30	; 48
    1fb8:	30 40       	sbci	r19, 0x00	; 0
    1fba:	79 01       	movw	r14, r18
    1fbc:	00 27       	eor	r16, r16
    1fbe:	f7 fc       	sbrc	r15, 7
    1fc0:	00 95       	com	r16
    1fc2:	10 2f       	mov	r17, r16
    1fc4:	e6 0e       	add	r14, r22
    1fc6:	f7 1e       	adc	r15, r23
    1fc8:	08 1f       	adc	r16, r24
    1fca:	19 1f       	adc	r17, r25
    1fcc:	e0 82       	st	Z, r14
    1fce:	f1 82       	std	Z+1, r15	; 0x01
    1fd0:	02 83       	std	Z+2, r16	; 0x02
    1fd2:	13 83       	std	Z+3, r17	; 0x03

        fileDatPos++;
    1fd4:	21 96       	adiw	r28, 0x01	; 1
    	while(ymodemBuffer[fileDatPos] == ' ' && fileDatPos < 1026) {
        fileDatPos++;
      }

      *fileSize = 0;
      while((ymodemBuffer[fileDatPos] != ' ' && ymodemBuffer[fileDatPos] != '\0') && fileDatPos < 1026) {
    1fd6:	11 96       	adiw	r26, 0x01	; 1
    1fd8:	8c 91       	ld	r24, X
    1fda:	80 32       	cpi	r24, 0x20	; 32
    1fdc:	99 f6       	brne	.-90     	; 0x1f84 <ymodem_receive+0x22a>
        *fileSize += (ymodemBuffer[fileDatPos] - '0');

        fileDatPos++;
      }

      if(*fileSize == 0) {
    1fde:	e1 14       	cp	r14, r1
    1fe0:	f1 04       	cpc	r15, r1
    1fe2:	01 05       	cpc	r16, r1
    1fe4:	11 05       	cpc	r17, r1
    1fe6:	09 f4       	brne	.+2      	; 0x1fea <ymodem_receive+0x290>
    1fe8:	b2 c0       	rjmp	.+356    	; 0x214e <ymodem_receive+0x3f4>
        return 4;
      }

      resendPacket = 0;
      canAttempts = 0;
      usart_transmit(ACK);
    1fea:	86 e0       	ldi	r24, 0x06	; 6
    1fec:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
      usart_transmit('C');
    1ff0:	83 e4       	ldi	r24, 0x43	; 67
    1ff2:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>

    }

    if(canAttempts > YMODEM_MAX_RETRIES) {
      usart_transmit(YMODEM_CAN);
      usart_transmit(YMODEM_CAN);
    1ff6:	ee 24       	eor	r14, r14
    1ff8:	cf ce       	rjmp	.-610    	; 0x1d98 <ymodem_receive+0x3e>
          shortPacketMode = 0;
          canAttempts = 0;

        } else if(ymodemBuffer[i] == EOT) {
          // Download complete
          usart_transmit(ACK);
    1ffa:	86 e0       	ldi	r24, 0x06	; 6
    1ffc:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>

          // To gracefully finish a Ymodem program, should confirm null filename, but I'll blindly consider it done

          usart_transmit('C');
    2000:	83 e4       	ldi	r24, 0x43	; 67
    2002:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    2006:	20 e0       	ldi	r18, 0x00	; 0
    2008:	30 e0       	ldi	r19, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    200a:	45 e8       	ldi	r20, 0x85	; 133
    200c:	52 e0       	ldi	r21, 0x02	; 2
    200e:	ca 01       	movw	r24, r20
    2010:	01 97       	sbiw	r24, 0x01	; 1
    2012:	f1 f7       	brne	.-4      	; 0x2010 <ymodem_receive+0x2b6>
    2014:	2f 5f       	subi	r18, 0xFF	; 255
    2016:	3f 4f       	sbci	r19, 0xFF	; 255
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2018:	89 e0       	ldi	r24, 0x09	; 9
    201a:	24 3c       	cpi	r18, 0xC4	; 196
    201c:	38 07       	cpc	r19, r24
    201e:	b9 f7       	brne	.-18     	; 0x200e <ymodem_receive+0x2b4>
          _delay_ms(250); // is there a better way to delay here?
          usart_transmit(ACK);
    2020:	86 e0       	ldi	r24, 0x06	; 6
    2022:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    2026:	80 e0       	ldi	r24, 0x00	; 0
  } while(1);

  /* Should wait here to make sure no additional data is sent. If it is, then
  the ACK probably got garbled and the EOT has been sent again. */
  return 0;
}
    2028:	df 91       	pop	r29
    202a:	cf 91       	pop	r28
    202c:	1f 91       	pop	r17
    202e:	0f 91       	pop	r16
    2030:	ff 90       	pop	r15
    2032:	ef 90       	pop	r14
    2034:	df 90       	pop	r13
    2036:	cf 90       	pop	r12
    2038:	bf 90       	pop	r11
    203a:	af 90       	pop	r10
    203c:	9f 90       	pop	r9
    203e:	8f 90       	pop	r8
    2040:	7f 90       	pop	r7
    2042:	6f 90       	pop	r6
    2044:	5f 90       	pop	r5
    2046:	4f 90       	pop	r4
    2048:	3f 90       	pop	r3
    204a:	08 95       	ret
      resendPacket = 0;
      canAttempts = 0;
      usart_transmit(ACK);
      usart_transmit('C');

    } else if (lastPacketNum == ymodemBuffer[1]) {
    204c:	33 16       	cp	r3, r19
    204e:	09 f4       	brne	.+2      	; 0x2052 <ymodem_receive+0x2f8>
    2050:	6a c0       	rjmp	.+212    	; 0x2126 <ymodem_receive+0x3cc>
    
    } else {
      // That was a good packet

      // First, see how many bytes should be passed to the buff_func, then process them
      if(shortPacketMode) {
    2052:	44 23       	and	r20, r20
    2054:	a9 f5       	brne	.+106    	; 0x20c0 <ymodem_receive+0x366>
          (buffer_func)(&ymodemBuffer[3], 128);
          recdBytes += 128;

        }
      } else {
        if(recdBytes + 1024 > *fileSize) {
    2056:	e1 2c       	mov	r14, r1
    2058:	54 e0       	ldi	r21, 0x04	; 4
    205a:	f5 2e       	mov	r15, r21
    205c:	01 2d       	mov	r16, r1
    205e:	11 2d       	mov	r17, r1
    2060:	e8 0c       	add	r14, r8
    2062:	f9 1c       	adc	r15, r9
    2064:	0a 1d       	adc	r16, r10
    2066:	1b 1d       	adc	r17, r11
    2068:	f3 01       	movw	r30, r6
    206a:	80 81       	ld	r24, Z
    206c:	91 81       	ldd	r25, Z+1	; 0x01
    206e:	a2 81       	ldd	r26, Z+2	; 0x02
    2070:	b3 81       	ldd	r27, Z+3	; 0x03
    2072:	8e 15       	cp	r24, r14
    2074:	9f 05       	cpc	r25, r15
    2076:	a0 07       	cpc	r26, r16
    2078:	b1 07       	cpc	r27, r17
    207a:	08 f0       	brcs	.+2      	; 0x207e <ymodem_receive+0x324>
    207c:	4d c0       	rjmp	.+154    	; 0x2118 <ymodem_receive+0x3be>
          // Must be a half packet, do buffer_func accordingly
          uint16_t j = *fileSize - recdBytes;
    207e:	8c 01       	movw	r16, r24
    2080:	08 19       	sub	r16, r8
    2082:	19 09       	sbc	r17, r9
          (buffer_func)(&ymodemBuffer[3], j);
    2084:	85 e4       	ldi	r24, 0x45	; 69
    2086:	91 e0       	ldi	r25, 0x01	; 1
    2088:	b8 01       	movw	r22, r16
    208a:	f2 01       	movw	r30, r4
    208c:	09 95       	icall
          recdBytes += j;
    208e:	78 01       	movw	r14, r16
    2090:	00 e0       	ldi	r16, 0x00	; 0
    2092:	10 e0       	ldi	r17, 0x00	; 0
    2094:	e8 0c       	add	r14, r8
    2096:	f9 1c       	adc	r15, r9
    2098:	0a 1d       	adc	r16, r10
    209a:	1b 1d       	adc	r17, r11

        }
      }

      // Update some values so we are good for the next run
      lastPacketNum = ymodemBuffer[1];
    209c:	30 90 43 01 	lds	r3, 0x0143
      resendPacket = 0;
      ymodemReceivedPackets++;
    20a0:	80 91 4b 05 	lds	r24, 0x054B
    20a4:	90 91 4c 05 	lds	r25, 0x054C
    20a8:	01 96       	adiw	r24, 0x01	; 1
    20aa:	90 93 4c 05 	sts	0x054C, r25
    20ae:	80 93 4b 05 	sts	0x054B, r24
      canAttempts = 0;
      usart_transmit(ACK);
    20b2:	86 e0       	ldi	r24, 0x06	; 6
    20b4:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    20b8:	47 01       	movw	r8, r14
    20ba:	58 01       	movw	r10, r16

    }

    if(canAttempts > YMODEM_MAX_RETRIES) {
      usart_transmit(YMODEM_CAN);
      usart_transmit(YMODEM_CAN);
    20bc:	ee 24       	eor	r14, r14
    20be:	6c ce       	rjmp	.-808    	; 0x1d98 <ymodem_receive+0x3e>
    } else {
      // That was a good packet

      // First, see how many bytes should be passed to the buff_func, then process them
      if(shortPacketMode) {
        if(recdBytes + 128 > *fileSize) {
    20c0:	60 e8       	ldi	r22, 0x80	; 128
    20c2:	e6 2e       	mov	r14, r22
    20c4:	f1 2c       	mov	r15, r1
    20c6:	01 2d       	mov	r16, r1
    20c8:	11 2d       	mov	r17, r1
    20ca:	e8 0c       	add	r14, r8
    20cc:	f9 1c       	adc	r15, r9
    20ce:	0a 1d       	adc	r16, r10
    20d0:	1b 1d       	adc	r17, r11
    20d2:	f3 01       	movw	r30, r6
    20d4:	80 81       	ld	r24, Z
    20d6:	91 81       	ldd	r25, Z+1	; 0x01
    20d8:	a2 81       	ldd	r26, Z+2	; 0x02
    20da:	b3 81       	ldd	r27, Z+3	; 0x03
    20dc:	8e 15       	cp	r24, r14
    20de:	9f 05       	cpc	r25, r15
    20e0:	a0 07       	cpc	r26, r16
    20e2:	b1 07       	cpc	r27, r17
    20e4:	28 f5       	brcc	.+74     	; 0x2130 <ymodem_receive+0x3d6>
          // Must be a half packet, do buffer_func accordingly
          uint8_t j = *fileSize - recdBytes;
    20e6:	18 2f       	mov	r17, r24
    20e8:	18 19       	sub	r17, r8
          (buffer_func)(&ymodemBuffer[3], j);
    20ea:	85 e4       	ldi	r24, 0x45	; 69
    20ec:	91 e0       	ldi	r25, 0x01	; 1
    20ee:	61 2f       	mov	r22, r17
    20f0:	70 e0       	ldi	r23, 0x00	; 0
    20f2:	f2 01       	movw	r30, r4
    20f4:	09 95       	icall
          recdBytes += j;
    20f6:	d5 01       	movw	r26, r10
    20f8:	c4 01       	movw	r24, r8
    20fa:	81 0f       	add	r24, r17
    20fc:	91 1d       	adc	r25, r1
    20fe:	a1 1d       	adc	r26, r1
    2100:	b1 1d       	adc	r27, r1
    2102:	7c 01       	movw	r14, r24
    2104:	8d 01       	movw	r16, r26
    2106:	ca cf       	rjmp	.-108    	; 0x209c <ymodem_receive+0x342>
          usart_transmit(NACK);
          canAttempts++;

          if(canAttempts > YMODEM_MAX_RETRIES) { 
            // Something's not working. Cancel by returning.
            usart_transmit(YMODEM_CAN);
    2108:	88 e1       	ldi	r24, 0x18	; 24
    210a:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
            usart_transmit(YMODEM_CAN);
    210e:	88 e1       	ldi	r24, 0x18	; 24
    2110:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    2114:	81 e0       	ldi	r24, 0x01	; 1
    2116:	88 cf       	rjmp	.-240    	; 0x2028 <ymodem_receive+0x2ce>
          (buffer_func)(&ymodemBuffer[3], j);
          recdBytes += j;

        } else {
          // Do a 1k byte buffer func
          (buffer_func)(&ymodemBuffer[3], 1024);
    2118:	85 e4       	ldi	r24, 0x45	; 69
    211a:	91 e0       	ldi	r25, 0x01	; 1
    211c:	60 e0       	ldi	r22, 0x00	; 0
    211e:	74 e0       	ldi	r23, 0x04	; 4
    2120:	f2 01       	movw	r30, r4
    2122:	09 95       	icall
    2124:	bb cf       	rjmp	.-138    	; 0x209c <ymodem_receive+0x342>

    } else if (lastPacketNum == ymodemBuffer[1]) {
      // It's a repeated packet. We've already received it successfully though

      resendPacket = 0;
      canAttempts++;
    2126:	e3 94       	inc	r14
      usart_transmit(ACK);
    2128:	86 e0       	ldi	r24, 0x06	; 6
    212a:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    212e:	87 ce       	rjmp	.-754    	; 0x1e3e <ymodem_receive+0xe4>
          (buffer_func)(&ymodemBuffer[3], j);
          recdBytes += j;

        } else {
          // Do a 128 byte buffer func
          (buffer_func)(&ymodemBuffer[3], 128);
    2130:	85 e4       	ldi	r24, 0x45	; 69
    2132:	91 e0       	ldi	r25, 0x01	; 1
    2134:	60 e8       	ldi	r22, 0x80	; 128
    2136:	70 e0       	ldi	r23, 0x00	; 0
    2138:	f2 01       	movw	r30, r4
    213a:	09 95       	icall
    213c:	af cf       	rjmp	.-162    	; 0x209c <ymodem_receive+0x342>
      }

      if(fileDatPos < 7) {
        // Null filename?
        // May have to be careful here. Ymodem may use this to indicate no further files are coming. This may not be an error...
        usart_transmit(YMODEM_CAN);
    213e:	88 e1       	ldi	r24, 0x18	; 24
    2140:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
        usart_transmit(YMODEM_CAN);
    2144:	88 e1       	ldi	r24, 0x18	; 24
    2146:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    214a:	83 e0       	ldi	r24, 0x03	; 3
    214c:	6d cf       	rjmp	.-294    	; 0x2028 <ymodem_receive+0x2ce>
        fileDatPos++;
      }

      if(*fileSize == 0) {
        // 0 byte file. Hmmm...
        usart_transmit(YMODEM_CAN);
    214e:	88 e1       	ldi	r24, 0x18	; 24
    2150:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
        usart_transmit(YMODEM_CAN);
    2154:	88 e1       	ldi	r24, 0x18	; 24
    2156:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    215a:	84 e0       	ldi	r24, 0x04	; 4
    215c:	65 cf       	rjmp	.-310    	; 0x2028 <ymodem_receive+0x2ce>

0000215e <memory_init>:
FLASHADDR flashAddress;

void memory_init(void) {

  // Set up all of the pins
  MEMORY_DATA_DDR = 0xFF; // Data - don't assert the bus in case we're wrong about the mode
    215e:	8f ef       	ldi	r24, 0xFF	; 255
    2160:	84 b9       	out	0x04, r24	; 4
  SST_HI5_DDR = SST_HI5_MASK; // MA address lines. 
    2162:	8f e7       	ldi	r24, 0x7F	; 127
    2164:	87 b9       	out	0x07, r24	; 7

  SST_CS_DDR |= (1 << SST_CS);
    2166:	57 9a       	sbi	0x0a, 7	; 10
  SST_OE_DDR |= (1 << SST_OE);
    2168:	54 9a       	sbi	0x0a, 4	; 10
  SST_WE_DDR |= (1 << SST_WE);
    216a:	0c 9a       	sbi	0x01, 4	; 1

  LATCH_OE_DDR |= (1 << LATCH_OE);
    216c:	0d 9a       	sbi	0x01, 5	; 1
  LATCH_CLK_LO8_DDR |= (1 << LATCH_CLK_LO8); 
    216e:	52 9a       	sbi	0x0a, 2	; 10
  LATCH_CLK_MID6_DDR |= (1 << LATCH_CLK_MID6);
    2170:	0a 9a       	sbi	0x01, 2	; 1

  SRAM_ADDR13_14_DDR |= SRAM_ADDR13_14_MASK;
    2172:	81 b1       	in	r24, 0x01	; 1
    2174:	83 60       	ori	r24, 0x03	; 3
    2176:	81 b9       	out	0x01, r24	; 1
  SRAM_CS_DDR |= (1 << SRAM_CS);
    2178:	0f 9a       	sbi	0x01, 7	; 1
  SRAM_WE_DDR |= (1 << SRAM_WE);
    217a:	53 9a       	sbi	0x0a, 3	; 10
  SRAM_OE_DDR |= (1 << SRAM_OE);
    217c:	54 9a       	sbi	0x0a, 4	; 10

  // Pull up inverted control pins
  SST_CS_PORT |= (1 << SST_CS);
    217e:	5f 9a       	sbi	0x0b, 7	; 11
  SST_OE_PORT |= (1 << SST_OE);
    2180:	5c 9a       	sbi	0x0b, 4	; 11
  SST_WE_PORT |= (1 << SST_WE);
    2182:	14 9a       	sbi	0x02, 4	; 2
  LATCH_OE_PORT |= (1 << LATCH_OE);
    2184:	15 9a       	sbi	0x02, 5	; 2
  SRAM_CS_PORT |= (1 << SRAM_CS);
    2186:	17 9a       	sbi	0x02, 7	; 2
  SRAM_WE_PORT |= (1 << SRAM_WE);
    2188:	5b 9a       	sbi	0x0b, 3	; 11
  SRAM_OE_PORT |= (1 << SRAM_OE);
    218a:	5c 9a       	sbi	0x0b, 4	; 11

  SST_MUX_DDR |= (1 << SST_MUX);
    218c:	56 9a       	sbi	0x0a, 6	; 10
  SST_MUX_PORT |= (1 << SST_MUX);
    218e:	5e 9a       	sbi	0x0b, 6	; 11
}
    2190:	08 95       	ret

00002192 <sst_flash_read_byte>:

uint8_t sst_flash_read_byte(FLASHADDR address, uint8_t *returnData) {
    2192:	fa 01       	movw	r30, r20

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2194:	65 b9       	out	0x05, r22	; 5
  _NOP();
    2196:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2198:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    219a:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    219c:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    219e:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    21a0:	75 b9       	out	0x05, r23	; 5
  _NOP();
    21a2:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    21a4:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    21a6:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    21a8:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    21aa:	00 00       	nop

  // Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    21ac:	2e e0       	ldi	r18, 0x0E	; 14
    21ae:	96 95       	lsr	r25
    21b0:	87 95       	ror	r24
    21b2:	77 95       	ror	r23
    21b4:	67 95       	ror	r22
    21b6:	2a 95       	dec	r18
    21b8:	d1 f7       	brne	.-12     	; 0x21ae <sst_flash_read_byte+0x1c>
    21ba:	68 b9       	out	0x08, r22	; 8
  _NOP();
    21bc:	00 00       	nop

  // Set read mode by pulling OE and CS low, after making data pins an input!
  MEMORY_DATA_DDR = 0x00; // Make data lines an input
    21be:	14 b8       	out	0x04, r1	; 4
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    21c0:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    21c2:	00 00       	nop
  SST_CS_PORT &= ~(1 << SST_CS);
    21c4:	5f 98       	cbi	0x0b, 7	; 11
  SST_OE_PORT &= ~(1 << SST_OE);
    21c6:	5c 98       	cbi	0x0b, 4	; 11
	...
  _NOP();
  _NOP();
  _NOP();

  // Read the data in!
  *returnData = MEMORY_DATA_PIN;
    21d0:	83 b1       	in	r24, 0x03	; 3
    21d2:	80 83       	st	Z, r24

  // Pull OE and CS up again, and make PORTB outputs again
  SST_OE_PORT |= (1 << SST_OE);
    21d4:	5c 9a       	sbi	0x0b, 4	; 11
  SST_CS_PORT |= (1 << SST_CS);
    21d6:	5f 9a       	sbi	0x0b, 7	; 11
  LATCH_OE_PORT |= (1 << LATCH_OE);
    21d8:	15 9a       	sbi	0x02, 5	; 2
  MEMORY_DATA_DDR = 0xFF;
    21da:	8f ef       	ldi	r24, 0xFF	; 255
    21dc:	84 b9       	out	0x04, r24	; 4

  return 0;
}
    21de:	80 e0       	ldi	r24, 0x00	; 0
    21e0:	08 95       	ret

000021e2 <sst_flash_write_sub_byte>:

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    21e2:	65 b9       	out	0x05, r22	; 5
  _NOP();
    21e4:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    21e6:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    21e8:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    21ea:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    21ec:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    21ee:	75 b9       	out	0x05, r23	; 5
  _NOP();
    21f0:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    21f2:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    21f4:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    21f6:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    21f8:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    21fa:	3e e0       	ldi	r19, 0x0E	; 14
    21fc:	96 95       	lsr	r25
    21fe:	87 95       	ror	r24
    2200:	77 95       	ror	r23
    2202:	67 95       	ror	r22
    2204:	3a 95       	dec	r19
    2206:	d1 f7       	brne	.-12     	; 0x21fc <sst_flash_write_sub_byte+0x1a>
    2208:	68 b9       	out	0x08, r22	; 8
  _NOP();
    220a:	00 00       	nop
  _NOP();
    220c:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    220e:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2210:	00 00       	nop
  _NOP();
    2212:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    2214:	45 b9       	out	0x05, r20	; 5
  _NOP();
    2216:	00 00       	nop
  _NOP();
    2218:	00 00       	nop
  _NOP();
    221a:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    221c:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    221e:	00 00       	nop
  _NOP();
    2220:	00 00       	nop
  _NOP();
    2222:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    2224:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    2226:	00 00       	nop
  _NOP();
    2228:	00 00       	nop
  _NOP();
    222a:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    222c:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    222e:	00 00       	nop
  _NOP();
    2230:	00 00       	nop
  _NOP();
    2232:	00 00       	nop

  return 0;
}
    2234:	80 e0       	ldi	r24, 0x00	; 0
    2236:	08 95       	ret

00002238 <sst_flash_sector_erase>:

uint8_t sst_flash_sector_erase(FLASHADDR addressA12andup) {
  
  return 0;
}
    2238:	80 e0       	ldi	r24, 0x00	; 0
    223a:	08 95       	ret

0000223c <sram_read_byte>:
  return chipID;
}

// *********************************** SRAM funcs ************************************************

uint8_t sram_read_byte(uint16_t address, uint8_t *returnData) {
    223c:	fb 01       	movw	r30, r22

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = (uint8_t)(address);
    223e:	85 b9       	out	0x05, r24	; 5
  _NOP();
    2240:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2242:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2244:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2246:	5a 98       	cbi	0x0b, 2	; 11

  MEMORY_DATA_PORT = (uint8_t)(address >> 8);
    2248:	95 b9       	out	0x05, r25	; 5
  _NOP();
    224a:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    224c:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    224e:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2250:	12 98       	cbi	0x02, 2	; 2

  SRAM_ADDR13_14_PORT = (SRAM_ADDR13_14_PORT & (~SRAM_ADDR13_14_MASK)) | ((uint8_t)(address >> 13) & SRAM_ADDR13_14_MASK);
    2252:	82 b1       	in	r24, 0x02	; 2
    2254:	92 95       	swap	r25
    2256:	96 95       	lsr	r25
    2258:	93 70       	andi	r25, 0x03	; 3
    225a:	8c 7f       	andi	r24, 0xFC	; 252
    225c:	89 2b       	or	r24, r25
    225e:	82 b9       	out	0x02, r24	; 2

  // Set read mode by pulling OE and CS low, after making data pins an input!
  MEMORY_DATA_DDR = 0x00; // Make data lines an input
    2260:	14 b8       	out	0x04, r1	; 4
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2262:	15 98       	cbi	0x02, 5	; 2

  SRAM_CS_PORT &= ~(1 << SRAM_CS);
    2264:	17 98       	cbi	0x02, 7	; 2
  SRAM_OE_PORT &= ~(1 << SRAM_OE);
    2266:	5c 98       	cbi	0x0b, 4	; 11
	...
  // 2 x NOP required to meet the 55ns data retrieval period
  _NOP();
  _NOP();

  // Read the data in!
  *returnData = MEMORY_DATA_PIN;
    2270:	83 b1       	in	r24, 0x03	; 3
    2272:	80 83       	st	Z, r24

  // Pull OE and CS up again, and make PORTB outputs again
  SRAM_OE_PORT |= (1 << SRAM_OE);
    2274:	5c 9a       	sbi	0x0b, 4	; 11
  SRAM_CS_PORT |= (1 << SRAM_CS);
    2276:	17 9a       	sbi	0x02, 7	; 2
  LATCH_OE_PORT |= (1 << LATCH_OE);
    2278:	15 9a       	sbi	0x02, 5	; 2
  MEMORY_DATA_DDR = 0xFF;
    227a:	8f ef       	ldi	r24, 0xFF	; 255
    227c:	84 b9       	out	0x04, r24	; 4

  return 0;
}
    227e:	80 e0       	ldi	r24, 0x00	; 0
    2280:	08 95       	ret

00002282 <sram_write_byte>:

uint8_t sram_write_byte(uint16_t address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = (uint8_t)(address);
    2282:	85 b9       	out	0x05, r24	; 5
  _NOP();
    2284:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2286:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2288:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    228a:	5a 98       	cbi	0x0b, 2	; 11

  MEMORY_DATA_PORT = (uint8_t)(address >> 8);
    228c:	95 b9       	out	0x05, r25	; 5
  _NOP();
    228e:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2290:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2292:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2294:	12 98       	cbi	0x02, 2	; 2

  SRAM_ADDR13_14_PORT = (SRAM_ADDR13_14_PORT & (~SRAM_ADDR13_14_MASK)) | ((uint8_t)(address >> 13) & SRAM_ADDR13_14_MASK);
    2296:	82 b1       	in	r24, 0x02	; 2
    2298:	92 95       	swap	r25
    229a:	96 95       	lsr	r25
    229c:	93 70       	andi	r25, 0x03	; 3
    229e:	8c 7f       	andi	r24, 0xFC	; 252
    22a0:	89 2b       	or	r24, r25
    22a2:	82 b9       	out	0x02, r24	; 2

  MEMORY_DATA_PORT = writeData;
    22a4:	65 b9       	out	0x05, r22	; 5

  // Set read mode by pulling OE and CS low, after making data pins an input!
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    22a6:	15 98       	cbi	0x02, 5	; 2
_NOP(); // Test NOPS to find out why writing isn't working
    22a8:	00 00       	nop
_NOP();
    22aa:	00 00       	nop
SRAM_OE_PORT |= (1 << SRAM_OE);
    22ac:	5c 9a       	sbi	0x0b, 4	; 11
_NOP();
    22ae:	00 00       	nop
_NOP();
    22b0:	00 00       	nop
  SRAM_CS_PORT &= ~(1 << SRAM_CS);
    22b2:	17 98       	cbi	0x02, 7	; 2
_NOP(); // Test NOPS to find out why writing isn't working
    22b4:	00 00       	nop
_NOP();
    22b6:	00 00       	nop
  SRAM_WE_PORT &= ~(1 << SRAM_WE);
    22b8:	5b 98       	cbi	0x0b, 3	; 11
	...
  _NOP();
  _NOP();
_NOP(); // Test NOPS to find out why writing isn't working
_NOP();
  // Pull OE and CS up again, and make PORTB outputs again
  SRAM_WE_PORT |= (1 << SRAM_WE);
    22c6:	5b 9a       	sbi	0x0b, 3	; 11
  SRAM_CS_PORT |= (1 << SRAM_CS);
    22c8:	17 9a       	sbi	0x02, 7	; 2
_NOP(); // Test NOPS to find out why writing isn't working
    22ca:	00 00       	nop
_NOP();
    22cc:	00 00       	nop
  LATCH_OE_PORT |= (1 << LATCH_OE);
    22ce:	15 9a       	sbi	0x02, 5	; 2

  return 0;
}
    22d0:	80 e0       	ldi	r24, 0x00	; 0
    22d2:	08 95       	ret

000022d4 <sst_flash_write_byte>:
  MEMORY_DATA_DDR = 0xFF;

  return 0;
}

uint8_t sst_flash_write_byte(FLASHADDR address, uint8_t writeData) {
    22d4:	ef 92       	push	r14
    22d6:	ff 92       	push	r15
    22d8:	0f 93       	push	r16
    22da:	1f 93       	push	r17
    22dc:	df 93       	push	r29
    22de:	cf 93       	push	r28
    22e0:	00 d0       	rcall	.+0      	; 0x22e2 <sst_flash_write_byte+0xe>
    22e2:	00 d0       	rcall	.+0      	; 0x22e4 <sst_flash_write_byte+0x10>
    22e4:	cd b7       	in	r28, 0x3d	; 61
    22e6:	de b7       	in	r29, 0x3e	; 62
    22e8:	69 83       	std	Y+1, r22	; 0x01
    22ea:	7a 83       	std	Y+2, r23	; 0x02
    22ec:	8b 83       	std	Y+3, r24	; 0x03
    22ee:	9c 83       	std	Y+4, r25	; 0x04

  // Select the correct chip  & put the chip into write mode. We'll use the /WE control method
//  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
//  _NOP();
  SST_CS_PORT &= ~(1 << SST_CS);
    22f0:	5f 98       	cbi	0x0b, 7	; 11

  sst_flash_command_sequence((address.address8[2] >> 3), SST_CMDMODE_BYTE);
    22f2:	2b 81       	ldd	r18, Y+3	; 0x03
    22f4:	26 95       	lsr	r18
    22f6:	26 95       	lsr	r18
    22f8:	26 95       	lsr	r18

static void sst_flash_command_sequence(uint8_t chipNum, uint8_t mode) {

  FLASHADDR address;
  // First 0x5555, 0xAA
  address.address32 = 0x5555;
    22fa:	35 e5       	ldi	r19, 0x55	; 85
    22fc:	e3 2e       	mov	r14, r19
    22fe:	35 e5       	ldi	r19, 0x55	; 85
    2300:	f3 2e       	mov	r15, r19
    2302:	01 2d       	mov	r16, r1
    2304:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 3);
    2306:	30 e0       	ldi	r19, 0x00	; 0
    2308:	22 0f       	add	r18, r18
    230a:	33 1f       	adc	r19, r19
    230c:	22 0f       	add	r18, r18
    230e:	33 1f       	adc	r19, r19
    2310:	22 0f       	add	r18, r18
    2312:	33 1f       	adc	r19, r19
    2314:	02 2f       	mov	r16, r18

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2316:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    2318:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    231a:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    231c:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    231e:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2320:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2322:	f5 b8       	out	0x05, r15	; 5
  _NOP();
    2324:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2326:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2328:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    232a:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    232c:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    232e:	8e e0       	ldi	r24, 0x0E	; 14
    2330:	16 95       	lsr	r17
    2332:	07 95       	ror	r16
    2334:	f7 94       	ror	r15
    2336:	e7 94       	ror	r14
    2338:	8a 95       	dec	r24
    233a:	d1 f7       	brne	.-12     	; 0x2330 <sst_flash_write_byte+0x5c>
    233c:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    233e:	00 00       	nop
  _NOP();
    2340:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2342:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2344:	00 00       	nop
  _NOP();
    2346:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    2348:	8a ea       	ldi	r24, 0xAA	; 170
    234a:	85 b9       	out	0x05, r24	; 5
  _NOP();
    234c:	00 00       	nop
  _NOP();
    234e:	00 00       	nop
  _NOP();
    2350:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    2352:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    2354:	00 00       	nop
  _NOP();
    2356:	00 00       	nop
  _NOP();
    2358:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    235a:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    235c:	00 00       	nop
  _NOP();
    235e:	00 00       	nop
  _NOP();
    2360:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    2362:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    2364:	00 00       	nop
  _NOP();
    2366:	00 00       	nop
  _NOP();
    2368:	00 00       	nop
  address.address32 = 0x5555;
  address.address8[2] |= (chipNum << 3);
  sst_flash_write_sub_byte(address, 0xAA);

  // Now 0x2AAA,0x55
  address.address32 = 0x2AAAA;
    236a:	0a ea       	ldi	r16, 0xAA	; 170
    236c:	e0 2e       	mov	r14, r16
    236e:	0a ea       	ldi	r16, 0xAA	; 170
    2370:	f0 2e       	mov	r15, r16
    2372:	02 e0       	ldi	r16, 0x02	; 2
    2374:	00 2f       	mov	r16, r16
    2376:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 3);
    2378:	02 2f       	mov	r16, r18
    237a:	02 60       	ori	r16, 0x02	; 2

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    237c:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    237e:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2380:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2382:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2384:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2386:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2388:	f5 b8       	out	0x05, r15	; 5
  _NOP();
    238a:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    238c:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    238e:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2390:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    2392:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2394:	be e0       	ldi	r27, 0x0E	; 14
    2396:	16 95       	lsr	r17
    2398:	07 95       	ror	r16
    239a:	f7 94       	ror	r15
    239c:	e7 94       	ror	r14
    239e:	ba 95       	dec	r27
    23a0:	d1 f7       	brne	.-12     	; 0x2396 <sst_flash_write_byte+0xc2>
    23a2:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    23a4:	00 00       	nop
  _NOP();
    23a6:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    23a8:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    23aa:	00 00       	nop
  _NOP();
    23ac:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    23ae:	85 e5       	ldi	r24, 0x55	; 85
    23b0:	85 b9       	out	0x05, r24	; 5
  _NOP();
    23b2:	00 00       	nop
  _NOP();
    23b4:	00 00       	nop
  _NOP();
    23b6:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    23b8:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    23ba:	00 00       	nop
  _NOP();
    23bc:	00 00       	nop
  _NOP();
    23be:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    23c0:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    23c2:	00 00       	nop
  _NOP();
    23c4:	00 00       	nop
  _NOP();
    23c6:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    23c8:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    23ca:	00 00       	nop
  _NOP();
    23cc:	00 00       	nop
  _NOP();
    23ce:	00 00       	nop
  address.address32 = 0x2AAAA;
  address.address8[2] |= (chipNum << 3);
  sst_flash_write_sub_byte(address, 0x55);

  // Now 0x5555 again
  address.address32 = 0x5555;
    23d0:	a5 e5       	ldi	r26, 0x55	; 85
    23d2:	ea 2e       	mov	r14, r26
    23d4:	a5 e5       	ldi	r26, 0x55	; 85
    23d6:	fa 2e       	mov	r15, r26
    23d8:	01 2d       	mov	r16, r1
    23da:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 3);
    23dc:	02 2f       	mov	r16, r18

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    23de:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    23e0:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    23e2:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    23e4:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    23e6:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    23e8:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    23ea:	f5 b8       	out	0x05, r15	; 5
  _NOP();
    23ec:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    23ee:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    23f0:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    23f2:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    23f4:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    23f6:	fe e0       	ldi	r31, 0x0E	; 14
    23f8:	16 95       	lsr	r17
    23fa:	07 95       	ror	r16
    23fc:	f7 94       	ror	r15
    23fe:	e7 94       	ror	r14
    2400:	fa 95       	dec	r31
    2402:	d1 f7       	brne	.-12     	; 0x23f8 <sst_flash_write_byte+0x124>
    2404:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    2406:	00 00       	nop
  _NOP();
    2408:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    240a:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    240c:	00 00       	nop
  _NOP();
    240e:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    2410:	80 ea       	ldi	r24, 0xA0	; 160
    2412:	85 b9       	out	0x05, r24	; 5
  _NOP();
    2414:	00 00       	nop
  _NOP();
    2416:	00 00       	nop
  _NOP();
    2418:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    241a:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    241c:	00 00       	nop
  _NOP();
    241e:	00 00       	nop
  _NOP();
    2420:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    2422:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    2424:	00 00       	nop
  _NOP();
    2426:	00 00       	nop
  _NOP();
    2428:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    242a:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    242c:	00 00       	nop
  _NOP();
    242e:	00 00       	nop
  _NOP();
    2430:	00 00       	nop
  SST_CS_PORT &= ~(1 << SST_CS);

  sst_flash_command_sequence((address.address8[2] >> 3), SST_CMDMODE_BYTE);

  // Now finally! The data!
  sst_flash_write_sub_byte(address, writeData);
    2432:	89 81       	ldd	r24, Y+1	; 0x01
    2434:	9a 81       	ldd	r25, Y+2	; 0x02
    2436:	ab 81       	ldd	r26, Y+3	; 0x03
    2438:	bc 81       	ldd	r27, Y+4	; 0x04

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    243a:	85 b9       	out	0x05, r24	; 5
  _NOP();
    243c:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    243e:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2440:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2442:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2444:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2446:	95 b9       	out	0x05, r25	; 5
  _NOP();
    2448:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    244a:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    244c:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    244e:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    2450:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2452:	ee e0       	ldi	r30, 0x0E	; 14
    2454:	b6 95       	lsr	r27
    2456:	a7 95       	ror	r26
    2458:	97 95       	ror	r25
    245a:	87 95       	ror	r24
    245c:	ea 95       	dec	r30
    245e:	d1 f7       	brne	.-12     	; 0x2454 <sst_flash_write_byte+0x180>
    2460:	88 b9       	out	0x08, r24	; 8
  _NOP();
    2462:	00 00       	nop
  _NOP();
    2464:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2466:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2468:	00 00       	nop
  _NOP();
    246a:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    246c:	45 b9       	out	0x05, r20	; 5
  _NOP();
    246e:	00 00       	nop
  _NOP();
    2470:	00 00       	nop
  _NOP();
    2472:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    2474:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    2476:	00 00       	nop
  _NOP();
    2478:	00 00       	nop
  _NOP();
    247a:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    247c:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    247e:	00 00       	nop
  _NOP();
    2480:	00 00       	nop
  _NOP();
    2482:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    2484:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    2486:	00 00       	nop
  _NOP();
    2488:	00 00       	nop
  _NOP();
    248a:	00 00       	nop

  // Now finally! The data!
  sst_flash_write_sub_byte(address, writeData);

  // Move to #DATA polling by pulling CS high again
  SST_CS_PORT |= (1 << SST_CS);
    248c:	5f 9a       	sbi	0x0b, 7	; 11

  // Wait until it's applied...
  // Data polling didn't seem to work, bit toggling bit looks okay...
  uint8_t i,j;
  sst_flash_read_byte(address, &i);
    248e:	89 81       	ldd	r24, Y+1	; 0x01
    2490:	9a 81       	ldd	r25, Y+2	; 0x02
    2492:	ab 81       	ldd	r26, Y+3	; 0x03
    2494:	bc 81       	ldd	r27, Y+4	; 0x04

uint8_t sst_flash_read_byte(FLASHADDR address, uint8_t *returnData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2496:	85 b9       	out	0x05, r24	; 5
  _NOP();
    2498:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    249a:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    249c:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    249e:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    24a0:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    24a2:	95 b9       	out	0x05, r25	; 5
  _NOP();
    24a4:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    24a6:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    24a8:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    24aa:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    24ac:	00 00       	nop

  // Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    24ae:	7e e0       	ldi	r23, 0x0E	; 14
    24b0:	b6 95       	lsr	r27
    24b2:	a7 95       	ror	r26
    24b4:	97 95       	ror	r25
    24b6:	87 95       	ror	r24
    24b8:	7a 95       	dec	r23
    24ba:	d1 f7       	brne	.-12     	; 0x24b0 <sst_flash_write_byte+0x1dc>
    24bc:	88 b9       	out	0x08, r24	; 8
  _NOP();
    24be:	00 00       	nop

  // Set read mode by pulling OE and CS low, after making data pins an input!
  MEMORY_DATA_DDR = 0x00; // Make data lines an input
    24c0:	14 b8       	out	0x04, r1	; 4
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    24c2:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    24c4:	00 00       	nop
  SST_CS_PORT &= ~(1 << SST_CS);
    24c6:	5f 98       	cbi	0x0b, 7	; 11
  SST_OE_PORT &= ~(1 << SST_OE);
    24c8:	5c 98       	cbi	0x0b, 4	; 11
	...
  _NOP();
  _NOP();
  _NOP();

  // Read the data in!
  *returnData = MEMORY_DATA_PIN;
    24d2:	23 b1       	in	r18, 0x03	; 3

  // Pull OE and CS up again, and make PORTB outputs again
  SST_OE_PORT |= (1 << SST_OE);
    24d4:	5c 9a       	sbi	0x0b, 4	; 11
  SST_CS_PORT |= (1 << SST_CS);
    24d6:	5f 9a       	sbi	0x0b, 7	; 11
  LATCH_OE_PORT |= (1 << LATCH_OE);
    24d8:	15 9a       	sbi	0x02, 5	; 2
  MEMORY_DATA_DDR = 0xFF;
    24da:	8f ef       	ldi	r24, 0xFF	; 255
    24dc:	84 b9       	out	0x04, r24	; 4

  // Wait until it's applied...
  // Data polling didn't seem to work, bit toggling bit looks okay...
  uint8_t i,j;
  sst_flash_read_byte(address, &i);
  i &= 0x40;
    24de:	20 74       	andi	r18, 0x40	; 64

  // Pull OE and CS up again, and make PORTB outputs again
  SST_OE_PORT |= (1 << SST_OE);
  SST_CS_PORT |= (1 << SST_CS);
  LATCH_OE_PORT |= (1 << LATCH_OE);
  MEMORY_DATA_DDR = 0xFF;
    24e0:	3f ef       	ldi	r19, 0xFF	; 255
    24e2:	01 c0       	rjmp	.+2      	; 0x24e6 <sst_flash_write_byte+0x212>
  i &= 0x40;
  do {
    j = i;
    sst_flash_read_byte(address, &i);
    i &= 0x40;
  } while(i != j);
    24e4:	28 2f       	mov	r18, r24
  uint8_t i,j;
  sst_flash_read_byte(address, &i);
  i &= 0x40;
  do {
    j = i;
    sst_flash_read_byte(address, &i);
    24e6:	89 81       	ldd	r24, Y+1	; 0x01
    24e8:	9a 81       	ldd	r25, Y+2	; 0x02
    24ea:	ab 81       	ldd	r26, Y+3	; 0x03
    24ec:	bc 81       	ldd	r27, Y+4	; 0x04

uint8_t sst_flash_read_byte(FLASHADDR address, uint8_t *returnData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    24ee:	85 b9       	out	0x05, r24	; 5
  _NOP();
    24f0:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    24f2:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    24f4:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    24f6:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    24f8:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    24fa:	95 b9       	out	0x05, r25	; 5
  _NOP();
    24fc:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    24fe:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2500:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2502:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    2504:	00 00       	nop

  // Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2506:	6e e0       	ldi	r22, 0x0E	; 14
    2508:	b6 95       	lsr	r27
    250a:	a7 95       	ror	r26
    250c:	97 95       	ror	r25
    250e:	87 95       	ror	r24
    2510:	6a 95       	dec	r22
    2512:	d1 f7       	brne	.-12     	; 0x2508 <sst_flash_write_byte+0x234>
    2514:	88 b9       	out	0x08, r24	; 8
  _NOP();
    2516:	00 00       	nop

  // Set read mode by pulling OE and CS low, after making data pins an input!
  MEMORY_DATA_DDR = 0x00; // Make data lines an input
    2518:	14 b8       	out	0x04, r1	; 4
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    251a:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    251c:	00 00       	nop
  SST_CS_PORT &= ~(1 << SST_CS);
    251e:	5f 98       	cbi	0x0b, 7	; 11
  SST_OE_PORT &= ~(1 << SST_OE);
    2520:	5c 98       	cbi	0x0b, 4	; 11
	...
  _NOP();
  _NOP();
  _NOP();

  // Read the data in!
  *returnData = MEMORY_DATA_PIN;
    252a:	83 b1       	in	r24, 0x03	; 3

  // Pull OE and CS up again, and make PORTB outputs again
  SST_OE_PORT |= (1 << SST_OE);
    252c:	5c 9a       	sbi	0x0b, 4	; 11
  SST_CS_PORT |= (1 << SST_CS);
    252e:	5f 9a       	sbi	0x0b, 7	; 11
  LATCH_OE_PORT |= (1 << LATCH_OE);
    2530:	15 9a       	sbi	0x02, 5	; 2
  MEMORY_DATA_DDR = 0xFF;
    2532:	34 b9       	out	0x04, r19	; 4
  sst_flash_read_byte(address, &i);
  i &= 0x40;
  do {
    j = i;
    sst_flash_read_byte(address, &i);
    i &= 0x40;
    2534:	80 74       	andi	r24, 0x40	; 64
  } while(i != j);
    2536:	82 17       	cp	r24, r18
    2538:	a9 f6       	brne	.-86     	; 0x24e4 <sst_flash_write_byte+0x210>

  // Do this twice in case the last time was a fluke...
  sst_flash_read_byte(address, &i);
    253a:	89 81       	ldd	r24, Y+1	; 0x01
    253c:	9a 81       	ldd	r25, Y+2	; 0x02
    253e:	ab 81       	ldd	r26, Y+3	; 0x03
    2540:	bc 81       	ldd	r27, Y+4	; 0x04

uint8_t sst_flash_read_byte(FLASHADDR address, uint8_t *returnData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2542:	85 b9       	out	0x05, r24	; 5
  _NOP();
    2544:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2546:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2548:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    254a:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    254c:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    254e:	95 b9       	out	0x05, r25	; 5
  _NOP();
    2550:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2552:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2554:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2556:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    2558:	00 00       	nop

  // Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    255a:	5e e0       	ldi	r21, 0x0E	; 14
    255c:	b6 95       	lsr	r27
    255e:	a7 95       	ror	r26
    2560:	97 95       	ror	r25
    2562:	87 95       	ror	r24
    2564:	5a 95       	dec	r21
    2566:	d1 f7       	brne	.-12     	; 0x255c <sst_flash_write_byte+0x288>
    2568:	88 b9       	out	0x08, r24	; 8
  _NOP();
    256a:	00 00       	nop

  // Set read mode by pulling OE and CS low, after making data pins an input!
  MEMORY_DATA_DDR = 0x00; // Make data lines an input
    256c:	14 b8       	out	0x04, r1	; 4
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    256e:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2570:	00 00       	nop
  SST_CS_PORT &= ~(1 << SST_CS);
    2572:	5f 98       	cbi	0x0b, 7	; 11
  SST_OE_PORT &= ~(1 << SST_OE);
    2574:	5c 98       	cbi	0x0b, 4	; 11
	...
  _NOP();
  _NOP();
  _NOP();

  // Read the data in!
  *returnData = MEMORY_DATA_PIN;
    257e:	23 b1       	in	r18, 0x03	; 3

  // Pull OE and CS up again, and make PORTB outputs again
  SST_OE_PORT |= (1 << SST_OE);
    2580:	5c 9a       	sbi	0x0b, 4	; 11
  SST_CS_PORT |= (1 << SST_CS);
    2582:	5f 9a       	sbi	0x0b, 7	; 11
  LATCH_OE_PORT |= (1 << LATCH_OE);
    2584:	15 9a       	sbi	0x02, 5	; 2
  MEMORY_DATA_DDR = 0xFF;
    2586:	8f ef       	ldi	r24, 0xFF	; 255
    2588:	84 b9       	out	0x04, r24	; 4
    i &= 0x40;
  } while(i != j);

  // Do this twice in case the last time was a fluke...
  sst_flash_read_byte(address, &i);
  i &= 0x40;
    258a:	20 74       	andi	r18, 0x40	; 64

  // Pull OE and CS up again, and make PORTB outputs again
  SST_OE_PORT |= (1 << SST_OE);
  SST_CS_PORT |= (1 << SST_CS);
  LATCH_OE_PORT |= (1 << LATCH_OE);
  MEMORY_DATA_DDR = 0xFF;
    258c:	3f ef       	ldi	r19, 0xFF	; 255
    258e:	01 c0       	rjmp	.+2      	; 0x2592 <sst_flash_write_byte+0x2be>
  i &= 0x40;
  do {
    j = i;
    sst_flash_read_byte(address, &i);
    i &= 0x40;
  } while(i != j);
    2590:	28 2f       	mov	r18, r24
  // Do this twice in case the last time was a fluke...
  sst_flash_read_byte(address, &i);
  i &= 0x40;
  do {
    j = i;
    sst_flash_read_byte(address, &i);
    2592:	89 81       	ldd	r24, Y+1	; 0x01
    2594:	9a 81       	ldd	r25, Y+2	; 0x02
    2596:	ab 81       	ldd	r26, Y+3	; 0x03
    2598:	bc 81       	ldd	r27, Y+4	; 0x04

uint8_t sst_flash_read_byte(FLASHADDR address, uint8_t *returnData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    259a:	85 b9       	out	0x05, r24	; 5
  _NOP();
    259c:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    259e:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    25a0:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    25a2:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    25a4:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    25a6:	95 b9       	out	0x05, r25	; 5
  _NOP();
    25a8:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    25aa:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    25ac:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    25ae:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    25b0:	00 00       	nop

  // Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    25b2:	4e e0       	ldi	r20, 0x0E	; 14
    25b4:	b6 95       	lsr	r27
    25b6:	a7 95       	ror	r26
    25b8:	97 95       	ror	r25
    25ba:	87 95       	ror	r24
    25bc:	4a 95       	dec	r20
    25be:	d1 f7       	brne	.-12     	; 0x25b4 <sst_flash_write_byte+0x2e0>
    25c0:	88 b9       	out	0x08, r24	; 8
  _NOP();
    25c2:	00 00       	nop

  // Set read mode by pulling OE and CS low, after making data pins an input!
  MEMORY_DATA_DDR = 0x00; // Make data lines an input
    25c4:	14 b8       	out	0x04, r1	; 4
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    25c6:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    25c8:	00 00       	nop
  SST_CS_PORT &= ~(1 << SST_CS);
    25ca:	5f 98       	cbi	0x0b, 7	; 11
  SST_OE_PORT &= ~(1 << SST_OE);
    25cc:	5c 98       	cbi	0x0b, 4	; 11
	...
  _NOP();
  _NOP();
  _NOP();

  // Read the data in!
  *returnData = MEMORY_DATA_PIN;
    25d6:	83 b1       	in	r24, 0x03	; 3

  // Pull OE and CS up again, and make PORTB outputs again
  SST_OE_PORT |= (1 << SST_OE);
    25d8:	5c 9a       	sbi	0x0b, 4	; 11
  SST_CS_PORT |= (1 << SST_CS);
    25da:	5f 9a       	sbi	0x0b, 7	; 11
  LATCH_OE_PORT |= (1 << LATCH_OE);
    25dc:	15 9a       	sbi	0x02, 5	; 2
  MEMORY_DATA_DDR = 0xFF;
    25de:	34 b9       	out	0x04, r19	; 4
  sst_flash_read_byte(address, &i);
  i &= 0x40;
  do {
    j = i;
    sst_flash_read_byte(address, &i);
    i &= 0x40;
    25e0:	80 74       	andi	r24, 0x40	; 64
  } while(i != j);
    25e2:	82 17       	cp	r24, r18
    25e4:	a9 f6       	brne	.-86     	; 0x2590 <sst_flash_write_byte+0x2bc>
//  _delay_us(20);

  return 0;
}
    25e6:	80 e0       	ldi	r24, 0x00	; 0
    25e8:	0f 90       	pop	r0
    25ea:	0f 90       	pop	r0
    25ec:	0f 90       	pop	r0
    25ee:	0f 90       	pop	r0
    25f0:	cf 91       	pop	r28
    25f2:	df 91       	pop	r29
    25f4:	1f 91       	pop	r17
    25f6:	0f 91       	pop	r16
    25f8:	ff 90       	pop	r15
    25fa:	ef 90       	pop	r14
    25fc:	08 95       	ret

000025fe <sst_flash_chip_erase>:
uint8_t sst_flash_sector_erase(FLASHADDR addressA12andup) {
  
  return 0;
}

uint8_t sst_flash_chip_erase(uint8_t chipNum) {
    25fe:	ef 92       	push	r14
    2600:	ff 92       	push	r15
    2602:	0f 93       	push	r16
    2604:	1f 93       	push	r17

  // Select the correct chip  & put the chip into write mode. We'll use the /WE control method
  SST_CS_PORT &= ~(1 << SST_CS);
    2606:	5f 98       	cbi	0x0b, 7	; 11

static void sst_flash_command_sequence(uint8_t chipNum, uint8_t mode) {

  FLASHADDR address;
  // First 0x5555, 0xAA
  address.address32 = 0x5555;
    2608:	65 e5       	ldi	r22, 0x55	; 85
    260a:	e6 2e       	mov	r14, r22
    260c:	65 e5       	ldi	r22, 0x55	; 85
    260e:	f6 2e       	mov	r15, r22
    2610:	01 2d       	mov	r16, r1
    2612:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 3);
    2614:	90 e0       	ldi	r25, 0x00	; 0
    2616:	88 0f       	add	r24, r24
    2618:	99 1f       	adc	r25, r25
    261a:	88 0f       	add	r24, r24
    261c:	99 1f       	adc	r25, r25
    261e:	88 0f       	add	r24, r24
    2620:	99 1f       	adc	r25, r25
    2622:	38 2f       	mov	r19, r24
    2624:	08 2f       	mov	r16, r24

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2626:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    2628:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    262a:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    262c:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    262e:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2630:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2632:	f5 b8       	out	0x05, r15	; 5
  _NOP();
    2634:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2636:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2638:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    263a:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    263c:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    263e:	4e e0       	ldi	r20, 0x0E	; 14
    2640:	16 95       	lsr	r17
    2642:	07 95       	ror	r16
    2644:	f7 94       	ror	r15
    2646:	e7 94       	ror	r14
    2648:	4a 95       	dec	r20
    264a:	d1 f7       	brne	.-12     	; 0x2640 <sst_flash_chip_erase+0x42>
    264c:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    264e:	00 00       	nop
  _NOP();
    2650:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2652:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2654:	00 00       	nop
  _NOP();
    2656:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    2658:	4a ea       	ldi	r20, 0xAA	; 170
    265a:	45 b9       	out	0x05, r20	; 5
  _NOP();
    265c:	00 00       	nop
  _NOP();
    265e:	00 00       	nop
  _NOP();
    2660:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    2662:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    2664:	00 00       	nop
  _NOP();
    2666:	00 00       	nop
  _NOP();
    2668:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    266a:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    266c:	00 00       	nop
  _NOP();
    266e:	00 00       	nop
  _NOP();
    2670:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    2672:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    2674:	00 00       	nop
  _NOP();
    2676:	00 00       	nop
  _NOP();
    2678:	00 00       	nop
  address.address32 = 0x5555;
  address.address8[2] |= (chipNum << 3);
  sst_flash_write_sub_byte(address, 0xAA);

  // Now 0x2AAA,0x55
  address.address32 = 0x2AAAA;
    267a:	2a ea       	ldi	r18, 0xAA	; 170
    267c:	e2 2e       	mov	r14, r18
    267e:	2a ea       	ldi	r18, 0xAA	; 170
    2680:	f2 2e       	mov	r15, r18
    2682:	22 e0       	ldi	r18, 0x02	; 2
    2684:	02 2f       	mov	r16, r18
    2686:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 3);
    2688:	32 60       	ori	r19, 0x02	; 2
    268a:	03 2f       	mov	r16, r19

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    268c:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    268e:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2690:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2692:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2694:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2696:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2698:	f5 b8       	out	0x05, r15	; 5
  _NOP();
    269a:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    269c:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    269e:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    26a0:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    26a2:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    26a4:	9e e0       	ldi	r25, 0x0E	; 14
    26a6:	16 95       	lsr	r17
    26a8:	07 95       	ror	r16
    26aa:	f7 94       	ror	r15
    26ac:	e7 94       	ror	r14
    26ae:	9a 95       	dec	r25
    26b0:	d1 f7       	brne	.-12     	; 0x26a6 <sst_flash_chip_erase+0xa8>
    26b2:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    26b4:	00 00       	nop
  _NOP();
    26b6:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    26b8:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    26ba:	00 00       	nop
  _NOP();
    26bc:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    26be:	55 e5       	ldi	r21, 0x55	; 85
    26c0:	55 b9       	out	0x05, r21	; 5
  _NOP();
    26c2:	00 00       	nop
  _NOP();
    26c4:	00 00       	nop
  _NOP();
    26c6:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    26c8:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    26ca:	00 00       	nop
  _NOP();
    26cc:	00 00       	nop
  _NOP();
    26ce:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    26d0:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    26d2:	00 00       	nop
  _NOP();
    26d4:	00 00       	nop
  _NOP();
    26d6:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    26d8:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    26da:	00 00       	nop
  _NOP();
    26dc:	00 00       	nop
  _NOP();
    26de:	00 00       	nop
  address.address32 = 0x2AAAA;
  address.address8[2] |= (chipNum << 3);
  sst_flash_write_sub_byte(address, 0x55);

  // Now 0x5555 again
  address.address32 = 0x5555;
    26e0:	b5 e5       	ldi	r27, 0x55	; 85
    26e2:	eb 2e       	mov	r14, r27
    26e4:	b5 e5       	ldi	r27, 0x55	; 85
    26e6:	fb 2e       	mov	r15, r27
    26e8:	01 2d       	mov	r16, r1
    26ea:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 3);
    26ec:	08 2f       	mov	r16, r24

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    26ee:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    26f0:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    26f2:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    26f4:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    26f6:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    26f8:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    26fa:	f5 b8       	out	0x05, r15	; 5
  _NOP();
    26fc:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    26fe:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2700:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2702:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    2704:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2706:	ae e0       	ldi	r26, 0x0E	; 14
    2708:	16 95       	lsr	r17
    270a:	07 95       	ror	r16
    270c:	f7 94       	ror	r15
    270e:	e7 94       	ror	r14
    2710:	aa 95       	dec	r26
    2712:	d1 f7       	brne	.-12     	; 0x2708 <sst_flash_chip_erase+0x10a>
    2714:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    2716:	00 00       	nop
  _NOP();
    2718:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    271a:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    271c:	00 00       	nop
  _NOP();
    271e:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    2720:	20 e8       	ldi	r18, 0x80	; 128
    2722:	25 b9       	out	0x05, r18	; 5
  _NOP();
    2724:	00 00       	nop
  _NOP();
    2726:	00 00       	nop
  _NOP();
    2728:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    272a:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    272c:	00 00       	nop
  _NOP();
    272e:	00 00       	nop
  _NOP();
    2730:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    2732:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    2734:	00 00       	nop
  _NOP();
    2736:	00 00       	nop
  _NOP();
    2738:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    273a:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    273c:	00 00       	nop
  _NOP();
    273e:	00 00       	nop
  _NOP();
    2740:	00 00       	nop

static void sst_flash_command_sequence(uint8_t chipNum, uint8_t mode) {

  FLASHADDR address;
  // First 0x5555, 0xAA
  address.address32 = 0x5555;
    2742:	f5 e5       	ldi	r31, 0x55	; 85
    2744:	ef 2e       	mov	r14, r31
    2746:	f5 e5       	ldi	r31, 0x55	; 85
    2748:	ff 2e       	mov	r15, r31
    274a:	01 2d       	mov	r16, r1
    274c:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 3);
    274e:	08 2f       	mov	r16, r24

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2750:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    2752:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2754:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2756:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2758:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    275a:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    275c:	f5 b8       	out	0x05, r15	; 5
  _NOP();
    275e:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2760:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2762:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2764:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    2766:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2768:	ee e0       	ldi	r30, 0x0E	; 14
    276a:	16 95       	lsr	r17
    276c:	07 95       	ror	r16
    276e:	f7 94       	ror	r15
    2770:	e7 94       	ror	r14
    2772:	ea 95       	dec	r30
    2774:	d1 f7       	brne	.-12     	; 0x276a <sst_flash_chip_erase+0x16c>
    2776:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    2778:	00 00       	nop
  _NOP();
    277a:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    277c:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    277e:	00 00       	nop
  _NOP();
    2780:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    2782:	45 b9       	out	0x05, r20	; 5
  _NOP();
    2784:	00 00       	nop
  _NOP();
    2786:	00 00       	nop
  _NOP();
    2788:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    278a:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    278c:	00 00       	nop
  _NOP();
    278e:	00 00       	nop
  _NOP();
    2790:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    2792:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    2794:	00 00       	nop
  _NOP();
    2796:	00 00       	nop
  _NOP();
    2798:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    279a:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    279c:	00 00       	nop
  _NOP();
    279e:	00 00       	nop
  _NOP();
    27a0:	00 00       	nop
  address.address32 = 0x5555;
  address.address8[2] |= (chipNum << 3);
  sst_flash_write_sub_byte(address, 0xAA);

  // Now 0x2AAA,0x55
  address.address32 = 0x2AAAA;
    27a2:	7a ea       	ldi	r23, 0xAA	; 170
    27a4:	e7 2e       	mov	r14, r23
    27a6:	7a ea       	ldi	r23, 0xAA	; 170
    27a8:	f7 2e       	mov	r15, r23
    27aa:	72 e0       	ldi	r23, 0x02	; 2
    27ac:	07 2f       	mov	r16, r23
    27ae:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 3);
    27b0:	03 2f       	mov	r16, r19

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    27b2:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    27b4:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    27b6:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    27b8:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    27ba:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    27bc:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    27be:	f5 b8       	out	0x05, r15	; 5
  _NOP();
    27c0:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    27c2:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    27c4:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    27c6:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    27c8:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    27ca:	6e e0       	ldi	r22, 0x0E	; 14
    27cc:	16 95       	lsr	r17
    27ce:	07 95       	ror	r16
    27d0:	f7 94       	ror	r15
    27d2:	e7 94       	ror	r14
    27d4:	6a 95       	dec	r22
    27d6:	d1 f7       	brne	.-12     	; 0x27cc <sst_flash_chip_erase+0x1ce>
    27d8:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    27da:	00 00       	nop
  _NOP();
    27dc:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    27de:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    27e0:	00 00       	nop
  _NOP();
    27e2:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    27e4:	55 b9       	out	0x05, r21	; 5
  _NOP();
    27e6:	00 00       	nop
  _NOP();
    27e8:	00 00       	nop
  _NOP();
    27ea:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    27ec:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    27ee:	00 00       	nop
  _NOP();
    27f0:	00 00       	nop
  _NOP();
    27f2:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    27f4:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    27f6:	00 00       	nop
  _NOP();
    27f8:	00 00       	nop
  _NOP();
    27fa:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    27fc:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    27fe:	00 00       	nop
  _NOP();
    2800:	00 00       	nop
  _NOP();
    2802:	00 00       	nop
  address.address32 = 0x2AAAA;
  address.address8[2] |= (chipNum << 3);
  sst_flash_write_sub_byte(address, 0x55);

  // Now 0x5555 again
  address.address32 = 0x5555;
    2804:	55 e5       	ldi	r21, 0x55	; 85
    2806:	e5 2e       	mov	r14, r21
    2808:	55 e5       	ldi	r21, 0x55	; 85
    280a:	f5 2e       	mov	r15, r21
    280c:	01 2d       	mov	r16, r1
    280e:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 3);
    2810:	08 2f       	mov	r16, r24

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2812:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    2814:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2816:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2818:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    281a:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    281c:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    281e:	f5 b8       	out	0x05, r15	; 5
  _NOP();
    2820:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2822:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2824:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2826:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    2828:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    282a:	4e e0       	ldi	r20, 0x0E	; 14
    282c:	16 95       	lsr	r17
    282e:	07 95       	ror	r16
    2830:	f7 94       	ror	r15
    2832:	e7 94       	ror	r14
    2834:	4a 95       	dec	r20
    2836:	d1 f7       	brne	.-12     	; 0x282c <sst_flash_chip_erase+0x22e>
    2838:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    283a:	00 00       	nop
  _NOP();
    283c:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    283e:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2840:	00 00       	nop
  _NOP();
    2842:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    2844:	80 e1       	ldi	r24, 0x10	; 16
    2846:	85 b9       	out	0x05, r24	; 5
  _NOP();
    2848:	00 00       	nop
  _NOP();
    284a:	00 00       	nop
  _NOP();
    284c:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    284e:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    2850:	00 00       	nop
  _NOP();
    2852:	00 00       	nop
  _NOP();
    2854:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    2856:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    2858:	00 00       	nop
  _NOP();
    285a:	00 00       	nop
  _NOP();
    285c:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    285e:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    2860:	00 00       	nop
  _NOP();
    2862:	00 00       	nop
  _NOP();
    2864:	00 00       	nop

  sst_flash_command_sequence(chipNum, SST_CMDMODE_CHIP1);
  sst_flash_command_sequence(chipNum, SST_CMDMODE_CHIP2);

  // Exit chip erase mode.
  SST_CS_PORT |= (1 << SST_CS);
    2866:	5f 9a       	sbi	0x0b, 7	; 11
    2868:	20 e0       	ldi	r18, 0x00	; 0
    286a:	30 e0       	ldi	r19, 0x00	; 0
    286c:	45 e8       	ldi	r20, 0x85	; 133
    286e:	52 e0       	ldi	r21, 0x02	; 2
    2870:	ca 01       	movw	r24, r20
    2872:	01 97       	sbiw	r24, 0x01	; 1
    2874:	f1 f7       	brne	.-4      	; 0x2872 <sst_flash_chip_erase+0x274>
    2876:	2f 5f       	subi	r18, 0xFF	; 255
    2878:	3f 4f       	sbci	r19, 0xFF	; 255
    287a:	83 e0       	ldi	r24, 0x03	; 3
    287c:	28 3e       	cpi	r18, 0xE8	; 232
    287e:	38 07       	cpc	r19, r24
    2880:	b9 f7       	brne	.-18     	; 0x2870 <sst_flash_chip_erase+0x272>

  _delay_ms(100); // Wait period for a whole chip erase

  return 0;
}
    2882:	80 e0       	ldi	r24, 0x00	; 0
    2884:	1f 91       	pop	r17
    2886:	0f 91       	pop	r16
    2888:	ff 90       	pop	r15
    288a:	ef 90       	pop	r14
    288c:	08 95       	ret

0000288e <sst_read_softwareID>:

/*
  Returns the hex byte ID of the SST chip
*/
uint8_t sst_read_softwareID(uint8_t chipNum) {
    288e:	ef 92       	push	r14
    2890:	ff 92       	push	r15
    2892:	0f 93       	push	r16
    2894:	1f 93       	push	r17

  uint8_t chipID;
  FLASHADDR address;
  address.address32 = 1;
    2896:	41 e0       	ldi	r20, 0x01	; 1
    2898:	50 e0       	ldi	r21, 0x00	; 0
    289a:	60 e0       	ldi	r22, 0x00	; 0
    289c:	70 e0       	ldi	r23, 0x00	; 0
  address.address8[2] = chipNum << 3;
    289e:	68 2f       	mov	r22, r24
    28a0:	66 0f       	add	r22, r22
    28a2:	66 0f       	add	r22, r22
    28a4:	66 0f       	add	r22, r22

  // Put the chip into ID mode. We'll use the /WE control method

  SST_CS_PORT &= ~(1 << SST_CS);
    28a6:	5f 98       	cbi	0x0b, 7	; 11

static void sst_flash_command_sequence(uint8_t chipNum, uint8_t mode) {

  FLASHADDR address;
  // First 0x5555, 0xAA
  address.address32 = 0x5555;
    28a8:	35 e5       	ldi	r19, 0x55	; 85
    28aa:	e3 2e       	mov	r14, r19
    28ac:	35 e5       	ldi	r19, 0x55	; 85
    28ae:	f3 2e       	mov	r15, r19
    28b0:	01 2d       	mov	r16, r1
    28b2:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 3);
    28b4:	90 e0       	ldi	r25, 0x00	; 0
    28b6:	88 0f       	add	r24, r24
    28b8:	99 1f       	adc	r25, r25
    28ba:	88 0f       	add	r24, r24
    28bc:	99 1f       	adc	r25, r25
    28be:	88 0f       	add	r24, r24
    28c0:	99 1f       	adc	r25, r25
    28c2:	38 2f       	mov	r19, r24
    28c4:	08 2f       	mov	r16, r24

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    28c6:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    28c8:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    28ca:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    28cc:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    28ce:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    28d0:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    28d2:	f5 b8       	out	0x05, r15	; 5
  _NOP();
    28d4:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    28d6:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    28d8:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    28da:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    28dc:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    28de:	9e e0       	ldi	r25, 0x0E	; 14
    28e0:	16 95       	lsr	r17
    28e2:	07 95       	ror	r16
    28e4:	f7 94       	ror	r15
    28e6:	e7 94       	ror	r14
    28e8:	9a 95       	dec	r25
    28ea:	d1 f7       	brne	.-12     	; 0x28e0 <sst_read_softwareID+0x52>
    28ec:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    28ee:	00 00       	nop
  _NOP();
    28f0:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    28f2:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    28f4:	00 00       	nop
  _NOP();
    28f6:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    28f8:	fa ea       	ldi	r31, 0xAA	; 170
    28fa:	f5 b9       	out	0x05, r31	; 5
  _NOP();
    28fc:	00 00       	nop
  _NOP();
    28fe:	00 00       	nop
  _NOP();
    2900:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    2902:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    2904:	00 00       	nop
  _NOP();
    2906:	00 00       	nop
  _NOP();
    2908:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    290a:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    290c:	00 00       	nop
  _NOP();
    290e:	00 00       	nop
  _NOP();
    2910:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    2912:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    2914:	00 00       	nop
  _NOP();
    2916:	00 00       	nop
  _NOP();
    2918:	00 00       	nop
  address.address32 = 0x5555;
  address.address8[2] |= (chipNum << 3);
  sst_flash_write_sub_byte(address, 0xAA);

  // Now 0x2AAA,0x55
  address.address32 = 0x2AAAA;
    291a:	0a ea       	ldi	r16, 0xAA	; 170
    291c:	e0 2e       	mov	r14, r16
    291e:	0a ea       	ldi	r16, 0xAA	; 170
    2920:	f0 2e       	mov	r15, r16
    2922:	02 e0       	ldi	r16, 0x02	; 2
    2924:	00 2f       	mov	r16, r16
    2926:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 3);
    2928:	32 60       	ori	r19, 0x02	; 2
    292a:	03 2f       	mov	r16, r19

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    292c:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    292e:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2930:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2932:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2934:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2936:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2938:	f5 b8       	out	0x05, r15	; 5
  _NOP();
    293a:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    293c:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    293e:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2940:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    2942:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2944:	be e0       	ldi	r27, 0x0E	; 14
    2946:	16 95       	lsr	r17
    2948:	07 95       	ror	r16
    294a:	f7 94       	ror	r15
    294c:	e7 94       	ror	r14
    294e:	ba 95       	dec	r27
    2950:	d1 f7       	brne	.-12     	; 0x2946 <sst_read_softwareID+0xb8>
    2952:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    2954:	00 00       	nop
  _NOP();
    2956:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2958:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    295a:	00 00       	nop
  _NOP();
    295c:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    295e:	e5 e5       	ldi	r30, 0x55	; 85
    2960:	e5 b9       	out	0x05, r30	; 5
  _NOP();
    2962:	00 00       	nop
  _NOP();
    2964:	00 00       	nop
  _NOP();
    2966:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    2968:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    296a:	00 00       	nop
  _NOP();
    296c:	00 00       	nop
  _NOP();
    296e:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    2970:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    2972:	00 00       	nop
  _NOP();
    2974:	00 00       	nop
  _NOP();
    2976:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    2978:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    297a:	00 00       	nop
  _NOP();
    297c:	00 00       	nop
  _NOP();
    297e:	00 00       	nop
  address.address32 = 0x2AAAA;
  address.address8[2] |= (chipNum << 3);
  sst_flash_write_sub_byte(address, 0x55);

  // Now 0x5555 again
  address.address32 = 0x5555;
    2980:	a5 e5       	ldi	r26, 0x55	; 85
    2982:	ea 2e       	mov	r14, r26
    2984:	a5 e5       	ldi	r26, 0x55	; 85
    2986:	fa 2e       	mov	r15, r26
    2988:	01 2d       	mov	r16, r1
    298a:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 3);
    298c:	08 2f       	mov	r16, r24

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    298e:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    2990:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2992:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2994:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2996:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2998:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    299a:	f5 b8       	out	0x05, r15	; 5
  _NOP();
    299c:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    299e:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    29a0:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    29a2:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    29a4:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    29a6:	2e e0       	ldi	r18, 0x0E	; 14
    29a8:	16 95       	lsr	r17
    29aa:	07 95       	ror	r16
    29ac:	f7 94       	ror	r15
    29ae:	e7 94       	ror	r14
    29b0:	2a 95       	dec	r18
    29b2:	d1 f7       	brne	.-12     	; 0x29a8 <sst_read_softwareID+0x11a>
    29b4:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    29b6:	00 00       	nop
  _NOP();
    29b8:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    29ba:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    29bc:	00 00       	nop
  _NOP();
    29be:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    29c0:	20 e9       	ldi	r18, 0x90	; 144
    29c2:	25 b9       	out	0x05, r18	; 5
  _NOP();
    29c4:	00 00       	nop
  _NOP();
    29c6:	00 00       	nop
  _NOP();
    29c8:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    29ca:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    29cc:	00 00       	nop
  _NOP();
    29ce:	00 00       	nop
  _NOP();
    29d0:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    29d2:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    29d4:	00 00       	nop
  _NOP();
    29d6:	00 00       	nop
  _NOP();
    29d8:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    29da:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    29dc:	00 00       	nop
  _NOP();
    29de:	00 00       	nop
  _NOP();
    29e0:	00 00       	nop

  // Put the chip into ID mode. We'll use the /WE control method

  SST_CS_PORT &= ~(1 << SST_CS);
  sst_flash_command_sequence(chipNum, SST_CMDMODE_ID_READ);
  SST_CS_PORT |= (1 << SST_CS);
    29e2:	5f 9a       	sbi	0x0b, 7	; 11

uint8_t sst_flash_read_byte(FLASHADDR address, uint8_t *returnData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    29e4:	45 b9       	out	0x05, r20	; 5
  _NOP();
    29e6:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    29e8:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    29ea:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    29ec:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    29ee:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    29f0:	55 b9       	out	0x05, r21	; 5
  _NOP();
    29f2:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    29f4:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    29f6:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    29f8:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    29fa:	00 00       	nop

  // Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    29fc:	9e e0       	ldi	r25, 0x0E	; 14
    29fe:	76 95       	lsr	r23
    2a00:	67 95       	ror	r22
    2a02:	57 95       	ror	r21
    2a04:	47 95       	ror	r20
    2a06:	9a 95       	dec	r25
    2a08:	d1 f7       	brne	.-12     	; 0x29fe <sst_read_softwareID+0x170>
    2a0a:	48 b9       	out	0x08, r20	; 8
  _NOP();
    2a0c:	00 00       	nop

  // Set read mode by pulling OE and CS low, after making data pins an input!
  MEMORY_DATA_DDR = 0x00; // Make data lines an input
    2a0e:	14 b8       	out	0x04, r1	; 4
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2a10:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2a12:	00 00       	nop
  SST_CS_PORT &= ~(1 << SST_CS);
    2a14:	5f 98       	cbi	0x0b, 7	; 11
  SST_OE_PORT &= ~(1 << SST_OE);
    2a16:	5c 98       	cbi	0x0b, 4	; 11
	...
  _NOP();
  _NOP();
  _NOP();

  // Read the data in!
  *returnData = MEMORY_DATA_PIN;
    2a20:	43 b1       	in	r20, 0x03	; 3

  // Pull OE and CS up again, and make PORTB outputs again
  SST_OE_PORT |= (1 << SST_OE);
    2a22:	5c 9a       	sbi	0x0b, 4	; 11
  SST_CS_PORT |= (1 << SST_CS);
    2a24:	5f 9a       	sbi	0x0b, 7	; 11
  LATCH_OE_PORT |= (1 << LATCH_OE);
    2a26:	15 9a       	sbi	0x02, 5	; 2
  MEMORY_DATA_DDR = 0xFF;
    2a28:	2f ef       	ldi	r18, 0xFF	; 255
    2a2a:	24 b9       	out	0x04, r18	; 4

  sst_flash_read_byte(address, &chipID);

  // Exit ID mode. We'll use the /WE control method

  SST_CS_PORT &= ~(1 << SST_CS);
    2a2c:	5f 98       	cbi	0x0b, 7	; 11

static void sst_flash_command_sequence(uint8_t chipNum, uint8_t mode) {

  FLASHADDR address;
  // First 0x5555, 0xAA
  address.address32 = 0x5555;
    2a2e:	05 e5       	ldi	r16, 0x55	; 85
    2a30:	e0 2e       	mov	r14, r16
    2a32:	05 e5       	ldi	r16, 0x55	; 85
    2a34:	f0 2e       	mov	r15, r16
    2a36:	01 2d       	mov	r16, r1
    2a38:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 3);
    2a3a:	08 2f       	mov	r16, r24

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2a3c:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    2a3e:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2a40:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2a42:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2a44:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2a46:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2a48:	f5 b8       	out	0x05, r15	; 5
  _NOP();
    2a4a:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2a4c:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2a4e:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2a50:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    2a52:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2a54:	be e0       	ldi	r27, 0x0E	; 14
    2a56:	16 95       	lsr	r17
    2a58:	07 95       	ror	r16
    2a5a:	f7 94       	ror	r15
    2a5c:	e7 94       	ror	r14
    2a5e:	ba 95       	dec	r27
    2a60:	d1 f7       	brne	.-12     	; 0x2a56 <sst_read_softwareID+0x1c8>
    2a62:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    2a64:	00 00       	nop
  _NOP();
    2a66:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2a68:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2a6a:	00 00       	nop
  _NOP();
    2a6c:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    2a6e:	f5 b9       	out	0x05, r31	; 5
  _NOP();
    2a70:	00 00       	nop
  _NOP();
    2a72:	00 00       	nop
  _NOP();
    2a74:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    2a76:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    2a78:	00 00       	nop
  _NOP();
    2a7a:	00 00       	nop
  _NOP();
    2a7c:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    2a7e:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    2a80:	00 00       	nop
  _NOP();
    2a82:	00 00       	nop
  _NOP();
    2a84:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    2a86:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    2a88:	00 00       	nop
  _NOP();
    2a8a:	00 00       	nop
  _NOP();
    2a8c:	00 00       	nop
  address.address32 = 0x5555;
  address.address8[2] |= (chipNum << 3);
  sst_flash_write_sub_byte(address, 0xAA);

  // Now 0x2AAA,0x55
  address.address32 = 0x2AAAA;
    2a8e:	aa ea       	ldi	r26, 0xAA	; 170
    2a90:	ea 2e       	mov	r14, r26
    2a92:	aa ea       	ldi	r26, 0xAA	; 170
    2a94:	fa 2e       	mov	r15, r26
    2a96:	a2 e0       	ldi	r26, 0x02	; 2
    2a98:	0a 2f       	mov	r16, r26
    2a9a:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 3);
    2a9c:	03 2f       	mov	r16, r19

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2a9e:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    2aa0:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2aa2:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2aa4:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2aa6:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2aa8:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2aaa:	f5 b8       	out	0x05, r15	; 5
  _NOP();
    2aac:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2aae:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2ab0:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2ab2:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    2ab4:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2ab6:	fe e0       	ldi	r31, 0x0E	; 14
    2ab8:	16 95       	lsr	r17
    2aba:	07 95       	ror	r16
    2abc:	f7 94       	ror	r15
    2abe:	e7 94       	ror	r14
    2ac0:	fa 95       	dec	r31
    2ac2:	d1 f7       	brne	.-12     	; 0x2ab8 <sst_read_softwareID+0x22a>
    2ac4:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    2ac6:	00 00       	nop
  _NOP();
    2ac8:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2aca:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2acc:	00 00       	nop
  _NOP();
    2ace:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    2ad0:	e5 b9       	out	0x05, r30	; 5
  _NOP();
    2ad2:	00 00       	nop
  _NOP();
    2ad4:	00 00       	nop
  _NOP();
    2ad6:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    2ad8:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    2ada:	00 00       	nop
  _NOP();
    2adc:	00 00       	nop
  _NOP();
    2ade:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    2ae0:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    2ae2:	00 00       	nop
  _NOP();
    2ae4:	00 00       	nop
  _NOP();
    2ae6:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    2ae8:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    2aea:	00 00       	nop
  _NOP();
    2aec:	00 00       	nop
  _NOP();
    2aee:	00 00       	nop
  address.address32 = 0x2AAAA;
  address.address8[2] |= (chipNum << 3);
  sst_flash_write_sub_byte(address, 0x55);

  // Now 0x5555 again
  address.address32 = 0x5555;
    2af0:	e5 e5       	ldi	r30, 0x55	; 85
    2af2:	ee 2e       	mov	r14, r30
    2af4:	e5 e5       	ldi	r30, 0x55	; 85
    2af6:	fe 2e       	mov	r15, r30
    2af8:	01 2d       	mov	r16, r1
    2afa:	11 2d       	mov	r17, r1
  address.address8[2] |= (chipNum << 3);
    2afc:	08 2f       	mov	r16, r24

uint8_t sst_flash_write_sub_byte(FLASHADDR address, uint8_t writeData) {

  // Set the address to read from
  // Remember you need to latch the address in!
  MEMORY_DATA_PORT = address.address8[0];
    2afe:	e5 b8       	out	0x05, r14	; 5
  _NOP();
    2b00:	00 00       	nop
  LATCH_CLK_LO8_PORT |= (1 << LATCH_CLK_LO8); // Rising edge triggered
    2b02:	5a 9a       	sbi	0x0b, 2	; 11
  _NOP();
    2b04:	00 00       	nop
  LATCH_CLK_LO8_PORT &= ~(1 << LATCH_CLK_LO8);
    2b06:	5a 98       	cbi	0x0b, 2	; 11
  _NOP();
    2b08:	00 00       	nop

  MEMORY_DATA_PORT = address.address8[1];
    2b0a:	f5 b8       	out	0x05, r15	; 5
  _NOP();
    2b0c:	00 00       	nop
  LATCH_CLK_MID6_PORT |= (1 << LATCH_CLK_MID6);
    2b0e:	12 9a       	sbi	0x02, 2	; 2
  _NOP();
    2b10:	00 00       	nop
  LATCH_CLK_MID6_PORT &= ~(1 << LATCH_CLK_MID6);
    2b12:	12 98       	cbi	0x02, 2	; 2
  _NOP();
    2b14:	00 00       	nop


// Address for ADDR14-21
  SST_HI5_PORT = address.address32 >> 14;//(address.address8[1] >> 6) | (address.address8[2] << 2); //address.address32 >> 14;
    2b16:	7e e0       	ldi	r23, 0x0E	; 14
    2b18:	16 95       	lsr	r17
    2b1a:	07 95       	ror	r16
    2b1c:	f7 94       	ror	r15
    2b1e:	e7 94       	ror	r14
    2b20:	7a 95       	dec	r23
    2b22:	d1 f7       	brne	.-12     	; 0x2b18 <sst_read_softwareID+0x28a>
    2b24:	e8 b8       	out	0x08, r14	; 8
  _NOP();
    2b26:	00 00       	nop
  _NOP();
    2b28:	00 00       	nop

  // Latch the address onto the chip by pulling /WE low
  LATCH_OE_PORT &= ~(1 << LATCH_OE);
    2b2a:	15 98       	cbi	0x02, 5	; 2
  _NOP();
    2b2c:	00 00       	nop
  _NOP();
    2b2e:	00 00       	nop

  // Set the data byte for the rising edge. @20MHz, CLK cycles are slow enough we don't need to delay here
  MEMORY_DATA_PORT = writeData;
    2b30:	80 ef       	ldi	r24, 0xF0	; 240
    2b32:	85 b9       	out	0x05, r24	; 5
  _NOP();
    2b34:	00 00       	nop
  _NOP();
    2b36:	00 00       	nop
  _NOP();
    2b38:	00 00       	nop
  
  SST_WE_PORT &= ~(1 << SST_WE);
    2b3a:	14 98       	cbi	0x02, 4	; 2
  _NOP();
    2b3c:	00 00       	nop
  _NOP();
    2b3e:	00 00       	nop
  _NOP();
    2b40:	00 00       	nop
  
  SST_WE_PORT |= (1 << SST_WE);
    2b42:	14 9a       	sbi	0x02, 4	; 2
  _NOP();
    2b44:	00 00       	nop
  _NOP();
    2b46:	00 00       	nop
  _NOP();
    2b48:	00 00       	nop

  LATCH_OE_PORT |= (1 << LATCH_OE);
    2b4a:	15 9a       	sbi	0x02, 5	; 2
  _NOP();
    2b4c:	00 00       	nop
  _NOP();
    2b4e:	00 00       	nop
  _NOP();
    2b50:	00 00       	nop

  // Exit ID mode. We'll use the /WE control method

  SST_CS_PORT &= ~(1 << SST_CS);
  sst_flash_command_sequence(chipNum, SST_CMDMODE_ID_EXIT);
  SST_CS_PORT |= (1 << SST_CS);
    2b52:	5f 9a       	sbi	0x0b, 7	; 11

  return chipID;
}
    2b54:	84 2f       	mov	r24, r20
    2b56:	1f 91       	pop	r17
    2b58:	0f 91       	pop	r16
    2b5a:	ff 90       	pop	r15
    2b5c:	ef 90       	pop	r14
    2b5e:	08 95       	ret

00002b60 <sram_buff_send>:
    }*/
  }

}

uint8_t sram_buff_send(unsigned char* buffer, uint16_t byteCnt) {
    2b60:	ef 92       	push	r14
    2b62:	ff 92       	push	r15
    2b64:	0f 93       	push	r16
    2b66:	1f 93       	push	r17
    2b68:	cf 93       	push	r28
    2b6a:	df 93       	push	r29
    2b6c:	7c 01       	movw	r14, r24
    2b6e:	8b 01       	movw	r16, r22
   for(uint16_t i = 0; i<byteCnt; i++, RAMaddress++) {
    2b70:	61 15       	cp	r22, r1
    2b72:	71 05       	cpc	r23, r1
    2b74:	11 f1       	breq	.+68     	; 0x2bba <sram_buff_send+0x5a>
    2b76:	c0 e0       	ldi	r28, 0x00	; 0
    2b78:	d0 e0       	ldi	r29, 0x00	; 0
     sram_read_byte(RAMaddress, &(buffer[i]));
    2b7a:	b7 01       	movw	r22, r14
    2b7c:	6c 0f       	add	r22, r28
    2b7e:	7d 1f       	adc	r23, r29
    2b80:	80 91 3a 01 	lds	r24, 0x013A
    2b84:	90 91 3b 01 	lds	r25, 0x013B
    2b88:	0e 94 1e 11 	call	0x223c	; 0x223c <sram_read_byte>
  }

}

uint8_t sram_buff_send(unsigned char* buffer, uint16_t byteCnt) {
   for(uint16_t i = 0; i<byteCnt; i++, RAMaddress++) {
    2b8c:	21 96       	adiw	r28, 0x01	; 1
    2b8e:	80 91 3a 01 	lds	r24, 0x013A
    2b92:	90 91 3b 01 	lds	r25, 0x013B
    2b96:	a0 91 3c 01 	lds	r26, 0x013C
    2b9a:	b0 91 3d 01 	lds	r27, 0x013D
    2b9e:	01 96       	adiw	r24, 0x01	; 1
    2ba0:	a1 1d       	adc	r26, r1
    2ba2:	b1 1d       	adc	r27, r1
    2ba4:	80 93 3a 01 	sts	0x013A, r24
    2ba8:	90 93 3b 01 	sts	0x013B, r25
    2bac:	a0 93 3c 01 	sts	0x013C, r26
    2bb0:	b0 93 3d 01 	sts	0x013D, r27
    2bb4:	c0 17       	cp	r28, r16
    2bb6:	d1 07       	cpc	r29, r17
    2bb8:	00 f3       	brcs	.-64     	; 0x2b7a <sram_buff_send+0x1a>
     sram_read_byte(RAMaddress, &(buffer[i]));
  }
  return 0;
}
    2bba:	80 e0       	ldi	r24, 0x00	; 0
    2bbc:	df 91       	pop	r29
    2bbe:	cf 91       	pop	r28
    2bc0:	1f 91       	pop	r17
    2bc2:	0f 91       	pop	r16
    2bc4:	ff 90       	pop	r15
    2bc6:	ef 90       	pop	r14
    2bc8:	08 95       	ret

00002bca <sram_buff_receive>:
  }

  return 0;
}

void sram_buff_receive(unsigned char* buffer, uint16_t byteCnt) {
    2bca:	ef 92       	push	r14
    2bcc:	ff 92       	push	r15
    2bce:	0f 93       	push	r16
    2bd0:	1f 93       	push	r17
    2bd2:	cf 93       	push	r28
    2bd4:	df 93       	push	r29
    2bd6:	7c 01       	movw	r14, r24
    2bd8:	8b 01       	movw	r16, r22
  for(uint16_t i = 0; i<byteCnt; i++, RAMaddress++) {
    2bda:	61 15       	cp	r22, r1
    2bdc:	71 05       	cpc	r23, r1
    2bde:	19 f1       	breq	.+70     	; 0x2c26 <sram_buff_receive+0x5c>
    2be0:	c0 e0       	ldi	r28, 0x00	; 0
    2be2:	d0 e0       	ldi	r29, 0x00	; 0
    sram_write_byte(RAMaddress, buffer[i]);
    2be4:	f7 01       	movw	r30, r14
    2be6:	ec 0f       	add	r30, r28
    2be8:	fd 1f       	adc	r31, r29
    2bea:	80 91 3a 01 	lds	r24, 0x013A
    2bee:	90 91 3b 01 	lds	r25, 0x013B
    2bf2:	60 81       	ld	r22, Z
    2bf4:	0e 94 41 11 	call	0x2282	; 0x2282 <sram_write_byte>

  return 0;
}

void sram_buff_receive(unsigned char* buffer, uint16_t byteCnt) {
  for(uint16_t i = 0; i<byteCnt; i++, RAMaddress++) {
    2bf8:	21 96       	adiw	r28, 0x01	; 1
    2bfa:	80 91 3a 01 	lds	r24, 0x013A
    2bfe:	90 91 3b 01 	lds	r25, 0x013B
    2c02:	a0 91 3c 01 	lds	r26, 0x013C
    2c06:	b0 91 3d 01 	lds	r27, 0x013D
    2c0a:	01 96       	adiw	r24, 0x01	; 1
    2c0c:	a1 1d       	adc	r26, r1
    2c0e:	b1 1d       	adc	r27, r1
    2c10:	80 93 3a 01 	sts	0x013A, r24
    2c14:	90 93 3b 01 	sts	0x013B, r25
    2c18:	a0 93 3c 01 	sts	0x013C, r26
    2c1c:	b0 93 3d 01 	sts	0x013D, r27
    2c20:	c0 17       	cp	r28, r16
    2c22:	d1 07       	cpc	r29, r17
    2c24:	f8 f2       	brcs	.-66     	; 0x2be4 <sram_buff_receive+0x1a>
      }
      RAMWriteErrorsAddrLast = RAMaddress;
    }*/
  }

}
    2c26:	df 91       	pop	r29
    2c28:	cf 91       	pop	r28
    2c2a:	1f 91       	pop	r17
    2c2c:	0f 91       	pop	r16
    2c2e:	ff 90       	pop	r15
    2c30:	ef 90       	pop	r14
    2c32:	08 95       	ret

00002c34 <flash_buff_send>:
    
  }
}

uint8_t flash_buff_send(unsigned char* buffer, uint16_t byteCnt)
{
    2c34:	ef 92       	push	r14
    2c36:	ff 92       	push	r15
    2c38:	0f 93       	push	r16
    2c3a:	1f 93       	push	r17
    2c3c:	cf 93       	push	r28
    2c3e:	df 93       	push	r29
    2c40:	7c 01       	movw	r14, r24
    2c42:	8b 01       	movw	r16, r22
  for(uint16_t i = 0; i<byteCnt; i++, flashAddress.address32++) {
    2c44:	61 15       	cp	r22, r1
    2c46:	71 05       	cpc	r23, r1
    2c48:	31 f1       	breq	.+76     	; 0x2c96 <flash_buff_send+0x62>
    2c4a:	c0 e0       	ldi	r28, 0x00	; 0
    2c4c:	d0 e0       	ldi	r29, 0x00	; 0
     sst_flash_read_byte(flashAddress, &(buffer[i]));
    2c4e:	60 91 4d 05 	lds	r22, 0x054D
    2c52:	70 91 4e 05 	lds	r23, 0x054E
    2c56:	80 91 4f 05 	lds	r24, 0x054F
    2c5a:	90 91 50 05 	lds	r25, 0x0550
    2c5e:	a7 01       	movw	r20, r14
    2c60:	4c 0f       	add	r20, r28
    2c62:	5d 1f       	adc	r21, r29
    2c64:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>
  }
}

uint8_t flash_buff_send(unsigned char* buffer, uint16_t byteCnt)
{
  for(uint16_t i = 0; i<byteCnt; i++, flashAddress.address32++) {
    2c68:	21 96       	adiw	r28, 0x01	; 1
    2c6a:	80 91 4d 05 	lds	r24, 0x054D
    2c6e:	90 91 4e 05 	lds	r25, 0x054E
    2c72:	a0 91 4f 05 	lds	r26, 0x054F
    2c76:	b0 91 50 05 	lds	r27, 0x0550
    2c7a:	01 96       	adiw	r24, 0x01	; 1
    2c7c:	a1 1d       	adc	r26, r1
    2c7e:	b1 1d       	adc	r27, r1
    2c80:	80 93 4d 05 	sts	0x054D, r24
    2c84:	90 93 4e 05 	sts	0x054E, r25
    2c88:	a0 93 4f 05 	sts	0x054F, r26
    2c8c:	b0 93 50 05 	sts	0x0550, r27
    2c90:	c0 17       	cp	r28, r16
    2c92:	d1 07       	cpc	r29, r17
    2c94:	e0 f2       	brcs	.-72     	; 0x2c4e <flash_buff_send+0x1a>
     sst_flash_read_byte(flashAddress, &(buffer[i]));
  }

  return 0;
}
    2c96:	80 e0       	ldi	r24, 0x00	; 0
    2c98:	df 91       	pop	r29
    2c9a:	cf 91       	pop	r28
    2c9c:	1f 91       	pop	r17
    2c9e:	0f 91       	pop	r16
    2ca0:	ff 90       	pop	r15
    2ca2:	ef 90       	pop	r14
    2ca4:	08 95       	ret

00002ca6 <flash_buff_receive>:
}

// ******************************* Buffer functions *****************************************************************

void flash_buff_receive(unsigned char* buffer, uint16_t byteCnt)
{
    2ca6:	ef 92       	push	r14
    2ca8:	ff 92       	push	r15
    2caa:	0f 93       	push	r16
    2cac:	1f 93       	push	r17
    2cae:	cf 93       	push	r28
    2cb0:	df 93       	push	r29
    2cb2:	7c 01       	movw	r14, r24
    2cb4:	8b 01       	movw	r16, r22
  for(uint16_t i = 0; i<byteCnt; i++, flashAddress.address32++) {
    2cb6:	61 15       	cp	r22, r1
    2cb8:	71 05       	cpc	r23, r1
    2cba:	39 f1       	breq	.+78     	; 0x2d0a <flash_buff_receive+0x64>
    2cbc:	c0 e0       	ldi	r28, 0x00	; 0
    2cbe:	d0 e0       	ldi	r29, 0x00	; 0
    sst_flash_write_byte(flashAddress, buffer[i]);
    2cc0:	60 91 4d 05 	lds	r22, 0x054D
    2cc4:	70 91 4e 05 	lds	r23, 0x054E
    2cc8:	80 91 4f 05 	lds	r24, 0x054F
    2ccc:	90 91 50 05 	lds	r25, 0x0550
    2cd0:	f7 01       	movw	r30, r14
    2cd2:	ec 0f       	add	r30, r28
    2cd4:	fd 1f       	adc	r31, r29
    2cd6:	40 81       	ld	r20, Z
    2cd8:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <sst_flash_write_byte>

// ******************************* Buffer functions *****************************************************************

void flash_buff_receive(unsigned char* buffer, uint16_t byteCnt)
{
  for(uint16_t i = 0; i<byteCnt; i++, flashAddress.address32++) {
    2cdc:	21 96       	adiw	r28, 0x01	; 1
    2cde:	80 91 4d 05 	lds	r24, 0x054D
    2ce2:	90 91 4e 05 	lds	r25, 0x054E
    2ce6:	a0 91 4f 05 	lds	r26, 0x054F
    2cea:	b0 91 50 05 	lds	r27, 0x0550
    2cee:	01 96       	adiw	r24, 0x01	; 1
    2cf0:	a1 1d       	adc	r26, r1
    2cf2:	b1 1d       	adc	r27, r1
    2cf4:	80 93 4d 05 	sts	0x054D, r24
    2cf8:	90 93 4e 05 	sts	0x054E, r25
    2cfc:	a0 93 4f 05 	sts	0x054F, r26
    2d00:	b0 93 50 05 	sts	0x0550, r27
    2d04:	c0 17       	cp	r28, r16
    2d06:	d1 07       	cpc	r29, r17
    2d08:	d8 f2       	brcs	.-74     	; 0x2cc0 <flash_buff_receive+0x1a>
    sst_flash_write_byte(flashAddress, buffer[i]);
    
  }
}
    2d0a:	df 91       	pop	r29
    2d0c:	cf 91       	pop	r28
    2d0e:	1f 91       	pop	r17
    2d10:	0f 91       	pop	r16
    2d12:	ff 90       	pop	r15
    2d14:	ef 90       	pop	r14
    2d16:	08 95       	ret

00002d18 <launch_mbc_mode>:
void launch_mbc_mode(void) {
  
  // Init ports first
  // Should be common inputs and outputs for all MBC modes, even if functions are different

  DDRA = 0xFB; // All outputs except PA5, which is now GB_CS, maybe I need to change RUMBLE (PA2) to input for ADDR12 too
    2d18:	8b ef       	ldi	r24, 0xFB	; 251
    2d1a:	81 b9       	out	0x01, r24	; 1
  DDRB = 0;  //DDRB = (1 << PB5) | (1 << PB6) | (1 << PB7); // Port B is data from the GB, note for MBC1, PB5-7 are not connected. Set them as Lo outputs
    2d1c:	14 b8       	out	0x04, r1	; 4
  DDRC = 0x7F; // MA output lines, with exception of PC7, which is 
    2d1e:	8f e7       	ldi	r24, 0x7F	; 127
    2d20:	87 b9       	out	0x07, r24	; 7
  DDRD = 0;
    2d22:	1a b8       	out	0x0a, r1	; 10

  PORTA = (1 << PA5) | (1 << PA4) | (1 << PA7); // Set (PA5) OE pins and (PA7) INTRAMEN hi, PA4 is Flash WE
    2d24:	80 eb       	ldi	r24, 0xB0	; 176
    2d26:	82 b9       	out	0x02, r24	; 2
  PORTB = 0;
    2d28:	15 b8       	out	0x05, r1	; 5
  PORTC = 0; // no pullups needed on these ports
    2d2a:	18 b8       	out	0x08, r1	; 8
  PORTD = (1 << PD0) | (1 << PD1); // Set UART pins hi
    2d2c:	83 e0       	ldi	r24, 0x03	; 3
    2d2e:	8b b9       	out	0x0b, r24	; 11

  

  // Hmmm. Will need to read EEPROM first to decide which is the correct mode...
  uint8_t mode = read_MBC_mode_only();
    2d30:	0e 94 68 20 	call	0x40d0	; 0x40d0 <read_MBC_mode_only>

  if(mode == CART_MODE_MBC1_16M) {
    2d34:	80 34       	cpi	r24, 0x40	; 64
    2d36:	41 f0       	breq	.+16     	; 0x2d48 <launch_mbc_mode+0x30>
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC1_16M8k();

  } else if (mode == CART_MODE_MBC1_4M) {
    2d38:	81 34       	cpi	r24, 0x41	; 65
    2d3a:	91 f0       	breq	.+36     	; 0x2d60 <launch_mbc_mode+0x48>
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC1_4M32k();

  } else if (mode == CART_MODE_MBC2) {
    2d3c:	85 34       	cpi	r24, 0x45	; 69
    2d3e:	b1 f0       	breq	.+44     	; 0x2d6c <launch_mbc_mode+0x54>
    PRR = 0xFF; // Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC2();

  } else if (mode == CART_MODE_MBC3) {
    2d40:	83 34       	cpi	r24, 0x43	; 67
    2d42:	d1 f0       	breq	.+52     	; 0x2d78 <launch_mbc_mode+0x60>
    PRR = 0xF7;// Turn off everything except timer1! We want a pseudo RTC!
    MBC_mode_MBC3();

  } else if (mode == CART_MODE_MBC5) {
    2d44:	82 34       	cpi	r24, 0x42	; 66
    2d46:	31 f0       	breq	.+12     	; 0x2d54 <launch_mbc_mode+0x3c>
    PRR = 0xFF; // Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC5();

  } else {
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    2d48:	8f ef       	ldi	r24, 0xFF	; 255
    2d4a:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC1_16M8k();
    2d4e:	0e 94 00 3f 	call	0x7e00	; 0x7e00 <MBC_mode_MBC1_16M8k>
    2d52:	08 95       	ret
  } else if (mode == CART_MODE_MBC3) {
    PRR = 0xF7;// Turn off everything except timer1! We want a pseudo RTC!
    MBC_mode_MBC3();

  } else if (mode == CART_MODE_MBC5) {
    PRR = 0xFF; // Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    2d54:	8f ef       	ldi	r24, 0xFF	; 255
    2d56:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC5();
    2d5a:	0e 94 28 3f 	call	0x7e50	; 0x7e50 <MBC_mode_MBC5>
    2d5e:	08 95       	ret
  if(mode == CART_MODE_MBC1_16M) {
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC1_16M8k();

  } else if (mode == CART_MODE_MBC1_4M) {
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    2d60:	8f ef       	ldi	r24, 0xFF	; 255
    2d62:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC1_4M32k();
    2d66:	0e 94 14 3f 	call	0x7e28	; 0x7e28 <MBC_mode_MBC1_4M32k>
    2d6a:	08 95       	ret

  } else if (mode == CART_MODE_MBC2) {
    PRR = 0xFF; // Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    2d6c:	8f ef       	ldi	r24, 0xFF	; 255
    2d6e:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC2();
    2d72:	0e 94 72 3f 	call	0x7ee4	; 0x7ee4 <MBC_mode_MBC2>
    2d76:	08 95       	ret

  } else if (mode == CART_MODE_MBC3) {
    PRR = 0xF7;// Turn off everything except timer1! We want a pseudo RTC!
    2d78:	87 ef       	ldi	r24, 0xF7	; 247
    2d7a:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC3();
    2d7e:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <MBC_mode_MBC3>
    2d82:	08 95       	ret

00002d84 <wait_for_continue>:
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    2d84:	86 e3       	ldi	r24, 0x36	; 54
    2d86:	91 e0       	ldi	r25, 0x01	; 1
    2d88:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    2d8c:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    2d90:	80 32       	cpi	r24, 0x20	; 32
    2d92:	e1 f7       	brne	.-8      	; 0x2d8c <wait_for_continue+0x8>
}
    2d94:	08 95       	ret

00002d96 <wait_for_confirm_cancel>:

uint8_t wait_for_confirm_cancel() {
  
  char input; 
  do {
    input = usart_receive();
    2d96:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while((input != 'Y') && (input != 'N') && (input != 'y') && (input != 'n'));
    2d9a:	89 35       	cpi	r24, 0x59	; 89
    2d9c:	41 f0       	breq	.+16     	; 0x2dae <wait_for_confirm_cancel+0x18>
    2d9e:	8e 34       	cpi	r24, 0x4E	; 78
    2da0:	21 f0       	breq	.+8      	; 0x2daa <wait_for_confirm_cancel+0x14>
    2da2:	89 37       	cpi	r24, 0x79	; 121
    2da4:	21 f0       	breq	.+8      	; 0x2dae <wait_for_confirm_cancel+0x18>
    2da6:	8e 36       	cpi	r24, 0x6E	; 110
    2da8:	b1 f7       	brne	.-20     	; 0x2d96 <wait_for_confirm_cancel>
    2daa:	81 e0       	ldi	r24, 0x01	; 1
    2dac:	08 95       	ret
    2dae:	80 e0       	ldi	r24, 0x00	; 0
  if((input == 'N') || (input == 'n')) {
    return 1;
  }

  return 0;
}
    2db0:	08 95       	ret

00002db2 <flash_new_firmware>:
}

uint8_t flash_new_firmware() { 

  // Run the bootloader
  asm("jmp 0xE000");
    2db2:	0c 94 00 70 	jmp	0xe000	; 0xe000 <MBC2_NZERO2+0x54ba>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    2db6:	86 e3       	ldi	r24, 0x36	; 54
    2db8:	91 e0       	ldi	r25, 0x01	; 1
    2dba:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    2dbe:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    2dc2:	80 32       	cpi	r24, 0x20	; 32
    2dc4:	e1 f7       	brne	.-8      	; 0x2dbe <flash_new_firmware+0xc>
  // Run the bootloader
  asm("jmp 0xE000");

  wait_for_continue();
  return 0;
}
    2dc6:	80 e0       	ldi	r24, 0x00	; 0
    2dc8:	08 95       	ret

00002dca <show_ROM_info>:
  return 0;
}

uint8_t show_ROM_info() {
  
  get_GBROM_info(&gbRomData);
    2dca:	87 e5       	ldi	r24, 0x57	; 87
    2dcc:	95 e0       	ldi	r25, 0x05	; 5
    2dce:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <get_GBROM_info>

  usart_transmit_str_P(PSTR("Gameboy ROM info (from flash):\r\n"));
    2dd2:	86 ee       	ldi	r24, 0xE6	; 230
    2dd4:	96 e0       	ldi	r25, 0x06	; 6
    2dd6:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit_str_P(PSTR("ROM name:         "));
    2dda:	83 ed       	ldi	r24, 0xD3	; 211
    2ddc:	96 e0       	ldi	r25, 0x06	; 6
    2dde:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit_str(gbRomData.name);
    2de2:	87 e5       	ldi	r24, 0x57	; 87
    2de4:	95 e0       	ldi	r25, 0x05	; 5
    2de6:	0e 94 2a 06 	call	0xc54	; 0xc54 <usart_transmit_str>
  usart_newline();
    2dea:	8a e0       	ldi	r24, 0x0A	; 10
    2dec:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    2df0:	8d e0       	ldi	r24, 0x0D	; 13
    2df2:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit_str_P(PSTR("ROM size:         0x"));
    2df6:	8e eb       	ldi	r24, 0xBE	; 190
    2df8:	96 e0       	ldi	r25, 0x06	; 6
    2dfa:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit(nibble_to_hex(gbRomData.ROMsize >> 4));
    2dfe:	80 91 68 05 	lds	r24, 0x0568
    2e02:	82 95       	swap	r24
    2e04:	8f 70       	andi	r24, 0x0F	; 15
    2e06:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    2e0a:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit(nibble_to_hex(gbRomData.ROMsize));
    2e0e:	80 91 68 05 	lds	r24, 0x0568
    2e12:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    2e16:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit(' ');
    2e1a:	80 e2       	ldi	r24, 0x20	; 32
    2e1c:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit_int32(gbRomData.ROMsizeBytes);
    2e20:	60 91 69 05 	lds	r22, 0x0569
    2e24:	70 91 6a 05 	lds	r23, 0x056A
    2e28:	80 91 6b 05 	lds	r24, 0x056B
    2e2c:	90 91 6c 05 	lds	r25, 0x056C
    2e30:	0e 94 4f 06 	call	0xc9e	; 0xc9e <usart_transmit_int32>
  usart_newline();
    2e34:	8a e0       	ldi	r24, 0x0A	; 10
    2e36:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    2e3a:	8d e0       	ldi	r24, 0x0D	; 13
    2e3c:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit_str_P(PSTR("SRAM size:        0x"));
    2e40:	89 ea       	ldi	r24, 0xA9	; 169
    2e42:	96 e0       	ldi	r25, 0x06	; 6
    2e44:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit(nibble_to_hex(gbRomData.RAMsize >> 4));
    2e48:	80 91 6d 05 	lds	r24, 0x056D
    2e4c:	82 95       	swap	r24
    2e4e:	8f 70       	andi	r24, 0x0F	; 15
    2e50:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    2e54:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit(nibble_to_hex(gbRomData.RAMsize));
    2e58:	80 91 6d 05 	lds	r24, 0x056D
    2e5c:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    2e60:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit(' ');
    2e64:	80 e2       	ldi	r24, 0x20	; 32
    2e66:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit_int32(gbRomData.RAMsizeBytes);
    2e6a:	60 91 6e 05 	lds	r22, 0x056E
    2e6e:	70 91 6f 05 	lds	r23, 0x056F
    2e72:	80 e0       	ldi	r24, 0x00	; 0
    2e74:	90 e0       	ldi	r25, 0x00	; 0
    2e76:	0e 94 4f 06 	call	0xc9e	; 0xc9e <usart_transmit_int32>
  usart_newline();
    2e7a:	8a e0       	ldi	r24, 0x0A	; 10
    2e7c:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    2e80:	8d e0       	ldi	r24, 0x0D	; 13
    2e82:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit_str_P(PSTR("MBC type:         0x"));
    2e86:	84 e9       	ldi	r24, 0x94	; 148
    2e88:	96 e0       	ldi	r25, 0x06	; 6
    2e8a:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit(nibble_to_hex(gbRomData.MBCtype >> 4));
    2e8e:	80 91 70 05 	lds	r24, 0x0570
    2e92:	82 95       	swap	r24
    2e94:	8f 70       	andi	r24, 0x0F	; 15
    2e96:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    2e9a:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit(nibble_to_hex(gbRomData.MBCtype));
    2e9e:	80 91 70 05 	lds	r24, 0x0570
    2ea2:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    2ea6:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit(' ');
    2eaa:	80 e2       	ldi	r24, 0x20	; 32
    2eac:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit_str(gbRomData.MBCname);
    2eb0:	81 e7       	ldi	r24, 0x71	; 113
    2eb2:	95 e0       	ldi	r25, 0x05	; 5
    2eb4:	0e 94 2a 06 	call	0xc54	; 0xc54 <usart_transmit_str>
  usart_newline();
    2eb8:	8a e0       	ldi	r24, 0x0A	; 10
    2eba:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    2ebe:	8d e0       	ldi	r24, 0x0D	; 13
    2ec0:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit_str_P(PSTR("CGB support?:     0x"));
    2ec4:	8f e7       	ldi	r24, 0x7F	; 127
    2ec6:	96 e0       	ldi	r25, 0x06	; 6
    2ec8:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit(nibble_to_hex(gbRomData.CGBsupport >> 4));
    2ecc:	80 91 86 05 	lds	r24, 0x0586
    2ed0:	82 95       	swap	r24
    2ed2:	8f 70       	andi	r24, 0x0F	; 15
    2ed4:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    2ed8:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit(nibble_to_hex(gbRomData.CGBsupport));
    2edc:	80 91 86 05 	lds	r24, 0x0586
    2ee0:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    2ee4:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit(' ');
    2ee8:	80 e2       	ldi	r24, 0x20	; 32
    2eea:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit_str(gbRomData.CGBsupportText);
    2eee:	87 e8       	ldi	r24, 0x87	; 135
    2ef0:	95 e0       	ldi	r25, 0x05	; 5
    2ef2:	0e 94 2a 06 	call	0xc54	; 0xc54 <usart_transmit_str>
  usart_newline();
    2ef6:	8a e0       	ldi	r24, 0x0A	; 10
    2ef8:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    2efc:	8d e0       	ldi	r24, 0x0D	; 13
    2efe:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit_str_P(PSTR("\r\nMBC mode on boot (From EEPROM)\r\n"));
    2f02:	8c e5       	ldi	r24, 0x5C	; 92
    2f04:	96 e0       	ldi	r25, 0x06	; 6
    2f06:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit_str_P(PSTR("MBC mode:         "));
    2f0a:	89 e4       	ldi	r24, 0x49	; 73
    2f0c:	96 e0       	ldi	r25, 0x06	; 6
    2f0e:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit(nibble_to_hex(eepData.MBCMode >> 4));
    2f12:	80 91 90 05 	lds	r24, 0x0590
    2f16:	82 95       	swap	r24
    2f18:	8f 70       	andi	r24, 0x0F	; 15
    2f1a:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    2f1e:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit(nibble_to_hex(eepData.MBCMode));
    2f22:	80 91 90 05 	lds	r24, 0x0590
    2f26:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    2f2a:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit(' ');
    2f2e:	80 e2       	ldi	r24, 0x20	; 32
    2f30:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit_str(eepData.MBCName);
    2f34:	81 e9       	ldi	r24, 0x91	; 145
    2f36:	95 e0       	ldi	r25, 0x05	; 5
    2f38:	0e 94 2a 06 	call	0xc54	; 0xc54 <usart_transmit_str>
  usart_newline();
    2f3c:	8a e0       	ldi	r24, 0x0A	; 10
    2f3e:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    2f42:	8d e0       	ldi	r24, 0x0D	; 13
    2f44:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit_str_P(PSTR("\r\nFirmware rev.:    1.0 26 Jan 19\r\n\n"));
    2f48:	84 e2       	ldi	r24, 0x24	; 36
    2f4a:	96 e0       	ldi	r25, 0x06	; 6
    2f4c:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    2f50:	86 e3       	ldi	r24, 0x36	; 54
    2f52:	91 e0       	ldi	r25, 0x01	; 1
    2f54:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    2f58:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    2f5c:	80 32       	cpi	r24, 0x20	; 32
    2f5e:	e1 f7       	brne	.-8      	; 0x2f58 <show_ROM_info+0x18e>
  usart_newline();
  usart_transmit_str_P(PSTR("\r\nFirmware rev.:    1.0 26 Jan 19\r\n\n"));

  wait_for_continue();
  return 0;
}
    2f60:	80 e0       	ldi	r24, 0x00	; 0
    2f62:	08 95       	ret

00002f64 <force_mbc_mode>:

  wait_for_continue();
  return 0;
}

uint8_t force_mbc_mode() {
    2f64:	1f 93       	push	r17

  // Show the user the menu options
  usart_transmit_str_P(PSTR("Select one of the MBC modes below:\r\n"));
    2f66:	8b e9       	ldi	r24, 0x9B	; 155
    2f68:	92 e0       	ldi	r25, 0x02	; 2
    2f6a:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit_str_P(PSTR("0 - MBC1 16Mb\r\n"));
    2f6e:	8b e8       	ldi	r24, 0x8B	; 139
    2f70:	92 e0       	ldi	r25, 0x02	; 2
    2f72:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit_str_P(PSTR("1 - MBC1 4Mb\r\n"));
    2f76:	8c e7       	ldi	r24, 0x7C	; 124
    2f78:	92 e0       	ldi	r25, 0x02	; 2
    2f7a:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit_str_P(PSTR("2 - MBC2\r\n"));
    2f7e:	81 e7       	ldi	r24, 0x71	; 113
    2f80:	92 e0       	ldi	r25, 0x02	; 2
    2f82:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit_str_P(PSTR("3 - MBC3\r\n"));
    2f86:	86 e6       	ldi	r24, 0x66	; 102
    2f88:	92 e0       	ldi	r25, 0x02	; 2
    2f8a:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit_str_P(PSTR("4 - MBC5\r\n"));
    2f8e:	8b e5       	ldi	r24, 0x5B	; 91
    2f90:	92 e0       	ldi	r25, 0x02	; 2
    2f92:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit_str_P(PSTR("c - Cancel selection\r\n"));
    2f96:	84 e4       	ldi	r24, 0x44	; 68
    2f98:	92 e0       	ldi	r25, 0x02	; 2
    2f9a:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    2f9e:	0f c0       	rjmp	.+30     	; 0x2fbe <force_mbc_mode+0x5a>
  uint8_t c;

  do {
    c = usart_receive();

    if((c >= '0' && c <= '4') || (c == 'c')) {
    2fa0:	13 36       	cpi	r17, 0x63	; 99
    2fa2:	31 f1       	breq	.+76     	; 0x2ff0 <force_mbc_mode+0x8c>
      break;
    }

    usart_transmit_str_P(PSTR("Unknown selection:"));
    2fa4:	81 e3       	ldi	r24, 0x31	; 49
    2fa6:	92 e0       	ldi	r25, 0x02	; 2
    2fa8:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    usart_transmit(c);
    2fac:	81 2f       	mov	r24, r17
    2fae:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    usart_newline();
    2fb2:	8a e0       	ldi	r24, 0x0A	; 10
    2fb4:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    2fb8:	8d e0       	ldi	r24, 0x0D	; 13
    2fba:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit_str_P(PSTR("c - Cancel selection\r\n"));

  uint8_t c;

  do {
    c = usart_receive();
    2fbe:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
    2fc2:	18 2f       	mov	r17, r24

    if((c >= '0' && c <= '4') || (c == 'c')) {
    2fc4:	80 53       	subi	r24, 0x30	; 48
    2fc6:	85 30       	cpi	r24, 0x05	; 5
    2fc8:	58 f7       	brcc	.-42     	; 0x2fa0 <force_mbc_mode+0x3c>
    usart_transmit(c);
    usart_newline();
  } while(1);

  // Set the new mode 
  if(c == '0') {
    2fca:	10 33       	cpi	r17, 0x30	; 48
    2fcc:	99 f1       	breq	.+102    	; 0x3034 <force_mbc_mode+0xd0>
    // MBC1 or ROM only
    eepData.MBCMode = CART_MODE_MBC1_16M;
    strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
  } else if (c == '1') {
    2fce:	11 33       	cpi	r17, 0x31	; 49
    2fd0:	09 f4       	brne	.+2      	; 0x2fd4 <force_mbc_mode+0x70>
    2fd2:	4e c0       	rjmp	.+156    	; 0x3070 <force_mbc_mode+0x10c>
    eepData.MBCMode = CART_MODE_MBC1_4M;
    strcpy_P(eepData.MBCName, PSTR("MBC1_4M "));
  } else if (c == '2') {
    2fd4:	12 33       	cpi	r17, 0x32	; 50
    2fd6:	c1 f1       	breq	.+112    	; 0x3048 <force_mbc_mode+0xe4>
    eepData.MBCMode = CART_MODE_MBC2;
    strcpy_P(eepData.MBCName, PSTR("MBC2    "));
  } else if (c == '3') {
    2fd8:	13 33       	cpi	r17, 0x33	; 51
    2fda:	51 f4       	brne	.+20     	; 0x2ff0 <force_mbc_mode+0x8c>
    eepData.MBCMode = CART_MODE_MBC3;
    2fdc:	83 e4       	ldi	r24, 0x43	; 67
    2fde:	80 93 90 05 	sts	0x0590, r24
    strcpy_P(eepData.MBCName, PSTR("MBC3    "));
    2fe2:	81 e9       	ldi	r24, 0x91	; 145
    2fe4:	95 e0       	ldi	r25, 0x05	; 5
    2fe6:	6d e0       	ldi	r22, 0x0D	; 13
    2fe8:	72 e0       	ldi	r23, 0x02	; 2
    2fea:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    2fee:	05 c0       	rjmp	.+10     	; 0x2ffa <force_mbc_mode+0x96>
  } else if (c == '4') {
    2ff0:	14 33       	cpi	r17, 0x34	; 52
    2ff2:	a1 f1       	breq	.+104    	; 0x305c <force_mbc_mode+0xf8>
    eepData.MBCMode = CART_MODE_MBC5;
    strcpy_P(eepData.MBCName, PSTR("MBC5    "));
  } else if (c == 'c') {
    2ff4:	13 36       	cpi	r17, 0x63	; 99
    2ff6:	09 f4       	brne	.+2      	; 0x2ffa <force_mbc_mode+0x96>
    2ff8:	45 c0       	rjmp	.+138    	; 0x3084 <force_mbc_mode+0x120>
    usart_transmit_str_P(PSTR("Cancel selection.\r\n"));
  }

  // EEPROM WRITE CYCLE GOES HERE IF DATA IS DIFFERENT!
  write_update_gbeepromdat(&eepData);
    2ffa:	80 e9       	ldi	r24, 0x90	; 144
    2ffc:	95 e0       	ldi	r25, 0x05	; 5
    2ffe:	0e 94 a9 20 	call	0x4152	; 0x4152 <write_update_gbeepromdat>

  usart_transmit_str_P(PSTR("MBC mode is now: "));
    3002:	8e ed       	ldi	r24, 0xDE	; 222
    3004:	91 e0       	ldi	r25, 0x01	; 1
    3006:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit_str(eepData.MBCName);
    300a:	81 e9       	ldi	r24, 0x91	; 145
    300c:	95 e0       	ldi	r25, 0x05	; 5
    300e:	0e 94 2a 06 	call	0xc54	; 0xc54 <usart_transmit_str>
  usart_newline();
    3012:	8a e0       	ldi	r24, 0x0A	; 10
    3014:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    3018:	8d e0       	ldi	r24, 0x0D	; 13
    301a:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    301e:	86 e3       	ldi	r24, 0x36	; 54
    3020:	91 e0       	ldi	r25, 0x01	; 1
    3022:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    3026:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    302a:	80 32       	cpi	r24, 0x20	; 32
    302c:	e1 f7       	brne	.-8      	; 0x3026 <force_mbc_mode+0xc2>
  usart_transmit_str(eepData.MBCName);
  usart_newline();

  wait_for_continue();
  return 0;
}
    302e:	80 e0       	ldi	r24, 0x00	; 0
    3030:	1f 91       	pop	r17
    3032:	08 95       	ret
  } while(1);

  // Set the new mode 
  if(c == '0') {
    // MBC1 or ROM only
    eepData.MBCMode = CART_MODE_MBC1_16M;
    3034:	80 e4       	ldi	r24, 0x40	; 64
    3036:	80 93 90 05 	sts	0x0590, r24
    strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
    303a:	81 e9       	ldi	r24, 0x91	; 145
    303c:	95 e0       	ldi	r25, 0x05	; 5
    303e:	68 e2       	ldi	r22, 0x28	; 40
    3040:	72 e0       	ldi	r23, 0x02	; 2
    3042:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    3046:	d9 cf       	rjmp	.-78     	; 0x2ffa <force_mbc_mode+0x96>
  } else if (c == '1') {
    eepData.MBCMode = CART_MODE_MBC1_4M;
    strcpy_P(eepData.MBCName, PSTR("MBC1_4M "));
  } else if (c == '2') {
    eepData.MBCMode = CART_MODE_MBC2;
    3048:	85 e4       	ldi	r24, 0x45	; 69
    304a:	80 93 90 05 	sts	0x0590, r24
    strcpy_P(eepData.MBCName, PSTR("MBC2    "));
    304e:	81 e9       	ldi	r24, 0x91	; 145
    3050:	95 e0       	ldi	r25, 0x05	; 5
    3052:	66 e1       	ldi	r22, 0x16	; 22
    3054:	72 e0       	ldi	r23, 0x02	; 2
    3056:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    305a:	cf cf       	rjmp	.-98     	; 0x2ffa <force_mbc_mode+0x96>
  } else if (c == '3') {
    eepData.MBCMode = CART_MODE_MBC3;
    strcpy_P(eepData.MBCName, PSTR("MBC3    "));
  } else if (c == '4') {
    eepData.MBCMode = CART_MODE_MBC5;
    305c:	82 e4       	ldi	r24, 0x42	; 66
    305e:	80 93 90 05 	sts	0x0590, r24
    strcpy_P(eepData.MBCName, PSTR("MBC5    "));
    3062:	81 e9       	ldi	r24, 0x91	; 145
    3064:	95 e0       	ldi	r25, 0x05	; 5
    3066:	64 e0       	ldi	r22, 0x04	; 4
    3068:	72 e0       	ldi	r23, 0x02	; 2
    306a:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    306e:	c5 cf       	rjmp	.-118    	; 0x2ffa <force_mbc_mode+0x96>
  if(c == '0') {
    // MBC1 or ROM only
    eepData.MBCMode = CART_MODE_MBC1_16M;
    strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
  } else if (c == '1') {
    eepData.MBCMode = CART_MODE_MBC1_4M;
    3070:	81 e4       	ldi	r24, 0x41	; 65
    3072:	80 93 90 05 	sts	0x0590, r24
    strcpy_P(eepData.MBCName, PSTR("MBC1_4M "));
    3076:	81 e9       	ldi	r24, 0x91	; 145
    3078:	95 e0       	ldi	r25, 0x05	; 5
    307a:	6f e1       	ldi	r22, 0x1F	; 31
    307c:	72 e0       	ldi	r23, 0x02	; 2
    307e:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    3082:	bb cf       	rjmp	.-138    	; 0x2ffa <force_mbc_mode+0x96>
    strcpy_P(eepData.MBCName, PSTR("MBC3    "));
  } else if (c == '4') {
    eepData.MBCMode = CART_MODE_MBC5;
    strcpy_P(eepData.MBCName, PSTR("MBC5    "));
  } else if (c == 'c') {
    usart_transmit_str_P(PSTR("Cancel selection.\r\n"));
    3084:	80 ef       	ldi	r24, 0xF0	; 240
    3086:	91 e0       	ldi	r25, 0x01	; 1
    3088:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    308c:	b6 cf       	rjmp	.-148    	; 0x2ffa <force_mbc_mode+0x96>

0000308e <flash_diagnostic>:

  wait_for_continue();
  return 0;
}

uint8_t flash_diagnostic() {
    308e:	1f 93       	push	r17

  uint8_t flashID = sst_read_softwareID(0);
    3090:	80 e0       	ldi	r24, 0x00	; 0
    3092:	0e 94 47 14 	call	0x288e	; 0x288e <sst_read_softwareID>
    3096:	18 2f       	mov	r17, r24

  usart_transmit_str_P(PSTR("Flash chip ID (expecting 0xB7)\r\n0: 0x"));
    3098:	82 ed       	ldi	r24, 0xD2	; 210
    309a:	92 e0       	ldi	r25, 0x02	; 2
    309c:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit(nibble_to_hex(flashID >> 4));
    30a0:	81 2f       	mov	r24, r17
    30a2:	82 95       	swap	r24
    30a4:	8f 70       	andi	r24, 0x0F	; 15
    30a6:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    30aa:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit(nibble_to_hex(flashID));
    30ae:	81 2f       	mov	r24, r17
    30b0:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    30b4:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_newline();
    30b8:	8a e0       	ldi	r24, 0x0A	; 10
    30ba:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    30be:	8d e0       	ldi	r24, 0x0D	; 13
    30c0:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  flashID = sst_read_softwareID(1);
    30c4:	81 e0       	ldi	r24, 0x01	; 1
    30c6:	0e 94 47 14 	call	0x288e	; 0x288e <sst_read_softwareID>
    30ca:	18 2f       	mov	r17, r24
  usart_transmit_str_P(PSTR("1: 0x"));
    30cc:	8c ec       	ldi	r24, 0xCC	; 204
    30ce:	92 e0       	ldi	r25, 0x02	; 2
    30d0:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit(nibble_to_hex(flashID >> 4));
    30d4:	81 2f       	mov	r24, r17
    30d6:	82 95       	swap	r24
    30d8:	8f 70       	andi	r24, 0x0F	; 15
    30da:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    30de:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit(nibble_to_hex(flashID));
    30e2:	81 2f       	mov	r24, r17
    30e4:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    30e8:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_newline();
    30ec:	8a e0       	ldi	r24, 0x0A	; 10
    30ee:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    30f2:	8d e0       	ldi	r24, 0x0D	; 13
    30f4:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  flashID = sst_read_softwareID(2);
    30f8:	82 e0       	ldi	r24, 0x02	; 2
    30fa:	0e 94 47 14 	call	0x288e	; 0x288e <sst_read_softwareID>
    30fe:	18 2f       	mov	r17, r24
  usart_transmit_str_P(PSTR("2: 0x"));
    3100:	86 ec       	ldi	r24, 0xC6	; 198
    3102:	92 e0       	ldi	r25, 0x02	; 2
    3104:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit(nibble_to_hex(flashID >> 4));
    3108:	81 2f       	mov	r24, r17
    310a:	82 95       	swap	r24
    310c:	8f 70       	andi	r24, 0x0F	; 15
    310e:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    3112:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit(nibble_to_hex(flashID));
    3116:	81 2f       	mov	r24, r17
    3118:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    311c:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_newline();
    3120:	8a e0       	ldi	r24, 0x0A	; 10
    3122:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    3126:	8d e0       	ldi	r24, 0x0D	; 13
    3128:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  flashID = sst_read_softwareID(3);
    312c:	83 e0       	ldi	r24, 0x03	; 3
    312e:	0e 94 47 14 	call	0x288e	; 0x288e <sst_read_softwareID>
    3132:	18 2f       	mov	r17, r24
  usart_transmit_str_P(PSTR("3: 0x"));
    3134:	80 ec       	ldi	r24, 0xC0	; 192
    3136:	92 e0       	ldi	r25, 0x02	; 2
    3138:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit(nibble_to_hex(flashID >> 4));
    313c:	81 2f       	mov	r24, r17
    313e:	82 95       	swap	r24
    3140:	8f 70       	andi	r24, 0x0F	; 15
    3142:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    3146:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_transmit(nibble_to_hex(flashID));
    314a:	81 2f       	mov	r24, r17
    314c:	0e 94 79 08 	call	0x10f2	; 0x10f2 <nibble_to_hex>
    3150:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  usart_newline();
    3154:	8a e0       	ldi	r24, 0x0A	; 10
    3156:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    315a:	8d e0       	ldi	r24, 0x0D	; 13
    315c:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    3160:	86 e3       	ldi	r24, 0x36	; 54
    3162:	91 e0       	ldi	r25, 0x01	; 1
    3164:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    3168:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    316c:	80 32       	cpi	r24, 0x20	; 32
    316e:	e1 f7       	brne	.-8      	; 0x3168 <flash_diagnostic+0xda>
  usart_transmit(nibble_to_hex(flashID));
  usart_newline();

  wait_for_continue();
  return 0;
}
    3170:	80 e0       	ldi	r24, 0x00	; 0
    3172:	1f 91       	pop	r17
    3174:	08 95       	ret

00003176 <receive_ROM>:

  wait_for_continue();
  return 0;
}

uint8_t receive_ROM() {
    3176:	0f 93       	push	r16
    3178:	1f 93       	push	r17
    317a:	cf 93       	push	r28
    317c:	df 93       	push	r29

  usart_transmit_str_P(PSTR("Confirm you wish to erase and flash a new ROM (Y/N)\r\n"));
    317e:	8e ee       	ldi	r24, 0xEE	; 238
    3180:	95 e0       	ldi	r25, 0x05	; 5
    3182:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

uint8_t wait_for_confirm_cancel() {
  
  char input; 
  do {
    input = usart_receive();
    3186:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while((input != 'Y') && (input != 'N') && (input != 'y') && (input != 'n'));
    318a:	89 35       	cpi	r24, 0x59	; 89
    318c:	c1 f0       	breq	.+48     	; 0x31be <receive_ROM+0x48>
    318e:	8e 34       	cpi	r24, 0x4E	; 78
    3190:	21 f0       	breq	.+8      	; 0x319a <receive_ROM+0x24>
    3192:	89 37       	cpi	r24, 0x79	; 121
    3194:	a1 f0       	breq	.+40     	; 0x31be <receive_ROM+0x48>
    3196:	8e 36       	cpi	r24, 0x6E	; 110
    3198:	b1 f7       	brne	.-20     	; 0x3186 <receive_ROM+0x10>
uint8_t receive_ROM() {

  usart_transmit_str_P(PSTR("Confirm you wish to erase and flash a new ROM (Y/N)\r\n"));

  if(wait_for_confirm_cancel()) {
    usart_transmit_str_P(commonAbort);
    319a:	82 e6       	ldi	r24, 0x62	; 98
    319c:	91 e0       	ldi	r25, 0x01	; 1
    319e:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    31a2:	86 e3       	ldi	r24, 0x36	; 54
    31a4:	91 e0       	ldi	r25, 0x01	; 1
    31a6:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    31aa:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    31ae:	80 32       	cpi	r24, 0x20	; 32
    31b0:	e1 f7       	brne	.-8      	; 0x31aa <receive_ROM+0x34>
    31b2:	81 e0       	ldi	r24, 0x01	; 1
  // EEPROM WRITE CYCLE GOES HERE IF DATA IS DIFFERENT!
  write_update_gbeepromdat(&eepData);

  wait_for_continue();
  return 0;
}
    31b4:	df 91       	pop	r29
    31b6:	cf 91       	pop	r28
    31b8:	1f 91       	pop	r17
    31ba:	0f 91       	pop	r16
    31bc:	08 95       	ret
    usart_transmit_str_P(commonAbort);
    wait_for_continue();
    return 1;
  }

  usart_transmit_str_P(PSTR("Erasing chip(s)\r\n"));
    31be:	8c ed       	ldi	r24, 0xDC	; 220
    31c0:	95 e0       	ldi	r25, 0x05	; 5
    31c2:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  sst_flash_chip_erase(0);
    31c6:	80 e0       	ldi	r24, 0x00	; 0
    31c8:	0e 94 ff 12 	call	0x25fe	; 0x25fe <sst_flash_chip_erase>
  sst_flash_chip_erase(1);
    31cc:	81 e0       	ldi	r24, 0x01	; 1
    31ce:	0e 94 ff 12 	call	0x25fe	; 0x25fe <sst_flash_chip_erase>
  sst_flash_chip_erase(2);
    31d2:	82 e0       	ldi	r24, 0x02	; 2
    31d4:	0e 94 ff 12 	call	0x25fe	; 0x25fe <sst_flash_chip_erase>
  sst_flash_chip_erase(3);
    31d8:	83 e0       	ldi	r24, 0x03	; 3
    31da:	0e 94 ff 12 	call	0x25fe	; 0x25fe <sst_flash_chip_erase>
  
  usart_transmit_str_P(PSTR("10 second delay. Quick, select the file to download via YMODEM protocol\r\n"));
    31de:	82 e9       	ldi	r24, 0x92	; 146
    31e0:	95 e0       	ldi	r25, 0x05	; 5
    31e2:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    31e6:	10 e3       	ldi	r17, 0x30	; 48
    31e8:	c5 e8       	ldi	r28, 0x85	; 133
    31ea:	d2 e0       	ldi	r29, 0x02	; 2

  for(uint8_t i=0; i<10; i++) {
    usart_transmit(i+'0');
    31ec:	81 2f       	mov	r24, r17
    31ee:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    31f2:	20 e0       	ldi	r18, 0x00	; 0
    31f4:	30 e0       	ldi	r19, 0x00	; 0
    31f6:	ce 01       	movw	r24, r28
    31f8:	01 97       	sbiw	r24, 0x01	; 1
    31fa:	f1 f7       	brne	.-4      	; 0x31f8 <receive_ROM+0x82>
    31fc:	2f 5f       	subi	r18, 0xFF	; 255
    31fe:	3f 4f       	sbci	r19, 0xFF	; 255
    3200:	87 e2       	ldi	r24, 0x27	; 39
    3202:	20 31       	cpi	r18, 0x10	; 16
    3204:	38 07       	cpc	r19, r24
    3206:	b9 f7       	brne	.-18     	; 0x31f6 <receive_ROM+0x80>
    3208:	1f 5f       	subi	r17, 0xFF	; 255
  sst_flash_chip_erase(2);
  sst_flash_chip_erase(3);
  
  usart_transmit_str_P(PSTR("10 second delay. Quick, select the file to download via YMODEM protocol\r\n"));

  for(uint8_t i=0; i<10; i++) {
    320a:	1a 33       	cpi	r17, 0x3A	; 58
    320c:	79 f7       	brne	.-34     	; 0x31ec <receive_ROM+0x76>
    usart_transmit(i+'0');
    _delay_ms(1000);
  }
  usart_newline();
    320e:	8a e0       	ldi	r24, 0x0A	; 10
    3210:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    3214:	8d e0       	ldi	r24, 0x0D	; 13
    3216:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>

  flashAddress.address32 = 0; // = 0 normally, change this to debug storing at a high address
    321a:	10 92 4d 05 	sts	0x054D, r1
    321e:	10 92 4e 05 	sts	0x054E, r1
    3222:	10 92 4f 05 	sts	0x054F, r1
    3226:	10 92 50 05 	sts	0x0550, r1
  uint8_t retVal = ymodem_receive(flash_buff_receive, &fileSize);
    322a:	83 e5       	ldi	r24, 0x53	; 83
    322c:	96 e1       	ldi	r25, 0x16	; 22
    322e:	66 e3       	ldi	r22, 0x36	; 54
    3230:	71 e0       	ldi	r23, 0x01	; 1
    3232:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <ymodem_receive>
    3236:	08 2f       	mov	r16, r24
    3238:	20 e0       	ldi	r18, 0x00	; 0
    323a:	30 e0       	ldi	r19, 0x00	; 0
    323c:	45 e8       	ldi	r20, 0x85	; 133
    323e:	52 e0       	ldi	r21, 0x02	; 2
    3240:	ca 01       	movw	r24, r20
    3242:	01 97       	sbiw	r24, 0x01	; 1
    3244:	f1 f7       	brne	.-4      	; 0x3242 <receive_ROM+0xcc>
    3246:	2f 5f       	subi	r18, 0xFF	; 255
    3248:	3f 4f       	sbci	r19, 0xFF	; 255
    324a:	89 e0       	ldi	r24, 0x09	; 9
    324c:	24 3c       	cpi	r18, 0xC4	; 196
    324e:	38 07       	cpc	r19, r24
    3250:	b9 f7       	brne	.-18     	; 0x3240 <receive_ROM+0xca>
  
  _delay_ms(250);

  if (retVal) {
    3252:	00 23       	and	r16, r16
    3254:	f1 f0       	breq	.+60     	; 0x3292 <receive_ROM+0x11c>
    3256:	10 e3       	ldi	r17, 0x30	; 48
    3258:	c5 e8       	ldi	r28, 0x85	; 133
    325a:	d2 e0       	ldi	r29, 0x02	; 2
    for(uint8_t i=0; i<10; i++) {
      usart_transmit(i+'0');
    325c:	81 2f       	mov	r24, r17
    325e:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    3262:	20 e0       	ldi	r18, 0x00	; 0
    3264:	30 e0       	ldi	r19, 0x00	; 0
    3266:	ce 01       	movw	r24, r28
    3268:	01 97       	sbiw	r24, 0x01	; 1
    326a:	f1 f7       	brne	.-4      	; 0x3268 <receive_ROM+0xf2>
    326c:	2f 5f       	subi	r18, 0xFF	; 255
    326e:	3f 4f       	sbci	r19, 0xFF	; 255
    3270:	87 e2       	ldi	r24, 0x27	; 39
    3272:	20 31       	cpi	r18, 0x10	; 16
    3274:	38 07       	cpc	r19, r24
    3276:	b9 f7       	brne	.-18     	; 0x3266 <receive_ROM+0xf0>
    3278:	1f 5f       	subi	r17, 0xFF	; 255
  uint8_t retVal = ymodem_receive(flash_buff_receive, &fileSize);
  
  _delay_ms(250);

  if (retVal) {
    for(uint8_t i=0; i<10; i++) {
    327a:	1a 33       	cpi	r17, 0x3A	; 58
    327c:	79 f7       	brne	.-34     	; 0x325c <receive_ROM+0xe6>
      usart_transmit(i+'0');
      _delay_ms(1000);
    }
    usart_transmit_str_P(PSTR("\r\nError: "));
    327e:	88 e8       	ldi	r24, 0x88	; 136
    3280:	95 e0       	ldi	r25, 0x05	; 5
    3282:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    usart_transmit_int32(retVal);
    3286:	60 2f       	mov	r22, r16
    3288:	70 e0       	ldi	r23, 0x00	; 0
    328a:	80 e0       	ldi	r24, 0x00	; 0
    328c:	90 e0       	ldi	r25, 0x00	; 0
    328e:	0e 94 4f 06 	call	0xc9e	; 0xc9e <usart_transmit_int32>
  } 

  usart_transmit_str_P(PSTR("\r\nFile received! Size: "));
    3292:	80 e7       	ldi	r24, 0x70	; 112
    3294:	95 e0       	ldi	r25, 0x05	; 5
    3296:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit_int32(fileSize);
    329a:	60 91 36 01 	lds	r22, 0x0136
    329e:	70 91 37 01 	lds	r23, 0x0137
    32a2:	80 91 38 01 	lds	r24, 0x0138
    32a6:	90 91 39 01 	lds	r25, 0x0139
    32aa:	0e 94 4f 06 	call	0xc9e	; 0xc9e <usart_transmit_int32>
  usart_transmit_str_P(PSTR("\r\nMax address        : "));
    32ae:	88 e5       	ldi	r24, 0x58	; 88
    32b0:	95 e0       	ldi	r25, 0x05	; 5
    32b2:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit_int32(flashAddress.address32);
    32b6:	60 91 4d 05 	lds	r22, 0x054D
    32ba:	70 91 4e 05 	lds	r23, 0x054E
    32be:	80 91 4f 05 	lds	r24, 0x054F
    32c2:	90 91 50 05 	lds	r25, 0x0550
    32c6:	0e 94 4f 06 	call	0xc9e	; 0xc9e <usart_transmit_int32>
  usart_newline();
    32ca:	8a e0       	ldi	r24, 0x0A	; 10
    32cc:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    32d0:	8d e0       	ldi	r24, 0x0D	; 13
    32d2:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  

  // Must update the EEPROM information too!
  get_GBROM_info(&gbRomData);
    32d6:	87 e5       	ldi	r24, 0x57	; 87
    32d8:	95 e0       	ldi	r25, 0x05	; 5
    32da:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <get_GBROM_info>
  
  // Set the new mode 
  if(gbRomData.MBCtype < 0x04) {
    32de:	90 91 70 05 	lds	r25, 0x0570
    32e2:	94 30       	cpi	r25, 0x04	; 4
    32e4:	b8 f0       	brcs	.+46     	; 0x3314 <receive_ROM+0x19e>
    } else {
      eepData.MBCMode = CART_MODE_MBC1_16M;
      strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
    }
  
  } else if(gbRomData.MBCtype == 0x05 || gbRomData.MBCtype == 0x06) {
    32e6:	89 2f       	mov	r24, r25
    32e8:	85 50       	subi	r24, 0x05	; 5
    32ea:	82 30       	cpi	r24, 0x02	; 2
    32ec:	08 f4       	brcc	.+2      	; 0x32f0 <receive_ROM+0x17a>
    32ee:	6d c0       	rjmp	.+218    	; 0x33ca <receive_ROM+0x254>
    // MBC2
    eepData.MBCMode = CART_MODE_MBC2;
    strcpy_P(eepData.MBCName, PSTR("MBC2    "));

  } else if(gbRomData.MBCtype >= 0x0F && gbRomData.MBCtype <= 0x13) {
    32f0:	89 2f       	mov	r24, r25
    32f2:	8f 50       	subi	r24, 0x0F	; 15
    32f4:	85 30       	cpi	r24, 0x05	; 5
    32f6:	08 f4       	brcc	.+2      	; 0x32fa <receive_ROM+0x184>
    32f8:	5e c0       	rjmp	.+188    	; 0x33b6 <receive_ROM+0x240>
    // MBC3
    eepData.MBCMode = CART_MODE_MBC3;
    strcpy_P(eepData.MBCName, PSTR("MBC3    "));

  } else if(gbRomData.MBCtype >= 0x19) {
    32fa:	99 31       	cpi	r25, 0x19	; 25
    32fc:	08 f4       	brcc	.+2      	; 0x3300 <receive_ROM+0x18a>
    32fe:	47 c0       	rjmp	.+142    	; 0x338e <receive_ROM+0x218>
    // MBC5
    eepData.MBCMode = CART_MODE_MBC5;
    3300:	82 e4       	ldi	r24, 0x42	; 66
    3302:	80 93 90 05 	sts	0x0590, r24
    strcpy_P(eepData.MBCName, PSTR("MBC5    "));
    3306:	81 e9       	ldi	r24, 0x91	; 145
    3308:	95 e0       	ldi	r25, 0x05	; 5
    330a:	66 ed       	ldi	r22, 0xD6	; 214
    330c:	74 e0       	ldi	r23, 0x04	; 4
    330e:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    3312:	21 c0       	rjmp	.+66     	; 0x3356 <receive_ROM+0x1e0>
  
  // Set the new mode 
  if(gbRomData.MBCtype < 0x04) {
    // MBC1 or ROM only
    
    if(gbRomData.RAMsizeBytes > 8192 && gbRomData.ROMsizeBytes <= 524288) {
    3314:	80 91 6e 05 	lds	r24, 0x056E
    3318:	90 91 6f 05 	lds	r25, 0x056F
    331c:	81 50       	subi	r24, 0x01	; 1
    331e:	90 42       	sbci	r25, 0x20	; 32
    3320:	60 f1       	brcs	.+88     	; 0x337a <receive_ROM+0x204>
    3322:	80 91 69 05 	lds	r24, 0x0569
    3326:	90 91 6a 05 	lds	r25, 0x056A
    332a:	a0 91 6b 05 	lds	r26, 0x056B
    332e:	b0 91 6c 05 	lds	r27, 0x056C
    3332:	81 50       	subi	r24, 0x01	; 1
    3334:	90 40       	sbci	r25, 0x00	; 0
    3336:	a8 40       	sbci	r26, 0x08	; 8
    3338:	b0 40       	sbci	r27, 0x00	; 0
    333a:	98 f1       	brcs	.+102    	; 0x33a2 <receive_ROM+0x22c>
      eepData.MBCMode = CART_MODE_MBC1_4M;
      strcpy_P(eepData.MBCName, PSTR("MBC1_4M "));
    } else if(gbRomData.RAMsizeBytes > 8192 && gbRomData.ROMsizeBytes > 524288) {
      eepData.MBCMode = CART_MODE_MBC3;
    333c:	83 e4       	ldi	r24, 0x43	; 67
    333e:	80 93 90 05 	sts	0x0590, r24
      strcpy_P(eepData.MBCName, PSTR("MBC3    "));
    3342:	81 e9       	ldi	r24, 0x91	; 145
    3344:	95 e0       	ldi	r25, 0x05	; 5
    3346:	66 e4       	ldi	r22, 0x46	; 70
    3348:	75 e0       	ldi	r23, 0x05	; 5
    334a:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
      usart_transmit_str_P(PSTR("WARNING: ROM and RAM size both exceed MBC1 mode sizes. Assuming MBC3 mode\r\n"));
    334e:	8a ef       	ldi	r24, 0xFA	; 250
    3350:	94 e0       	ldi	r25, 0x04	; 4
    3352:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    eepData.MBCMode = CART_MODE_MBC1_16M;
    strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
  }

  // EEPROM WRITE CYCLE GOES HERE IF DATA IS DIFFERENT!
  write_update_gbeepromdat(&eepData);
    3356:	80 e9       	ldi	r24, 0x90	; 144
    3358:	95 e0       	ldi	r25, 0x05	; 5
    335a:	0e 94 a9 20 	call	0x4152	; 0x4152 <write_update_gbeepromdat>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    335e:	86 e3       	ldi	r24, 0x36	; 54
    3360:	91 e0       	ldi	r25, 0x01	; 1
    3362:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    3366:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    336a:	80 32       	cpi	r24, 0x20	; 32
    336c:	e1 f7       	brne	.-8      	; 0x3366 <receive_ROM+0x1f0>
    336e:	80 e0       	ldi	r24, 0x00	; 0
  // EEPROM WRITE CYCLE GOES HERE IF DATA IS DIFFERENT!
  write_update_gbeepromdat(&eepData);

  wait_for_continue();
  return 0;
}
    3370:	df 91       	pop	r29
    3372:	cf 91       	pop	r28
    3374:	1f 91       	pop	r17
    3376:	0f 91       	pop	r16
    3378:	08 95       	ret
    } else if(gbRomData.RAMsizeBytes > 8192 && gbRomData.ROMsizeBytes > 524288) {
      eepData.MBCMode = CART_MODE_MBC3;
      strcpy_P(eepData.MBCName, PSTR("MBC3    "));
      usart_transmit_str_P(PSTR("WARNING: ROM and RAM size both exceed MBC1 mode sizes. Assuming MBC3 mode\r\n"));
    } else {
      eepData.MBCMode = CART_MODE_MBC1_16M;
    337a:	80 e4       	ldi	r24, 0x40	; 64
    337c:	80 93 90 05 	sts	0x0590, r24
      strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
    3380:	81 e9       	ldi	r24, 0x91	; 145
    3382:	95 e0       	ldi	r25, 0x05	; 5
    3384:	61 ef       	ldi	r22, 0xF1	; 241
    3386:	74 e0       	ldi	r23, 0x04	; 4
    3388:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    338c:	e4 cf       	rjmp	.-56     	; 0x3356 <receive_ROM+0x1e0>
    // MBC5
    eepData.MBCMode = CART_MODE_MBC5;
    strcpy_P(eepData.MBCName, PSTR("MBC5    "));
  } else {
    // default to MBC116M8k unless someone else says...
    eepData.MBCMode = CART_MODE_MBC1_16M;
    338e:	80 e4       	ldi	r24, 0x40	; 64
    3390:	80 93 90 05 	sts	0x0590, r24
    strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
    3394:	81 e9       	ldi	r24, 0x91	; 145
    3396:	95 e0       	ldi	r25, 0x05	; 5
    3398:	6d ec       	ldi	r22, 0xCD	; 205
    339a:	74 e0       	ldi	r23, 0x04	; 4
    339c:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    33a0:	da cf       	rjmp	.-76     	; 0x3356 <receive_ROM+0x1e0>
  // Set the new mode 
  if(gbRomData.MBCtype < 0x04) {
    // MBC1 or ROM only
    
    if(gbRomData.RAMsizeBytes > 8192 && gbRomData.ROMsizeBytes <= 524288) {
      eepData.MBCMode = CART_MODE_MBC1_4M;
    33a2:	81 e4       	ldi	r24, 0x41	; 65
    33a4:	80 93 90 05 	sts	0x0590, r24
      strcpy_P(eepData.MBCName, PSTR("MBC1_4M "));
    33a8:	81 e9       	ldi	r24, 0x91	; 145
    33aa:	95 e0       	ldi	r25, 0x05	; 5
    33ac:	6f e4       	ldi	r22, 0x4F	; 79
    33ae:	75 e0       	ldi	r23, 0x05	; 5
    33b0:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    33b4:	d0 cf       	rjmp	.-96     	; 0x3356 <receive_ROM+0x1e0>
    eepData.MBCMode = CART_MODE_MBC2;
    strcpy_P(eepData.MBCName, PSTR("MBC2    "));

  } else if(gbRomData.MBCtype >= 0x0F && gbRomData.MBCtype <= 0x13) {
    // MBC3
    eepData.MBCMode = CART_MODE_MBC3;
    33b6:	83 e4       	ldi	r24, 0x43	; 67
    33b8:	80 93 90 05 	sts	0x0590, r24
    strcpy_P(eepData.MBCName, PSTR("MBC3    "));
    33bc:	81 e9       	ldi	r24, 0x91	; 145
    33be:	95 e0       	ldi	r25, 0x05	; 5
    33c0:	6f ed       	ldi	r22, 0xDF	; 223
    33c2:	74 e0       	ldi	r23, 0x04	; 4
    33c4:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    33c8:	c6 cf       	rjmp	.-116    	; 0x3356 <receive_ROM+0x1e0>
      strcpy_P(eepData.MBCName, PSTR("MBC1_16M"));
    }
  
  } else if(gbRomData.MBCtype == 0x05 || gbRomData.MBCtype == 0x06) {
    // MBC2
    eepData.MBCMode = CART_MODE_MBC2;
    33ca:	85 e4       	ldi	r24, 0x45	; 69
    33cc:	80 93 90 05 	sts	0x0590, r24
    strcpy_P(eepData.MBCName, PSTR("MBC2    "));
    33d0:	81 e9       	ldi	r24, 0x91	; 145
    33d2:	95 e0       	ldi	r25, 0x05	; 5
    33d4:	68 ee       	ldi	r22, 0xE8	; 232
    33d6:	74 e0       	ldi	r23, 0x04	; 4
    33d8:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    33dc:	bc cf       	rjmp	.-136    	; 0x3356 <receive_ROM+0x1e0>

000033de <receive_save>:

  wait_for_continue();
  return 0;
}

uint8_t receive_save() {
    33de:	1f 93       	push	r17
    33e0:	cf 93       	push	r28
    33e2:	df 93       	push	r29

  usart_transmit_str_P(PSTR("Confirm you wish to download a save file (Y/N)\r\n"));
    33e4:	84 e1       	ldi	r24, 0x14	; 20
    33e6:	94 e0       	ldi	r25, 0x04	; 4
    33e8:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

uint8_t wait_for_confirm_cancel() {
  
  char input; 
  do {
    input = usart_receive();
    33ec:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while((input != 'Y') && (input != 'N') && (input != 'y') && (input != 'n'));
    33f0:	89 35       	cpi	r24, 0x59	; 89
    33f2:	b9 f0       	breq	.+46     	; 0x3422 <receive_save+0x44>
    33f4:	8e 34       	cpi	r24, 0x4E	; 78
    33f6:	21 f0       	breq	.+8      	; 0x3400 <receive_save+0x22>
    33f8:	89 37       	cpi	r24, 0x79	; 121
    33fa:	99 f0       	breq	.+38     	; 0x3422 <receive_save+0x44>
    33fc:	8e 36       	cpi	r24, 0x6E	; 110
    33fe:	b1 f7       	brne	.-20     	; 0x33ec <receive_save+0xe>
uint8_t receive_save() {

  usart_transmit_str_P(PSTR("Confirm you wish to download a save file (Y/N)\r\n"));

  if(wait_for_confirm_cancel()) {
    usart_transmit_str_P(commonAbort);
    3400:	82 e6       	ldi	r24, 0x62	; 98
    3402:	91 e0       	ldi	r25, 0x01	; 1
    3404:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    3408:	86 e3       	ldi	r24, 0x36	; 54
    340a:	91 e0       	ldi	r25, 0x01	; 1
    340c:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    3410:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    3414:	80 32       	cpi	r24, 0x20	; 32
    3416:	e1 f7       	brne	.-8      	; 0x3410 <receive_save+0x32>
    3418:	81 e0       	ldi	r24, 0x01	; 1
    usart_newline();
  }

  wait_for_continue();
  return 0;
}
    341a:	df 91       	pop	r29
    341c:	cf 91       	pop	r28
    341e:	1f 91       	pop	r17
    3420:	08 95       	ret
    usart_transmit_str_P(commonAbort);
    wait_for_continue();
    return 1;
  }
  
  usart_transmit_str_P(PSTR("10 second delay. Quick, select the file to download via YMODEM protocol\r\n"));
    3422:	8a ec       	ldi	r24, 0xCA	; 202
    3424:	93 e0       	ldi	r25, 0x03	; 3
    3426:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    342a:	10 e3       	ldi	r17, 0x30	; 48
    342c:	c5 e8       	ldi	r28, 0x85	; 133
    342e:	d2 e0       	ldi	r29, 0x02	; 2

  for(uint8_t i=0; i<10; i++) {
    usart_transmit(i+'0');
    3430:	81 2f       	mov	r24, r17
    3432:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    3436:	20 e0       	ldi	r18, 0x00	; 0
    3438:	30 e0       	ldi	r19, 0x00	; 0
    343a:	ce 01       	movw	r24, r28
    343c:	01 97       	sbiw	r24, 0x01	; 1
    343e:	f1 f7       	brne	.-4      	; 0x343c <receive_save+0x5e>
    3440:	2f 5f       	subi	r18, 0xFF	; 255
    3442:	3f 4f       	sbci	r19, 0xFF	; 255
    3444:	87 e2       	ldi	r24, 0x27	; 39
    3446:	20 31       	cpi	r18, 0x10	; 16
    3448:	38 07       	cpc	r19, r24
    344a:	b9 f7       	brne	.-18     	; 0x343a <receive_save+0x5c>
    344c:	1f 5f       	subi	r17, 0xFF	; 255
    return 1;
  }
  
  usart_transmit_str_P(PSTR("10 second delay. Quick, select the file to download via YMODEM protocol\r\n"));

  for(uint8_t i=0; i<10; i++) {
    344e:	1a 33       	cpi	r17, 0x3A	; 58
    3450:	79 f7       	brne	.-34     	; 0x3430 <receive_save+0x52>
    usart_transmit(i+'0');
    _delay_ms(1000);
  }
  usart_newline();
    3452:	8a e0       	ldi	r24, 0x0A	; 10
    3454:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    3458:	8d e0       	ldi	r24, 0x0D	; 13
    345a:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
  
  RAMaddress = 0;
    345e:	10 92 3a 01 	sts	0x013A, r1
    3462:	10 92 3b 01 	sts	0x013B, r1
    3466:	10 92 3c 01 	sts	0x013C, r1
    346a:	10 92 3d 01 	sts	0x013D, r1
  RAMWriteErrors = 0;
    346e:	10 92 56 05 	sts	0x0556, r1
    3472:	10 92 55 05 	sts	0x0555, r1
  ymodem_receive(sram_buff_receive, &fileSize);
    3476:	85 ee       	ldi	r24, 0xE5	; 229
    3478:	95 e1       	ldi	r25, 0x15	; 21
    347a:	66 e3       	ldi	r22, 0x36	; 54
    347c:	71 e0       	ldi	r23, 0x01	; 1
    347e:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <ymodem_receive>

  usart_transmit_str_P(PSTR("\r\nFile received! Size: "));
    3482:	82 eb       	ldi	r24, 0xB2	; 178
    3484:	93 e0       	ldi	r25, 0x03	; 3
    3486:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  usart_transmit_int32(fileSize);
    348a:	60 91 36 01 	lds	r22, 0x0136
    348e:	70 91 37 01 	lds	r23, 0x0137
    3492:	80 91 38 01 	lds	r24, 0x0138
    3496:	90 91 39 01 	lds	r25, 0x0139
    349a:	0e 94 4f 06 	call	0xc9e	; 0xc9e <usart_transmit_int32>
  usart_newline();
    349e:	8a e0       	ldi	r24, 0x0A	; 10
    34a0:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    34a4:	8d e0       	ldi	r24, 0x0D	; 13
    34a6:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>

  if(RAMWriteErrors) {
    34aa:	80 91 55 05 	lds	r24, 0x0555
    34ae:	90 91 56 05 	lds	r25, 0x0556
    34b2:	89 2b       	or	r24, r25
    34b4:	69 f4       	brne	.+26     	; 0x34d0 <receive_save+0xf2>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    34b6:	86 e3       	ldi	r24, 0x36	; 54
    34b8:	91 e0       	ldi	r25, 0x01	; 1
    34ba:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    34be:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    34c2:	80 32       	cpi	r24, 0x20	; 32
    34c4:	e1 f7       	brne	.-8      	; 0x34be <receive_save+0xe0>
    34c6:	80 e0       	ldi	r24, 0x00	; 0
    usart_newline();
  }

  wait_for_continue();
  return 0;
}
    34c8:	df 91       	pop	r29
    34ca:	cf 91       	pop	r28
    34cc:	1f 91       	pop	r17
    34ce:	08 95       	ret
  usart_transmit_str_P(PSTR("\r\nFile received! Size: "));
  usart_transmit_int32(fileSize);
  usart_newline();

  if(RAMWriteErrors) {
    usart_transmit_str_P(PSTR("RAM write errors: "));
    34d0:	8f e9       	ldi	r24, 0x9F	; 159
    34d2:	93 e0       	ldi	r25, 0x03	; 3
    34d4:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    usart_transmit_int32(RAMWriteErrors);
    34d8:	60 91 55 05 	lds	r22, 0x0555
    34dc:	70 91 56 05 	lds	r23, 0x0556
    34e0:	80 e0       	ldi	r24, 0x00	; 0
    34e2:	90 e0       	ldi	r25, 0x00	; 0
    34e4:	0e 94 4f 06 	call	0xc9e	; 0xc9e <usart_transmit_int32>
    usart_newline();
    34e8:	8a e0       	ldi	r24, 0x0A	; 10
    34ea:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    34ee:	8d e0       	ldi	r24, 0x0D	; 13
    34f0:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    usart_transmit_str_P(PSTR("First Addr: "));
    34f4:	82 e9       	ldi	r24, 0x92	; 146
    34f6:	93 e0       	ldi	r25, 0x03	; 3
    34f8:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    usart_transmit_int32(RAMWriteErrorsAddrFirst);
    34fc:	60 91 53 05 	lds	r22, 0x0553
    3500:	70 91 54 05 	lds	r23, 0x0554
    3504:	80 e0       	ldi	r24, 0x00	; 0
    3506:	90 e0       	ldi	r25, 0x00	; 0
    3508:	0e 94 4f 06 	call	0xc9e	; 0xc9e <usart_transmit_int32>
    usart_newline();
    350c:	8a e0       	ldi	r24, 0x0A	; 10
    350e:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    3512:	8d e0       	ldi	r24, 0x0D	; 13
    3514:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    usart_transmit_str_P(PSTR("Last Addr: "));
    3518:	86 e8       	ldi	r24, 0x86	; 134
    351a:	93 e0       	ldi	r25, 0x03	; 3
    351c:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    usart_transmit_int32(RAMWriteErrorsAddrLast);
    3520:	60 91 51 05 	lds	r22, 0x0551
    3524:	70 91 52 05 	lds	r23, 0x0552
    3528:	80 e0       	ldi	r24, 0x00	; 0
    352a:	90 e0       	ldi	r25, 0x00	; 0
    352c:	0e 94 4f 06 	call	0xc9e	; 0xc9e <usart_transmit_int32>
    usart_newline();
    3530:	8a e0       	ldi	r24, 0x0A	; 10
    3532:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    3536:	8d e0       	ldi	r24, 0x0D	; 13
    3538:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    353c:	bc cf       	rjmp	.-136    	; 0x34b6 <receive_save+0xd8>

0000353e <dump_save>:
  return 0;
}

uint8_t dump_save() {

  usart_transmit_str_P(PSTR("Confirm you wish to dump the current save file (Y/N)\r\n"));
    353e:	8f e4       	ldi	r24, 0x4F	; 79
    3540:	93 e0       	ldi	r25, 0x03	; 3
    3542:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

uint8_t wait_for_confirm_cancel() {
  
  char input; 
  do {
    input = usart_receive();
    3546:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while((input != 'Y') && (input != 'N') && (input != 'y') && (input != 'n'));
    354a:	89 35       	cpi	r24, 0x59	; 89
    354c:	a1 f0       	breq	.+40     	; 0x3576 <dump_save+0x38>
    354e:	8e 34       	cpi	r24, 0x4E	; 78
    3550:	21 f0       	breq	.+8      	; 0x355a <dump_save+0x1c>
    3552:	89 37       	cpi	r24, 0x79	; 121
    3554:	81 f0       	breq	.+32     	; 0x3576 <dump_save+0x38>
    3556:	8e 36       	cpi	r24, 0x6E	; 110
    3558:	b1 f7       	brne	.-20     	; 0x3546 <dump_save+0x8>

  usart_transmit_str_P(PSTR("Confirm you wish to dump the current save file (Y/N)\r\n"));

  if(wait_for_confirm_cancel()) {
    // Abort
    usart_transmit_str_P(commonAbort);
    355a:	82 e6       	ldi	r24, 0x62	; 98
    355c:	91 e0       	ldi	r25, 0x01	; 1
    355e:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    3562:	86 e3       	ldi	r24, 0x36	; 54
    3564:	91 e0       	ldi	r25, 0x01	; 1
    3566:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    356a:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    356e:	80 32       	cpi	r24, 0x20	; 32
    3570:	e1 f7       	brne	.-8      	; 0x356a <dump_save+0x2c>
    3572:	81 e0       	ldi	r24, 0x01	; 1
    3574:	08 95       	ret
    usart_transmit_str_P(commonAbort);
    wait_for_continue();
    return 1;
  }

  usart_transmit_str_P(PSTR("Select YMODEM receive on your terminal to download. AVR will be waiting\r\n"));
    3576:	85 e0       	ldi	r24, 0x05	; 5
    3578:	93 e0       	ldi	r25, 0x03	; 3
    357a:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  RAMaddress = 0;
    357e:	10 92 3a 01 	sts	0x013A, r1
    3582:	10 92 3b 01 	sts	0x013B, r1
    3586:	10 92 3c 01 	sts	0x013C, r1
    358a:	10 92 3d 01 	sts	0x013D, r1
  ymodem_send(sram_buff_send, "GBDump.sav", gbRomData.RAMsizeBytes);
    358e:	20 91 6e 05 	lds	r18, 0x056E
    3592:	30 91 6f 05 	lds	r19, 0x056F
    3596:	40 e0       	ldi	r20, 0x00	; 0
    3598:	50 e0       	ldi	r21, 0x00	; 0
    359a:	80 eb       	ldi	r24, 0xB0	; 176
    359c:	95 e1       	ldi	r25, 0x15	; 21
    359e:	65 e1       	ldi	r22, 0x15	; 21
    35a0:	71 e0       	ldi	r23, 0x01	; 1
    35a2:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <ymodem_send>

  usart_transmit_str_P(PSTR("File sent!\r\n"));
    35a6:	88 ef       	ldi	r24, 0xF8	; 248
    35a8:	92 e0       	ldi	r25, 0x02	; 2
    35aa:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    35ae:	86 e3       	ldi	r24, 0x36	; 54
    35b0:	91 e0       	ldi	r25, 0x01	; 1
    35b2:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    35b6:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    35ba:	80 32       	cpi	r24, 0x20	; 32
    35bc:	e1 f7       	brne	.-8      	; 0x35b6 <dump_save+0x78>
    35be:	80 e0       	ldi	r24, 0x00	; 0

  usart_transmit_str_P(PSTR("File sent!\r\n"));

  wait_for_continue();
  return 0;
}
    35c0:	08 95       	ret

000035c2 <dump_ROM>:
  return 0;
}

uint8_t dump_ROM() {

  usart_transmit_str_P(PSTR("Confirm you wish to dump the current ROM (Y/N)\r\n"));
    35c2:	8c e9       	ldi	r24, 0x9C	; 156
    35c4:	94 e0       	ldi	r25, 0x04	; 4
    35c6:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

uint8_t wait_for_confirm_cancel() {
  
  char input; 
  do {
    input = usart_receive();
    35ca:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while((input != 'Y') && (input != 'N') && (input != 'y') && (input != 'n'));
    35ce:	89 35       	cpi	r24, 0x59	; 89
    35d0:	a1 f0       	breq	.+40     	; 0x35fa <dump_ROM+0x38>
    35d2:	8e 34       	cpi	r24, 0x4E	; 78
    35d4:	21 f0       	breq	.+8      	; 0x35de <dump_ROM+0x1c>
    35d6:	89 37       	cpi	r24, 0x79	; 121
    35d8:	81 f0       	breq	.+32     	; 0x35fa <dump_ROM+0x38>
    35da:	8e 36       	cpi	r24, 0x6E	; 110
    35dc:	b1 f7       	brne	.-20     	; 0x35ca <dump_ROM+0x8>

  usart_transmit_str_P(PSTR("Confirm you wish to dump the current ROM (Y/N)\r\n"));

  if(wait_for_confirm_cancel()) {
    // Abort
    usart_transmit_str_P(commonAbort);
    35de:	82 e6       	ldi	r24, 0x62	; 98
    35e0:	91 e0       	ldi	r25, 0x01	; 1
    35e2:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    35e6:	86 e3       	ldi	r24, 0x36	; 54
    35e8:	91 e0       	ldi	r25, 0x01	; 1
    35ea:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    35ee:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    35f2:	80 32       	cpi	r24, 0x20	; 32
    35f4:	e1 f7       	brne	.-8      	; 0x35ee <dump_ROM+0x2c>
    35f6:	81 e0       	ldi	r24, 0x01	; 1
    35f8:	08 95       	ret
    usart_transmit_str_P(commonAbort);
    wait_for_continue();
    return 1;
  }

  usart_transmit_str_P(PSTR("Select YMODEM receive on your terminal to download. AVR will be waiting\r\n"));
    35fa:	82 e5       	ldi	r24, 0x52	; 82
    35fc:	94 e0       	ldi	r25, 0x04	; 4
    35fe:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  flashAddress.address32 = 0; // Reset the address again
    3602:	10 92 4d 05 	sts	0x054D, r1
    3606:	10 92 4e 05 	sts	0x054E, r1
    360a:	10 92 4f 05 	sts	0x054F, r1
    360e:	10 92 50 05 	sts	0x0550, r1

  // Two different cases here for naming convention at the other end!
  // Might change this later to take the game name from the ROM and send that through
  if(gbRomData.CGBsupport != GB_PRE_CGB) {
    3612:	80 91 86 05 	lds	r24, 0x0586
    3616:	88 23       	and	r24, r24
    3618:	e1 f4       	brne	.+56     	; 0x3652 <dump_ROM+0x90>
    ymodem_send(flash_buff_send, "GBDump.gbc", gbRomData.ROMsizeBytes);
  } else {
    ymodem_send(flash_buff_send, "GBDump.gb", gbRomData.ROMsizeBytes);
    361a:	20 91 69 05 	lds	r18, 0x0569
    361e:	30 91 6a 05 	lds	r19, 0x056A
    3622:	40 91 6b 05 	lds	r20, 0x056B
    3626:	50 91 6c 05 	lds	r21, 0x056C
    362a:	8a e1       	ldi	r24, 0x1A	; 26
    362c:	96 e1       	ldi	r25, 0x16	; 22
    362e:	6b e2       	ldi	r22, 0x2B	; 43
    3630:	71 e0       	ldi	r23, 0x01	; 1
    3632:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <ymodem_send>
  }
  
  usart_transmit_str_P(PSTR("File sent!\r\n"));
    3636:	85 e4       	ldi	r24, 0x45	; 69
    3638:	94 e0       	ldi	r25, 0x04	; 4
    363a:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    363e:	86 e3       	ldi	r24, 0x36	; 54
    3640:	91 e0       	ldi	r25, 0x01	; 1
    3642:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    3646:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    364a:	80 32       	cpi	r24, 0x20	; 32
    364c:	e1 f7       	brne	.-8      	; 0x3646 <dump_ROM+0x84>
    364e:	80 e0       	ldi	r24, 0x00	; 0
  
  usart_transmit_str_P(PSTR("File sent!\r\n"));

  wait_for_continue();
  return 0;
}
    3650:	08 95       	ret
  flashAddress.address32 = 0; // Reset the address again

  // Two different cases here for naming convention at the other end!
  // Might change this later to take the game name from the ROM and send that through
  if(gbRomData.CGBsupport != GB_PRE_CGB) {
    ymodem_send(flash_buff_send, "GBDump.gbc", gbRomData.ROMsizeBytes);
    3652:	20 91 69 05 	lds	r18, 0x0569
    3656:	30 91 6a 05 	lds	r19, 0x056A
    365a:	40 91 6b 05 	lds	r20, 0x056B
    365e:	50 91 6c 05 	lds	r21, 0x056C
    3662:	8a e1       	ldi	r24, 0x1A	; 26
    3664:	96 e1       	ldi	r25, 0x16	; 22
    3666:	60 e2       	ldi	r22, 0x20	; 32
    3668:	71 e0       	ldi	r23, 0x01	; 1
    366a:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <ymodem_send>
    366e:	e3 cf       	rjmp	.-58     	; 0x3636 <dump_ROM+0x74>

00003670 <show_menu>:
  4 - Dump a SRAM save to the PC
  5 - Flash diagnostic (confirm present)
  6 - UART settings (change BAUD)

*/
uint8_t show_menu(void) {
    3670:	1f 93       	push	r17
    3672:	cf 93       	push	r28
    3674:	df 93       	push	r29
    3676:	c5 e8       	ldi	r28, 0x85	; 133
    3678:	d2 e0       	ldi	r29, 0x02	; 2

  uint8_t menuVal;
  
  while(1) {

    usart_clear_ht();
    367a:	0e 94 9e 08 	call	0x113c	; 0x113c <usart_clear_ht>
    usart_transmit_str_P(PSTR("Welcome to Blake's GB flash cart\r\nChoose one of the following options\r\n\r\n"));
    367e:	8c ee       	ldi	r24, 0xEC	; 236
    3680:	98 e0       	ldi	r25, 0x08	; 8
    3682:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("0 - Show system and ROM information\r\n"));
    3686:	86 ec       	ldi	r24, 0xC6	; 198
    3688:	98 e0       	ldi	r25, 0x08	; 8
    368a:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("1 - Download new ROM to cart\r\n"));
    368e:	87 ea       	ldi	r24, 0xA7	; 167
    3690:	98 e0       	ldi	r25, 0x08	; 8
    3692:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("2 - Dump ROM to PC\r\n"));
    3696:	82 e9       	ldi	r24, 0x92	; 146
    3698:	98 e0       	ldi	r25, 0x08	; 8
    369a:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("3 - Download save file to cart\r\n"));
    369e:	81 e7       	ldi	r24, 0x71	; 113
    36a0:	98 e0       	ldi	r25, 0x08	; 8
    36a2:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("4 - Dump save file to PC\r\n"));
    36a6:	86 e5       	ldi	r24, 0x56	; 86
    36a8:	98 e0       	ldi	r25, 0x08	; 8
    36aa:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("5 - View flash IC detection\r\n"));
    36ae:	88 e3       	ldi	r24, 0x38	; 56
    36b0:	98 e0       	ldi	r25, 0x08	; 8
    36b2:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("6 - Force MBC mode (for incorrect cartridge header or compatibility tests)\r\n"));
    36b6:	8b ee       	ldi	r24, 0xEB	; 235
    36b8:	97 e0       	ldi	r25, 0x07	; 7
    36ba:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("7 - Flash new cart firmware (must be <56KB due to placement of bootloader)\r\n"));
    36be:	8e e9       	ldi	r24, 0x9E	; 158
    36c0:	97 e0       	ldi	r25, 0x07	; 7
    36c2:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("8 - Enter Gameboy mode - WARNING! DISCONNECT UART!\r\n"));
    36c6:	89 e6       	ldi	r24, 0x69	; 105
    36c8:	97 e0       	ldi	r25, 0x07	; 7
    36ca:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    usart_transmit_str_P(PSTR("\r\nDisconnect the cable before using the cart in a Gameboy!\r\n"));
    36ce:	8c e2       	ldi	r24, 0x2C	; 44
    36d0:	97 e0       	ldi	r25, 0x07	; 7
    36d2:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

    usart_transmit_str_P(PSTR("\r\nUser selection: "));
    36d6:	89 e1       	ldi	r24, 0x19	; 25
    36d8:	97 e0       	ldi	r25, 0x07	; 7
    36da:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    
    menuVal = usart_receive() - '0';
    36de:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
    36e2:	18 2f       	mov	r17, r24
    36e4:	10 53       	subi	r17, 0x30	; 48
    usart_transmit(menuVal + '0');
    36e6:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    usart_newline();
    36ea:	8a e0       	ldi	r24, 0x0A	; 10
    36ec:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>
    36f0:	8d e0       	ldi	r24, 0x0D	; 13
    36f2:	0e 94 1b 06 	call	0xc36	; 0xc36 <usart_transmit>

    if(menuVal == MENU_ROM_INFO) {
    36f6:	11 23       	and	r17, r17
    36f8:	09 f1       	breq	.+66     	; 0x373c <show_menu+0xcc>
      show_ROM_info();

    } else if (menuVal == MENU_RX_ROM) {
    36fa:	11 30       	cpi	r17, 0x01	; 1
    36fc:	11 f1       	breq	.+68     	; 0x3742 <show_menu+0xd2>
      receive_ROM();

    } else if(menuVal == MENU_DUMP_ROM) {
    36fe:	12 30       	cpi	r17, 0x02	; 2
    3700:	19 f1       	breq	.+70     	; 0x3748 <show_menu+0xd8>
      dump_ROM();

    } else if(menuVal == MENU_RX_SAVE) {
    3702:	13 30       	cpi	r17, 0x03	; 3
    3704:	e1 f1       	breq	.+120    	; 0x377e <show_menu+0x10e>
      receive_save();
    
    } else if(menuVal == MENU_DUMP_SAVE) {
    3706:	14 30       	cpi	r17, 0x04	; 4
    3708:	e9 f1       	breq	.+122    	; 0x3784 <show_menu+0x114>
      dump_save();
    
    } else if(menuVal == MENU_FLASH_DIAG) {
    370a:	15 30       	cpi	r17, 0x05	; 5
    370c:	09 f4       	brne	.+2      	; 0x3710 <show_menu+0xa0>
    370e:	57 c0       	rjmp	.+174    	; 0x37be <show_menu+0x14e>
      flash_diagnostic();
    
    } else if(menuVal == MENU_FORCE_MBC) {
    3710:	16 30       	cpi	r17, 0x06	; 6
    3712:	09 f4       	brne	.+2      	; 0x3716 <show_menu+0xa6>
    3714:	83 c0       	rjmp	.+262    	; 0x381c <show_menu+0x1ac>
      force_mbc_mode();

    } else if(menuVal == MENU_NEW_FW) {
    3716:	17 30       	cpi	r17, 0x07	; 7
    3718:	09 f4       	brne	.+2      	; 0x371c <show_menu+0xac>
    371a:	83 c0       	rjmp	.+262    	; 0x3822 <show_menu+0x1b2>
      flash_new_firmware();

    } else if(menuVal == MENU_GB_MODE) {
    371c:	18 30       	cpi	r17, 0x08	; 8
    371e:	09 f4       	brne	.+2      	; 0x3722 <show_menu+0xb2>
    3720:	b0 c0       	rjmp	.+352    	; 0x3882 <show_menu+0x212>
      enter_GB_mode();      

    } else {

      usart_transmit_str_P(PSTR("Unknown request\r\n"));
    3722:	87 e0       	ldi	r24, 0x07	; 7
    3724:	97 e0       	ldi	r25, 0x07	; 7
    3726:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    372a:	86 e3       	ldi	r24, 0x36	; 54
    372c:	91 e0       	ldi	r25, 0x01	; 1
    372e:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    3732:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    3736:	80 32       	cpi	r24, 0x20	; 32
    3738:	e1 f7       	brne	.-8      	; 0x3732 <show_menu+0xc2>
    373a:	9f cf       	rjmp	.-194    	; 0x367a <show_menu+0xa>
    menuVal = usart_receive() - '0';
    usart_transmit(menuVal + '0');
    usart_newline();

    if(menuVal == MENU_ROM_INFO) {
      show_ROM_info();
    373c:	0e 94 e5 16 	call	0x2dca	; 0x2dca <show_ROM_info>
    3740:	9c cf       	rjmp	.-200    	; 0x367a <show_menu+0xa>

    } else if (menuVal == MENU_RX_ROM) {
      receive_ROM();
    3742:	0e 94 bb 18 	call	0x3176	; 0x3176 <receive_ROM>
    3746:	99 cf       	rjmp	.-206    	; 0x367a <show_menu+0xa>
  return 0;
}

uint8_t dump_ROM() {

  usart_transmit_str_P(PSTR("Confirm you wish to dump the current ROM (Y/N)\r\n"));
    3748:	8c e9       	ldi	r24, 0x9C	; 156
    374a:	94 e0       	ldi	r25, 0x04	; 4
    374c:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

uint8_t wait_for_confirm_cancel() {
  
  char input; 
  do {
    input = usart_receive();
    3750:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while((input != 'Y') && (input != 'N') && (input != 'y') && (input != 'n'));
    3754:	89 35       	cpi	r24, 0x59	; 89
    3756:	b1 f1       	breq	.+108    	; 0x37c4 <show_menu+0x154>
    3758:	8e 34       	cpi	r24, 0x4E	; 78
    375a:	21 f0       	breq	.+8      	; 0x3764 <show_menu+0xf4>
    375c:	89 37       	cpi	r24, 0x79	; 121
    375e:	91 f1       	breq	.+100    	; 0x37c4 <show_menu+0x154>
    3760:	8e 36       	cpi	r24, 0x6E	; 110
    3762:	b1 f7       	brne	.-20     	; 0x3750 <show_menu+0xe0>

  usart_transmit_str_P(PSTR("Confirm you wish to dump the current ROM (Y/N)\r\n"));

  if(wait_for_confirm_cancel()) {
    // Abort
    usart_transmit_str_P(commonAbort);
    3764:	82 e6       	ldi	r24, 0x62	; 98
    3766:	91 e0       	ldi	r25, 0x01	; 1
    3768:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    376c:	86 e3       	ldi	r24, 0x36	; 54
    376e:	91 e0       	ldi	r25, 0x01	; 1
    3770:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    3774:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    3778:	80 32       	cpi	r24, 0x20	; 32
    377a:	e1 f7       	brne	.-8      	; 0x3774 <show_menu+0x104>
    377c:	7e cf       	rjmp	.-260    	; 0x367a <show_menu+0xa>

    } else if(menuVal == MENU_DUMP_ROM) {
      dump_ROM();

    } else if(menuVal == MENU_RX_SAVE) {
      receive_save();
    377e:	0e 94 ef 19 	call	0x33de	; 0x33de <receive_save>
    3782:	7b cf       	rjmp	.-266    	; 0x367a <show_menu+0xa>
  return 0;
}

uint8_t dump_save() {

  usart_transmit_str_P(PSTR("Confirm you wish to dump the current save file (Y/N)\r\n"));
    3784:	8f e4       	ldi	r24, 0x4F	; 79
    3786:	93 e0       	ldi	r25, 0x03	; 3
    3788:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

uint8_t wait_for_confirm_cancel() {
  
  char input; 
  do {
    input = usart_receive();
    378c:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while((input != 'Y') && (input != 'N') && (input != 'y') && (input != 'n'));
    3790:	89 35       	cpi	r24, 0x59	; 89
    3792:	09 f4       	brne	.+2      	; 0x3796 <show_menu+0x126>
    3794:	51 c0       	rjmp	.+162    	; 0x3838 <show_menu+0x1c8>
    3796:	8e 34       	cpi	r24, 0x4E	; 78
    3798:	29 f0       	breq	.+10     	; 0x37a4 <show_menu+0x134>
    379a:	89 37       	cpi	r24, 0x79	; 121
    379c:	09 f4       	brne	.+2      	; 0x37a0 <show_menu+0x130>
    379e:	4c c0       	rjmp	.+152    	; 0x3838 <show_menu+0x1c8>
    37a0:	8e 36       	cpi	r24, 0x6E	; 110
    37a2:	a1 f7       	brne	.-24     	; 0x378c <show_menu+0x11c>

  usart_transmit_str_P(PSTR("Confirm you wish to dump the current save file (Y/N)\r\n"));

  if(wait_for_confirm_cancel()) {
    // Abort
    usart_transmit_str_P(commonAbort);
    37a4:	82 e6       	ldi	r24, 0x62	; 98
    37a6:	91 e0       	ldi	r25, 0x01	; 1
    37a8:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    37ac:	86 e3       	ldi	r24, 0x36	; 54
    37ae:	91 e0       	ldi	r25, 0x01	; 1
    37b0:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    37b4:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    37b8:	80 32       	cpi	r24, 0x20	; 32
    37ba:	e1 f7       	brne	.-8      	; 0x37b4 <show_menu+0x144>
    37bc:	5e cf       	rjmp	.-324    	; 0x367a <show_menu+0xa>
    
    } else if(menuVal == MENU_DUMP_SAVE) {
      dump_save();
    
    } else if(menuVal == MENU_FLASH_DIAG) {
      flash_diagnostic();
    37be:	0e 94 47 18 	call	0x308e	; 0x308e <flash_diagnostic>
    37c2:	5b cf       	rjmp	.-330    	; 0x367a <show_menu+0xa>
    usart_transmit_str_P(commonAbort);
    wait_for_continue();
    return 1;
  }

  usart_transmit_str_P(PSTR("Select YMODEM receive on your terminal to download. AVR will be waiting\r\n"));
    37c4:	82 e5       	ldi	r24, 0x52	; 82
    37c6:	94 e0       	ldi	r25, 0x04	; 4
    37c8:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  flashAddress.address32 = 0; // Reset the address again
    37cc:	10 92 4d 05 	sts	0x054D, r1
    37d0:	10 92 4e 05 	sts	0x054E, r1
    37d4:	10 92 4f 05 	sts	0x054F, r1
    37d8:	10 92 50 05 	sts	0x0550, r1

  // Two different cases here for naming convention at the other end!
  // Might change this later to take the game name from the ROM and send that through
  if(gbRomData.CGBsupport != GB_PRE_CGB) {
    37dc:	80 91 86 05 	lds	r24, 0x0586
    37e0:	88 23       	and	r24, r24
    37e2:	09 f4       	brne	.+2      	; 0x37e6 <show_menu+0x176>
    37e4:	69 c0       	rjmp	.+210    	; 0x38b8 <show_menu+0x248>
    ymodem_send(flash_buff_send, "GBDump.gbc", gbRomData.ROMsizeBytes);
    37e6:	20 91 69 05 	lds	r18, 0x0569
    37ea:	30 91 6a 05 	lds	r19, 0x056A
    37ee:	40 91 6b 05 	lds	r20, 0x056B
    37f2:	50 91 6c 05 	lds	r21, 0x056C
    37f6:	8a e1       	ldi	r24, 0x1A	; 26
    37f8:	96 e1       	ldi	r25, 0x16	; 22
    37fa:	60 e2       	ldi	r22, 0x20	; 32
    37fc:	71 e0       	ldi	r23, 0x01	; 1
    37fe:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <ymodem_send>
  } else {
    ymodem_send(flash_buff_send, "GBDump.gb", gbRomData.ROMsizeBytes);
  }
  
  usart_transmit_str_P(PSTR("File sent!\r\n"));
    3802:	85 e4       	ldi	r24, 0x45	; 69
    3804:	94 e0       	ldi	r25, 0x04	; 4
    3806:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    380a:	86 e3       	ldi	r24, 0x36	; 54
    380c:	91 e0       	ldi	r25, 0x01	; 1
    380e:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    3812:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    3816:	80 32       	cpi	r24, 0x20	; 32
    3818:	e1 f7       	brne	.-8      	; 0x3812 <show_menu+0x1a2>
    381a:	2f cf       	rjmp	.-418    	; 0x367a <show_menu+0xa>
    
    } else if(menuVal == MENU_FLASH_DIAG) {
      flash_diagnostic();
    
    } else if(menuVal == MENU_FORCE_MBC) {
      force_mbc_mode();
    381c:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <force_mbc_mode>
    3820:	2c cf       	rjmp	.-424    	; 0x367a <show_menu+0xa>
}

uint8_t flash_new_firmware() { 

  // Run the bootloader
  asm("jmp 0xE000");
    3822:	0c 94 00 70 	jmp	0xe000	; 0xe000 <MBC2_NZERO2+0x54ba>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    3826:	86 e3       	ldi	r24, 0x36	; 54
    3828:	91 e0       	ldi	r25, 0x01	; 1
    382a:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    382e:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    3832:	80 32       	cpi	r24, 0x20	; 32
    3834:	e1 f7       	brne	.-8      	; 0x382e <show_menu+0x1be>
    3836:	21 cf       	rjmp	.-446    	; 0x367a <show_menu+0xa>
    usart_transmit_str_P(commonAbort);
    wait_for_continue();
    return 1;
  }

  usart_transmit_str_P(PSTR("Select YMODEM receive on your terminal to download. AVR will be waiting\r\n"));
    3838:	85 e0       	ldi	r24, 0x05	; 5
    383a:	93 e0       	ldi	r25, 0x03	; 3
    383c:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  RAMaddress = 0;
    3840:	10 92 3a 01 	sts	0x013A, r1
    3844:	10 92 3b 01 	sts	0x013B, r1
    3848:	10 92 3c 01 	sts	0x013C, r1
    384c:	10 92 3d 01 	sts	0x013D, r1
  ymodem_send(sram_buff_send, "GBDump.sav", gbRomData.RAMsizeBytes);
    3850:	20 91 6e 05 	lds	r18, 0x056E
    3854:	30 91 6f 05 	lds	r19, 0x056F
    3858:	40 e0       	ldi	r20, 0x00	; 0
    385a:	50 e0       	ldi	r21, 0x00	; 0
    385c:	80 eb       	ldi	r24, 0xB0	; 176
    385e:	95 e1       	ldi	r25, 0x15	; 21
    3860:	65 e1       	ldi	r22, 0x15	; 21
    3862:	71 e0       	ldi	r23, 0x01	; 1
    3864:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <ymodem_send>

  usart_transmit_str_P(PSTR("File sent!\r\n"));
    3868:	88 ef       	ldi	r24, 0xF8	; 248
    386a:	92 e0       	ldi	r25, 0x02	; 2
    386c:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    3870:	86 e3       	ldi	r24, 0x36	; 54
    3872:	91 e0       	ldi	r25, 0x01	; 1
    3874:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    3878:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    387c:	80 32       	cpi	r24, 0x20	; 32
    387e:	e1 f7       	brne	.-8      	; 0x3878 <show_menu+0x208>
    3880:	fc ce       	rjmp	.-520    	; 0x367a <show_menu+0xa>
  return 0;
}

void enter_GB_mode() {

  usart_transmit_str_P(PSTR("Confirm you wish to disable communication and enter MBC mode (Y/N)\r\n"));
    3882:	89 e9       	ldi	r24, 0x99	; 153
    3884:	91 e0       	ldi	r25, 0x01	; 1
    3886:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

uint8_t wait_for_confirm_cancel() {
  
  char input; 
  do {
    input = usart_receive();
    388a:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while((input != 'Y') && (input != 'N') && (input != 'y') && (input != 'n'));
    388e:	89 35       	cpi	r24, 0x59	; 89
    3890:	11 f1       	breq	.+68     	; 0x38d6 <show_menu+0x266>
    3892:	8e 34       	cpi	r24, 0x4E	; 78
    3894:	21 f0       	breq	.+8      	; 0x389e <show_menu+0x22e>
    3896:	89 37       	cpi	r24, 0x79	; 121
    3898:	f1 f0       	breq	.+60     	; 0x38d6 <show_menu+0x266>
    389a:	8e 36       	cpi	r24, 0x6E	; 110
    389c:	b1 f7       	brne	.-20     	; 0x388a <show_menu+0x21a>

  usart_transmit_str_P(PSTR("Confirm you wish to disable communication and enter MBC mode (Y/N)\r\n"));

  if(wait_for_confirm_cancel()) {
    // Abort
    usart_transmit_str_P(commonAbort);
    389e:	82 e6       	ldi	r24, 0x62	; 98
    38a0:	91 e0       	ldi	r25, 0x01	; 1
    38a2:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    38a6:	86 e3       	ldi	r24, 0x36	; 54
    38a8:	91 e0       	ldi	r25, 0x01	; 1
    38aa:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    38ae:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    38b2:	80 32       	cpi	r24, 0x20	; 32
    38b4:	e1 f7       	brne	.-8      	; 0x38ae <show_menu+0x23e>
    38b6:	e1 ce       	rjmp	.-574    	; 0x367a <show_menu+0xa>
  // Two different cases here for naming convention at the other end!
  // Might change this later to take the game name from the ROM and send that through
  if(gbRomData.CGBsupport != GB_PRE_CGB) {
    ymodem_send(flash_buff_send, "GBDump.gbc", gbRomData.ROMsizeBytes);
  } else {
    ymodem_send(flash_buff_send, "GBDump.gb", gbRomData.ROMsizeBytes);
    38b8:	20 91 69 05 	lds	r18, 0x0569
    38bc:	30 91 6a 05 	lds	r19, 0x056A
    38c0:	40 91 6b 05 	lds	r20, 0x056B
    38c4:	50 91 6c 05 	lds	r21, 0x056C
    38c8:	8a e1       	ldi	r24, 0x1A	; 26
    38ca:	96 e1       	ldi	r25, 0x16	; 22
    38cc:	6b e2       	ldi	r22, 0x2B	; 43
    38ce:	71 e0       	ldi	r23, 0x01	; 1
    38d0:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <ymodem_send>
    38d4:	96 cf       	rjmp	.-212    	; 0x3802 <show_menu+0x192>
    usart_transmit_str_P(commonAbort);
    wait_for_continue();
    return;
  }

  usart_transmit_str_P(PSTR("Bye!\r\n"));
    38d6:	82 e9       	ldi	r24, 0x92	; 146
    38d8:	91 e0       	ldi	r25, 0x01	; 1
    38da:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    38de:	20 e0       	ldi	r18, 0x00	; 0
    38e0:	30 e0       	ldi	r19, 0x00	; 0
    38e2:	ce 01       	movw	r24, r28
    38e4:	01 97       	sbiw	r24, 0x01	; 1
    38e6:	f1 f7       	brne	.-4      	; 0x38e4 <show_menu+0x274>
    38e8:	2f 5f       	subi	r18, 0xFF	; 255
    38ea:	3f 4f       	sbci	r19, 0xFF	; 255
    38ec:	89 e0       	ldi	r24, 0x09	; 9
    38ee:	24 3c       	cpi	r18, 0xC4	; 196
    38f0:	38 07       	cpc	r19, r24
    38f2:	b9 f7       	brne	.-18     	; 0x38e2 <show_menu+0x272>
void launch_mbc_mode(void) {
  
  // Init ports first
  // Should be common inputs and outputs for all MBC modes, even if functions are different

  DDRA = 0xFB; // All outputs except PA5, which is now GB_CS, maybe I need to change RUMBLE (PA2) to input for ADDR12 too
    38f4:	8b ef       	ldi	r24, 0xFB	; 251
    38f6:	81 b9       	out	0x01, r24	; 1
  DDRB = 0;  //DDRB = (1 << PB5) | (1 << PB6) | (1 << PB7); // Port B is data from the GB, note for MBC1, PB5-7 are not connected. Set them as Lo outputs
    38f8:	14 b8       	out	0x04, r1	; 4
  DDRC = 0x7F; // MA output lines, with exception of PC7, which is 
    38fa:	8f e7       	ldi	r24, 0x7F	; 127
    38fc:	87 b9       	out	0x07, r24	; 7
  DDRD = 0;
    38fe:	1a b8       	out	0x0a, r1	; 10

  PORTA = (1 << PA5) | (1 << PA4) | (1 << PA7); // Set (PA5) OE pins and (PA7) INTRAMEN hi, PA4 is Flash WE
    3900:	80 eb       	ldi	r24, 0xB0	; 176
    3902:	82 b9       	out	0x02, r24	; 2
  PORTB = 0;
    3904:	15 b8       	out	0x05, r1	; 5
  PORTC = 0; // no pullups needed on these ports
    3906:	18 b8       	out	0x08, r1	; 8
  PORTD = (1 << PD0) | (1 << PD1); // Set UART pins hi
    3908:	83 e0       	ldi	r24, 0x03	; 3
    390a:	8b b9       	out	0x0b, r24	; 11

  

  // Hmmm. Will need to read EEPROM first to decide which is the correct mode...
  uint8_t mode = read_MBC_mode_only();
    390c:	0e 94 68 20 	call	0x40d0	; 0x40d0 <read_MBC_mode_only>

  if(mode == CART_MODE_MBC1_16M) {
    3910:	80 34       	cpi	r24, 0x40	; 64
    3912:	41 f0       	breq	.+16     	; 0x3924 <show_menu+0x2b4>
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC1_16M8k();

  } else if (mode == CART_MODE_MBC1_4M) {
    3914:	81 34       	cpi	r24, 0x41	; 65
    3916:	91 f0       	breq	.+36     	; 0x393c <show_menu+0x2cc>
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC1_4M32k();

  } else if (mode == CART_MODE_MBC2) {
    3918:	85 34       	cpi	r24, 0x45	; 69
    391a:	b1 f0       	breq	.+44     	; 0x3948 <show_menu+0x2d8>
    PRR = 0xFF; // Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC2();

  } else if (mode == CART_MODE_MBC3) {
    391c:	83 34       	cpi	r24, 0x43	; 67
    391e:	d1 f0       	breq	.+52     	; 0x3954 <show_menu+0x2e4>
    PRR = 0xF7;// Turn off everything except timer1! We want a pseudo RTC!
    MBC_mode_MBC3();

  } else if (mode == CART_MODE_MBC5) {
    3920:	82 34       	cpi	r24, 0x42	; 66
    3922:	31 f0       	breq	.+12     	; 0x3930 <show_menu+0x2c0>
    PRR = 0xFF; // Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC5();

  } else {
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    3924:	8f ef       	ldi	r24, 0xFF	; 255
    3926:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC1_16M8k();
    392a:	0e 94 00 3f 	call	0x7e00	; 0x7e00 <MBC_mode_MBC1_16M8k>
    392e:	a5 ce       	rjmp	.-694    	; 0x367a <show_menu+0xa>
  } else if (mode == CART_MODE_MBC3) {
    PRR = 0xF7;// Turn off everything except timer1! We want a pseudo RTC!
    MBC_mode_MBC3();

  } else if (mode == CART_MODE_MBC5) {
    PRR = 0xFF; // Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    3930:	8f ef       	ldi	r24, 0xFF	; 255
    3932:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC5();
    3936:	0e 94 28 3f 	call	0x7e50	; 0x7e50 <MBC_mode_MBC5>
    393a:	9f ce       	rjmp	.-706    	; 0x367a <show_menu+0xa>
  if(mode == CART_MODE_MBC1_16M) {
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC1_16M8k();

  } else if (mode == CART_MODE_MBC1_4M) {
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    393c:	8f ef       	ldi	r24, 0xFF	; 255
    393e:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC1_4M32k();
    3942:	0e 94 14 3f 	call	0x7e28	; 0x7e28 <MBC_mode_MBC1_4M32k>
    3946:	99 ce       	rjmp	.-718    	; 0x367a <show_menu+0xa>

  } else if (mode == CART_MODE_MBC2) {
    PRR = 0xFF; // Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    3948:	8f ef       	ldi	r24, 0xFF	; 255
    394a:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC2();
    394e:	0e 94 72 3f 	call	0x7ee4	; 0x7ee4 <MBC_mode_MBC2>
    3952:	93 ce       	rjmp	.-730    	; 0x367a <show_menu+0xa>

  } else if (mode == CART_MODE_MBC3) {
    PRR = 0xF7;// Turn off everything except timer1! We want a pseudo RTC!
    3954:	87 ef       	ldi	r24, 0xF7	; 247
    3956:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC3();
    395a:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <MBC_mode_MBC3>
    395e:	8d ce       	rjmp	.-742    	; 0x367a <show_menu+0xa>

00003960 <enter_GB_mode>:
  return 0;
}

void enter_GB_mode() {

  usart_transmit_str_P(PSTR("Confirm you wish to disable communication and enter MBC mode (Y/N)\r\n"));
    3960:	89 e9       	ldi	r24, 0x99	; 153
    3962:	91 e0       	ldi	r25, 0x01	; 1
    3964:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

uint8_t wait_for_confirm_cancel() {
  
  char input; 
  do {
    input = usart_receive();
    3968:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while((input != 'Y') && (input != 'N') && (input != 'y') && (input != 'n'));
    396c:	89 35       	cpi	r24, 0x59	; 89
    396e:	99 f0       	breq	.+38     	; 0x3996 <enter_GB_mode+0x36>
    3970:	8e 34       	cpi	r24, 0x4E	; 78
    3972:	21 f0       	breq	.+8      	; 0x397c <enter_GB_mode+0x1c>
    3974:	89 37       	cpi	r24, 0x79	; 121
    3976:	79 f0       	breq	.+30     	; 0x3996 <enter_GB_mode+0x36>
    3978:	8e 36       	cpi	r24, 0x6E	; 110
    397a:	b1 f7       	brne	.-20     	; 0x3968 <enter_GB_mode+0x8>

  usart_transmit_str_P(PSTR("Confirm you wish to disable communication and enter MBC mode (Y/N)\r\n"));

  if(wait_for_confirm_cancel()) {
    // Abort
    usart_transmit_str_P(commonAbort);
    397c:	82 e6       	ldi	r24, 0x62	; 98
    397e:	91 e0       	ldi	r25, 0x01	; 1
    3980:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
  return 0;
}

void wait_for_continue() {

  usart_transmit_str_P(commonReturn);
    3984:	86 e3       	ldi	r24, 0x36	; 54
    3986:	91 e0       	ldi	r25, 0x01	; 1
    3988:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>

  char input; 
  do {
    input = usart_receive();
    398c:	0e 94 23 06 	call	0xc46	; 0xc46 <usart_receive>
  } while(input != ' ');
    3990:	80 32       	cpi	r24, 0x20	; 32
    3992:	e1 f7       	brne	.-8      	; 0x398c <enter_GB_mode+0x2c>
    3994:	08 95       	ret
    usart_transmit_str_P(commonAbort);
    wait_for_continue();
    return;
  }

  usart_transmit_str_P(PSTR("Bye!\r\n"));
    3996:	82 e9       	ldi	r24, 0x92	; 146
    3998:	91 e0       	ldi	r25, 0x01	; 1
    399a:	0e 94 39 06 	call	0xc72	; 0xc72 <usart_transmit_str_P>
    399e:	20 e0       	ldi	r18, 0x00	; 0
    39a0:	30 e0       	ldi	r19, 0x00	; 0
    39a2:	45 e8       	ldi	r20, 0x85	; 133
    39a4:	52 e0       	ldi	r21, 0x02	; 2
    39a6:	ca 01       	movw	r24, r20
    39a8:	01 97       	sbiw	r24, 0x01	; 1
    39aa:	f1 f7       	brne	.-4      	; 0x39a8 <enter_GB_mode+0x48>
    39ac:	2f 5f       	subi	r18, 0xFF	; 255
    39ae:	3f 4f       	sbci	r19, 0xFF	; 255
    39b0:	89 e0       	ldi	r24, 0x09	; 9
    39b2:	24 3c       	cpi	r18, 0xC4	; 196
    39b4:	38 07       	cpc	r19, r24
    39b6:	b9 f7       	brne	.-18     	; 0x39a6 <enter_GB_mode+0x46>
void launch_mbc_mode(void) {
  
  // Init ports first
  // Should be common inputs and outputs for all MBC modes, even if functions are different

  DDRA = 0xFB; // All outputs except PA5, which is now GB_CS, maybe I need to change RUMBLE (PA2) to input for ADDR12 too
    39b8:	8b ef       	ldi	r24, 0xFB	; 251
    39ba:	81 b9       	out	0x01, r24	; 1
  DDRB = 0;  //DDRB = (1 << PB5) | (1 << PB6) | (1 << PB7); // Port B is data from the GB, note for MBC1, PB5-7 are not connected. Set them as Lo outputs
    39bc:	14 b8       	out	0x04, r1	; 4
  DDRC = 0x7F; // MA output lines, with exception of PC7, which is 
    39be:	8f e7       	ldi	r24, 0x7F	; 127
    39c0:	87 b9       	out	0x07, r24	; 7
  DDRD = 0;
    39c2:	1a b8       	out	0x0a, r1	; 10

  PORTA = (1 << PA5) | (1 << PA4) | (1 << PA7); // Set (PA5) OE pins and (PA7) INTRAMEN hi, PA4 is Flash WE
    39c4:	80 eb       	ldi	r24, 0xB0	; 176
    39c6:	82 b9       	out	0x02, r24	; 2
  PORTB = 0;
    39c8:	15 b8       	out	0x05, r1	; 5
  PORTC = 0; // no pullups needed on these ports
    39ca:	18 b8       	out	0x08, r1	; 8
  PORTD = (1 << PD0) | (1 << PD1); // Set UART pins hi
    39cc:	83 e0       	ldi	r24, 0x03	; 3
    39ce:	8b b9       	out	0x0b, r24	; 11

  

  // Hmmm. Will need to read EEPROM first to decide which is the correct mode...
  uint8_t mode = read_MBC_mode_only();
    39d0:	0e 94 68 20 	call	0x40d0	; 0x40d0 <read_MBC_mode_only>

  if(mode == CART_MODE_MBC1_16M) {
    39d4:	80 34       	cpi	r24, 0x40	; 64
    39d6:	41 f0       	breq	.+16     	; 0x39e8 <enter_GB_mode+0x88>
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC1_16M8k();

  } else if (mode == CART_MODE_MBC1_4M) {
    39d8:	81 34       	cpi	r24, 0x41	; 65
    39da:	91 f0       	breq	.+36     	; 0x3a00 <enter_GB_mode+0xa0>
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC1_4M32k();

  } else if (mode == CART_MODE_MBC2) {
    39dc:	85 34       	cpi	r24, 0x45	; 69
    39de:	b1 f0       	breq	.+44     	; 0x3a0c <enter_GB_mode+0xac>
    PRR = 0xFF; // Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC2();

  } else if (mode == CART_MODE_MBC3) {
    39e0:	83 34       	cpi	r24, 0x43	; 67
    39e2:	d1 f0       	breq	.+52     	; 0x3a18 <enter_GB_mode+0xb8>
    PRR = 0xF7;// Turn off everything except timer1! We want a pseudo RTC!
    MBC_mode_MBC3();

  } else if (mode == CART_MODE_MBC5) {
    39e4:	82 34       	cpi	r24, 0x42	; 66
    39e6:	31 f0       	breq	.+12     	; 0x39f4 <enter_GB_mode+0x94>
    PRR = 0xFF; // Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC5();

  } else {
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    39e8:	8f ef       	ldi	r24, 0xFF	; 255
    39ea:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC1_16M8k();
    39ee:	0e 94 00 3f 	call	0x7e00	; 0x7e00 <MBC_mode_MBC1_16M8k>
    39f2:	08 95       	ret
  } else if (mode == CART_MODE_MBC3) {
    PRR = 0xF7;// Turn off everything except timer1! We want a pseudo RTC!
    MBC_mode_MBC3();

  } else if (mode == CART_MODE_MBC5) {
    PRR = 0xFF; // Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    39f4:	8f ef       	ldi	r24, 0xFF	; 255
    39f6:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC5();
    39fa:	0e 94 28 3f 	call	0x7e50	; 0x7e50 <MBC_mode_MBC5>
    39fe:	08 95       	ret
  if(mode == CART_MODE_MBC1_16M) {
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    MBC_mode_MBC1_16M8k();

  } else if (mode == CART_MODE_MBC1_4M) {
    PRR = 0xFF;// Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    3a00:	8f ef       	ldi	r24, 0xFF	; 255
    3a02:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC1_4M32k();
    3a06:	0e 94 14 3f 	call	0x7e28	; 0x7e28 <MBC_mode_MBC1_4M32k>
    3a0a:	08 95       	ret

  } else if (mode == CART_MODE_MBC2) {
    PRR = 0xFF; // Turn every peripheral off. We don't need them in this mode. (this includes the UART now!)
    3a0c:	8f ef       	ldi	r24, 0xFF	; 255
    3a0e:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC2();
    3a12:	0e 94 72 3f 	call	0x7ee4	; 0x7ee4 <MBC_mode_MBC2>
    3a16:	08 95       	ret

  } else if (mode == CART_MODE_MBC3) {
    PRR = 0xF7;// Turn off everything except timer1! We want a pseudo RTC!
    3a18:	87 ef       	ldi	r24, 0xF7	; 247
    3a1a:	80 93 64 00 	sts	0x0064, r24
    MBC_mode_MBC3();
    3a1e:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <MBC_mode_MBC3>
    3a22:	08 95       	ret

00003a24 <get_GBROM_info>:
#include "memory_latched.h"

// Gameboy global variables
GBROMDATA gbRomData;

void get_GBROM_info(GBROMDATA *gbromData) {
    3a24:	cf 93       	push	r28
    3a26:	df 93       	push	r29
    3a28:	ec 01       	movw	r28, r24

  flashAddress.address32 = 0x0134; // Offset to filename
    3a2a:	84 e3       	ldi	r24, 0x34	; 52
    3a2c:	91 e0       	ldi	r25, 0x01	; 1
    3a2e:	a0 e0       	ldi	r26, 0x00	; 0
    3a30:	b0 e0       	ldi	r27, 0x00	; 0
    3a32:	80 93 4d 05 	sts	0x054D, r24
    3a36:	90 93 4e 05 	sts	0x054E, r25
    3a3a:	a0 93 4f 05 	sts	0x054F, r26
    3a3e:	b0 93 50 05 	sts	0x0550, r27
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3a42:	64 e3       	ldi	r22, 0x34	; 52
    3a44:	71 e0       	ldi	r23, 0x01	; 1
    3a46:	80 e0       	ldi	r24, 0x00	; 0
    3a48:	90 e0       	ldi	r25, 0x00	; 0
    3a4a:	ae 01       	movw	r20, r28
    3a4c:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3a50:	60 91 4d 05 	lds	r22, 0x054D
    3a54:	70 91 4e 05 	lds	r23, 0x054E
    3a58:	80 91 4f 05 	lds	r24, 0x054F
    3a5c:	90 91 50 05 	lds	r25, 0x0550
    3a60:	6f 5f       	subi	r22, 0xFF	; 255
    3a62:	7f 4f       	sbci	r23, 0xFF	; 255
    3a64:	8f 4f       	sbci	r24, 0xFF	; 255
    3a66:	9f 4f       	sbci	r25, 0xFF	; 255
    3a68:	60 93 4d 05 	sts	0x054D, r22
    3a6c:	70 93 4e 05 	sts	0x054E, r23
    3a70:	80 93 4f 05 	sts	0x054F, r24
    3a74:	90 93 50 05 	sts	0x0550, r25
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3a78:	ae 01       	movw	r20, r28
    3a7a:	4f 5f       	subi	r20, 0xFF	; 255
    3a7c:	5f 4f       	sbci	r21, 0xFF	; 255
    3a7e:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3a82:	60 91 4d 05 	lds	r22, 0x054D
    3a86:	70 91 4e 05 	lds	r23, 0x054E
    3a8a:	80 91 4f 05 	lds	r24, 0x054F
    3a8e:	90 91 50 05 	lds	r25, 0x0550
    3a92:	6f 5f       	subi	r22, 0xFF	; 255
    3a94:	7f 4f       	sbci	r23, 0xFF	; 255
    3a96:	8f 4f       	sbci	r24, 0xFF	; 255
    3a98:	9f 4f       	sbci	r25, 0xFF	; 255
    3a9a:	60 93 4d 05 	sts	0x054D, r22
    3a9e:	70 93 4e 05 	sts	0x054E, r23
    3aa2:	80 93 4f 05 	sts	0x054F, r24
    3aa6:	90 93 50 05 	sts	0x0550, r25
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3aaa:	ae 01       	movw	r20, r28
    3aac:	4e 5f       	subi	r20, 0xFE	; 254
    3aae:	5f 4f       	sbci	r21, 0xFF	; 255
    3ab0:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3ab4:	60 91 4d 05 	lds	r22, 0x054D
    3ab8:	70 91 4e 05 	lds	r23, 0x054E
    3abc:	80 91 4f 05 	lds	r24, 0x054F
    3ac0:	90 91 50 05 	lds	r25, 0x0550
    3ac4:	6f 5f       	subi	r22, 0xFF	; 255
    3ac6:	7f 4f       	sbci	r23, 0xFF	; 255
    3ac8:	8f 4f       	sbci	r24, 0xFF	; 255
    3aca:	9f 4f       	sbci	r25, 0xFF	; 255
    3acc:	60 93 4d 05 	sts	0x054D, r22
    3ad0:	70 93 4e 05 	sts	0x054E, r23
    3ad4:	80 93 4f 05 	sts	0x054F, r24
    3ad8:	90 93 50 05 	sts	0x0550, r25
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3adc:	ae 01       	movw	r20, r28
    3ade:	4d 5f       	subi	r20, 0xFD	; 253
    3ae0:	5f 4f       	sbci	r21, 0xFF	; 255
    3ae2:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3ae6:	60 91 4d 05 	lds	r22, 0x054D
    3aea:	70 91 4e 05 	lds	r23, 0x054E
    3aee:	80 91 4f 05 	lds	r24, 0x054F
    3af2:	90 91 50 05 	lds	r25, 0x0550
    3af6:	6f 5f       	subi	r22, 0xFF	; 255
    3af8:	7f 4f       	sbci	r23, 0xFF	; 255
    3afa:	8f 4f       	sbci	r24, 0xFF	; 255
    3afc:	9f 4f       	sbci	r25, 0xFF	; 255
    3afe:	60 93 4d 05 	sts	0x054D, r22
    3b02:	70 93 4e 05 	sts	0x054E, r23
    3b06:	80 93 4f 05 	sts	0x054F, r24
    3b0a:	90 93 50 05 	sts	0x0550, r25
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3b0e:	ae 01       	movw	r20, r28
    3b10:	4c 5f       	subi	r20, 0xFC	; 252
    3b12:	5f 4f       	sbci	r21, 0xFF	; 255
    3b14:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3b18:	60 91 4d 05 	lds	r22, 0x054D
    3b1c:	70 91 4e 05 	lds	r23, 0x054E
    3b20:	80 91 4f 05 	lds	r24, 0x054F
    3b24:	90 91 50 05 	lds	r25, 0x0550
    3b28:	6f 5f       	subi	r22, 0xFF	; 255
    3b2a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b2c:	8f 4f       	sbci	r24, 0xFF	; 255
    3b2e:	9f 4f       	sbci	r25, 0xFF	; 255
    3b30:	60 93 4d 05 	sts	0x054D, r22
    3b34:	70 93 4e 05 	sts	0x054E, r23
    3b38:	80 93 4f 05 	sts	0x054F, r24
    3b3c:	90 93 50 05 	sts	0x0550, r25
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3b40:	ae 01       	movw	r20, r28
    3b42:	4b 5f       	subi	r20, 0xFB	; 251
    3b44:	5f 4f       	sbci	r21, 0xFF	; 255
    3b46:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3b4a:	60 91 4d 05 	lds	r22, 0x054D
    3b4e:	70 91 4e 05 	lds	r23, 0x054E
    3b52:	80 91 4f 05 	lds	r24, 0x054F
    3b56:	90 91 50 05 	lds	r25, 0x0550
    3b5a:	6f 5f       	subi	r22, 0xFF	; 255
    3b5c:	7f 4f       	sbci	r23, 0xFF	; 255
    3b5e:	8f 4f       	sbci	r24, 0xFF	; 255
    3b60:	9f 4f       	sbci	r25, 0xFF	; 255
    3b62:	60 93 4d 05 	sts	0x054D, r22
    3b66:	70 93 4e 05 	sts	0x054E, r23
    3b6a:	80 93 4f 05 	sts	0x054F, r24
    3b6e:	90 93 50 05 	sts	0x0550, r25
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3b72:	ae 01       	movw	r20, r28
    3b74:	4a 5f       	subi	r20, 0xFA	; 250
    3b76:	5f 4f       	sbci	r21, 0xFF	; 255
    3b78:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3b7c:	60 91 4d 05 	lds	r22, 0x054D
    3b80:	70 91 4e 05 	lds	r23, 0x054E
    3b84:	80 91 4f 05 	lds	r24, 0x054F
    3b88:	90 91 50 05 	lds	r25, 0x0550
    3b8c:	6f 5f       	subi	r22, 0xFF	; 255
    3b8e:	7f 4f       	sbci	r23, 0xFF	; 255
    3b90:	8f 4f       	sbci	r24, 0xFF	; 255
    3b92:	9f 4f       	sbci	r25, 0xFF	; 255
    3b94:	60 93 4d 05 	sts	0x054D, r22
    3b98:	70 93 4e 05 	sts	0x054E, r23
    3b9c:	80 93 4f 05 	sts	0x054F, r24
    3ba0:	90 93 50 05 	sts	0x0550, r25
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3ba4:	ae 01       	movw	r20, r28
    3ba6:	49 5f       	subi	r20, 0xF9	; 249
    3ba8:	5f 4f       	sbci	r21, 0xFF	; 255
    3baa:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3bae:	60 91 4d 05 	lds	r22, 0x054D
    3bb2:	70 91 4e 05 	lds	r23, 0x054E
    3bb6:	80 91 4f 05 	lds	r24, 0x054F
    3bba:	90 91 50 05 	lds	r25, 0x0550
    3bbe:	6f 5f       	subi	r22, 0xFF	; 255
    3bc0:	7f 4f       	sbci	r23, 0xFF	; 255
    3bc2:	8f 4f       	sbci	r24, 0xFF	; 255
    3bc4:	9f 4f       	sbci	r25, 0xFF	; 255
    3bc6:	60 93 4d 05 	sts	0x054D, r22
    3bca:	70 93 4e 05 	sts	0x054E, r23
    3bce:	80 93 4f 05 	sts	0x054F, r24
    3bd2:	90 93 50 05 	sts	0x0550, r25
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3bd6:	ae 01       	movw	r20, r28
    3bd8:	48 5f       	subi	r20, 0xF8	; 248
    3bda:	5f 4f       	sbci	r21, 0xFF	; 255
    3bdc:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3be0:	60 91 4d 05 	lds	r22, 0x054D
    3be4:	70 91 4e 05 	lds	r23, 0x054E
    3be8:	80 91 4f 05 	lds	r24, 0x054F
    3bec:	90 91 50 05 	lds	r25, 0x0550
    3bf0:	6f 5f       	subi	r22, 0xFF	; 255
    3bf2:	7f 4f       	sbci	r23, 0xFF	; 255
    3bf4:	8f 4f       	sbci	r24, 0xFF	; 255
    3bf6:	9f 4f       	sbci	r25, 0xFF	; 255
    3bf8:	60 93 4d 05 	sts	0x054D, r22
    3bfc:	70 93 4e 05 	sts	0x054E, r23
    3c00:	80 93 4f 05 	sts	0x054F, r24
    3c04:	90 93 50 05 	sts	0x0550, r25
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3c08:	ae 01       	movw	r20, r28
    3c0a:	47 5f       	subi	r20, 0xF7	; 247
    3c0c:	5f 4f       	sbci	r21, 0xFF	; 255
    3c0e:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3c12:	60 91 4d 05 	lds	r22, 0x054D
    3c16:	70 91 4e 05 	lds	r23, 0x054E
    3c1a:	80 91 4f 05 	lds	r24, 0x054F
    3c1e:	90 91 50 05 	lds	r25, 0x0550
    3c22:	6f 5f       	subi	r22, 0xFF	; 255
    3c24:	7f 4f       	sbci	r23, 0xFF	; 255
    3c26:	8f 4f       	sbci	r24, 0xFF	; 255
    3c28:	9f 4f       	sbci	r25, 0xFF	; 255
    3c2a:	60 93 4d 05 	sts	0x054D, r22
    3c2e:	70 93 4e 05 	sts	0x054E, r23
    3c32:	80 93 4f 05 	sts	0x054F, r24
    3c36:	90 93 50 05 	sts	0x0550, r25
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3c3a:	ae 01       	movw	r20, r28
    3c3c:	46 5f       	subi	r20, 0xF6	; 246
    3c3e:	5f 4f       	sbci	r21, 0xFF	; 255
    3c40:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3c44:	60 91 4d 05 	lds	r22, 0x054D
    3c48:	70 91 4e 05 	lds	r23, 0x054E
    3c4c:	80 91 4f 05 	lds	r24, 0x054F
    3c50:	90 91 50 05 	lds	r25, 0x0550
    3c54:	6f 5f       	subi	r22, 0xFF	; 255
    3c56:	7f 4f       	sbci	r23, 0xFF	; 255
    3c58:	8f 4f       	sbci	r24, 0xFF	; 255
    3c5a:	9f 4f       	sbci	r25, 0xFF	; 255
    3c5c:	60 93 4d 05 	sts	0x054D, r22
    3c60:	70 93 4e 05 	sts	0x054E, r23
    3c64:	80 93 4f 05 	sts	0x054F, r24
    3c68:	90 93 50 05 	sts	0x0550, r25
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3c6c:	ae 01       	movw	r20, r28
    3c6e:	45 5f       	subi	r20, 0xF5	; 245
    3c70:	5f 4f       	sbci	r21, 0xFF	; 255
    3c72:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3c76:	60 91 4d 05 	lds	r22, 0x054D
    3c7a:	70 91 4e 05 	lds	r23, 0x054E
    3c7e:	80 91 4f 05 	lds	r24, 0x054F
    3c82:	90 91 50 05 	lds	r25, 0x0550
    3c86:	6f 5f       	subi	r22, 0xFF	; 255
    3c88:	7f 4f       	sbci	r23, 0xFF	; 255
    3c8a:	8f 4f       	sbci	r24, 0xFF	; 255
    3c8c:	9f 4f       	sbci	r25, 0xFF	; 255
    3c8e:	60 93 4d 05 	sts	0x054D, r22
    3c92:	70 93 4e 05 	sts	0x054E, r23
    3c96:	80 93 4f 05 	sts	0x054F, r24
    3c9a:	90 93 50 05 	sts	0x0550, r25
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3c9e:	ae 01       	movw	r20, r28
    3ca0:	44 5f       	subi	r20, 0xF4	; 244
    3ca2:	5f 4f       	sbci	r21, 0xFF	; 255
    3ca4:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3ca8:	60 91 4d 05 	lds	r22, 0x054D
    3cac:	70 91 4e 05 	lds	r23, 0x054E
    3cb0:	80 91 4f 05 	lds	r24, 0x054F
    3cb4:	90 91 50 05 	lds	r25, 0x0550
    3cb8:	6f 5f       	subi	r22, 0xFF	; 255
    3cba:	7f 4f       	sbci	r23, 0xFF	; 255
    3cbc:	8f 4f       	sbci	r24, 0xFF	; 255
    3cbe:	9f 4f       	sbci	r25, 0xFF	; 255
    3cc0:	60 93 4d 05 	sts	0x054D, r22
    3cc4:	70 93 4e 05 	sts	0x054E, r23
    3cc8:	80 93 4f 05 	sts	0x054F, r24
    3ccc:	90 93 50 05 	sts	0x0550, r25
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3cd0:	ae 01       	movw	r20, r28
    3cd2:	43 5f       	subi	r20, 0xF3	; 243
    3cd4:	5f 4f       	sbci	r21, 0xFF	; 255
    3cd6:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3cda:	60 91 4d 05 	lds	r22, 0x054D
    3cde:	70 91 4e 05 	lds	r23, 0x054E
    3ce2:	80 91 4f 05 	lds	r24, 0x054F
    3ce6:	90 91 50 05 	lds	r25, 0x0550
    3cea:	6f 5f       	subi	r22, 0xFF	; 255
    3cec:	7f 4f       	sbci	r23, 0xFF	; 255
    3cee:	8f 4f       	sbci	r24, 0xFF	; 255
    3cf0:	9f 4f       	sbci	r25, 0xFF	; 255
    3cf2:	60 93 4d 05 	sts	0x054D, r22
    3cf6:	70 93 4e 05 	sts	0x054E, r23
    3cfa:	80 93 4f 05 	sts	0x054F, r24
    3cfe:	90 93 50 05 	sts	0x0550, r25
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3d02:	ae 01       	movw	r20, r28
    3d04:	42 5f       	subi	r20, 0xF2	; 242
    3d06:	5f 4f       	sbci	r21, 0xFF	; 255
    3d08:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3d0c:	60 91 4d 05 	lds	r22, 0x054D
    3d10:	70 91 4e 05 	lds	r23, 0x054E
    3d14:	80 91 4f 05 	lds	r24, 0x054F
    3d18:	90 91 50 05 	lds	r25, 0x0550
    3d1c:	6f 5f       	subi	r22, 0xFF	; 255
    3d1e:	7f 4f       	sbci	r23, 0xFF	; 255
    3d20:	8f 4f       	sbci	r24, 0xFF	; 255
    3d22:	9f 4f       	sbci	r25, 0xFF	; 255
    3d24:	60 93 4d 05 	sts	0x054D, r22
    3d28:	70 93 4e 05 	sts	0x054E, r23
    3d2c:	80 93 4f 05 	sts	0x054F, r24
    3d30:	90 93 50 05 	sts	0x0550, r25
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3d34:	ae 01       	movw	r20, r28
    3d36:	41 5f       	subi	r20, 0xF1	; 241
    3d38:	5f 4f       	sbci	r21, 0xFF	; 255
    3d3a:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

void get_GBROM_info(GBROMDATA *gbromData) {

  flashAddress.address32 = 0x0134; // Offset to filename
  // Read ROM name from the flash chip
  for(uint8_t i=0; i< 17; i++, flashAddress.address32++) {
    3d3e:	60 91 4d 05 	lds	r22, 0x054D
    3d42:	70 91 4e 05 	lds	r23, 0x054E
    3d46:	80 91 4f 05 	lds	r24, 0x054F
    3d4a:	90 91 50 05 	lds	r25, 0x0550
    3d4e:	6f 5f       	subi	r22, 0xFF	; 255
    3d50:	7f 4f       	sbci	r23, 0xFF	; 255
    3d52:	8f 4f       	sbci	r24, 0xFF	; 255
    3d54:	9f 4f       	sbci	r25, 0xFF	; 255
    3d56:	60 93 4d 05 	sts	0x054D, r22
    3d5a:	70 93 4e 05 	sts	0x054E, r23
    3d5e:	80 93 4f 05 	sts	0x054F, r24
    3d62:	90 93 50 05 	sts	0x0550, r25
    sst_flash_read_byte(flashAddress, &((*gbromData).name[i]));
    3d66:	ae 01       	movw	r20, r28
    3d68:	40 5f       	subi	r20, 0xF0	; 240
    3d6a:	5f 4f       	sbci	r21, 0xFF	; 255
    3d6c:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>
  }
  (*gbromData).name[16] = '\0';
    3d70:	18 8a       	std	Y+16, r1	; 0x10

  flashAddress.address32 = 0x0148;
    3d72:	88 e4       	ldi	r24, 0x48	; 72
    3d74:	91 e0       	ldi	r25, 0x01	; 1
    3d76:	a0 e0       	ldi	r26, 0x00	; 0
    3d78:	b0 e0       	ldi	r27, 0x00	; 0
    3d7a:	80 93 4d 05 	sts	0x054D, r24
    3d7e:	90 93 4e 05 	sts	0x054E, r25
    3d82:	a0 93 4f 05 	sts	0x054F, r26
    3d86:	b0 93 50 05 	sts	0x0550, r27
  sst_flash_read_byte(flashAddress, &((*gbromData).ROMsize));
    3d8a:	ae 01       	movw	r20, r28
    3d8c:	4f 5e       	subi	r20, 0xEF	; 239
    3d8e:	5f 4f       	sbci	r21, 0xFF	; 255
    3d90:	68 e4       	ldi	r22, 0x48	; 72
    3d92:	71 e0       	ldi	r23, 0x01	; 1
    3d94:	80 e0       	ldi	r24, 0x00	; 0
    3d96:	90 e0       	ldi	r25, 0x00	; 0
    3d98:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

  flashAddress.address32 = 0x0149;
    3d9c:	89 e4       	ldi	r24, 0x49	; 73
    3d9e:	91 e0       	ldi	r25, 0x01	; 1
    3da0:	a0 e0       	ldi	r26, 0x00	; 0
    3da2:	b0 e0       	ldi	r27, 0x00	; 0
    3da4:	80 93 4d 05 	sts	0x054D, r24
    3da8:	90 93 4e 05 	sts	0x054E, r25
    3dac:	a0 93 4f 05 	sts	0x054F, r26
    3db0:	b0 93 50 05 	sts	0x0550, r27
  sst_flash_read_byte(flashAddress, &((*gbromData).RAMsize));
    3db4:	ae 01       	movw	r20, r28
    3db6:	4a 5e       	subi	r20, 0xEA	; 234
    3db8:	5f 4f       	sbci	r21, 0xFF	; 255
    3dba:	69 e4       	ldi	r22, 0x49	; 73
    3dbc:	71 e0       	ldi	r23, 0x01	; 1
    3dbe:	80 e0       	ldi	r24, 0x00	; 0
    3dc0:	90 e0       	ldi	r25, 0x00	; 0
    3dc2:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

  flashAddress.address32 = 0x0147;
    3dc6:	87 e4       	ldi	r24, 0x47	; 71
    3dc8:	91 e0       	ldi	r25, 0x01	; 1
    3dca:	a0 e0       	ldi	r26, 0x00	; 0
    3dcc:	b0 e0       	ldi	r27, 0x00	; 0
    3dce:	80 93 4d 05 	sts	0x054D, r24
    3dd2:	90 93 4e 05 	sts	0x054E, r25
    3dd6:	a0 93 4f 05 	sts	0x054F, r26
    3dda:	b0 93 50 05 	sts	0x0550, r27
  sst_flash_read_byte(flashAddress, &((*gbromData).MBCtype));
    3dde:	ae 01       	movw	r20, r28
    3de0:	47 5e       	subi	r20, 0xE7	; 231
    3de2:	5f 4f       	sbci	r21, 0xFF	; 255
    3de4:	67 e4       	ldi	r22, 0x47	; 71
    3de6:	71 e0       	ldi	r23, 0x01	; 1
    3de8:	80 e0       	ldi	r24, 0x00	; 0
    3dea:	90 e0       	ldi	r25, 0x00	; 0
    3dec:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

  flashAddress.address32 = 0x0143;
    3df0:	83 e4       	ldi	r24, 0x43	; 67
    3df2:	91 e0       	ldi	r25, 0x01	; 1
    3df4:	a0 e0       	ldi	r26, 0x00	; 0
    3df6:	b0 e0       	ldi	r27, 0x00	; 0
    3df8:	80 93 4d 05 	sts	0x054D, r24
    3dfc:	90 93 4e 05 	sts	0x054E, r25
    3e00:	a0 93 4f 05 	sts	0x054F, r26
    3e04:	b0 93 50 05 	sts	0x0550, r27
  sst_flash_read_byte(flashAddress, &((*gbromData).CGBsupport));
    3e08:	ae 01       	movw	r20, r28
    3e0a:	41 5d       	subi	r20, 0xD1	; 209
    3e0c:	5f 4f       	sbci	r21, 0xFF	; 255
    3e0e:	63 e4       	ldi	r22, 0x43	; 67
    3e10:	71 e0       	ldi	r23, 0x01	; 1
    3e12:	80 e0       	ldi	r24, 0x00	; 0
    3e14:	90 e0       	ldi	r25, 0x00	; 0
    3e16:	0e 94 c9 10 	call	0x2192	; 0x2192 <sst_flash_read_byte>

  // Now fill out the additional GBROMDATA fields
  // Convert hex ROM size to bytes ROM size
  if((*gbromData).ROMsize == GBROM_32k) {
    3e1a:	89 89       	ldd	r24, Y+17	; 0x11
    3e1c:	88 23       	and	r24, r24
    3e1e:	09 f0       	breq	.+2      	; 0x3e22 <get_GBROM_info+0x3fe>
    3e20:	52 c0       	rjmp	.+164    	; 0x3ec6 <get_GBROM_info+0x4a2>
    (*gbromData).ROMsizeBytes = 32768;
    3e22:	80 e0       	ldi	r24, 0x00	; 0
    3e24:	90 e8       	ldi	r25, 0x80	; 128
    3e26:	a0 e0       	ldi	r26, 0x00	; 0
    3e28:	b0 e0       	ldi	r27, 0x00	; 0
    3e2a:	8a 8b       	std	Y+18, r24	; 0x12
    3e2c:	9b 8b       	std	Y+19, r25	; 0x13
    3e2e:	ac 8b       	std	Y+20, r26	; 0x14
    3e30:	bd 8b       	std	Y+21, r27	; 0x15
  } else {
    (*gbromData).ROMsizeBytes = 0;
  }

  // Convert the RAM size
  if((*gbromData).RAMsize == GBRAM_0k) {
    3e32:	8e 89       	ldd	r24, Y+22	; 0x16
    3e34:	88 23       	and	r24, r24
    3e36:	51 f0       	breq	.+20     	; 0x3e4c <get_GBROM_info+0x428>
    (*gbromData).RAMsizeBytes = 0;
  } else if((*gbromData).RAMsize == GBRAM_2k) {
    3e38:	81 30       	cpi	r24, 0x01	; 1
    3e3a:	09 f4       	brne	.+2      	; 0x3e3e <get_GBROM_info+0x41a>
    3e3c:	7a c0       	rjmp	.+244    	; 0x3f32 <get_GBROM_info+0x50e>
    (*gbromData).RAMsizeBytes = 2048;
  } else if((*gbromData).RAMsize == GBRAM_8k) {
    3e3e:	82 30       	cpi	r24, 0x02	; 2
    3e40:	09 f4       	brne	.+2      	; 0x3e44 <get_GBROM_info+0x420>
    3e42:	b3 c0       	rjmp	.+358    	; 0x3faa <get_GBROM_info+0x586>
    (*gbromData).RAMsizeBytes = 8192;
  } else if((*gbromData).RAMsize == GBRAM_32k) {
    3e44:	83 30       	cpi	r24, 0x03	; 3
    3e46:	09 f4       	brne	.+2      	; 0x3e4a <get_GBROM_info+0x426>
    3e48:	89 c0       	rjmp	.+274    	; 0x3f5c <get_GBROM_info+0x538>
    (*gbromData).RAMsizeBytes = 32768;
  } else if((*gbromData).RAMsize == GBRAM_64k) {
    3e4a:	85 30       	cpi	r24, 0x05	; 5
    (*gbromData).RAMsizeBytes = (uint32_t) 65536;
  } else if((*gbromData).RAMsize == GBRAM_128k) {
    (*gbromData).RAMsizeBytes = 131072UL;
  } else {
    (*gbromData).RAMsizeBytes = 0;
    3e4c:	18 8e       	std	Y+24, r1	; 0x18
    3e4e:	1f 8a       	std	Y+23, r1	; 0x17
  }

  // Get the MBC mode name
  if((*gbromData).MBCtype == GBCART_ROM_ONLY) {
    3e50:	89 8d       	ldd	r24, Y+25	; 0x19
    3e52:	88 23       	and	r24, r24
    3e54:	09 f4       	brne	.+2      	; 0x3e58 <get_GBROM_info+0x434>
    3e56:	4d c0       	rjmp	.+154    	; 0x3ef2 <get_GBROM_info+0x4ce>
    strcpy_P((*gbromData).MBCname,PSTR("ROM only"));
  } else if((*gbromData).MBCtype == GBCART_MBC1) {
    3e58:	81 30       	cpi	r24, 0x01	; 1
    3e5a:	09 f4       	brne	.+2      	; 0x3e5e <get_GBROM_info+0x43a>
    3e5c:	96 c0       	rjmp	.+300    	; 0x3f8a <get_GBROM_info+0x566>
    strcpy_P((*gbromData).MBCname,PSTR("MBC1"));
  } else if((*gbromData).MBCtype == GBCART_MBC1_RAM) {
    3e5e:	82 30       	cpi	r24, 0x02	; 2
    3e60:	09 f4       	brne	.+2      	; 0x3e64 <get_GBROM_info+0x440>
    3e62:	75 c0       	rjmp	.+234    	; 0x3f4e <get_GBROM_info+0x52a>
    strcpy_P((*gbromData).MBCname,PSTR("MBC1 RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC1_RAM_BATT) {
    3e64:	83 30       	cpi	r24, 0x03	; 3
    3e66:	09 f4       	brne	.+2      	; 0x3e6a <get_GBROM_info+0x446>
    3e68:	ae c0       	rjmp	.+348    	; 0x3fc6 <get_GBROM_info+0x5a2>
    strcpy_P((*gbromData).MBCname,PSTR("MBC1 RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC5) {
    3e6a:	89 31       	cpi	r24, 0x19	; 25
    3e6c:	09 f4       	brne	.+2      	; 0x3e70 <get_GBROM_info+0x44c>
    3e6e:	b2 c0       	rjmp	.+356    	; 0x3fd4 <get_GBROM_info+0x5b0>
    strcpy_P((*gbromData).MBCname,PSTR("MBC5"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RAM) {
    3e70:	8a 31       	cpi	r24, 0x1A	; 26
    3e72:	09 f4       	brne	.+2      	; 0x3e76 <get_GBROM_info+0x452>
    3e74:	b6 c0       	rjmp	.+364    	; 0x3fe2 <get_GBROM_info+0x5be>
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RAM_BATT) {
    3e76:	8b 31       	cpi	r24, 0x1B	; 27
    3e78:	09 f4       	brne	.+2      	; 0x3e7c <get_GBROM_info+0x458>
    3e7a:	d5 c0       	rjmp	.+426    	; 0x4026 <get_GBROM_info+0x602>
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE) {
    3e7c:	8c 31       	cpi	r24, 0x1C	; 28
    3e7e:	09 f4       	brne	.+2      	; 0x3e82 <get_GBROM_info+0x45e>
    3e80:	c0 c0       	rjmp	.+384    	; 0x4002 <get_GBROM_info+0x5de>
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE_RAM) {
    3e82:	8d 31       	cpi	r24, 0x1D	; 29
    3e84:	09 f4       	brne	.+2      	; 0x3e88 <get_GBROM_info+0x464>
    3e86:	df c0       	rjmp	.+446    	; 0x4046 <get_GBROM_info+0x622>
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE_RAM_BATT) {
    3e88:	8e 31       	cpi	r24, 0x1E	; 30
    3e8a:	09 f4       	brne	.+2      	; 0x3e8e <get_GBROM_info+0x46a>
    3e8c:	e3 c0       	rjmp	.+454    	; 0x4054 <get_GBROM_info+0x630>
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC3_RTC_BATT) {
    3e8e:	8f 30       	cpi	r24, 0x0F	; 15
    3e90:	09 f4       	brne	.+2      	; 0x3e94 <get_GBROM_info+0x470>
    3e92:	f0 c0       	rjmp	.+480    	; 0x4074 <get_GBROM_info+0x650>
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RTC BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC3_RTC_RAM_BATT) {
    3e94:	80 31       	cpi	r24, 0x10	; 16
    3e96:	09 f4       	brne	.+2      	; 0x3e9a <get_GBROM_info+0x476>
    3e98:	f4 c0       	rjmp	.+488    	; 0x4082 <get_GBROM_info+0x65e>
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RTC RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC3) {
    3e9a:	81 31       	cpi	r24, 0x11	; 17
    3e9c:	09 f4       	brne	.+2      	; 0x3ea0 <get_GBROM_info+0x47c>
    3e9e:	f8 c0       	rjmp	.+496    	; 0x4090 <get_GBROM_info+0x66c>
    strcpy_P((*gbromData).MBCname,PSTR("MBC3"));
  } else if((*gbromData).MBCtype == GBCART_MBC3_RAM) {
    3ea0:	82 31       	cpi	r24, 0x12	; 18
    3ea2:	09 f4       	brne	.+2      	; 0x3ea6 <get_GBROM_info+0x482>
    3ea4:	07 c1       	rjmp	.+526    	; 0x40b4 <get_GBROM_info+0x690>
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC3_RAM_BATT) {
    3ea6:	83 31       	cpi	r24, 0x13	; 19
    3ea8:	09 f4       	brne	.+2      	; 0x3eac <get_GBROM_info+0x488>
    3eaa:	0b c1       	rjmp	.+534    	; 0x40c2 <get_GBROM_info+0x69e>
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC2) {
    3eac:	85 30       	cpi	r24, 0x05	; 5
    3eae:	09 f4       	brne	.+2      	; 0x3eb2 <get_GBROM_info+0x48e>
    3eb0:	af c0       	rjmp	.+350    	; 0x4010 <get_GBROM_info+0x5ec>
    strcpy_P((*gbromData).MBCname,PSTR("MBC2"));
    (*gbromData).RAMsizeBytes = 512; // Special case here, as MBC2 header may not disclose internal MBC RAM
  } else if((*gbromData).MBCtype == GBCART_MBC2_BATT) {
    3eb2:	86 30       	cpi	r24, 0x06	; 6
    3eb4:	09 f4       	brne	.+2      	; 0x3eb8 <get_GBROM_info+0x494>
    3eb6:	f3 c0       	rjmp	.+486    	; 0x409e <get_GBROM_info+0x67a>
    strcpy_P((*gbromData).MBCname,PSTR("MBC2 BATT"));
    (*gbromData).RAMsizeBytes = 512; // Special case here, as MBC2 header may not disclose internal MBC RAM
  } else {
    strcpy_P((*gbromData).MBCname,PSTR("Unsupported MBC type"));
    3eb8:	ce 01       	movw	r24, r28
    3eba:	4a 96       	adiw	r24, 0x1a	; 26
    3ebc:	68 e5       	ldi	r22, 0x58	; 88
    3ebe:	79 e0       	ldi	r23, 0x09	; 9
    3ec0:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    3ec4:	1c c0       	rjmp	.+56     	; 0x3efe <get_GBROM_info+0x4da>

  // Now fill out the additional GBROMDATA fields
  // Convert hex ROM size to bytes ROM size
  if((*gbromData).ROMsize == GBROM_32k) {
    (*gbromData).ROMsizeBytes = 32768;
  } else if ((*gbromData).ROMsize == GBROM_64k) {
    3ec6:	81 30       	cpi	r24, 0x01	; 1
    3ec8:	c9 f1       	breq	.+114    	; 0x3f3c <get_GBROM_info+0x518>
    (*gbromData).ROMsizeBytes = 65536;
  } else if ((*gbromData).ROMsize == GBROM_128k) {
    3eca:	82 30       	cpi	r24, 0x02	; 2
    3ecc:	09 f4       	brne	.+2      	; 0x3ed0 <get_GBROM_info+0x4ac>
    3ece:	72 c0       	rjmp	.+228    	; 0x3fb4 <get_GBROM_info+0x590>
    (*gbromData).ROMsizeBytes = 131072;
  } else if ((*gbromData).ROMsize == GBROM_256k) {
    3ed0:	83 30       	cpi	r24, 0x03	; 3
    3ed2:	09 f4       	brne	.+2      	; 0x3ed6 <get_GBROM_info+0x4b2>
    3ed4:	48 c0       	rjmp	.+144    	; 0x3f66 <get_GBROM_info+0x542>
    (*gbromData).ROMsizeBytes = 262144;
  } else if ((*gbromData).ROMsize == GBROM_512k) {
    3ed6:	84 30       	cpi	r24, 0x04	; 4
    3ed8:	09 f4       	brne	.+2      	; 0x3edc <get_GBROM_info+0x4b8>
    3eda:	8a c0       	rjmp	.+276    	; 0x3ff0 <get_GBROM_info+0x5cc>
    (*gbromData).ROMsizeBytes = 524288;
  } else if ((*gbromData).ROMsize == GBROM_1M) {
    3edc:	85 30       	cpi	r24, 0x05	; 5
    3ede:	09 f4       	brne	.+2      	; 0x3ee2 <get_GBROM_info+0x4be>
    3ee0:	a9 c0       	rjmp	.+338    	; 0x4034 <get_GBROM_info+0x610>
    (*gbromData).ROMsizeBytes = 1048576;
  } else if ((*gbromData).ROMsize == GBROM_2M) {
    3ee2:	86 30       	cpi	r24, 0x06	; 6
    3ee4:	09 f4       	brne	.+2      	; 0x3ee8 <get_GBROM_info+0x4c4>
    3ee6:	bd c0       	rjmp	.+378    	; 0x4062 <get_GBROM_info+0x63e>
    (*gbromData).ROMsizeBytes = 2097152;
  } else {
    (*gbromData).ROMsizeBytes = 0;
    3ee8:	1a 8a       	std	Y+18, r1	; 0x12
    3eea:	1b 8a       	std	Y+19, r1	; 0x13
    3eec:	1c 8a       	std	Y+20, r1	; 0x14
    3eee:	1d 8a       	std	Y+21, r1	; 0x15
    3ef0:	a0 cf       	rjmp	.-192    	; 0x3e32 <get_GBROM_info+0x40e>
    (*gbromData).RAMsizeBytes = 0;
  }

  // Get the MBC mode name
  if((*gbromData).MBCtype == GBCART_ROM_ONLY) {
    strcpy_P((*gbromData).MBCname,PSTR("ROM only"));
    3ef2:	ce 01       	movw	r24, r28
    3ef4:	4a 96       	adiw	r24, 0x1a	; 26
    3ef6:	61 e2       	ldi	r22, 0x21	; 33
    3ef8:	7a e0       	ldi	r23, 0x0A	; 10
    3efa:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    (*gbromData).RAMsizeBytes = 512; // Special case here, as MBC2 header may not disclose internal MBC RAM
  } else {
    strcpy_P((*gbromData).MBCname,PSTR("Unsupported MBC type"));
  }
  
  if((*gbromData).CGBsupport == GB_PRE_CGB) {
    3efe:	8f a5       	ldd	r24, Y+47	; 0x2f
    3f00:	88 23       	and	r24, r24
    3f02:	71 f0       	breq	.+28     	; 0x3f20 <get_GBROM_info+0x4fc>
    strcpy_P((*gbromData).CGBsupportText, PSTR("Pre-CGB"));
  } else if ((*gbromData).CGBsupport == GB_AND_CGB) {
    3f04:	80 38       	cpi	r24, 0x80	; 128
    3f06:	09 f4       	brne	.+2      	; 0x3f0a <get_GBROM_info+0x4e6>
    3f08:	47 c0       	rjmp	.+142    	; 0x3f98 <get_GBROM_info+0x574>
    strcpy_P((*gbromData).CGBsupportText, PSTR("GB & CGB"));
  } else if ((*gbromData).CGBsupport == CGB_ONLY) {
    3f0a:	80 3c       	cpi	r24, 0xC0	; 192
    3f0c:	a9 f1       	breq	.+106    	; 0x3f78 <get_GBROM_info+0x554>
    strcpy_P((*gbromData).CGBsupportText, PSTR("CGB only"));
  } else {
    strcpy_P((*gbromData).CGBsupportText, PSTR("UNK VAL"));
    3f0e:	ce 01       	movw	r24, r28
    3f10:	c0 96       	adiw	r24, 0x30	; 48
    3f12:	66 e3       	ldi	r22, 0x36	; 54
    3f14:	79 e0       	ldi	r23, 0x09	; 9
    3f16:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
  }
}
    3f1a:	df 91       	pop	r29
    3f1c:	cf 91       	pop	r28
    3f1e:	08 95       	ret
  } else {
    strcpy_P((*gbromData).MBCname,PSTR("Unsupported MBC type"));
  }
  
  if((*gbromData).CGBsupport == GB_PRE_CGB) {
    strcpy_P((*gbromData).CGBsupportText, PSTR("Pre-CGB"));
    3f20:	ce 01       	movw	r24, r28
    3f22:	c0 96       	adiw	r24, 0x30	; 48
    3f24:	60 e5       	ldi	r22, 0x50	; 80
    3f26:	79 e0       	ldi	r23, 0x09	; 9
    3f28:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
  } else if ((*gbromData).CGBsupport == CGB_ONLY) {
    strcpy_P((*gbromData).CGBsupportText, PSTR("CGB only"));
  } else {
    strcpy_P((*gbromData).CGBsupportText, PSTR("UNK VAL"));
  }
}
    3f2c:	df 91       	pop	r29
    3f2e:	cf 91       	pop	r28
    3f30:	08 95       	ret

  // Convert the RAM size
  if((*gbromData).RAMsize == GBRAM_0k) {
    (*gbromData).RAMsizeBytes = 0;
  } else if((*gbromData).RAMsize == GBRAM_2k) {
    (*gbromData).RAMsizeBytes = 2048;
    3f32:	80 e0       	ldi	r24, 0x00	; 0
    3f34:	98 e0       	ldi	r25, 0x08	; 8
    3f36:	98 8f       	std	Y+24, r25	; 0x18
    3f38:	8f 8b       	std	Y+23, r24	; 0x17
    3f3a:	8a cf       	rjmp	.-236    	; 0x3e50 <get_GBROM_info+0x42c>
  // Now fill out the additional GBROMDATA fields
  // Convert hex ROM size to bytes ROM size
  if((*gbromData).ROMsize == GBROM_32k) {
    (*gbromData).ROMsizeBytes = 32768;
  } else if ((*gbromData).ROMsize == GBROM_64k) {
    (*gbromData).ROMsizeBytes = 65536;
    3f3c:	80 e0       	ldi	r24, 0x00	; 0
    3f3e:	90 e0       	ldi	r25, 0x00	; 0
    3f40:	a1 e0       	ldi	r26, 0x01	; 1
    3f42:	b0 e0       	ldi	r27, 0x00	; 0
    3f44:	8a 8b       	std	Y+18, r24	; 0x12
    3f46:	9b 8b       	std	Y+19, r25	; 0x13
    3f48:	ac 8b       	std	Y+20, r26	; 0x14
    3f4a:	bd 8b       	std	Y+21, r27	; 0x15
    3f4c:	72 cf       	rjmp	.-284    	; 0x3e32 <get_GBROM_info+0x40e>
  if((*gbromData).MBCtype == GBCART_ROM_ONLY) {
    strcpy_P((*gbromData).MBCname,PSTR("ROM only"));
  } else if((*gbromData).MBCtype == GBCART_MBC1) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC1"));
  } else if((*gbromData).MBCtype == GBCART_MBC1_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC1 RAM"));
    3f4e:	ce 01       	movw	r24, r28
    3f50:	4a 96       	adiw	r24, 0x1a	; 26
    3f52:	63 e1       	ldi	r22, 0x13	; 19
    3f54:	7a e0       	ldi	r23, 0x0A	; 10
    3f56:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    3f5a:	d1 cf       	rjmp	.-94     	; 0x3efe <get_GBROM_info+0x4da>
  } else if((*gbromData).RAMsize == GBRAM_2k) {
    (*gbromData).RAMsizeBytes = 2048;
  } else if((*gbromData).RAMsize == GBRAM_8k) {
    (*gbromData).RAMsizeBytes = 8192;
  } else if((*gbromData).RAMsize == GBRAM_32k) {
    (*gbromData).RAMsizeBytes = 32768;
    3f5c:	80 e0       	ldi	r24, 0x00	; 0
    3f5e:	90 e8       	ldi	r25, 0x80	; 128
    3f60:	98 8f       	std	Y+24, r25	; 0x18
    3f62:	8f 8b       	std	Y+23, r24	; 0x17
    3f64:	75 cf       	rjmp	.-278    	; 0x3e50 <get_GBROM_info+0x42c>
  } else if ((*gbromData).ROMsize == GBROM_64k) {
    (*gbromData).ROMsizeBytes = 65536;
  } else if ((*gbromData).ROMsize == GBROM_128k) {
    (*gbromData).ROMsizeBytes = 131072;
  } else if ((*gbromData).ROMsize == GBROM_256k) {
    (*gbromData).ROMsizeBytes = 262144;
    3f66:	80 e0       	ldi	r24, 0x00	; 0
    3f68:	90 e0       	ldi	r25, 0x00	; 0
    3f6a:	a4 e0       	ldi	r26, 0x04	; 4
    3f6c:	b0 e0       	ldi	r27, 0x00	; 0
    3f6e:	8a 8b       	std	Y+18, r24	; 0x12
    3f70:	9b 8b       	std	Y+19, r25	; 0x13
    3f72:	ac 8b       	std	Y+20, r26	; 0x14
    3f74:	bd 8b       	std	Y+21, r27	; 0x15
    3f76:	5d cf       	rjmp	.-326    	; 0x3e32 <get_GBROM_info+0x40e>
  if((*gbromData).CGBsupport == GB_PRE_CGB) {
    strcpy_P((*gbromData).CGBsupportText, PSTR("Pre-CGB"));
  } else if ((*gbromData).CGBsupport == GB_AND_CGB) {
    strcpy_P((*gbromData).CGBsupportText, PSTR("GB & CGB"));
  } else if ((*gbromData).CGBsupport == CGB_ONLY) {
    strcpy_P((*gbromData).CGBsupportText, PSTR("CGB only"));
    3f78:	ce 01       	movw	r24, r28
    3f7a:	c0 96       	adiw	r24, 0x30	; 48
    3f7c:	6e e3       	ldi	r22, 0x3E	; 62
    3f7e:	79 e0       	ldi	r23, 0x09	; 9
    3f80:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
  } else {
    strcpy_P((*gbromData).CGBsupportText, PSTR("UNK VAL"));
  }
}
    3f84:	df 91       	pop	r29
    3f86:	cf 91       	pop	r28
    3f88:	08 95       	ret

  // Get the MBC mode name
  if((*gbromData).MBCtype == GBCART_ROM_ONLY) {
    strcpy_P((*gbromData).MBCname,PSTR("ROM only"));
  } else if((*gbromData).MBCtype == GBCART_MBC1) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC1"));
    3f8a:	ce 01       	movw	r24, r28
    3f8c:	4a 96       	adiw	r24, 0x1a	; 26
    3f8e:	6c e1       	ldi	r22, 0x1C	; 28
    3f90:	7a e0       	ldi	r23, 0x0A	; 10
    3f92:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    3f96:	b3 cf       	rjmp	.-154    	; 0x3efe <get_GBROM_info+0x4da>
  }
  
  if((*gbromData).CGBsupport == GB_PRE_CGB) {
    strcpy_P((*gbromData).CGBsupportText, PSTR("Pre-CGB"));
  } else if ((*gbromData).CGBsupport == GB_AND_CGB) {
    strcpy_P((*gbromData).CGBsupportText, PSTR("GB & CGB"));
    3f98:	ce 01       	movw	r24, r28
    3f9a:	c0 96       	adiw	r24, 0x30	; 48
    3f9c:	67 e4       	ldi	r22, 0x47	; 71
    3f9e:	79 e0       	ldi	r23, 0x09	; 9
    3fa0:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
  } else if ((*gbromData).CGBsupport == CGB_ONLY) {
    strcpy_P((*gbromData).CGBsupportText, PSTR("CGB only"));
  } else {
    strcpy_P((*gbromData).CGBsupportText, PSTR("UNK VAL"));
  }
}
    3fa4:	df 91       	pop	r29
    3fa6:	cf 91       	pop	r28
    3fa8:	08 95       	ret
  if((*gbromData).RAMsize == GBRAM_0k) {
    (*gbromData).RAMsizeBytes = 0;
  } else if((*gbromData).RAMsize == GBRAM_2k) {
    (*gbromData).RAMsizeBytes = 2048;
  } else if((*gbromData).RAMsize == GBRAM_8k) {
    (*gbromData).RAMsizeBytes = 8192;
    3faa:	80 e0       	ldi	r24, 0x00	; 0
    3fac:	90 e2       	ldi	r25, 0x20	; 32
    3fae:	98 8f       	std	Y+24, r25	; 0x18
    3fb0:	8f 8b       	std	Y+23, r24	; 0x17
    3fb2:	4e cf       	rjmp	.-356    	; 0x3e50 <get_GBROM_info+0x42c>
  if((*gbromData).ROMsize == GBROM_32k) {
    (*gbromData).ROMsizeBytes = 32768;
  } else if ((*gbromData).ROMsize == GBROM_64k) {
    (*gbromData).ROMsizeBytes = 65536;
  } else if ((*gbromData).ROMsize == GBROM_128k) {
    (*gbromData).ROMsizeBytes = 131072;
    3fb4:	80 e0       	ldi	r24, 0x00	; 0
    3fb6:	90 e0       	ldi	r25, 0x00	; 0
    3fb8:	a2 e0       	ldi	r26, 0x02	; 2
    3fba:	b0 e0       	ldi	r27, 0x00	; 0
    3fbc:	8a 8b       	std	Y+18, r24	; 0x12
    3fbe:	9b 8b       	std	Y+19, r25	; 0x13
    3fc0:	ac 8b       	std	Y+20, r26	; 0x14
    3fc2:	bd 8b       	std	Y+21, r27	; 0x15
    3fc4:	36 cf       	rjmp	.-404    	; 0x3e32 <get_GBROM_info+0x40e>
  } else if((*gbromData).MBCtype == GBCART_MBC1) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC1"));
  } else if((*gbromData).MBCtype == GBCART_MBC1_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC1 RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC1_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC1 RAM BATT"));
    3fc6:	ce 01       	movw	r24, r28
    3fc8:	4a 96       	adiw	r24, 0x1a	; 26
    3fca:	65 e0       	ldi	r22, 0x05	; 5
    3fcc:	7a e0       	ldi	r23, 0x0A	; 10
    3fce:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    3fd2:	95 cf       	rjmp	.-214    	; 0x3efe <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC5) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5"));
    3fd4:	ce 01       	movw	r24, r28
    3fd6:	4a 96       	adiw	r24, 0x1a	; 26
    3fd8:	60 e0       	ldi	r22, 0x00	; 0
    3fda:	7a e0       	ldi	r23, 0x0A	; 10
    3fdc:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    3fe0:	8e cf       	rjmp	.-228    	; 0x3efe <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC5_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RAM"));
    3fe2:	ce 01       	movw	r24, r28
    3fe4:	4a 96       	adiw	r24, 0x1a	; 26
    3fe6:	67 ef       	ldi	r22, 0xF7	; 247
    3fe8:	79 e0       	ldi	r23, 0x09	; 9
    3fea:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    3fee:	87 cf       	rjmp	.-242    	; 0x3efe <get_GBROM_info+0x4da>
  } else if ((*gbromData).ROMsize == GBROM_128k) {
    (*gbromData).ROMsizeBytes = 131072;
  } else if ((*gbromData).ROMsize == GBROM_256k) {
    (*gbromData).ROMsizeBytes = 262144;
  } else if ((*gbromData).ROMsize == GBROM_512k) {
    (*gbromData).ROMsizeBytes = 524288;
    3ff0:	80 e0       	ldi	r24, 0x00	; 0
    3ff2:	90 e0       	ldi	r25, 0x00	; 0
    3ff4:	a8 e0       	ldi	r26, 0x08	; 8
    3ff6:	b0 e0       	ldi	r27, 0x00	; 0
    3ff8:	8a 8b       	std	Y+18, r24	; 0x12
    3ffa:	9b 8b       	std	Y+19, r25	; 0x13
    3ffc:	ac 8b       	std	Y+20, r26	; 0x14
    3ffe:	bd 8b       	std	Y+21, r27	; 0x15
    4000:	18 cf       	rjmp	.-464    	; 0x3e32 <get_GBROM_info+0x40e>
  } else if((*gbromData).MBCtype == GBCART_MBC5_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE"));
    4002:	ce 01       	movw	r24, r28
    4004:	4a 96       	adiw	r24, 0x1a	; 26
    4006:	6d ed       	ldi	r22, 0xDD	; 221
    4008:	79 e0       	ldi	r23, 0x09	; 9
    400a:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    400e:	77 cf       	rjmp	.-274    	; 0x3efe <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC3_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC3_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC2) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC2"));
    4010:	ce 01       	movw	r24, r28
    4012:	4a 96       	adiw	r24, 0x1a	; 26
    4014:	67 e7       	ldi	r22, 0x77	; 119
    4016:	79 e0       	ldi	r23, 0x09	; 9
    4018:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    (*gbromData).RAMsizeBytes = 512; // Special case here, as MBC2 header may not disclose internal MBC RAM
    401c:	80 e0       	ldi	r24, 0x00	; 0
    401e:	92 e0       	ldi	r25, 0x02	; 2
    4020:	98 8f       	std	Y+24, r25	; 0x18
    4022:	8f 8b       	std	Y+23, r24	; 0x17
    4024:	6c cf       	rjmp	.-296    	; 0x3efe <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC5) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RAM BATT"));
    4026:	ce 01       	movw	r24, r28
    4028:	4a 96       	adiw	r24, 0x1a	; 26
    402a:	69 ee       	ldi	r22, 0xE9	; 233
    402c:	79 e0       	ldi	r23, 0x09	; 9
    402e:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    4032:	65 cf       	rjmp	.-310    	; 0x3efe <get_GBROM_info+0x4da>
  } else if ((*gbromData).ROMsize == GBROM_256k) {
    (*gbromData).ROMsizeBytes = 262144;
  } else if ((*gbromData).ROMsize == GBROM_512k) {
    (*gbromData).ROMsizeBytes = 524288;
  } else if ((*gbromData).ROMsize == GBROM_1M) {
    (*gbromData).ROMsizeBytes = 1048576;
    4034:	80 e0       	ldi	r24, 0x00	; 0
    4036:	90 e0       	ldi	r25, 0x00	; 0
    4038:	a0 e1       	ldi	r26, 0x10	; 16
    403a:	b0 e0       	ldi	r27, 0x00	; 0
    403c:	8a 8b       	std	Y+18, r24	; 0x12
    403e:	9b 8b       	std	Y+19, r25	; 0x13
    4040:	ac 8b       	std	Y+20, r26	; 0x14
    4042:	bd 8b       	std	Y+21, r27	; 0x15
    4044:	f6 ce       	rjmp	.-532    	; 0x3e32 <get_GBROM_info+0x40e>
  } else if((*gbromData).MBCtype == GBCART_MBC5_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE RAM"));
    4046:	ce 01       	movw	r24, r28
    4048:	4a 96       	adiw	r24, 0x1a	; 26
    404a:	6d ec       	ldi	r22, 0xCD	; 205
    404c:	79 e0       	ldi	r23, 0x09	; 9
    404e:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    4052:	55 cf       	rjmp	.-342    	; 0x3efe <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE RAM BATT"));
    4054:	ce 01       	movw	r24, r28
    4056:	4a 96       	adiw	r24, 0x1a	; 26
    4058:	68 eb       	ldi	r22, 0xB8	; 184
    405a:	79 e0       	ldi	r23, 0x09	; 9
    405c:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    4060:	4e cf       	rjmp	.-356    	; 0x3efe <get_GBROM_info+0x4da>
  } else if ((*gbromData).ROMsize == GBROM_512k) {
    (*gbromData).ROMsizeBytes = 524288;
  } else if ((*gbromData).ROMsize == GBROM_1M) {
    (*gbromData).ROMsizeBytes = 1048576;
  } else if ((*gbromData).ROMsize == GBROM_2M) {
    (*gbromData).ROMsizeBytes = 2097152;
    4062:	80 e0       	ldi	r24, 0x00	; 0
    4064:	90 e0       	ldi	r25, 0x00	; 0
    4066:	a0 e2       	ldi	r26, 0x20	; 32
    4068:	b0 e0       	ldi	r27, 0x00	; 0
    406a:	8a 8b       	std	Y+18, r24	; 0x12
    406c:	9b 8b       	std	Y+19, r25	; 0x13
    406e:	ac 8b       	std	Y+20, r26	; 0x14
    4070:	bd 8b       	std	Y+21, r27	; 0x15
    4072:	df ce       	rjmp	.-578    	; 0x3e32 <get_GBROM_info+0x40e>
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE RAM"));
  } else if((*gbromData).MBCtype == GBCART_MBC5_RUMBLE_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC5 RUMBLE RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC3_RTC_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RTC BATT"));
    4074:	ce 01       	movw	r24, r28
    4076:	4a 96       	adiw	r24, 0x1a	; 26
    4078:	6a ea       	ldi	r22, 0xAA	; 170
    407a:	79 e0       	ldi	r23, 0x09	; 9
    407c:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    4080:	3e cf       	rjmp	.-388    	; 0x3efe <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC3_RTC_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RTC RAM BATT"));
    4082:	ce 01       	movw	r24, r28
    4084:	4a 96       	adiw	r24, 0x1a	; 26
    4086:	68 e9       	ldi	r22, 0x98	; 152
    4088:	79 e0       	ldi	r23, 0x09	; 9
    408a:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    408e:	37 cf       	rjmp	.-402    	; 0x3efe <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC3) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3"));
    4090:	ce 01       	movw	r24, r28
    4092:	4a 96       	adiw	r24, 0x1a	; 26
    4094:	63 e9       	ldi	r22, 0x93	; 147
    4096:	79 e0       	ldi	r23, 0x09	; 9
    4098:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    409c:	30 cf       	rjmp	.-416    	; 0x3efe <get_GBROM_info+0x4da>
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC2) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC2"));
    (*gbromData).RAMsizeBytes = 512; // Special case here, as MBC2 header may not disclose internal MBC RAM
  } else if((*gbromData).MBCtype == GBCART_MBC2_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC2 BATT"));
    409e:	ce 01       	movw	r24, r28
    40a0:	4a 96       	adiw	r24, 0x1a	; 26
    40a2:	6d e6       	ldi	r22, 0x6D	; 109
    40a4:	79 e0       	ldi	r23, 0x09	; 9
    40a6:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    (*gbromData).RAMsizeBytes = 512; // Special case here, as MBC2 header may not disclose internal MBC RAM
    40aa:	80 e0       	ldi	r24, 0x00	; 0
    40ac:	92 e0       	ldi	r25, 0x02	; 2
    40ae:	98 8f       	std	Y+24, r25	; 0x18
    40b0:	8f 8b       	std	Y+23, r24	; 0x17
    40b2:	25 cf       	rjmp	.-438    	; 0x3efe <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC3_RTC_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RTC RAM BATT"));
  } else if((*gbromData).MBCtype == GBCART_MBC3) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3"));
  } else if((*gbromData).MBCtype == GBCART_MBC3_RAM) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RAM"));
    40b4:	ce 01       	movw	r24, r28
    40b6:	4a 96       	adiw	r24, 0x1a	; 26
    40b8:	6a e8       	ldi	r22, 0x8A	; 138
    40ba:	79 e0       	ldi	r23, 0x09	; 9
    40bc:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    40c0:	1e cf       	rjmp	.-452    	; 0x3efe <get_GBROM_info+0x4da>
  } else if((*gbromData).MBCtype == GBCART_MBC3_RAM_BATT) {
    strcpy_P((*gbromData).MBCname,PSTR("MBC3 RAM BATT"));
    40c2:	ce 01       	movw	r24, r28
    40c4:	4a 96       	adiw	r24, 0x1a	; 26
    40c6:	6c e7       	ldi	r22, 0x7C	; 124
    40c8:	79 e0       	ldi	r23, 0x09	; 9
    40ca:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    40ce:	17 cf       	rjmp	.-466    	; 0x3efe <get_GBROM_info+0x4da>

000040d0 <read_MBC_mode_only>:

  return 0;
}

uint8_t read_MBC_mode_only() {
  return eeprom_read_byte(0x00);
    40d0:	80 e0       	ldi	r24, 0x00	; 0
    40d2:	90 e0       	ldi	r25, 0x00	; 0
    40d4:	0e 94 93 21 	call	0x4326	; 0x4326 <__eerd_byte_m644>
}
    40d8:	08 95       	ret

000040da <program_initial_gbeepromdat>:
  } 

  return 0;
}

uint8_t program_initial_gbeepromdat(uint8_t MBCmode) {
    40da:	68 2f       	mov	r22, r24

  eeprom_write_byte(0x00, MBCmode);
    40dc:	80 e0       	ldi	r24, 0x00	; 0
    40de:	90 e0       	ldi	r25, 0x00	; 0
    40e0:	0e 94 cb 21 	call	0x4396	; 0x4396 <__eewr_byte_m644>
  eeprom_write_dword((uint32_t*)0x0A, 115200UL);
    40e4:	8a e0       	ldi	r24, 0x0A	; 10
    40e6:	90 e0       	ldi	r25, 0x00	; 0
    40e8:	40 e0       	ldi	r20, 0x00	; 0
    40ea:	52 ec       	ldi	r21, 0xC2	; 194
    40ec:	61 e0       	ldi	r22, 0x01	; 1
    40ee:	70 e0       	ldi	r23, 0x00	; 0
    40f0:	0e 94 d9 21 	call	0x43b2	; 0x43b2 <__eewr_dword_m644>
  eeprom_write_word((uint16_t*)0x0E, 1);
    40f4:	8e e0       	ldi	r24, 0x0E	; 14
    40f6:	90 e0       	ldi	r25, 0x00	; 0
    40f8:	61 e0       	ldi	r22, 0x01	; 1
    40fa:	70 e0       	ldi	r23, 0x00	; 0
    40fc:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <__eewr_word_m644>

  return 0;
}
    4100:	80 e0       	ldi	r24, 0x00	; 0
    4102:	08 95       	ret

00004104 <compare_gbeepromdat>:
//clock_prescale_set(clock_div_1);

  return 0;
}

uint8_t compare_gbeepromdat(GBEEPROMDATA *eepData) {
    4104:	1f 93       	push	r17
    4106:	cf 93       	push	r28
    4108:	df 93       	push	r29
    410a:	ec 01       	movw	r28, r24
  
  GBEEPROMDATA temp;
  temp.MBCMode = eeprom_read_byte(0x00); // Address 0
    410c:	80 e0       	ldi	r24, 0x00	; 0
    410e:	90 e0       	ldi	r25, 0x00	; 0
    4110:	0e 94 93 21 	call	0x4326	; 0x4326 <__eerd_byte_m644>
    4114:	18 2f       	mov	r17, r24
  temp.uartBaud = eeprom_read_dword((uint32_t*)0x0A);
    4116:	8a e0       	ldi	r24, 0x0A	; 10
    4118:	90 e0       	ldi	r25, 0x00	; 0
    411a:	0e 94 9b 21 	call	0x4336	; 0x4336 <__eerd_dword_m644>
    411e:	9b 01       	movw	r18, r22
    4120:	ac 01       	movw	r20, r24

  if (temp.MBCMode != (*eepData).MBCMode) {
    4122:	88 81       	ld	r24, Y
    4124:	18 17       	cp	r17, r24
    4126:	31 f0       	breq	.+12     	; 0x4134 <compare_gbeepromdat+0x30>
    4128:	61 e0       	ldi	r22, 0x01	; 1
  } else if (temp.uartBaud != (*eepData).uartBaud){
    return 1;
  } 

  return 0;
}
    412a:	86 2f       	mov	r24, r22
    412c:	df 91       	pop	r29
    412e:	cf 91       	pop	r28
    4130:	1f 91       	pop	r17
    4132:	08 95       	ret
  
  GBEEPROMDATA temp;
  temp.MBCMode = eeprom_read_byte(0x00); // Address 0
  temp.uartBaud = eeprom_read_dword((uint32_t*)0x0A);

  if (temp.MBCMode != (*eepData).MBCMode) {
    4134:	60 e0       	ldi	r22, 0x00	; 0
    4136:	8a 85       	ldd	r24, Y+10	; 0x0a
    4138:	9b 85       	ldd	r25, Y+11	; 0x0b
    413a:	ac 85       	ldd	r26, Y+12	; 0x0c
    413c:	bd 85       	ldd	r27, Y+13	; 0x0d
    413e:	28 17       	cp	r18, r24
    4140:	39 07       	cpc	r19, r25
    4142:	4a 07       	cpc	r20, r26
    4144:	5b 07       	cpc	r21, r27
    4146:	81 f7       	brne	.-32     	; 0x4128 <compare_gbeepromdat+0x24>
  } else if (temp.uartBaud != (*eepData).uartBaud){
    return 1;
  } 

  return 0;
}
    4148:	86 2f       	mov	r24, r22
    414a:	df 91       	pop	r29
    414c:	cf 91       	pop	r28
    414e:	1f 91       	pop	r17
    4150:	08 95       	ret

00004152 <write_update_gbeepromdat>:
  }

  return 0;
}

uint8_t write_update_gbeepromdat(GBEEPROMDATA *eepData) {
    4152:	0f 93       	push	r16
    4154:	1f 93       	push	r17
    4156:	8c 01       	movw	r16, r24
  
  

  (*eepData).writeCount++;
    4158:	fc 01       	movw	r30, r24
    415a:	86 85       	ldd	r24, Z+14	; 0x0e
    415c:	97 85       	ldd	r25, Z+15	; 0x0f
    415e:	01 96       	adiw	r24, 0x01	; 1
    4160:	97 87       	std	Z+15, r25	; 0x0f
    4162:	86 87       	std	Z+14, r24	; 0x0e
// Trying to drop the clock speed for writes, as I seem to have errors
//clock_prescale_set(clock_div_2);
  eeprom_update_byte(0x00, (*eepData).MBCMode);
    4164:	80 e0       	ldi	r24, 0x00	; 0
    4166:	90 e0       	ldi	r25, 0x00	; 0
    4168:	60 81       	ld	r22, Z
    416a:	0e 94 a7 21 	call	0x434e	; 0x434e <__eeupd_byte_m644>
  eeprom_update_dword((uint32_t*)0x0A, (*eepData).uartBaud);
    416e:	f8 01       	movw	r30, r16
    4170:	42 85       	ldd	r20, Z+10	; 0x0a
    4172:	53 85       	ldd	r21, Z+11	; 0x0b
    4174:	64 85       	ldd	r22, Z+12	; 0x0c
    4176:	75 85       	ldd	r23, Z+13	; 0x0d
    4178:	8a e0       	ldi	r24, 0x0A	; 10
    417a:	90 e0       	ldi	r25, 0x00	; 0
    417c:	0e 94 b9 21 	call	0x4372	; 0x4372 <__eeupd_dword_m644>
  eeprom_update_word((uint16_t*)0x0E, (*eepData).writeCount);
    4180:	f8 01       	movw	r30, r16
    4182:	66 85       	ldd	r22, Z+14	; 0x0e
    4184:	77 85       	ldd	r23, Z+15	; 0x0f
    4186:	8e e0       	ldi	r24, 0x0E	; 14
    4188:	90 e0       	ldi	r25, 0x00	; 0
    418a:	0e 94 c5 21 	call	0x438a	; 0x438a <__eeupd_word_m644>

//clock_prescale_set(clock_div_1);

  return 0;
}
    418e:	80 e0       	ldi	r24, 0x00	; 0
    4190:	1f 91       	pop	r17
    4192:	0f 91       	pop	r16
    4194:	08 95       	ret

00004196 <read_gbeepromdat>:
0x01-09 MBCName
0x0A-0D uartBaud
0x0E-0F writeCount
*/

uint8_t read_gbeepromdat(GBEEPROMDATA *eepData) {
    4196:	1f 93       	push	r17
    4198:	cf 93       	push	r28
    419a:	df 93       	push	r29
    419c:	ec 01       	movw	r28, r24
  
  (*eepData).MBCMode = eeprom_read_byte(0x00); // Address 0
    419e:	80 e0       	ldi	r24, 0x00	; 0
    41a0:	90 e0       	ldi	r25, 0x00	; 0
    41a2:	0e 94 93 21 	call	0x4326	; 0x4326 <__eerd_byte_m644>
    41a6:	18 2f       	mov	r17, r24
    41a8:	88 83       	st	Y, r24
  (*eepData).uartBaud = eeprom_read_dword((uint32_t*)0x0A);
    41aa:	8a e0       	ldi	r24, 0x0A	; 10
    41ac:	90 e0       	ldi	r25, 0x00	; 0
    41ae:	0e 94 9b 21 	call	0x4336	; 0x4336 <__eerd_dword_m644>
    41b2:	6a 87       	std	Y+10, r22	; 0x0a
    41b4:	7b 87       	std	Y+11, r23	; 0x0b
    41b6:	8c 87       	std	Y+12, r24	; 0x0c
    41b8:	9d 87       	std	Y+13, r25	; 0x0d
  (*eepData).writeCount = eeprom_read_word((uint16_t*)0x0E);
    41ba:	8e e0       	ldi	r24, 0x0E	; 14
    41bc:	90 e0       	ldi	r25, 0x00	; 0
    41be:	0e 94 a1 21 	call	0x4342	; 0x4342 <__eerd_word_m644>
    41c2:	9f 87       	std	Y+15, r25	; 0x0f
    41c4:	8e 87       	std	Y+14, r24	; 0x0e

  if((*eepData).MBCMode == CART_MODE_MBC1_16M) {
    41c6:	10 34       	cpi	r17, 0x40	; 64
    41c8:	f1 f0       	breq	.+60     	; 0x4206 <read_gbeepromdat+0x70>
    strcpy_P((*eepData).MBCName, PSTR("MBC1_16M"));
  } else if((*eepData).MBCMode == CART_MODE_MBC1_4M) {
    41ca:	11 34       	cpi	r17, 0x41	; 65
    41cc:	39 f1       	breq	.+78     	; 0x421c <read_gbeepromdat+0x86>
    strcpy_P((*eepData).MBCName, PSTR("MBC1_4M "));
  } else if((*eepData).MBCMode == CART_MODE_MBC2) {
    41ce:	15 34       	cpi	r17, 0x45	; 69
    41d0:	81 f1       	breq	.+96     	; 0x4232 <read_gbeepromdat+0x9c>
    strcpy_P((*eepData).MBCName, PSTR("MBC2    "));
  } else if((*eepData).MBCMode == CART_MODE_MBC3) {
    41d2:	13 34       	cpi	r17, 0x43	; 67
    41d4:	c9 f1       	breq	.+114    	; 0x4248 <read_gbeepromdat+0xb2>
    strcpy_P((*eepData).MBCName, PSTR("MBC3    "));
  } else if((*eepData).MBCMode == CART_MODE_MBC5) {
    41d6:	12 34       	cpi	r17, 0x42	; 66
    41d8:	59 f0       	breq	.+22     	; 0x41f0 <read_gbeepromdat+0x5a>
    strcpy_P((*eepData).MBCName, PSTR("MBC5    "));
  } else {
    strcpy_P((*eepData).MBCName, PSTR("MODE UNK"));
    41da:	ce 01       	movw	r24, r28
    41dc:	01 96       	adiw	r24, 0x01	; 1
    41de:	6a e2       	ldi	r22, 0x2A	; 42
    41e0:	7a e0       	ldi	r23, 0x0A	; 10
    41e2:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
  }

  return 0;
}
    41e6:	80 e0       	ldi	r24, 0x00	; 0
    41e8:	df 91       	pop	r29
    41ea:	cf 91       	pop	r28
    41ec:	1f 91       	pop	r17
    41ee:	08 95       	ret
  } else if((*eepData).MBCMode == CART_MODE_MBC2) {
    strcpy_P((*eepData).MBCName, PSTR("MBC2    "));
  } else if((*eepData).MBCMode == CART_MODE_MBC3) {
    strcpy_P((*eepData).MBCName, PSTR("MBC3    "));
  } else if((*eepData).MBCMode == CART_MODE_MBC5) {
    strcpy_P((*eepData).MBCName, PSTR("MBC5    "));
    41f0:	ce 01       	movw	r24, r28
    41f2:	01 96       	adiw	r24, 0x01	; 1
    41f4:	63 e3       	ldi	r22, 0x33	; 51
    41f6:	7a e0       	ldi	r23, 0x0A	; 10
    41f8:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
  } else {
    strcpy_P((*eepData).MBCName, PSTR("MODE UNK"));
  }

  return 0;
}
    41fc:	80 e0       	ldi	r24, 0x00	; 0
    41fe:	df 91       	pop	r29
    4200:	cf 91       	pop	r28
    4202:	1f 91       	pop	r17
    4204:	08 95       	ret
  (*eepData).MBCMode = eeprom_read_byte(0x00); // Address 0
  (*eepData).uartBaud = eeprom_read_dword((uint32_t*)0x0A);
  (*eepData).writeCount = eeprom_read_word((uint16_t*)0x0E);

  if((*eepData).MBCMode == CART_MODE_MBC1_16M) {
    strcpy_P((*eepData).MBCName, PSTR("MBC1_16M"));
    4206:	ce 01       	movw	r24, r28
    4208:	01 96       	adiw	r24, 0x01	; 1
    420a:	67 e5       	ldi	r22, 0x57	; 87
    420c:	7a e0       	ldi	r23, 0x0A	; 10
    420e:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
  } else {
    strcpy_P((*eepData).MBCName, PSTR("MODE UNK"));
  }

  return 0;
}
    4212:	80 e0       	ldi	r24, 0x00	; 0
    4214:	df 91       	pop	r29
    4216:	cf 91       	pop	r28
    4218:	1f 91       	pop	r17
    421a:	08 95       	ret
  (*eepData).writeCount = eeprom_read_word((uint16_t*)0x0E);

  if((*eepData).MBCMode == CART_MODE_MBC1_16M) {
    strcpy_P((*eepData).MBCName, PSTR("MBC1_16M"));
  } else if((*eepData).MBCMode == CART_MODE_MBC1_4M) {
    strcpy_P((*eepData).MBCName, PSTR("MBC1_4M "));
    421c:	ce 01       	movw	r24, r28
    421e:	01 96       	adiw	r24, 0x01	; 1
    4220:	6e e4       	ldi	r22, 0x4E	; 78
    4222:	7a e0       	ldi	r23, 0x0A	; 10
    4224:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
  } else {
    strcpy_P((*eepData).MBCName, PSTR("MODE UNK"));
  }

  return 0;
}
    4228:	80 e0       	ldi	r24, 0x00	; 0
    422a:	df 91       	pop	r29
    422c:	cf 91       	pop	r28
    422e:	1f 91       	pop	r17
    4230:	08 95       	ret
  if((*eepData).MBCMode == CART_MODE_MBC1_16M) {
    strcpy_P((*eepData).MBCName, PSTR("MBC1_16M"));
  } else if((*eepData).MBCMode == CART_MODE_MBC1_4M) {
    strcpy_P((*eepData).MBCName, PSTR("MBC1_4M "));
  } else if((*eepData).MBCMode == CART_MODE_MBC2) {
    strcpy_P((*eepData).MBCName, PSTR("MBC2    "));
    4232:	ce 01       	movw	r24, r28
    4234:	01 96       	adiw	r24, 0x01	; 1
    4236:	65 e4       	ldi	r22, 0x45	; 69
    4238:	7a e0       	ldi	r23, 0x0A	; 10
    423a:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
  } else {
    strcpy_P((*eepData).MBCName, PSTR("MODE UNK"));
  }

  return 0;
}
    423e:	80 e0       	ldi	r24, 0x00	; 0
    4240:	df 91       	pop	r29
    4242:	cf 91       	pop	r28
    4244:	1f 91       	pop	r17
    4246:	08 95       	ret
  } else if((*eepData).MBCMode == CART_MODE_MBC1_4M) {
    strcpy_P((*eepData).MBCName, PSTR("MBC1_4M "));
  } else if((*eepData).MBCMode == CART_MODE_MBC2) {
    strcpy_P((*eepData).MBCName, PSTR("MBC2    "));
  } else if((*eepData).MBCMode == CART_MODE_MBC3) {
    strcpy_P((*eepData).MBCName, PSTR("MBC3    "));
    4248:	ce 01       	movw	r24, r28
    424a:	01 96       	adiw	r24, 0x01	; 1
    424c:	6c e3       	ldi	r22, 0x3C	; 60
    424e:	7a e0       	ldi	r23, 0x0A	; 10
    4250:	0e 94 8c 21 	call	0x4318	; 0x4318 <strcpy_P>
    4254:	c8 cf       	rjmp	.-112    	; 0x41e6 <read_gbeepromdat+0x50>

00004256 <__mulsi3>:
    4256:	62 9f       	mul	r22, r18
    4258:	d0 01       	movw	r26, r0
    425a:	73 9f       	mul	r23, r19
    425c:	f0 01       	movw	r30, r0
    425e:	82 9f       	mul	r24, r18
    4260:	e0 0d       	add	r30, r0
    4262:	f1 1d       	adc	r31, r1
    4264:	64 9f       	mul	r22, r20
    4266:	e0 0d       	add	r30, r0
    4268:	f1 1d       	adc	r31, r1
    426a:	92 9f       	mul	r25, r18
    426c:	f0 0d       	add	r31, r0
    426e:	83 9f       	mul	r24, r19
    4270:	f0 0d       	add	r31, r0
    4272:	74 9f       	mul	r23, r20
    4274:	f0 0d       	add	r31, r0
    4276:	65 9f       	mul	r22, r21
    4278:	f0 0d       	add	r31, r0
    427a:	99 27       	eor	r25, r25
    427c:	72 9f       	mul	r23, r18
    427e:	b0 0d       	add	r27, r0
    4280:	e1 1d       	adc	r30, r1
    4282:	f9 1f       	adc	r31, r25
    4284:	63 9f       	mul	r22, r19
    4286:	b0 0d       	add	r27, r0
    4288:	e1 1d       	adc	r30, r1
    428a:	f9 1f       	adc	r31, r25
    428c:	bd 01       	movw	r22, r26
    428e:	cf 01       	movw	r24, r30
    4290:	11 24       	eor	r1, r1
    4292:	08 95       	ret

00004294 <__udivmodqi4>:
    4294:	99 1b       	sub	r25, r25
    4296:	79 e0       	ldi	r23, 0x09	; 9
    4298:	04 c0       	rjmp	.+8      	; 0x42a2 <__udivmodqi4_ep>

0000429a <__udivmodqi4_loop>:
    429a:	99 1f       	adc	r25, r25
    429c:	96 17       	cp	r25, r22
    429e:	08 f0       	brcs	.+2      	; 0x42a2 <__udivmodqi4_ep>
    42a0:	96 1b       	sub	r25, r22

000042a2 <__udivmodqi4_ep>:
    42a2:	88 1f       	adc	r24, r24
    42a4:	7a 95       	dec	r23
    42a6:	c9 f7       	brne	.-14     	; 0x429a <__udivmodqi4_loop>
    42a8:	80 95       	com	r24
    42aa:	08 95       	ret

000042ac <__udivmodhi4>:
    42ac:	aa 1b       	sub	r26, r26
    42ae:	bb 1b       	sub	r27, r27
    42b0:	51 e1       	ldi	r21, 0x11	; 17
    42b2:	07 c0       	rjmp	.+14     	; 0x42c2 <__udivmodhi4_ep>

000042b4 <__udivmodhi4_loop>:
    42b4:	aa 1f       	adc	r26, r26
    42b6:	bb 1f       	adc	r27, r27
    42b8:	a6 17       	cp	r26, r22
    42ba:	b7 07       	cpc	r27, r23
    42bc:	10 f0       	brcs	.+4      	; 0x42c2 <__udivmodhi4_ep>
    42be:	a6 1b       	sub	r26, r22
    42c0:	b7 0b       	sbc	r27, r23

000042c2 <__udivmodhi4_ep>:
    42c2:	88 1f       	adc	r24, r24
    42c4:	99 1f       	adc	r25, r25
    42c6:	5a 95       	dec	r21
    42c8:	a9 f7       	brne	.-22     	; 0x42b4 <__udivmodhi4_loop>
    42ca:	80 95       	com	r24
    42cc:	90 95       	com	r25
    42ce:	bc 01       	movw	r22, r24
    42d0:	cd 01       	movw	r24, r26
    42d2:	08 95       	ret

000042d4 <__udivmodsi4>:
    42d4:	a1 e2       	ldi	r26, 0x21	; 33
    42d6:	1a 2e       	mov	r1, r26
    42d8:	aa 1b       	sub	r26, r26
    42da:	bb 1b       	sub	r27, r27
    42dc:	fd 01       	movw	r30, r26
    42de:	0d c0       	rjmp	.+26     	; 0x42fa <__udivmodsi4_ep>

000042e0 <__udivmodsi4_loop>:
    42e0:	aa 1f       	adc	r26, r26
    42e2:	bb 1f       	adc	r27, r27
    42e4:	ee 1f       	adc	r30, r30
    42e6:	ff 1f       	adc	r31, r31
    42e8:	a2 17       	cp	r26, r18
    42ea:	b3 07       	cpc	r27, r19
    42ec:	e4 07       	cpc	r30, r20
    42ee:	f5 07       	cpc	r31, r21
    42f0:	20 f0       	brcs	.+8      	; 0x42fa <__udivmodsi4_ep>
    42f2:	a2 1b       	sub	r26, r18
    42f4:	b3 0b       	sbc	r27, r19
    42f6:	e4 0b       	sbc	r30, r20
    42f8:	f5 0b       	sbc	r31, r21

000042fa <__udivmodsi4_ep>:
    42fa:	66 1f       	adc	r22, r22
    42fc:	77 1f       	adc	r23, r23
    42fe:	88 1f       	adc	r24, r24
    4300:	99 1f       	adc	r25, r25
    4302:	1a 94       	dec	r1
    4304:	69 f7       	brne	.-38     	; 0x42e0 <__udivmodsi4_loop>
    4306:	60 95       	com	r22
    4308:	70 95       	com	r23
    430a:	80 95       	com	r24
    430c:	90 95       	com	r25
    430e:	9b 01       	movw	r18, r22
    4310:	ac 01       	movw	r20, r24
    4312:	bd 01       	movw	r22, r26
    4314:	cf 01       	movw	r24, r30
    4316:	08 95       	ret

00004318 <strcpy_P>:
    4318:	fb 01       	movw	r30, r22
    431a:	dc 01       	movw	r26, r24
    431c:	05 90       	lpm	r0, Z+
    431e:	0d 92       	st	X+, r0
    4320:	00 20       	and	r0, r0
    4322:	e1 f7       	brne	.-8      	; 0x431c <strcpy_P+0x4>
    4324:	08 95       	ret

00004326 <__eerd_byte_m644>:
    4326:	f9 99       	sbic	0x1f, 1	; 31
    4328:	fe cf       	rjmp	.-4      	; 0x4326 <__eerd_byte_m644>
    432a:	92 bd       	out	0x22, r25	; 34
    432c:	81 bd       	out	0x21, r24	; 33
    432e:	f8 9a       	sbi	0x1f, 0	; 31
    4330:	99 27       	eor	r25, r25
    4332:	80 b5       	in	r24, 0x20	; 32
    4334:	08 95       	ret

00004336 <__eerd_dword_m644>:
    4336:	a6 e1       	ldi	r26, 0x16	; 22
    4338:	b0 e0       	ldi	r27, 0x00	; 0
    433a:	44 e0       	ldi	r20, 0x04	; 4
    433c:	50 e0       	ldi	r21, 0x00	; 0
    433e:	0c 94 e8 21 	jmp	0x43d0	; 0x43d0 <__eerd_blraw_m644>

00004342 <__eerd_word_m644>:
    4342:	a8 e1       	ldi	r26, 0x18	; 24
    4344:	b0 e0       	ldi	r27, 0x00	; 0
    4346:	42 e0       	ldi	r20, 0x02	; 2
    4348:	50 e0       	ldi	r21, 0x00	; 0
    434a:	0c 94 e8 21 	jmp	0x43d0	; 0x43d0 <__eerd_blraw_m644>

0000434e <__eeupd_byte_m644>:
    434e:	26 2f       	mov	r18, r22

00004350 <__eeupd_r18_m644>:
    4350:	f9 99       	sbic	0x1f, 1	; 31
    4352:	fe cf       	rjmp	.-4      	; 0x4350 <__eeupd_r18_m644>
    4354:	92 bd       	out	0x22, r25	; 34
    4356:	81 bd       	out	0x21, r24	; 33
    4358:	f8 9a       	sbi	0x1f, 0	; 31
    435a:	01 97       	sbiw	r24, 0x01	; 1
    435c:	00 b4       	in	r0, 0x20	; 32
    435e:	02 16       	cp	r0, r18
    4360:	39 f0       	breq	.+14     	; 0x4370 <__eeupd_r18_m644+0x20>
    4362:	1f ba       	out	0x1f, r1	; 31
    4364:	20 bd       	out	0x20, r18	; 32
    4366:	0f b6       	in	r0, 0x3f	; 63
    4368:	f8 94       	cli
    436a:	fa 9a       	sbi	0x1f, 2	; 31
    436c:	f9 9a       	sbi	0x1f, 1	; 31
    436e:	0f be       	out	0x3f, r0	; 63
    4370:	08 95       	ret

00004372 <__eeupd_dword_m644>:
    4372:	03 96       	adiw	r24, 0x03	; 3
    4374:	27 2f       	mov	r18, r23
    4376:	0e 94 a8 21 	call	0x4350	; 0x4350 <__eeupd_r18_m644>
    437a:	0e 94 a7 21 	call	0x434e	; 0x434e <__eeupd_byte_m644>
    437e:	25 2f       	mov	r18, r21
    4380:	0e 94 a8 21 	call	0x4350	; 0x4350 <__eeupd_r18_m644>
    4384:	24 2f       	mov	r18, r20
    4386:	0c 94 a8 21 	jmp	0x4350	; 0x4350 <__eeupd_r18_m644>

0000438a <__eeupd_word_m644>:
    438a:	01 96       	adiw	r24, 0x01	; 1
    438c:	27 2f       	mov	r18, r23
    438e:	0e 94 a8 21 	call	0x4350	; 0x4350 <__eeupd_r18_m644>
    4392:	0c 94 a7 21 	jmp	0x434e	; 0x434e <__eeupd_byte_m644>

00004396 <__eewr_byte_m644>:
    4396:	26 2f       	mov	r18, r22

00004398 <__eewr_r18_m644>:
    4398:	f9 99       	sbic	0x1f, 1	; 31
    439a:	fe cf       	rjmp	.-4      	; 0x4398 <__eewr_r18_m644>
    439c:	1f ba       	out	0x1f, r1	; 31
    439e:	92 bd       	out	0x22, r25	; 34
    43a0:	81 bd       	out	0x21, r24	; 33
    43a2:	20 bd       	out	0x20, r18	; 32
    43a4:	0f b6       	in	r0, 0x3f	; 63
    43a6:	f8 94       	cli
    43a8:	fa 9a       	sbi	0x1f, 2	; 31
    43aa:	f9 9a       	sbi	0x1f, 1	; 31
    43ac:	0f be       	out	0x3f, r0	; 63
    43ae:	01 96       	adiw	r24, 0x01	; 1
    43b0:	08 95       	ret

000043b2 <__eewr_dword_m644>:
    43b2:	24 2f       	mov	r18, r20
    43b4:	0e 94 cc 21 	call	0x4398	; 0x4398 <__eewr_r18_m644>
    43b8:	25 2f       	mov	r18, r21
    43ba:	0e 94 cc 21 	call	0x4398	; 0x4398 <__eewr_r18_m644>
    43be:	0c 94 e1 21 	jmp	0x43c2	; 0x43c2 <__eewr_word_m644>

000043c2 <__eewr_word_m644>:
    43c2:	0e 94 cb 21 	call	0x4396	; 0x4396 <__eewr_byte_m644>
    43c6:	27 2f       	mov	r18, r23
    43c8:	0c 94 cc 21 	jmp	0x4398	; 0x4398 <__eewr_r18_m644>

000043cc <__eerd_block_m644>:
    43cc:	dc 01       	movw	r26, r24
    43ce:	cb 01       	movw	r24, r22

000043d0 <__eerd_blraw_m644>:
    43d0:	fc 01       	movw	r30, r24
    43d2:	f9 99       	sbic	0x1f, 1	; 31
    43d4:	fe cf       	rjmp	.-4      	; 0x43d2 <__eerd_blraw_m644+0x2>
    43d6:	06 c0       	rjmp	.+12     	; 0x43e4 <__eerd_blraw_m644+0x14>
    43d8:	f2 bd       	out	0x22, r31	; 34
    43da:	e1 bd       	out	0x21, r30	; 33
    43dc:	f8 9a       	sbi	0x1f, 0	; 31
    43de:	31 96       	adiw	r30, 0x01	; 1
    43e0:	00 b4       	in	r0, 0x20	; 32
    43e2:	0d 92       	st	X+, r0
    43e4:	41 50       	subi	r20, 0x01	; 1
    43e6:	50 40       	sbci	r21, 0x00	; 0
    43e8:	b8 f7       	brcc	.-18     	; 0x43d8 <__eerd_blraw_m644+0x8>
    43ea:	08 95       	ret

000043ec <_exit>:
    43ec:	f8 94       	cli

000043ee <__stop_program>:
    43ee:	ff cf       	rjmp	.-2      	; 0x43ee <__stop_program>

Disassembly of section .MBC1_16M_0000:

00008000 <.MBC1_16M_0000>:
; **********************************************************************************
; ************* MBC1 16M8k MODE JUMP TABLE *****************************************
; **********************************************************************************
; ************************* READ JUMP TABLE (Read is low)
.section .MBC1_16M_0000,"ax",@progbits ;0x4000 ROM bank 0
  out   _SFR_IO_ADDR(PORTC), r1; Set PORTC to 0x00
    8000:	18 b8       	out	0x08, r1	; 8
  rjmp  MBC1_16M_CLK; Finished setting up the lines for a read :)
    8002:	08 cf       	rjmp	.-496    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_0010:

00008040 <.MBC1_16M_0010>:

.section .MBC1_16M_0010,"ax",@progbits ;0x4020 ROM bank 0
  out   _SFR_IO_ADDR(PORTC), r1; Set PORTC to 0x00
    8040:	18 b8       	out	0x08, r1	; 8
  rjmp  MBC1_16M_CLK; Finished setting up the lines for a read :);
    8042:	e8 ce       	rjmp	.-560    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_0100:

00008080 <.MBC1_16M_0100>:

.section .MBC1_16M_0100,"ax",@progbits ;0x4040 ROM bank XX
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the stored MA14_18_21 value (r22)
    8080:	68 b9       	out	0x08, r22	; 8
  rjmp  MBC1_16M_CLK; Finished setting up the lines for a read :)
    8082:	c8 ce       	rjmp	.-624    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_0110:

000080c0 <.MBC1_16M_0110>:

.section .MBC1_16M_0110,"ax",@progbits ;0x4060 ROM bank XX
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the stored MA14_18_21 value (r22)
    80c0:	68 b9       	out	0x08, r22	; 8
  rjmp  MBC1_16M_CLK; Finished setting up the lines for a read :)
    80c2:	a8 ce       	rjmp	.-688    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_1000:

00008100 <.MBC1_16M_1000>:

.section .MBC1_16M_1000,"ax",@progbits ;0x4080 Reserved. Do nothing
  rjmp  MBC1_16M_CLK;
    8100:	89 ce       	rjmp	.-750    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_1010:

00008140 <.MBC1_16M_1010>:
;  andi  r16, 0xC0; RAM_/EN & GB_/CS flag pin check <- consider changing this to a register
;  brbc  1, MBC1_16M_RAM_DIS; branch without enabling RAM if zero flag is not set in SREG
;  cbi   _SFR_IO_ADDR(PORTA), PA2;SRAM_CS_PIN - Pull SRAM_CS low
;MBC1_16M_RAM_DIS:
  ; don't think I need to do anything with access controlled in hardware (OR gate)
  rjmp  MBC1_16M_CLK;
    8140:	69 ce       	rjmp	.-814    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_1100:

00008180 <.MBC1_16M_1100>:

.section .MBC1_16M_1100,"ax",@progbits ;0x40C0 Reserved. Do nothing
  rjmp  MBC1_16M_CLK;
    8180:	49 ce       	rjmp	.-878    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_1110:

000081c0 <.MBC1_16M_1110>:

.section .MBC1_16M_1110,"ax",@progbits ;0x40E0 Reserved. Do nothing
  rjmp  MBC1_16M_CLK;
    81c0:	29 ce       	rjmp	.-942    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_0001:

00008020 <MBC1_16M_RAM_FLG_DIS-0x10>:

; ************************* WRITE JUMP TABLE (Read is hi)
.section .MBC1_16M_0001,"ax",@progbits ;0x4010 Ram enable/disable
  nop; This many NOPS may be needed to as data isn't good until WR is asserted
    8020:	00 00       	nop
  nop;
    8022:	00 00       	nop
  in    r17, _SFR_IO_ADDR(PINB)
    8024:	13 b1       	in	r17, 0x03	; 3
  andi  r17, 0x1F ; Mask D0-4. I don't want to add this, but we'll see if MBC data is corrupted otherwise
    8026:	1f 71       	andi	r17, 0x1F	; 31
  cpi   r17, 0x0A; 0x0A is an enable command
    8028:	1a 30       	cpi	r17, 0x0A	; 10
  brne  MBC1_16M_RAM_FLG_DIS
    802a:	11 f4       	brne	.+4      	; 0x8030 <MBC1_16M_RAM_FLG_DIS>
  cbi   _SFR_IO_ADDR(PORTA), PA7;
    802c:	17 98       	cbi	0x02, 7	; 2
  rjmp  MBC1_16M_CLK
    802e:	f2 ce       	rjmp	.-540    	; 0x7e14 <MBC1_16M_CLK>

00008030 <MBC1_16M_RAM_FLG_DIS>:
MBC1_16M_RAM_FLG_DIS:
  sbi   _SFR_IO_ADDR(PORTA), PA7
    8030:	17 9a       	sbi	0x02, 7	; 2
  rjmp  MBC1_16M_CLK
    8032:	f0 ce       	rjmp	.-544    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_0011:

00008060 <MBC1_16M_NZERO-0xe>:

.section .MBC1_16M_0011,"ax",@progbits ;0x4030 ROM bank numbers
  andi  r22, 0xE0;REG_MA14_18, MA19_21_MASK ; Mask only hi bits to ditch the old low bits
    8060:	60 7e       	andi	r22, 0xE0	; 224
  nop; Need a NOP here for DATA to be valid... without this, this is 13-16 cycles in, so it should be safe...
    8062:	00 00       	nop
  in    r17, _SFR_IO_ADDR(PINB);GB_DAT_REG, GB_DAT_R ;Read in PINB data for use in each write mode
    8064:	13 b1       	in	r17, 0x03	; 3
  andi  r17, 0x1F ; Mask D0-4. I don't want to add this, but we'll see if MBC data is corrupted otherwise
    8066:	1f 71       	andi	r17, 0x1F	; 31
  tst   r17
    8068:	11 23       	and	r17, r17
  brne  MBC1_16M_NZERO
    806a:	09 f4       	brne	.+2      	; 0x806e <MBC1_16M_NZERO>
  inc   r17
    806c:	13 95       	inc	r17

0000806e <MBC1_16M_NZERO>:
MBC1_16M_NZERO:
  or    r22, r17;REG_MA14_18, GB_DAT_REG
    806e:	61 2b       	or	r22, r17
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the MA mask value. Probably don't need to OUT this here for a WRITE command
    8070:	68 b9       	out	0x08, r22	; 8
  rjmp  MBC1_16M_CLK;
    8072:	d0 ce       	rjmp	.-608    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_0101:

000080a0 <.MBC1_16M_0101>:

.section .MBC1_16M_0101,"ax",@progbits ;0x4050 ROM bank number high bits
  andi  r22, 0x1F ;REG_MA14_21, 0x1F; CLR the older data
    80a0:	6f 71       	andi	r22, 0x1F	; 31
  nop; This many NOPS may be needed to as data isn't good until WR is asserted
    80a2:	00 00       	nop
  sbic  _SFR_IO_ADDR(PINB), 0
    80a4:	18 99       	sbic	0x03, 0	; 3
  sbr   r22, 5;REG_MA14_21, 5; Set bit 5, MA19
    80a6:	65 60       	ori	r22, 0x05	; 5
  sbic  _SFR_IO_ADDR(PINB), 1
    80a8:	19 99       	sbic	0x03, 1	; 3
  sbr   r22, 6;REG_MA14_21, 6; Set bit 6, MA20
    80aa:	66 60       	ori	r22, 0x06	; 6
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER ;R_MA14_21, REG_MA14_21
    80ac:	68 b9       	out	0x08, r22	; 8
  rjmp MBC1_16M_CLK;
    80ae:	b2 ce       	rjmp	.-668    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_0111:

000080e0 <.MBC1_16M_0111>:

.section .MBC1_16M_0111,"ax",@progbits ;0x4070 ROM/RAM mode select
  ; Figure out if we need a mode change
  nop; This many NOPS may be needed to as data isn't good until WR is asserted
    80e0:	00 00       	nop
  nop;
    80e2:	00 00       	nop
  sbis  _SFR_IO_ADDR(PINB), 0 ; Skip if Data bit 0 is set - we need a mode change
    80e4:	18 9b       	sbis	0x03, 0	; 3
  rjmp  MBC1_16M_CLK; Stay in our own lane
    80e6:	96 ce       	rjmp	.-724    	; 0x7e14 <MBC1_16M_CLK>
/*  sbrc  r22, 5; lo hi bit (decipher that!) ; I took this part out because TCAGBD said this is zeroed. Should I save it in case this mode comes back?
  sbi   _SFR_IO_ADDR(PORTA), 0
  sbrc  r22, 6; hi hi bit
  sbi   _SFR_IO_ADDR(PORTA), 1*/

  andi  r22, 0x1F;REG_MA14_21, remove the high bits as we're mode switching
    80e8:	6f 71       	andi	r22, 0x1F	; 31
  out   _SFR_IO_ADDR(PORTC), r22; Update the MA address bits before we switch modes
    80ea:	68 b9       	out	0x08, r22	; 8
  rjmp  MBC1_4M_CLK ; Mode switch jump!
    80ec:	a7 ce       	rjmp	.-690    	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_16M_1001:

00008120 <.MBC1_16M_1001>:

.section .MBC1_16M_1001,"ax",@progbits ;0x4090 Reserved. Do nothing
  rjmp  MBC1_16M_CLK;
    8120:	79 ce       	rjmp	.-782    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_1011:

00008160 <.MBC1_16M_1011>:
;  andi  r16, 0xC0; RAM_/EN & GB_/CS flag pin check <- consider changing this to a register
;  brbc  1, MBC1_16M_RAM_DIS2; branch without enabling RAM if zero flag is not set in SREG
;  cbi   _SFR_IO_ADDR(PORTA), PA2;SRAM_CS_PIN - Pull SRAM_CS low
;MBC1_16M_RAM_DIS2:
; May not need anything here with SRAM being controlled by the OR gate (and INTERNAL_RAM pin)
  rjmp  MBC1_16M_CLK;
    8160:	59 ce       	rjmp	.-846    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_1101:

000081a0 <.MBC1_16M_1101>:

.section .MBC1_16M_1101,"ax",@progbits ;0x40D0 Reserved. Do nothing
  rjmp  MBC1_16M_CLK;
    81a0:	39 ce       	rjmp	.-910    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_16M_1111:

000081e0 <.MBC1_16M_1111>:

.section .MBC1_16M_1111,"ax",@progbits ;0x40F0 Reserved. Do nothing
  rjmp  MBC1_16M_CLK;
    81e0:	19 ce       	rjmp	.-974    	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_4M_0000:

00008200 <.MBC1_4M_0000>:
; **********************************************************************************
; ************* MBC1 2M32k MODE JUMP TABLE *****************************************
; **********************************************************************************
; ************************* READ JUMP TABLE (Read is low)
.section .MBC1_4M_0000,"ax",@progbits ;0x4100 ROM bank 0
  out   _SFR_IO_ADDR(PORTC), r1; Set PORTC to 0x00
    8200:	18 b8       	out	0x08, r1	; 8
  rjmp  MBC1_4M_CLK;
    8202:	1c ce       	rjmp	.-968    	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_0010:

00008240 <.MBC1_4M_0010>:

.section .MBC1_4M_0010,"ax",@progbits ;0x4120 ROM bank 0
  out   _SFR_IO_ADDR(PORTC), r1; Set PORTC to 0x00
    8240:	18 b8       	out	0x08, r1	; 8
  rjmp  MBC1_4M_CLK;
    8242:	fc cd       	rjmp	.-1032   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_0100:

00008280 <.MBC1_4M_0100>:

.section .MBC1_4M_0100,"ax",@progbits ;0x4140 ROM bank XX
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the stored MA14_18_21 value (r22)
    8280:	68 b9       	out	0x08, r22	; 8
  rjmp  MBC1_4M_CLK;
    8282:	dc cd       	rjmp	.-1096   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_0110:

000082c0 <.MBC1_4M_0110>:

.section .MBC1_4M_0110,"ax",@progbits ;0x4160 ROM bank XX
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the stored MA14_18_21 value (r22)
    82c0:	68 b9       	out	0x08, r22	; 8
  rjmp  MBC1_4M_CLK;
    82c2:	bc cd       	rjmp	.-1160   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_1000:

00008300 <.MBC1_4M_1000>:

.section .MBC1_4M_1000,"ax",@progbits ;0x4180 Reserved. Do nothing
  rjmp  MBC1_4M_CLK;
    8300:	9d cd       	rjmp	.-1222   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_1010:

00008340 <.MBC1_4M_1010>:

.section .MBC1_4M_1010,"ax",@progbits ;0x41A0 RAM read
  ; Do nothing, this is handled in hardware (OR gate)
  rjmp  MBC1_4M_CLK;
    8340:	7d cd       	rjmp	.-1286   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_1100:

00008380 <.MBC1_4M_1100>:

.section .MBC1_4M_1100,"ax",@progbits ;0x41C0 Reserved. Do nothing
  rjmp  MBC1_4M_CLK;
    8380:	5d cd       	rjmp	.-1350   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_1110:

000083c0 <.MBC1_4M_1110>:

.section .MBC1_4M_1110,"ax",@progbits ;0x41E0 Reserved. Do nothing
  rjmp  MBC1_4M_CLK;
    83c0:	3d cd       	rjmp	.-1414   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_0001:

00008220 <MBC1_4M_RAM_FLG_DIS-0x10>:

; ************************* WRITE JUMP TABLE (Read is hi)
.section .MBC1_4M_0001,"ax",@progbits ;0x4110 Ram enable
  nop; This many NOPS may be needed to as data isn't good until WR is asserted
    8220:	00 00       	nop
  nop;
    8222:	00 00       	nop
  in    r17, _SFR_IO_ADDR(PINB)
    8224:	13 b1       	in	r17, 0x03	; 3
  andi  r17, 0x1F ; Mask D0-4. I don't want to add this, but we'll see if MBC data is corrupted otherwise
    8226:	1f 71       	andi	r17, 0x1F	; 31
  cpi   r17, 0x0A; 0x0A is an enable command
    8228:	1a 30       	cpi	r17, 0x0A	; 10
  brne  MBC1_4M_RAM_FLG_DIS
    822a:	11 f4       	brne	.+4      	; 0x8230 <MBC1_4M_RAM_FLG_DIS>
  cbi   _SFR_IO_ADDR(PORTA), PA7;
    822c:	17 98       	cbi	0x02, 7	; 2
  rjmp  MBC1_4M_CLK
    822e:	06 ce       	rjmp	.-1012   	; 0x7e3c <MBC1_4M_CLK>

00008230 <MBC1_4M_RAM_FLG_DIS>:
MBC1_4M_RAM_FLG_DIS:
  sbi   _SFR_IO_ADDR(PORTA), PA7
    8230:	17 9a       	sbi	0x02, 7	; 2
  rjmp  MBC1_4M_CLK;
    8232:	04 ce       	rjmp	.-1016   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_0011:

00008260 <MBC1_4M_NZERO-0xe>:

.section .MBC1_4M_0011,"ax",@progbits ;0x4130 ROM bank numbers
  andi  r22, 0xE0;REG_MA14_18, MA19_21_MASK ; Mask only hi bits to ditch the old low bits
    8260:	60 7e       	andi	r22, 0xE0	; 224
  nop; Need a NOP here for DATA to be valid... without this, this is 13-16 cycles in, so it should be safe...
    8262:	00 00       	nop
  in    r17, _SFR_IO_ADDR(PINB);GB_DAT_REG, GB_DAT_R ;Read in PINB data for use in each write mode
    8264:	13 b1       	in	r17, 0x03	; 3
  andi  r17, 0x1F ; Mask D0-4. I don't want to add this, but we'll see if MBC data is corrupted otherwise
    8266:	1f 71       	andi	r17, 0x1F	; 31
  tst   r17
    8268:	11 23       	and	r17, r17
  brne  MBC1_4M_NZERO
    826a:	09 f4       	brne	.+2      	; 0x826e <MBC1_4M_NZERO>
  inc   r17
    826c:	13 95       	inc	r17

0000826e <MBC1_4M_NZERO>:
MBC1_4M_NZERO:
  or    r22, r17;REG_MA14_18, GB_DAT_REG
    826e:	61 2b       	or	r22, r17
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the MA mask value. Probably don't need to OUT this here for a WRITE command
    8270:	68 b9       	out	0x08, r22	; 8
  rjmp  MBC1_4M_CLK;
    8272:	e4 cd       	rjmp	.-1080   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_0101:

000082a0 <.MBC1_4M_0101>:

.section .MBC1_4M_0101,"ax",@progbits ;0x4150 RAM bank number
  in    r18, _SFR_IO_ADDR(PORTA) ;Prep for changing the RAM bank number
    82a0:	22 b1       	in	r18, 0x02	; 2
  andi  r18, 0xFC ; CLR the old bits
    82a2:	2c 7f       	andi	r18, 0xFC	; 252
  in    r17, _SFR_IO_ADDR(PINB);Read in PINB data
    82a4:	13 b1       	in	r17, 0x03	; 3
  andi  r17, 0x03; Mask the RAM bank number (in case of rubbish in)
    82a6:	13 70       	andi	r17, 0x03	; 3
  or    r18, r17 ; Put it together and whaddaya got?
    82a8:	21 2b       	or	r18, r17
  out   _SFR_IO_ADDR(PORTA), r18 
    82aa:	22 b9       	out	0x02, r18	; 2
  rjmp  MBC1_4M_CLK;
    82ac:	c7 cd       	rjmp	.-1138   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_0111:

000082e0 <.MBC1_4M_0111>:

.section .MBC1_4M_0111,"ax",@progbits ;0x4170 ROM/RAM mode select 
;*** Something I hadn't considered here, what if these bits should be translated across ROM and RAM when switching? ***
; This might be the way the chip operates, rather than discarding them when clearing before a mode switch. Should I even
; clear the old bits? Guess time will tell what I should do here
  in    r18, _SFR_IO_ADDR(PORTA); This many NOPS may be needed to as data isn't good until WR is asserted
    82e0:	22 b1       	in	r18, 0x02	; 2
  andi  r18, 0xFC; In preparation for mode switch, get rid of the RAM bank bits
    82e2:	2c 7f       	andi	r18, 0xFC	; 252
  sbic  _SFR_IO_ADDR(PINB), 0 ; Skip if Data bit 0 is set - we need a mode change
    82e4:	18 99       	sbic	0x03, 0	; 3
  rjmp  MBC1_4M_CLK; Stay in our own lane
    82e6:	aa cd       	rjmp	.-1196   	; 0x7e3c <MBC1_4M_CLK>
  sbr   r22, 5;REG_MA14_21, 5; Set bit 5, MA19
  sbic  _SFR_IO_ADDR(PORTA), 1
  sbr   r22, 6;REG_MA14_21, 6; Set bit 6, MA20
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER ;R_MA14_21, REG_MA14_21*/

  out   _SFR_IO_ADDR(PORTA), r18; Update the RAM bank bits before we switch modes
    82e8:	22 b9       	out	0x02, r18	; 2
  rjmp  MBC1_16M_CLK ; Mode switch jump!
    82ea:	94 cd       	rjmp	.-1240   	; 0x7e14 <MBC1_16M_CLK>

Disassembly of section .MBC1_4M_1001:

00008320 <.MBC1_4M_1001>:

.section .MBC1_4M_1001,"ax",@progbits ;0x4190 Reserved. Do nothing
  rjmp  MBC1_4M_CLK;
    8320:	8d cd       	rjmp	.-1254   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_1011:

00008360 <.MBC1_4M_1011>:

.section .MBC1_4M_1011,"ax",@progbits ;0x41B0 RAM write
  ; Do nothing, this is handled in hardware (OR gate)
  rjmp  MBC1_4M_CLK;
    8360:	6d cd       	rjmp	.-1318   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_1101:

000083a0 <.MBC1_4M_1101>:

.section .MBC1_4M_1101,"ax",@progbits ;0x41D0 Reserved. Do nothing
  rjmp  MBC1_4M_CLK;
    83a0:	4d cd       	rjmp	.-1382   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC1_4M_1111:

000083e0 <.MBC1_4M_1111>:

.section .MBC1_4M_1111,"ax",@progbits ;0x41F0 Reserved. Do nothing
  rjmp  MBC1_4M_CLK;
    83e0:	2d cd       	rjmp	.-1446   	; 0x7e3c <MBC1_4M_CLK>

Disassembly of section .MBC5_0000:

00008400 <.MBC5_0000>:
; **********************************************************************************
; ************* MBC5 MODE JUMP TABLE *********************************************** 8 cycles to JMP table
; **********************************************************************************
; ************************* READ JUMP TABLE (Read is low)
.section .MBC5_0000,"ax",@progbits ;0x4200
  out   _SFR_IO_ADDR(PORTC), r1; Set PORTC to 0x00
    8400:	18 b8       	out	0x08, r1	; 8
  sbrs  r25, 2; Check CLK pin that was read pre-jmp. If it's low, then we're in DSM
    8402:	92 ff       	sbrs	r25, 2
  ldi   ZH, r31_MBC5_DSM
    8404:	f4 e4       	ldi	r31, 0x44	; 68
  rjmp  MBC5_CLK;
    8406:	2f cd       	rjmp	.-1442   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_0010:

00008440 <.MBC5_0010>:

.section .MBC5_0010,"ax",@progbits ;0x4220 ROM bank 0
  out   _SFR_IO_ADDR(PORTC), r1; Set PORTC to 0x00
    8440:	18 b8       	out	0x08, r1	; 8
  sbrs  r25, 2; Check CLK pin that was read pre-jmp. If it's low, then we're in DSM
    8442:	92 ff       	sbrs	r25, 2
  ldi   ZH, r31_MBC5_DSM
    8444:	f4 e4       	ldi	r31, 0x44	; 68
  rjmp  MBC5_CLK;
    8446:	0f cd       	rjmp	.-1506   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_0100:

00008480 <.MBC5_0100>:

.section .MBC5_0100,"ax",@progbits ;0x4240 ROM bank XX
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the stored MA14_18_21 value (r22)
    8480:	68 b9       	out	0x08, r22	; 8
  sbrs  r25, 2; Check CLK pin that was read pre-jmp. If it's low, then we're in DSM
    8482:	92 ff       	sbrs	r25, 2
  ldi   ZH, r31_MBC5_DSM
    8484:	f4 e4       	ldi	r31, 0x44	; 68
  rjmp  MBC5_CLK;
    8486:	ef cc       	rjmp	.-1570   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_0110:

000084c0 <.MBC5_0110>:

.section .MBC5_0110,"ax",@progbits ;0x4260 ROM bank XX
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the stored MA14_18_21 value (r22)
    84c0:	68 b9       	out	0x08, r22	; 8
  sbrs  r25, 2; Check CLK pin that was read pre-jmp. If it's low, then we're in DSM
    84c2:	92 ff       	sbrs	r25, 2
  ldi   ZH, r31_MBC5_DSM
    84c4:	f4 e4       	ldi	r31, 0x44	; 68
  rjmp  MBC5_CLK;
    84c6:	cf cc       	rjmp	.-1634   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_1000:

00008500 <.MBC5_1000>:

.section .MBC5_1000,"ax",@progbits ;0x4280 Reserved. Do nothing
out   _SFR_IO_ADDR(PORTC), r1; Set PORTC to 0x00
    8500:	18 b8       	out	0x08, r1	; 8
sbrs  r25, 2; Check CLK pin that was read pre-jmp. If it's low, then we're in DSM
    8502:	92 ff       	sbrs	r25, 2
ldi   ZH, r31_MBC5_DSM
    8504:	f4 e4       	ldi	r31, 0x44	; 68
  rjmp  MBC5_CLK;
    8506:	af cc       	rjmp	.-1698   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_1010:

00008540 <.MBC5_1010>:

.section .MBC5_1010,"ax",@progbits ;0x42A0 RAM read
  ; Do nothing. RAM is handled in HW :)
out   _SFR_IO_ADDR(PORTC), r1; Set PORTC to 0x00
    8540:	18 b8       	out	0x08, r1	; 8
sbrs  r25, 2; Check CLK pin that was read pre-jmp. If it's low, then we're in DSM
    8542:	92 ff       	sbrs	r25, 2
ldi   ZH, r31_MBC5_DSM
    8544:	f4 e4       	ldi	r31, 0x44	; 68
  rjmp  MBC5_CLK;
    8546:	8f cc       	rjmp	.-1762   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_1100:

00008580 <.MBC5_1100>:

.section .MBC5_1100,"ax",@progbits ;0x42C0 Reserved. Do nothing
out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the stored MA14_18_21 value (r22)
    8580:	68 b9       	out	0x08, r22	; 8
sbrs  r25, 2; Check CLK pin that was read pre-jmp. If it's low, then we're in DSM
    8582:	92 ff       	sbrs	r25, 2
ldi   ZH, r31_MBC5_DSM
    8584:	f4 e4       	ldi	r31, 0x44	; 68
  rjmp  MBC5_CLK;
    8586:	6f cc       	rjmp	.-1826   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_1110:

000085c0 <.MBC5_1110>:

.section .MBC5_1110,"ax",@progbits ;0x42E0 Reserved. Do nothing
out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the stored MA14_18_21 value (r22)
    85c0:	68 b9       	out	0x08, r22	; 8
sbrs  r25, 2; Check CLK pin that was read pre-jmp. If it's low, then we're in DSM
    85c2:	92 ff       	sbrs	r25, 2
ldi   ZH, r31_MBC5_DSM
    85c4:	f4 e4       	ldi	r31, 0x44	; 68
  rjmp  MBC5_CLK;
    85c6:	4f cc       	rjmp	.-1890   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_0001:

00008420 <MBC5_0001>:

; ************************* WRITE JUMP TABLE (Read is hi)
.section .MBC5_0001,"ax",@progbits ;0x4210 Ram enable
MBC5_0001:
; Shouldn't beed an extra NOP like MBC3 because this mode already has an extra instruction before IJMP
  nop; This many NOPS may be needed to as data isn't good until WR is asserted
    8420:	00 00       	nop
  nop;
    8422:	00 00       	nop

  in    r17, _SFR_IO_ADDR(PINB)
    8424:	13 b1       	in	r17, 0x03	; 3
  cpi   r17, 0x0A; 0x0A is an enable command
    8426:	1a 30       	cpi	r17, 0x0A	; 10
  brne  MBC5_RAM_FLG_DIS
    8428:	11 f4       	brne	.+4      	; 0x842e <MBC5_RAM_FLG_DIS>
  cbi   _SFR_IO_ADDR(PORTA), PA7;
    842a:	17 98       	cbi	0x02, 7	; 2
  rjmp  MBC5_CLK
    842c:	1c cd       	rjmp	.-1480   	; 0x7e66 <MBC5_CLK>

0000842e <MBC5_RAM_FLG_DIS>:
MBC5_RAM_FLG_DIS:
  sbi   _SFR_IO_ADDR(PORTA), PA7
    842e:	17 9a       	sbi	0x02, 7	; 2
  rjmp  MBC5_CLK;
    8430:	1a cd       	rjmp	.-1484   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_0011:

00008460 <MBC5_0011>:
; 0x20-2F and 0x30-3F, instead of using a block address of 0x20-3F like in other MBC modes. The only 
; reason I am ignoring this is because I don't have 8MB of flash, and therefore should have absolutely
; no reason for anyone to access the 9th bit in the upper half of the address space! If they did, I 
; would need to connect ADDR12 to RUMBLE (and change this pin to be an input) and monitor it in this loop
MBC5_0011:
  nop
    8460:	00 00       	nop
  nop; Need a NOP here for DATA to be valid... without this, this is 13-16 cycles in, so it should be safe...
    8462:	00 00       	nop

  in    r22, _SFR_IO_ADDR(PINB); 8 lo bits of ROM address. Easy! Too bad you can't copy port to port
    8464:	63 b1       	in	r22, 0x03	; 3
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the MA mask value. Probably don't need to OUT this here for a WRITE command
    8466:	68 b9       	out	0x08, r22	; 8
  rjmp  MBC5_CLK;
    8468:	fe cc       	rjmp	.-1540   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_0101:

000084a0 <MBC5_0101>:

.section .MBC5_0101,"ax",@progbits ;0x4250 RAM bank number  - Rumble doesn't need to be masked anymore - rewired the prototype board.
MBC5_0101:
  in    r18, _SFR_IO_ADDR(PORTA) ;Prep for changing the RAM bank number
    84a0:	22 b1       	in	r18, 0x02	; 2
  andi  r18, 0xF4 ; CLR the old bits
    84a2:	24 7f       	andi	r18, 0xF4	; 244

  in    r17, _SFR_IO_ADDR(PINB);Read in PINB data
    84a4:	13 b1       	in	r17, 0x03	; 3
  andi  r17, 0x0B; Mask the RAM bank number (because we share a two bit value on the PORT)
    84a6:	1b 70       	andi	r17, 0x0B	; 11
  or    r18, r17 ; Put it together and whaddaya got?
    84a8:	21 2b       	or	r18, r17
  out   _SFR_IO_ADDR(PORTA), r18 
    84aa:	22 b9       	out	0x02, r18	; 2
  rjmp  MBC5_CLK;
    84ac:	dc cc       	rjmp	.-1608   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_0111:

000084e0 <.MBC5_0111>:

.section .MBC5_0111,"ax",@progbits ;0x4270 Not used in MBC5
  rjmp  MBC5_CLK;
    84e0:	c2 cc       	rjmp	.-1660   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_1001:

00008520 <.MBC5_1001>:

.section .MBC5_1001,"ax",@progbits ;0x4290 Reserved. Do nothing
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip if set
    8520:	4f 9b       	sbis	0x09, 7	; 9
  rjmp  MBC5_0001;
    8522:	7e cf       	rjmp	.-260    	; 0x8420 <MBC5_0001>

  rjmp  MBC5_CLK;
    8524:	a0 cc       	rjmp	.-1728   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_1011:

00008560 <.MBC5_1011>:

.section .MBC5_1011,"ax",@progbits ;0x42B0 RAM write
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip if set
    8560:	4f 9b       	sbis	0x09, 7	; 9
  rjmp  MBC5_0011;
    8562:	7e cf       	rjmp	.-260    	; 0x8460 <MBC5_0011>
  rjmp  MBC5_CLK;
    8564:	80 cc       	rjmp	.-1792   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_1101:

000085a0 <.MBC5_1101>:

.section .MBC5_1101,"ax",@progbits ;0x42D0 Reserved. Do nothing
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip if cleared
    85a0:	4f 9b       	sbis	0x09, 7	; 9
  rjmp  MBC5_0101;
    85a2:	7e cf       	rjmp	.-260    	; 0x84a0 <MBC5_0101>
  rjmp  MBC5_CLK;
    85a4:	60 cc       	rjmp	.-1856   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC5_1111:

000085e0 <.MBC5_1111>:

.section .MBC5_1111,"ax",@progbits ;0x42F0 Reserved. Do nothing
  rjmp  MBC5_CLK;
    85e0:	42 cc       	rjmp	.-1916   	; 0x7e66 <MBC5_CLK>

Disassembly of section .MBC_BASE:

00007e00 <MBC_mode_MBC1_16M8k>:

.section .MBC_BASE,"ax",@progbits ;0x3F00
; **********************************************************************************
MBC_mode_MBC1_16M8k:
  ; Set up the external interrupt on PD2 for the interrupt
  ldi   r16, 0x03; set rising edge mask for EICRA
    7e00:	03 e0       	ldi	r16, 0x03	; 3
  sts   EICRA, r16; Set EICRA
    7e02:	00 93 69 00 	sts	0x0069, r16
  ldi   r16, 0x01
    7e06:	01 e0       	ldi	r16, 0x01	; 1
  out   _SFR_IO_ADDR(EIMSK), r16; set EIMSK to enable the rising edge INT0 interrupt
    7e08:	0d bb       	out	0x1d, r16	; 29
  clr   r0; Make r0 0x01 for use clearing interrupt flags later - r1 is always 0
    7e0a:	00 24       	eor	r0, r0
  inc   r0; r0 = 0x01
    7e0c:	03 94       	inc	r0
  clr   r1; Make sure this is zero, and leave it at zero!
    7e0e:	11 24       	eor	r1, r1

  ldi   r22, 0x01; MA14-18 must start as 0x01 to meet the MBC1 read spec (can't be bank 0)
    7e10:	61 e0       	ldi	r22, 0x01	; 1
  ldi   ZH, r31_MBC1_16M; Set high byte for MBC mode for IJMP call to 1 (can't be 0)
    7e12:	f0 e4       	ldi	r31, 0x40	; 64

00007e14 <MBC1_16M_CLK>:
  
MBC1_16M_CLK:; Wait for a CLK pulse
  sbis  _SFR_IO_ADDR(EIFR), INT0; See if the interrupt flag is set in EIFR, if so, continue, else loop
    7e14:	e0 9b       	sbis	0x1c, 0	; 28
  rjmp  MBC1_16M_CLK
    7e16:	fe cf       	rjmp	.-4      	; 0x7e14 <MBC1_16M_CLK>
  
  ; These NOPs are required because ADDR15 is set AFTER all of the other address bits. Min 5 cycles after the rjmp above
  out   _SFR_IO_ADDR(EIFR), r0; EIFR, clear the interrupt flag
    7e18:	0c ba       	out	0x1c, r0	; 28
	...
  nop 
  nop
  nop
  nop

  in    ZL, _SFR_IO_ADDR(PIND)
    7e22:	e9 b1       	in	r30, 0x09	; 9
  andi  ZL, 0xF0
    7e24:	e0 7f       	andi	r30, 0xF0	; 240
  ijmp
    7e26:	09 94       	ijmp

00007e28 <MBC_mode_MBC1_4M32k>:


; **************************************
MBC_mode_MBC1_4M32k:
  ; Set up the external interrupt on PD2 for the interrupt
  ldi   r16, 0x03; set rising edge mask for EICRA
    7e28:	03 e0       	ldi	r16, 0x03	; 3
  sts   EICRA, r16; Set EICRA
    7e2a:	00 93 69 00 	sts	0x0069, r16
  ldi   r16, 0x01
    7e2e:	01 e0       	ldi	r16, 0x01	; 1
  out   _SFR_IO_ADDR(EIMSK), r16; set EIMSK to enable the rising edge INT0 interrupt
    7e30:	0d bb       	out	0x1d, r16	; 29
  clr   r0; Make r0 0x01 for use clearing interrupt flags later - r1 is always 0
    7e32:	00 24       	eor	r0, r0
  inc   r0; r0 = 0x01
    7e34:	03 94       	inc	r0
  clr   r1; Make sure this is zero, and leave it at zero!
    7e36:	11 24       	eor	r1, r1

  ldi   r22, 0x01; MA14-18 must start as 0x01 to meet the MBC1 read spec (can't be bank 0)
    7e38:	61 e0       	ldi	r22, 0x01	; 1
  ldi   ZH, r31_MBC1_4M; Set high byte for MBC mode for IJMP call to 1 (can't be 0)
    7e3a:	f1 e4       	ldi	r31, 0x41	; 65

00007e3c <MBC1_4M_CLK>:
  
MBC1_4M_CLK:; Wait for a CLK pulse
  sbis  _SFR_IO_ADDR(EIFR), INT0; See if the interrupt flag is set in EIFR, if so, continue, else loop
    7e3c:	e0 9b       	sbis	0x1c, 0	; 28
  rjmp  MBC1_4M_CLK
    7e3e:	fe cf       	rjmp	.-4      	; 0x7e3c <MBC1_4M_CLK>
  
  ; These NOPs are required because ADDR15 is set AFTER all of the other address bits. Min 5 cycles after the rjmp above
  out   _SFR_IO_ADDR(EIFR), r0; EIFR, clear the interrupt flag
    7e40:	0c ba       	out	0x1c, r0	; 28
	...
  nop
  nop
  nop
  nop

  in    ZL, _SFR_IO_ADDR(PIND)
    7e4a:	e9 b1       	in	r30, 0x09	; 9
  andi  ZL, 0xF0
    7e4c:	e0 7f       	andi	r30, 0xF0	; 240
  ijmp
    7e4e:	09 94       	ijmp

00007e50 <MBC_mode_MBC5>:


; **********************************************************************************
MBC_mode_MBC5:
  ; Set up the external interrupt on PD2 for the interrupt
  ldi   r16, 0x03; set rising edge mask for EICRA
    7e50:	03 e0       	ldi	r16, 0x03	; 3
  sts   EICRA, r16; Set EICRA
    7e52:	00 93 69 00 	sts	0x0069, r16
  ldi   r16, 0x01
    7e56:	01 e0       	ldi	r16, 0x01	; 1
  out   _SFR_IO_ADDR(EIMSK), r16; set EIMSK to enable the rising edge INT0 interrupt
    7e58:	0d bb       	out	0x1d, r16	; 29
  clr   r0; Make r0 0x01 for use clearing interrupt flags later - r1 is always 0
    7e5a:	00 24       	eor	r0, r0
  inc   r0; r0 = 0x01
    7e5c:	03 94       	inc	r0
  clr   r1; Make sure this is zero, and leave it at zero!
    7e5e:	11 24       	eor	r1, r1

  ldi   r22, 0x01; Other code looks like it preloads this to bank 1, even though 0x00 is a valid bank for MBC5
    7e60:	61 e0       	ldi	r22, 0x01	; 1
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the stored MA14_18_21 value (r22)
    7e62:	68 b9       	out	0x08, r22	; 8
  ldi   r31, r31_MBC5; Set high byte for MBC mode for IJMP call to 1 (can't be 0)
    7e64:	f2 e4       	ldi	r31, 0x42	; 66

00007e66 <MBC5_CLK>:

MBC5_CLK:; Wait for a CLK pulse
  sbis  _SFR_IO_ADDR(EIFR), INT0; See if the interrupt flag is set in EIFR, if so, continue, else loop
    7e66:	e0 9b       	sbis	0x1c, 0	; 28
  rjmp  MBC5_CLK
    7e68:	fe cf       	rjmp	.-4      	; 0x7e66 <MBC5_CLK>
  
  ; These NOPs are required because ADDR15 is set AFTER all of the other address bits. Min 5 cycles after the rjmp above
  out   _SFR_IO_ADDR(EIFR), r0; EIFR, clear the interrupt flag
    7e6a:	0c ba       	out	0x1c, r0	; 28
  in    ZL, _SFR_IO_ADDR(PIND)
    7e6c:	e9 b1       	in	r30, 0x09	; 9
  andi  ZL, 0xF0
    7e6e:	e0 7f       	andi	r30, 0xF0	; 240
  in    r25, _SFR_IO_ADDR(PIND) ; Take this in to check CLK during READ cycles to go into double speed mode...
    7e70:	99 b1       	in	r25, 0x09	; 9
  ijmp
    7e72:	09 94       	ijmp

00007e74 <MBC5_DSM_CLK>:
 

MBC5_DSM_CLK:; Wait for a CLK pulse
  sbis  _SFR_IO_ADDR(EIFR), INT0; See if the interrupt flag is set in EIFR, if so, continue, else loop
    7e74:	e0 9b       	sbis	0x1c, 0	; 28
  rjmp  MBC5_DSM_CLK
    7e76:	fe cf       	rjmp	.-4      	; 0x7e74 <MBC5_DSM_CLK>
  out   _SFR_IO_ADDR(EIFR), r0; EIFR, clear the interrupt flag
    7e78:	0c ba       	out	0x1c, r0	; 28
  
  ; ADDR15 is set AFTER all of the other address bits. Guess 3 cycles in DSM - will have to test
  in    ZL, _SFR_IO_ADDR(PIND)
    7e7a:	e9 b1       	in	r30, 0x09	; 9
  andi  ZL, 0xF0 ; Would be nice to do away with this. But CLK is always going to be hi, UART lines are probably pulled up too as will WE. It may be better to invert these lines in HW instead...
    7e7c:	e0 7f       	andi	r30, 0xF0	; 240
  ijmp
    7e7e:	09 94       	ijmp

00007e80 <MBC_mode_MBC3>:


; **********************************************************************************
MBC_mode_MBC3:
  ; Set up the external interrupt on PD2 for the interrupt
  ldi   r16, 0x03; set rising edge mask for EICRA
    7e80:	03 e0       	ldi	r16, 0x03	; 3
  sts   EICRA, r16; Set EICRA
    7e82:	00 93 69 00 	sts	0x0069, r16
  ldi   r16, 0x01
    7e86:	01 e0       	ldi	r16, 0x01	; 1
  out   _SFR_IO_ADDR(EIMSK), r16; set EIMSK to enable the rising edge INT0 interrupt
    7e88:	0d bb       	out	0x1d, r16	; 29
  clr   r0; Make r0 0x01 for use clearing interrupt flags later - r1 is always 0
    7e8a:	00 24       	eor	r0, r0
  inc   r0; r0 = 0x01
    7e8c:	03 94       	inc	r0
  clr   r1; Make sure this is zero, and leave it at zero!
    7e8e:	11 24       	eor	r1, r1
  clr   r2; Clear r2 so that 1's complement will be 0xFF
    7e90:	22 24       	eor	r2, r2
  com   r2; set r2 as 0xFF for changing DDR for outputting RTC values
    7e92:	20 94       	com	r2
  clr   r3
    7e94:	33 24       	eor	r3, r3
  inc   r3
    7e96:	33 94       	inc	r3
  inc   r3; set r3=2 (0x02) to clear TIFR1 OCF1A flag
    7e98:	33 94       	inc	r3

  ; Set up timer1 to overflow ~1 sec
  ldi   r16, 0x62 ; This is high byte for timer 1. Total value of H and L register is 25200 (25804800 / 1024 = 25200 counts/sec)
    7e9a:	02 e6       	ldi	r16, 0x62	; 98
  sts   OCR1AH, r16
    7e9c:	00 93 89 00 	sts	0x0089, r16
  ldi   r16, 0x70 ; low byte for output compare
    7ea0:	00 e7       	ldi	r16, 0x70	; 112
  sts   OCR1AL, r16
    7ea2:	00 93 88 00 	sts	0x0088, r16
  ldi   r16, (1 << OCIE1A);
    7ea6:	02 e0       	ldi	r16, 0x02	; 2
  sts   TIMSK1, r16
    7ea8:	00 93 6f 00 	sts	0x006F, r16
  ldi   r16, (1 << WGM12) | (1 << CS12) | (1 << CS10) 
    7eac:	0d e0       	ldi	r16, 0x0D	; 13
  sts   TCCR1B, r16 ; CTC mode, OCR1A is TOP, prescaler=1024
    7eae:	00 93 81 00 	sts	0x0081, r16

  ldi   r22, 0x01; MA14-18 must start as 0x01 to meet the MBC1 read spec (can't be bank 0)
    7eb2:	61 e0       	ldi	r22, 0x01	; 1
  ldi   ZH, r31_MBC3; Set high byte for MBC mode for IJMP call to 1 (can't be 0)
    7eb4:	f3 e4       	ldi	r31, 0x43	; 67
; jump table.)

  ;r28 bit 7 will be used for RAM enable in MBC3 because of the need to disable RAM when reading/writing RTC registers
  ; Hmmm... might need to set up some timers too to act as a fake RTC
  ;r28 low nibble will be the RAM/RTC bank number. Need to save this for later when using INTRAMEN. 
  ldi   YL, 0x88 ; Sets bank 0 by default. The C setup code already pulled SRAM_CS hi
    7eb6:	c8 e8       	ldi	r28, 0x88	; 136
  // Because I don't use RAM in MBC modes (generally), I will use RAM for RTC values so I can use an indirect load instruction (from Y register)
  ldi   YH, 0x01; SRAM starts at 0x0100
    7eb8:	d1 e0       	ldi	r29, 0x01	; 1
  ; r20   hours
  ; r21   day counter lo8
  ; r23:0 day counter hi1
  ; r23:6 start (0) /stop (1)
  ; r23:7 day counter carry
  ldi   r18, 0 ; Need to think how I want to set default values for the RTC here
    7eba:	20 e0       	ldi	r18, 0x00	; 0
  ldi   r19, 30
    7ebc:	3e e1       	ldi	r19, 0x1E	; 30
  ldi   r20, 9
    7ebe:	49 e0       	ldi	r20, 0x09	; 9
  ldi   r21, 0
    7ec0:	50 e0       	ldi	r21, 0x00	; 0
  ldi   r23, 0
    7ec2:	70 e0       	ldi	r23, 0x00	; 0
  sts   0x188, r18
    7ec4:	20 93 88 01 	sts	0x0188, r18
  sts   0x189, r19
    7ec8:	30 93 89 01 	sts	0x0189, r19
  sts   0x18A, r20
    7ecc:	40 93 8a 01 	sts	0x018A, r20
  sts   0x18B, r21
    7ed0:	50 93 8b 01 	sts	0x018B, r21
  sts   0x18C, r23
    7ed4:	70 93 8c 01 	sts	0x018C, r23

00007ed8 <MBC3_CLK>:

MBC3_CLK:; Wait for a CLK pulse
  sbis  _SFR_IO_ADDR(EIFR), INT0; See if the interrupt flag is set in EIFR, if so, continue, else loop
    7ed8:	e0 9b       	sbis	0x1c, 0	; 28
  rjmp  MBC3_CLK
    7eda:	fe cf       	rjmp	.-4      	; 0x7ed8 <MBC3_CLK>

/*  ; These NOPs are required because ADDR15 is set AFTER all of the other address bits. Min 5 cycles after the rjmp above*/
  ; For this revision, data is (mostly) good to read after OUT. Replace the 5 NOP cycles 
  out   _SFR_IO_ADDR(EIFR), r0; EIFR, clear the interrupt flag
    7edc:	0c ba       	out	0x1c, r0	; 28
  in    ZL, _SFR_IO_ADDR(PIND)
    7ede:	e9 b1       	in	r30, 0x09	; 9
  andi  ZL, 0xF0
    7ee0:	e0 7f       	andi	r30, 0xF0	; 240
  ijmp
    7ee2:	09 94       	ijmp

00007ee4 <MBC_mode_MBC2>:
 

; **********************************************************************************
MBC_mode_MBC2:
  ; Set up the external interrupt on PD2 for the interrupt
  ldi   r16, 0x03; set rising edge mask for EICRA
    7ee4:	03 e0       	ldi	r16, 0x03	; 3
  sts   EICRA, r16; Set EICRA
    7ee6:	00 93 69 00 	sts	0x0069, r16
  ldi   r16, 0x01
    7eea:	01 e0       	ldi	r16, 0x01	; 1
  out   _SFR_IO_ADDR(EIMSK), r16; set EIMSK to enable the rising edge INT0 interrupt
    7eec:	0d bb       	out	0x1d, r16	; 29
  clr   r0; Make r0 0x01 for use clearing interrupt flags later - r1 is always 0
    7eee:	00 24       	eor	r0, r0
  inc   r0; r0 = 0x01
    7ef0:	03 94       	inc	r0
  clr   r1; Make sure this is zero, and leave it at zero!
    7ef2:	11 24       	eor	r1, r1

  ldi   r22, 0x01; MA14-17 must start as 0x01 to meet the MBC2 read spec (can't be bank 0)
    7ef4:	61 e0       	ldi	r22, 0x01	; 1
  ldi   ZH, r31_MBC2; Set high byte for MBC mode for IJMP call to 1 (can't be 0)
    7ef6:	f5 e4       	ldi	r31, 0x45	; 69

00007ef8 <MBC2_CLK>:

MBC2_CLK:; Wait for a CLK pulse
  sbis  _SFR_IO_ADDR(EIFR), INT0; See if the interrupt flag is set in EIFR, if so, continue, else loop
    7ef8:	e0 9b       	sbis	0x1c, 0	; 28
  rjmp  MBC2_CLK
    7efa:	fe cf       	rjmp	.-4      	; 0x7ef8 <MBC2_CLK>
  
  ; These NOPs are required because ADDR15 is set AFTER all of the other address bits. Min 5 cycles after the rjmp above
  out   _SFR_IO_ADDR(EIFR), r0; EIFR, clear the interrupt flag
    7efc:	0c ba       	out	0x1c, r0	; 28
  in    ZL, _SFR_IO_ADDR(PIND)
    7efe:	e9 b1       	in	r30, 0x09	; 9
  andi  ZL, 0xD0  ; NOTE: This mask is different to the other MBC modes as MBC2 does not have A13 connected
    7f00:	e0 7d       	andi	r30, 0xD0	; 208
                  ; Because of this difference, the jump table is half the size (take out A13=1!)
  ijmp
    7f02:	09 94       	ijmp

Disassembly of section .MBC3_0000:

00008600 <MBC3_0000>:
; ************* MBC3 MODE JUMP TABLE ***********************************************
; **********************************************************************************
; ************************* READ JUMP TABLE (Read is low)
.section .MBC3_0000,"ax",@progbits ;0x4300 ROM bank 0
MBC3_0000:
  out   _SFR_IO_ADDR(PORTC), r1; Set PORTC to 0x00
    8600:	18 b8       	out	0x08, r1	; 8

  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8602:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8604:	69 cc       	rjmp	.-1838   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8606:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8608:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    860a:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_0000_OUT              ; branch if not
    860c:	10 f0       	brcs	.+4      	; 0x8612 <MBC3_0000_OUT>
  inc   r19                        ; increment minutes
    860e:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8610:	22 27       	eor	r18, r18

00008612 <MBC3_0000_OUT>:
MBC3_0000_OUT:
  rjmp  MBC3_CLK;
    8612:	62 cc       	rjmp	.-1852   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_0010:

00008640 <MBC3_0010>:

.section .MBC3_0010,"ax",@progbits ;0x4320 ROM bank 0
MBC3_0010:
  out   _SFR_IO_ADDR(PORTC), r1; Set PORTC to 0x00
    8640:	18 b8       	out	0x08, r1	; 8

  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8642:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8644:	49 cc       	rjmp	.-1902   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8646:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8648:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    864a:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_0010_OUT              ; branch if not
    864c:	10 f0       	brcs	.+4      	; 0x8652 <MBC3_0010_OUT>
  inc   r19                        ; increment minutes
    864e:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8650:	22 27       	eor	r18, r18

00008652 <MBC3_0010_OUT>:
MBC3_0010_OUT:
  rjmp  MBC3_CLK;
    8652:	42 cc       	rjmp	.-1916   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_0100:

00008680 <MBC3_0100>:

.section .MBC3_0100,"ax",@progbits ;0x4340 ROM bank XX
MBC3_0100:
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the stored MA14_18_21 value (r22)
    8680:	68 b9       	out	0x08, r22	; 8

  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8682:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8684:	29 cc       	rjmp	.-1966   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8686:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8688:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    868a:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_0100_OUT              ; branch if not
    868c:	10 f0       	brcs	.+4      	; 0x8692 <MBC3_0100_OUT>
  inc   r19                        ; increment minutes
    868e:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8690:	22 27       	eor	r18, r18

00008692 <MBC3_0100_OUT>:
MBC3_0100_OUT:
  rjmp  MBC3_CLK;
    8692:	22 cc       	rjmp	.-1980   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_0110:

000086c0 <MBC3_0110>:

.section .MBC3_0110,"ax",@progbits ;0x4360 ROM bank XX
MBC3_0110:
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the stored MA14_18_21 value (r22)
    86c0:	68 b9       	out	0x08, r22	; 8
  
  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    86c2:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    86c4:	09 cc       	rjmp	.-2030   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    86c6:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    86c8:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    86ca:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_0110_OUT              ; branch if not
    86cc:	10 f0       	brcs	.+4      	; 0x86d2 <MBC3_0110_OUT>
  inc   r19                        ; increment minutes
    86ce:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    86d0:	22 27       	eor	r18, r18

000086d2 <MBC3_0110_OUT>:
MBC3_0110_OUT:
  rjmp  MBC3_CLK;
    86d2:	02 cc       	rjmp	.-2044   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_1000:

00008700 <MBC3_RTC_END-0x1a>:

.section .MBC3_1000,"ax",@progbits ;0x4380 Reserved. Do nothing
/*sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip is set
rjmp  MBC3_0000 ; ROM bank 0*/ ;This mode is reserved. It shouldn't care if we change things
out   _SFR_IO_ADDR(PORTC), r1; Set PORTC to 0x00
    8700:	18 b8       	out	0x08, r1	; 8

  ; Probably have about 12-13 cycles to do RTC updates where out is the only instruction, 9-10 where RJMPS occur (by my raw count :S)
  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8702:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8704:	e9 cb       	rjmp	.-2094   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8706:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8708:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    870a:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_RTC_END              ; branch if not
    870c:	30 f0       	brcs	.+12     	; 0x871a <MBC3_RTC_END>
  inc   r19                        ; increment minutes
    870e:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8710:	22 27       	eor	r18, r18
  cpi   r19, 60                    ; is minutes = 60
    8712:	3c 33       	cpi	r19, 0x3C	; 60
  brlo  MBC3_RTC_END              ; branch if not
    8714:	10 f0       	brcs	.+4      	; 0x871a <MBC3_RTC_END>
  inc   r20                       ; increment hours
    8716:	43 95       	inc	r20
  clr   r19                        ; clear minutes ; bah, this is 12 cycles here, and I haven't done a day check yet... I'll have to break it up unfortunately
    8718:	33 27       	eor	r19, r19

0000871a <MBC3_RTC_END>:
MBC3_RTC_END:
  rjmp  MBC3_CLK;
    871a:	de cb       	rjmp	.-2116   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_1010:

00008740 <MBC3_RTC_STUFF-0x4>:
.section .MBC3_1010,"ax",@progbits ;0x43A0 RAM/RTC read
;sbic  _SFR_IO_ADDR(PIND), 7; Check A15, skip is cleared - by combining these sections, I save 2 cycles for read
;rjmp  MBC3_RTC_STUFF ; ROM bank 0 ; This might cause us problems. Any chance we can swap it with RAM/RTC read?
;out   _SFR_IO_ADDR(PORTC), r1; Set PORTC to 0x00
;rjmp  MBC3_CLK;
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip if set - by combining these sections, I save 1 cycle for read
    8740:	4f 9b       	sbis	0x09, 7	; 9
rjmp  MBC3_0010
    8742:	7e cf       	rjmp	.-260    	; 0x8640 <MBC3_0010>

00008744 <MBC3_RTC_STUFF>:

MBC3_RTC_STUFF:
  ; RAM is enabled in hardware. Only RTC code needs be here
  ; 10th (13th) cycle is next line?
; This loop may be too slow for a read cycle. Not sure if I can do this
  out   _SFR_IO_ADDR(PORTB), r7 ; r7 will be the temporary register to store RTC values to be pushed out 
    8744:	75 b8       	out	0x05, r7	; 5
  cpi   YL, 0x88; If r28 is >0x88, RTC is enabled and bank 8-C are selected. Push out an RTC value
    8746:	c8 38       	cpi	r28, 0x88	; 136
  brlo  MBC3_NOT_RTC_RD
    8748:	28 f0       	brcs	.+10     	; 0x8754 <MBC3_NOT_RTC_RD>
  ; DDRB output would be hard though. How do I make them an input again without stuffing the timing?
  out   _SFR_IO_ADDR(DDRB), r2 ;-> pre-load r2 with 0xFF to make all outputs
    874a:	24 b8       	out	0x04, r2	; 4
	...

00008754 <MBC3_NOT_RTC_RD>:
  nop
  nop
  nop
;  nop ; might fit an extra one in. See if the RTC fails first,I think it would fail because I set the output too late first though
MBC3_NOT_RTC_RD:
  out   _SFR_IO_ADDR(DDRB), r1 ; Revert or leave PINB as inputs
    8754:	14 b8       	out	0x04, r1	; 4
  out   _SFR_IO_ADDR(PORTB), r1; Make 0 again, disable all pullups
    8756:	15 b8       	out	0x05, r1	; 5
  rjmp  MBC3_CLK;
    8758:	bf cb       	rjmp	.-2178   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_1100:

00008780 <MBC3_RTC_END2-0x1a>:

.section .MBC3_1100,"ax",@progbits ;0x43C0 Reserved. Do nothing
/*sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip is set
rjmp  MBC3_0100 ; ROM bank XX*/ ;This mode is reserved. It shouldn't care if we change things
out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the stored MA14_18_21 value (r22)
    8780:	68 b9       	out	0x08, r22	; 8

; Probably have about 12-13 cycles to do RTC updates where out is the only instruction, 9-10 where RJMPS occur (by my raw count :S)
  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    8782:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    8784:	a9 cb       	rjmp	.-2222   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    8786:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    8788:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    878a:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_RTC_END2             ; branch if not
    878c:	30 f0       	brcs	.+12     	; 0x879a <MBC3_RTC_END2>
  inc   r19                        ; increment minutes
    878e:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    8790:	22 27       	eor	r18, r18
  cpi   r19, 60                    ; is minutes = 60
    8792:	3c 33       	cpi	r19, 0x3C	; 60
  brlo  MBC3_RTC_END2             ; branch if not
    8794:	10 f0       	brcs	.+4      	; 0x879a <MBC3_RTC_END2>
  inc   r20                       ; increment hours
    8796:	43 95       	inc	r20
  clr   r19                        ; clear minutes ; bah, this is 12 cycles here, and I haven't done a day check yet... I'll have to break it up unfortunately
    8798:	33 27       	eor	r19, r19

0000879a <MBC3_RTC_END2>:
MBC3_RTC_END2:
  rjmp  MBC3_CLK;
    879a:	9e cb       	rjmp	.-2244   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_1110:

000087c0 <MBC3_RTC_END3-0x1a>:

.section .MBC3_1110,"ax",@progbits ;0x43E0 Reserved. Do nothing
/*sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip is set
rjmp  MBC3_0110 ; ROM bank XX*/ ;This mode is reserved. It shouldn't care if we change things
out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the stored MA14_18_21 value (r22)
    87c0:	68 b9       	out	0x08, r22	; 8

; Probably have about 12-13 cycles to do RTC updates where out is the only instruction, 9-10 where RJMPS occur (by my raw count :S)
  sbis  _SFR_IO_ADDR(TIFR1), OCF1A; is timer overflow set
    87c2:	b1 9b       	sbis	0x16, 1	; 22
  rjmp  MBC3_CLK                  ; branch if not
    87c4:	89 cb       	rjmp	.-2286   	; 0x7ed8 <MBC3_CLK>
  inc   r18                        ; increment seconds
    87c6:	23 95       	inc	r18
  out   _SFR_IO_ADDR(TIFR1), r3   ; clear flag
    87c8:	36 ba       	out	0x16, r3	; 22
  cpi   r18, 60                    ; is seconds = 60
    87ca:	2c 33       	cpi	r18, 0x3C	; 60
  brlo  MBC3_RTC_END3              ; branch if not
    87cc:	30 f0       	brcs	.+12     	; 0x87da <MBC3_RTC_END3>
  inc   r19                        ; increment minutes
    87ce:	33 95       	inc	r19
  clr   r18                        ; clear seconds
    87d0:	22 27       	eor	r18, r18
  cpi   r19, 60                    ; is minutes = 60
    87d2:	3c 33       	cpi	r19, 0x3C	; 60
  brlo  MBC3_RTC_END3              ; branch if not
    87d4:	10 f0       	brcs	.+4      	; 0x87da <MBC3_RTC_END3>
  inc   r20                       ; increment hours
    87d6:	43 95       	inc	r20
  clr   r19                        ; clear minutes ; bah, this is 12 cycles here, and I haven't done a day check yet... I'll have to break it up unfortunately
    87d8:	33 27       	eor	r19, r19

000087da <MBC3_RTC_END3>:
MBC3_RTC_END3:
  rjmp  MBC3_CLK;
    87da:	7e cb       	rjmp	.-2308   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_0001:

00008620 <MBC3_0001>:
MBC3_0001:
; Replacing 3 nops here with a hairbrained work around to load r7 with correct RTC value. Force Y to be enabled because code will fix it anyway!
;nop
;  nop
;  nop
  sbr   YL, 7; pretends RAM is enabled, even if it's not because it'll be fixed below!
    8620:	c7 60       	ori	r28, 0x07	; 7
  ld    r7, Y
    8622:	78 80       	ld	r7, Y

  in    r17, _SFR_IO_ADDR(PINB) ; No need to mask in MBC3 mode as it has D0-7 inputs
    8624:	13 b1       	in	r17, 0x03	; 3
  cpi   r17, 0x0A; 0x0A is an enable command
    8626:	1a 30       	cpi	r17, 0x0A	; 10
  brne  MBC3_RAM_FLG_DIS
    8628:	11 f4       	brne	.+4      	; 0x862e <MBC3_RAM_FLG_DIS>
;  sbr   YL, 7; Enable RAM/RTC
  cbi   _SFR_IO_ADDR(PORTA), PA7;
    862a:	17 98       	cbi	0x02, 7	; 2
  rjmp  MBC3_CLK
    862c:	55 cc       	rjmp	.-1878   	; 0x7ed8 <MBC3_CLK>

0000862e <MBC3_RAM_FLG_DIS>:
MBC3_RAM_FLG_DIS:
  cbr   YL, 7; Disable RTC
    862e:	c8 7f       	andi	r28, 0xF8	; 248
  sbi   _SFR_IO_ADDR(PORTA), PA7; Disable RAM
    8630:	17 9a       	sbi	0x02, 7	; 2
  rjmp  MBC3_CLK;
    8632:	52 cc       	rjmp	.-1884   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_0011:

00008660 <MBC3_0011>:

.section .MBC3_0011,"ax",@progbits ;0x4330 ROM bank numbers
MBC3_0011:
  nop;
    8660:	00 00       	nop
  nop; Need a NOP here for DATA to be valid... without this, this is 13-16 cycles in, so it should be safe...
    8662:	00 00       	nop
nop
    8664:	00 00       	nop
  in    r22, _SFR_IO_ADDR(PINB); We can read r22 directly in MBC3 mode because there are no other hi ROM bits to worry about
    8666:	63 b1       	in	r22, 0x03	; 3
  andi  r22, 0x7F ; Mask D0-6. I don't want to add this, but I haven't tested if MBC data is corrupted otherwise
    8668:	6f 77       	andi	r22, 0x7F	; 127
  tst   r22
    866a:	66 23       	and	r22, r22
  brne  MBC3_NZERO
    866c:	09 f4       	brne	.+2      	; 0x8670 <MBC3_NZERO>
  inc   r22; MBC3 still doesn't put bank 0 at location 1.
    866e:	63 95       	inc	r22

00008670 <MBC3_NZERO>:
MBC3_NZERO:
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the MA mask value. Probably don't need to OUT this here for a WRITE command
    8670:	68 b9       	out	0x08, r22	; 8
  rjmp  MBC3_CLK;
    8672:	32 cc       	rjmp	.-1948   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_0101:

000086a0 <MBC3_0101>:

.section .MBC3_0101,"ax",@progbits ;0x4350 RAM/RTC bank number
MBC3_0101:
  in    r24, _SFR_IO_ADDR(PORTA) ;Prep for changing the RAM bank number
    86a0:	82 b1       	in	r24, 0x02	; 2
  andi  r24, 0xFC ; CLR the old bits on the PORT 
    86a2:	8c 7f       	andi	r24, 0xFC	; 252
nop
    86a4:	00 00       	nop
  in    r17, _SFR_IO_ADDR(PINB);Read in PINB data
    86a6:	13 b1       	in	r17, 0x03	; 3
  andi  YL, 0x80; Clear the old register value, except for RTC enable/disable
    86a8:	c0 78       	andi	r28, 0x80	; 128
  or    YL, r17; Save the bank number for later - Need this to stop READ and WRITE commands from reading RTC values when physical RAM is mapped
    86aa:	c1 2b       	or	r28, r17
  
  cpi   r17, 0x04 ; Valid physical RAM banks are 0-3. Anything higher disables physical RAM
    86ac:	14 30       	cpi	r17, 0x04	; 4
  brsh  MBC3_RTC_REGS; Branch if same or higher
    86ae:	28 f4       	brcc	.+10     	; 0x86ba <MBC3_RTC_REGS>
  ; It's a physical bank here 
  or    r24, r17 ; Put the new value into PORTA temp value
    86b0:	81 2b       	or	r24, r17
  out   _SFR_IO_ADDR(PORTA), r24 ; Push PORTA back out
    86b2:	82 b9       	out	0x02, r24	; 2
  sbrc  YL, 7; If bit 7 in r28 is cleared, then RAM isn't enabled. Don't enable RAM!
    86b4:	c7 fd       	sbrc	r28, 7
  cbi   _SFR_IO_ADDR(PORTA), PA7;
    86b6:	17 98       	cbi	0x02, 7	; 2
  rjmp  MBC3_CLK;
    86b8:	0f cc       	rjmp	.-2018   	; 0x7ed8 <MBC3_CLK>

000086ba <MBC3_RTC_REGS>:
MBC3_RTC_REGS:
  sbi   _SFR_IO_ADDR(PORTA), PA7; Disable physical RAM
    86ba:	17 9a       	sbi	0x02, 7	; 2
  ld    r7, Y ; Load r7 with the RTC value pointed to by the Y register. WARNING! THIS CODE READS INCORRECT LCOATION IF RAM IS DISABLED AS r28 BIT 7 = 0!
    86bc:	78 80       	ld	r7, Y
  rjmp  MBC3_CLK;
    86be:	0c cc       	rjmp	.-2024   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_0111:

000086e0 <MBC3_0111>:

.section .MBC3_0111,"ax",@progbits ;0x4370 Latch RTC data
MBC3_0111:
  ; To latch data, send it to RAM! (this simplifies retrieval later on). This isn't quite in the MBC3 spec, but it's easier than write sequences
  sts   0x188, r18
    86e0:	20 93 88 01 	sts	0x0188, r18
  sts   0x189, r19
    86e4:	30 93 89 01 	sts	0x0189, r19
  sts   0x18A, r20
    86e8:	40 93 8a 01 	sts	0x018A, r20
  sts   0x18B, r21
    86ec:	50 93 8b 01 	sts	0x018B, r21
  sts   0x18C, r23
    86f0:	70 93 8c 01 	sts	0x018C, r23
  rjmp  MBC3_CLK;
    86f4:	f1 cb       	rjmp	.-2078   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_1001:

00008720 <MBC3_RTC_END4-0x18>:

.section .MBC3_1001,"ax",@progbits ;0x4390 Reserved. Do nothing
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip if set
    8720:	4f 9b       	sbis	0x09, 7	; 9
rjmp  MBC3_0001 ; Jump to RAM/RTC enable
    8722:	7e cf       	rjmp	.-260    	; 0x8620 <MBC3_0001>

  ; Do day counting here
  cpi   r20, 24                   ; is hours = 24
    8724:	48 31       	cpi	r20, 0x18	; 24
  brlo  MBC3_RTC_END4             ; branch if not
    8726:	40 f0       	brcs	.+16     	; 0x8738 <MBC3_RTC_END4>
  clr   r20                       ; clear hours
    8728:	44 27       	eor	r20, r20
  inc   r21                       ; increment days - swapped the order here because I want to do an overflow check to increment 
    872a:	53 95       	inc	r21
  tst   r21                       ; Is r11 now 0? If so, it's an overflow (or someone stopped the counter beautifully...)
    872c:	55 23       	and	r21, r21
  brne  MBC3_RTC_END4             ; branch if not
    872e:	21 f4       	brne	.+8      	; 0x8738 <MBC3_RTC_END4>
  sbrc  r23, 0                    ; Check if hi bit of day counter is already set
    8730:	70 fd       	sbrc	r23, 0
  sbr   r23, 7                    ; Set the overflow bit
    8732:	77 60       	ori	r23, 0x07	; 7
  inc   r23                       ; inc r12, because 1+1 = 2! (which we can then mask out - nothing uses bit 1 of this register I believe)
    8734:	73 95       	inc	r23
  andi  r23, 0xC1                 ; keep bit 0, 6 and 7. Clear all others
    8736:	71 7c       	andi	r23, 0xC1	; 193

00008738 <MBC3_RTC_END4>:
MBC3_RTC_END4:
  rjmp  MBC3_CLK;
    8738:	cf cb       	rjmp	.-2146   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_1011:

00008760 <MBC3_RTC_SRG-0x12>:

.section .MBC3_1011,"ax",@progbits ;0x43B0 RAM/RTC write
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip is set
    8760:	4f 9b       	sbis	0x09, 7	; 9
rjmp  MBC3_0011 ; Jump to ROM bank numbers
    8762:	7e cf       	rjmp	.-260    	; 0x8660 <MBC3_0011>

  ;  cpi   YL, 0x88; If r28 is >=0x88, RTC is enabled and bank 8-C are selected. Do an RTC write
  cpi   YL, 0x8C; NOTE: I'm running too low on cycles to update seconds and minutes, so I'm only doing hours and days. Who cares about hours anyway?
    8764:	cc 38       	cpi	r28, 0x8C	; 140
  breq  MBC3_RTC_SRG
    8766:	29 f0       	breq	.+10     	; 0x8772 <MBC3_RTC_SRG>
  cpi   YL, 0x8B; NOTE: I'm running too low on cycles to update seconds and minutes, so I'm only doing hours and days. Who cares about hours anyway?
    8768:	cb 38       	cpi	r28, 0x8B	; 139
  breq  MBC3_RTC_DAY
    876a:	31 f0       	breq	.+12     	; 0x8778 <MBC3_RTC_DAY>
  cpi   YL, 0x8A; NOTE: I'm running too low on cycles to update seconds and minutes, so I'm only doing hours and days. Who cares about hours anyway?
    876c:	ca 38       	cpi	r28, 0x8A	; 138
  breq  MBC3_RTC_HRS
    876e:	31 f0       	breq	.+12     	; 0x877c <MBC3_RTC_HRS>
  rjmp  MBC3_CLK;
    8770:	b3 cb       	rjmp	.-2202   	; 0x7ed8 <MBC3_CLK>

00008772 <MBC3_RTC_SRG>:

MBC3_RTC_SRG: 
  nop;
    8772:	00 00       	nop
  in    r23, _SFR_IO_ADDR(PINB);Read in PINB data
    8774:	73 b1       	in	r23, 0x03	; 3
  rjmp  MBC3_CLK
    8776:	b0 cb       	rjmp	.-2208   	; 0x7ed8 <MBC3_CLK>

00008778 <MBC3_RTC_DAY>:
MBC3_RTC_DAY:
  in    r21, _SFR_IO_ADDR(PINB);Read in PINB data
    8778:	53 b1       	in	r21, 0x03	; 3
  rjmp  MBC3_CLK
    877a:	ae cb       	rjmp	.-2212   	; 0x7ed8 <MBC3_CLK>

0000877c <MBC3_RTC_HRS>:
MBC3_RTC_HRS:
  in    r20, _SFR_IO_ADDR(PINB);Read in PINB data
    877c:	43 b1       	in	r20, 0x03	; 3
  rjmp  MBC3_CLK
    877e:	ac cb       	rjmp	.-2216   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_1101:

000087a0 <.MBC3_1101>:

.section .MBC3_1101,"ax",@progbits ;0x43D0 Reserved. Do nothing
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip if set
    87a0:	4f 9b       	sbis	0x09, 7	; 9
rjmp  MBC3_0101 ; Jump to RAM/RTC bank number. Or do it here and make the above SBIC
    87a2:	7e cf       	rjmp	.-260    	; 0x86a0 <MBC3_0101>

  rjmp  MBC3_CLK;
    87a4:	99 cb       	rjmp	.-2254   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC3_1111:

000087e0 <MBC3_RTC_END5-0x18>:

.section .MBC3_1111,"ax",@progbits ;0x43F0 Reserved. Do nothing
sbis  _SFR_IO_ADDR(PIND), 7; Check A15, skip is set
    87e0:	4f 9b       	sbis	0x09, 7	; 9
rjmp  MBC3_0111 ; Jump to Latch RTC. Or do it here and make the above SBIC
    87e2:	7e cf       	rjmp	.-260    	; 0x86e0 <MBC3_0111>

  ; Do day counting here
  cpi   r20, 24                   ; is hours = 24
    87e4:	48 31       	cpi	r20, 0x18	; 24
  brlo  MBC3_RTC_END5             ; branch if not
    87e6:	40 f0       	brcs	.+16     	; 0x87f8 <MBC3_RTC_END5>
  clr   r20                       ; clear hours
    87e8:	44 27       	eor	r20, r20
  inc   r21                       ; increment days - swapped the order here because I want to do an overflow check to increment 
    87ea:	53 95       	inc	r21
  tst   r21                       ; Is r11 now 0? If so, it's an overflow (or someone stopped the counter beautifully...)
    87ec:	55 23       	and	r21, r21
  brne  MBC3_RTC_END5             ; branch if not
    87ee:	21 f4       	brne	.+8      	; 0x87f8 <MBC3_RTC_END5>
  sbrc  r23, 0                    ; Check if hi bit of day counter is already set
    87f0:	70 fd       	sbrc	r23, 0
  sbr   r23, 7                    ; Set the overflow bit
    87f2:	77 60       	ori	r23, 0x07	; 7
  inc   r23                       ; inc r12, because 1+1 = 2! (which we can then mask out - nothing uses bit 1 of this register I believe)
    87f4:	73 95       	inc	r23
  andi  r23, 0xC1                 ; keep bit 0, 6 and 7. Clear all others
    87f6:	71 7c       	andi	r23, 0xC1	; 193

000087f8 <MBC3_RTC_END5>:
MBC3_RTC_END5:
  rjmp  MBC3_CLK;
    87f8:	6f cb       	rjmp	.-2338   	; 0x7ed8 <MBC3_CLK>

Disassembly of section .MBC5_DSM_0000:

00008800 <.MBC5_DSM_0000>:
; **********************************************************************************
; ************* MBC5 DOUBLE SPEED MODE JUMP TABLE **********************************
; **********************************************************************************
; ************************* READ JUMP TABLE (Read is low)
.section .MBC5_DSM_0000,"ax",@progbits ;0x4400 ROM bank 0
  sbic  _SFR_IO_ADDR(PIND), 2; If CLK is hi here, then we're not in DSM. Change the jump table!
    8800:	4a 99       	sbic	0x09, 2	; 9
  ldi   ZH, r31_MBC5
    8802:	f2 e4       	ldi	r31, 0x42	; 66
  rjmp  MBC5_DSM_CLK;
    8804:	37 cb       	rjmp	.-2450   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_0010:

00008840 <.MBC5_DSM_0010>:

.section .MBC5_DSM_0010,"ax",@progbits ;0x4420 ROM bank 0
  sbic  _SFR_IO_ADDR(PIND), 2; If CLK is hi here, then we're not in DSM. Change the jump table!
    8840:	4a 99       	sbic	0x09, 2	; 9
  ldi   ZH, r31_MBC5
    8842:	f2 e4       	ldi	r31, 0x42	; 66
  rjmp  MBC5_DSM_CLK;
    8844:	17 cb       	rjmp	.-2514   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_0100:

00008880 <.MBC5_DSM_0100>:

.section .MBC5_DSM_0100,"ax",@progbits ;0x4440 ROM bank XX
  sbic  _SFR_IO_ADDR(PIND), 2; If CLK is hi here, then we're not in DSM. Change the jump table!
    8880:	4a 99       	sbic	0x09, 2	; 9
  ldi   ZH, r31_MBC5
    8882:	f2 e4       	ldi	r31, 0x42	; 66
  rjmp  MBC5_DSM_CLK;
    8884:	f7 ca       	rjmp	.-2578   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_0110:

000088c0 <.MBC5_DSM_0110>:

.section .MBC5_DSM_0110,"ax",@progbits ;0x4460 ROM bank XX
  sbic  _SFR_IO_ADDR(PIND), 2; If CLK is hi here, then we're not in DSM. Change the jump table!
    88c0:	4a 99       	sbic	0x09, 2	; 9
  ldi   ZH, r31_MBC5
    88c2:	f2 e4       	ldi	r31, 0x42	; 66
  rjmp  MBC5_DSM_CLK;
    88c4:	d7 ca       	rjmp	.-2642   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_1000:

00008900 <.MBC5_DSM_1000>:

.section .MBC5_DSM_1000,"ax",@progbits ;0x4480 Reserved. Do nothing
  in    r23, _SFR_IO_ADDR(PORTA) ; Doing stuff in here to try and compensate for a lack of cycles elsewhere. Don't even know if this is useful.
    8900:	72 b1       	in	r23, 0x02	; 2
  ori   r23, 0x80; I think I overstep CLK boundaries by adding a fourth instruction here, but I need it...
    8902:	70 68       	ori	r23, 0x80	; 128
  rjmp  MBC5_DSM_CLK;
    8904:	b7 ca       	rjmp	.-2706   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_1010:

00008940 <.MBC5_DSM_1010>:

.section .MBC5_DSM_1010,"ax",@progbits ;0x44A0 RAM read
  ; For DSM, this is in HW, which gives me 3 free cycles which I'll use to set up RAM bank number and enable/disable
  ; I'm assuming that if you enable RAM, you will read or write to it before disabling it again, which should result
  ; in calling this code. May be a flawed assumption which could break things.
  in    r23, _SFR_IO_ADDR(PORTA)
    8940:	72 b1       	in	r23, 0x02	; 2
  mov   r24, r23 ; Make a copy
    8942:	87 2f       	mov	r24, r23
  cbr   r24, 0x03; CLR the RAM bank bits in prep for ORing it later
    8944:	8c 7f       	andi	r24, 0xFC	; 252
  ori   r23, 0x80; I think I overstep CLK boundaries by adding a fourth instruction here, but I need it...
    8946:	70 68       	ori	r23, 0x80	; 128
  rjmp  MBC5_DSM_CLK;
    8948:	95 ca       	rjmp	.-2774   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_1100:

00008980 <.MBC5_DSM_1100>:

.section .MBC5_DSM_1100,"ax",@progbits ;0x44C0 Reserved. Do nothing
  in    r24, _SFR_IO_ADDR(PORTA); Doing stuff in here to try and compensate for a lack of cycles elsewhere. Don't even know if this is useful.
    8980:	82 b1       	in	r24, 0x02	; 2
  cbr   r24, 0x03; CLR the RAM bank bits in prep for ORing it later
    8982:	8c 7f       	andi	r24, 0xFC	; 252
  rjmp  MBC5_DSM_CLK;
    8984:	77 ca       	rjmp	.-2834   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_1110:

000089c0 <.MBC5_DSM_1110>:

.section .MBC5_DSM_1110,"ax",@progbits ;0x44E0 Reserved. Do nothing
  in    r23, _SFR_IO_ADDR(PORTA) ; Doing stuff in here to try and compensate for a lack of cycles elsewhere. Don't even know if this is useful.
    89c0:	72 b1       	in	r23, 0x02	; 2
  ori   r23, 0x80; I think I overstep CLK boundaries by adding a fourth instruction here, but I need it...
    89c2:	70 68       	ori	r23, 0x80	; 128
  rjmp  MBC5_DSM_CLK;
    89c4:	57 ca       	rjmp	.-2898   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_0001:

00008820 <.MBC5_DSM_0001>:

; ************************* WRITE JUMP TABLE (Read is hi)
.section .MBC5_DSM_0001,"ax",@progbits ;0x4410 Ram enable
; No NOPs in DSM. Assume WR is asserted already
; We're going to play dangerously for DSM. Just check for 0x08 instead of 0x0A to save cycles
  out   _SFR_IO_ADDR(PORTA), r23  ; Immediately disable RAM (should have already OR'd this)
    8820:	72 b9       	out	0x02, r23	; 2
  sbic  _SFR_IO_ADDR(PINB), 3     ; Check for 0x08
    8822:	1b 99       	sbic	0x03, 3	; 3
  cbi   _SFR_IO_ADDR(PORTA), PA7  ; Eugh, this is a 2 cycle instruction, it may break things...
    8824:	17 98       	cbi	0x02, 7	; 2
  rjmp  MBC5_DSM_CLK
    8826:	26 cb       	rjmp	.-2484   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_0011:

00008860 <.MBC5_DSM_0011>:
; Technically I cheat in this loop. This address space is actually broken up into lo8 and hi1 across 
; 0x20-2F and 0x30-3F, instead of using a block address of 0x20-3F like in other MBC modes. The only 
; reason I am ignoring this is because I don't have 8MB of flash, and therefore should have absolutely
; no reason for anyone to access the 9th bit in the upper half of the address space! If they did, I 
; would need to connect ADDR12 to RUMBLE (and change this pin to be an input) and monitor it in this loop
  in    r22, _SFR_IO_ADDR(PINB); 8 lo bits of ROM address. Easy! Too bad you can't copy port to port
    8860:	63 b1       	in	r22, 0x03	; 3
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the MA mask value. Probably don't need to OUT this here for a WRITE command
    8862:	68 b9       	out	0x08, r22	; 8
  rjmp  MBC5_DSM_CLK;
    8864:	07 cb       	rjmp	.-2546   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_0101:

000088a0 <.MBC5_DSM_0101>:

.section .MBC5_DSM_0101,"ax",@progbits ;0x4450 RAM bank number  - NEED TO CHANGE THE PINOUT TO LET THE RUMBLE PIN BE MASKED EASILY!
  in    r17, _SFR_IO_ADDR(PINB);Read in PINB data, no mask because speed... Very dangerous.
    88a0:	13 b1       	in	r17, 0x03	; 3
  or    r24, r17 ; This is dangerous if RAM bank is changed consecutively without reading or writing, because r24 isn't cleared!
    88a2:	81 2b       	or	r24, r17
  out   _SFR_IO_ADDR(PORTA), r24
    88a4:	82 b9       	out	0x02, r24	; 2
  rjmp  MBC5_DSM_CLK;
    88a6:	e6 ca       	rjmp	.-2612   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_0111:

000088e0 <.MBC5_DSM_0111>:

.section .MBC5_DSM_0111,"ax",@progbits ;0x4470 Not used in MBC5
  in    r24, _SFR_IO_ADDR(PORTA); Doing stuff in here to try and compensate for a lack of cycles elsewhere. Don't even know if this is useful.
    88e0:	82 b1       	in	r24, 0x02	; 2
  cbr   r24, 0x03; CLR the RAM bank bits in prep for ORing it later
    88e2:	8c 7f       	andi	r24, 0xFC	; 252
  rjmp  MBC5_DSM_CLK;
    88e4:	c7 ca       	rjmp	.-2674   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_1001:

00008920 <.MBC5_DSM_1001>:

.section .MBC5_DSM_1001,"ax",@progbits ;0x4490 Reserved. Do nothing
  in    r23, _SFR_IO_ADDR(PORTA) ; Doing stuff in here to try and compensate for a lack of cycles elsewhere. Don't even know if this is useful.
    8920:	72 b1       	in	r23, 0x02	; 2
  ori   r23, 0x80; I think I overstep CLK boundaries by adding a fourth instruction here, but I need it...
    8922:	70 68       	ori	r23, 0x80	; 128
  rjmp  MBC5_DSM_CLK;
    8924:	a7 ca       	rjmp	.-2738   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_1011:

00008960 <.MBC5_DSM_1011>:

.section .MBC5_DSM_1011,"ax",@progbits ;0x44B0 RAM write
  ; For DSM, this is in HW, which gives me 3 free cycles which I'll use to set up RAM bank number and enable/disable
  ; I'm assuming that if you enable RAM, you will read or write to it before disabling it again, which should result
  ; in calling this code. May be a flawed assumption which could break things.
  in    r23, _SFR_IO_ADDR(PORTA)
    8960:	72 b1       	in	r23, 0x02	; 2
  mov   r24, r23 ; Make a copy
    8962:	87 2f       	mov	r24, r23
  cbr   r24, 0x03; CLR the RAM bank bits in prep for ORing it later
    8964:	8c 7f       	andi	r24, 0xFC	; 252
  ori   r23, 0x80; I think I overstep CLK boundaries by adding a fourth instruction here, but I need it...
    8966:	70 68       	ori	r23, 0x80	; 128
  rjmp  MBC5_DSM_CLK;
    8968:	85 ca       	rjmp	.-2806   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_1101:

000089a0 <.MBC5_DSM_1101>:

.section .MBC5_DSM_1101,"ax",@progbits ;0x44D0 Reserved. Do nothing
  in    r24, _SFR_IO_ADDR(PORTA); Doing stuff in here to try and compensate for a lack of cycles elsewhere. Don't even know if this is useful.
    89a0:	82 b1       	in	r24, 0x02	; 2
  cbr   r24, 0x03; CLR the RAM bank bits in prep for ORing it later
    89a2:	8c 7f       	andi	r24, 0xFC	; 252
  rjmp  MBC5_DSM_CLK;
    89a4:	67 ca       	rjmp	.-2866   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC5_DSM_1111:

000089e0 <.MBC5_DSM_1111>:

.section .MBC5_DSM_1111,"ax",@progbits ;0x44F0 Reserved. Do nothing
  in    r24, _SFR_IO_ADDR(PORTA); Doing stuff in here to try and compensate for a lack of cycles elsewhere. Don't even know if this is useful.
    89e0:	82 b1       	in	r24, 0x02	; 2
  cbr   r24, 0x03; CLR the RAM bank bits in prep for ORing it later
    89e2:	8c 7f       	andi	r24, 0xFC	; 252
  rjmp  MBC5_DSM_CLK;
    89e4:	47 ca       	rjmp	.-2930   	; 0x7e74 <MBC5_DSM_CLK>

Disassembly of section .MBC2_0000:

00008a00 <.MBC2_0000>:
; **********************************************************************************
; ************* MBC2 MODE JUMP TABLE ***********************************************
; **********************************************************************************
; ************************* READ JUMP TABLE (Read is low)
.section .MBC2_0000,"ax",@progbits ;0x4500 ROM bank 0
  out   _SFR_IO_ADDR(PORTC), r1; Set PORTC to 0x00
    8a00:	18 b8       	out	0x08, r1	; 8
  rjmp  MBC2_CLK; Finished setting up the lines for a read :)
    8a02:	7a ca       	rjmp	.-2828   	; 0x7ef8 <MBC2_CLK>

Disassembly of section .MBC2_0100:

00008a80 <.MBC2_0100>:

.section .MBC2_0100,"ax",@progbits ;0x4540 ROM bank XX
  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the stored MA14_18_21 value (r22)
    8a80:	68 b9       	out	0x08, r22	; 8
  rjmp  MBC2_CLK; Finished setting up the lines for a read :)
    8a82:	3a ca       	rjmp	.-2956   	; 0x7ef8 <MBC2_CLK>

Disassembly of section .MBC2_1000:

00008b00 <.MBC2_1000>:


.section .MBC2_1000,"ax",@progbits ;0x4580 Reserved. Do nothing
out   _SFR_IO_ADDR(PORTC), r1; Set PORTC to 0x00
    8b00:	18 b8       	out	0x08, r1	; 8
  rjmp  MBC2_CLK;
    8b02:	fa c9       	rjmp	.-3084   	; 0x7ef8 <MBC2_CLK>

Disassembly of section .MBC2_1100:

00008b80 <.MBC2_1100>:

.section .MBC2_1100,"ax",@progbits ;0x45C0 Reserved. Do nothing
out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the stored MA14_18_21 value (r22)
    8b80:	68 b9       	out	0x08, r22	; 8
  rjmp  MBC2_CLK;
    8b82:	ba c9       	rjmp	.-3212   	; 0x7ef8 <MBC2_CLK>

Disassembly of section .MBC2_0001:

00008a20 <MBC2_RAM_FLG_DIS-0x12>:

; ************************* WRITE JUMP TABLE (Read is hi)
.section .MBC2_0001,"ax",@progbits ;0x4510 Ram enable/disable OR ROM bank numbers. Need to read A8!!!
; Read A8 here, JMP to ROM bank numbers if A8=1, else continue
  sbic  _SFR_IO_ADDR(PINC), 7; Using MA21 as A8 (in theory)
    8a20:	37 99       	sbic	0x06, 7	; 6
  rjmp  MBC2_ROM_BANKING
    8a22:	09 c0       	rjmp	.+18     	; 0x8a36 <MBC2_ROM_BANKING>

  nop
    8a24:	00 00       	nop
  in    r17, _SFR_IO_ADDR(PINB)
    8a26:	13 b1       	in	r17, 0x03	; 3
  andi  r17, 0x0F ; Mask D0-4. I don't want to add this, but we'll see if MBC data is corrupted otherwise
    8a28:	1f 70       	andi	r17, 0x0F	; 15
  cpi   r17, 0x0A; 0x0A is an enable command - Is this valid for MBC2? It's not specific on the gbdev wiki
    8a2a:	1a 30       	cpi	r17, 0x0A	; 10
  brne  MBC2_RAM_FLG_DIS
    8a2c:	11 f4       	brne	.+4      	; 0x8a32 <MBC2_RAM_FLG_DIS>
  cbi   _SFR_IO_ADDR(PORTA), PA7;
    8a2e:	17 98       	cbi	0x02, 7	; 2
  rjmp  MBC2_CLK
    8a30:	63 ca       	rjmp	.-2874   	; 0x7ef8 <MBC2_CLK>

00008a32 <MBC2_RAM_FLG_DIS>:
MBC2_RAM_FLG_DIS:
  sbi   _SFR_IO_ADDR(PORTA), PA7
    8a32:	17 9a       	sbi	0x02, 7	; 2
  rjmp  MBC2_CLK
    8a34:	61 ca       	rjmp	.-2878   	; 0x7ef8 <MBC2_CLK>

00008a36 <MBC2_ROM_BANKING>:

MBC2_ROM_BANKING:
  andi  r22, 0xF0;REG_MA14_18, MA19_21_MASK ; Mask only hi bits to ditch the old low bits
    8a36:	60 7f       	andi	r22, 0xF0	; 240
;  nop; Need a NOP here for DATA to be valid... without this, this is 13-16 cycles in, so it should be safe...
  in    r17, _SFR_IO_ADDR(PINB);GB_DAT_REG, GB_DAT_R ;Read in PINB data for use in each write mode
    8a38:	13 b1       	in	r17, 0x03	; 3
  andi  r17, 0x0F ; Mask D0-3.
    8a3a:	1f 70       	andi	r17, 0x0F	; 15
  tst   r17
    8a3c:	11 23       	and	r17, r17
  brne  MBC2_NZERO
    8a3e:	09 f4       	brne	.+2      	; 0x8a42 <MBC2_NZERO>
  inc   r17
    8a40:	13 95       	inc	r17

00008a42 <MBC2_NZERO>:
MBC2_NZERO:
  or    r22, r17;REG_MA14_18, GB_DAT_REG
    8a42:	61 2b       	or	r22, r17
;  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the MA mask value. Probably don't need to OUT this here for a WRITE command
  rjmp  MBC2_CLK;
    8a44:	59 ca       	rjmp	.-2894   	; 0x7ef8 <MBC2_CLK>

Disassembly of section .MBC2_0101:

00008aa0 <.MBC2_0101>:

.section .MBC2_0101,"ax",@progbits ;0x4550 Not used for MBC2
  rjmp MBC2_CLK;
    8aa0:	2b ca       	rjmp	.-2986   	; 0x7ef8 <MBC2_CLK>

Disassembly of section .MBC2_1001:

00008b20 <MBC2_RAM_FLG_DIS2-0x16>:

.section .MBC2_1001,"ax",@progbits ;0x4590 Reserved. Do nothing
sbic  _SFR_IO_ADDR(PIND), 7; Check A15, skip is cleared - by combining these sections, I save 2 cycles for read
    8b20:	4f 99       	sbic	0x09, 7	; 9
  rjmp  MBC2_CLK;
    8b22:	ea c9       	rjmp	.-3116   	; 0x7ef8 <MBC2_CLK>
; Do RAM enable/ROM read here (A15=0)
; Read A8 here, JMP to ROM bank numbers if A8=1, else continue
  sbic  _SFR_IO_ADDR(PINC), 7; Using MA21 as A8 (in theory)
    8b24:	37 99       	sbic	0x06, 7	; 6
  rjmp  MBC2_ROM_BANKING2
    8b26:	09 c0       	rjmp	.+18     	; 0x8b3a <MBC2_ROM_BANKING2>

  nop
    8b28:	00 00       	nop
  in    r17, _SFR_IO_ADDR(PINB)
    8b2a:	13 b1       	in	r17, 0x03	; 3
  andi  r17, 0x0F ; Mask D0-4. I don't want to add this, but we'll see if MBC data is corrupted otherwise
    8b2c:	1f 70       	andi	r17, 0x0F	; 15
  cpi   r17, 0x0A; 0x0A is an enable command - Is this valid for MBC2? It's not specific on the gbdev wiki
    8b2e:	1a 30       	cpi	r17, 0x0A	; 10
  brne  MBC2_RAM_FLG_DIS2
    8b30:	11 f4       	brne	.+4      	; 0x8b36 <MBC2_RAM_FLG_DIS2>
  cbi   _SFR_IO_ADDR(PORTA), PA7;
    8b32:	17 98       	cbi	0x02, 7	; 2
  rjmp  MBC2_CLK
    8b34:	e1 c9       	rjmp	.-3134   	; 0x7ef8 <MBC2_CLK>

00008b36 <MBC2_RAM_FLG_DIS2>:
MBC2_RAM_FLG_DIS2:
  sbi   _SFR_IO_ADDR(PORTA), PA7
    8b36:	17 9a       	sbi	0x02, 7	; 2
  rjmp  MBC2_CLK
    8b38:	df c9       	rjmp	.-3138   	; 0x7ef8 <MBC2_CLK>

00008b3a <MBC2_ROM_BANKING2>:

MBC2_ROM_BANKING2:
  andi  r22, 0xF0;REG_MA14_18, MA19_21_MASK ; Mask only hi bits to ditch the old low bits
    8b3a:	60 7f       	andi	r22, 0xF0	; 240
;  nop; Need a NOP here for DATA to be valid... without this, this is 13-16 cycles in, so it should be safe...
  in    r17, _SFR_IO_ADDR(PINB);GB_DAT_REG, GB_DAT_R ;Read in PINB data for use in each write mode
    8b3c:	13 b1       	in	r17, 0x03	; 3
  andi  r17, 0x0F ; Mask D0-3.
    8b3e:	1f 70       	andi	r17, 0x0F	; 15
  tst   r17
    8b40:	11 23       	and	r17, r17
  brne  MBC2_NZERO2
    8b42:	09 f4       	brne	.+2      	; 0x8b46 <MBC2_NZERO2>
  inc   r17
    8b44:	13 95       	inc	r17

00008b46 <MBC2_NZERO2>:
MBC2_NZERO2:
  or    r22, r17;REG_MA14_18, GB_DAT_REG
    8b46:	61 2b       	or	r22, r17
;  out   _SFR_IO_ADDR(PORTC), MA14_18_21_REGISTER; Set PORTC to the MA mask value. Probably don't need to OUT this here for a WRITE command
  rjmp  MBC2_CLK;
    8b48:	d7 c9       	rjmp	.-3154   	; 0x7ef8 <MBC2_CLK>

Disassembly of section .MBC2_1101:

00008ba0 <.MBC2_1101>:

.section .MBC2_1101,"ax",@progbits ;0x45D0 Reserved. Do nothing
  rjmp  MBC2_CLK;
    8ba0:	ab c9       	rjmp	.-3242   	; 0x7ef8 <MBC2_CLK>
