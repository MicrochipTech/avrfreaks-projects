
DOGM128-6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000152a  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001a  00800060  0000152a  0000159e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000c  0080007a  00001544  000015b8  2**0
                  ALLOC
  3 .debug_aranges 000000a0  00000000  00000000  000015b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000003ba  00000000  00000000  00001658  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001268  00000000  00000000  00001a12  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000005e0  00000000  00000000  00002c7a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000df4  00000000  00000000  0000325a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000300  00000000  00000000  00004050  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000052d  00000000  00000000  00004350  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000e7e  00000000  00000000  0000487d  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b9 04 	jmp	0x972	; 0x972 <__ctors_end>
       4:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
       8:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
       c:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      10:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      14:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      18:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      1c:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      20:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      24:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      28:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      2c:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      30:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      34:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      38:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      3c:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      40:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      44:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      48:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      4c:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>
      50:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__bad_interrupt>

00000054 <__c.1952>:
      54:	31 32 33 34 35 36 37 38 39 30 00                    1234567890.

0000005f <ASCII5_7>:
      5f:	00 00 00 00 00 00 00 5f 00 00 00 07 00 07 00 14     ......._........
      6f:	7f 14 7f 14 24 2a 7f 2a 12 23 13 08 64 62 36 49     ....$*.*.#..db6I
      7f:	55 22 50 00 05 03 00 00 00 1c 22 41 00 00 41 22     U"P......."A..A"
      8f:	1c 00 08 2a 1c 2a 08 08 08 3e 08 08 00 50 30 00     ...*.*...>...P0.
      9f:	00 08 08 08 08 08 00 60 60 00 00 20 10 08 04 02     .......``.. ....
      af:	3e 51 49 45 3e 00 42 7f 40 00 42 61 51 49 46 21     >QIE>.B.@.BaQIF!
      bf:	41 45 4b 31 18 14 12 7f 10 27 45 45 45 39 3c 4a     AEK1.....'EEE9<J
      cf:	49 49 30 01 71 09 05 03 36 49 49 49 36 06 49 49     II0.q...6III6.II
      df:	29 1e 00 36 36 00 00 00 56 36 00 00 00 08 14 22     )..66...V6....."
      ef:	41 14 14 14 14 14 41 22 14 08 00 02 01 51 09 06     A.....A".....Q..
      ff:	32 49 79 41 3e 7e 11 11 11 7e 7f 49 49 49 36 3e     2IyA>~...~.III6>
     10f:	41 41 41 22 7f 41 41 22 1c 7f 49 49 49 41 7f 09     AAA".AA"..IIIA..
     11f:	09 01 01 3e 41 41 51 32 7f 08 08 08 7f 00 41 7f     ...>AAQ2......A.
     12f:	41 00 20 40 41 3f 01 7f 08 14 22 41 7f 40 40 40     A. @A?...."A.@@@
     13f:	40 7f 02 04 02 7f 7f 04 08 10 7f 3e 41 41 41 3e     @..........>AAA>
     14f:	7f 09 09 09 06 3e 41 51 21 5e 7f 09 19 29 46 46     .....>AQ!^...)FF
     15f:	49 49 49 31 01 01 7f 01 01 3f 40 40 40 3f 1f 20     III1.....?@@@?. 
     16f:	40 20 1f 7f 20 18 20 7f 63 14 08 14 63 03 04 78     @ .. . .c...c..x
     17f:	04 03 61 51 49 45 43 00 00 7f 41 41 02 04 08 10     ..aQIEC...AA....
     18f:	20 41 41 7f 00 00 04 02 01 02 04 40 40 40 40 40      AA........@@@@@
     19f:	00 01 02 04 00 20 54 54 54 78 7f 48 44 44 38 38     ..... TTTx.HDD88
     1af:	44 44 44 20 38 44 44 48 7f 38 54 54 54 18 08 7e     DDD 8DDH.8TTT..~
     1bf:	09 01 02 08 14 54 54 3c 7f 08 04 04 78 00 44 7d     .....TT<....x.D}
     1cf:	40 00 20 40 44 3d 00 00 7f 10 28 44 00 41 7f 40     @. @D=....(D.A.@
     1df:	00 7c 04 18 04 78 7c 08 04 04 78 38 44 44 44 38     .|...x|...x8DDD8
     1ef:	7c 14 14 14 08 08 14 14 18 7c 7c 08 04 04 08 48     |........||....H
     1ff:	54 54 54 20 04 3f 44 40 20 3c 40 40 20 7c 1c 20     TTT .?D@ <@@ |. 
     20f:	40 20 1c 3c 40 30 40 3c 44 28 10 28 44 0c 50 50     @ .<@0@<D(.(D.PP
     21f:	50 3c 44 64 54 4c 44 00 08 36 41 00 00 00 7f 00     P<DdTLD..6A.....
     22f:	00 00 41 36 08 00 08 08 2a 1c 08 08 1c 2a 08 08     ..A6....*....*..

0000023f <ASCII8_16>:
	...
     24f:	00 00 70 f8 f8 70 00 00 00 00 00 1b 1b 00 00 00     ..p..p..........
     25f:	00 1c 3c 00 00 3c 1c 00 00 00 00 00 00 00 00 00     ..<..<..........
     26f:	40 f0 f0 40 f0 f0 40 00 04 1f 1f 04 1f 1f 04 00     @..@..@.........
     27f:	70 f8 88 8e 8e 98 30 00 0c 18 10 70 70 1f 0f 00     p.....0....pp...
     28f:	60 60 00 00 80 c0 60 00 18 0c 06 03 01 18 18 00     ``....`.........
     29f:	00 b0 f8 c8 78 b0 80 00 0f 1f 10 11 0f 1f 10 00     ....x...........
     2af:	00 20 3c 1c 00 00 00 00 00 00 00 00 00 00 00 00     . <.............
     2bf:	00 00 e0 f0 18 08 00 00 00 00 07 0f 18 10 00 00     ................
     2cf:	00 00 08 18 f0 e0 00 00 00 00 10 18 0f 07 00 00     ................
     2df:	00 40 c0 80 80 c0 40 00 01 05 07 03 03 07 05 01     .@....@.........
     2ef:	00 00 00 c0 c0 00 00 00 00 01 01 07 07 01 01 00     ................
	...
     307:	00 00 20 3c 1c 00 00 00 00 00 00 00 00 00 00 00     .. <............
     317:	01 01 01 01 01 01 01 00 00 00 00 00 00 00 00 00     ................
     327:	00 00 00 18 18 00 00 00 00 00 00 00 80 c0 60 00     ..............`.
     337:	18 0c 06 03 01 00 00 00 e0 f0 18 88 88 18 f0 e0     ................
     347:	07 0f 18 11 11 18 0f 07 00 20 30 f8 f8 00 00 00     ......... 0.....
     357:	00 10 10 1f 1f 10 10 00 10 18 08 88 c8 78 30 00     .............x0.
     367:	1c 1e 13 11 10 18 18 00 10 18 88 88 88 f8 70 00     ..............p.
     377:	08 18 10 10 10 1f 0f 00 80 c0 60 30 f8 f8 00 00     ..........`0....
     387:	01 01 01 11 1f 1f 11 00 f8 f8 88 88 88 88 08 00     ................
     397:	08 18 10 10 10 1f 0f 00 e0 f0 98 88 88 80 00 00     ................
     3a7:	0f 1f 10 10 10 1f 0f 00 18 18 08 08 88 f8 78 00     ..............x.
     3b7:	00 00 1e 1f 01 00 00 00 70 f8 88 88 88 f8 70 00     ........p.....p.
     3c7:	0f 1f 10 10 10 1f 0f 00 70 f8 88 88 88 f8 f0 00     ........p.......
     3d7:	00 10 10 10 18 0f 07 00 00 00 00 60 60 00 00 00     ...........``...
     3e7:	00 00 00 0c 0c 00 00 00 00 00 00 60 60 00 00 00     ...........``...
     3f7:	00 00 10 1c 0c 00 00 00 00 00 80 c0 60 30 10 00     ............`0..
     407:	00 01 03 06 0c 18 10 00 00 40 40 40 40 40 40 00     .........@@@@@@.
     417:	00 02 02 02 02 02 02 00 00 10 30 60 c0 80 00 00     ..........0`....
     427:	00 10 18 0c 06 03 01 00 30 38 08 88 c8 78 30 00     ........08...x0.
     437:	00 00 00 1b 1b 00 00 00 e0 f0 10 90 90 f0 e0 00     ................
     447:	0f 1f 10 17 17 17 03 00 c0 e0 30 18 30 e0 c0 00     ..........0.0...
     457:	1f 1f 01 01 01 1f 1f 00 08 f8 f8 88 88 f8 70 00     ..............p.
     467:	10 1f 1f 10 10 1f 0f 00 e0 f0 18 08 08 18 30 00     ..............0.
     477:	07 0f 18 10 10 18 0c 00 08 f8 f8 08 18 f0 e0 00     ................
     487:	10 1f 1f 10 18 0f 07 00 08 f8 f8 88 c8 18 38 00     ..............8.
     497:	10 1f 1f 10 11 18 1c 00 08 f8 f8 88 c8 18 38 00     ..............8.
     4a7:	10 1f 1f 10 01 00 00 00 e0 f0 18 08 08 18 30 00     ..............0.
     4b7:	07 0f 18 11 11 0f 1f 00 f8 f8 80 80 80 f8 f8 00     ................
     4c7:	1f 1f 00 00 00 1f 1f 00 00 00 08 f8 f8 08 00 00     ................
     4d7:	00 00 10 1f 1f 10 00 00 00 00 00 08 f8 f8 08 00     ................
     4e7:	0e 1e 10 10 1f 0f 00 00 08 f8 f8 80 c0 78 38 00     .............x8.
     4f7:	10 1f 1f 01 03 1e 1c 00 08 f8 f8 08 00 00 00 00     ................
     507:	10 1f 1f 10 10 18 1c 00 f8 f8 70 e0 e0 70 f8 f8     ..........p..p..
     517:	1f 1f 00 00 00 00 1f 1f f8 f8 70 e0 c0 f8 f8 00     ..........p.....
     527:	1f 1f 00 00 01 1f 1f 00 f0 f8 08 08 08 f8 f0 00     ................
     537:	0f 1f 10 10 10 1f 0f 00 08 f8 f8 88 88 f8 70 00     ..............p.
     547:	10 1f 1f 10 00 00 00 00 f0 f8 08 08 08 f8 f0 00     ................
     557:	0f 1f 10 1c 78 7f 4f 00 08 f8 f8 88 88 f8 70 00     ....x.O.......p.
     567:	10 1f 1f 00 01 1f 1e 00 30 78 c8 88 88 38 30 00     ........0x...80.
     577:	0c 1c 10 10 11 1f 0e 00 38 18 08 f8 f8 08 18 38     ........8......8
     587:	00 00 10 1f 1f 10 00 00 f8 f8 00 00 00 f8 f8 00     ................
     597:	0f 1f 10 10 10 1f 0f 00 f8 f8 00 00 00 00 f8 f8     ................
     5a7:	03 07 0c 18 18 0c 07 03 f8 f8 00 00 00 00 f8 f8     ................
     5b7:	07 1f 1c 07 07 1c 1f 07 18 38 60 c0 c0 60 38 18     .........8`..`8.
     5c7:	18 1c 06 03 03 06 1c 18 38 78 c0 80 80 c0 78 38     ........8x....x8
     5d7:	00 00 10 1f 1f 10 00 00 38 18 08 88 c8 68 38 18     ........8....h8.
     5e7:	1c 1e 13 11 10 10 18 1c 00 00 f8 f8 08 08 00 00     ................
     5f7:	00 00 1f 1f 10 10 00 00 70 e0 c0 80 00 00 00 00     ........p.......
     607:	00 00 01 03 07 0e 1c 00 00 00 08 08 f8 f8 00 00     ................
     617:	00 00 10 10 1f 1f 00 00 10 18 0c 06 0c 18 10 00     ................
	...
     637:	40 40 40 40 40 40 40 40 00 00 06 0e 08 00 00 00     @@@@@@@@........
	...
     64f:	00 40 40 40 c0 80 00 00 0e 1f 11 11 0f 1f 10 00     .@@@............
     65f:	08 f8 f8 40 c0 80 00 00 00 1f 1f 10 10 1f 0f 00     ...@............
     66f:	80 c0 40 40 40 c0 80 00 0f 1f 10 10 10 18 08 00     ..@@@...........
     67f:	00 80 c0 48 f8 f8 00 00 0f 1f 10 10 0f 1f 10 00     ...H............
     68f:	80 c0 40 40 40 c0 80 00 0f 1f 11 11 11 19 09 00     ..@@@...........
     69f:	80 f0 f8 88 18 30 00 00 10 1f 1f 10 00 00 00 00     .....0..........
     6af:	80 c0 40 40 80 c0 40 00 4f df 90 90 ff 7f 00 00     ..@@..@.O.......
     6bf:	08 f8 f8 80 40 c0 80 00 10 1f 1f 00 00 1f 1f 00     ....@...........
     6cf:	00 00 40 d8 d8 00 00 00 00 00 10 1f 1f 10 00 00     ..@.............
     6df:	00 00 00 00 40 d8 d8 00 00 60 e0 80 80 ff 7f 00     ....@....`......
     6ef:	08 f8 f8 00 80 c0 40 00 10 1f 1f 03 07 1c 18 00     ......@.........
     6ff:	00 00 08 f8 f8 00 00 00 00 00 10 1f 1f 10 00 00     ................
     70f:	c0 c0 c0 80 80 c0 c0 80 1f 1f 00 1f 1f 00 1f 1f     ................
     71f:	40 c0 80 40 40 c0 80 00 00 1f 1f 00 00 1f 1f 00     @..@@...........
     72f:	80 c0 40 40 40 c0 80 00 0f 1f 10 10 10 1f 0f 00     ..@@@...........
     73f:	40 c0 80 40 40 c0 80 00 80 ff ff 90 10 1f 0f 00     @..@@...........
     74f:	80 c0 40 40 80 c0 40 00 0f 1f 10 90 ff ff 80 00     ..@@..@.........
     75f:	40 c0 80 c0 40 c0 80 00 10 1f 1f 10 00 01 01 00     @...@...........
     76f:	80 c0 40 40 40 c0 80 00 08 19 13 12 16 1c 08 00     ..@@@...........
     77f:	40 40 f0 f8 40 40 00 00 00 00 0f 1f 10 18 08 00     @@..@@..........
     78f:	c0 c0 00 00 c0 c0 00 00 0f 1f 10 10 0f 1f 10 00     ................
     79f:	c0 c0 00 00 00 00 c0 c0 03 07 0c 18 18 0c 07 03     ................
     7af:	c0 c0 00 00 00 00 c0 c0 0f 1f 18 0e 0e 18 1f 0f     ................
     7bf:	40 c0 80 00 00 80 c0 40 10 18 0d 07 07 0d 18 10     @......@........
     7cf:	c0 c0 00 00 00 c0 c0 00 8f 9f 90 90 d0 7f 3f 00     ..............?.
     7df:	c0 c0 40 40 c0 c0 40 00 18 1c 16 13 11 18 18 00     ..@@..@.........
     7ef:	00 80 80 f0 78 08 08 00 00 00 00 0f 1f 10 10 00     ....x...........
     7ff:	00 00 00 78 78 00 00 00 00 00 00 1f 1f 00 00 00     ...xx...........
     80f:	00 08 08 78 f0 80 80 00 00 10 10 1f 0f 00 00 00     ...x............
     81f:	10 18 08 18 10 18 08 00 00 00 00 00 00 00 00 00     ................

0000082f <HZ_Table>:
     82f:	bb b7 04 44 44 fc 44 44 00 04 04 84 e4 1c 84 04     ...DD.DD........
     83f:	04 00 10 30 10 1f 08 08 00 02 01 00 ff 00 00 01     ...0............
     84f:	06 00 bb fa 10 10 d0 ff 90 10 00 fc 04 04 04 fc     ................
     85f:	00 00 00 00 04 03 00 ff 80 41 20 1f 00 00 00 3f     .........A ....?
     86f:	40 40 70 00 c1 a2 00 10 10 90 10 10 11 16 10 10     @@p.............
     87f:	10 d0 10 10 00 00 40 40 40 40 43 5c 40 40 50 4c     ......@@@@C\@@PL
     88f:	43 40 40 40 40 00 c8 c6 20 30 ac 63 18 00 10 10     C@@@@... 0.c....
     89f:	9f a8 48 a8 08 08 c0 00 22 67 22 12 92 85 45 3d     ..H....."g"...E=
     8af:	04 04 7c 84 85 85 e1 00 c9 f9 04 04 d4 54 54 54     ..|..........TTT
     8bf:	54 df 54 54 54 54 d4 04 04 00 80 60 1f 02 02 02     T.TTTT.....`....
     8cf:	02 03 02 02 02 02 03 00 00 00 ca d5 00 f8 00 00     ................
     8df:	ff 00 80 60 df 10 10 10 f0 10 10 00 00 0f 04 02     ...`............
     8ef:	ff 00 80 40 21 16 08 16 61 c0 40 00 cc e5 80 40     ...@!...a.@....@
     8ff:	20 f8 07 10 10 d0 30 ff 30 d0 10 10 10 00 00 00      .....0.0.......
     90f:	00 ff 08 04 03 04 04 ff 04 04 03 0c 04 00 cf ec     ................
     91f:	00 fc 04 04 fc 00 f8 08 cc 4a 49 c8 08 f8 00 00     .........JI.....
     92f:	00 0f 04 04 0f 00 ff 00 0f 08 08 4f 80 7f 00 00     ...........O....
     93f:	d2 f4 40 40 44 44 4c 74 45 46 44 64 5c 44 44 40     ..@@DDLtEFDd\DD@
     94f:	40 00 00 00 00 ff 49 49 49 49 49 49 49 ff 00 00     @.....IIIIIII...
	...

00000961 <HexChars>:
     961:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF
	...

00000972 <__ctors_end>:
     972:	11 24       	eor	r1, r1
     974:	1f be       	out	0x3f, r1	; 63
     976:	cf e5       	ldi	r28, 0x5F	; 95
     978:	d8 e0       	ldi	r29, 0x08	; 8
     97a:	de bf       	out	0x3e, r29	; 62
     97c:	cd bf       	out	0x3d, r28	; 61

0000097e <__do_copy_data>:
     97e:	10 e0       	ldi	r17, 0x00	; 0
     980:	a0 e6       	ldi	r26, 0x60	; 96
     982:	b0 e0       	ldi	r27, 0x00	; 0
     984:	ea e2       	ldi	r30, 0x2A	; 42
     986:	f5 e1       	ldi	r31, 0x15	; 21
     988:	02 c0       	rjmp	.+4      	; 0x98e <.do_copy_data_start>

0000098a <.do_copy_data_loop>:
     98a:	05 90       	lpm	r0, Z+
     98c:	0d 92       	st	X+, r0

0000098e <.do_copy_data_start>:
     98e:	aa 37       	cpi	r26, 0x7A	; 122
     990:	b1 07       	cpc	r27, r17
     992:	d9 f7       	brne	.-10     	; 0x98a <.do_copy_data_loop>

00000994 <__do_clear_bss>:
     994:	10 e0       	ldi	r17, 0x00	; 0
     996:	aa e7       	ldi	r26, 0x7A	; 122
     998:	b0 e0       	ldi	r27, 0x00	; 0
     99a:	01 c0       	rjmp	.+2      	; 0x99e <.do_clear_bss_start>

0000099c <.do_clear_bss_loop>:
     99c:	1d 92       	st	X+, r1

0000099e <.do_clear_bss_start>:
     99e:	a6 38       	cpi	r26, 0x86	; 134
     9a0:	b1 07       	cpc	r27, r17
     9a2:	e1 f7       	brne	.-8      	; 0x99c <.do_clear_bss_loop>
     9a4:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <main>
     9a8:	0c 94 93 0a 	jmp	0x1526	; 0x1526 <_exit>

000009ac <__bad_interrupt>:
     9ac:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000009b0 <lcd_spi_write>:
//#include "graphics.h"


 
void lcd_spi_write(unsigned char hexwrite)  //SPI Init
{
     9b0:	8f b9       	out	0x0f, r24	; 15
	delay_us(1);
	SPDR = hexwrite;				// Daten nach Sender und starten
	// while(!(SPSR & (1<<SPIF)));			// warte bis Bit 1: fertig
	loop_until_bit_is_set(SPSR, SPIF);		// warte bis Bit 1: fertig
     9b2:	77 9b       	sbis	0x0e, 7	; 14
     9b4:	fe cf       	rjmp	.-4      	; 0x9b2 <lcd_spi_write+0x2>
	delay_us(1);
	hexwrite = SPDR;				// SPIF wider 0 (Pseudolesen)
     9b6:	8f b1       	in	r24, 0x0f	; 15
}
     9b8:	08 95       	ret

000009ba <lcd_set_a0>:


void lcd_set_a0(uint8_t type)
{
     9ba:	88 23       	and	r24, r24
     9bc:	11 f0       	breq	.+4      	; 0x9c2 <lcd_set_a0+0x8>
     9be:	c0 98       	cbi	0x18, 0	; 24
     9c0:	08 95       	ret
	if (type) cbi(LCD_DOGM_PORT, LCD_DOGM_A0); // Command (LCD_CMD) // Reg Select: 0 => Instruction Reg (w)
	else      sbi(LCD_DOGM_PORT, LCD_DOGM_A0); // Data (LCD_DATA)	// Reg Select: 1 => Data Reg (w)
     9c2:	c0 9a       	sbi	0x18, 0	; 24
     9c4:	08 95       	ret

000009c6 <lcd_set_cs>:
}


void lcd_set_cs(uint8_t enable)
{
     9c6:	88 23       	and	r24, r24
     9c8:	11 f0       	breq	.+4      	; 0x9ce <lcd_set_cs+0x8>
     9ca:	c1 98       	cbi	0x18, 1	; 24
     9cc:	08 95       	ret
	if (enable) cbi(LCD_DOGM_PORT, LCD_DOGM_CSB);	// DOGM select = LOW
	else 		sbi(LCD_DOGM_PORT, LCD_DOGM_CSB);	// DOGM deselect = HIGH
     9ce:	c1 9a       	sbi	0x18, 1	; 24
     9d0:	08 95       	ret

000009d2 <delay_us>:
	}

}

void delay_us(u32 time_us)
{
     9d2:	08 95       	ret

000009d4 <main>:
	else 		sbi(LCD_DOGM_PORT, LCD_DOGM_CSB);	// DOGM deselect = HIGH
}


int main(void)
{
     9d4:	c2 9a       	sbi	0x18, 2	; 24

	RES_PORT |= (1<<RES_BIT); 
	
	LCD_DOGM_DPORT = 0xff;			// set output
     9d6:	8f ef       	ldi	r24, 0xFF	; 255
     9d8:	87 bb       	out	0x17, r24	; 23
	LCD_DOGM_PORT = 0xff;			// clear LEDS
     9da:	88 bb       	out	0x18, r24	; 24
	sbi(DDRC,7);	
     9dc:	a7 9a       	sbi	0x14, 7	; 20

	SPCR = (1 << SPE) | (1 << MSTR) | (1<<SPR0);	// SPI Master
     9de:	81 e5       	ldi	r24, 0x51	; 81
     9e0:	8d b9       	out	0x0d, r24	; 13
	InitDelay();
     9e2:	0e 94 44 0a 	call	0x1488	; 0x1488 <InitDelay>
	dogm_core_set_remore(&(lcd_spi_write), &(lcd_set_a0), &(lcd_set_cs), &(delay_us)); //SPI Init
     9e6:	29 ee       	ldi	r18, 0xE9	; 233
     9e8:	34 e0       	ldi	r19, 0x04	; 4
     9ea:	43 ee       	ldi	r20, 0xE3	; 227
     9ec:	54 e0       	ldi	r21, 0x04	; 4
     9ee:	6d ed       	ldi	r22, 0xDD	; 221
     9f0:	74 e0       	ldi	r23, 0x04	; 4
     9f2:	88 ed       	ldi	r24, 0xD8	; 216
     9f4:	94 e0       	ldi	r25, 0x04	; 4
     9f6:	0e 94 51 05 	call	0xaa2	; 0xaa2 <dogm_core_set_remore>

	
	rprintfInit(LCD_DisplayChar5_7); // define output function for 5x7 char size
     9fa:	8b ee       	ldi	r24, 0xEB	; 235
     9fc:	95 e0       	ldi	r25, 0x05	; 5
     9fe:	0e 94 55 08 	call	0x10aa	; 0x10aa <rprintfInit>

	Delay(1000); //Inicialization 100ms Default delay is 100us
     a02:	88 ee       	ldi	r24, 0xE8	; 232
     a04:	93 e0       	ldi	r25, 0x03	; 3
     a06:	0e 94 4b 0a 	call	0x1496	; 0x1496 <Delay>


	disp_init();
     a0a:	0e 94 26 08 	call	0x104c	; 0x104c <disp_init>


	LCD_DisplayString5_7("DOGM128-6", 0, 0); 	//Zeile 0     // Befehl aus LCD_ST7565 
     a0e:	40 e0       	ldi	r20, 0x00	; 0
     a10:	60 e0       	ldi	r22, 0x00	; 0
     a12:	80 e6       	ldi	r24, 0x60	; 96
     a14:	90 e0       	ldi	r25, 0x00	; 0
     a16:	0e 94 86 07 	call	0xf0c	; 0xf0c <LCD_DisplayString5_7>
	LCD_DisplayString8_16("   DOGM128-6   ", 6, 0); 	//Zeile 0     // Befehl aus LCD_ST7565 
     a1a:	40 e0       	ldi	r20, 0x00	; 0
     a1c:	66 e0       	ldi	r22, 0x06	; 6
     a1e:	8a e6       	ldi	r24, 0x6A	; 106
     a20:	90 e0       	ldi	r25, 0x00	; 0
     a22:	0e 94 3d 07 	call	0xe7a	; 0xe7a <LCD_DisplayString8_16>
	XY_Goto5_7(2,0);	
     a26:	60 e0       	ldi	r22, 0x00	; 0
     a28:	82 e0       	ldi	r24, 0x02	; 2
     a2a:	0e 94 6a 05 	call	0xad4	; 0xad4 <XY_Goto5_7>
	rprintf("1234567890");                        	// Befehl aus AvrLib, siehe  rprintf.c 
     a2e:	84 e5       	ldi	r24, 0x54	; 84
     a30:	90 e0       	ldi	r25, 0x00	; 0
     a32:	9f 93       	push	r25
     a34:	8f 93       	push	r24
     a36:	81 e0       	ldi	r24, 0x01	; 1
     a38:	8f 93       	push	r24
     a3a:	0e 94 b0 09 	call	0x1360	; 0x1360 <rprintf1RamRom>
	Delay(20000);
     a3e:	80 e2       	ldi	r24, 0x20	; 32
     a40:	9e e4       	ldi	r25, 0x4E	; 78
     a42:	0e 94 4b 0a 	call	0x1496	; 0x1496 <Delay>
	LCD_Draw_Pixel(0,0,1);
     a46:	41 e0       	ldi	r20, 0x01	; 1
     a48:	60 e0       	ldi	r22, 0x00	; 0
     a4a:	80 e0       	ldi	r24, 0x00	; 0
     a4c:	0e 94 06 08 	call	0x100c	; 0x100c <LCD_Draw_Pixel>
     a50:	0f 90       	pop	r0
     a52:	0f 90       	pop	r0
     a54:	0f 90       	pop	r0
     a56:	ff cf       	rjmp	.-2      	; 0xa56 <main+0x82>

00000a58 <dogm_core_write>:
 * \return always void
 * \retval void always
 *
 */
static void dogm_core_write(unsigned char data, lcd_type_t type)
{
     a58:	1f 93       	push	r17
     a5a:	18 2f       	mov	r17, r24
     a5c:	86 2f       	mov	r24, r22
	pset_a0(type);		// select the register
     a5e:	e0 91 7c 00 	lds	r30, 0x007C
     a62:	f0 91 7d 00 	lds	r31, 0x007D
     a66:	09 95       	icall
	pset_cs(1);		// select the lcd
     a68:	e0 91 7e 00 	lds	r30, 0x007E
     a6c:	f0 91 7f 00 	lds	r31, 0x007F
     a70:	81 e0       	ldi	r24, 0x01	; 1
     a72:	09 95       	icall
	pspi_write(data);	// write the data to lcd
     a74:	e0 91 7a 00 	lds	r30, 0x007A
     a78:	f0 91 7b 00 	lds	r31, 0x007B
     a7c:	81 2f       	mov	r24, r17
     a7e:	09 95       	icall
	pdelay_us(30);		// wait for >26.3us
     a80:	e0 91 80 00 	lds	r30, 0x0080
     a84:	f0 91 81 00 	lds	r31, 0x0081
     a88:	6e e1       	ldi	r22, 0x1E	; 30
     a8a:	70 e0       	ldi	r23, 0x00	; 0
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	09 95       	icall
	pset_cs(0);		// deselect the lcd
     a92:	e0 91 7e 00 	lds	r30, 0x007E
     a96:	f0 91 7f 00 	lds	r31, 0x007F
     a9a:	80 e0       	ldi	r24, 0x00	; 0
     a9c:	09 95       	icall
}
     a9e:	1f 91       	pop	r17
     aa0:	08 95       	ret

00000aa2 <dogm_core_set_remore>:
 * \return always void
 * \retval void always
 *
 */
void dogm_core_set_remore(void (*remote_spi_write)(unsigned char), void (*remote_set_a0)(uint8_t), void (*remote_set_cs)(uint8_t), void (*remote_delay_us)(u32))
{
     aa2:	90 93 7b 00 	sts	0x007B, r25
     aa6:	80 93 7a 00 	sts	0x007A, r24
	pspi_write = remote_spi_write;
	pset_a0 = remote_set_a0;
     aaa:	70 93 7d 00 	sts	0x007D, r23
     aae:	60 93 7c 00 	sts	0x007C, r22
	pset_cs = remote_set_cs;
     ab2:	50 93 7f 00 	sts	0x007F, r21
     ab6:	40 93 7e 00 	sts	0x007E, r20
	pdelay_us = remote_delay_us;
     aba:	30 93 81 00 	sts	0x0081, r19
     abe:	20 93 80 00 	sts	0x0080, r18
}
     ac2:	08 95       	ret

00000ac4 <dogm_core_cmd>:
 * \return always void
 * \retval void always
 *
 */
void dogm_core_cmd(char cmd)
{
     ac4:	61 e0       	ldi	r22, 0x01	; 1
     ac6:	0e 94 2c 05 	call	0xa58	; 0xa58 <dogm_core_write>
	dogm_core_write((unsigned char)cmd, LCD_CMD);
}
     aca:	08 95       	ret

00000acc <dogm_core_data>:
 * \return always void
 * \retval void always
 *
 */
void dogm_core_data(char c)
{
     acc:	60 e0       	ldi	r22, 0x00	; 0
     ace:	0e 94 2c 05 	call	0xa58	; 0xa58 <dogm_core_write>
	dogm_core_write((unsigned char)c, LCD_DATA);
}
     ad2:	08 95       	ret

00000ad4 <XY_Goto5_7>:
	xy_adrColumn = xy_adrColumn+8;
}


void XY_Goto5_7(uint8_t adrPage, uint8_t adrColumn) // nach Page 0-7 und Column 0-24 
{
     ad4:	98 2f       	mov	r25, r24
 	xy_adrColumn = adrColumn;
 	xy_adrColumn = ((xy_adrColumn*5)+1);
     ad6:	85 e0       	ldi	r24, 0x05	; 5
     ad8:	68 9f       	mul	r22, r24
     ada:	b0 01       	movw	r22, r0
     adc:	11 24       	eor	r1, r1
     ade:	6f 5f       	subi	r22, 0xFF	; 255
     ae0:	60 93 84 00 	sts	0x0084, r22
	if(xy_adrColumn>= 121)	xy_adrColumn = 121;
     ae4:	69 37       	cpi	r22, 0x79	; 121
     ae6:	18 f0       	brcs	.+6      	; 0xaee <XY_Goto5_7+0x1a>
     ae8:	89 e7       	ldi	r24, 0x79	; 121
     aea:	80 93 84 00 	sts	0x0084, r24
	xy_adrPage   = adrPage;
     aee:	90 93 85 00 	sts	0x0085, r25
	if(xy_adrPage>= 7)		xy_adrPage = 7;
     af2:	97 30       	cpi	r25, 0x07	; 7
     af4:	18 f0       	brcs	.+6      	; 0xafc <XY_Goto5_7+0x28>
     af6:	87 e0       	ldi	r24, 0x07	; 7
     af8:	80 93 85 00 	sts	0x0085, r24
     afc:	08 95       	ret

00000afe <XY_Goto8_16>:
}

void XY_Goto8_16(uint8_t adrPage, uint8_t adrColumn) // nach Page 0-6 und Column 0-15 
{
     afe:	98 2f       	mov	r25, r24
 	xy_adrColumn = adrColumn;
 	xy_adrColumn = (xy_adrColumn*8);
     b00:	70 e0       	ldi	r23, 0x00	; 0
     b02:	83 e0       	ldi	r24, 0x03	; 3
     b04:	66 0f       	add	r22, r22
     b06:	77 1f       	adc	r23, r23
     b08:	8a 95       	dec	r24
     b0a:	e1 f7       	brne	.-8      	; 0xb04 <XY_Goto8_16+0x6>
     b0c:	60 93 84 00 	sts	0x0084, r22
	if(xy_adrColumn>= 120)	xy_adrColumn = 120;
     b10:	68 37       	cpi	r22, 0x78	; 120
     b12:	18 f0       	brcs	.+6      	; 0xb1a <XY_Goto8_16+0x1c>
     b14:	88 e7       	ldi	r24, 0x78	; 120
     b16:	80 93 84 00 	sts	0x0084, r24
	xy_adrPage   = adrPage;
     b1a:	90 93 85 00 	sts	0x0085, r25
	if(xy_adrPage>= 6)		xy_adrPage = 6;
     b1e:	96 30       	cpi	r25, 0x06	; 6
     b20:	18 f0       	brcs	.+6      	; 0xb28 <XY_Goto8_16+0x2a>
     b22:	86 e0       	ldi	r24, 0x06	; 6
     b24:	80 93 85 00 	sts	0x0085, r24
     b28:	08 95       	ret

00000b2a <LCD_SetColumnAddress>:
	Page &= 0x0F;
	dogm_core_cmd(0xB0 | Page);
}

void LCD_SetColumnAddress(uint8_t Column)
{
     b2a:	1f 93       	push	r17
     b2c:	18 2f       	mov	r17, r24
	dogm_core_cmd(0x10 | (Column>>4));
     b2e:	82 95       	swap	r24
     b30:	8f 70       	andi	r24, 0x0F	; 15
     b32:	80 61       	ori	r24, 0x10	; 16
     b34:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>
	dogm_core_cmd(Column & 0x0F);
     b38:	81 2f       	mov	r24, r17
     b3a:	8f 70       	andi	r24, 0x0F	; 15
     b3c:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>
}
     b40:	1f 91       	pop	r17
     b42:	08 95       	ret

00000b44 <LCD_SetPageAddress>:
	LineStart &= 0x3F;
	dogm_core_cmd(0x40 | LineStart);
}

void LCD_SetPageAddress(uint8_t Page)
{
     b44:	8f 70       	andi	r24, 0x0F	; 15
     b46:	80 6b       	ori	r24, 0xB0	; 176
     b48:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>
	Page &= 0x0F;
	dogm_core_cmd(0xB0 | Page);
}
     b4c:	08 95       	ret

00000b4e <LCD_DisplayChar8_16>:
	}
		xy_adrColumn = xy_adrColumn+6;  // Zeichenabstand 6 = ok, 5 fast zu eng, 
}

void LCD_DisplayChar8_16(uint8_t XH_Dig)
{
     b4e:	0f 93       	push	r16
     b50:	1f 93       	push	r17
     b52:	cf 93       	push	r28
     b54:	df 93       	push	r29
    
	uint8_t *dptr;               // dptr_adderss for Dig code.
   	uint8_t i;

   	if(XH_Dig < 0x20) XH_Dig = 0x20;
     b56:	80 32       	cpi	r24, 0x20	; 32
     b58:	08 f4       	brcc	.+2      	; 0xb5c <LCD_DisplayChar8_16+0xe>
     b5a:	80 e2       	ldi	r24, 0x20	; 32
	
   	dptr = &ASCII8_16[(XH_Dig-0x20)*16];
     b5c:	08 2f       	mov	r16, r24
     b5e:	10 e0       	ldi	r17, 0x00	; 0
     b60:	94 e0       	ldi	r25, 0x04	; 4
     b62:	00 0f       	add	r16, r16
     b64:	11 1f       	adc	r17, r17
     b66:	9a 95       	dec	r25
     b68:	e1 f7       	brne	.-8      	; 0xb62 <LCD_DisplayChar8_16+0x14>
     b6a:	01 5c       	subi	r16, 0xC1	; 193
     b6c:	1f 4f       	sbci	r17, 0xFF	; 255
	
	LCD_SetPageAddress(xy_adrPage);
     b6e:	80 91 85 00 	lds	r24, 0x0085
     b72:	0e 94 a2 05 	call	0xb44	; 0xb44 <LCD_SetPageAddress>
	LCD_SetColumnAddress(xy_adrColumn);
     b76:	80 91 84 00 	lds	r24, 0x0084
     b7a:	0e 94 95 05 	call	0xb2a	; 0xb2a <LCD_SetColumnAddress>
     b7e:	c0 e0       	ldi	r28, 0x00	; 0
     b80:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i< 8; i++)
	{
    	dogm_core_data(pgm_read_byte(dptr));
     b82:	f8 01       	movw	r30, r16
     b84:	ec 0f       	add	r30, r28
     b86:	fd 1f       	adc	r31, r29
     b88:	e4 91       	lpm	r30, Z+
     b8a:	8e 2f       	mov	r24, r30
     b8c:	0e 94 66 05 	call	0xacc	; 0xacc <dogm_core_data>
     b90:	21 96       	adiw	r28, 0x01	; 1
	
   	dptr = &ASCII8_16[(XH_Dig-0x20)*16];
	
	LCD_SetPageAddress(xy_adrPage);
	LCD_SetColumnAddress(xy_adrColumn);
	for(i=0; i< 8; i++)
     b92:	c8 30       	cpi	r28, 0x08	; 8
     b94:	d1 05       	cpc	r29, r1
     b96:	a9 f7       	brne	.-22     	; 0xb82 <LCD_DisplayChar8_16+0x34>
     b98:	e8 01       	movw	r28, r16
     b9a:	28 96       	adiw	r28, 0x08	; 8
	{
    	dogm_core_data(pgm_read_byte(dptr));
    	dptr = dptr + 1;
	}

	LCD_SetPageAddress(xy_adrPage+1);
     b9c:	80 91 85 00 	lds	r24, 0x0085
     ba0:	8f 5f       	subi	r24, 0xFF	; 255
     ba2:	0e 94 a2 05 	call	0xb44	; 0xb44 <LCD_SetPageAddress>
	LCD_SetColumnAddress(xy_adrColumn);
     ba6:	80 91 84 00 	lds	r24, 0x0084
     baa:	0e 94 95 05 	call	0xb2a	; 0xb2a <LCD_SetColumnAddress>
	for(i=0; i< 8; i++)
     bae:	00 5f       	subi	r16, 0xF0	; 240
     bb0:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		dogm_core_data(pgm_read_byte(dptr));
     bb2:	fe 01       	movw	r30, r28
     bb4:	84 91       	lpm	r24, Z+
     bb6:	0e 94 66 05 	call	0xacc	; 0xacc <dogm_core_data>
    	dptr = dptr + 1;
     bba:	21 96       	adiw	r28, 0x01	; 1
    	dptr = dptr + 1;
	}

	LCD_SetPageAddress(xy_adrPage+1);
	LCD_SetColumnAddress(xy_adrColumn);
	for(i=0; i< 8; i++)
     bbc:	c0 17       	cp	r28, r16
     bbe:	d1 07       	cpc	r29, r17
     bc0:	c1 f7       	brne	.-16     	; 0xbb2 <LCD_DisplayChar8_16+0x64>
	{
		dogm_core_data(pgm_read_byte(dptr));
    	dptr = dptr + 1;
	}
	xy_adrColumn = xy_adrColumn+8;
     bc2:	80 91 84 00 	lds	r24, 0x0084
     bc6:	88 5f       	subi	r24, 0xF8	; 248
     bc8:	80 93 84 00 	sts	0x0084, r24
}
     bcc:	df 91       	pop	r29
     bce:	cf 91       	pop	r28
     bd0:	1f 91       	pop	r17
     bd2:	0f 91       	pop	r16
     bd4:	08 95       	ret

00000bd6 <LCD_DisplayChar5_7>:
	
	return TRUE;
}

void LCD_DisplayChar5_7(uint8_t XH_Dig)
{
     bd6:	0f 93       	push	r16
     bd8:	1f 93       	push	r17
     bda:	cf 93       	push	r28
     bdc:	df 93       	push	r29
     bde:	e8 2f       	mov	r30, r24
    
	uint8_t *dptr;               // dptr_adderss for Dig code.
   	uint8_t i;

   	if(XH_Dig < 0x20) XH_Dig = 0x20;
     be0:	80 32       	cpi	r24, 0x20	; 32
     be2:	08 f4       	brcc	.+2      	; 0xbe6 <LCD_DisplayChar5_7+0x10>
     be4:	e0 e2       	ldi	r30, 0x20	; 32
   	dptr = &ASCII5_7[(XH_Dig-0x20)*5];
     be6:	85 e0       	ldi	r24, 0x05	; 5
     be8:	e8 9f       	mul	r30, r24
     bea:	80 01       	movw	r16, r0
     bec:	11 24       	eor	r1, r1
     bee:	01 54       	subi	r16, 0x41	; 65
     bf0:	10 40       	sbci	r17, 0x00	; 0
	LCD_SetPageAddress(xy_adrPage);
     bf2:	80 91 85 00 	lds	r24, 0x0085
     bf6:	0e 94 a2 05 	call	0xb44	; 0xb44 <LCD_SetPageAddress>
	LCD_SetColumnAddress(xy_adrColumn);
     bfa:	80 91 84 00 	lds	r24, 0x0084
     bfe:	0e 94 95 05 	call	0xb2a	; 0xb2a <LCD_SetColumnAddress>
     c02:	c0 e0       	ldi	r28, 0x00	; 0
     c04:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i< 5; i++)
	{
    	dogm_core_data(pgm_read_byte(dptr));
     c06:	f8 01       	movw	r30, r16
     c08:	ec 0f       	add	r30, r28
     c0a:	fd 1f       	adc	r31, r29
     c0c:	e4 91       	lpm	r30, Z+
     c0e:	8e 2f       	mov	r24, r30
     c10:	0e 94 66 05 	call	0xacc	; 0xacc <dogm_core_data>
     c14:	21 96       	adiw	r28, 0x01	; 1

   	if(XH_Dig < 0x20) XH_Dig = 0x20;
   	dptr = &ASCII5_7[(XH_Dig-0x20)*5];
	LCD_SetPageAddress(xy_adrPage);
	LCD_SetColumnAddress(xy_adrColumn);
	for(i=0; i< 5; i++)
     c16:	c5 30       	cpi	r28, 0x05	; 5
     c18:	d1 05       	cpc	r29, r1
     c1a:	a9 f7       	brne	.-22     	; 0xc06 <LCD_DisplayChar5_7+0x30>
	{
    	dogm_core_data(pgm_read_byte(dptr));
    	dptr = dptr + 1;
	}
		xy_adrColumn = xy_adrColumn+6;  // Zeichenabstand 6 = ok, 5 fast zu eng, 
     c1c:	80 91 84 00 	lds	r24, 0x0084
     c20:	8a 5f       	subi	r24, 0xFA	; 250
     c22:	80 93 84 00 	sts	0x0084, r24
}
     c26:	df 91       	pop	r29
     c28:	cf 91       	pop	r28
     c2a:	1f 91       	pop	r17
     c2c:	0f 91       	pop	r16
     c2e:	08 95       	ret

00000c30 <LCD_DisplayPicture>:
//-----------------------------------------------------------------------
// LCD_DisplayPicture
// Picture Size: Hight*Weight
//-----------------------------------------------------------------------
uint8_t LCD_DisplayPicture(char *Picture, uint8_t adrPage, uint8_t adrColumn,uint8_t Weight, uint8_t Hight)
{
     c30:	bf 92       	push	r11
     c32:	cf 92       	push	r12
     c34:	df 92       	push	r13
     c36:	ef 92       	push	r14
     c38:	ff 92       	push	r15
     c3a:	0f 93       	push	r16
     c3c:	1f 93       	push	r17
     c3e:	fc 01       	movw	r30, r24
     c40:	b6 2e       	mov	r11, r22
     c42:	c4 2e       	mov	r12, r20
     c44:	d2 2e       	mov	r13, r18
     c46:	e0 2e       	mov	r14, r16
	uint8_t *dptr;               // dptr_adderss for Dig code.
   	uint8_t i, j;

	if((adrPage+Hight)>MAX_PAGE) 		return FALSE;
     c48:	86 2f       	mov	r24, r22
     c4a:	90 e0       	ldi	r25, 0x00	; 0
     c4c:	80 0f       	add	r24, r16
     c4e:	91 1d       	adc	r25, r1
     c50:	09 97       	sbiw	r24, 0x09	; 9
     c52:	f4 f4       	brge	.+60     	; 0xc90 <LCD_DisplayPicture+0x60>
	if((adrColumn+Weight)>MAX_COLUMN) 	return FALSE;
     c54:	84 2f       	mov	r24, r20
     c56:	90 e0       	ldi	r25, 0x00	; 0
     c58:	82 0f       	add	r24, r18
     c5a:	91 1d       	adc	r25, r1
     c5c:	81 38       	cpi	r24, 0x81	; 129
     c5e:	91 05       	cpc	r25, r1
     c60:	bc f4       	brge	.+46     	; 0xc90 <LCD_DisplayPicture+0x60>
     c62:	00 e0       	ldi	r16, 0x00	; 0
	{
		LCD_SetPageAddress(adrPage+i);
		LCD_SetColumnAddress(adrColumn);
		for(j=0; j<Weight; j++)
		{
			dogm_core_data(pgm_read_byte(dptr));
     c64:	f4 90       	lpm	r15, Z+
     c66:	10 c0       	rjmp	.+32     	; 0xc88 <LCD_DisplayPicture+0x58>
	
	dptr = (uint8_t *)Picture;
	
	for(i=0; i<Hight; i++)
	{
		LCD_SetPageAddress(adrPage+i);
     c68:	80 2f       	mov	r24, r16
     c6a:	8b 0d       	add	r24, r11
     c6c:	0e 94 a2 05 	call	0xb44	; 0xb44 <LCD_SetPageAddress>
		LCD_SetColumnAddress(adrColumn);
     c70:	8c 2d       	mov	r24, r12
     c72:	0e 94 95 05 	call	0xb2a	; 0xb2a <LCD_SetColumnAddress>
     c76:	10 e0       	ldi	r17, 0x00	; 0
     c78:	04 c0       	rjmp	.+8      	; 0xc82 <LCD_DisplayPicture+0x52>
		for(j=0; j<Weight; j++)
		{
			dogm_core_data(pgm_read_byte(dptr));
     c7a:	8f 2d       	mov	r24, r15
     c7c:	0e 94 66 05 	call	0xacc	; 0xacc <dogm_core_data>
	
	for(i=0; i<Hight; i++)
	{
		LCD_SetPageAddress(adrPage+i);
		LCD_SetColumnAddress(adrColumn);
		for(j=0; j<Weight; j++)
     c80:	1f 5f       	subi	r17, 0xFF	; 255
     c82:	1d 15       	cp	r17, r13
     c84:	d0 f3       	brcs	.-12     	; 0xc7a <LCD_DisplayPicture+0x4a>
	if((adrPage+Hight)>MAX_PAGE) 		return FALSE;
	if((adrColumn+Weight)>MAX_COLUMN) 	return FALSE;
	
	dptr = (uint8_t *)Picture;
	
	for(i=0; i<Hight; i++)
     c86:	0f 5f       	subi	r16, 0xFF	; 255
     c88:	0e 15       	cp	r16, r14
     c8a:	70 f3       	brcs	.-36     	; 0xc68 <LCD_DisplayPicture+0x38>
     c8c:	8f ef       	ldi	r24, 0xFF	; 255
     c8e:	01 c0       	rjmp	.+2      	; 0xc92 <LCD_DisplayPicture+0x62>
     c90:	80 e0       	ldi	r24, 0x00	; 0
			dogm_core_data(pgm_read_byte(dptr));
		}
	}
	
	return TRUE;
}
     c92:	1f 91       	pop	r17
     c94:	0f 91       	pop	r16
     c96:	ff 90       	pop	r15
     c98:	ef 90       	pop	r14
     c9a:	df 90       	pop	r13
     c9c:	cf 90       	pop	r12
     c9e:	bf 90       	pop	r11
     ca0:	08 95       	ret

00000ca2 <LCD_DisplayASCII8_16>:
	}
	

} 
void LCD_DisplayASCII8_16(uint8_t XH_Dig, uint8_t adrPage, uint8_t adrColumn)
{
     ca2:	ef 92       	push	r14
     ca4:	ff 92       	push	r15
     ca6:	0f 93       	push	r16
     ca8:	1f 93       	push	r17
     caa:	cf 93       	push	r28
     cac:	df 93       	push	r29
     cae:	f6 2e       	mov	r15, r22
     cb0:	e4 2e       	mov	r14, r20
   	uint8_t *dptr;               // dptr_adderss for Dig code.
   	uint8_t i;

   	if(XH_Dig < 0x20) XH_Dig = 0x20;
     cb2:	80 32       	cpi	r24, 0x20	; 32
     cb4:	08 f4       	brcc	.+2      	; 0xcb8 <LCD_DisplayASCII8_16+0x16>
     cb6:	80 e2       	ldi	r24, 0x20	; 32
	
   	dptr = &ASCII8_16[(XH_Dig-0x20)*16];
     cb8:	08 2f       	mov	r16, r24
     cba:	10 e0       	ldi	r17, 0x00	; 0
     cbc:	24 e0       	ldi	r18, 0x04	; 4
     cbe:	00 0f       	add	r16, r16
     cc0:	11 1f       	adc	r17, r17
     cc2:	2a 95       	dec	r18
     cc4:	e1 f7       	brne	.-8      	; 0xcbe <LCD_DisplayASCII8_16+0x1c>
     cc6:	01 5c       	subi	r16, 0xC1	; 193
     cc8:	1f 4f       	sbci	r17, 0xFF	; 255
	
	LCD_SetPageAddress(adrPage);
     cca:	8f 2d       	mov	r24, r15
     ccc:	0e 94 a2 05 	call	0xb44	; 0xb44 <LCD_SetPageAddress>
	LCD_SetColumnAddress(adrColumn);
     cd0:	8e 2d       	mov	r24, r14
     cd2:	0e 94 95 05 	call	0xb2a	; 0xb2a <LCD_SetColumnAddress>
     cd6:	c0 e0       	ldi	r28, 0x00	; 0
     cd8:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i< 8; i++)
	{
    	dogm_core_data(pgm_read_byte(dptr));
     cda:	f8 01       	movw	r30, r16
     cdc:	ec 0f       	add	r30, r28
     cde:	fd 1f       	adc	r31, r29
     ce0:	e4 91       	lpm	r30, Z+
     ce2:	8e 2f       	mov	r24, r30
     ce4:	0e 94 66 05 	call	0xacc	; 0xacc <dogm_core_data>
     ce8:	21 96       	adiw	r28, 0x01	; 1
	
   	dptr = &ASCII8_16[(XH_Dig-0x20)*16];
	
	LCD_SetPageAddress(adrPage);
	LCD_SetColumnAddress(adrColumn);
	for(i=0; i< 8; i++)
     cea:	c8 30       	cpi	r28, 0x08	; 8
     cec:	d1 05       	cpc	r29, r1
     cee:	a9 f7       	brne	.-22     	; 0xcda <LCD_DisplayASCII8_16+0x38>
     cf0:	e8 01       	movw	r28, r16
     cf2:	28 96       	adiw	r28, 0x08	; 8
	{
    	dogm_core_data(pgm_read_byte(dptr));
    	dptr = dptr + 1;
	}
	
	LCD_SetPageAddress(adrPage+1);
     cf4:	8f 2d       	mov	r24, r15
     cf6:	8f 5f       	subi	r24, 0xFF	; 255
     cf8:	0e 94 a2 05 	call	0xb44	; 0xb44 <LCD_SetPageAddress>
	LCD_SetColumnAddress(adrColumn);
     cfc:	8e 2d       	mov	r24, r14
     cfe:	0e 94 95 05 	call	0xb2a	; 0xb2a <LCD_SetColumnAddress>
	for(i=0; i< 8; i++)
     d02:	00 5f       	subi	r16, 0xF0	; 240
     d04:	1f 4f       	sbci	r17, 0xFF	; 255
	{
    	dogm_core_data(pgm_read_byte(dptr));
     d06:	fe 01       	movw	r30, r28
     d08:	84 91       	lpm	r24, Z+
     d0a:	0e 94 66 05 	call	0xacc	; 0xacc <dogm_core_data>
    	dptr = dptr + 1;
     d0e:	21 96       	adiw	r28, 0x01	; 1
    	dptr = dptr + 1;
	}
	
	LCD_SetPageAddress(adrPage+1);
	LCD_SetColumnAddress(adrColumn);
	for(i=0; i< 8; i++)
     d10:	c0 17       	cp	r28, r16
     d12:	d1 07       	cpc	r29, r17
     d14:	c1 f7       	brne	.-16     	; 0xd06 <LCD_DisplayASCII8_16+0x64>
	{
    	dogm_core_data(pgm_read_byte(dptr));
    	dptr = dptr + 1;
	}
} 
     d16:	df 91       	pop	r29
     d18:	cf 91       	pop	r28
     d1a:	1f 91       	pop	r17
     d1c:	0f 91       	pop	r16
     d1e:	ff 90       	pop	r15
     d20:	ef 90       	pop	r14
     d22:	08 95       	ret

00000d24 <LCD_DisplayASCII5_7>:
//-----------------------------------------------------------------------------
// LCD  : lcd Display ASCII.
// Size : 8X16
//-----------------------------------------------------------------------------
void LCD_DisplayASCII5_7(uint8_t XH_Dig, uint8_t adrPage, uint8_t adrColumn)
{
     d24:	ff 92       	push	r15
     d26:	0f 93       	push	r16
     d28:	1f 93       	push	r17
     d2a:	cf 93       	push	r28
     d2c:	df 93       	push	r29
     d2e:	e8 2f       	mov	r30, r24
     d30:	f4 2e       	mov	r15, r20
   	uint8_t *dptr;               // dptr_adderss for Dig code.
   	uint8_t i;

   	if(XH_Dig < 0x20) XH_Dig = 0x20;
     d32:	80 32       	cpi	r24, 0x20	; 32
     d34:	08 f4       	brcc	.+2      	; 0xd38 <LCD_DisplayASCII5_7+0x14>
     d36:	e0 e2       	ldi	r30, 0x20	; 32
	
   	dptr = &ASCII5_7[(XH_Dig-0x20)*5];
     d38:	85 e0       	ldi	r24, 0x05	; 5
     d3a:	e8 9f       	mul	r30, r24
     d3c:	80 01       	movw	r16, r0
     d3e:	11 24       	eor	r1, r1
     d40:	01 54       	subi	r16, 0x41	; 65
     d42:	10 40       	sbci	r17, 0x00	; 0
	
	LCD_SetPageAddress(adrPage);
     d44:	86 2f       	mov	r24, r22
     d46:	0e 94 a2 05 	call	0xb44	; 0xb44 <LCD_SetPageAddress>
	LCD_SetColumnAddress(adrColumn);
     d4a:	8f 2d       	mov	r24, r15
     d4c:	0e 94 95 05 	call	0xb2a	; 0xb2a <LCD_SetColumnAddress>
     d50:	c0 e0       	ldi	r28, 0x00	; 0
     d52:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i< 5; i++)
	{
    	dogm_core_data(pgm_read_byte(dptr));
     d54:	f8 01       	movw	r30, r16
     d56:	ec 0f       	add	r30, r28
     d58:	fd 1f       	adc	r31, r29
     d5a:	e4 91       	lpm	r30, Z+
     d5c:	8e 2f       	mov	r24, r30
     d5e:	0e 94 66 05 	call	0xacc	; 0xacc <dogm_core_data>
     d62:	21 96       	adiw	r28, 0x01	; 1
	
   	dptr = &ASCII5_7[(XH_Dig-0x20)*5];
	
	LCD_SetPageAddress(adrPage);
	LCD_SetColumnAddress(adrColumn);
	for(i=0; i< 5; i++)
     d64:	c5 30       	cpi	r28, 0x05	; 5
     d66:	d1 05       	cpc	r29, r1
     d68:	a9 f7       	brne	.-22     	; 0xd54 <LCD_DisplayASCII5_7+0x30>
    	dogm_core_data(pgm_read_byte(dptr));
    	dptr = dptr + 1;
	}
	

} 
     d6a:	df 91       	pop	r29
     d6c:	cf 91       	pop	r28
     d6e:	1f 91       	pop	r17
     d70:	0f 91       	pop	r16
     d72:	ff 90       	pop	r15
     d74:	08 95       	ret

00000d76 <LCD_DisplayHZ>:
//-----------------------------------------------------------------------------
// LCD : Display Chinese.
// Size: 16x16
//-----------------------------------------------------------------------------
 uint8_t LCD_DisplayHZ(char* XH_HZ, uint8_t adrPage, uint8_t adrColumn)
{
     d76:	cf 92       	push	r12
     d78:	df 92       	push	r13
     d7a:	ef 92       	push	r14
     d7c:	ff 92       	push	r15
     d7e:	0f 93       	push	r16
     d80:	1f 93       	push	r17
     d82:	cf 93       	push	r28
     d84:	df 93       	push	r29
     d86:	fc 01       	movw	r30, r24
     d88:	d6 2e       	mov	r13, r22
     d8a:	c4 2e       	mov	r12, r20
   	uint8_t *dptr;               // dptr_adderss for HZ code.
   	uint8_t i, j;
	char charH, charL;

	charH = *XH_HZ++;
     d8c:	60 81       	ld	r22, Z
	charL = *XH_HZ;
     d8e:	51 81       	ldd	r21, Z+1	; 0x01
     d90:	20 e0       	ldi	r18, 0x00	; 0
     d92:	30 e0       	ldi	r19, 0x00	; 0
     d94:	42 2f       	mov	r20, r18
	
    for(j=0; j<sizeof(HZ_Table)/sizeof(HZ_t); j++)
    {
    	dptr = &HZ_Table[j].Hz_Data[0];
        if(charH == pgm_read_byte(dptr) && charL == pgm_read_byte(dptr+1))
     d96:	c9 01       	movw	r24, r18
     d98:	fc 01       	movw	r30, r24
     d9a:	15 e0       	ldi	r17, 0x05	; 5
     d9c:	ee 0f       	add	r30, r30
     d9e:	ff 1f       	adc	r31, r31
     da0:	1a 95       	dec	r17
     da2:	e1 f7       	brne	.-8      	; 0xd9c <LCD_DisplayHZ+0x26>
     da4:	88 0f       	add	r24, r24
     da6:	99 1f       	adc	r25, r25
     da8:	e8 0f       	add	r30, r24
     daa:	f9 1f       	adc	r31, r25
     dac:	e1 5d       	subi	r30, 0xD1	; 209
     dae:	f7 4f       	sbci	r31, 0xF7	; 247
     db0:	e4 91       	lpm	r30, Z+
     db2:	6e 17       	cp	r22, r30
     db4:	81 f4       	brne	.+32     	; 0xdd6 <LCD_DisplayHZ+0x60>
     db6:	c9 01       	movw	r24, r18
     db8:	fc 01       	movw	r30, r24
     dba:	a5 e0       	ldi	r26, 0x05	; 5
     dbc:	ee 0f       	add	r30, r30
     dbe:	ff 1f       	adc	r31, r31
     dc0:	aa 95       	dec	r26
     dc2:	e1 f7       	brne	.-8      	; 0xdbc <LCD_DisplayHZ+0x46>
     dc4:	88 0f       	add	r24, r24
     dc6:	99 1f       	adc	r25, r25
     dc8:	e8 0f       	add	r30, r24
     dca:	f9 1f       	adc	r31, r25
     dcc:	e0 5d       	subi	r30, 0xD0	; 208
     dce:	f7 4f       	sbci	r31, 0xF7	; 247
     dd0:	e4 91       	lpm	r30, Z+
     dd2:	5e 17       	cp	r21, r30
     dd4:	51 f0       	breq	.+20     	; 0xdea <LCD_DisplayHZ+0x74>
            break;
     dd6:	4f 5f       	subi	r20, 0xFF	; 255
     dd8:	2f 5f       	subi	r18, 0xFF	; 255
     dda:	3f 4f       	sbci	r19, 0xFF	; 255
	char charH, charL;

	charH = *XH_HZ++;
	charL = *XH_HZ;
	
    for(j=0; j<sizeof(HZ_Table)/sizeof(HZ_t); j++)
     ddc:	29 30       	cpi	r18, 0x09	; 9
     dde:	31 05       	cpc	r19, r1
     de0:	c9 f6       	brne	.-78     	; 0xd94 <LCD_DisplayHZ+0x1e>
    {
    	dptr = &HZ_Table[j].Hz_Data[0];
        if(charH == pgm_read_byte(dptr) && charL == pgm_read_byte(dptr+1))
            break;
    }
	if(j<sizeof(HZ_Table)/sizeof(HZ_t))
     de2:	49 30       	cpi	r20, 0x09	; 9
     de4:	10 f0       	brcs	.+4      	; 0xdea <LCD_DisplayHZ+0x74>
     de6:	80 e0       	ldi	r24, 0x00	; 0
     de8:	3f c0       	rjmp	.+126    	; 0xe68 <LCD_DisplayHZ+0xf2>
   		dptr = HZ_Table[j].Table;
     dea:	e4 2e       	mov	r14, r20
     dec:	ff 24       	eor	r15, r15
     dee:	87 01       	movw	r16, r14
     df0:	64 e0       	ldi	r22, 0x04	; 4
     df2:	00 0f       	add	r16, r16
     df4:	11 1f       	adc	r17, r17
     df6:	6a 95       	dec	r22
     df8:	e1 f7       	brne	.-8      	; 0xdf2 <LCD_DisplayHZ+0x7c>
     dfa:	0e 0d       	add	r16, r14
     dfc:	1f 1d       	adc	r17, r15
     dfe:	00 0f       	add	r16, r16
     e00:	11 1f       	adc	r17, r17
     e02:	0f 5c       	subi	r16, 0xCF	; 207
     e04:	17 4f       	sbci	r17, 0xF7	; 247
	else 
		return FALSE;
	
	LCD_SetPageAddress(adrPage); 
     e06:	8d 2d       	mov	r24, r13
     e08:	0e 94 a2 05 	call	0xb44	; 0xb44 <LCD_SetPageAddress>
    LCD_SetColumnAddress(adrColumn);
     e0c:	8c 2d       	mov	r24, r12
     e0e:	0e 94 95 05 	call	0xb2a	; 0xb2a <LCD_SetColumnAddress>
     e12:	c0 e0       	ldi	r28, 0x00	; 0
     e14:	d0 e0       	ldi	r29, 0x00	; 0
   	for(i=0; i< 16; i++)    
  	{
     	dogm_core_data(pgm_read_byte(dptr));
     e16:	f8 01       	movw	r30, r16
     e18:	ec 0f       	add	r30, r28
     e1a:	fd 1f       	adc	r31, r29
     e1c:	e4 91       	lpm	r30, Z+
     e1e:	8e 2f       	mov	r24, r30
     e20:	0e 94 66 05 	call	0xacc	; 0xacc <dogm_core_data>
     e24:	21 96       	adiw	r28, 0x01	; 1
	else 
		return FALSE;
	
	LCD_SetPageAddress(adrPage); 
    LCD_SetColumnAddress(adrColumn);
   	for(i=0; i< 16; i++)    
     e26:	c0 31       	cpi	r28, 0x10	; 16
     e28:	d1 05       	cpc	r29, r1
     e2a:	a9 f7       	brne	.-22     	; 0xe16 <LCD_DisplayHZ+0xa0>
     e2c:	e7 01       	movw	r28, r14
     e2e:	45 e0       	ldi	r20, 0x05	; 5
     e30:	cc 0f       	add	r28, r28
     e32:	dd 1f       	adc	r29, r29
     e34:	4a 95       	dec	r20
     e36:	e1 f7       	brne	.-8      	; 0xe30 <LCD_DisplayHZ+0xba>
     e38:	ee 0c       	add	r14, r14
     e3a:	ff 1c       	adc	r15, r15
     e3c:	ce 0d       	add	r28, r14
     e3e:	df 1d       	adc	r29, r15
     e40:	cf 5b       	subi	r28, 0xBF	; 191
     e42:	d7 4f       	sbci	r29, 0xF7	; 247
  	{
     	dogm_core_data(pgm_read_byte(dptr));
     	dptr ++;
  	}
	
	LCD_SetPageAddress(adrPage+1); 
     e44:	8d 2d       	mov	r24, r13
     e46:	8f 5f       	subi	r24, 0xFF	; 255
     e48:	0e 94 a2 05 	call	0xb44	; 0xb44 <LCD_SetPageAddress>
    LCD_SetColumnAddress(adrColumn);
     e4c:	8c 2d       	mov	r24, r12
     e4e:	0e 94 95 05 	call	0xb2a	; 0xb2a <LCD_SetColumnAddress>
    for(i=0; i< 16; i++)    
     e52:	00 5e       	subi	r16, 0xE0	; 224
     e54:	1f 4f       	sbci	r17, 0xFF	; 255
  	{
     	dogm_core_data(pgm_read_byte(dptr));
     e56:	fe 01       	movw	r30, r28
     e58:	84 91       	lpm	r24, Z+
     e5a:	0e 94 66 05 	call	0xacc	; 0xacc <dogm_core_data>
     	dptr ++;
     e5e:	21 96       	adiw	r28, 0x01	; 1
     	dptr ++;
  	}
	
	LCD_SetPageAddress(adrPage+1); 
    LCD_SetColumnAddress(adrColumn);
    for(i=0; i< 16; i++)    
     e60:	c0 17       	cp	r28, r16
     e62:	d1 07       	cpc	r29, r17
     e64:	c1 f7       	brne	.-16     	; 0xe56 <LCD_DisplayHZ+0xe0>
     e66:	8f ef       	ldi	r24, 0xFF	; 255
     	dogm_core_data(pgm_read_byte(dptr));
     	dptr ++;
  	}

    return TRUE;
}
     e68:	df 91       	pop	r29
     e6a:	cf 91       	pop	r28
     e6c:	1f 91       	pop	r17
     e6e:	0f 91       	pop	r16
     e70:	ff 90       	pop	r15
     e72:	ef 90       	pop	r14
     e74:	df 90       	pop	r13
     e76:	cf 90       	pop	r12
     e78:	08 95       	ret

00000e7a <LCD_DisplayString8_16>:
	
    return uLen;
}

uint8_t LCD_DisplayString8_16(char *String, uint8_t adrPage, uint8_t adrColumn)
{
     e7a:	af 92       	push	r10
     e7c:	bf 92       	push	r11
     e7e:	df 92       	push	r13
     e80:	ef 92       	push	r14
     e82:	ff 92       	push	r15
     e84:	0f 93       	push	r16
     e86:	1f 93       	push	r17
     e88:	df 93       	push	r29
     e8a:	cf 93       	push	r28
     e8c:	00 d0       	rcall	.+0      	; 0xe8e <LCD_DisplayString8_16+0x14>
     e8e:	cd b7       	in	r28, 0x3d	; 61
     e90:	de b7       	in	r29, 0x3e	; 62
     e92:	7c 01       	movw	r14, r24
    char cData[2];
    uint8_t uLen,uPage,uCol;
	
	uLen = strlen(String);
     e94:	fc 01       	movw	r30, r24
     e96:	01 90       	ld	r0, Z+
     e98:	00 20       	and	r0, r0
     e9a:	e9 f7       	brne	.-6      	; 0xe96 <LCD_DisplayString8_16+0x1c>
     e9c:	31 97       	sbiw	r30, 0x01	; 1
     e9e:	de 2e       	mov	r13, r30
     ea0:	d8 1a       	sub	r13, r24
     ea2:	06 2f       	mov	r16, r22
     ea4:	14 2f       	mov	r17, r20
			uLen --;
		}
		else
		{
			cData[1] = *String++;
			LCD_DisplayHZ(cData,  uPage, uCol);
     ea6:	5e 01       	movw	r10, r28
     ea8:	08 94       	sec
     eaa:	a1 1c       	adc	r10, r1
     eac:	b1 1c       	adc	r11, r1
     eae:	1f c0       	rjmp	.+62     	; 0xeee <LCD_DisplayString8_16+0x74>
    uPage = adrPage;
    uCol = adrColumn;

    while(uLen)
    {
        cData[0] = *String++;
     eb0:	f7 01       	movw	r30, r14
     eb2:	81 91       	ld	r24, Z+
     eb4:	7f 01       	movw	r14, r30
     eb6:	89 83       	std	Y+1, r24	; 0x01
		if(cData[0] <= 0x80)
     eb8:	81 38       	cpi	r24, 0x81	; 129
     eba:	38 f4       	brcc	.+14     	; 0xeca <LCD_DisplayString8_16+0x50>
		{
			LCD_DisplayASCII8_16(cData[0], uPage, uCol);
     ebc:	41 2f       	mov	r20, r17
     ebe:	60 2f       	mov	r22, r16
     ec0:	0e 94 51 06 	call	0xca2	; 0xca2 <LCD_DisplayASCII8_16>
			uCol += 8;
     ec4:	18 5f       	subi	r17, 0xF8	; 248
			uLen --;
     ec6:	da 94       	dec	r13
     ec8:	0b c0       	rjmp	.+22     	; 0xee0 <LCD_DisplayString8_16+0x66>
		}
		else
		{
			cData[1] = *String++;
     eca:	81 91       	ld	r24, Z+
     ecc:	7f 01       	movw	r14, r30
     ece:	8a 83       	std	Y+2, r24	; 0x02
			LCD_DisplayHZ(cData,  uPage, uCol);
     ed0:	41 2f       	mov	r20, r17
     ed2:	60 2f       	mov	r22, r16
     ed4:	c5 01       	movw	r24, r10
     ed6:	0e 94 bb 06 	call	0xd76	; 0xd76 <LCD_DisplayHZ>
			uCol += 16;
     eda:	10 5f       	subi	r17, 0xF0	; 240
			uLen -= 2;
     edc:	fe ef       	ldi	r31, 0xFE	; 254
     ede:	df 0e       	add	r13, r31
		}
		
		if(uCol >= MAX_COLUMN)
     ee0:	17 ff       	sbrs	r17, 7
     ee2:	05 c0       	rjmp	.+10     	; 0xeee <LCD_DisplayString8_16+0x74>
		{
			uCol = 0;
			uPage += 2;
     ee4:	0e 5f       	subi	r16, 0xFE	; 254
			if(uPage >= MAX_PAGE)
     ee6:	08 30       	cpi	r16, 0x08	; 8
     ee8:	08 f0       	brcs	.+2      	; 0xeec <LCD_DisplayString8_16+0x72>
     eea:	00 e0       	ldi	r16, 0x00	; 0
     eec:	10 e0       	ldi	r17, 0x00	; 0
	
	uLen = strlen(String);
    uPage = adrPage;
    uCol = adrColumn;

    while(uLen)
     eee:	dd 20       	and	r13, r13
     ef0:	f9 f6       	brne	.-66     	; 0xeb0 <LCD_DisplayString8_16+0x36>
				uPage = 0;
		}
	}
	
    return uLen;
}
     ef2:	80 e0       	ldi	r24, 0x00	; 0
     ef4:	0f 90       	pop	r0
     ef6:	0f 90       	pop	r0
     ef8:	cf 91       	pop	r28
     efa:	df 91       	pop	r29
     efc:	1f 91       	pop	r17
     efe:	0f 91       	pop	r16
     f00:	ff 90       	pop	r15
     f02:	ef 90       	pop	r14
     f04:	df 90       	pop	r13
     f06:	bf 90       	pop	r11
     f08:	af 90       	pop	r10
     f0a:	08 95       	ret

00000f0c <LCD_DisplayString5_7>:
// LCD  : lcd Display String.
// ASCII(8*16)
//-----------------------------------------------------------------------------

uint8_t LCD_DisplayString5_7(char *String, uint8_t adrPage, uint8_t adrColumn)
{
     f0c:	af 92       	push	r10
     f0e:	bf 92       	push	r11
     f10:	df 92       	push	r13
     f12:	ef 92       	push	r14
     f14:	ff 92       	push	r15
     f16:	0f 93       	push	r16
     f18:	1f 93       	push	r17
     f1a:	df 93       	push	r29
     f1c:	cf 93       	push	r28
     f1e:	00 d0       	rcall	.+0      	; 0xf20 <LCD_DisplayString5_7+0x14>
     f20:	cd b7       	in	r28, 0x3d	; 61
     f22:	de b7       	in	r29, 0x3e	; 62
     f24:	7c 01       	movw	r14, r24
    char cData[2];
    uint8_t uLen,uPage,uCol;
	
	uLen = strlen(String);
     f26:	fc 01       	movw	r30, r24
     f28:	01 90       	ld	r0, Z+
     f2a:	00 20       	and	r0, r0
     f2c:	e9 f7       	brne	.-6      	; 0xf28 <LCD_DisplayString5_7+0x1c>
     f2e:	31 97       	sbiw	r30, 0x01	; 1
     f30:	de 2e       	mov	r13, r30
     f32:	d8 1a       	sub	r13, r24
     f34:	14 2f       	mov	r17, r20
     f36:	06 2f       	mov	r16, r22
			uLen --;
		}
		else
		{
			cData[1] = *String++;
			LCD_DisplayHZ(cData,  uPage, uCol);
     f38:	5e 01       	movw	r10, r28
     f3a:	08 94       	sec
     f3c:	a1 1c       	adc	r10, r1
     f3e:	b1 1c       	adc	r11, r1
     f40:	21 c0       	rjmp	.+66     	; 0xf84 <LCD_DisplayString5_7+0x78>
    uPage = adrPage;
    uCol = adrColumn;

    while(uLen)
    {
        cData[0] = *String++;
     f42:	f7 01       	movw	r30, r14
     f44:	81 91       	ld	r24, Z+
     f46:	7f 01       	movw	r14, r30
     f48:	89 83       	std	Y+1, r24	; 0x01
		if(cData[0] <= 0x80)
     f4a:	81 38       	cpi	r24, 0x81	; 129
     f4c:	38 f4       	brcc	.+14     	; 0xf5c <LCD_DisplayString5_7+0x50>
		{
			LCD_DisplayASCII5_7(cData[0], uPage, uCol);
     f4e:	41 2f       	mov	r20, r17
     f50:	60 2f       	mov	r22, r16
     f52:	0e 94 92 06 	call	0xd24	; 0xd24 <LCD_DisplayASCII5_7>
			uCol += 6;
     f56:	1a 5f       	subi	r17, 0xFA	; 250
			uLen --;
     f58:	da 94       	dec	r13
     f5a:	0b c0       	rjmp	.+22     	; 0xf72 <LCD_DisplayString5_7+0x66>
		}
		else
		{
			cData[1] = *String++;
     f5c:	81 91       	ld	r24, Z+
     f5e:	7f 01       	movw	r14, r30
     f60:	8a 83       	std	Y+2, r24	; 0x02
			LCD_DisplayHZ(cData,  uPage, uCol);
     f62:	41 2f       	mov	r20, r17
     f64:	60 2f       	mov	r22, r16
     f66:	c5 01       	movw	r24, r10
     f68:	0e 94 bb 06 	call	0xd76	; 0xd76 <LCD_DisplayHZ>
			uCol += 16;
     f6c:	10 5f       	subi	r17, 0xF0	; 240
			uLen -= 2;
     f6e:	fe ef       	ldi	r31, 0xFE	; 254
     f70:	df 0e       	add	r13, r31
		}
		
		if(uCol >= MAX_COLUMN)
     f72:	17 ff       	sbrs	r17, 7
     f74:	07 c0       	rjmp	.+14     	; 0xf84 <LCD_DisplayString5_7+0x78>
		{
			uCol = 0;
			uPage += 2;
     f76:	0e 5f       	subi	r16, 0xFE	; 254
			if(uPage >= MAX_PAGE)
     f78:	08 30       	cpi	r16, 0x08	; 8
     f7a:	18 f0       	brcs	.+6      	; 0xf82 <LCD_DisplayString5_7+0x76>
     f7c:	10 e0       	ldi	r17, 0x00	; 0
     f7e:	00 e0       	ldi	r16, 0x00	; 0
     f80:	01 c0       	rjmp	.+2      	; 0xf84 <LCD_DisplayString5_7+0x78>
     f82:	10 e0       	ldi	r17, 0x00	; 0
	
	uLen = strlen(String);
    uPage = adrPage;
    uCol = adrColumn;

    while(uLen)
     f84:	dd 20       	and	r13, r13
     f86:	e9 f6       	brne	.-70     	; 0xf42 <LCD_DisplayString5_7+0x36>
				uPage = 0;
		}
	}
	
    return uLen;
}
     f88:	80 e0       	ldi	r24, 0x00	; 0
     f8a:	0f 90       	pop	r0
     f8c:	0f 90       	pop	r0
     f8e:	cf 91       	pop	r28
     f90:	df 91       	pop	r29
     f92:	1f 91       	pop	r17
     f94:	0f 91       	pop	r16
     f96:	ff 90       	pop	r15
     f98:	ef 90       	pop	r14
     f9a:	df 90       	pop	r13
     f9c:	bf 90       	pop	r11
     f9e:	af 90       	pop	r10
     fa0:	08 95       	ret

00000fa2 <LCD_CLR>:
      	}
   	}
} 

void LCD_CLR(void)
{
     fa2:	1f 93       	push	r17
     fa4:	cf 93       	push	r28
     fa6:	df 93       	push	r29
     fa8:	10 e0       	ldi	r17, 0x00	; 0
   	uint8_t adrPage, adrLaw, Data;
	Data = 0;
   	
	for(adrPage = 0; adrPage < MAX_PAGE; adrPage++)
	{  
		LCD_SetPageAddress(adrPage);
     faa:	81 2f       	mov	r24, r17
     fac:	0e 94 a2 05 	call	0xb44	; 0xb44 <LCD_SetPageAddress>
		LCD_SetColumnAddress(0);
     fb0:	80 e0       	ldi	r24, 0x00	; 0
     fb2:	0e 94 95 05 	call	0xb2a	; 0xb2a <LCD_SetColumnAddress>
     fb6:	c1 e8       	ldi	r28, 0x81	; 129
     fb8:	d0 e0       	ldi	r29, 0x00	; 0
     fba:	03 c0       	rjmp	.+6      	; 0xfc2 <LCD_CLR+0x20>
      	for(adrLaw = 0; adrLaw < MAX_COLUMN; adrLaw++)
      	{
      		dogm_core_data(Data);
     fbc:	80 e0       	ldi	r24, 0x00	; 0
     fbe:	0e 94 66 05 	call	0xacc	; 0xacc <dogm_core_data>
     fc2:	21 97       	sbiw	r28, 0x01	; 1
   	
	for(adrPage = 0; adrPage < MAX_PAGE; adrPage++)
	{  
		LCD_SetPageAddress(adrPage);
		LCD_SetColumnAddress(0);
      	for(adrLaw = 0; adrLaw < MAX_COLUMN; adrLaw++)
     fc4:	d9 f7       	brne	.-10     	; 0xfbc <LCD_CLR+0x1a>
void LCD_CLR(void)
{
   	uint8_t adrPage, adrLaw, Data;
	Data = 0;
   	
	for(adrPage = 0; adrPage < MAX_PAGE; adrPage++)
     fc6:	1f 5f       	subi	r17, 0xFF	; 255
     fc8:	18 30       	cpi	r17, 0x08	; 8
     fca:	79 f7       	brne	.-34     	; 0xfaa <LCD_CLR+0x8>
      	for(adrLaw = 0; adrLaw < MAX_COLUMN; adrLaw++)
      	{
      		dogm_core_data(Data);
      	}
   	}
} 
     fcc:	df 91       	pop	r29
     fce:	cf 91       	pop	r28
     fd0:	1f 91       	pop	r17
     fd2:	08 95       	ret

00000fd4 <LCD_CLR_PICTURE>:

//-----------------------------------------------------------------------------
// LCD:Clear picture.
//-----------------------------------------------------------------------------
void LCD_CLR_PICTURE(uint8_t Data)
{
     fd4:	0f 93       	push	r16
     fd6:	1f 93       	push	r17
     fd8:	cf 93       	push	r28
     fda:	df 93       	push	r29
     fdc:	08 2f       	mov	r16, r24
     fde:	10 e0       	ldi	r17, 0x00	; 0
   	uint8_t adrPage, adrLaw;
	
   	for(adrPage = 0; adrPage < MAX_PAGE; adrPage++)
	{  
		LCD_SetPageAddress(adrPage);
     fe0:	81 2f       	mov	r24, r17
     fe2:	0e 94 a2 05 	call	0xb44	; 0xb44 <LCD_SetPageAddress>
		LCD_SetColumnAddress(0);
     fe6:	80 e0       	ldi	r24, 0x00	; 0
     fe8:	0e 94 95 05 	call	0xb2a	; 0xb2a <LCD_SetColumnAddress>
     fec:	c1 e8       	ldi	r28, 0x81	; 129
     fee:	d0 e0       	ldi	r29, 0x00	; 0
     ff0:	03 c0       	rjmp	.+6      	; 0xff8 <LCD_CLR_PICTURE+0x24>
      	for(adrLaw = 0; adrLaw < MAX_COLUMN; adrLaw++)
      	{
      		dogm_core_data(Data);
     ff2:	80 2f       	mov	r24, r16
     ff4:	0e 94 66 05 	call	0xacc	; 0xacc <dogm_core_data>
     ff8:	21 97       	sbiw	r28, 0x01	; 1
	
   	for(adrPage = 0; adrPage < MAX_PAGE; adrPage++)
	{  
		LCD_SetPageAddress(adrPage);
		LCD_SetColumnAddress(0);
      	for(adrLaw = 0; adrLaw < MAX_COLUMN; adrLaw++)
     ffa:	d9 f7       	brne	.-10     	; 0xff2 <LCD_CLR_PICTURE+0x1e>
//-----------------------------------------------------------------------------
void LCD_CLR_PICTURE(uint8_t Data)
{
   	uint8_t adrPage, adrLaw;
	
   	for(adrPage = 0; adrPage < MAX_PAGE; adrPage++)
     ffc:	1f 5f       	subi	r17, 0xFF	; 255
     ffe:	18 30       	cpi	r17, 0x08	; 8
    1000:	79 f7       	brne	.-34     	; 0xfe0 <LCD_CLR_PICTURE+0xc>
      	for(adrLaw = 0; adrLaw < MAX_COLUMN; adrLaw++)
      	{
      		dogm_core_data(Data);
      	}
   	}
} 
    1002:	df 91       	pop	r29
    1004:	cf 91       	pop	r28
    1006:	1f 91       	pop	r17
    1008:	0f 91       	pop	r16
    100a:	08 95       	ret

0000100c <LCD_Draw_Pixel>:

//-----------------------------------------------------------------------------
// LCD:Drav Pixel on screen
//-----------------------------------------------------------------------------
void LCD_Draw_Pixel(uint8_t Xpos,uint8_t Ypos,uint8_t Color)
{
    100c:	80 e0       	ldi	r24, 0x00	; 0
    100e:	0e 94 a2 05 	call	0xb44	; 0xb44 <LCD_SetPageAddress>
	   	uint8_t adrPage, adrLaw;
		LCD_SetPageAddress(0);
		LCD_SetColumnAddress(0);
    1012:	80 e0       	ldi	r24, 0x00	; 0
    1014:	0e 94 95 05 	call	0xb2a	; 0xb2a <LCD_SetColumnAddress>
		dogm_core_data(1);
    1018:	81 e0       	ldi	r24, 0x01	; 1
    101a:	0e 94 66 05 	call	0xacc	; 0xacc <dogm_core_data>


}
    101e:	08 95       	ret

00001020 <LCD_SetStartLine>:
	Power &= 0x07;
	dogm_core_cmd(0x28 | Power);
}

void LCD_SetStartLine(uint8_t LineStart)
{
    1020:	8f 73       	andi	r24, 0x3F	; 63
    1022:	80 64       	ori	r24, 0x40	; 64
    1024:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>
	LineStart &= 0x3F;
	dogm_core_cmd(0x40 | LineStart);
}
    1028:	08 95       	ret

0000102a <LCD_PowerControl>:
	On &= 0x01;
	dogm_core_cmd(0xAE | On);
}

void LCD_PowerControl(uint8_t Power)
{
    102a:	87 70       	andi	r24, 0x07	; 7
    102c:	88 62       	ori	r24, 0x28	; 40
    102e:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>
	Power &= 0x07;
	dogm_core_cmd(0x28 | Power);
}
    1032:	08 95       	ret

00001034 <LCD_DisplayOnOff>:
	Delay(200);	
	RES_PORT |= (1<<RES_BIT); // RES\ = HIGH (kein Reset)
}

void LCD_DisplayOnOff(uint8_t On)
{
    1034:	81 70       	andi	r24, 0x01	; 1
    1036:	8e 6a       	ori	r24, 0xAE	; 174
    1038:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>
	On &= 0x01;
	dogm_core_cmd(0xAE | On);
}
    103c:	08 95       	ret

0000103e <dogm_reset>:
}



void dogm_reset(void)
{
    103e:	c2 98       	cbi	0x18, 2	; 24
	//Reset display (20ms)
	RES_PORT &= ~(1<<RES_BIT); // RES\ = LOW (Reset)
	Delay(200);	
    1040:	88 ec       	ldi	r24, 0xC8	; 200
    1042:	90 e0       	ldi	r25, 0x00	; 0
    1044:	0e 94 4b 0a 	call	0x1496	; 0x1496 <Delay>
	RES_PORT |= (1<<RES_BIT); // RES\ = HIGH (kein Reset)
    1048:	c2 9a       	sbi	0x18, 2	; 24
}
    104a:	08 95       	ret

0000104c <disp_init>:

uint8_t xy_adrColumn;   // globaler Spiecher fr XY_Goto
uint8_t xy_adrPage;

void disp_init(void)
{
    104c:	0e 94 1f 08 	call	0x103e	; 0x103e <dogm_reset>
	dogm_reset(); //(100ms)


	//Display start line
	dogm_core_cmd(0x40); // Display start line 0
    1050:	80 e4       	ldi	r24, 0x40	; 64
    1052:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>

	//Bottom view
	dogm_core_cmd(0xA1); // ADC reverse
    1056:	81 ea       	ldi	r24, 0xA1	; 161
    1058:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>
	dogm_core_cmd(0xC0); // Normal COM0~COM63
    105c:	80 ec       	ldi	r24, 0xC0	; 192
    105e:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>

	//Normal / Inverted
	dogm_core_cmd(0xA6); // Display normal
    1062:	86 ea       	ldi	r24, 0xA6	; 166
    1064:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>

	//Hardware options
	dogm_core_cmd(0xA2); // Set bias 1/9 (Duty 1/65)
    1068:	82 ea       	ldi	r24, 0xA2	; 162
    106a:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>
	dogm_core_cmd(0x2F); // Booster, Regulator and Follower on
    106e:	8f e2       	ldi	r24, 0x2F	; 47
    1070:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>
	dogm_core_cmd(0xF8); // Set internal Booster to 4x
    1074:	88 ef       	ldi	r24, 0xF8	; 248
    1076:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>
	dogm_core_cmd(0x00);
    107a:	80 e0       	ldi	r24, 0x00	; 0
    107c:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>

	//Contrast options
	dogm_core_cmd(0x27); // Contrast set
    1080:	87 e2       	ldi	r24, 0x27	; 39
    1082:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>
	dogm_core_cmd(0x81);
    1086:	81 e8       	ldi	r24, 0x81	; 129
    1088:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>
	dogm_core_cmd(0x16);
    108c:	86 e1       	ldi	r24, 0x16	; 22
    108e:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>

	//Indicator options
	dogm_core_cmd(0xAC); // No indicator
    1092:	8c ea       	ldi	r24, 0xAC	; 172
    1094:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>
	dogm_core_cmd(0x00);
    1098:	80 e0       	ldi	r24, 0x00	; 0
    109a:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>

	//(Init done)
	dogm_core_cmd(0xAF); // Display on
    109e:	8f ea       	ldi	r24, 0xAF	; 175
    10a0:	0e 94 62 05 	call	0xac4	; 0xac4 <dogm_core_cmd>
	
	LCD_CLR(); // DOGM  Clear
    10a4:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <LCD_CLR>
}
    10a8:	08 95       	ret

000010aa <rprintfInit>:

// *** rprintf initialization ***
// you must call this function once and supply the character output
// routine before using other functions in this library
void rprintfInit(void (*putchar_func)(unsigned char c))
{
    10aa:	90 93 83 00 	sts	0x0083, r25
    10ae:	80 93 82 00 	sts	0x0082, r24
	rputchar = putchar_func;
}
    10b2:	08 95       	ret

000010b4 <rprintfChar>:

// *** rprintfChar ***
// send a character/byte to the current output device
void rprintfChar(unsigned char c)
{
    10b4:	1f 93       	push	r17
    10b6:	18 2f       	mov	r17, r24
	// do LF -> CR/LF translation
	if(c == '\n')
    10b8:	8a 30       	cpi	r24, 0x0A	; 10
    10ba:	31 f4       	brne	.+12     	; 0x10c8 <rprintfChar+0x14>
		rputchar('\r');
    10bc:	e0 91 82 00 	lds	r30, 0x0082
    10c0:	f0 91 83 00 	lds	r31, 0x0083
    10c4:	8d e0       	ldi	r24, 0x0D	; 13
    10c6:	09 95       	icall
	// send character
	rputchar(c);
    10c8:	e0 91 82 00 	lds	r30, 0x0082
    10cc:	f0 91 83 00 	lds	r31, 0x0083
    10d0:	81 2f       	mov	r24, r17
    10d2:	09 95       	icall
}
    10d4:	1f 91       	pop	r17
    10d6:	08 95       	ret

000010d8 <rprintfStr>:

// *** rprintfStr ***
// prints a null-terminated string stored in RAM
void rprintfStr(char str[])
{
    10d8:	cf 93       	push	r28
    10da:	df 93       	push	r29
    10dc:	ec 01       	movw	r28, r24
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;
    10de:	00 97       	sbiw	r24, 0x00	; 0
    10e0:	21 f4       	brne	.+8      	; 0x10ea <rprintfStr+0x12>
    10e2:	06 c0       	rjmp	.+12     	; 0x10f0 <rprintfStr+0x18>

	// print the string until a null-terminator
	while (*str)
		rprintfChar(*str++);
    10e4:	21 96       	adiw	r28, 0x01	; 1
    10e6:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <rprintfChar>
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;

	// print the string until a null-terminator
	while (*str)
    10ea:	88 81       	ld	r24, Y
    10ec:	88 23       	and	r24, r24
    10ee:	d1 f7       	brne	.-12     	; 0x10e4 <rprintfStr+0xc>
		rprintfChar(*str++);
}
    10f0:	df 91       	pop	r29
    10f2:	cf 91       	pop	r28
    10f4:	08 95       	ret

000010f6 <rprintfStrLen>:
// *** rprintfStrLen ***
// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], unsigned int start, unsigned int len)
{
    10f6:	ef 92       	push	r14
    10f8:	ff 92       	push	r15
    10fa:	0f 93       	push	r16
    10fc:	1f 93       	push	r17
    10fe:	cf 93       	push	r28
    1100:	df 93       	push	r29
    1102:	8c 01       	movw	r16, r24
    1104:	7a 01       	movw	r14, r20
	register int i=0;

	// check to make sure we have a good pointer
	if (!str) return;
    1106:	00 97       	sbiw	r24, 0x00	; 0
    1108:	e9 f0       	breq	.+58     	; 0x1144 <rprintfStrLen+0x4e>
    110a:	20 e0       	ldi	r18, 0x00	; 0
    110c:	30 e0       	ldi	r19, 0x00	; 0
	// spin through characters up to requested start
	// keep going as long as there's no null
	while((i++<start) && (*str++));
    110e:	26 17       	cp	r18, r22
    1110:	37 07       	cpc	r19, r23
    1112:	38 f4       	brcc	.+14     	; 0x1122 <rprintfStrLen+0x2c>
    1114:	f8 01       	movw	r30, r16
    1116:	81 91       	ld	r24, Z+
    1118:	8f 01       	movw	r16, r30
    111a:	2f 5f       	subi	r18, 0xFF	; 255
    111c:	3f 4f       	sbci	r19, 0xFF	; 255
    111e:	88 23       	and	r24, r24
    1120:	b1 f7       	brne	.-20     	; 0x110e <rprintfStrLen+0x18>
    1122:	c0 e0       	ldi	r28, 0x00	; 0
    1124:	d0 e0       	ldi	r29, 0x00	; 0
    1126:	0b c0       	rjmp	.+22     	; 0x113e <rprintfStrLen+0x48>
	// then print exactly len characters
	for(i=0; i<len; i++)
	{
		// print data out of the string as long as we haven't reached a null yet
		// at the null, start printing spaces
		if(*str)
    1128:	f8 01       	movw	r30, r16
    112a:	80 81       	ld	r24, Z
    112c:	88 23       	and	r24, r24
    112e:	19 f0       	breq	.+6      	; 0x1136 <rprintfStrLen+0x40>
			rprintfChar(*str++);
    1130:	0f 5f       	subi	r16, 0xFF	; 255
    1132:	1f 4f       	sbci	r17, 0xFF	; 255
    1134:	01 c0       	rjmp	.+2      	; 0x1138 <rprintfStrLen+0x42>
		else
			rprintfChar(' ');
    1136:	80 e2       	ldi	r24, 0x20	; 32
    1138:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <rprintfChar>
//		// keep steping through string as long as there's no null
//		if(*str) str++;
//	}

	// then print exactly len characters
	for(i=0; i<len; i++)
    113c:	21 96       	adiw	r28, 0x01	; 1
    113e:	ce 15       	cp	r28, r14
    1140:	df 05       	cpc	r29, r15
    1142:	90 f3       	brcs	.-28     	; 0x1128 <rprintfStrLen+0x32>
			rprintfChar(*str++);
		else
			rprintfChar(' ');
	}

}
    1144:	df 91       	pop	r29
    1146:	cf 91       	pop	r28
    1148:	1f 91       	pop	r17
    114a:	0f 91       	pop	r16
    114c:	ff 90       	pop	r15
    114e:	ef 90       	pop	r14
    1150:	08 95       	ret

00001152 <rprintfProgStr>:

// *** rprintfProgStr ***
// prints a null-terminated string stored in program ROM
void rprintfProgStr(const prog_char str[])
{
    1152:	cf 93       	push	r28
    1154:	df 93       	push	r29
    1156:	ec 01       	movw	r28, r24
	// print a string stored in program memory
	register char c;

	// check to make sure we have a good pointer
	if (!str) return;
    1158:	00 97       	sbiw	r24, 0x00	; 0
    115a:	19 f4       	brne	.+6      	; 0x1162 <rprintfProgStr+0x10>
    115c:	07 c0       	rjmp	.+14     	; 0x116c <rprintfProgStr+0x1a>
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
		rprintfChar(c);
    115e:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <rprintfChar>
    1162:	fe 01       	movw	r30, r28

	// check to make sure we have a good pointer
	if (!str) return;
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
    1164:	21 96       	adiw	r28, 0x01	; 1
    1166:	84 91       	lpm	r24, Z+
    1168:	88 23       	and	r24, r24
    116a:	c9 f7       	brne	.-14     	; 0x115e <rprintfProgStr+0xc>
		rprintfChar(c);
}
    116c:	df 91       	pop	r29
    116e:	cf 91       	pop	r28
    1170:	08 95       	ret

00001172 <rprintfCRLF>:

// *** rprintfCRLF ***
// prints carriage return and line feed
void rprintfCRLF(void)
{
    1172:	8a e0       	ldi	r24, 0x0A	; 10
    1174:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <rprintfChar>
	// print CR/LF
	//rprintfChar('\r');
	// LF -> CR/LF translation built-in to rprintfChar()
	rprintfChar('\n');
}
    1178:	08 95       	ret

0000117a <rprintfu04>:

// *** rprintfu04 ***
// prints an unsigned 4-bit number in hex (1 digit)
void rprintfu04(unsigned char data)
{
    117a:	e8 2f       	mov	r30, r24
    117c:	f0 e0       	ldi	r31, 0x00	; 0
    117e:	ef 70       	andi	r30, 0x0F	; 15
    1180:	f0 70       	andi	r31, 0x00	; 0
    1182:	ef 59       	subi	r30, 0x9F	; 159
    1184:	f6 4f       	sbci	r31, 0xF6	; 246
    1186:	e4 91       	lpm	r30, Z+
    1188:	8e 2f       	mov	r24, r30
    118a:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <rprintfChar>
//	if (Character>9)
//		Character+='A'-10;
//	else
//		Character+='0';
	rprintfChar(hexchar(data));
}
    118e:	08 95       	ret

00001190 <rprintfu08>:

// *** rprintfu08 ***
// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(unsigned char data)
{
    1190:	1f 93       	push	r17
    1192:	18 2f       	mov	r17, r24
	// print 8-bit hex value
	rprintfu04(data>>4);
    1194:	82 95       	swap	r24
    1196:	8f 70       	andi	r24, 0x0F	; 15
    1198:	0e 94 bd 08 	call	0x117a	; 0x117a <rprintfu04>
	rprintfu04(data);
    119c:	81 2f       	mov	r24, r17
    119e:	0e 94 bd 08 	call	0x117a	; 0x117a <rprintfu04>
}
    11a2:	1f 91       	pop	r17
    11a4:	08 95       	ret

000011a6 <rprintfu16>:

// *** rprintfu16 ***
// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(unsigned short data)
{
    11a6:	1f 93       	push	r17
    11a8:	18 2f       	mov	r17, r24
	// print 16-bit hex value
	rprintfu08(data>>8);
    11aa:	89 2f       	mov	r24, r25
    11ac:	0e 94 c8 08 	call	0x1190	; 0x1190 <rprintfu08>
	rprintfu08(data);
    11b0:	81 2f       	mov	r24, r17
    11b2:	0e 94 c8 08 	call	0x1190	; 0x1190 <rprintfu08>
}
    11b6:	1f 91       	pop	r17
    11b8:	08 95       	ret

000011ba <rprintfu32>:

// *** rprintfu32 ***
// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(unsigned long data)
{
    11ba:	ef 92       	push	r14
    11bc:	ff 92       	push	r15
    11be:	0f 93       	push	r16
    11c0:	1f 93       	push	r17
    11c2:	7b 01       	movw	r14, r22
    11c4:	8c 01       	movw	r16, r24
	// print 32-bit hex value
	rprintfu16(data>>16);
    11c6:	c8 01       	movw	r24, r16
    11c8:	aa 27       	eor	r26, r26
    11ca:	bb 27       	eor	r27, r27
    11cc:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <rprintfu16>
	rprintfu16(data);
    11d0:	c7 01       	movw	r24, r14
    11d2:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <rprintfu16>
}
    11d6:	1f 91       	pop	r17
    11d8:	0f 91       	pop	r16
    11da:	ff 90       	pop	r15
    11dc:	ef 90       	pop	r14
    11de:	08 95       	ret

000011e0 <rprintfNum>:
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
{
    11e0:	2f 92       	push	r2
    11e2:	3f 92       	push	r3
    11e4:	4f 92       	push	r4
    11e6:	5f 92       	push	r5
    11e8:	6f 92       	push	r6
    11ea:	7f 92       	push	r7
    11ec:	8f 92       	push	r8
    11ee:	9f 92       	push	r9
    11f0:	af 92       	push	r10
    11f2:	bf 92       	push	r11
    11f4:	cf 92       	push	r12
    11f6:	df 92       	push	r13
    11f8:	ef 92       	push	r14
    11fa:	ff 92       	push	r15
    11fc:	0f 93       	push	r16
    11fe:	1f 93       	push	r17
    1200:	df 93       	push	r29
    1202:	cf 93       	push	r28
    1204:	cd b7       	in	r28, 0x3d	; 61
    1206:	de b7       	in	r29, 0x3e	; 62
    1208:	a3 97       	sbiw	r28, 0x23	; 35
    120a:	0f b6       	in	r0, 0x3f	; 63
    120c:	f8 94       	cli
    120e:	de bf       	out	0x3e, r29	; 62
    1210:	0f be       	out	0x3f, r0	; 63
    1212:	cd bf       	out	0x3d, r28	; 61
    1214:	6a a3       	std	Y+34, r22	; 0x22
    1216:	24 2e       	mov	r2, r20
    1218:	2b a3       	std	Y+35, r18	; 0x23
    121a:	37 01       	movw	r6, r14
    121c:	48 01       	movw	r8, r16
	char *p, buf[32];
	unsigned long x;
	unsigned char count;

	// prepare negative number
	if( isSigned && (n < 0) )
    121e:	44 23       	and	r20, r20
    1220:	51 f0       	breq	.+20     	; 0x1236 <rprintfNum+0x56>
    1222:	17 ff       	sbrs	r17, 7
    1224:	08 c0       	rjmp	.+16     	; 0x1236 <rprintfNum+0x56>
	{
		x = -n;
    1226:	ee 24       	eor	r14, r14
    1228:	ff 24       	eor	r15, r15
    122a:	87 01       	movw	r16, r14
    122c:	e6 18       	sub	r14, r6
    122e:	f7 08       	sbc	r15, r7
    1230:	08 09       	sbc	r16, r8
    1232:	19 09       	sbc	r17, r9
    1234:	02 c0       	rjmp	.+4      	; 0x123a <rprintfNum+0x5a>
	}
	else
	{
	 	x = n;
    1236:	84 01       	movw	r16, r8
    1238:	73 01       	movw	r14, r6
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
    123a:	2a a1       	ldd	r18, Y+34	; 0x22
    123c:	21 50       	subi	r18, 0x01	; 1
    123e:	90 e0       	ldi	r25, 0x00	; 0
    1240:	21 10       	cpse	r2, r1
    1242:	91 e0       	ldi	r25, 0x01	; 1
    1244:	29 1b       	sub	r18, r25
    1246:	29 a3       	std	Y+33, r18	; 0x21
  	p = buf + sizeof (buf);
  	*--p = '\0';
    1248:	18 a2       	std	Y+32, r1	; 0x20
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
    124a:	a8 2e       	mov	r10, r24
    124c:	bb 24       	eor	r11, r11
    124e:	cc 24       	eor	r12, r12
    1250:	dd 24       	eor	r13, r13
    1252:	c8 01       	movw	r24, r16
    1254:	b7 01       	movw	r22, r14
    1256:	a6 01       	movw	r20, r12
    1258:	95 01       	movw	r18, r10
    125a:	0e 94 71 0a 	call	0x14e2	; 0x14e2 <__udivmodsi4>
    125e:	fb 01       	movw	r30, r22
    1260:	ef 70       	andi	r30, 0x0F	; 15
    1262:	f0 70       	andi	r31, 0x00	; 0
    1264:	ef 59       	subi	r30, 0x9F	; 159
    1266:	f6 4f       	sbci	r31, 0xF6	; 246
    1268:	64 91       	lpm	r22, Z+
    126a:	6f 8f       	std	Y+31, r22	; 0x1f
    126c:	c8 01       	movw	r24, r16
    126e:	b7 01       	movw	r22, r14
    1270:	a6 01       	movw	r20, r12
    1272:	95 01       	movw	r18, r10
    1274:	0e 94 71 0a 	call	0x14e2	; 0x14e2 <__udivmodsi4>
    1278:	c9 01       	movw	r24, r18
    127a:	da 01       	movw	r26, r20
    127c:	7c 01       	movw	r14, r24
    127e:	8d 01       	movw	r16, r26
    1280:	9e e1       	ldi	r25, 0x1E	; 30
    1282:	49 2e       	mov	r4, r25
    1284:	51 2c       	mov	r5, r1
    1286:	4c 0e       	add	r4, r28
    1288:	5d 1e       	adc	r5, r29
    128a:	39 a0       	ldd	r3, Y+33	; 0x21
    128c:	25 c0       	rjmp	.+74     	; 0x12d8 <rprintfNum+0xf8>
	// calculate remaining digits
	while(count--)
	{
		if(x != 0)
    128e:	e1 14       	cp	r14, r1
    1290:	f1 04       	cpc	r15, r1
    1292:	01 05       	cpc	r16, r1
    1294:	11 05       	cpc	r17, r1
    1296:	c9 f0       	breq	.+50     	; 0x12ca <rprintfNum+0xea>
		{
			// calculate next digit
			*--p = hexchar(x%base); x /= base;
    1298:	c8 01       	movw	r24, r16
    129a:	b7 01       	movw	r22, r14
    129c:	a6 01       	movw	r20, r12
    129e:	95 01       	movw	r18, r10
    12a0:	0e 94 71 0a 	call	0x14e2	; 0x14e2 <__udivmodsi4>
    12a4:	fb 01       	movw	r30, r22
    12a6:	ef 70       	andi	r30, 0x0F	; 15
    12a8:	f0 70       	andi	r31, 0x00	; 0
    12aa:	ef 59       	subi	r30, 0x9F	; 159
    12ac:	f6 4f       	sbci	r31, 0xF6	; 246
    12ae:	64 91       	lpm	r22, Z+
    12b0:	f2 01       	movw	r30, r4
    12b2:	60 83       	st	Z, r22
    12b4:	c8 01       	movw	r24, r16
    12b6:	b7 01       	movw	r22, r14
    12b8:	a6 01       	movw	r20, r12
    12ba:	95 01       	movw	r18, r10
    12bc:	0e 94 71 0a 	call	0x14e2	; 0x14e2 <__udivmodsi4>
    12c0:	c9 01       	movw	r24, r18
    12c2:	da 01       	movw	r26, r20
    12c4:	7c 01       	movw	r14, r24
    12c6:	8d 01       	movw	r16, r26
    12c8:	03 c0       	rjmp	.+6      	; 0x12d0 <rprintfNum+0xf0>
		}
		else
		{
			// no more digits left, pad out to desired length
			*--p = padchar;
    12ca:	2b a1       	ldd	r18, Y+35	; 0x23
    12cc:	f2 01       	movw	r30, r4
    12ce:	20 83       	st	Z, r18
    12d0:	3a 94       	dec	r3
    12d2:	08 94       	sec
    12d4:	41 08       	sbc	r4, r1
    12d6:	51 08       	sbc	r5, r1
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
	// calculate remaining digits
	while(count--)
    12d8:	33 20       	and	r3, r3
    12da:	c9 f6       	brne	.-78     	; 0x128e <rprintfNum+0xae>
    12dc:	ce 01       	movw	r24, r28
    12de:	4f 96       	adiw	r24, 0x1f	; 31
    12e0:	8c 01       	movw	r16, r24
    12e2:	e9 a1       	ldd	r30, Y+33	; 0x21
    12e4:	0e 1b       	sub	r16, r30
    12e6:	11 09       	sbc	r17, r1
			*--p = padchar;
		}
	}

	// apply signed notation if requested
	if( isSigned )
    12e8:	22 20       	and	r2, r2
    12ea:	f1 f0       	breq	.+60     	; 0x1328 <rprintfNum+0x148>
	{
		if(n < 0)
    12ec:	97 fe       	sbrs	r9, 7
    12ee:	05 c0       	rjmp	.+10     	; 0x12fa <rprintfNum+0x11a>
		{
   			*--p = '-';
    12f0:	8d e2       	ldi	r24, 0x2D	; 45
    12f2:	f8 01       	movw	r30, r16
    12f4:	82 93       	st	-Z, r24
    12f6:	8f 01       	movw	r16, r30
    12f8:	17 c0       	rjmp	.+46     	; 0x1328 <rprintfNum+0x148>
    12fa:	c8 01       	movw	r24, r16
    12fc:	01 97       	sbiw	r24, 0x01	; 1
		}
		else if(n > 0)
    12fe:	61 14       	cp	r6, r1
    1300:	71 04       	cpc	r7, r1
    1302:	81 04       	cpc	r8, r1
    1304:	91 04       	cpc	r9, r1
    1306:	19 f0       	breq	.+6      	; 0x130e <rprintfNum+0x12e>
		{
	   		*--p = '+';
    1308:	8c 01       	movw	r16, r24
    130a:	8b e2       	ldi	r24, 0x2B	; 43
    130c:	02 c0       	rjmp	.+4      	; 0x1312 <rprintfNum+0x132>
		}
		else
		{
	   		*--p = ' ';
    130e:	8c 01       	movw	r16, r24
    1310:	80 e2       	ldi	r24, 0x20	; 32
    1312:	f8 01       	movw	r30, r16
    1314:	80 83       	st	Z, r24
    1316:	08 c0       	rjmp	.+16     	; 0x1328 <rprintfNum+0x148>

	// print the string right-justified
	count = numDigits;
	while(count--)
	{
		rprintfChar(*p++);
    1318:	f8 01       	movw	r30, r16
    131a:	81 91       	ld	r24, Z+
    131c:	8f 01       	movw	r16, r30
    131e:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <rprintfChar>
    1322:	fa a1       	ldd	r31, Y+34	; 0x22
    1324:	f1 50       	subi	r31, 0x01	; 1
    1326:	fa a3       	std	Y+34, r31	; 0x22
		}
	}

	// print the string right-justified
	count = numDigits;
	while(count--)
    1328:	2a a1       	ldd	r18, Y+34	; 0x22
    132a:	22 23       	and	r18, r18
    132c:	a9 f7       	brne	.-22     	; 0x1318 <rprintfNum+0x138>
	{
		rprintfChar(*p++);
	}
}
    132e:	a3 96       	adiw	r28, 0x23	; 35
    1330:	0f b6       	in	r0, 0x3f	; 63
    1332:	f8 94       	cli
    1334:	de bf       	out	0x3e, r29	; 62
    1336:	0f be       	out	0x3f, r0	; 63
    1338:	cd bf       	out	0x3d, r28	; 61
    133a:	cf 91       	pop	r28
    133c:	df 91       	pop	r29
    133e:	1f 91       	pop	r17
    1340:	0f 91       	pop	r16
    1342:	ff 90       	pop	r15
    1344:	ef 90       	pop	r14
    1346:	df 90       	pop	r13
    1348:	cf 90       	pop	r12
    134a:	bf 90       	pop	r11
    134c:	af 90       	pop	r10
    134e:	9f 90       	pop	r9
    1350:	8f 90       	pop	r8
    1352:	7f 90       	pop	r7
    1354:	6f 90       	pop	r6
    1356:	5f 90       	pop	r5
    1358:	4f 90       	pop	r4
    135a:	3f 90       	pop	r3
    135c:	2f 90       	pop	r2
    135e:	08 95       	ret

00001360 <rprintf1RamRom>:
// Supports:
// %d - decimal
// %x - hex
// %c - character
int rprintf1RamRom(unsigned char stringInRom, const char *format, ...)
{
    1360:	7f 92       	push	r7
    1362:	8f 92       	push	r8
    1364:	9f 92       	push	r9
    1366:	af 92       	push	r10
    1368:	bf 92       	push	r11
    136a:	cf 92       	push	r12
    136c:	df 92       	push	r13
    136e:	ef 92       	push	r14
    1370:	ff 92       	push	r15
    1372:	0f 93       	push	r16
    1374:	1f 93       	push	r17
    1376:	df 93       	push	r29
    1378:	cf 93       	push	r28
    137a:	cd b7       	in	r28, 0x3d	; 61
    137c:	de b7       	in	r29, 0x3e	; 62
    137e:	78 88       	ldd	r7, Y+16	; 0x10
    1380:	c9 88       	ldd	r12, Y+17	; 0x11
    1382:	da 88       	ldd	r13, Y+18	; 0x12
    1384:	53 e1       	ldi	r21, 0x13	; 19
    1386:	e5 2e       	mov	r14, r21
    1388:	f1 2c       	mov	r15, r1
    138a:	ec 0e       	add	r14, r28
    138c:	fd 1e       	adc	r15, r29
    138e:	14 c0       	rjmp	.+40     	; 0x13b8 <rprintf1RamRom+0x58>
	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
		{	// Until '%' or '\0'
			if (!format_flag)
    1390:	88 23       	and	r24, r24
    1392:	81 f4       	brne	.+32     	; 0x13b4 <rprintf1RamRom+0x54>
				div_val /= base;
			} while (div_val);
		}
	}
	va_end(ap);
}
    1394:	80 e0       	ldi	r24, 0x00	; 0
    1396:	90 e0       	ldi	r25, 0x00	; 0
    1398:	cf 91       	pop	r28
    139a:	df 91       	pop	r29
    139c:	1f 91       	pop	r17
    139e:	0f 91       	pop	r16
    13a0:	ff 90       	pop	r15
    13a2:	ef 90       	pop	r14
    13a4:	df 90       	pop	r13
    13a6:	cf 90       	pop	r12
    13a8:	bf 90       	pop	r11
    13aa:	af 90       	pop	r10
    13ac:	9f 90       	pop	r9
    13ae:	8f 90       	pop	r8
    13b0:	7f 90       	pop	r7
    13b2:	08 95       	ret
			if (!format_flag)
			{
				va_end(ap);
				return(0);
			}
			rprintfChar(format_flag);
    13b4:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <rprintfChar>
    13b8:	96 01       	movw	r18, r12
    13ba:	2f 5f       	subi	r18, 0xFF	; 255
    13bc:	3f 4f       	sbci	r19, 0xFF	; 255
	va_list ap;

	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
    13be:	77 20       	and	r7, r7
    13c0:	21 f0       	breq	.+8      	; 0x13ca <rprintf1RamRom+0x6a>
    13c2:	f6 01       	movw	r30, r12
    13c4:	69 01       	movw	r12, r18
    13c6:	84 91       	lpm	r24, Z+
    13c8:	03 c0       	rjmp	.+6      	; 0x13d0 <rprintf1RamRom+0x70>
    13ca:	f6 01       	movw	r30, r12
    13cc:	80 81       	ld	r24, Z
    13ce:	69 01       	movw	r12, r18
    13d0:	85 32       	cpi	r24, 0x25	; 37
    13d2:	f1 f6       	brne	.-68     	; 0x1390 <rprintf1RamRom+0x30>
    13d4:	2f 5f       	subi	r18, 0xFF	; 255
    13d6:	3f 4f       	sbci	r19, 0xFF	; 255
				return(0);
			}
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
    13d8:	77 20       	and	r7, r7
    13da:	21 f0       	breq	.+8      	; 0x13e4 <rprintf1RamRom+0x84>
    13dc:	f6 01       	movw	r30, r12
    13de:	69 01       	movw	r12, r18
    13e0:	84 91       	lpm	r24, Z+
    13e2:	03 c0       	rjmp	.+6      	; 0x13ea <rprintf1RamRom+0x8a>
    13e4:	f6 01       	movw	r30, r12
    13e6:	80 81       	ld	r24, Z
    13e8:	69 01       	movw	r12, r18
    13ea:	84 36       	cpi	r24, 0x64	; 100
    13ec:	29 f0       	breq	.+10     	; 0x13f8 <rprintf1RamRom+0x98>
    13ee:	88 37       	cpi	r24, 0x78	; 120
    13f0:	81 f0       	breq	.+32     	; 0x1412 <rprintf1RamRom+0xb2>
    13f2:	83 36       	cpi	r24, 0x63	; 99
    13f4:	f9 f6       	brne	.-66     	; 0x13b4 <rprintf1RamRom+0x54>
    13f6:	06 c0       	rjmp	.+12     	; 0x1404 <rprintf1RamRom+0xa4>
    13f8:	00 e1       	ldi	r16, 0x10	; 16
    13fa:	17 e2       	ldi	r17, 0x27	; 39
    13fc:	4a e0       	ldi	r20, 0x0A	; 10
    13fe:	a4 2e       	mov	r10, r20
    1400:	b1 2c       	mov	r11, r1
    1402:	0c c0       	rjmp	.+24     	; 0x141c <rprintf1RamRom+0xbc>
		{
			case 'c': format_flag = va_arg(ap,int);
    1404:	f7 01       	movw	r30, r14
    1406:	80 81       	ld	r24, Z
    1408:	22 e0       	ldi	r18, 0x02	; 2
    140a:	30 e0       	ldi	r19, 0x00	; 0
    140c:	e2 0e       	add	r14, r18
    140e:	f3 1e       	adc	r15, r19
    1410:	d1 cf       	rjmp	.-94     	; 0x13b4 <rprintf1RamRom+0x54>
			default:  rprintfChar(format_flag); continue;
    1412:	00 e0       	ldi	r16, 0x00	; 0
    1414:	10 e1       	ldi	r17, 0x10	; 16
    1416:	30 e1       	ldi	r19, 0x10	; 16
    1418:	a3 2e       	mov	r10, r19
    141a:	b1 2c       	mov	r11, r1
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
    141c:	22 e0       	ldi	r18, 0x02	; 2
    141e:	82 2e       	mov	r8, r18
    1420:	91 2c       	mov	r9, r1
    1422:	8e 0c       	add	r8, r14
    1424:	9f 1c       	adc	r9, r15
    1426:	f7 01       	movw	r30, r14
    1428:	e0 80       	ld	r14, Z
    142a:	f1 80       	ldd	r15, Z+1	; 0x01
			if (format_flag == 'd')
    142c:	84 36       	cpi	r24, 0x64	; 100
    142e:	b1 f4       	brne	.+44     	; 0x145c <rprintf1RamRom+0xfc>
			{
				if (((int)u_val) < 0)
    1430:	f7 fe       	sbrs	r15, 7
    1432:	11 c0       	rjmp	.+34     	; 0x1456 <rprintf1RamRom+0xf6>
				{
					u_val = - u_val;
    1434:	f0 94       	com	r15
    1436:	e1 94       	neg	r14
    1438:	f1 08       	sbc	r15, r1
    143a:	f3 94       	inc	r15
					rprintfChar('-');
    143c:	8d e2       	ldi	r24, 0x2D	; 45
    143e:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <rprintfChar>
    1442:	09 c0       	rjmp	.+18     	; 0x1456 <rprintf1RamRom+0xf6>
				}
				while (div_val > 1 && div_val > u_val) div_val /= 10;
    1444:	c8 01       	movw	r24, r16
    1446:	6a e0       	ldi	r22, 0x0A	; 10
    1448:	70 e0       	ldi	r23, 0x00	; 0
    144a:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <__udivmodhi4>
    144e:	8b 01       	movw	r16, r22
    1450:	62 30       	cpi	r22, 0x02	; 2
    1452:	71 05       	cpc	r23, r1
    1454:	18 f0       	brcs	.+6      	; 0x145c <rprintf1RamRom+0xfc>
    1456:	e0 16       	cp	r14, r16
    1458:	f1 06       	cpc	r15, r17
    145a:	a0 f3       	brcs	.-24     	; 0x1444 <rprintf1RamRom+0xe4>
			}
			do
			{
				//rprintfChar(pgm_read_byte(HexChars+(u_val/div_val)));
				rprintfu04(u_val/div_val);
    145c:	c7 01       	movw	r24, r14
    145e:	b8 01       	movw	r22, r16
    1460:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <__udivmodhi4>
    1464:	86 2f       	mov	r24, r22
    1466:	0e 94 bd 08 	call	0x117a	; 0x117a <rprintfu04>
				u_val %= div_val;
    146a:	c7 01       	movw	r24, r14
    146c:	b8 01       	movw	r22, r16
    146e:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <__udivmodhi4>
    1472:	7c 01       	movw	r14, r24
				div_val /= base;
    1474:	c8 01       	movw	r24, r16
    1476:	b5 01       	movw	r22, r10
    1478:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <__udivmodhi4>
    147c:	8b 01       	movw	r16, r22
			} while (div_val);
    147e:	61 15       	cp	r22, r1
    1480:	71 05       	cpc	r23, r1
    1482:	61 f7       	brne	.-40     	; 0x145c <rprintf1RamRom+0xfc>
    1484:	74 01       	movw	r14, r8
    1486:	98 cf       	rjmp	.-208    	; 0x13b8 <rprintf1RamRom+0x58>

00001488 <InitDelay>:
// Funkcia Delay sa pouziva na casove oneskorenie programu, pouzity timer1
#include "global.h"
/// Typedefs //////////

void InitDelay(void)
{
    1488:	81 e0       	ldi	r24, 0x01	; 1
    148a:	8e bd       	out	0x2e, r24	; 46
outb(TCCR1B,(0<<CS12)|(0<<CS11)|(1<<CS10));
outb(TCNT1H,0xFC);		// cas na 100us
    148c:	8c ef       	ldi	r24, 0xFC	; 252
    148e:	8d bd       	out	0x2d, r24	; 45
outb(TCNT1L,0xE0);		// cas na 100us
    1490:	80 ee       	ldi	r24, 0xE0	; 224
    1492:	8c bd       	out	0x2c, r24	; 44
}
    1494:	08 95       	ret

00001496 <Delay>:

void Delay(unsigned int time)
{
    1496:	9c 01       	movw	r18, r24
while (time>0)
	{
	outb(TCNT1H,0xFC);		// cas na 0,1s
    1498:	4c ef       	ldi	r20, 0xFC	; 252
	outb(TCNT1L,0xE0);		// cas na 0,1s
    149a:	90 ee       	ldi	r25, 0xE0	; 224
    149c:	0a c0       	rjmp	.+20     	; 0x14b2 <Delay+0x1c>

void Delay(unsigned int time)
{
while (time>0)
	{
	outb(TCNT1H,0xFC);		// cas na 0,1s
    149e:	4d bd       	out	0x2d, r20	; 45
	outb(TCNT1L,0xE0);		// cas na 0,1s
    14a0:	9c bd       	out	0x2c, r25	; 44
	while(!bit_is_set(TIFR,TOV1)); // caka na koniec
    14a2:	08 b6       	in	r0, 0x38	; 56
    14a4:	02 fe       	sbrs	r0, 2
    14a6:	fd cf       	rjmp	.-6      	; 0x14a2 <Delay+0xc>
	sbi(TIFR,TOV1);			// nuluje priznak
    14a8:	88 b7       	in	r24, 0x38	; 56
    14aa:	84 60       	ori	r24, 0x04	; 4
    14ac:	88 bf       	out	0x38, r24	; 56
	time-=1;
    14ae:	21 50       	subi	r18, 0x01	; 1
    14b0:	30 40       	sbci	r19, 0x00	; 0
outb(TCNT1L,0xE0);		// cas na 100us
}

void Delay(unsigned int time)
{
while (time>0)
    14b2:	21 15       	cp	r18, r1
    14b4:	31 05       	cpc	r19, r1
    14b6:	99 f7       	brne	.-26     	; 0x149e <Delay+0x8>
	outb(TCNT1L,0xE0);		// cas na 0,1s
	while(!bit_is_set(TIFR,TOV1)); // caka na koniec
	sbi(TIFR,TOV1);			// nuluje priznak
	time-=1;
	}
}
    14b8:	08 95       	ret

000014ba <__udivmodhi4>:
    14ba:	aa 1b       	sub	r26, r26
    14bc:	bb 1b       	sub	r27, r27
    14be:	51 e1       	ldi	r21, 0x11	; 17
    14c0:	07 c0       	rjmp	.+14     	; 0x14d0 <__udivmodhi4_ep>

000014c2 <__udivmodhi4_loop>:
    14c2:	aa 1f       	adc	r26, r26
    14c4:	bb 1f       	adc	r27, r27
    14c6:	a6 17       	cp	r26, r22
    14c8:	b7 07       	cpc	r27, r23
    14ca:	10 f0       	brcs	.+4      	; 0x14d0 <__udivmodhi4_ep>
    14cc:	a6 1b       	sub	r26, r22
    14ce:	b7 0b       	sbc	r27, r23

000014d0 <__udivmodhi4_ep>:
    14d0:	88 1f       	adc	r24, r24
    14d2:	99 1f       	adc	r25, r25
    14d4:	5a 95       	dec	r21
    14d6:	a9 f7       	brne	.-22     	; 0x14c2 <__udivmodhi4_loop>
    14d8:	80 95       	com	r24
    14da:	90 95       	com	r25
    14dc:	bc 01       	movw	r22, r24
    14de:	cd 01       	movw	r24, r26
    14e0:	08 95       	ret

000014e2 <__udivmodsi4>:
    14e2:	a1 e2       	ldi	r26, 0x21	; 33
    14e4:	1a 2e       	mov	r1, r26
    14e6:	aa 1b       	sub	r26, r26
    14e8:	bb 1b       	sub	r27, r27
    14ea:	fd 01       	movw	r30, r26
    14ec:	0d c0       	rjmp	.+26     	; 0x1508 <__udivmodsi4_ep>

000014ee <__udivmodsi4_loop>:
    14ee:	aa 1f       	adc	r26, r26
    14f0:	bb 1f       	adc	r27, r27
    14f2:	ee 1f       	adc	r30, r30
    14f4:	ff 1f       	adc	r31, r31
    14f6:	a2 17       	cp	r26, r18
    14f8:	b3 07       	cpc	r27, r19
    14fa:	e4 07       	cpc	r30, r20
    14fc:	f5 07       	cpc	r31, r21
    14fe:	20 f0       	brcs	.+8      	; 0x1508 <__udivmodsi4_ep>
    1500:	a2 1b       	sub	r26, r18
    1502:	b3 0b       	sbc	r27, r19
    1504:	e4 0b       	sbc	r30, r20
    1506:	f5 0b       	sbc	r31, r21

00001508 <__udivmodsi4_ep>:
    1508:	66 1f       	adc	r22, r22
    150a:	77 1f       	adc	r23, r23
    150c:	88 1f       	adc	r24, r24
    150e:	99 1f       	adc	r25, r25
    1510:	1a 94       	dec	r1
    1512:	69 f7       	brne	.-38     	; 0x14ee <__udivmodsi4_loop>
    1514:	60 95       	com	r22
    1516:	70 95       	com	r23
    1518:	80 95       	com	r24
    151a:	90 95       	com	r25
    151c:	9b 01       	movw	r18, r22
    151e:	ac 01       	movw	r20, r24
    1520:	bd 01       	movw	r22, r26
    1522:	cf 01       	movw	r24, r30
    1524:	08 95       	ret

00001526 <_exit>:
    1526:	f8 94       	cli

00001528 <__stop_program>:
    1528:	ff cf       	rjmp	.-2      	; 0x1528 <__stop_program>
