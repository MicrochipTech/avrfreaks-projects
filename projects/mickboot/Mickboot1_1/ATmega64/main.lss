
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000b4  00800100  0000ed30  00000dc4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000d30  0000e000  0000e000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002b7  008001b4  008001b4  00000e78  2**0
                  ALLOC
  3 .debug_aranges 000000c0  00000000  00000000  00000e78  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000002d2  00000000  00000000  00000f38  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000ee4  00000000  00000000  0000120a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000077e  00000000  00000000  000020ee  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000e5a  00000000  00000000  0000286c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001b0  00000000  00000000  000036c8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000042c  00000000  00000000  00003878  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000006c0  00000000  00000000  00003ca4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000d8  00000000  00000000  00004364  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0000e000 <__vectors>:
    e000:	0c 94 46 70 	jmp	0xe08c	; 0xe08c <__ctors_end>
    e004:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e008:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e00c:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e010:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e014:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e018:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e01c:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e020:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e024:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e028:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e02c:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e030:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e034:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e038:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e03c:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e040:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e044:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e048:	0c 94 68 72 	jmp	0xe4d0	; 0xe4d0 <__vector_18>
    e04c:	0c 94 e3 72 	jmp	0xe5c6	; 0xe5c6 <__vector_19>
    e050:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e054:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e058:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e05c:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e060:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e064:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e068:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e06c:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e070:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e074:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e078:	0c 94 a5 72 	jmp	0xe54a	; 0xe54a <__vector_30>
    e07c:	0c 94 2b 73 	jmp	0xe656	; 0xe656 <__vector_31>
    e080:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e084:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e088:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>

0000e08c <__ctors_end>:
    e08c:	11 24       	eor	r1, r1
    e08e:	1f be       	out	0x3f, r1	; 63
    e090:	cf ef       	ldi	r28, 0xFF	; 255
    e092:	d0 e1       	ldi	r29, 0x10	; 16
    e094:	de bf       	out	0x3e, r29	; 62
    e096:	cd bf       	out	0x3d, r28	; 61

0000e098 <__do_copy_data>:
    e098:	11 e0       	ldi	r17, 0x01	; 1
    e09a:	a0 e0       	ldi	r26, 0x00	; 0
    e09c:	b1 e0       	ldi	r27, 0x01	; 1
    e09e:	e0 e3       	ldi	r30, 0x30	; 48
    e0a0:	fd ee       	ldi	r31, 0xED	; 237
    e0a2:	02 c0       	rjmp	.+4      	; 0xe0a8 <.do_copy_data_start>

0000e0a4 <.do_copy_data_loop>:
    e0a4:	05 90       	lpm	r0, Z+
    e0a6:	0d 92       	st	X+, r0

0000e0a8 <.do_copy_data_start>:
    e0a8:	a4 3b       	cpi	r26, 0xB4	; 180
    e0aa:	b1 07       	cpc	r27, r17
    e0ac:	d9 f7       	brne	.-10     	; 0xe0a4 <.do_copy_data_loop>

0000e0ae <__do_clear_bss>:
    e0ae:	14 e0       	ldi	r17, 0x04	; 4
    e0b0:	a4 eb       	ldi	r26, 0xB4	; 180
    e0b2:	b1 e0       	ldi	r27, 0x01	; 1
    e0b4:	01 c0       	rjmp	.+2      	; 0xe0b8 <.do_clear_bss_start>

0000e0b6 <.do_clear_bss_loop>:
    e0b6:	1d 92       	st	X+, r1

0000e0b8 <.do_clear_bss_start>:
    e0b8:	ab 36       	cpi	r26, 0x6B	; 107
    e0ba:	b1 07       	cpc	r27, r17
    e0bc:	e1 f7       	brne	.-8      	; 0xe0b6 <.do_clear_bss_loop>
    e0be:	0e 94 65 70 	call	0xe0ca	; 0xe0ca <main>
    e0c2:	0c 94 96 76 	jmp	0xed2c	; 0xed2c <_exit>

0000e0c6 <__bad_interrupt>:
    e0c6:	0c 94 00 70 	jmp	0xe000	; 0xe000 <__vectors>

0000e0ca <main>:
	extern volatile unsigned char uart_select; //1=uart0 2=uart1


// Main application routine.
int main(void)
{
    e0ca:	ef 92       	push	r14
    e0cc:	ff 92       	push	r15
    e0ce:	1f 93       	push	r17
    e0d0:	cf 93       	push	r28
    e0d2:	df 93       	push	r29
	int timeout;
	char *char_ptr, failed, finished;
	
	if(uart_init())	// detect ' ' on com 1 or 0, then configure that port
    e0d4:	0e 94 78 73 	call	0xe6f0	; 0xe6f0 <uart_init>
    e0d8:	88 23       	and	r24, r24
    e0da:	09 f4       	brne	.+2      	; 0xe0de <main+0x14>
    e0dc:	bb c0       	rjmp	.+374    	; 0xe254 <main+0x18a>
	{
		MCUCR = _BV(IVCE);
    e0de:	81 e0       	ldi	r24, 0x01	; 1
    e0e0:	85 bf       	out	0x35, r24	; 53
		MCUCR = _BV(IVSEL);
    e0e2:	82 e0       	ldi	r24, 0x02	; 2
    e0e4:	85 bf       	out	0x35, r24	; 53
		
		sei();
    e0e6:	78 94       	sei
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    e0e8:	80 e4       	ldi	r24, 0x40	; 64
    e0ea:	e8 2e       	mov	r14, r24
    e0ec:	8c e9       	ldi	r24, 0x9C	; 156
    e0ee:	f8 2e       	mov	r15, r24
		do
		{
			timeout=TIMEOUT_ZPROMPT/0.010;
			UART_TX("\r\nMICKBOOT V1.1 Uart");
    e0f0:	80 e0       	ldi	r24, 0x00	; 0
    e0f2:	91 e0       	ldi	r25, 0x01	; 1
    e0f4:	0e 94 1f 72 	call	0xe43e	; 0xe43e <uart_write_string>
			
			if(UCSR1B & _BV(RXEN1))
    e0f8:	80 91 9a 00 	lds	r24, 0x009A
    e0fc:	84 ff       	sbrs	r24, 4
    e0fe:	03 c0       	rjmp	.+6      	; 0xe106 <main+0x3c>
				UART_TX("1");
    e100:	85 e1       	ldi	r24, 0x15	; 21
    e102:	91 e0       	ldi	r25, 0x01	; 1
    e104:	02 c0       	rjmp	.+4      	; 0xe10a <main+0x40>
			else
				UART_TX("0");
    e106:	87 e1       	ldi	r24, 0x17	; 23
    e108:	91 e0       	ldi	r25, 0x01	; 1
    e10a:	0e 94 1f 72 	call	0xe43e	; 0xe43e <uart_write_string>
			
			UART_TX("\r\nSend Z\r\n");
    e10e:	89 e1       	ldi	r24, 0x19	; 25
    e110:	91 e0       	ldi	r25, 0x01	; 1
    e112:	0e 94 1f 72 	call	0xe43e	; 0xe43e <uart_write_string>
    e116:	28 eb       	ldi	r18, 0xB8	; 184
    e118:	3b e0       	ldi	r19, 0x0B	; 11
			
			finished=FALSE;
			failed=FALSE;
			do
			{
				if(uart_fifo_rx.bytes_used)
    e11a:	80 91 c5 02 	lds	r24, 0x02C5
    e11e:	88 23       	and	r24, r24
    e120:	09 f4       	brne	.+2      	; 0xe124 <main+0x5a>
    e122:	70 c0       	rjmp	.+224    	; 0xe204 <main+0x13a>
				{
					timeout=TIMEOUT_ZPROMPT/0.010;
					if(fifo_read_char()=='Z')
    e124:	0e 94 b6 75 	call	0xeb6c	; 0xeb6c <fifo_read_char>
    e128:	8a 35       	cpi	r24, 0x5A	; 90
    e12a:	a9 f7       	brne	.-22     	; 0xe116 <main+0x4c>
					{
						UART_TX("\r\nSend hex file in ASCII\r\n");
    e12c:	84 e2       	ldi	r24, 0x24	; 36
    e12e:	91 e0       	ldi	r25, 0x01	; 1
    e130:	0e 94 1f 72 	call	0xe43e	; 0xe43e <uart_write_string>
						timeout=TIMEOUT_HEX_DATA/0.010;
						failed=FALSE;
						finished=FALSE;
						ihex_init();
    e134:	0e 94 8b 74 	call	0xe916	; 0xe916 <ihex_init>
    e138:	c0 e7       	ldi	r28, 0x70	; 112
    e13a:	d7 e1       	ldi	r29, 0x17	; 23
						do
						{
							if(uart_fifo_rx.bytes_used)
    e13c:	80 91 c5 02 	lds	r24, 0x02C5
    e140:	88 23       	and	r24, r24
    e142:	09 f4       	brne	.+2      	; 0xe146 <main+0x7c>
    e144:	41 c0       	rjmp	.+130    	; 0xe1c8 <main+0xfe>
							{
								timeout=TIMEOUT_HEX_DATA/0.010;
								ihex_char(fifo_read_char());
    e146:	0e 94 b6 75 	call	0xeb6c	; 0xeb6c <fifo_read_char>
    e14a:	0e 94 87 75 	call	0xeb0e	; 0xeb0e <ihex_char>
								if(ihex_byte_count)
    e14e:	80 91 2e 04 	lds	r24, 0x042E
    e152:	88 23       	and	r24, r24
    e154:	39 f1       	breq	.+78     	; 0xe1a4 <main+0xda>
    e156:	ce e1       	ldi	r28, 0x1E	; 30
    e158:	d4 e0       	ldi	r29, 0x04	; 4
    e15a:	1b c0       	rjmp	.+54     	; 0xe192 <main+0xc8>
								{
									char_ptr = ihex_data;
									while(ihex_byte_count--)
										flash_byte(ihex_address++, *char_ptr++);
    e15c:	60 91 b8 01 	lds	r22, 0x01B8
    e160:	70 91 b9 01 	lds	r23, 0x01B9
    e164:	80 91 ba 01 	lds	r24, 0x01BA
    e168:	90 91 bb 01 	lds	r25, 0x01BB
    e16c:	6f 5f       	subi	r22, 0xFF	; 255
    e16e:	7f 4f       	sbci	r23, 0xFF	; 255
    e170:	8f 4f       	sbci	r24, 0xFF	; 255
    e172:	9f 4f       	sbci	r25, 0xFF	; 255
    e174:	60 93 b8 01 	sts	0x01B8, r22
    e178:	70 93 b9 01 	sts	0x01B9, r23
    e17c:	80 93 ba 01 	sts	0x01BA, r24
    e180:	90 93 bb 01 	sts	0x01BB, r25
    e184:	61 50       	subi	r22, 0x01	; 1
    e186:	70 40       	sbci	r23, 0x00	; 0
    e188:	80 40       	sbci	r24, 0x00	; 0
    e18a:	90 40       	sbci	r25, 0x00	; 0
    e18c:	49 91       	ld	r20, Y+
    e18e:	0e 94 b3 71 	call	0xe366	; 0xe366 <flash_byte>
								timeout=TIMEOUT_HEX_DATA/0.010;
								ihex_char(fifo_read_char());
								if(ihex_byte_count)
								{
									char_ptr = ihex_data;
									while(ihex_byte_count--)
    e192:	80 91 2e 04 	lds	r24, 0x042E
    e196:	81 50       	subi	r24, 0x01	; 1
    e198:	80 93 2e 04 	sts	0x042E, r24
    e19c:	8f 5f       	subi	r24, 0xFF	; 255
    e19e:	f1 f6       	brne	.-68     	; 0xe15c <main+0x92>
										flash_byte(ihex_address++, *char_ptr++);
									ihex_byte_count=0;
    e1a0:	10 92 2e 04 	sts	0x042E, r1
								};
								if(ihex_status==IHEX_STATUS_EOF)
    e1a4:	80 91 1d 04 	lds	r24, 0x041D
    e1a8:	81 30       	cpi	r24, 0x01	; 1
    e1aa:	09 f0       	breq	.+2      	; 0xe1ae <main+0xe4>
    e1ac:	60 c0       	rjmp	.+192    	; 0xe26e <main+0x1a4>
								{
									flash_finish();
    e1ae:	0e 94 b0 71 	call	0xe360	; 0xe360 <flash_finish>
									if(!writer_failed)
    e1b2:	80 91 b6 01 	lds	r24, 0x01B6
    e1b6:	88 23       	and	r24, r24
    e1b8:	09 f0       	breq	.+2      	; 0xe1bc <main+0xf2>
    e1ba:	59 c0       	rjmp	.+178    	; 0xe26e <main+0x1a4>
									{
										UART_TX("Success!\r\n");
    e1bc:	8f e3       	ldi	r24, 0x3F	; 63
    e1be:	91 e0       	ldi	r25, 0x01	; 1
    e1c0:	0e 94 1f 72 	call	0xe43e	; 0xe43e <uart_write_string>
    e1c4:	11 e0       	ldi	r17, 0x01	; 1
    e1c6:	54 c0       	rjmp	.+168    	; 0xe270 <main+0x1a6>
									};							
								};
							}
							else
							{
								timeout--;
    e1c8:	21 97       	sbiw	r28, 0x01	; 1
    e1ca:	c7 01       	movw	r24, r14
    e1cc:	01 97       	sbiw	r24, 0x01	; 1
    e1ce:	f1 f7       	brne	.-4      	; 0xe1cc <main+0x102>
								_delay_ms(10);
							};
							
							if(!timeout)	//if timeout looking for hex data, repeat Z prompt
    e1d0:	20 97       	sbiw	r28, 0x00	; 0
    e1d2:	11 f0       	breq	.+4      	; 0xe1d8 <main+0x10e>
    e1d4:	90 e0       	ldi	r25, 0x00	; 0
    e1d6:	05 c0       	rjmp	.+10     	; 0xe1e2 <main+0x118>
							{
								UART_TX("Timeout waiting for hex data\r\n");
    e1d8:	8a e4       	ldi	r24, 0x4A	; 74
    e1da:	91 e0       	ldi	r25, 0x01	; 1
    e1dc:	0e 94 1f 72 	call	0xe43e	; 0xe43e <uart_write_string>
    e1e0:	91 e0       	ldi	r25, 0x01	; 1
    e1e2:	10 e0       	ldi	r17, 0x00	; 0
								failed=TRUE;
							};
							
							if(ihex_status == IHEX_STATUS_ERROR)
    e1e4:	80 91 1d 04 	lds	r24, 0x041D
    e1e8:	82 30       	cpi	r24, 0x02	; 2
    e1ea:	29 f4       	brne	.+10     	; 0xe1f6 <main+0x12c>
							{
								UART_TX("Hex file ERROR!\r\n");
    e1ec:	89 e6       	ldi	r24, 0x69	; 105
    e1ee:	91 e0       	ldi	r25, 0x01	; 1
    e1f0:	0e 94 1f 72 	call	0xe43e	; 0xe43e <uart_write_string>
    e1f4:	41 c0       	rjmp	.+130    	; 0xe278 <main+0x1ae>
								failed=TRUE;
							};
							
						}while(!failed && !finished);
    e1f6:	99 23       	and	r25, r25
    e1f8:	09 f0       	breq	.+2      	; 0xe1fc <main+0x132>
    e1fa:	3e c0       	rjmp	.+124    	; 0xe278 <main+0x1ae>
    e1fc:	11 23       	and	r17, r17
    e1fe:	09 f4       	brne	.+2      	; 0xe202 <main+0x138>
    e200:	9d cf       	rjmp	.-198    	; 0xe13c <main+0x72>
    e202:	0d c0       	rjmp	.+26     	; 0xe21e <main+0x154>
					};
				}
				else
				{
					timeout--;
    e204:	21 50       	subi	r18, 0x01	; 1
    e206:	30 40       	sbci	r19, 0x00	; 0
    e208:	c7 01       	movw	r24, r14
    e20a:	01 97       	sbiw	r24, 0x01	; 1
    e20c:	f1 f7       	brne	.-4      	; 0xe20a <main+0x140>
					_delay_ms(10);
					if(!timeout)	//if timeout looking for Z, finish and run main app
    e20e:	21 15       	cp	r18, r1
    e210:	31 05       	cpc	r19, r1
    e212:	09 f0       	breq	.+2      	; 0xe216 <main+0x14c>
    e214:	82 cf       	rjmp	.-252    	; 0xe11a <main+0x50>
					{
						finished=TRUE;
						UART_TX("Timeout waiting for Z\r\n");
    e216:	8b e7       	ldi	r24, 0x7B	; 123
    e218:	91 e0       	ldi	r25, 0x01	; 1
    e21a:	0e 94 1f 72 	call	0xe43e	; 0xe43e <uart_write_string>
			}while(!failed && !finished);
			
		//repeat Z prompt until finished
		}while(!finished);
		
		UART_TX("RUNNING\r\n");
    e21e:	83 e9       	ldi	r24, 0x93	; 147
    e220:	91 e0       	ldi	r25, 0x01	; 1
    e222:	0e 94 1f 72 	call	0xe43e	; 0xe43e <uart_write_string>
    e226:	88 e8       	ldi	r24, 0x88	; 136
    e228:	93 e1       	ldi	r25, 0x13	; 19
    e22a:	20 e9       	ldi	r18, 0x90	; 144
    e22c:	31 e0       	ldi	r19, 0x01	; 1
    e22e:	f9 01       	movw	r30, r18
    e230:	31 97       	sbiw	r30, 0x01	; 1
    e232:	f1 f7       	brne	.-4      	; 0xe230 <main+0x166>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    e234:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    e236:	d9 f7       	brne	.-10     	; 0xe22e <main+0x164>
		_delay_ms(500);
		cli();
    e238:	f8 94       	cli
		MCUCR = _BV(IVCE);
    e23a:	81 e0       	ldi	r24, 0x01	; 1
    e23c:	85 bf       	out	0x35, r24	; 53
		MCUCR = 0;
    e23e:	15 be       	out	0x35, r1	; 53
		wdt_enable(WDTO_15MS);
    e240:	28 e0       	ldi	r18, 0x08	; 8
    e242:	88 e1       	ldi	r24, 0x18	; 24
    e244:	90 e0       	ldi	r25, 0x00	; 0
    e246:	0f b6       	in	r0, 0x3f	; 63
    e248:	f8 94       	cli
    e24a:	a8 95       	wdr
    e24c:	81 bd       	out	0x21, r24	; 33
    e24e:	0f be       	out	0x3f, r0	; 63
    e250:	21 bd       	out	0x21, r18	; 33
    e252:	ff cf       	rjmp	.-2      	; 0xe252 <main+0x188>
		while(1);
		//once finished run main app
	};
	
	(*mainapp)();
    e254:	e0 91 b4 01 	lds	r30, 0x01B4
    e258:	f0 91 b5 01 	lds	r31, 0x01B5
    e25c:	09 95       	icall

	return 0;
}
    e25e:	80 e0       	ldi	r24, 0x00	; 0
    e260:	90 e0       	ldi	r25, 0x00	; 0
    e262:	df 91       	pop	r29
    e264:	cf 91       	pop	r28
    e266:	1f 91       	pop	r17
    e268:	ff 90       	pop	r15
    e26a:	ef 90       	pop	r14
    e26c:	08 95       	ret
		wdt_enable(WDTO_15MS);
		while(1);
		//once finished run main app
	};
	
	(*mainapp)();
    e26e:	10 e0       	ldi	r17, 0x00	; 0
    e270:	90 e0       	ldi	r25, 0x00	; 0
    e272:	c0 e7       	ldi	r28, 0x70	; 112
    e274:	d7 e1       	ldi	r29, 0x17	; 23
    e276:	b6 cf       	rjmp	.-148    	; 0xe1e4 <main+0x11a>
				
			//look for Z while not failed and not finished (a failure must repeat z prompt)
			}while(!failed && !finished);
			
		//repeat Z prompt until finished
		}while(!finished);
    e278:	11 23       	and	r17, r17
    e27a:	09 f4       	brne	.+2      	; 0xe27e <main+0x1b4>
    e27c:	39 cf       	rjmp	.-398    	; 0xe0f0 <main+0x26>
    e27e:	cf cf       	rjmp	.-98     	; 0xe21e <main+0x154>

0000e280 <write_page>:
{
	write_page();
}

void write_page(void)
{		
    e280:	df 92       	push	r13
    e282:	ef 92       	push	r14
    e284:	ff 92       	push	r15
    e286:	0f 93       	push	r16
    e288:	1f 93       	push	r17
    e28a:	cf 93       	push	r28
    e28c:	df 93       	push	r29
    e28e:	1a e0       	ldi	r17, 0x0A	; 10
			tempint2=buffer_verify[tempint+1];
			tempint2<<=8;
			tempint2+=buffer_verify[tempint];
			ATOMIC_BLOCK(ATOMIC_FORCEON)
			{
				boot_page_fill(progmem_add, tempint2);	
    e290:	dd 24       	eor	r13, r13
    e292:	d3 94       	inc	r13
			tempint+=2;
		};
		
		ATOMIC_BLOCK(ATOMIC_FORCEON)
		{
			boot_page_erase(current_page);
    e294:	93 e0       	ldi	r25, 0x03	; 3
    e296:	e9 2e       	mov	r14, r25
		}
		boot_spm_busy_wait();      // Wait until the memory is erased.
		ATOMIC_BLOCK(ATOMIC_FORCEON)
		{
			boot_page_write(current_page);
    e298:	85 e0       	ldi	r24, 0x05	; 5
    e29a:	f8 2e       	mov	r15, r24
		}
		boot_spm_busy_wait();      // Wait until the memory is programmed.
		
		progmem_add = current_page;
		boot_rww_enable();
    e29c:	01 e1       	ldi	r16, 0x11	; 17
	unsigned int tempint, tempint2;
	
	do
	{
		//fill buffer
		progmem_add = current_page;
    e29e:	20 91 b1 01 	lds	r18, 0x01B1
    e2a2:	30 91 b2 01 	lds	r19, 0x01B2
    e2a6:	a4 ec       	ldi	r26, 0xC4	; 196
    e2a8:	b1 e0       	ldi	r27, 0x01	; 1
		tempint=0;
		while(tempint!=FLASH_PAGE_SIZE)
		{
			tempint2=buffer_verify[tempint+1];
			tempint2<<=8;
    e2aa:	11 96       	adiw	r26, 0x01	; 1
    e2ac:	dc 91       	ld	r29, X
    e2ae:	11 97       	sbiw	r26, 0x01	; 1
    e2b0:	c0 e0       	ldi	r28, 0x00	; 0
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    e2b2:	f8 94       	cli
			tempint2+=buffer_verify[tempint];
			ATOMIC_BLOCK(ATOMIC_FORCEON)
			{
				boot_page_fill(progmem_add, tempint2);	
    e2b4:	8c 91       	ld	r24, X
    e2b6:	ae 01       	movw	r20, r28
    e2b8:	48 0f       	add	r20, r24
    e2ba:	51 1d       	adc	r21, r1
    e2bc:	f9 01       	movw	r30, r18
    e2be:	0a 01       	movw	r0, r20
    e2c0:	d0 92 68 00 	sts	0x0068, r13
    e2c4:	e8 95       	spm
    e2c6:	11 24       	eor	r1, r1
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    e2c8:	78 94       	sei
			}
			progmem_add+=2;
    e2ca:	2e 5f       	subi	r18, 0xFE	; 254
    e2cc:	3f 4f       	sbci	r19, 0xFF	; 255
    e2ce:	12 96       	adiw	r26, 0x02	; 2
	do
	{
		//fill buffer
		progmem_add = current_page;
		tempint=0;
		while(tempint!=FLASH_PAGE_SIZE)
    e2d0:	f2 e0       	ldi	r31, 0x02	; 2
    e2d2:	a4 3c       	cpi	r26, 0xC4	; 196
    e2d4:	bf 07       	cpc	r27, r31
    e2d6:	49 f7       	brne	.-46     	; 0xe2aa <write_page+0x2a>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    e2d8:	f8 94       	cli
			tempint+=2;
		};
		
		ATOMIC_BLOCK(ATOMIC_FORCEON)
		{
			boot_page_erase(current_page);
    e2da:	e0 91 b1 01 	lds	r30, 0x01B1
    e2de:	f0 91 b2 01 	lds	r31, 0x01B2
    e2e2:	e0 92 68 00 	sts	0x0068, r14
    e2e6:	e8 95       	spm
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    e2e8:	78 94       	sei
		}
		boot_spm_busy_wait();      // Wait until the memory is erased.
    e2ea:	80 91 68 00 	lds	r24, 0x0068
    e2ee:	80 fd       	sbrc	r24, 0
    e2f0:	fc cf       	rjmp	.-8      	; 0xe2ea <write_page+0x6a>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    e2f2:	f8 94       	cli
		ATOMIC_BLOCK(ATOMIC_FORCEON)
		{
			boot_page_write(current_page);
    e2f4:	e0 91 b1 01 	lds	r30, 0x01B1
    e2f8:	f0 91 b2 01 	lds	r31, 0x01B2
    e2fc:	f0 92 68 00 	sts	0x0068, r15
    e300:	e8 95       	spm
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    e302:	78 94       	sei
		}
		boot_spm_busy_wait();      // Wait until the memory is programmed.
    e304:	80 91 68 00 	lds	r24, 0x0068
    e308:	80 fd       	sbrc	r24, 0
    e30a:	fc cf       	rjmp	.-8      	; 0xe304 <write_page+0x84>
		
		progmem_add = current_page;
		boot_rww_enable();
    e30c:	00 93 68 00 	sts	0x0068, r16
    e310:	e8 95       	spm
		
		if( memcmp_P(buffer_verify, (PGM_P)progmem_add, FLASH_PAGE_SIZE) )
    e312:	60 91 b1 01 	lds	r22, 0x01B1
    e316:	70 91 b2 01 	lds	r23, 0x01B2
    e31a:	84 ec       	ldi	r24, 0xC4	; 196
    e31c:	91 e0       	ldi	r25, 0x01	; 1
    e31e:	40 e0       	ldi	r20, 0x00	; 0
    e320:	51 e0       	ldi	r21, 0x01	; 1
    e322:	0e 94 17 76 	call	0xec2e	; 0xec2e <memcmp_P>
    e326:	89 2b       	or	r24, r25
    e328:	11 f4       	brne	.+4      	; 0xe32e <write_page+0xae>
    e32a:	81 e0       	ldi	r24, 0x01	; 1
    e32c:	06 c0       	rjmp	.+12     	; 0xe33a <write_page+0xba>
		{
			UART_TX("Retrying\r\n");
    e32e:	8d e9       	ldi	r24, 0x9D	; 157
    e330:	91 e0       	ldi	r25, 0x01	; 1
    e332:	0e 94 1f 72 	call	0xe43e	; 0xe43e <uart_write_string>
			retry--;
    e336:	11 50       	subi	r17, 0x01	; 1
    e338:	80 e0       	ldi	r24, 0x00	; 0
		}
		else
			verified=TRUE;
			
	}while(retry && !verified);
    e33a:	11 23       	and	r17, r17
    e33c:	21 f0       	breq	.+8      	; 0xe346 <write_page+0xc6>
    e33e:	88 23       	and	r24, r24
    e340:	09 f4       	brne	.+2      	; 0xe344 <write_page+0xc4>
    e342:	ad cf       	rjmp	.-166    	; 0xe29e <write_page+0x1e>
    e344:	05 c0       	rjmp	.+10     	; 0xe350 <write_page+0xd0>
	
	if(!verified)
    e346:	88 23       	and	r24, r24
    e348:	19 f4       	brne	.+6      	; 0xe350 <write_page+0xd0>
		writer_failed=TRUE;
    e34a:	81 e0       	ldi	r24, 0x01	; 1
    e34c:	80 93 b6 01 	sts	0x01B6, r24
}
    e350:	df 91       	pop	r29
    e352:	cf 91       	pop	r28
    e354:	1f 91       	pop	r17
    e356:	0f 91       	pop	r16
    e358:	ff 90       	pop	r15
    e35a:	ef 90       	pop	r14
    e35c:	df 90       	pop	r13
    e35e:	08 95       	ret

0000e360 <flash_finish>:
	write_needed=TRUE;
}

void flash_finish(void)
{
	write_page();
    e360:	0e 94 40 71 	call	0xe280	; 0xe280 <write_page>
}
    e364:	08 95       	ret

0000e366 <flash_byte>:
	char memcmp_farP(void* ram_ptr, unsigned long progmem_add, unsigned int size);
	void write_page(void);

// call with bytes, builds pages and writes pages to flash.
void flash_byte(unsigned long address, char byte)
{
    e366:	df 92       	push	r13
    e368:	ef 92       	push	r14
    e36a:	ff 92       	push	r15
    e36c:	0f 93       	push	r16
    e36e:	1f 93       	push	r17
    e370:	df 93       	push	r29
    e372:	cf 93       	push	r28
    e374:	cd b7       	in	r28, 0x3d	; 61
    e376:	de b7       	in	r29, 0x3e	; 62
    e378:	2a 97       	sbiw	r28, 0x0a	; 10
    e37a:	0f b6       	in	r0, 0x3f	; 63
    e37c:	f8 94       	cli
    e37e:	de bf       	out	0x3e, r29	; 62
    e380:	0f be       	out	0x3f, r0	; 63
    e382:	cd bf       	out	0x3d, r28	; 61
    e384:	7b 01       	movw	r14, r22
    e386:	8c 01       	movw	r16, r24
    e388:	d4 2e       	mov	r13, r20
	static char write_needed=FALSE;
	int tempint=0;
	unsigned int progmem_add;

	//new page?
	if((address & FLASH_PAGE_MASK) != current_page)
    e38a:	9b 01       	movw	r18, r22
    e38c:	ac 01       	movw	r20, r24
    e38e:	20 70       	andi	r18, 0x00	; 0
    e390:	40 70       	andi	r20, 0x00	; 0
    e392:	50 70       	andi	r21, 0x00	; 0
    e394:	80 91 b1 01 	lds	r24, 0x01B1
    e398:	90 91 b2 01 	lds	r25, 0x01B2
    e39c:	a0 e0       	ldi	r26, 0x00	; 0
    e39e:	b0 e0       	ldi	r27, 0x00	; 0
    e3a0:	28 17       	cp	r18, r24
    e3a2:	39 07       	cpc	r19, r25
    e3a4:	4a 07       	cpc	r20, r26
    e3a6:	5b 07       	cpc	r21, r27
    e3a8:	a1 f1       	breq	.+104    	; 0xe412 <flash_byte+0xac>
	{
		//write previous page (if there is one)
		if(write_needed)
    e3aa:	80 91 b7 01 	lds	r24, 0x01B7
    e3ae:	88 23       	and	r24, r24
    e3b0:	11 f0       	breq	.+4      	; 0xe3b6 <flash_byte+0x50>
			write_page();
    e3b2:	0e 94 40 71 	call	0xe280	; 0xe280 <write_page>
		
		current_page = (unsigned int)address & FLASH_PAGE_MASK;
    e3b6:	c7 01       	movw	r24, r14
    e3b8:	80 70       	andi	r24, 0x00	; 0
    e3ba:	90 93 b2 01 	sts	0x01B2, r25
    e3be:	80 93 b1 01 	sts	0x01B1, r24
		
		UART_TX("PAGE ");
    e3c2:	88 ea       	ldi	r24, 0xA8	; 168
    e3c4:	91 e0       	ldi	r25, 0x01	; 1
    e3c6:	0e 94 1f 72 	call	0xe43e	; 0xe43e <uart_write_string>
		UART_TX(ltoa(current_page, tempbuf, 16));
    e3ca:	60 91 b1 01 	lds	r22, 0x01B1
    e3ce:	70 91 b2 01 	lds	r23, 0x01B2
    e3d2:	80 e0       	ldi	r24, 0x00	; 0
    e3d4:	90 e0       	ldi	r25, 0x00	; 0
    e3d6:	ae 01       	movw	r20, r28
    e3d8:	4f 5f       	subi	r20, 0xFF	; 255
    e3da:	5f 4f       	sbci	r21, 0xFF	; 255
    e3dc:	20 e1       	ldi	r18, 0x10	; 16
    e3de:	30 e0       	ldi	r19, 0x00	; 0
    e3e0:	0e 94 2d 76 	call	0xec5a	; 0xec5a <ltoa>
    e3e4:	0e 94 1f 72 	call	0xe43e	; 0xe43e <uart_write_string>
		UART_TX("\r\n");
    e3e8:	8e ea       	ldi	r24, 0xAE	; 174
    e3ea:	91 e0       	ldi	r25, 0x01	; 1
    e3ec:	0e 94 1f 72 	call	0xe43e	; 0xe43e <uart_write_string>
		
		//read new page into buffer
		progmem_add = current_page;
    e3f0:	e0 91 b1 01 	lds	r30, 0x01B1
    e3f4:	f0 91 b2 01 	lds	r31, 0x01B2
    e3f8:	a4 ec       	ldi	r26, 0xC4	; 196
    e3fa:	b1 e0       	ldi	r27, 0x01	; 1
		tempint=0;
		while(tempint!=FLASH_PAGE_SIZE)
			buffer_verify[tempint++]=pgm_read_byte(progmem_add++);
    e3fc:	9f 01       	movw	r18, r30
    e3fe:	2f 5f       	subi	r18, 0xFF	; 255
    e400:	3f 4f       	sbci	r19, 0xFF	; 255
    e402:	84 91       	lpm	r24, Z+
    e404:	8d 93       	st	X+, r24
		UART_TX("\r\n");
		
		//read new page into buffer
		progmem_add = current_page;
		tempint=0;
		while(tempint!=FLASH_PAGE_SIZE)
    e406:	82 e0       	ldi	r24, 0x02	; 2
    e408:	a4 3c       	cpi	r26, 0xC4	; 196
    e40a:	b8 07       	cpc	r27, r24
    e40c:	11 f0       	breq	.+4      	; 0xe412 <flash_byte+0xac>
    e40e:	f9 01       	movw	r30, r18
    e410:	f5 cf       	rjmp	.-22     	; 0xe3fc <flash_byte+0x96>
			buffer_verify[tempint++]=pgm_read_byte(progmem_add++);
	};

	buffer_verify[address&0xFF]=byte;
    e412:	f7 01       	movw	r30, r14
    e414:	f0 70       	andi	r31, 0x00	; 0
    e416:	ec 53       	subi	r30, 0x3C	; 60
    e418:	fe 4f       	sbci	r31, 0xFE	; 254
    e41a:	d0 82       	st	Z, r13

	write_needed=TRUE;
    e41c:	81 e0       	ldi	r24, 0x01	; 1
    e41e:	80 93 b7 01 	sts	0x01B7, r24
}
    e422:	2a 96       	adiw	r28, 0x0a	; 10
    e424:	0f b6       	in	r0, 0x3f	; 63
    e426:	f8 94       	cli
    e428:	de bf       	out	0x3e, r29	; 62
    e42a:	0f be       	out	0x3f, r0	; 63
    e42c:	cd bf       	out	0x3d, r28	; 61
    e42e:	cf 91       	pop	r28
    e430:	df 91       	pop	r29
    e432:	1f 91       	pop	r17
    e434:	0f 91       	pop	r16
    e436:	ff 90       	pop	r15
    e438:	ef 90       	pop	r14
    e43a:	df 90       	pop	r13
    e43c:	08 95       	ret

0000e43e <uart_write_string>:
	};
	return found;
}

void uart_write_string(char*string)
{
    e43e:	cf 93       	push	r28
    e440:	df 93       	push	r29
    e442:	ec 01       	movw	r28, r24
    e444:	37 c0       	rjmp	.+110    	; 0xe4b4 <uart_write_string+0x76>
	while(*string)
	{
		while(uart_fifo_tx.bytes_free==0);
    e446:	80 91 cf 03 	lds	r24, 0x03CF
    e44a:	88 23       	and	r24, r24
    e44c:	e1 f3       	breq	.-8      	; 0xe446 <uart_write_string+0x8>
		
		*((char*)uart_fifo_tx.head_ptr) = *string;
    e44e:	e0 91 d1 03 	lds	r30, 0x03D1
    e452:	f0 91 d2 03 	lds	r31, 0x03D2
    e456:	90 83       	st	Z, r25
		uart_fifo_tx.head_ptr++;
    e458:	80 91 d1 03 	lds	r24, 0x03D1
    e45c:	90 91 d2 03 	lds	r25, 0x03D2
    e460:	01 96       	adiw	r24, 0x01	; 1
    e462:	90 93 d2 03 	sts	0x03D2, r25
    e466:	80 93 d1 03 	sts	0x03D1, r24
		
		if(uart_fifo_tx.head_ptr == uart_fifo_tx.end)
    e46a:	20 91 d1 03 	lds	r18, 0x03D1
    e46e:	30 91 d2 03 	lds	r19, 0x03D2
    e472:	80 91 d7 03 	lds	r24, 0x03D7
    e476:	90 91 d8 03 	lds	r25, 0x03D8
    e47a:	28 17       	cp	r18, r24
    e47c:	39 07       	cpc	r19, r25
    e47e:	41 f4       	brne	.+16     	; 0xe490 <uart_write_string+0x52>
			uart_fifo_tx.head_ptr = uart_fifo_tx.start;
    e480:	80 91 d5 03 	lds	r24, 0x03D5
    e484:	90 91 d6 03 	lds	r25, 0x03D6
    e488:	90 93 d2 03 	sts	0x03D2, r25
    e48c:	80 93 d1 03 	sts	0x03D1, r24
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    e490:	f8 94       	cli
		
		ATOMIC_BLOCK(ATOMIC_FORCEON)
		{
			uart_fifo_tx.bytes_free --;
    e492:	80 91 cf 03 	lds	r24, 0x03CF
    e496:	81 50       	subi	r24, 0x01	; 1
    e498:	80 93 cf 03 	sts	0x03CF, r24
			uart_fifo_tx.bytes_used ++;
    e49c:	80 91 d0 03 	lds	r24, 0x03D0
    e4a0:	8f 5f       	subi	r24, 0xFF	; 255
    e4a2:	80 93 d0 03 	sts	0x03D0, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    e4a6:	78 94       	sei
		}
		
		uart_fifo_tx.post_fptr();
    e4a8:	e0 91 d9 03 	lds	r30, 0x03D9
    e4ac:	f0 91 da 03 	lds	r31, 0x03DA
    e4b0:	09 95       	icall
		string++;
    e4b2:	21 96       	adiw	r28, 0x01	; 1
	return found;
}

void uart_write_string(char*string)
{
	while(*string)
    e4b4:	98 81       	ld	r25, Y
    e4b6:	99 23       	and	r25, r25
    e4b8:	31 f6       	brne	.-116    	; 0xe446 <uart_write_string+0x8>
		}
		
		uart_fifo_tx.post_fptr();
		string++;
	};
}
    e4ba:	df 91       	pop	r29
    e4bc:	cf 91       	pop	r28
    e4be:	08 95       	ret

0000e4c0 <uart0_isrtx_enable>:

void uart0_isrtx_enable(void)
{
	UCSR0B |= _BV(UDRIE0);	// tx interrupt
    e4c0:	55 9a       	sbi	0x0a, 5	; 10
}
    e4c2:	08 95       	ret

0000e4c4 <uart1_isrtx_enable>:

void uart1_isrtx_enable(void)
{
	UCSR1B |= _BV(UDRIE1);	// tx interrupt
    e4c4:	ea e9       	ldi	r30, 0x9A	; 154
    e4c6:	f0 e0       	ldi	r31, 0x00	; 0
    e4c8:	80 81       	ld	r24, Z
    e4ca:	80 62       	ori	r24, 0x20	; 32
    e4cc:	80 83       	st	Z, r24
}
    e4ce:	08 95       	ret

0000e4d0 <__vector_18>:

ISR(USART0_RX_vect)
{
    e4d0:	1f 92       	push	r1
    e4d2:	0f 92       	push	r0
    e4d4:	0f b6       	in	r0, 0x3f	; 63
    e4d6:	0f 92       	push	r0
    e4d8:	11 24       	eor	r1, r1
    e4da:	2f 93       	push	r18
    e4dc:	3f 93       	push	r19
    e4de:	8f 93       	push	r24
    e4e0:	9f 93       	push	r25
    e4e2:	ef 93       	push	r30
    e4e4:	ff 93       	push	r31
	*((char*)uart_fifo_rx.head_ptr) = UDR0;
    e4e6:	e0 91 c6 02 	lds	r30, 0x02C6
    e4ea:	f0 91 c7 02 	lds	r31, 0x02C7
    e4ee:	8c b1       	in	r24, 0x0c	; 12
    e4f0:	80 83       	st	Z, r24
	uart_fifo_rx.head_ptr++;
    e4f2:	80 91 c6 02 	lds	r24, 0x02C6
    e4f6:	90 91 c7 02 	lds	r25, 0x02C7
    e4fa:	01 96       	adiw	r24, 0x01	; 1
    e4fc:	90 93 c7 02 	sts	0x02C7, r25
    e500:	80 93 c6 02 	sts	0x02C6, r24

	if(uart_fifo_rx.head_ptr == uart_fifo_rx.end)
    e504:	20 91 c6 02 	lds	r18, 0x02C6
    e508:	30 91 c7 02 	lds	r19, 0x02C7
    e50c:	80 91 cc 02 	lds	r24, 0x02CC
    e510:	90 91 cd 02 	lds	r25, 0x02CD
    e514:	28 17       	cp	r18, r24
    e516:	39 07       	cpc	r19, r25
    e518:	41 f4       	brne	.+16     	; 0xe52a <__vector_18+0x5a>
		uart_fifo_rx.head_ptr = uart_fifo_rx.start;	
    e51a:	80 91 ca 02 	lds	r24, 0x02CA
    e51e:	90 91 cb 02 	lds	r25, 0x02CB
    e522:	90 93 c7 02 	sts	0x02C7, r25
    e526:	80 93 c6 02 	sts	0x02C6, r24
	uart_fifo_rx.bytes_used ++;
    e52a:	80 91 c5 02 	lds	r24, 0x02C5
    e52e:	8f 5f       	subi	r24, 0xFF	; 255
    e530:	80 93 c5 02 	sts	0x02C5, r24
}
    e534:	ff 91       	pop	r31
    e536:	ef 91       	pop	r30
    e538:	9f 91       	pop	r25
    e53a:	8f 91       	pop	r24
    e53c:	3f 91       	pop	r19
    e53e:	2f 91       	pop	r18
    e540:	0f 90       	pop	r0
    e542:	0f be       	out	0x3f, r0	; 63
    e544:	0f 90       	pop	r0
    e546:	1f 90       	pop	r1
    e548:	18 95       	reti

0000e54a <__vector_30>:

ISR(USART1_RX_vect)
{
    e54a:	1f 92       	push	r1
    e54c:	0f 92       	push	r0
    e54e:	0f b6       	in	r0, 0x3f	; 63
    e550:	0f 92       	push	r0
    e552:	11 24       	eor	r1, r1
    e554:	2f 93       	push	r18
    e556:	3f 93       	push	r19
    e558:	8f 93       	push	r24
    e55a:	9f 93       	push	r25
    e55c:	ef 93       	push	r30
    e55e:	ff 93       	push	r31
	*((char*)uart_fifo_rx.head_ptr) = UDR1;
    e560:	e0 91 c6 02 	lds	r30, 0x02C6
    e564:	f0 91 c7 02 	lds	r31, 0x02C7
    e568:	80 91 9c 00 	lds	r24, 0x009C
    e56c:	80 83       	st	Z, r24
	uart_fifo_rx.head_ptr++;
    e56e:	80 91 c6 02 	lds	r24, 0x02C6
    e572:	90 91 c7 02 	lds	r25, 0x02C7
    e576:	01 96       	adiw	r24, 0x01	; 1
    e578:	90 93 c7 02 	sts	0x02C7, r25
    e57c:	80 93 c6 02 	sts	0x02C6, r24

	if(uart_fifo_rx.head_ptr == uart_fifo_rx.end)
    e580:	20 91 c6 02 	lds	r18, 0x02C6
    e584:	30 91 c7 02 	lds	r19, 0x02C7
    e588:	80 91 cc 02 	lds	r24, 0x02CC
    e58c:	90 91 cd 02 	lds	r25, 0x02CD
    e590:	28 17       	cp	r18, r24
    e592:	39 07       	cpc	r19, r25
    e594:	41 f4       	brne	.+16     	; 0xe5a6 <__vector_30+0x5c>
		uart_fifo_rx.head_ptr = uart_fifo_rx.start;	
    e596:	80 91 ca 02 	lds	r24, 0x02CA
    e59a:	90 91 cb 02 	lds	r25, 0x02CB
    e59e:	90 93 c7 02 	sts	0x02C7, r25
    e5a2:	80 93 c6 02 	sts	0x02C6, r24
	uart_fifo_rx.bytes_used ++;
    e5a6:	80 91 c5 02 	lds	r24, 0x02C5
    e5aa:	8f 5f       	subi	r24, 0xFF	; 255
    e5ac:	80 93 c5 02 	sts	0x02C5, r24
}
    e5b0:	ff 91       	pop	r31
    e5b2:	ef 91       	pop	r30
    e5b4:	9f 91       	pop	r25
    e5b6:	8f 91       	pop	r24
    e5b8:	3f 91       	pop	r19
    e5ba:	2f 91       	pop	r18
    e5bc:	0f 90       	pop	r0
    e5be:	0f be       	out	0x3f, r0	; 63
    e5c0:	0f 90       	pop	r0
    e5c2:	1f 90       	pop	r1
    e5c4:	18 95       	reti

0000e5c6 <__vector_19>:

ISR(USART0_UDRE_vect)
{
    e5c6:	1f 92       	push	r1
    e5c8:	0f 92       	push	r0
    e5ca:	0f b6       	in	r0, 0x3f	; 63
    e5cc:	0f 92       	push	r0
    e5ce:	11 24       	eor	r1, r1
    e5d0:	2f 93       	push	r18
    e5d2:	3f 93       	push	r19
    e5d4:	8f 93       	push	r24
    e5d6:	9f 93       	push	r25
    e5d8:	ef 93       	push	r30
    e5da:	ff 93       	push	r31
	if(uart_fifo_tx.bytes_used==0)
    e5dc:	80 91 d0 03 	lds	r24, 0x03D0
    e5e0:	88 23       	and	r24, r24
    e5e2:	11 f4       	brne	.+4      	; 0xe5e8 <__vector_19+0x22>
		UCSR0B &= ~_BV(UDRIE0);			// disable tx interrupt
    e5e4:	55 98       	cbi	0x0a, 5	; 10
    e5e6:	2c c0       	rjmp	.+88     	; 0xe640 <__vector_19+0x7a>
	else
	{
		UDR0=*((char*)uart_fifo_tx.tail_ptr);
    e5e8:	e0 91 d3 03 	lds	r30, 0x03D3
    e5ec:	f0 91 d4 03 	lds	r31, 0x03D4
    e5f0:	80 81       	ld	r24, Z
    e5f2:	8c b9       	out	0x0c, r24	; 12
		uart_fifo_tx.tail_ptr++;	
    e5f4:	80 91 d3 03 	lds	r24, 0x03D3
    e5f8:	90 91 d4 03 	lds	r25, 0x03D4
    e5fc:	01 96       	adiw	r24, 0x01	; 1
    e5fe:	90 93 d4 03 	sts	0x03D4, r25
    e602:	80 93 d3 03 	sts	0x03D3, r24
		
		if(uart_fifo_tx.tail_ptr == uart_fifo_tx.end)
    e606:	20 91 d3 03 	lds	r18, 0x03D3
    e60a:	30 91 d4 03 	lds	r19, 0x03D4
    e60e:	80 91 d7 03 	lds	r24, 0x03D7
    e612:	90 91 d8 03 	lds	r25, 0x03D8
    e616:	28 17       	cp	r18, r24
    e618:	39 07       	cpc	r19, r25
    e61a:	41 f4       	brne	.+16     	; 0xe62c <__vector_19+0x66>
			uart_fifo_tx.tail_ptr = uart_fifo_tx.start;
    e61c:	80 91 d5 03 	lds	r24, 0x03D5
    e620:	90 91 d6 03 	lds	r25, 0x03D6
    e624:	90 93 d4 03 	sts	0x03D4, r25
    e628:	80 93 d3 03 	sts	0x03D3, r24
		
		uart_fifo_tx.bytes_free ++;
    e62c:	80 91 cf 03 	lds	r24, 0x03CF
    e630:	8f 5f       	subi	r24, 0xFF	; 255
    e632:	80 93 cf 03 	sts	0x03CF, r24
		uart_fifo_tx.bytes_used --;
    e636:	80 91 d0 03 	lds	r24, 0x03D0
    e63a:	81 50       	subi	r24, 0x01	; 1
    e63c:	80 93 d0 03 	sts	0x03D0, r24
	};
}
    e640:	ff 91       	pop	r31
    e642:	ef 91       	pop	r30
    e644:	9f 91       	pop	r25
    e646:	8f 91       	pop	r24
    e648:	3f 91       	pop	r19
    e64a:	2f 91       	pop	r18
    e64c:	0f 90       	pop	r0
    e64e:	0f be       	out	0x3f, r0	; 63
    e650:	0f 90       	pop	r0
    e652:	1f 90       	pop	r1
    e654:	18 95       	reti

0000e656 <__vector_31>:

ISR(USART1_UDRE_vect)
{
    e656:	1f 92       	push	r1
    e658:	0f 92       	push	r0
    e65a:	0f b6       	in	r0, 0x3f	; 63
    e65c:	0f 92       	push	r0
    e65e:	11 24       	eor	r1, r1
    e660:	2f 93       	push	r18
    e662:	3f 93       	push	r19
    e664:	8f 93       	push	r24
    e666:	9f 93       	push	r25
    e668:	ef 93       	push	r30
    e66a:	ff 93       	push	r31
	if(uart_fifo_tx.bytes_used==0)
    e66c:	80 91 d0 03 	lds	r24, 0x03D0
    e670:	88 23       	and	r24, r24
    e672:	31 f4       	brne	.+12     	; 0xe680 <__vector_31+0x2a>
		UCSR1B &= ~_BV(UDRIE1);			// disable tx interrupt
    e674:	80 91 9a 00 	lds	r24, 0x009A
    e678:	8f 7d       	andi	r24, 0xDF	; 223
    e67a:	80 93 9a 00 	sts	0x009A, r24
    e67e:	2d c0       	rjmp	.+90     	; 0xe6da <__vector_31+0x84>
	else
	{
		UDR1=*((char*)uart_fifo_tx.tail_ptr);
    e680:	e0 91 d3 03 	lds	r30, 0x03D3
    e684:	f0 91 d4 03 	lds	r31, 0x03D4
    e688:	80 81       	ld	r24, Z
    e68a:	80 93 9c 00 	sts	0x009C, r24
		uart_fifo_tx.tail_ptr++;
    e68e:	80 91 d3 03 	lds	r24, 0x03D3
    e692:	90 91 d4 03 	lds	r25, 0x03D4
    e696:	01 96       	adiw	r24, 0x01	; 1
    e698:	90 93 d4 03 	sts	0x03D4, r25
    e69c:	80 93 d3 03 	sts	0x03D3, r24
		
		if(uart_fifo_tx.tail_ptr == uart_fifo_tx.end)
    e6a0:	20 91 d3 03 	lds	r18, 0x03D3
    e6a4:	30 91 d4 03 	lds	r19, 0x03D4
    e6a8:	80 91 d7 03 	lds	r24, 0x03D7
    e6ac:	90 91 d8 03 	lds	r25, 0x03D8
    e6b0:	28 17       	cp	r18, r24
    e6b2:	39 07       	cpc	r19, r25
    e6b4:	41 f4       	brne	.+16     	; 0xe6c6 <__vector_31+0x70>
			uart_fifo_tx.tail_ptr = uart_fifo_tx.start;
    e6b6:	80 91 d5 03 	lds	r24, 0x03D5
    e6ba:	90 91 d6 03 	lds	r25, 0x03D6
    e6be:	90 93 d4 03 	sts	0x03D4, r25
    e6c2:	80 93 d3 03 	sts	0x03D3, r24
		
		uart_fifo_tx.bytes_free ++;
    e6c6:	80 91 cf 03 	lds	r24, 0x03CF
    e6ca:	8f 5f       	subi	r24, 0xFF	; 255
    e6cc:	80 93 cf 03 	sts	0x03CF, r24
		uart_fifo_tx.bytes_used --;
    e6d0:	80 91 d0 03 	lds	r24, 0x03D0
    e6d4:	81 50       	subi	r24, 0x01	; 1
    e6d6:	80 93 d0 03 	sts	0x03D0, r24
	};
}
    e6da:	ff 91       	pop	r31
    e6dc:	ef 91       	pop	r30
    e6de:	9f 91       	pop	r25
    e6e0:	8f 91       	pop	r24
    e6e2:	3f 91       	pop	r19
    e6e4:	2f 91       	pop	r18
    e6e6:	0f 90       	pop	r0
    e6e8:	0f be       	out	0x3f, r0	; 63
    e6ea:	0f 90       	pop	r0
    e6ec:	1f 90       	pop	r1
    e6ee:	18 95       	reti

0000e6f0 <uart_init>:

	struct fifo_control uart_fifo_tx;
	struct fifo_control uart_fifo_rx;

char uart_init(void)
{
    e6f0:	cf 93       	push	r28
    e6f2:	df 93       	push	r29
	int tempint;
	char found=FALSE;

	//Uart0 already configured? (means bootloader called from main app)
	if(UCSR0B & _BV(RXEN0))
    e6f4:	54 9b       	sbis	0x0a, 4	; 10
    e6f6:	08 c0       	rjmp	.+16     	; 0xe708 <uart_init+0x18>
	{
		UCSR0B |= _BV(RXCIE0);	// enable rx interrupt (writes to fifo)
    e6f8:	57 9a       	sbi	0x0a, 7	; 10
		fifo_init(&uart_fifo_tx,UART_FIFO_TX_SIZE, uart0_isrtx_enable, uart_fifo_data_tx);
    e6fa:	8f ec       	ldi	r24, 0xCF	; 207
    e6fc:	93 e0       	ldi	r25, 0x03	; 3
    e6fe:	60 e4       	ldi	r22, 0x40	; 64
    e700:	70 e0       	ldi	r23, 0x00	; 0
    e702:	40 e6       	ldi	r20, 0x60	; 96
    e704:	52 e7       	ldi	r21, 0x72	; 114
    e706:	0f c0       	rjmp	.+30     	; 0xe726 <uart_init+0x36>
		fifo_init(&uart_fifo_rx,UART_FIFO_RX_SIZE, NULL, uart_fifo_data_rx);
		found=TRUE;
	}
	else if(UCSR1B & _BV(RXEN1))
    e708:	80 91 9a 00 	lds	r24, 0x009A
    e70c:	84 ff       	sbrs	r24, 4
    e70e:	1b c0       	rjmp	.+54     	; 0xe746 <uart_init+0x56>
	{
		UCSR1B |= _BV(RXCIE1);	// enable rx interrupt (writes to fifo)
    e710:	80 91 9a 00 	lds	r24, 0x009A
    e714:	80 68       	ori	r24, 0x80	; 128
    e716:	80 93 9a 00 	sts	0x009A, r24
		fifo_init(&uart_fifo_tx,UART_FIFO_TX_SIZE, uart1_isrtx_enable, uart_fifo_data_tx);
    e71a:	8f ec       	ldi	r24, 0xCF	; 207
    e71c:	93 e0       	ldi	r25, 0x03	; 3
    e71e:	60 e4       	ldi	r22, 0x40	; 64
    e720:	70 e0       	ldi	r23, 0x00	; 0
    e722:	42 e6       	ldi	r20, 0x62	; 98
    e724:	52 e7       	ldi	r21, 0x72	; 114
    e726:	2b ed       	ldi	r18, 0xDB	; 219
    e728:	33 e0       	ldi	r19, 0x03	; 3
    e72a:	0e 94 fd 75 	call	0xebfa	; 0xebfa <fifo_init>
		fifo_init(&uart_fifo_rx,UART_FIFO_RX_SIZE, NULL, uart_fifo_data_rx);
    e72e:	84 ec       	ldi	r24, 0xC4	; 196
    e730:	92 e0       	ldi	r25, 0x02	; 2
    e732:	6f ef       	ldi	r22, 0xFF	; 255
    e734:	70 e0       	ldi	r23, 0x00	; 0
    e736:	40 e0       	ldi	r20, 0x00	; 0
    e738:	50 e0       	ldi	r21, 0x00	; 0
    e73a:	20 ed       	ldi	r18, 0xD0	; 208
    e73c:	32 e0       	ldi	r19, 0x02	; 2
    e73e:	0e 94 fd 75 	call	0xebfa	; 0xebfa <fifo_init>
    e742:	91 e0       	ldi	r25, 0x01	; 1
    e744:	9b c0       	rjmp	.+310    	; 0xe87c <uart_init+0x18c>
	}
	else 
	{
	
		// Setup Uart0
		DDRE &=~_BV(PE0);		// UTX0 input
    e746:	10 98       	cbi	0x02, 0	; 2
		UCSR0B |= _BV(RXEN0);	// enable rx
    e748:	54 9a       	sbi	0x0a, 4	; 10
		UCSR0B |= _BV(RXCIE0);	// enable rx interrupt (writes to fifo)
    e74a:	57 9a       	sbi	0x0a, 7	; 10
		UCSR0B &= ~_BV(UDRIE0);	// disable tx interrupt (for now)	
    e74c:	55 98       	cbi	0x0a, 5	; 10

		// Setup Uart1
		DDRD &=~_BV(PD2);		// URX1 input
    e74e:	8a 98       	cbi	0x11, 2	; 17
		UCSR1B |= _BV(RXEN1);	// enable rx
    e750:	80 91 9a 00 	lds	r24, 0x009A
    e754:	80 61       	ori	r24, 0x10	; 16
    e756:	80 93 9a 00 	sts	0x009A, r24
		UCSR1B |= _BV(RXCIE1);	// enable rx interrupt (writes to fifo)
    e75a:	80 91 9a 00 	lds	r24, 0x009A
    e75e:	80 68       	ori	r24, 0x80	; 128
    e760:	80 93 9a 00 	sts	0x009A, r24
		UCSR1B &= ~_BV(UDRIE1);	// disable tx interrupt (for now)	
    e764:	80 91 9a 00 	lds	r24, 0x009A
    e768:	8f 7d       	andi	r24, 0xDF	; 223
    e76a:	80 93 9a 00 	sts	0x009A, r24

		#define BAUD_TOL	5
		#define BAUD		UART0BAUD
		#include <util/setbaud.h>
		UBRR0H = (char)(UBRR_VALUE>>8);
    e76e:	10 92 90 00 	sts	0x0090, r1
		UBRR0L = (char)(UBRR_VALUE);
    e772:	97 e6       	ldi	r25, 0x67	; 103
    e774:	99 b9       	out	0x09, r25	; 9
		#if USE_2X
			UCSR0A |= _BV(U2X0);
		#else
			UCSR0A &= _BV(U2X0);
    e776:	8b b1       	in	r24, 0x0b	; 11
    e778:	82 70       	andi	r24, 0x02	; 2
    e77a:	8b b9       	out	0x0b, r24	; 11
		#endif
		
		#undef	BAUD
		#define	BAUD		UART1BAUD
		#include <util/setbaud.h>
		UBRR1H = (char)(UBRR_VALUE>>8);
    e77c:	10 92 98 00 	sts	0x0098, r1
		UBRR1L = (char)(UBRR_VALUE);
    e780:	90 93 99 00 	sts	0x0099, r25
		#if USE_2X
			UCSR1A |= _BV(U2X1);
		#else
			UCSR1A &= _BV(U2X1);
    e784:	80 91 9b 00 	lds	r24, 0x009B
    e788:	82 70       	andi	r24, 0x02	; 2
    e78a:	80 93 9b 00 	sts	0x009B, r24
    e78e:	88 ec       	ldi	r24, 0xC8	; 200
    e790:	90 e0       	ldi	r25, 0x00	; 0
    e792:	40 e0       	ldi	r20, 0x00	; 0
    e794:	c0 ea       	ldi	r28, 0xA0	; 160
    e796:	df e0       	ldi	r29, 0x0F	; 15
    e798:	59 c0       	rjmp	.+178    	; 0xe84c <uart_init+0x15c>
		#endif
		
		tempint=BOOTWINDOW;
		while(tempint--)
		{
			if(UCSR0A & _BV(RXC0))
    e79a:	5f 9b       	sbis	0x0b, 7	; 11
    e79c:	27 c0       	rjmp	.+78     	; 0xe7ec <uart_init+0xfc>
			{
				if(UDR0==' ')
    e79e:	8c b1       	in	r24, 0x0c	; 12
    e7a0:	80 32       	cpi	r24, 0x20	; 32
    e7a2:	21 f5       	brne	.+72     	; 0xe7ec <uart_init+0xfc>
				{
					UCSR1B &=~_BV(RXEN1);	// disable rx
    e7a4:	80 91 9a 00 	lds	r24, 0x009A
    e7a8:	8f 7e       	andi	r24, 0xEF	; 239
    e7aa:	80 93 9a 00 	sts	0x009A, r24
					UCSR1B &=~_BV(RXCIE1);	// disable rx interrupt (writes to fifo)
    e7ae:	80 91 9a 00 	lds	r24, 0x009A
    e7b2:	8f 77       	andi	r24, 0x7F	; 127
    e7b4:	80 93 9a 00 	sts	0x009A, r24
					fifo_init(&uart_fifo_tx,UART_FIFO_TX_SIZE, uart0_isrtx_enable, uart_fifo_data_tx);
    e7b8:	8f ec       	ldi	r24, 0xCF	; 207
    e7ba:	93 e0       	ldi	r25, 0x03	; 3
    e7bc:	60 e4       	ldi	r22, 0x40	; 64
    e7be:	70 e0       	ldi	r23, 0x00	; 0
    e7c0:	40 e6       	ldi	r20, 0x60	; 96
    e7c2:	52 e7       	ldi	r21, 0x72	; 114
    e7c4:	2b ed       	ldi	r18, 0xDB	; 219
    e7c6:	33 e0       	ldi	r19, 0x03	; 3
    e7c8:	0e 94 fd 75 	call	0xebfa	; 0xebfa <fifo_init>
					fifo_init(&uart_fifo_rx,UART_FIFO_RX_SIZE, NULL, uart_fifo_data_rx);
    e7cc:	84 ec       	ldi	r24, 0xC4	; 196
    e7ce:	92 e0       	ldi	r25, 0x02	; 2
    e7d0:	6f ef       	ldi	r22, 0xFF	; 255
    e7d2:	70 e0       	ldi	r23, 0x00	; 0
    e7d4:	40 e0       	ldi	r20, 0x00	; 0
    e7d6:	50 e0       	ldi	r21, 0x00	; 0
    e7d8:	20 ed       	ldi	r18, 0xD0	; 208
    e7da:	32 e0       	ldi	r19, 0x02	; 2
    e7dc:	0e 94 fd 75 	call	0xebfa	; 0xebfa <fifo_init>
					DDRE |=_BV(PE1);		// UTX0 output
    e7e0:	11 9a       	sbi	0x02, 1	; 2
					UCSR0B |= _BV(TXEN0);	// enable tx
    e7e2:	53 9a       	sbi	0x0a, 3	; 10
					UCSR0B |= _BV(UDRIE0);	// enable tx interrupt
    e7e4:	55 9a       	sbi	0x0a, 5	; 10
    e7e6:	20 e0       	ldi	r18, 0x00	; 0
    e7e8:	30 e0       	ldi	r19, 0x00	; 0
    e7ea:	41 e0       	ldi	r20, 0x01	; 1
					tempint=0;
					found=TRUE;
				};
			};
			
			if(UCSR1A & _BV(RXC1))
    e7ec:	80 91 9b 00 	lds	r24, 0x009B
    e7f0:	87 ff       	sbrs	r24, 7
    e7f2:	28 c0       	rjmp	.+80     	; 0xe844 <uart_init+0x154>
			{
				if(UDR1==' ')
    e7f4:	80 91 9c 00 	lds	r24, 0x009C
    e7f8:	80 32       	cpi	r24, 0x20	; 32
    e7fa:	21 f5       	brne	.+72     	; 0xe844 <uart_init+0x154>
				{
					UCSR0B &=~_BV(RXEN0);	// disable rx
    e7fc:	54 98       	cbi	0x0a, 4	; 10
					UCSR0B &=~_BV(RXCIE0);	// disable rx interrupt (writes to fifo)
    e7fe:	57 98       	cbi	0x0a, 7	; 10
					fifo_init(&uart_fifo_tx,UART_FIFO_TX_SIZE, uart1_isrtx_enable, uart_fifo_data_tx);
    e800:	8f ec       	ldi	r24, 0xCF	; 207
    e802:	93 e0       	ldi	r25, 0x03	; 3
    e804:	60 e4       	ldi	r22, 0x40	; 64
    e806:	70 e0       	ldi	r23, 0x00	; 0
    e808:	42 e6       	ldi	r20, 0x62	; 98
    e80a:	52 e7       	ldi	r21, 0x72	; 114
    e80c:	2b ed       	ldi	r18, 0xDB	; 219
    e80e:	33 e0       	ldi	r19, 0x03	; 3
    e810:	0e 94 fd 75 	call	0xebfa	; 0xebfa <fifo_init>
					fifo_init(&uart_fifo_rx,UART_FIFO_RX_SIZE, NULL, uart_fifo_data_rx);
    e814:	84 ec       	ldi	r24, 0xC4	; 196
    e816:	92 e0       	ldi	r25, 0x02	; 2
    e818:	6f ef       	ldi	r22, 0xFF	; 255
    e81a:	70 e0       	ldi	r23, 0x00	; 0
    e81c:	40 e0       	ldi	r20, 0x00	; 0
    e81e:	50 e0       	ldi	r21, 0x00	; 0
    e820:	20 ed       	ldi	r18, 0xD0	; 208
    e822:	32 e0       	ldi	r19, 0x02	; 2
    e824:	0e 94 fd 75 	call	0xebfa	; 0xebfa <fifo_init>
					DDRD |=_BV(PD3);		// UTX1 output
    e828:	8b 9a       	sbi	0x11, 3	; 17
					UCSR1B |= _BV(TXEN1);	// enable tx
    e82a:	80 91 9a 00 	lds	r24, 0x009A
    e82e:	88 60       	ori	r24, 0x08	; 8
    e830:	80 93 9a 00 	sts	0x009A, r24
					UCSR1B |= _BV(UDRIE1);	// enable tx interrupt
    e834:	80 91 9a 00 	lds	r24, 0x009A
    e838:	80 62       	ori	r24, 0x20	; 32
    e83a:	80 93 9a 00 	sts	0x009A, r24
    e83e:	20 e0       	ldi	r18, 0x00	; 0
    e840:	30 e0       	ldi	r19, 0x00	; 0
    e842:	41 e0       	ldi	r20, 0x01	; 1
    e844:	ce 01       	movw	r24, r28
    e846:	01 97       	sbiw	r24, 0x01	; 1
    e848:	f1 f7       	brne	.-4      	; 0xe846 <uart_init+0x156>
    e84a:	c9 01       	movw	r24, r18
		#else
			UCSR1A &= _BV(U2X1);
		#endif
		
		tempint=BOOTWINDOW;
		while(tempint--)
    e84c:	9c 01       	movw	r18, r24
    e84e:	21 50       	subi	r18, 0x01	; 1
    e850:	30 40       	sbci	r19, 0x00	; 0
    e852:	89 2b       	or	r24, r25
    e854:	09 f0       	breq	.+2      	; 0xe858 <uart_init+0x168>
    e856:	a1 cf       	rjmp	.-190    	; 0xe79a <uart_init+0xaa>
    e858:	94 2f       	mov	r25, r20
			};
			_delay_ms(1);
		};
	};
	
	if(!found)
    e85a:	44 23       	and	r20, r20
    e85c:	79 f4       	brne	.+30     	; 0xe87c <uart_init+0x18c>
	{
		DDRD=0;
    e85e:	11 ba       	out	0x11, r1	; 17
		UCSR0B=0;
    e860:	1a b8       	out	0x0a, r1	; 10
		UCSR1B=0;
    e862:	10 92 9a 00 	sts	0x009A, r1
	
		UBRR0H = 0;
    e866:	10 92 90 00 	sts	0x0090, r1
		UBRR0L = 0;
    e86a:	19 b8       	out	0x09, r1	; 9
		UBRR1H = 0;
    e86c:	10 92 98 00 	sts	0x0098, r1
		UBRR1L = 0;
    e870:	10 92 99 00 	sts	0x0099, r1
	
		UCSR0A =0x20;
    e874:	80 e2       	ldi	r24, 0x20	; 32
    e876:	8b b9       	out	0x0b, r24	; 11
		UCSR1A =0x20;	
    e878:	80 93 9b 00 	sts	0x009B, r24
	};
	return found;
}
    e87c:	89 2f       	mov	r24, r25
    e87e:	df 91       	pop	r29
    e880:	cf 91       	pop	r28
    e882:	08 95       	ret

0000e884 <hex2ascii>:

// call to print memory to a text buffer as hex data
// option=0, ############
// option=1, ##:##:##:##:##:## (used for MAC)
char* hex2ascii(char* textbuf, void* startadd, unsigned char length, unsigned char option)
{
    e884:	0f 93       	push	r16
    e886:	1f 93       	push	r17
    e888:	cf 93       	push	r28
    e88a:	df 93       	push	r29
    e88c:	18 2f       	mov	r17, r24
    e88e:	09 2f       	mov	r16, r25
    e890:	eb 01       	movw	r28, r22
    e892:	62 2f       	mov	r22, r18
	void* endadd = (unsigned char*)startadd+length;
    e894:	ce 01       	movw	r24, r28
    e896:	84 0f       	add	r24, r20
    e898:	91 1d       	adc	r25, r1
    e89a:	ac 01       	movw	r20, r24
    e89c:	21 2f       	mov	r18, r17
    e89e:	30 2f       	mov	r19, r16
    e8a0:	c9 01       	movw	r24, r18
    e8a2:	fc 01       	movw	r30, r24
			textbuf[0]+=7;
		if(textbuf[1]>0x39)
			textbuf[1]+=7;
		textbuf+=2;
		if(option==1 && startadd != endadd)
			*textbuf++=':';
    e8a4:	2a e3       	ldi	r18, 0x3A	; 58
	char* retval = textbuf;

	unsigned char tempchar;
	do
	{
		tempchar=*(unsigned char*)startadd++;
    e8a6:	89 91       	ld	r24, Y+
		textbuf[0]=0x30+(tempchar>>4);
    e8a8:	98 2f       	mov	r25, r24
    e8aa:	92 95       	swap	r25
    e8ac:	9f 70       	andi	r25, 0x0F	; 15
    e8ae:	90 5d       	subi	r25, 0xD0	; 208
    e8b0:	df 01       	movw	r26, r30
    e8b2:	9d 93       	st	X+, r25
		textbuf[1]=0x30+(tempchar&0x0F);
    e8b4:	8f 70       	andi	r24, 0x0F	; 15
    e8b6:	80 5d       	subi	r24, 0xD0	; 208
    e8b8:	81 83       	std	Z+1, r24	; 0x01
		if(textbuf[0]>0x39)
    e8ba:	9a 33       	cpi	r25, 0x3A	; 58
    e8bc:	10 f0       	brcs	.+4      	; 0xe8c2 <hex2ascii+0x3e>
			textbuf[0]+=7;
    e8be:	99 5f       	subi	r25, 0xF9	; 249
    e8c0:	90 83       	st	Z, r25
		if(textbuf[1]>0x39)
    e8c2:	8c 91       	ld	r24, X
    e8c4:	8a 33       	cpi	r24, 0x3A	; 58
    e8c6:	10 f0       	brcs	.+4      	; 0xe8cc <hex2ascii+0x48>
			textbuf[1]+=7;
    e8c8:	89 5f       	subi	r24, 0xF9	; 249
    e8ca:	8c 93       	st	X, r24
		textbuf+=2;
    e8cc:	32 96       	adiw	r30, 0x02	; 2
		if(option==1 && startadd != endadd)
    e8ce:	61 30       	cpi	r22, 0x01	; 1
    e8d0:	29 f4       	brne	.+10     	; 0xe8dc <hex2ascii+0x58>
    e8d2:	c4 17       	cp	r28, r20
    e8d4:	d5 07       	cpc	r29, r21
    e8d6:	29 f0       	breq	.+10     	; 0xe8e2 <hex2ascii+0x5e>
			*textbuf++=':';
    e8d8:	21 93       	st	Z+, r18
    e8da:	e5 cf       	rjmp	.-54     	; 0xe8a6 <hex2ascii+0x22>
	}while(startadd != endadd);
    e8dc:	c4 17       	cp	r28, r20
    e8de:	d5 07       	cpc	r29, r21
    e8e0:	11 f7       	brne	.-60     	; 0xe8a6 <hex2ascii+0x22>
	*textbuf++=0;
    e8e2:	10 82       	st	Z, r1
	return retval;
}
    e8e4:	81 2f       	mov	r24, r17
    e8e6:	90 2f       	mov	r25, r16
    e8e8:	df 91       	pop	r29
    e8ea:	cf 91       	pop	r28
    e8ec:	1f 91       	pop	r17
    e8ee:	0f 91       	pop	r16
    e8f0:	08 95       	ret

0000e8f2 <read_bige_uint>:

unsigned int read_bige_uint(unsigned int bige)
{
    e8f2:	df 93       	push	r29
    e8f4:	cf 93       	push	r28
    e8f6:	00 d0       	rcall	.+0      	; 0xe8f8 <read_bige_uint+0x6>
    e8f8:	cd b7       	in	r28, 0x3d	; 61
    e8fa:	de b7       	in	r29, 0x3e	; 62
    e8fc:	9a 83       	std	Y+2, r25	; 0x02
    e8fe:	89 83       	std	Y+1, r24	; 0x01
	unsigned int retval;
	retval = ((unsigned char*)&bige)[0];
	retval<<=8;
    e900:	38 2f       	mov	r19, r24
    e902:	20 e0       	ldi	r18, 0x00	; 0
    e904:	8a 81       	ldd	r24, Y+2	; 0x02
    e906:	28 0f       	add	r18, r24
    e908:	31 1d       	adc	r19, r1
	retval+= ((unsigned char*)&bige)[1];
	return retval;
}
    e90a:	c9 01       	movw	r24, r18
    e90c:	0f 90       	pop	r0
    e90e:	0f 90       	pop	r0
    e910:	cf 91       	pop	r28
    e912:	df 91       	pop	r29
    e914:	08 95       	ret

0000e916 <ihex_init>:
	char *line_ptr;

//call to initialise ihex parser
void ihex_init()
{
	ext_seg_add=0;
    e916:	10 92 bc 01 	sts	0x01BC, r1
    e91a:	10 92 bd 01 	sts	0x01BD, r1
    e91e:	10 92 be 01 	sts	0x01BE, r1
    e922:	10 92 bf 01 	sts	0x01BF, r1
	ext_lin_add=0;
    e926:	10 92 c0 01 	sts	0x01C0, r1
    e92a:	10 92 c1 01 	sts	0x01C1, r1
    e92e:	10 92 c2 01 	sts	0x01C2, r1
    e932:	10 92 c3 01 	sts	0x01C3, r1
	line_ptr=hexline.ascii;
    e936:	8f e2       	ldi	r24, 0x2F	; 47
    e938:	94 e0       	ldi	r25, 0x04	; 4
    e93a:	90 93 1c 04 	sts	0x041C, r25
    e93e:	80 93 1b 04 	sts	0x041B, r24
	*line_ptr=0;
    e942:	10 92 2f 04 	sts	0x042F, r1
	ihex_status=0;
    e946:	10 92 1d 04 	sts	0x041D, r1
}
    e94a:	08 95       	ret

0000e94c <ascii2hex>:
	else
		ihex_status=IHEX_STATUS_ERROR;
}

char ascii2hex(char* ascii)
{
    e94c:	fc 01       	movw	r30, r24
	char retval=0;
	if(ascii[0] > '9')
    e94e:	80 81       	ld	r24, Z
    e950:	8a 33       	cpi	r24, 0x3A	; 58
    e952:	10 f0       	brcs	.+4      	; 0xe958 <ascii2hex+0xc>
		retval += 0x0A + ascii[0] -'A';
    e954:	87 53       	subi	r24, 0x37	; 55
    e956:	01 c0       	rjmp	.+2      	; 0xe95a <ascii2hex+0xe>
	else
		retval += 0x00 + ascii[0] -'0';
    e958:	80 53       	subi	r24, 0x30	; 48
	retval<<=4;
    e95a:	98 2f       	mov	r25, r24
    e95c:	92 95       	swap	r25
    e95e:	90 7f       	andi	r25, 0xF0	; 240
	if(ascii[1] > '9')
    e960:	81 81       	ldd	r24, Z+1	; 0x01
    e962:	8a 33       	cpi	r24, 0x3A	; 58
    e964:	18 f0       	brcs	.+6      	; 0xe96c <ascii2hex+0x20>
		retval += 0x0A + ascii[1] -'A';
    e966:	87 53       	subi	r24, 0x37	; 55
    e968:	89 0f       	add	r24, r25
    e96a:	08 95       	ret
	else
		retval += 0x00 + ascii[1] -'0';
    e96c:	80 53       	subi	r24, 0x30	; 48
    e96e:	89 0f       	add	r24, r25
	return retval;
}
    e970:	08 95       	ret

0000e972 <ihex_process_line>:
	};
}

//called from ihex_char when a hex line is complete
void ihex_process_line(void)
{
    e972:	ef 92       	push	r14
    e974:	ff 92       	push	r15
    e976:	0f 93       	push	r16
    e978:	1f 93       	push	r17
    e97a:	cf 93       	push	r28
    e97c:	df 93       	push	r29
	char byte_count, *target, *source, checksum;
	unsigned char index;

	//if valid size
	if(isxdigit(hexline.ascii[1]) && isxdigit(hexline.ascii[2]))
    e97e:	80 91 30 04 	lds	r24, 0x0430
    e982:	90 e0       	ldi	r25, 0x00	; 0
    e984:	0e 94 0c 76 	call	0xec18	; 0xec18 <isxdigit>
    e988:	89 2b       	or	r24, r25
    e98a:	71 f0       	breq	.+28     	; 0xe9a8 <ihex_process_line+0x36>
    e98c:	80 91 31 04 	lds	r24, 0x0431
    e990:	90 e0       	ldi	r25, 0x00	; 0
    e992:	0e 94 0c 76 	call	0xec18	; 0xec18 <isxdigit>
    e996:	89 2b       	or	r24, r25
    e998:	39 f0       	breq	.+14     	; 0xe9a8 <ihex_process_line+0x36>
		hexline.ihex.byte_count = ascii2hex(&hexline.ascii[1]);
    e99a:	80 e3       	ldi	r24, 0x30	; 48
    e99c:	94 e0       	ldi	r25, 0x04	; 4
    e99e:	0e 94 a6 74 	call	0xe94c	; 0xe94c <ascii2hex>
    e9a2:	80 93 2f 04 	sts	0x042F, r24
    e9a6:	02 c0       	rjmp	.+4      	; 0xe9ac <ihex_process_line+0x3a>
	else
		hexline.ihex.byte_count=0;
    e9a8:	10 92 2f 04 	sts	0x042F, r1

	//convert ascii to hex
	byte_count=hexline.ihex.byte_count+sizeof(struct ihex_struct)-1;
    e9ac:	e0 90 2f 04 	lds	r14, 0x042F
    e9b0:	84 e0       	ldi	r24, 0x04	; 4
    e9b2:	e8 0e       	add	r14, r24
	target = &hexline.raw[1];
	source = &hexline.ascii[3];	//skip : and length field
	if(byte_count > (MAXLEN-6)/2)	//MAXLEN -'CR' -':' -'0terminator' -'size low byte' -'size hi byte'
    e9b4:	eb e1       	ldi	r30, 0x1B	; 27
    e9b6:	ee 15       	cp	r30, r14
    e9b8:	08 f4       	brcc	.+2      	; 0xe9bc <ihex_process_line+0x4a>
    e9ba:	ee 24       	eor	r14, r14
    e9bc:	00 e3       	ldi	r16, 0x30	; 48
    e9be:	14 e0       	ldi	r17, 0x04	; 4
    e9c0:	e8 01       	movw	r28, r16
    e9c2:	22 96       	adiw	r28, 0x02	; 2
    e9c4:	08 c0       	rjmp	.+16     	; 0xe9d6 <ihex_process_line+0x64>
		byte_count=0;
	while(byte_count)
	{
		*target++=ascii2hex(source);
    e9c6:	ce 01       	movw	r24, r28
    e9c8:	0e 94 a6 74 	call	0xe94c	; 0xe94c <ascii2hex>
    e9cc:	f8 01       	movw	r30, r16
    e9ce:	81 93       	st	Z+, r24
    e9d0:	8f 01       	movw	r16, r30
		source+=2;
    e9d2:	22 96       	adiw	r28, 0x02	; 2
		byte_count--;
    e9d4:	ea 94       	dec	r14
	byte_count=hexline.ihex.byte_count+sizeof(struct ihex_struct)-1;
	target = &hexline.raw[1];
	source = &hexline.ascii[3];	//skip : and length field
	if(byte_count > (MAXLEN-6)/2)	//MAXLEN -'CR' -':' -'0terminator' -'size low byte' -'size hi byte'
		byte_count=0;
	while(byte_count)
    e9d6:	ee 20       	and	r14, r14
    e9d8:	b1 f7       	brne	.-20     	; 0xe9c6 <ihex_process_line+0x54>
		source+=2;
		byte_count--;
	};

	//test checksum
	byte_count=hexline.ihex.byte_count+sizeof(struct ihex_struct)-1;
    e9da:	80 91 2f 04 	lds	r24, 0x042F
    e9de:	8c 5f       	subi	r24, 0xFC	; 252
    e9e0:	ef e2       	ldi	r30, 0x2F	; 47
    e9e2:	f4 e0       	ldi	r31, 0x04	; 4
    e9e4:	20 e0       	ldi	r18, 0x00	; 0
	checksum=0;
	index=0;
	while(byte_count--)
    e9e6:	90 e0       	ldi	r25, 0x00	; 0
    e9e8:	8e 0f       	add	r24, r30
    e9ea:	9f 1f       	adc	r25, r31
    e9ec:	02 c0       	rjmp	.+4      	; 0xe9f2 <ihex_process_line+0x80>
		checksum-=hexline.raw[index++];
    e9ee:	23 1b       	sub	r18, r19
    e9f0:	31 96       	adiw	r30, 0x01	; 1
    e9f2:	30 81       	ld	r19, Z

	//test checksum
	byte_count=hexline.ihex.byte_count+sizeof(struct ihex_struct)-1;
	checksum=0;
	index=0;
	while(byte_count--)
    e9f4:	e8 17       	cp	r30, r24
    e9f6:	f9 07       	cpc	r31, r25
    e9f8:	d1 f7       	brne	.-12     	; 0xe9ee <ihex_process_line+0x7c>
		checksum-=hexline.raw[index++];
	
	if(checksum == hexline.raw[index])
    e9fa:	23 17       	cp	r18, r19
    e9fc:	09 f0       	breq	.+2      	; 0xea00 <ihex_process_line+0x8e>
    e9fe:	7d c0       	rjmp	.+250    	; 0xeafa <ihex_process_line+0x188>
	{
		if(hexline.ihex.type == IHEX_TYPE_DATA)
    ea00:	80 91 32 04 	lds	r24, 0x0432
    ea04:	88 23       	and	r24, r24
    ea06:	c1 f5       	brne	.+112    	; 0xea78 <ihex_process_line+0x106>
		{
			//calculate actual address
			ihex_address=(unsigned long)read_bige_uint(hexline.ihex.address);
    ea08:	80 91 30 04 	lds	r24, 0x0430
    ea0c:	90 91 31 04 	lds	r25, 0x0431
    ea10:	0e 94 79 74 	call	0xe8f2	; 0xe8f2 <read_bige_uint>
			ihex_address+=ext_seg_add;
			ihex_address+=ext_lin_add;
    ea14:	20 91 c0 01 	lds	r18, 0x01C0
    ea18:	30 91 c1 01 	lds	r19, 0x01C1
    ea1c:	40 91 c2 01 	lds	r20, 0x01C2
    ea20:	50 91 c3 01 	lds	r21, 0x01C3
    ea24:	e0 90 bc 01 	lds	r14, 0x01BC
    ea28:	f0 90 bd 01 	lds	r15, 0x01BD
    ea2c:	00 91 be 01 	lds	r16, 0x01BE
    ea30:	10 91 bf 01 	lds	r17, 0x01BF
    ea34:	2e 0d       	add	r18, r14
    ea36:	3f 1d       	adc	r19, r15
    ea38:	40 1f       	adc	r20, r16
    ea3a:	51 1f       	adc	r21, r17
    ea3c:	a0 e0       	ldi	r26, 0x00	; 0
    ea3e:	b0 e0       	ldi	r27, 0x00	; 0
    ea40:	28 0f       	add	r18, r24
    ea42:	39 1f       	adc	r19, r25
    ea44:	4a 1f       	adc	r20, r26
    ea46:	5b 1f       	adc	r21, r27
    ea48:	20 93 b8 01 	sts	0x01B8, r18
    ea4c:	30 93 b9 01 	sts	0x01B9, r19
    ea50:	40 93 ba 01 	sts	0x01BA, r20
    ea54:	50 93 bb 01 	sts	0x01BB, r21
			
			//copy data to output
			memcpy(ihex_data, hexline.ihex.data, hexline.ihex.byte_count);
    ea58:	2e e1       	ldi	r18, 0x1E	; 30
    ea5a:	34 e0       	ldi	r19, 0x04	; 4
    ea5c:	40 91 2f 04 	lds	r20, 0x042F
    ea60:	e3 e3       	ldi	r30, 0x33	; 51
    ea62:	f4 e0       	ldi	r31, 0x04	; 4
    ea64:	c9 01       	movw	r24, r18
    ea66:	bf 01       	movw	r22, r30
    ea68:	50 e0       	ldi	r21, 0x00	; 0
    ea6a:	0e 94 24 76 	call	0xec48	; 0xec48 <memcpy>
			//copy byte count to output
			ihex_byte_count=hexline.ihex.byte_count;
    ea6e:	80 91 2f 04 	lds	r24, 0x042F
    ea72:	80 93 2e 04 	sts	0x042E, r24
    ea76:	44 c0       	rjmp	.+136    	; 0xeb00 <ihex_process_line+0x18e>
		}
		else if(hexline.ihex.type == IHEX_TYPE_EXT_SEG_ADD)
    ea78:	82 30       	cpi	r24, 0x02	; 2
    ea7a:	f9 f4       	brne	.+62     	; 0xeaba <ihex_process_line+0x148>
		{
			ext_seg_add=hexline.ihex.data[0];
			ext_seg_add<<=8;
			ext_seg_add+=hexline.ihex.data[1];
			ext_seg_add<<=4;
    ea7c:	80 91 33 04 	lds	r24, 0x0433
    ea80:	90 e0       	ldi	r25, 0x00	; 0
    ea82:	a0 e0       	ldi	r26, 0x00	; 0
    ea84:	b0 e0       	ldi	r27, 0x00	; 0
    ea86:	ba 2f       	mov	r27, r26
    ea88:	a9 2f       	mov	r26, r25
    ea8a:	98 2f       	mov	r25, r24
    ea8c:	88 27       	eor	r24, r24
    ea8e:	20 91 34 04 	lds	r18, 0x0434
    ea92:	82 0f       	add	r24, r18
    ea94:	91 1d       	adc	r25, r1
    ea96:	a1 1d       	adc	r26, r1
    ea98:	b1 1d       	adc	r27, r1
    ea9a:	44 e0       	ldi	r20, 0x04	; 4
    ea9c:	88 0f       	add	r24, r24
    ea9e:	99 1f       	adc	r25, r25
    eaa0:	aa 1f       	adc	r26, r26
    eaa2:	bb 1f       	adc	r27, r27
    eaa4:	4a 95       	dec	r20
    eaa6:	d1 f7       	brne	.-12     	; 0xea9c <ihex_process_line+0x12a>
    eaa8:	80 93 bc 01 	sts	0x01BC, r24
    eaac:	90 93 bd 01 	sts	0x01BD, r25
    eab0:	a0 93 be 01 	sts	0x01BE, r26
    eab4:	b0 93 bf 01 	sts	0x01BF, r27
    eab8:	23 c0       	rjmp	.+70     	; 0xeb00 <ihex_process_line+0x18e>
		}
		else if(hexline.ihex.type == IHEX_TYPE_EXT_LIN_ADD)
    eaba:	84 30       	cpi	r24, 0x04	; 4
    eabc:	d9 f4       	brne	.+54     	; 0xeaf4 <ihex_process_line+0x182>
		{
			ext_lin_add=hexline.ihex.data[0];
			ext_lin_add<<=8;
			ext_lin_add+=hexline.ihex.data[1];
			ext_lin_add<<=16;
    eabe:	80 91 33 04 	lds	r24, 0x0433
    eac2:	90 e0       	ldi	r25, 0x00	; 0
    eac4:	a0 e0       	ldi	r26, 0x00	; 0
    eac6:	b0 e0       	ldi	r27, 0x00	; 0
    eac8:	ba 2f       	mov	r27, r26
    eaca:	a9 2f       	mov	r26, r25
    eacc:	98 2f       	mov	r25, r24
    eace:	88 27       	eor	r24, r24
    ead0:	20 91 34 04 	lds	r18, 0x0434
    ead4:	82 0f       	add	r24, r18
    ead6:	91 1d       	adc	r25, r1
    ead8:	a1 1d       	adc	r26, r1
    eada:	b1 1d       	adc	r27, r1
    eadc:	dc 01       	movw	r26, r24
    eade:	99 27       	eor	r25, r25
    eae0:	88 27       	eor	r24, r24
    eae2:	80 93 c0 01 	sts	0x01C0, r24
    eae6:	90 93 c1 01 	sts	0x01C1, r25
    eaea:	a0 93 c2 01 	sts	0x01C2, r26
    eaee:	b0 93 c3 01 	sts	0x01C3, r27
    eaf2:	06 c0       	rjmp	.+12     	; 0xeb00 <ihex_process_line+0x18e>
		}
		else if(hexline.ihex.type == IHEX_TYPE_EOF)
    eaf4:	81 30       	cpi	r24, 0x01	; 1
    eaf6:	21 f4       	brne	.+8      	; 0xeb00 <ihex_process_line+0x18e>
    eaf8:	01 c0       	rjmp	.+2      	; 0xeafc <ihex_process_line+0x18a>
			ihex_status=IHEX_STATUS_EOF;
	}
	else
		ihex_status=IHEX_STATUS_ERROR;
    eafa:	82 e0       	ldi	r24, 0x02	; 2
    eafc:	80 93 1d 04 	sts	0x041D, r24
}
    eb00:	df 91       	pop	r29
    eb02:	cf 91       	pop	r28
    eb04:	1f 91       	pop	r17
    eb06:	0f 91       	pop	r16
    eb08:	ff 90       	pop	r15
    eb0a:	ef 90       	pop	r14
    eb0c:	08 95       	ret

0000eb0e <ihex_char>:
	ihex_status=0;
}

//characters are passed to this function
void ihex_char(char x)
{
    eb0e:	98 2f       	mov	r25, r24
	//start of new line?
	if(x==':')
    eb10:	8a 33       	cpi	r24, 0x3A	; 58
    eb12:	59 f4       	brne	.+22     	; 0xeb2a <ihex_char+0x1c>
	{
		line_ptr=hexline.ascii;
		*line_ptr=x;
    eb14:	80 93 2f 04 	sts	0x042F, r24
		line_ptr++;
    eb18:	80 e3       	ldi	r24, 0x30	; 48
    eb1a:	94 e0       	ldi	r25, 0x04	; 4
    eb1c:	90 93 1c 04 	sts	0x041C, r25
    eb20:	80 93 1b 04 	sts	0x041B, r24
		*line_ptr=0;
    eb24:	10 92 30 04 	sts	0x0430, r1
    eb28:	08 95       	ret
	}
	//else if line in progress, append to line
	else if(hexline.ascii[0]==':')
    eb2a:	80 91 2f 04 	lds	r24, 0x042F
    eb2e:	8a 33       	cpi	r24, 0x3A	; 58
    eb30:	e1 f4       	brne	.+56     	; 0xeb6a <ihex_char+0x5c>
	{
		if(line_ptr != &hexline.ascii[MAXLEN-1])
    eb32:	a0 91 1b 04 	lds	r26, 0x041B
    eb36:	b0 91 1c 04 	lds	r27, 0x041C
    eb3a:	84 e0       	ldi	r24, 0x04	; 4
    eb3c:	aa 36       	cpi	r26, 0x6A	; 106
    eb3e:	b8 07       	cpc	r27, r24
    eb40:	41 f0       	breq	.+16     	; 0xeb52 <ihex_char+0x44>
		{
			*line_ptr++=x;
    eb42:	fd 01       	movw	r30, r26
    eb44:	91 93       	st	Z+, r25
    eb46:	f0 93 1c 04 	sts	0x041C, r31
    eb4a:	e0 93 1b 04 	sts	0x041B, r30
			*line_ptr=0;
    eb4e:	11 96       	adiw	r26, 0x01	; 1
    eb50:	1c 92       	st	X, r1
		};
		if(x=='\r')
    eb52:	9d 30       	cpi	r25, 0x0D	; 13
    eb54:	51 f4       	brne	.+20     	; 0xeb6a <ihex_char+0x5c>
		{
			ihex_process_line();
    eb56:	0e 94 b9 74 	call	0xe972	; 0xe972 <ihex_process_line>
			line_ptr=hexline.ascii;
    eb5a:	8f e2       	ldi	r24, 0x2F	; 47
    eb5c:	94 e0       	ldi	r25, 0x04	; 4
    eb5e:	90 93 1c 04 	sts	0x041C, r25
    eb62:	80 93 1b 04 	sts	0x041B, r24
			*line_ptr=0;
    eb66:	10 92 2f 04 	sts	0x042F, r1
    eb6a:	08 95       	ret

0000eb6c <fifo_read_char>:

char fifo_read_char(void)
{
	char retval=0;
	
	while(uart_fifo_rx.bytes_used==0);
    eb6c:	80 91 c5 02 	lds	r24, 0x02C5
    eb70:	88 23       	and	r24, r24
    eb72:	e1 f3       	breq	.-8      	; 0xeb6c <fifo_read_char>

	retval=*((char*)uart_fifo_rx.tail_ptr);
    eb74:	e0 91 c8 02 	lds	r30, 0x02C8
    eb78:	f0 91 c9 02 	lds	r31, 0x02C9
    eb7c:	e0 81       	ld	r30, Z
	uart_fifo_rx.tail_ptr++;	
    eb7e:	80 91 c8 02 	lds	r24, 0x02C8
    eb82:	90 91 c9 02 	lds	r25, 0x02C9
    eb86:	01 96       	adiw	r24, 0x01	; 1
    eb88:	90 93 c9 02 	sts	0x02C9, r25
    eb8c:	80 93 c8 02 	sts	0x02C8, r24
	
	if(uart_fifo_rx.tail_ptr == uart_fifo_rx.end)
    eb90:	20 91 c8 02 	lds	r18, 0x02C8
    eb94:	30 91 c9 02 	lds	r19, 0x02C9
    eb98:	80 91 cc 02 	lds	r24, 0x02CC
    eb9c:	90 91 cd 02 	lds	r25, 0x02CD
    eba0:	28 17       	cp	r18, r24
    eba2:	39 07       	cpc	r19, r25
    eba4:	41 f4       	brne	.+16     	; 0xebb6 <fifo_read_char+0x4a>
		uart_fifo_rx.tail_ptr = uart_fifo_rx.start;
    eba6:	80 91 ca 02 	lds	r24, 0x02CA
    ebaa:	90 91 cb 02 	lds	r25, 0x02CB
    ebae:	90 93 c9 02 	sts	0x02C9, r25
    ebb2:	80 93 c8 02 	sts	0x02C8, r24
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    ebb6:	f8 94       	cli

	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		uart_fifo_rx.bytes_free ++;
    ebb8:	80 91 c4 02 	lds	r24, 0x02C4
    ebbc:	8f 5f       	subi	r24, 0xFF	; 255
    ebbe:	80 93 c4 02 	sts	0x02C4, r24
		uart_fifo_rx.bytes_used --;
    ebc2:	80 91 c5 02 	lds	r24, 0x02C5
    ebc6:	81 50       	subi	r24, 0x01	; 1
    ebc8:	80 93 c5 02 	sts	0x02C5, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    ebcc:	78 94       	sei
	}

	return retval;
}
    ebce:	8e 2f       	mov	r24, r30
    ebd0:	08 95       	ret

0000ebd2 <fifo_flush>:
	fifo_flush(obj);
} 

//100506, made atomic so pointers cannot be corrupted by ISR's
void fifo_flush(struct fifo_control *obj)
{
    ebd2:	fc 01       	movw	r30, r24
	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
    ebd4:	4f b7       	in	r20, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    ebd6:	f8 94       	cli
	{
		(*obj).tail_ptr = (*obj).start;
    ebd8:	86 81       	ldd	r24, Z+6	; 0x06
    ebda:	97 81       	ldd	r25, Z+7	; 0x07
    ebdc:	95 83       	std	Z+5, r25	; 0x05
    ebde:	84 83       	std	Z+4, r24	; 0x04
		(*obj).head_ptr = (*obj).start;
    ebe0:	86 81       	ldd	r24, Z+6	; 0x06
    ebe2:	97 81       	ldd	r25, Z+7	; 0x07
    ebe4:	93 83       	std	Z+3, r25	; 0x03
    ebe6:	82 83       	std	Z+2, r24	; 0x02
		(*obj).bytes_free=(*obj).end-(*obj).start;
    ebe8:	80 85       	ldd	r24, Z+8	; 0x08
    ebea:	91 85       	ldd	r25, Z+9	; 0x09
    ebec:	26 81       	ldd	r18, Z+6	; 0x06
    ebee:	37 81       	ldd	r19, Z+7	; 0x07
    ebf0:	82 1b       	sub	r24, r18
    ebf2:	80 83       	st	Z, r24
		(*obj).bytes_used=0;
    ebf4:	11 82       	std	Z+1, r1	; 0x01
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    ebf6:	4f bf       	out	0x3f, r20	; 63
	}
}
    ebf8:	08 95       	ret

0000ebfa <fifo_init>:
	return retval;
}


void fifo_init(struct fifo_control *obj, unsigned int size, void(*post_fptr)(void), void* data_space)
{
    ebfa:	fc 01       	movw	r30, r24
	(*obj).start = data_space;
    ebfc:	37 83       	std	Z+7, r19	; 0x07
    ebfe:	26 83       	std	Z+6, r18	; 0x06
	(*obj).end=(*obj).start + size;		// note, end points to last item in buffer + 1
    ec00:	86 81       	ldd	r24, Z+6	; 0x06
    ec02:	97 81       	ldd	r25, Z+7	; 0x07
    ec04:	86 0f       	add	r24, r22
    ec06:	97 1f       	adc	r25, r23
    ec08:	91 87       	std	Z+9, r25	; 0x09
    ec0a:	80 87       	std	Z+8, r24	; 0x08
	(*obj).post_fptr=post_fptr;
    ec0c:	53 87       	std	Z+11, r21	; 0x0b
    ec0e:	42 87       	std	Z+10, r20	; 0x0a
	fifo_flush(obj);
    ec10:	cf 01       	movw	r24, r30
    ec12:	0e 94 e9 75 	call	0xebd2	; 0xebd2 <fifo_flush>
} 
    ec16:	08 95       	ret

0000ec18 <isxdigit>:
    ec18:	91 11       	cpse	r25, r1
    ec1a:	53 c0       	rjmp	.+166    	; 0xecc2 <__ctype_isfalse>
    ec1c:	80 53       	subi	r24, 0x30	; 48
    ec1e:	8a 50       	subi	r24, 0x0A	; 10
    ec20:	28 f0       	brcs	.+10     	; 0xec2c <isxdigit+0x14>
    ec22:	86 5c       	subi	r24, 0xC6	; 198
    ec24:	80 62       	ori	r24, 0x20	; 32
    ec26:	81 56       	subi	r24, 0x61	; 97
    ec28:	86 50       	subi	r24, 0x06	; 6
    ec2a:	b8 f7       	brcc	.-18     	; 0xec1a <isxdigit+0x2>
    ec2c:	08 95       	ret

0000ec2e <memcmp_P>:
    ec2e:	fb 01       	movw	r30, r22
    ec30:	dc 01       	movw	r26, r24
    ec32:	04 c0       	rjmp	.+8      	; 0xec3c <memcmp_P+0xe>
    ec34:	8d 91       	ld	r24, X+
    ec36:	05 90       	lpm	r0, Z+
    ec38:	80 19       	sub	r24, r0
    ec3a:	21 f4       	brne	.+8      	; 0xec44 <memcmp_P+0x16>
    ec3c:	41 50       	subi	r20, 0x01	; 1
    ec3e:	50 40       	sbci	r21, 0x00	; 0
    ec40:	c8 f7       	brcc	.-14     	; 0xec34 <memcmp_P+0x6>
    ec42:	88 1b       	sub	r24, r24
    ec44:	99 0b       	sbc	r25, r25
    ec46:	08 95       	ret

0000ec48 <memcpy>:
    ec48:	fb 01       	movw	r30, r22
    ec4a:	dc 01       	movw	r26, r24
    ec4c:	02 c0       	rjmp	.+4      	; 0xec52 <memcpy+0xa>
    ec4e:	01 90       	ld	r0, Z+
    ec50:	0d 92       	st	X+, r0
    ec52:	41 50       	subi	r20, 0x01	; 1
    ec54:	50 40       	sbci	r21, 0x00	; 0
    ec56:	d8 f7       	brcc	.-10     	; 0xec4e <memcpy+0x6>
    ec58:	08 95       	ret

0000ec5a <ltoa>:
    ec5a:	fa 01       	movw	r30, r20
    ec5c:	cf 93       	push	r28
    ec5e:	ff 93       	push	r31
    ec60:	ef 93       	push	r30
    ec62:	22 30       	cpi	r18, 0x02	; 2
    ec64:	44 f1       	brlt	.+80     	; 0xecb6 <ltoa+0x5c>
    ec66:	25 32       	cpi	r18, 0x25	; 37
    ec68:	34 f5       	brge	.+76     	; 0xecb6 <ltoa+0x5c>
    ec6a:	c2 2f       	mov	r28, r18
    ec6c:	e8 94       	clt
    ec6e:	ca 30       	cpi	r28, 0x0A	; 10
    ec70:	49 f4       	brne	.+18     	; 0xec84 <ltoa+0x2a>
    ec72:	97 fb       	bst	r25, 7
    ec74:	3e f4       	brtc	.+14     	; 0xec84 <ltoa+0x2a>
    ec76:	90 95       	com	r25
    ec78:	80 95       	com	r24
    ec7a:	70 95       	com	r23
    ec7c:	61 95       	neg	r22
    ec7e:	7f 4f       	sbci	r23, 0xFF	; 255
    ec80:	8f 4f       	sbci	r24, 0xFF	; 255
    ec82:	9f 4f       	sbci	r25, 0xFF	; 255
    ec84:	2c 2f       	mov	r18, r28
    ec86:	33 27       	eor	r19, r19
    ec88:	44 27       	eor	r20, r20
    ec8a:	55 27       	eor	r21, r21
    ec8c:	ff 93       	push	r31
    ec8e:	ef 93       	push	r30
    ec90:	0e 94 74 76 	call	0xece8	; 0xece8 <__udivmodsi4>
    ec94:	ef 91       	pop	r30
    ec96:	ff 91       	pop	r31
    ec98:	60 5d       	subi	r22, 0xD0	; 208
    ec9a:	6a 33       	cpi	r22, 0x3A	; 58
    ec9c:	0c f0       	brlt	.+2      	; 0xeca0 <ltoa+0x46>
    ec9e:	69 5d       	subi	r22, 0xD9	; 217
    eca0:	61 93       	st	Z+, r22
    eca2:	b9 01       	movw	r22, r18
    eca4:	ca 01       	movw	r24, r20
    eca6:	60 50       	subi	r22, 0x00	; 0
    eca8:	70 40       	sbci	r23, 0x00	; 0
    ecaa:	80 40       	sbci	r24, 0x00	; 0
    ecac:	90 40       	sbci	r25, 0x00	; 0
    ecae:	51 f7       	brne	.-44     	; 0xec84 <ltoa+0x2a>
    ecb0:	16 f4       	brtc	.+4      	; 0xecb6 <ltoa+0x5c>
    ecb2:	cd e2       	ldi	r28, 0x2D	; 45
    ecb4:	c1 93       	st	Z+, r28
    ecb6:	10 82       	st	Z, r1
    ecb8:	8f 91       	pop	r24
    ecba:	9f 91       	pop	r25
    ecbc:	cf 91       	pop	r28
    ecbe:	0c 94 64 76 	jmp	0xecc8	; 0xecc8 <strrev>

0000ecc2 <__ctype_isfalse>:
    ecc2:	99 27       	eor	r25, r25
    ecc4:	88 27       	eor	r24, r24

0000ecc6 <__ctype_istrue>:
    ecc6:	08 95       	ret

0000ecc8 <strrev>:
    ecc8:	dc 01       	movw	r26, r24
    ecca:	fc 01       	movw	r30, r24
    eccc:	67 2f       	mov	r22, r23
    ecce:	71 91       	ld	r23, Z+
    ecd0:	77 23       	and	r23, r23
    ecd2:	e1 f7       	brne	.-8      	; 0xeccc <strrev+0x4>
    ecd4:	32 97       	sbiw	r30, 0x02	; 2
    ecd6:	04 c0       	rjmp	.+8      	; 0xece0 <strrev+0x18>
    ecd8:	7c 91       	ld	r23, X
    ecda:	6d 93       	st	X+, r22
    ecdc:	70 83       	st	Z, r23
    ecde:	62 91       	ld	r22, -Z
    ece0:	ae 17       	cp	r26, r30
    ece2:	bf 07       	cpc	r27, r31
    ece4:	c8 f3       	brcs	.-14     	; 0xecd8 <strrev+0x10>
    ece6:	08 95       	ret

0000ece8 <__udivmodsi4>:
    ece8:	a1 e2       	ldi	r26, 0x21	; 33
    ecea:	1a 2e       	mov	r1, r26
    ecec:	aa 1b       	sub	r26, r26
    ecee:	bb 1b       	sub	r27, r27
    ecf0:	fd 01       	movw	r30, r26
    ecf2:	0d c0       	rjmp	.+26     	; 0xed0e <__udivmodsi4_ep>

0000ecf4 <__udivmodsi4_loop>:
    ecf4:	aa 1f       	adc	r26, r26
    ecf6:	bb 1f       	adc	r27, r27
    ecf8:	ee 1f       	adc	r30, r30
    ecfa:	ff 1f       	adc	r31, r31
    ecfc:	a2 17       	cp	r26, r18
    ecfe:	b3 07       	cpc	r27, r19
    ed00:	e4 07       	cpc	r30, r20
    ed02:	f5 07       	cpc	r31, r21
    ed04:	20 f0       	brcs	.+8      	; 0xed0e <__udivmodsi4_ep>
    ed06:	a2 1b       	sub	r26, r18
    ed08:	b3 0b       	sbc	r27, r19
    ed0a:	e4 0b       	sbc	r30, r20
    ed0c:	f5 0b       	sbc	r31, r21

0000ed0e <__udivmodsi4_ep>:
    ed0e:	66 1f       	adc	r22, r22
    ed10:	77 1f       	adc	r23, r23
    ed12:	88 1f       	adc	r24, r24
    ed14:	99 1f       	adc	r25, r25
    ed16:	1a 94       	dec	r1
    ed18:	69 f7       	brne	.-38     	; 0xecf4 <__udivmodsi4_loop>
    ed1a:	60 95       	com	r22
    ed1c:	70 95       	com	r23
    ed1e:	80 95       	com	r24
    ed20:	90 95       	com	r25
    ed22:	9b 01       	movw	r18, r22
    ed24:	ac 01       	movw	r20, r24
    ed26:	bd 01       	movw	r22, r26
    ed28:	cf 01       	movw	r24, r30
    ed2a:	08 95       	ret

0000ed2c <_exit>:
    ed2c:	f8 94       	cli

0000ed2e <__stop_program>:
    ed2e:	ff cf       	rjmp	.-2      	; 0xed2e <__stop_program>
