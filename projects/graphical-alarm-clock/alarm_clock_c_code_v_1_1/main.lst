   1               		.file	"main.c"
   2               		.arch atmega32
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
  79               	.global	font5x7
  80               		.section	.progmem.data,"a",@progbits
  83               	font5x7:
  84 0000 0000      		.word	0
  85 0002 0000      		.word	0
  86 0004 0000      		.word	0
  87 0006 0000      		.word	0
  88 0008 0000      		.word	0
  89 000a 0000      		.word	0
  90 000c 0000      		.word	0
  91 000e 5F00      		.word	95
  92 0010 0000      		.word	0
  93 0012 0000      		.word	0
  94 0014 0000      		.word	0
  95 0016 0700      		.word	7
  96 0018 0000      		.word	0
  97 001a 0700      		.word	7
  98 001c 0000      		.word	0
  99 001e 1400      		.word	20
 100 0020 7F00      		.word	127
 101 0022 1400      		.word	20
 102 0024 7F00      		.word	127
 103 0026 1400      		.word	20
 104 0028 2400      		.word	36
 105 002a 2A00      		.word	42
 106 002c 7F00      		.word	127
 107 002e 2A00      		.word	42
 108 0030 1200      		.word	18
 109 0032 2300      		.word	35
 110 0034 1300      		.word	19
 111 0036 0800      		.word	8
 112 0038 6400      		.word	100
 113 003a 6200      		.word	98
 114 003c 3600      		.word	54
 115 003e 4900      		.word	73
 116 0040 5500      		.word	85
 117 0042 2200      		.word	34
 118 0044 5000      		.word	80
 119 0046 0000      		.word	0
 120 0048 0500      		.word	5
 121 004a 0300      		.word	3
 122 004c 0000      		.word	0
 123 004e 0000      		.word	0
 124 0050 0000      		.word	0
 125 0052 1C00      		.word	28
 126 0054 2200      		.word	34
 127 0056 4100      		.word	65
 128 0058 0000      		.word	0
 129 005a 0000      		.word	0
 130 005c 4100      		.word	65
 131 005e 2200      		.word	34
 132 0060 1C00      		.word	28
 133 0062 0000      		.word	0
 134 0064 0800      		.word	8
 135 0066 2A00      		.word	42
 136 0068 1C00      		.word	28
 137 006a 2A00      		.word	42
 138 006c 0800      		.word	8
 139 006e 0800      		.word	8
 140 0070 0800      		.word	8
 141 0072 3E00      		.word	62
 142 0074 0800      		.word	8
 143 0076 0800      		.word	8
 144 0078 0000      		.word	0
 145 007a 5000      		.word	80
 146 007c 3000      		.word	48
 147 007e 0000      		.word	0
 148 0080 0000      		.word	0
 149 0082 0800      		.word	8
 150 0084 0800      		.word	8
 151 0086 0800      		.word	8
 152 0088 0800      		.word	8
 153 008a 0800      		.word	8
 154 008c 0000      		.word	0
 155 008e 6000      		.word	96
 156 0090 6000      		.word	96
 157 0092 0000      		.word	0
 158 0094 0000      		.word	0
 159 0096 2000      		.word	32
 160 0098 1000      		.word	16
 161 009a 0800      		.word	8
 162 009c 0400      		.word	4
 163 009e 0200      		.word	2
 164 00a0 3E00      		.word	62
 165 00a2 5100      		.word	81
 166 00a4 4900      		.word	73
 167 00a6 4500      		.word	69
 168 00a8 3E00      		.word	62
 169 00aa 0000      		.word	0
 170 00ac 4200      		.word	66
 171 00ae 7F00      		.word	127
 172 00b0 4000      		.word	64
 173 00b2 0000      		.word	0
 174 00b4 4200      		.word	66
 175 00b6 6100      		.word	97
 176 00b8 5100      		.word	81
 177 00ba 4900      		.word	73
 178 00bc 4600      		.word	70
 179 00be 2100      		.word	33
 180 00c0 4100      		.word	65
 181 00c2 4500      		.word	69
 182 00c4 4B00      		.word	75
 183 00c6 3100      		.word	49
 184 00c8 1800      		.word	24
 185 00ca 1400      		.word	20
 186 00cc 1200      		.word	18
 187 00ce 7F00      		.word	127
 188 00d0 1000      		.word	16
 189 00d2 2700      		.word	39
 190 00d4 4500      		.word	69
 191 00d6 4500      		.word	69
 192 00d8 4500      		.word	69
 193 00da 3900      		.word	57
 194 00dc 3C00      		.word	60
 195 00de 4A00      		.word	74
 196 00e0 4900      		.word	73
 197 00e2 4900      		.word	73
 198 00e4 3000      		.word	48
 199 00e6 0100      		.word	1
 200 00e8 7100      		.word	113
 201 00ea 0900      		.word	9
 202 00ec 0500      		.word	5
 203 00ee 0300      		.word	3
 204 00f0 3600      		.word	54
 205 00f2 4900      		.word	73
 206 00f4 4900      		.word	73
 207 00f6 4900      		.word	73
 208 00f8 3600      		.word	54
 209 00fa 0600      		.word	6
 210 00fc 4900      		.word	73
 211 00fe 4900      		.word	73
 212 0100 2900      		.word	41
 213 0102 1E00      		.word	30
 214 0104 0000      		.word	0
 215 0106 3600      		.word	54
 216 0108 3600      		.word	54
 217 010a 0000      		.word	0
 218 010c 0000      		.word	0
 219 010e 0000      		.word	0
 220 0110 5600      		.word	86
 221 0112 3600      		.word	54
 222 0114 0000      		.word	0
 223 0116 0000      		.word	0
 224 0118 0000      		.word	0
 225 011a 0800      		.word	8
 226 011c 1400      		.word	20
 227 011e 2200      		.word	34
 228 0120 4100      		.word	65
 229 0122 1400      		.word	20
 230 0124 1400      		.word	20
 231 0126 1400      		.word	20
 232 0128 1400      		.word	20
 233 012a 1400      		.word	20
 234 012c 4100      		.word	65
 235 012e 2200      		.word	34
 236 0130 1400      		.word	20
 237 0132 0800      		.word	8
 238 0134 0000      		.word	0
 239 0136 0200      		.word	2
 240 0138 0100      		.word	1
 241 013a 5100      		.word	81
 242 013c 0900      		.word	9
 243 013e 0600      		.word	6
 244 0140 3200      		.word	50
 245 0142 4900      		.word	73
 246 0144 7900      		.word	121
 247 0146 4100      		.word	65
 248 0148 3E00      		.word	62
 249 014a 7E00      		.word	126
 250 014c 1100      		.word	17
 251 014e 1100      		.word	17
 252 0150 1100      		.word	17
 253 0152 7E00      		.word	126
 254 0154 7F00      		.word	127
 255 0156 4900      		.word	73
 256 0158 4900      		.word	73
 257 015a 4900      		.word	73
 258 015c 3600      		.word	54
 259 015e 3E00      		.word	62
 260 0160 4100      		.word	65
 261 0162 4100      		.word	65
 262 0164 4100      		.word	65
 263 0166 2200      		.word	34
 264 0168 7F00      		.word	127
 265 016a 4100      		.word	65
 266 016c 4100      		.word	65
 267 016e 2200      		.word	34
 268 0170 1C00      		.word	28
 269 0172 7F00      		.word	127
 270 0174 4900      		.word	73
 271 0176 4900      		.word	73
 272 0178 4900      		.word	73
 273 017a 4100      		.word	65
 274 017c 7F00      		.word	127
 275 017e 0900      		.word	9
 276 0180 0900      		.word	9
 277 0182 0100      		.word	1
 278 0184 0100      		.word	1
 279 0186 3E00      		.word	62
 280 0188 4100      		.word	65
 281 018a 4100      		.word	65
 282 018c 5100      		.word	81
 283 018e 3200      		.word	50
 284 0190 7F00      		.word	127
 285 0192 0800      		.word	8
 286 0194 0800      		.word	8
 287 0196 0800      		.word	8
 288 0198 7F00      		.word	127
 289 019a 0000      		.word	0
 290 019c 4100      		.word	65
 291 019e 7F00      		.word	127
 292 01a0 4100      		.word	65
 293 01a2 0000      		.word	0
 294 01a4 2000      		.word	32
 295 01a6 4000      		.word	64
 296 01a8 4100      		.word	65
 297 01aa 3F00      		.word	63
 298 01ac 0100      		.word	1
 299 01ae 7F00      		.word	127
 300 01b0 0800      		.word	8
 301 01b2 1400      		.word	20
 302 01b4 2200      		.word	34
 303 01b6 4100      		.word	65
 304 01b8 7F00      		.word	127
 305 01ba 4000      		.word	64
 306 01bc 4000      		.word	64
 307 01be 4000      		.word	64
 308 01c0 4000      		.word	64
 309 01c2 7F00      		.word	127
 310 01c4 0200      		.word	2
 311 01c6 0400      		.word	4
 312 01c8 0200      		.word	2
 313 01ca 7F00      		.word	127
 314 01cc 7F00      		.word	127
 315 01ce 0400      		.word	4
 316 01d0 0800      		.word	8
 317 01d2 1000      		.word	16
 318 01d4 7F00      		.word	127
 319 01d6 3E00      		.word	62
 320 01d8 4100      		.word	65
 321 01da 4100      		.word	65
 322 01dc 4100      		.word	65
 323 01de 3E00      		.word	62
 324 01e0 7F00      		.word	127
 325 01e2 0900      		.word	9
 326 01e4 0900      		.word	9
 327 01e6 0900      		.word	9
 328 01e8 0600      		.word	6
 329 01ea 3E00      		.word	62
 330 01ec 4100      		.word	65
 331 01ee 5100      		.word	81
 332 01f0 2100      		.word	33
 333 01f2 5E00      		.word	94
 334 01f4 7F00      		.word	127
 335 01f6 0900      		.word	9
 336 01f8 1900      		.word	25
 337 01fa 2900      		.word	41
 338 01fc 4600      		.word	70
 339 01fe 4600      		.word	70
 340 0200 4900      		.word	73
 341 0202 4900      		.word	73
 342 0204 4900      		.word	73
 343 0206 3100      		.word	49
 344 0208 0100      		.word	1
 345 020a 0100      		.word	1
 346 020c 7F00      		.word	127
 347 020e 0100      		.word	1
 348 0210 0100      		.word	1
 349 0212 3F00      		.word	63
 350 0214 4000      		.word	64
 351 0216 4000      		.word	64
 352 0218 4000      		.word	64
 353 021a 3F00      		.word	63
 354 021c 1F00      		.word	31
 355 021e 2000      		.word	32
 356 0220 4000      		.word	64
 357 0222 2000      		.word	32
 358 0224 1F00      		.word	31
 359 0226 7F00      		.word	127
 360 0228 2000      		.word	32
 361 022a 1800      		.word	24
 362 022c 2000      		.word	32
 363 022e 7F00      		.word	127
 364 0230 6300      		.word	99
 365 0232 1400      		.word	20
 366 0234 0800      		.word	8
 367 0236 1400      		.word	20
 368 0238 6300      		.word	99
 369 023a 0300      		.word	3
 370 023c 0400      		.word	4
 371 023e 7800      		.word	120
 372 0240 0400      		.word	4
 373 0242 0300      		.word	3
 374 0244 6100      		.word	97
 375 0246 5100      		.word	81
 376 0248 4900      		.word	73
 377 024a 4500      		.word	69
 378 024c 4300      		.word	67
 379 024e 0000      		.word	0
 380 0250 0000      		.word	0
 381 0252 7F00      		.word	127
 382 0254 4100      		.word	65
 383 0256 4100      		.word	65
 384 0258 0200      		.word	2
 385 025a 0400      		.word	4
 386 025c 0800      		.word	8
 387 025e 1000      		.word	16
 388 0260 2000      		.word	32
 389 0262 4100      		.word	65
 390 0264 4100      		.word	65
 391 0266 7F00      		.word	127
 392 0268 0000      		.word	0
 393 026a 0000      		.word	0
 394 026c 0400      		.word	4
 395 026e 0200      		.word	2
 396 0270 0100      		.word	1
 397 0272 0200      		.word	2
 398 0274 0400      		.word	4
 399 0276 4000      		.word	64
 400 0278 4000      		.word	64
 401 027a 4000      		.word	64
 402 027c 4000      		.word	64
 403 027e 4000      		.word	64
 404 0280 0000      		.word	0
 405 0282 0100      		.word	1
 406 0284 0200      		.word	2
 407 0286 0400      		.word	4
 408 0288 0000      		.word	0
 409 028a 2000      		.word	32
 410 028c 5400      		.word	84
 411 028e 5400      		.word	84
 412 0290 5400      		.word	84
 413 0292 7800      		.word	120
 414 0294 7F00      		.word	127
 415 0296 4800      		.word	72
 416 0298 4400      		.word	68
 417 029a 4400      		.word	68
 418 029c 3800      		.word	56
 419 029e 3800      		.word	56
 420 02a0 4400      		.word	68
 421 02a2 4400      		.word	68
 422 02a4 4400      		.word	68
 423 02a6 2000      		.word	32
 424 02a8 3800      		.word	56
 425 02aa 4400      		.word	68
 426 02ac 4400      		.word	68
 427 02ae 4800      		.word	72
 428 02b0 7F00      		.word	127
 429 02b2 3800      		.word	56
 430 02b4 5400      		.word	84
 431 02b6 5400      		.word	84
 432 02b8 5400      		.word	84
 433 02ba 1800      		.word	24
 434 02bc 0800      		.word	8
 435 02be 7E00      		.word	126
 436 02c0 0900      		.word	9
 437 02c2 0100      		.word	1
 438 02c4 0200      		.word	2
 439 02c6 0800      		.word	8
 440 02c8 5400      		.word	84
 441 02ca 5400      		.word	84
 442 02cc 5400      		.word	84
 443 02ce 3C00      		.word	60
 444 02d0 7F00      		.word	127
 445 02d2 0800      		.word	8
 446 02d4 0400      		.word	4
 447 02d6 0400      		.word	4
 448 02d8 7800      		.word	120
 449 02da 0000      		.word	0
 450 02dc 4400      		.word	68
 451 02de 7D00      		.word	125
 452 02e0 4000      		.word	64
 453 02e2 0000      		.word	0
 454 02e4 2000      		.word	32
 455 02e6 4000      		.word	64
 456 02e8 4400      		.word	68
 457 02ea 3D00      		.word	61
 458 02ec 0000      		.word	0
 459 02ee 0000      		.word	0
 460 02f0 7F00      		.word	127
 461 02f2 1000      		.word	16
 462 02f4 2800      		.word	40
 463 02f6 4400      		.word	68
 464 02f8 0000      		.word	0
 465 02fa 4100      		.word	65
 466 02fc 7F00      		.word	127
 467 02fe 4000      		.word	64
 468 0300 0000      		.word	0
 469 0302 7C00      		.word	124
 470 0304 0400      		.word	4
 471 0306 1800      		.word	24
 472 0308 0400      		.word	4
 473 030a 7800      		.word	120
 474 030c 7C00      		.word	124
 475 030e 0800      		.word	8
 476 0310 0400      		.word	4
 477 0312 0400      		.word	4
 478 0314 7800      		.word	120
 479 0316 3800      		.word	56
 480 0318 4400      		.word	68
 481 031a 4400      		.word	68
 482 031c 4400      		.word	68
 483 031e 3800      		.word	56
 484 0320 7C00      		.word	124
 485 0322 1400      		.word	20
 486 0324 1400      		.word	20
 487 0326 1400      		.word	20
 488 0328 0800      		.word	8
 489 032a 0800      		.word	8
 490 032c 1400      		.word	20
 491 032e 1400      		.word	20
 492 0330 1800      		.word	24
 493 0332 7C00      		.word	124
 494 0334 7C00      		.word	124
 495 0336 0800      		.word	8
 496 0338 0400      		.word	4
 497 033a 0400      		.word	4
 498 033c 0800      		.word	8
 499 033e 4800      		.word	72
 500 0340 5400      		.word	84
 501 0342 5400      		.word	84
 502 0344 5400      		.word	84
 503 0346 2000      		.word	32
 504 0348 0400      		.word	4
 505 034a 3F00      		.word	63
 506 034c 4400      		.word	68
 507 034e 4000      		.word	64
 508 0350 2000      		.word	32
 509 0352 3C00      		.word	60
 510 0354 4000      		.word	64
 511 0356 4000      		.word	64
 512 0358 2000      		.word	32
 513 035a 7C00      		.word	124
 514 035c 1C00      		.word	28
 515 035e 2000      		.word	32
 516 0360 4000      		.word	64
 517 0362 2000      		.word	32
 518 0364 1C00      		.word	28
 519 0366 3C00      		.word	60
 520 0368 4000      		.word	64
 521 036a 3000      		.word	48
 522 036c 4000      		.word	64
 523 036e 3C00      		.word	60
 524 0370 4400      		.word	68
 525 0372 2800      		.word	40
 526 0374 1000      		.word	16
 527 0376 2800      		.word	40
 528 0378 4400      		.word	68
 529 037a 0C00      		.word	12
 530 037c 5000      		.word	80
 531 037e 5000      		.word	80
 532 0380 5000      		.word	80
 533 0382 3C00      		.word	60
 534 0384 4400      		.word	68
 535 0386 6400      		.word	100
 536 0388 5400      		.word	84
 537 038a 4C00      		.word	76
 538 038c 4400      		.word	68
 539 038e 0000      		.word	0
 540 0390 0800      		.word	8
 541 0392 3600      		.word	54
 542 0394 4100      		.word	65
 543 0396 0000      		.word	0
 544 0398 0000      		.word	0
 545 039a 0000      		.word	0
 546 039c 7F00      		.word	127
 547 039e 0000      		.word	0
 548 03a0 0000      		.word	0
 549 03a2 0000      		.word	0
 550 03a4 4100      		.word	65
 551 03a6 3600      		.word	54
 552 03a8 0800      		.word	8
 553 03aa 0000      		.word	0
 554 03ac 0800      		.word	8
 555 03ae 0800      		.word	8
 556 03b0 2A00      		.word	42
 557 03b2 1C00      		.word	28
 558 03b4 0800      		.word	8
 559 03b6 0800      		.word	8
 560 03b8 1C00      		.word	28
 561 03ba 2A00      		.word	42
 562 03bc 0800      		.word	8
 563 03be 0800      		.word	8
 564               	.global	strSetTheTime
 567               	strSetTheTime:
 568 03c0 53        		.byte	83
 569 03c1 65        		.byte	101
 570 03c2 74        		.byte	116
 571 03c3 20        		.byte	32
 572 03c4 74        		.byte	116
 573 03c5 68        		.byte	104
 574 03c6 65        		.byte	101
 575 03c7 20        		.byte	32
 576 03c8 54        		.byte	84
 577 03c9 69        		.byte	105
 578 03ca 6D        		.byte	109
 579 03cb 65        		.byte	101
 580 03cc FF        		.byte	-1
 581               	.global	strSetTheAlarm
 584               	strSetTheAlarm:
 585 03cd 53        		.byte	83
 586 03ce 65        		.byte	101
 587 03cf 74        		.byte	116
 588 03d0 20        		.byte	32
 589 03d1 74        		.byte	116
 590 03d2 68        		.byte	104
 591 03d3 65        		.byte	101
 592 03d4 20        		.byte	32
 593 03d5 41        		.byte	65
 594 03d6 6C        		.byte	108
 595 03d7 61        		.byte	97
 596 03d8 72        		.byte	114
 597 03d9 6D        		.byte	109
 598 03da FF        		.byte	-1
 599               	.global	strTarget
 602               	strTarget:
 603 03db 54        		.byte	84
 604 03dc 61        		.byte	97
 605 03dd 72        		.byte	114
 606 03de 62        		.byte	98
 607 03df 75        		.byte	117
 608 03e0 74        		.byte	116
 609 03e1 FF        		.byte	-1
 610               	.global	strLock
 613               	strLock:
 614 03e2 4C        		.byte	76
 615 03e3 6F        		.byte	111
 616 03e4 63        		.byte	99
 617 03e5 6B        		.byte	107
 618 03e6 FF        		.byte	-1
 619               	.global	strPatrol
 622               	strPatrol:
 623 03e7 50        		.byte	80
 624 03e8 61        		.byte	97
 625 03e9 74        		.byte	116
 626 03ea 72        		.byte	114
 627 03eb 6F        		.byte	111
 628 03ec 6C        		.byte	108
 629 03ed FF        		.byte	-1
 630               	.global	strHow
 633               	strHow:
 634 03ee 54        		.byte	84
 635 03ef 68        		.byte	104
 636 03f0 69        		.byte	105
 637 03f1 73        		.byte	115
 638 03f2 20        		.byte	32
 639 03f3 69        		.byte	105
 640 03f4 73        		.byte	115
 641 03f5 20        		.byte	32
 642 03f6 6D        		.byte	109
 643 03f7 61        		.byte	97
 644 03f8 74        		.byte	116
 645 03f9 74        		.byte	116
 646 03fa FF        		.byte	-1
 647               	.global	strAudio
 650               	strAudio:
 651 03fb 41        		.byte	65
 652 03fc 55        		.byte	85
 653 03fd 44        		.byte	68
 654 03fe 49        		.byte	73
 655 03ff 4F        		.byte	79
 656 0400 20        		.byte	32
 657 0401 3D        		.byte	61
 658 0402 20        		.byte	32
 659 0403 FF        		.byte	-1
 660               	.global	strRange
 663               	strRange:
 664 0404 52        		.byte	82
 665 0405 41        		.byte	65
 666 0406 4E        		.byte	78
 667 0407 47        		.byte	71
 668 0408 45        		.byte	69
 669 0409 20        		.byte	32
 670 040a 3D        		.byte	61
 671 040b 20        		.byte	32
 672 040c FF        		.byte	-1
 673               	.global	strRequals
 676               	strRequals:
 677 040d 52        		.byte	82
 678 040e 3D        		.byte	61
 679 040f 20        		.byte	32
 680 0410 FF        		.byte	-1
 681               	.global	strAlarmOff
 684               	strAlarmOff:
 685 0411 41        		.byte	65
 686 0412 6C        		.byte	108
 687 0413 61        		.byte	97
 688 0414 72        		.byte	114
 689 0415 6D        		.byte	109
 690 0416 20        		.byte	32
 691 0417 4F        		.byte	79
 692 0418 66        		.byte	102
 693 0419 66        		.byte	102
 694 041a FF        		.byte	-1
 695               	.global	strAlarmOn
 698               	strAlarmOn:
 699 041b 41        		.byte	65
 700 041c 6C        		.byte	108
 701 041d 61        		.byte	97
 702 041e 72        		.byte	114
 703 041f 6D        		.byte	109
 704 0420 20        		.byte	32
 705 0421 4F        		.byte	79
 706 0422 6E        		.byte	110
 707 0423 FF        		.byte	-1
 708               	.global	strJan
 711               	strJan:
 712 0424 4A        		.byte	74
 713 0425 61        		.byte	97
 714 0426 6E        		.byte	110
 715 0427 2E        		.byte	46
 716 0428 FF        		.byte	-1
 717               	.global	strFeb
 720               	strFeb:
 721 0429 46        		.byte	70
 722 042a 65        		.byte	101
 723 042b 62        		.byte	98
 724 042c 2E        		.byte	46
 725 042d FF        		.byte	-1
 726               	.global	strMarch
 729               	strMarch:
 730 042e 4D        		.byte	77
 731 042f 61        		.byte	97
 732 0430 72        		.byte	114
 733 0431 2E        		.byte	46
 734 0432 FF        		.byte	-1
 735               	.global	strApril
 738               	strApril:
 739 0433 41        		.byte	65
 740 0434 70        		.byte	112
 741 0435 72        		.byte	114
 742 0436 2E        		.byte	46
 743 0437 FF        		.byte	-1
 744               	.global	strMay
 747               	strMay:
 748 0438 4D        		.byte	77
 749 0439 61        		.byte	97
 750 043a 79        		.byte	121
 751 043b 20        		.byte	32
 752 043c FF        		.byte	-1
 753               	.global	strJune
 756               	strJune:
 757 043d 4A        		.byte	74
 758 043e 75        		.byte	117
 759 043f 6E        		.byte	110
 760 0440 65        		.byte	101
 761 0441 FF        		.byte	-1
 762               	.global	strJuly
 765               	strJuly:
 766 0442 4A        		.byte	74
 767 0443 75        		.byte	117
 768 0444 6C        		.byte	108
 769 0445 79        		.byte	121
 770 0446 FF        		.byte	-1
 771               	.global	strAug
 774               	strAug:
 775 0447 41        		.byte	65
 776 0448 75        		.byte	117
 777 0449 67        		.byte	103
 778 044a 2E        		.byte	46
 779 044b FF        		.byte	-1
 780               	.global	strSept
 783               	strSept:
 784 044c 53        		.byte	83
 785 044d 65        		.byte	101
 786 044e 70        		.byte	112
 787 044f 2E        		.byte	46
 788 0450 FF        		.byte	-1
 789               	.global	strOct
 792               	strOct:
 793 0451 4F        		.byte	79
 794 0452 63        		.byte	99
 795 0453 74        		.byte	116
 796 0454 2E        		.byte	46
 797 0455 FF        		.byte	-1
 798               	.global	strNov
 801               	strNov:
 802 0456 4E        		.byte	78
 803 0457 6F        		.byte	111
 804 0458 76        		.byte	118
 805 0459 2E        		.byte	46
 806 045a FF        		.byte	-1
 807               	.global	strDec
 810               	strDec:
 811 045b 44        		.byte	68
 812 045c 65        		.byte	101
 813 045d 63        		.byte	99
 814 045e 2E        		.byte	46
 815 045f FF        		.byte	-1
 816               	.global	strAM
 819               	strAM:
 820 0460 41        		.byte	65
 821 0461 4D        		.byte	77
 822 0462 FF        		.byte	-1
 823               	.global	strPM
 826               	strPM:
 827 0463 50        		.byte	80
 828 0464 4D        		.byte	77
 829 0465 FF        		.byte	-1
 830               	.global	strPhotoTriggerValue
 833               	strPhotoTriggerValue:
 834 0466 50        		.byte	80
 835 0467 68        		.byte	104
 836 0468 6F        		.byte	111
 837 0469 74        		.byte	116
 838 046a 6F        		.byte	111
 839 046b 20        		.byte	32
 840 046c 54        		.byte	84
 841 046d 72        		.byte	114
 842 046e 69        		.byte	105
 843 046f 67        		.byte	103
 844 0470 67        		.byte	103
 845 0471 65        		.byte	101
 846 0472 72        		.byte	114
 847 0473 20        		.byte	32
 848 0474 56        		.byte	86
 849 0475 61        		.byte	97
 850 0476 6C        		.byte	108
 851 0477 75        		.byte	117
 852 0478 65        		.byte	101
 853 0479 FF        		.byte	-1
 854               	.global	strDarkRoom
 857               	strDarkRoom:
 858 047a 44        		.byte	68
 859 047b 61        		.byte	97
 860 047c 72        		.byte	114
 861 047d 6B        		.byte	107
 862 047e 20        		.byte	32
 863 047f 52        		.byte	82
 864 0480 6F        		.byte	111
 865 0481 6F        		.byte	111
 866 0482 6D        		.byte	109
 867 0483 3D        		.byte	61
 868 0484 39        		.byte	57
 869 0485 30        		.byte	48
 870 0486 30        		.byte	48
 871 0487 FF        		.byte	-1
 872               	.global	strBrightRoom
 875               	strBrightRoom:
 876 0488 42        		.byte	66
 877 0489 72        		.byte	114
 878 048a 69        		.byte	105
 879 048b 67        		.byte	103
 880 048c 68        		.byte	104
 881 048d 74        		.byte	116
 882 048e 20        		.byte	32
 883 048f 52        		.byte	82
 884 0490 6F        		.byte	111
 885 0491 6F        		.byte	111
 886 0492 6D        		.byte	109
 887 0493 3D        		.byte	61
 888 0494 31        		.byte	49
 889 0495 33        		.byte	51
 890 0496 35        		.byte	53
 891 0497 FF        		.byte	-1
 892               	.global	strPhotocellReading
 895               	strPhotocellReading:
 896 0498 50        		.byte	80
 897 0499 68        		.byte	104
 898 049a 6F        		.byte	111
 899 049b 74        		.byte	116
 900 049c 6F        		.byte	111
 901 049d 20        		.byte	32
 902 049e 52        		.byte	82
 903 049f 65        		.byte	101
 904 04a0 61        		.byte	97
 905 04a1 64        		.byte	100
 906 04a2 69        		.byte	105
 907 04a3 6E        		.byte	110
 908 04a4 67        		.byte	103
 909 04a5 3D        		.byte	61
 910 04a6 FF        		.byte	-1
 911               	.global	strSetTriggerValue
 914               	strSetTriggerValue:
 915 04a7 53        		.byte	83
 916 04a8 65        		.byte	101
 917 04a9 74        		.byte	116
 918 04aa 20        		.byte	32
 919 04ab 54        		.byte	84
 920 04ac 72        		.byte	114
 921 04ad 69        		.byte	105
 922 04ae 67        		.byte	103
 923 04af 67        		.byte	103
 924 04b0 65        		.byte	101
 925 04b1 72        		.byte	114
 926 04b2 20        		.byte	32
 927 04b3 56        		.byte	86
 928 04b4 61        		.byte	97
 929 04b5 6C        		.byte	108
 930 04b6 75        		.byte	117
 931 04b7 65        		.byte	101
 932 04b8 3A        		.byte	58
 933 04b9 FF        		.byte	-1
 934               	.global	strBacklightOffTime
 937               	strBacklightOffTime:
 938 04ba 42        		.byte	66
 939 04bb 61        		.byte	97
 940 04bc 63        		.byte	99
 941 04bd 6B        		.byte	107
 942 04be 6C        		.byte	108
 943 04bf 69        		.byte	105
 944 04c0 67        		.byte	103
 945 04c1 68        		.byte	104
 946 04c2 74        		.byte	116
 947 04c3 20        		.byte	32
 948 04c4 4F        		.byte	79
 949 04c5 66        		.byte	102
 950 04c6 66        		.byte	102
 951 04c7 20        		.byte	32
 952 04c8 54        		.byte	84
 953 04c9 69        		.byte	105
 954 04ca 6D        		.byte	109
 955 04cb 65        		.byte	101
 956 04cc FF        		.byte	-1
 957               	.global	strBacklightOnTime
 960               	strBacklightOnTime:
 961 04cd 42        		.byte	66
 962 04ce 61        		.byte	97
 963 04cf 63        		.byte	99
 964 04d0 6B        		.byte	107
 965 04d1 6C        		.byte	108
 966 04d2 69        		.byte	105
 967 04d3 67        		.byte	103
 968 04d4 68        		.byte	104
 969 04d5 74        		.byte	116
 970 04d6 20        		.byte	32
 971 04d7 4F        		.byte	79
 972 04d8 6E        		.byte	110
 973 04d9 20        		.byte	32
 974 04da 54        		.byte	84
 975 04db 69        		.byte	105
 976 04dc 6D        		.byte	109
 977 04dd 65        		.byte	101
 978 04de FF        		.byte	-1
 979               	.global	strUsuallyTen
 982               	strUsuallyTen:
 983 04df 28        		.byte	40
 984 04e0 55        		.byte	85
 985 04e1 73        		.byte	115
 986 04e2 75        		.byte	117
 987 04e3 61        		.byte	97
 988 04e4 6C        		.byte	108
 989 04e5 6C        		.byte	108
 990 04e6 79        		.byte	121
 991 04e7 20        		.byte	32
 992 04e8 31        		.byte	49
 993 04e9 30        		.byte	48
 994 04ea 3A        		.byte	58
 995 04eb 30        		.byte	48
 996 04ec 30        		.byte	48
 997 04ed 70        		.byte	112
 998 04ee 6D        		.byte	109
 999 04ef 29        		.byte	41
 1000 04f0 FF        		.byte	-1
 1001               	.global	strUsuallySix
 1004               	strUsuallySix:
 1005 04f1 28        		.byte	40
 1006 04f2 55        		.byte	85
 1007 04f3 73        		.byte	115
 1008 04f4 75        		.byte	117
 1009 04f5 61        		.byte	97
 1010 04f6 6C        		.byte	108
 1011 04f7 6C        		.byte	108
 1012 04f8 79        		.byte	121
 1013 04f9 20        		.byte	32
 1014 04fa 36        		.byte	54
 1015 04fb 3A        		.byte	58
 1016 04fc 30        		.byte	48
 1017 04fd 30        		.byte	48
 1018 04fe 61        		.byte	97
 1019 04ff 6D        		.byte	109
 1020 0500 29        		.byte	41
 1021 0501 FF        		.byte	-1
 1022               	.global	strColonZero
 1025               	strColonZero:
 1026 0502 3A        		.byte	58
 1027 0503 30        		.byte	48
 1028 0504 30        		.byte	48
 1029 0505 FF        		.byte	-1
 1030               	.global	strBigFont0
 1033               	strBigFont0:
 1034 0506 00        		.byte	0
 1035 0507 80        		.byte	-128
 1036 0508 F0        		.byte	-16
 1037 0509 F8        		.byte	-8
 1038 050a FC        		.byte	-4
 1039 050b 7E        		.byte	126
 1040 050c 1E        		.byte	30
 1041 050d 1E        		.byte	30
 1042 050e 1E        		.byte	30
 1043 050f 7E        		.byte	126
 1044 0510 FC        		.byte	-4
 1045 0511 F8        		.byte	-8
 1046 0512 F0        		.byte	-16
 1047 0513 80        		.byte	-128
 1048 0514 00        		.byte	0
 1049 0515 00        		.byte	0
 1050 0516 00        		.byte	0
 1051 0517 FF        		.byte	-1
 1052 0518 FF        		.byte	-1
 1053 0519 FF        		.byte	-1
 1054 051a FF        		.byte	-1
 1055 051b 00        		.byte	0
 1056 051c 00        		.byte	0
 1057 051d 00        		.byte	0
 1058 051e 00        		.byte	0
 1059 051f 00        		.byte	0
 1060 0520 FF        		.byte	-1
 1061 0521 FF        		.byte	-1
 1062 0522 FF        		.byte	-1
 1063 0523 FF        		.byte	-1
 1064 0524 00        		.byte	0
 1065 0525 00        		.byte	0
 1066 0526 00        		.byte	0
 1067 0527 03        		.byte	3
 1068 0528 1F        		.byte	31
 1069 0529 3F        		.byte	63
 1070 052a 7F        		.byte	127
 1071 052b FC        		.byte	-4
 1072 052c F0        		.byte	-16
 1073 052d F0        		.byte	-16
 1074 052e F0        		.byte	-16
 1075 052f FC        		.byte	-4
 1076 0530 7F        		.byte	127
 1077 0531 3F        		.byte	63
 1078 0532 1F        		.byte	31
 1079 0533 03        		.byte	3
 1080 0534 00        		.byte	0
 1081 0535 00        		.byte	0
 1082 0536 00        		.byte	0
 1083 0537 C0        		.byte	-64
 1084 0538 E0        		.byte	-32
 1085 0539 E0        		.byte	-32
 1086 053a F0        		.byte	-16
 1087 053b 78        		.byte	120
 1088 053c FC        		.byte	-4
 1089 053d FE        		.byte	-2
 1090 053e FE        		.byte	-2
 1091 053f FE        		.byte	-2
 1092 0540 00        		.byte	0
 1093 0541 00        		.byte	0
 1094 0542 00        		.byte	0
 1095 0543 00        		.byte	0
 1096 0544 00        		.byte	0
 1097 0545 00        		.byte	0
 1098 0546 00        		.byte	0
 1099 0547 03        		.byte	3
 1100 0548 01        		.byte	1
 1101 0549 01        		.byte	1
 1102 054a 00        		.byte	0
 1103 054b 00        		.byte	0
 1104 054c FF        		.byte	-1
 1105 054d FF        		.byte	-1
 1106 054e FF        		.byte	-1
 1107 054f FF        		.byte	-1
 1108 0550 00        		.byte	0
 1109 0551 00        		.byte	0
 1110 0552 00        		.byte	0
 1111 0553 00        		.byte	0
 1112 0554 00        		.byte	0
 1113 0555 00        		.byte	0
 1114 0556 00        		.byte	0
 1115 0557 F0        		.byte	-16
 1116 0558 F0        		.byte	-16
 1117 0559 F0        		.byte	-16
 1118 055a F0        		.byte	-16
 1119 055b F0        		.byte	-16
 1120 055c FF        		.byte	-1
 1121 055d FF        		.byte	-1
 1122 055e FF        		.byte	-1
 1123 055f FF        		.byte	-1
 1124 0560 F0        		.byte	-16
 1125 0561 F0        		.byte	-16
 1126 0562 F0        		.byte	-16
 1127 0563 F0        		.byte	-16
 1128 0564 00        		.byte	0
 1129 0565 00        		.byte	0
 1130 0566 00        		.byte	0
 1131 0567 E0        		.byte	-32
 1132 0568 F8        		.byte	-8
 1133 0569 FC        		.byte	-4
 1134 056a FC        		.byte	-4
 1135 056b 3E        		.byte	62
 1136 056c 1E        		.byte	30
 1137 056d 1E        		.byte	30
 1138 056e 1E        		.byte	30
 1139 056f 3E        		.byte	62
 1140 0570 FC        		.byte	-4
 1141 0571 FC        		.byte	-4
 1142 0572 F8        		.byte	-8
 1143 0573 E0        		.byte	-32
 1144 0574 00        		.byte	0
 1145 0575 00        		.byte	0
 1146 0576 00        		.byte	0
 1147 0577 00        		.byte	0
 1148 0578 00        		.byte	0
 1149 0579 00        		.byte	0
 1150 057a 00        		.byte	0
 1151 057b 80        		.byte	-128
 1152 057c C0        		.byte	-64
 1153 057d E0        		.byte	-32
 1154 057e F0        		.byte	-16
 1155 057f FC        		.byte	-4
 1156 0580 7F        		.byte	127
 1157 0581 3F        		.byte	63
 1158 0582 1F        		.byte	31
 1159 0583 03        		.byte	3
 1160 0584 00        		.byte	0
 1161 0585 00        		.byte	0
 1162 0586 00        		.byte	0
 1163 0587 C0        		.byte	-64
 1164 0588 F8        		.byte	-8
 1165 0589 FC        		.byte	-4
 1166 058a FF        		.byte	-1
 1167 058b FF        		.byte	-1
 1168 058c FF        		.byte	-1
 1169 058d F3        		.byte	-13
 1170 058e F1        		.byte	-15
 1171 058f F0        		.byte	-16
 1172 0590 F0        		.byte	-16
 1173 0591 F0        		.byte	-16
 1174 0592 F0        		.byte	-16
 1175 0593 F0        		.byte	-16
 1176 0594 00        		.byte	0
 1177 0595 00        		.byte	0
 1178 0596 00        		.byte	0
 1179 0597 C0        		.byte	-64
 1180 0598 F0        		.byte	-16
 1181 0599 FC        		.byte	-4
 1182 059a FC        		.byte	-4
 1183 059b 3E        		.byte	62
 1184 059c 1E        		.byte	30
 1185 059d 1E        		.byte	30
 1186 059e 1E        		.byte	30
 1187 059f 3E        		.byte	62
 1188 05a0 FC        		.byte	-4
 1189 05a1 FC        		.byte	-4
 1190 05a2 F8        		.byte	-8
 1191 05a3 E0        		.byte	-32
 1192 05a4 00        		.byte	0
 1193 05a5 00        		.byte	0
 1194 05a6 00        		.byte	0
 1195 05a7 00        		.byte	0
 1196 05a8 00        		.byte	0
 1197 05a9 00        		.byte	0
 1198 05aa 00        		.byte	0
 1199 05ab 00        		.byte	0
 1200 05ac 3C        		.byte	60
 1201 05ad 3C        		.byte	60
 1202 05ae 3C        		.byte	60
 1203 05af 7E        		.byte	126
 1204 05b0 FF        		.byte	-1
 1205 05b1 FF        		.byte	-1
 1206 05b2 E7        		.byte	-25
 1207 05b3 C1        		.byte	-63
 1208 05b4 00        		.byte	0
 1209 05b5 00        		.byte	0
 1210 05b6 00        		.byte	0
 1211 05b7 06        		.byte	6
 1212 05b8 1E        		.byte	30
 1213 05b9 7E        		.byte	126
 1214 05ba 7E        		.byte	126
 1215 05bb F8        		.byte	-8
 1216 05bc F0        		.byte	-16
 1217 05bd F0        		.byte	-16
 1218 05be F0        		.byte	-16
 1219 05bf F8        		.byte	-8
 1220 05c0 7F        		.byte	127
 1221 05c1 7F        		.byte	127
 1222 05c2 3F        		.byte	63
 1223 05c3 0F        		.byte	15
 1224 05c4 00        		.byte	0
 1225 05c5 00        		.byte	0
 1226 05c6 00        		.byte	0
 1227 05c7 FE        		.byte	-2
 1228 05c8 FE        		.byte	-2
 1229 05c9 FE        		.byte	-2
 1230 05ca FE        		.byte	-2
 1231 05cb 00        		.byte	0
 1232 05cc 00        		.byte	0
 1233 05cd 00        		.byte	0
 1234 05ce FE        		.byte	-2
 1235 05cf FE        		.byte	-2
 1236 05d0 FE        		.byte	-2
 1237 05d1 FE        		.byte	-2
 1238 05d2 00        		.byte	0
 1239 05d3 00        		.byte	0
 1240 05d4 00        		.byte	0
 1241 05d5 00        		.byte	0
 1242 05d6 00        		.byte	0
 1243 05d7 FF        		.byte	-1
 1244 05d8 FF        		.byte	-1
 1245 05d9 FF        		.byte	-1
 1246 05da FF        		.byte	-1
 1247 05db F8        		.byte	-8
 1248 05dc F8        		.byte	-8
 1249 05dd F8        		.byte	-8
 1250 05de FF        		.byte	-1
 1251 05df FF        		.byte	-1
 1252 05e0 FF        		.byte	-1
 1253 05e1 FF        		.byte	-1
 1254 05e2 F8        		.byte	-8
 1255 05e3 F8        		.byte	-8
 1256 05e4 00        		.byte	0
 1257 05e5 00        		.byte	0
 1258 05e6 00        		.byte	0
 1259 05e7 00        		.byte	0
 1260 05e8 00        		.byte	0
 1261 05e9 00        		.byte	0
 1262 05ea 00        		.byte	0
 1263 05eb 00        		.byte	0
 1264 05ec 00        		.byte	0
 1265 05ed 00        		.byte	0
 1266 05ee FF        		.byte	-1
 1267 05ef FF        		.byte	-1
 1268 05f0 FF        		.byte	-1
 1269 05f1 FF        		.byte	-1
 1270 05f2 00        		.byte	0
 1271 05f3 00        		.byte	0
 1272 05f4 00        		.byte	0
 1273 05f5 00        		.byte	0
 1274 05f6 00        		.byte	0
 1275 05f7 FE        		.byte	-2
 1276 05f8 FE        		.byte	-2
 1277 05f9 FE        		.byte	-2
 1278 05fa FE        		.byte	-2
 1279 05fb 1E        		.byte	30
 1280 05fc 1E        		.byte	30
 1281 05fd 1E        		.byte	30
 1282 05fe 1E        		.byte	30
 1283 05ff 1E        		.byte	30
 1284 0600 1E        		.byte	30
 1285 0601 1E        		.byte	30
 1286 0602 1E        		.byte	30
 1287 0603 00        		.byte	0
 1288 0604 00        		.byte	0
 1289 0605 00        		.byte	0
 1290 0606 00        		.byte	0
 1291 0607 1F        		.byte	31
 1292 0608 3F        		.byte	63
 1293 0609 3F        		.byte	63
 1294 060a 1F        		.byte	31
 1295 060b 0F        		.byte	15
 1296 060c 0F        		.byte	15
 1297 060d 0F        		.byte	15
 1298 060e 0F        		.byte	15
 1299 060f 1F        		.byte	31
 1300 0610 FE        		.byte	-2
 1301 0611 FE        		.byte	-2
 1302 0612 FC        		.byte	-4
 1303 0613 F0        		.byte	-16
 1304 0614 00        		.byte	0
 1305 0615 00        		.byte	0
 1306 0616 00        		.byte	0
 1307 0617 06        		.byte	6
 1308 0618 1E        		.byte	30
 1309 0619 7E        		.byte	126
 1310 061a 7E        		.byte	126
 1311 061b F8        		.byte	-8
 1312 061c F0        		.byte	-16
 1313 061d F0        		.byte	-16
 1314 061e F0        		.byte	-16
 1315 061f F8        		.byte	-8
 1316 0620 7F        		.byte	127
 1317 0621 3F        		.byte	63
 1318 0622 1F        		.byte	31
 1319 0623 07        		.byte	7
 1320 0624 00        		.byte	0
 1321 0625 00        		.byte	0
 1322 0626 00        		.byte	0
 1323 0627 80        		.byte	-128
 1324 0628 E0        		.byte	-32
 1325 0629 F8        		.byte	-8
 1326 062a FC        		.byte	-4
 1327 062b 7C        		.byte	124
 1328 062c 1E        		.byte	30
 1329 062d 1E        		.byte	30
 1330 062e 1E        		.byte	30
 1331 062f 3E        		.byte	62
 1332 0630 7E        		.byte	126
 1333 0631 7C        		.byte	124
 1334 0632 78        		.byte	120
 1335 0633 60        		.byte	96
 1336 0634 00        		.byte	0
 1337 0635 00        		.byte	0
 1338 0636 00        		.byte	0
 1339 0637 FF        		.byte	-1
 1340 0638 FF        		.byte	-1
 1341 0639 FF        		.byte	-1
 1342 063a FF        		.byte	-1
 1343 063b 3C        		.byte	60
 1344 063c 1E        		.byte	30
 1345 063d 1E        		.byte	30
 1346 063e 1E        		.byte	30
 1347 063f 3E        		.byte	62
 1348 0640 FC        		.byte	-4
 1349 0641 FC        		.byte	-4
 1350 0642 F8        		.byte	-8
 1351 0643 E0        		.byte	-32
 1352 0644 00        		.byte	0
 1353 0645 00        		.byte	0
 1354 0646 00        		.byte	0
 1355 0647 03        		.byte	3
 1356 0648 1F        		.byte	31
 1357 0649 3F        		.byte	63
 1358 064a 7F        		.byte	127
 1359 064b F8        		.byte	-8
 1360 064c F0        		.byte	-16
 1361 064d F0        		.byte	-16
 1362 064e F0        		.byte	-16
 1363 064f F8        		.byte	-8
 1364 0650 7F        		.byte	127
 1365 0651 7F        		.byte	127
 1366 0652 3F        		.byte	63
 1367 0653 0F        		.byte	15
 1368 0654 00        		.byte	0
 1369 0655 00        		.byte	0
 1370 0656 00        		.byte	0
 1371 0657 1E        		.byte	30
 1372 0658 1E        		.byte	30
 1373 0659 1E        		.byte	30
 1374 065a 1E        		.byte	30
 1375 065b 1E        		.byte	30
 1376 065c 1E        		.byte	30
 1377 065d 1E        		.byte	30
 1378 065e DE        		.byte	-34
 1379 065f FE        		.byte	-2
 1380 0660 FE        		.byte	-2
 1381 0661 FE        		.byte	-2
 1382 0662 3E        		.byte	62
 1383 0663 1E        		.byte	30
 1384 0664 00        		.byte	0
 1385 0665 00        		.byte	0
 1386 0666 00        		.byte	0
 1387 0667 00        		.byte	0
 1388 0668 00        		.byte	0
 1389 0669 00        		.byte	0
 1390 066a 80        		.byte	-128
 1391 066b F0        		.byte	-16
 1392 066c FC        		.byte	-4
 1393 066d FF        		.byte	-1
 1394 066e 7F        		.byte	127
 1395 066f 0F        		.byte	15
 1396 0670 03        		.byte	3
 1397 0671 00        		.byte	0
 1398 0672 00        		.byte	0
 1399 0673 00        		.byte	0
 1400 0674 00        		.byte	0
 1401 0675 00        		.byte	0
 1402 0676 00        		.byte	0
 1403 0677 00        		.byte	0
 1404 0678 00        		.byte	0
 1405 0679 F8        		.byte	-8
 1406 067a FF        		.byte	-1
 1407 067b FF        		.byte	-1
 1408 067c FF        		.byte	-1
 1409 067d 07        		.byte	7
 1410 067e 00        		.byte	0
 1411 067f 00        		.byte	0
 1412 0680 00        		.byte	0
 1413 0681 00        		.byte	0
 1414 0682 00        		.byte	0
 1415 0683 00        		.byte	0
 1416 0684 00        		.byte	0
 1417 0685 00        		.byte	0
 1418 0686 00        		.byte	0
 1419 0687 F0        		.byte	-16
 1420 0688 F8        		.byte	-8
 1421 0689 FC        		.byte	-4
 1422 068a FC        		.byte	-4
 1423 068b 3E        		.byte	62
 1424 068c 1E        		.byte	30
 1425 068d 1E        		.byte	30
 1426 068e 1E        		.byte	30
 1427 068f 3E        		.byte	62
 1428 0690 FC        		.byte	-4
 1429 0691 FC        		.byte	-4
 1430 0692 F8        		.byte	-8
 1431 0693 F0        		.byte	-16
 1432 0694 00        		.byte	0
 1433 0695 00        		.byte	0
 1434 0696 00        		.byte	0
 1435 0697 81        		.byte	-127
 1436 0698 E7        		.byte	-25
 1437 0699 F7        		.byte	-9
 1438 069a FF        		.byte	-1
 1439 069b 7E        		.byte	126
 1440 069c 3C        		.byte	60
 1441 069d 3C        		.byte	60
 1442 069e 3C        		.byte	60
 1443 069f 7E        		.byte	126
 1444 06a0 FF        		.byte	-1
 1445 06a1 FF        		.byte	-1
 1446 06a2 E7        		.byte	-25
 1447 06a3 81        		.byte	-127
 1448 06a4 00        		.byte	0
 1449 06a5 00        		.byte	0
 1450 06a6 00        		.byte	0
 1451 06a7 0F        		.byte	15
 1452 06a8 3F        		.byte	63
 1453 06a9 7F        		.byte	127
 1454 06aa 7F        		.byte	127
 1455 06ab F8        		.byte	-8
 1456 06ac F0        		.byte	-16
 1457 06ad F0        		.byte	-16
 1458 06ae F0        		.byte	-16
 1459 06af F8        		.byte	-8
 1460 06b0 7F        		.byte	127
 1461 06b1 7F        		.byte	127
 1462 06b2 3F        		.byte	63
 1463 06b3 0F        		.byte	15
 1464 06b4 00        		.byte	0
 1465 06b5 00        		.byte	0
 1466 06b6 00        		.byte	0
 1467 06b7 E0        		.byte	-32
 1468 06b8 F8        		.byte	-8
 1469 06b9 FC        		.byte	-4
 1470 06ba FC        		.byte	-4
 1471 06bb 3E        		.byte	62
 1472 06bc 1E        		.byte	30
 1473 06bd 1E        		.byte	30
 1474 06be 1E        		.byte	30
 1475 06bf 3E        		.byte	62
 1476 06c0 FC        		.byte	-4
 1477 06c1 F8        		.byte	-8
 1478 06c2 F0        		.byte	-16
 1479 06c3 80        		.byte	-128
 1480 06c4 00        		.byte	0
 1481 06c5 00        		.byte	0
 1482 06c6 00        		.byte	0
 1483 06c7 0F        		.byte	15
 1484 06c8 3F        		.byte	63
 1485 06c9 7F        		.byte	127
 1486 06ca 7F        		.byte	127
 1487 06cb F8        		.byte	-8
 1488 06cc F0        		.byte	-16
 1489 06cd F0        		.byte	-16
 1490 06ce F0        		.byte	-16
 1491 06cf 78        		.byte	120
 1492 06d0 FF        		.byte	-1
 1493 06d1 FF        		.byte	-1
 1494 06d2 FF        		.byte	-1
 1495 06d3 FF        		.byte	-1
 1496 06d4 00        		.byte	0
 1497 06d5 00        		.byte	0
 1498 06d6 00        		.byte	0
 1499 06d7 0C        		.byte	12
 1500 06d8 3C        		.byte	60
 1501 06d9 7C        		.byte	124
 1502 06da FC        		.byte	-4
 1503 06db F8        		.byte	-8
 1504 06dc F0        		.byte	-16
 1505 06dd F0        		.byte	-16
 1506 06de F0        		.byte	-16
 1507 06df 7C        		.byte	124
 1508 06e0 7F        		.byte	127
 1509 06e1 3F        		.byte	63
 1510 06e2 0F        		.byte	15
 1511 06e3 03        		.byte	3
 1512 06e4 00        		.byte	0
 1513 06e5 00        		.byte	0
 1514               	.global	strBigFontPeriod
 1517               	strBigFontPeriod:
 1518 06e6 00        		.byte	0
 1519 06e7 00        		.byte	0
 1520 06e8 00        		.byte	0
 1521 06e9 00        		.byte	0
 1522 06ea 00        		.byte	0
 1523 06eb 00        		.byte	0
 1524 06ec 00        		.byte	0
 1525 06ed 00        		.byte	0
 1526 06ee 00        		.byte	0
 1527 06ef 00        		.byte	0
 1528 06f0 00        		.byte	0
 1529 06f1 00        		.byte	0
 1530 06f2 00        		.byte	0
 1531 06f3 00        		.byte	0
 1532 06f4 00        		.byte	0
 1533 06f5 00        		.byte	0
 1534 06f6 00        		.byte	0
 1535 06f7 00        		.byte	0
 1536 06f8 00        		.byte	0
 1537 06f9 00        		.byte	0
 1538 06fa 00        		.byte	0
 1539 06fb 00        		.byte	0
 1540 06fc 00        		.byte	0
 1541 06fd 00        		.byte	0
 1542 06fe 00        		.byte	0
 1543 06ff 00        		.byte	0
 1544 0700 00        		.byte	0
 1545 0701 00        		.byte	0
 1546 0702 00        		.byte	0
 1547 0703 00        		.byte	0
 1548 0704 00        		.byte	0
 1549 0705 00        		.byte	0
 1550 0706 00        		.byte	0
 1551 0707 00        		.byte	0
 1552 0708 00        		.byte	0
 1553 0709 00        		.byte	0
 1554 070a 00        		.byte	0
 1555 070b F8        		.byte	-8
 1556 070c F8        		.byte	-8
 1557 070d F8        		.byte	-8
 1558 070e F8        		.byte	-8
 1559 070f F8        		.byte	-8
 1560 0710 00        		.byte	0
 1561 0711 00        		.byte	0
 1562 0712 00        		.byte	0
 1563 0713 00        		.byte	0
 1564 0714 00        		.byte	0
 1565 0715 00        		.byte	0
 1566               	.global	strBigFontColon
 1569               	strBigFontColon:
 1570 0716 00        		.byte	0
 1571 0717 00        		.byte	0
 1572 0718 00        		.byte	0
 1573 0719 00        		.byte	0
 1574 071a 00        		.byte	0
 1575 071b 00        		.byte	0
 1576 071c E0        		.byte	-32
 1577 071d E0        		.byte	-32
 1578 071e E0        		.byte	-32
 1579 071f E0        		.byte	-32
 1580 0720 00        		.byte	0
 1581 0721 00        		.byte	0
 1582 0722 00        		.byte	0
 1583 0723 00        		.byte	0
 1584 0724 00        		.byte	0
 1585 0725 00        		.byte	0
 1586 0726 00        		.byte	0
 1587 0727 00        		.byte	0
 1588 0728 00        		.byte	0
 1589 0729 00        		.byte	0
 1590 072a 00        		.byte	0
 1591 072b 00        		.byte	0
 1592 072c 81        		.byte	-127
 1593 072d 81        		.byte	-127
 1594 072e 81        		.byte	-127
 1595 072f 81        		.byte	-127
 1596 0730 00        		.byte	0
 1597 0731 00        		.byte	0
 1598 0732 00        		.byte	0
 1599 0733 00        		.byte	0
 1600 0734 00        		.byte	0
 1601 0735 00        		.byte	0
 1602 0736 00        		.byte	0
 1603 0737 00        		.byte	0
 1604 0738 00        		.byte	0
 1605 0739 00        		.byte	0
 1606 073a 00        		.byte	0
 1607 073b 00        		.byte	0
 1608 073c 07        		.byte	7
 1609 073d 07        		.byte	7
 1610 073e 07        		.byte	7
 1611 073f 07        		.byte	7
 1612 0740 00        		.byte	0
 1613 0741 00        		.byte	0
 1614 0742 00        		.byte	0
 1615 0743 00        		.byte	0
 1616 0744 00        		.byte	0
 1617 0745 00        		.byte	0
 1618               	.global	strSegTbl
 1621               	strSegTbl:
 1622 0746 7E        		.byte	126
 1623 0747 30        		.byte	48
 1624 0748 6D        		.byte	109
 1625 0749 79        		.byte	121
 1626 074a 33        		.byte	51
 1627 074b 5B        		.byte	91
 1628 074c 5F        		.byte	95
 1629 074d 70        		.byte	112
 1630 074e 7F        		.byte	127
 1631 074f 7B        		.byte	123
 1632               	.global	str50
 1635               	str50:
 1636 0750 43        		.byte	67
 1637 0751 6C        		.byte	108
 1638 0752 6F        		.byte	111
 1639 0753 63        		.byte	99
 1640 0754 6B        		.byte	107
 1641 0755 20        		.byte	32
 1642 0756 53        		.byte	83
 1643 0757 65        		.byte	101
 1644 0758 74        		.byte	116
 1645 0759 75        		.byte	117
 1646 075a 70        		.byte	112
 1647 075b FF        		.byte	-1
 1648 075c 0000 0000 		.skip 10,0
 1648      0000 0000 
 1648      0000 
 1649 0766 53        		.byte	83
 1650 0767 65        		.byte	101
 1651 0768 74        		.byte	116
 1652 0769 20        		.byte	32
 1653 076a 41        		.byte	65
 1654 076b 6C        		.byte	108
 1655 076c 61        		.byte	97
 1656 076d 72        		.byte	114
 1657 076e 6D        		.byte	109
 1658 076f 20        		.byte	32
 1659 0770 4F        		.byte	79
 1660 0771 4E        		.byte	78
 1661 0772 2F        		.byte	47
 1662 0773 4F        		.byte	79
 1663 0774 46        		.byte	70
 1664 0775 46        		.byte	70
 1665 0776 FF        		.byte	-1
 1666 0777 0000 0000 		.skip 5,0
 1666      00
 1667 077c 53        		.byte	83
 1668 077d 65        		.byte	101
 1669 077e 74        		.byte	116
 1670 077f 20        		.byte	32
 1671 0780 43        		.byte	67
 1672 0781 6C        		.byte	108
 1673 0782 6F        		.byte	111
 1674 0783 63        		.byte	99
 1675 0784 6B        		.byte	107
 1676 0785 FF        		.byte	-1
 1677 0786 0000 0000 		.skip 12,0
 1677      0000 0000 
 1677      0000 0000 
 1678 0792 53        		.byte	83
 1679 0793 65        		.byte	101
 1680 0794 74        		.byte	116
 1681 0795 20        		.byte	32
 1682 0796 41        		.byte	65
 1683 0797 6C        		.byte	108
 1684 0798 61        		.byte	97
 1685 0799 72        		.byte	114
 1686 079a 6D        		.byte	109
 1687 079b FF        		.byte	-1
 1688 079c 0000 0000 		.skip 12,0
 1688      0000 0000 
 1688      0000 0000 
 1689 07a8 53        		.byte	83
 1690 07a9 65        		.byte	101
 1691 07aa 74        		.byte	116
 1692 07ab 20        		.byte	32
 1693 07ac 42        		.byte	66
 1694 07ad 61        		.byte	97
 1695 07ae 63        		.byte	99
 1696 07af 6B        		.byte	107
 1697 07b0 6C        		.byte	108
 1698 07b1 69        		.byte	105
 1699 07b2 67        		.byte	103
 1700 07b3 68        		.byte	104
 1701 07b4 74        		.byte	116
 1702 07b5 20        		.byte	32
 1703 07b6 54        		.byte	84
 1704 07b7 69        		.byte	105
 1705 07b8 6D        		.byte	109
 1706 07b9 65        		.byte	101
 1707 07ba FF        		.byte	-1
 1708 07bb 0000 00   		.skip 3,0
 1709 07be 50        		.byte	80
 1710 07bf 68        		.byte	104
 1711 07c0 6F        		.byte	111
 1712 07c1 74        		.byte	116
 1713 07c2 6F        		.byte	111
 1714 07c3 20        		.byte	32
 1715 07c4 54        		.byte	84
 1716 07c5 72        		.byte	114
 1717 07c6 69        		.byte	105
 1718 07c7 67        		.byte	103
 1719 07c8 67        		.byte	103
 1720 07c9 65        		.byte	101
 1721 07ca 72        		.byte	114
 1722 07cb 20        		.byte	32
 1723 07cc 56        		.byte	86
 1724 07cd 61        		.byte	97
 1725 07ce 6C        		.byte	108
 1726 07cf 75        		.byte	117
 1727 07d0 65        		.byte	101
 1728 07d1 FF        		.byte	-1
 1729 07d2 0000      		.skip 2,0
 1730 07d4 41        		.byte	65
 1731 07d5 62        		.byte	98
 1732 07d6 6F        		.byte	111
 1733 07d7 75        		.byte	117
 1734 07d8 74        		.byte	116
 1735 07d9 20        		.byte	32
 1736 07da 54        		.byte	84
 1737 07db 68        		.byte	104
 1738 07dc 69        		.byte	105
 1739 07dd 73        		.byte	115
 1740 07de 20        		.byte	32
 1741 07df 43        		.byte	67
 1742 07e0 6C        		.byte	108
 1743 07e1 6F        		.byte	111
 1744 07e2 63        		.byte	99
 1745 07e3 6B        		.byte	107
 1746 07e4 FF        		.byte	-1
 1747 07e5 0000 0000 		.skip 5,0
 1747      00
 1748 07ea 45        		.byte	69
 1749 07eb 58        		.byte	88
 1750 07ec 49        		.byte	73
 1751 07ed 54        		.byte	84
 1752 07ee FF        		.byte	-1
 1753 07ef 0000 0000 		.skip 17,0
 1753      0000 0000 
 1753      0000 0000 
 1753      0000 0000 
 1753      00
 1754               	.global	str51
 1757               	str51:
 1758 0800 4F        		.byte	79
 1759 0801 44        		.byte	68
 1760 0802 45        		.byte	69
 1761 0803 20        		.byte	32
 1762 0804 54        		.byte	84
 1763 0805 4F        		.byte	79
 1764 0806 20        		.byte	32
 1765 0807 53        		.byte	83
 1766 0808 50        		.byte	80
 1767 0809 4F        		.byte	79
 1768 080a 54        		.byte	84
 1769 080b FF        		.byte	-1
 1770 080c 0000 0000 		.skip 10,0
 1770      0000 0000 
 1770      0000 
 1771 0816 46        		.byte	70
 1772 0817 65        		.byte	101
 1773 0818 6C        		.byte	108
 1774 0819 69        		.byte	105
 1775 081a 73        		.byte	115
 1776 081b 20        		.byte	32
 1777 081c 43        		.byte	67
 1778 081d 61        		.byte	97
 1779 081e 74        		.byte	116
 1780 081f 74        		.byte	116
 1781 0820 75        		.byte	117
 1782 0821 73        		.byte	115
 1783 0822 FF        		.byte	-1
 1784 0823 0000 0000 		.skip 9,0
 1784      0000 0000 
 1784      00
 1785 082c 69        		.byte	105
 1786 082d 73        		.byte	115
 1787 082e 20        		.byte	32
 1788 082f 79        		.byte	121
 1789 0830 6F        		.byte	111
 1790 0831 75        		.byte	117
 1791 0832 72        		.byte	114
 1792 0833 20        		.byte	32
 1793 0834 74        		.byte	116
 1794 0835 61        		.byte	97
 1795 0836 78        		.byte	120
 1796 0837 6F        		.byte	111
 1797 0838 6E        		.byte	110
 1798 0839 6F        		.byte	111
 1799 083a 6D        		.byte	109
 1800 083b 69        		.byte	105
 1801 083c 63        		.byte	99
 1802 083d FF        		.byte	-1
 1803 083e 0000 0000 		.skip 4,0
 1804 0842 6E        		.byte	110
 1805 0843 6F        		.byte	111
 1806 0844 6D        		.byte	109
 1807 0845 65        		.byte	101
 1808 0846 6E        		.byte	110
 1809 0847 63        		.byte	99
 1810 0848 6C        		.byte	108
 1811 0849 61        		.byte	97
 1812 084a 74        		.byte	116
 1813 084b 75        		.byte	117
 1814 084c 72        		.byte	114
 1815 084d 65        		.byte	101
 1816 084e FF        		.byte	-1
 1817 084f 0000 0000 		.skip 9,0
 1817      0000 0000 
 1817      00
 1818 0858 61        		.byte	97
 1819 0859 6E        		.byte	110
 1820 085a 20        		.byte	32
 1821 085b 65        		.byte	101
 1822 085c 6E        		.byte	110
 1823 085d 64        		.byte	100
 1824 085e 6F        		.byte	111
 1825 085f 74        		.byte	116
 1826 0860 68        		.byte	104
 1827 0861 65        		.byte	101
 1828 0862 72        		.byte	114
 1829 0863 6D        		.byte	109
 1830 0864 69        		.byte	105
 1831 0865 63        		.byte	99
 1832 0866 FF        		.byte	-1
 1833 0867 0000 0000 		.skip 7,0
 1833      0000 00
 1834 086e 71        		.byte	113
 1835 086f 75        		.byte	117
 1836 0870 61        		.byte	97
 1837 0871 64        		.byte	100
 1838 0872 72        		.byte	114
 1839 0873 75        		.byte	117
 1840 0874 70        		.byte	112
 1841 0875 65        		.byte	101
 1842 0876 64        		.byte	100
 1843 0877 2C        		.byte	44
 1844 0878 FF        		.byte	-1
 1845 0879 0000 0000 		.skip 11,0
 1845      0000 0000 
 1845      0000 00
 1846 0884 63        		.byte	99
 1847 0885 61        		.byte	97
 1848 0886 72        		.byte	114
 1849 0887 6E        		.byte	110
 1850 0888 69        		.byte	105
 1851 0889 76        		.byte	118
 1852 088a 6F        		.byte	111
 1853 088b 72        		.byte	114
 1854 088c 6F        		.byte	111
 1855 088d 75        		.byte	117
 1856 088e 73        		.byte	115
 1857 088f FF        		.byte	-1
 1858 0890 0000 0000 		.skip 10,0
 1858      0000 0000 
 1858      0000 
 1859 089a 62        		.byte	98
 1860 089b 79        		.byte	121
 1861 089c 20        		.byte	32
 1862 089d 6E        		.byte	110
 1863 089e 61        		.byte	97
 1864 089f 74        		.byte	116
 1865 08a0 75        		.byte	117
 1866 08a1 72        		.byte	114
 1867 08a2 65        		.byte	101
 1868 08a3 3F        		.byte	63
 1869 08a4 FF        		.byte	-1
 1870 08a5 0000 0000 		.skip 11,0
 1870      0000 0000 
 1870      0000 00
 1871               	.global	str64
 1874               	str64:
 1875 08b0 44        		.byte	68
 1876 08b1 65        		.byte	101
 1877 08b2 73        		.byte	115
 1878 08b3 69        		.byte	105
 1879 08b4 67        		.byte	103
 1880 08b5 6E        		.byte	110
 1881 08b6 65        		.byte	101
 1882 08b7 72        		.byte	114
 1883 08b8 3A        		.byte	58
 1884 08b9 FF        		.byte	-1
 1885 08ba 0000 0000 		.skip 12,0
 1885      0000 0000 
 1885      0000 0000 
 1886 08c6 4D        		.byte	77
 1887 08c7 61        		.byte	97
 1888 08c8 74        		.byte	116
 1889 08c9 74        		.byte	116
 1890 08ca 20        		.byte	32
 1891 08cb 4D        		.byte	77
 1892 08cc 65        		.byte	101
 1893 08cd 65        		.byte	101
 1894 08ce 72        		.byte	114
 1895 08cf 69        		.byte	105
 1896 08d0 61        		.byte	97
 1897 08d1 6E        		.byte	110
 1898 08d2 FF        		.byte	-1
 1899 08d3 0000 0000 		.skip 9,0
 1899      0000 0000 
 1899      00
 1900 08dc 43        		.byte	67
 1901 08dd 68        		.byte	104
 1902 08de 61        		.byte	97
 1903 08df 6E        		.byte	110
 1904 08e0 75        		.byte	117
 1905 08e1 74        		.byte	116
 1906 08e2 65        		.byte	101
 1907 08e3 2C        		.byte	44
 1908 08e4 20        		.byte	32
 1909 08e5 4B        		.byte	75
 1910 08e6 61        		.byte	97
 1911 08e7 6E        		.byte	110
 1912 08e8 73        		.byte	115
 1913 08e9 61        		.byte	97
 1914 08ea 73        		.byte	115
 1915 08eb FF        		.byte	-1
 1916 08ec 0000 0000 		.skip 6,0
 1916      0000 
 1917 08f2 41        		.byte	65
 1918 08f3 75        		.byte	117
 1919 08f4 67        		.byte	103
 1920 08f5 2E        		.byte	46
 1921 08f6 20        		.byte	32
 1922 08f7 32        		.byte	50
 1923 08f8 30        		.byte	48
 1924 08f9 30        		.byte	48
 1925 08fa 35        		.byte	53
 1926 08fb 20        		.byte	32
 1927 08fc 56        		.byte	86
 1928 08fd 31        		.byte	49
 1929 08fe 2E        		.byte	46
 1930 08ff 31        		.byte	49
 1931 0900 FF        		.byte	-1
 1932 0901 0000 0000 		.skip 7,0
 1932      0000 00
 1933 0908 75        		.byte	117
 1934 0909 43        		.byte	67
 1935 090a 6F        		.byte	111
 1936 090b 6E        		.byte	110
 1937 090c 74        		.byte	116
 1938 090d 72        		.byte	114
 1939 090e 6F        		.byte	111
 1940 090f 6C        		.byte	108
 1941 0910 3A        		.byte	58
 1942 0911 20        		.byte	32
 1943 0912 41        		.byte	65
 1944 0913 54        		.byte	84
 1945 0914 4D        		.byte	77
 1946 0915 45        		.byte	69
 1947 0916 47        		.byte	71
 1948 0917 41        		.byte	65
 1949 0918 33        		.byte	51
 1950 0919 32        		.byte	50
 1951 091a FF        		.byte	-1
 1952 091b 0000 00   		.skip 3,0
 1953 091e 43        		.byte	67
 1954 091f 6C        		.byte	108
 1955 0920 6F        		.byte	111
 1956 0921 63        		.byte	99
 1957 0922 6B        		.byte	107
 1958 0923 3D        		.byte	61
 1959 0924 34        		.byte	52
 1960 0925 4D        		.byte	77
 1961 0926 48        		.byte	72
 1962 0927 7A        		.byte	122
 1963 0928 FF        		.byte	-1
 1964 0929 0000 0000 		.skip 11,0
 1964      0000 0000 
 1964      0000 00
 1965 0934 52        		.byte	82
 1966 0935 65        		.byte	101
 1967 0936 62        		.byte	98
 1968 0937 65        		.byte	101
 1969 0938 63        		.byte	99
 1970 0939 63        		.byte	99
 1971 093a 61        		.byte	97
 1972 093b 20        		.byte	32
 1973 093c 69        		.byte	105
 1974 093d 73        		.byte	115
 1975 093e 20        		.byte	32
 1976 093f 61        		.byte	97
 1977 0940 20        		.byte	32
 1978 0941 62        		.byte	98
 1979 0942 61        		.byte	97
 1980 0943 62        		.byte	98
 1981 0944 65        		.byte	101
 1982 0945 21        		.byte	33
 1983 0946 FF        		.byte	-1
 1984 0947 0000 00   		.skip 3,0
 1985 094a 28        		.byte	40
 1986 094b 61        		.byte	97
 1987 094c 6E        		.byte	110
 1988 094d 79        		.byte	121
 1989 094e 20        		.byte	32
 1990 094f 6B        		.byte	107
 1991 0950 65        		.byte	101
 1992 0951 79        		.byte	121
 1993 0952 20        		.byte	32
 1994 0953 65        		.byte	101
 1995 0954 78        		.byte	120
 1996 0955 69        		.byte	105
 1997 0956 74        		.byte	116
 1998 0957 73        		.byte	115
 1999 0958 29        		.byte	41
 2000 0959 FF        		.byte	-1
 2001 095a 0000 0000 		.skip 6,0
 2001      0000 
 2002               	.global	strKustom
 2005               	strKustom:
 2006 0960 00        		.byte	0
 2007 0961 00        		.byte	0
 2008 0962 00        		.byte	0
 2009 0963 00        		.byte	0
 2010 0964 00        		.byte	0
 2011 0965 00        		.byte	0
 2012 0966 00        		.byte	0
 2013 0967 00        		.byte	0
 2014 0968 00        		.byte	0
 2015 0969 00        		.byte	0
 2016 096a 00        		.byte	0
 2017 096b 00        		.byte	0
 2018 096c 00        		.byte	0
 2019 096d 00        		.byte	0
 2020 096e 00        		.byte	0
 2021 096f 00        		.byte	0
 2022 0970 00        		.byte	0
 2023 0971 00        		.byte	0
 2024 0972 00        		.byte	0
 2025 0973 00        		.byte	0
 2026 0974 00        		.byte	0
 2027 0975 00        		.byte	0
 2028 0976 00        		.byte	0
 2029 0977 00        		.byte	0
 2030 0978 00        		.byte	0
 2031 0979 00        		.byte	0
 2032 097a 00        		.byte	0
 2033 097b 00        		.byte	0
 2034 097c 00        		.byte	0
 2035 097d 00        		.byte	0
 2036 097e 00        		.byte	0
 2037 097f 00        		.byte	0
 2038 0980 C0        		.byte	-64
 2039 0981 F0        		.byte	-16
 2040 0982 F0        		.byte	-16
 2041 0983 F8        		.byte	-8
 2042 0984 F8        		.byte	-8
 2043 0985 78        		.byte	120
 2044 0986 3C        		.byte	60
 2045 0987 3C        		.byte	60
 2046 0988 1C        		.byte	28
 2047 0989 1C        		.byte	28
 2048 098a 1C        		.byte	28
 2049 098b 1C        		.byte	28
 2050 098c 1C        		.byte	28
 2051 098d 1C        		.byte	28
 2052 098e 18        		.byte	24
 2053 098f 38        		.byte	56
 2054 0990 38        		.byte	56
 2055 0991 78        		.byte	120
 2056 0992 78        		.byte	120
 2057 0993 70        		.byte	112
 2058 0994 70        		.byte	112
 2059 0995 F0        		.byte	-16
 2060 0996 E0        		.byte	-32
 2061 0997 E0        		.byte	-32
 2062 0998 E0        		.byte	-32
 2063 0999 C0        		.byte	-64
 2064 099a C0        		.byte	-64
 2065 099b 80        		.byte	-128
 2066 099c 80        		.byte	-128
 2067 099d 80        		.byte	-128
 2068 099e 00        		.byte	0
 2069 099f 00        		.byte	0
 2070 09a0 80        		.byte	-128
 2071 09a1 80        		.byte	-128
 2072 09a2 80        		.byte	-128
 2073 09a3 C0        		.byte	-64
 2074 09a4 C0        		.byte	-64
 2075 09a5 E0        		.byte	-32
 2076 09a6 E0        		.byte	-32
 2077 09a7 E0        		.byte	-32
 2078 09a8 F0        		.byte	-16
 2079 09a9 70        		.byte	112
 2080 09aa 70        		.byte	112
 2081 09ab 78        		.byte	120
 2082 09ac 78        		.byte	120
 2083 09ad 38        		.byte	56
 2084 09ae 38        		.byte	56
 2085 09af 38        		.byte	56
 2086 09b0 1C        		.byte	28
 2087 09b1 1C        		.byte	28
 2088 09b2 1C        		.byte	28
 2089 09b3 1C        		.byte	28
 2090 09b4 1C        		.byte	28
 2091 09b5 1C        		.byte	28
 2092 09b6 3C        		.byte	60
 2093 09b7 3C        		.byte	60
 2094 09b8 78        		.byte	120
 2095 09b9 78        		.byte	120
 2096 09ba F8        		.byte	-8
 2097 09bb F0        		.byte	-16
 2098 09bc E0        		.byte	-32
 2099 09bd C0        		.byte	-64
 2100 09be 80        		.byte	-128
 2101 09bf 00        		.byte	0
 2102 09c0 00        		.byte	0
 2103 09c1 00        		.byte	0
 2104 09c2 00        		.byte	0
 2105 09c3 00        		.byte	0
 2106 09c4 00        		.byte	0
 2107 09c5 00        		.byte	0
 2108 09c6 00        		.byte	0
 2109 09c7 00        		.byte	0
 2110 09c8 00        		.byte	0
 2111 09c9 00        		.byte	0
 2112 09ca 00        		.byte	0
 2113 09cb 00        		.byte	0
 2114 09cc 00        		.byte	0
 2115 09cd 00        		.byte	0
 2116 09ce 00        		.byte	0
 2117 09cf 00        		.byte	0
 2118 09d0 00        		.byte	0
 2119 09d1 00        		.byte	0
 2120 09d2 00        		.byte	0
 2121 09d3 00        		.byte	0
 2122 09d4 00        		.byte	0
 2123 09d5 00        		.byte	0
 2124 09d6 00        		.byte	0
 2125 09d7 00        		.byte	0
 2126 09d8 00        		.byte	0
 2127 09d9 00        		.byte	0
 2128 09da 00        		.byte	0
 2129 09db 00        		.byte	0
 2130 09dc 00        		.byte	0
 2131 09dd 00        		.byte	0
 2132 09de 00        		.byte	0
 2133 09df 00        		.byte	0
 2134 09e0 00        		.byte	0
 2135 09e1 00        		.byte	0
 2136 09e2 00        		.byte	0
 2137 09e3 00        		.byte	0
 2138 09e4 00        		.byte	0
 2139 09e5 00        		.byte	0
 2140 09e6 00        		.byte	0
 2141 09e7 00        		.byte	0
 2142 09e8 00        		.byte	0
 2143 09e9 00        		.byte	0
 2144 09ea 00        		.byte	0
 2145 09eb 00        		.byte	0
 2146 09ec 00        		.byte	0
 2147 09ed 00        		.byte	0
 2148 09ee 00        		.byte	0
 2149 09ef 00        		.byte	0
 2150 09f0 00        		.byte	0
 2151 09f1 00        		.byte	0
 2152 09f2 00        		.byte	0
 2153 09f3 00        		.byte	0
 2154 09f4 00        		.byte	0
 2155 09f5 00        		.byte	0
 2156 09f6 00        		.byte	0
 2157 09f7 00        		.byte	0
 2158 09f8 00        		.byte	0
 2159 09f9 00        		.byte	0
 2160 09fa 00        		.byte	0
 2161 09fb 00        		.byte	0
 2162 09fc 00        		.byte	0
 2163 09fd 00        		.byte	0
 2164 09fe FC        		.byte	-4
 2165 09ff FF        		.byte	-1
 2166 0a00 FF        		.byte	-1
 2167 0a01 FF        		.byte	-1
 2168 0a02 FF        		.byte	-1
 2169 0a03 01        		.byte	1
 2170 0a04 00        		.byte	0
 2171 0a05 00        		.byte	0
 2172 0a06 00        		.byte	0
 2173 0a07 00        		.byte	0
 2174 0a08 00        		.byte	0
 2175 0a09 00        		.byte	0
 2176 0a0a 00        		.byte	0
 2177 0a0b 00        		.byte	0
 2178 0a0c 00        		.byte	0
 2179 0a0d 00        		.byte	0
 2180 0a0e 00        		.byte	0
 2181 0a0f 00        		.byte	0
 2182 0a10 00        		.byte	0
 2183 0a11 00        		.byte	0
 2184 0a12 00        		.byte	0
 2185 0a13 00        		.byte	0
 2186 0a14 00        		.byte	0
 2187 0a15 80        		.byte	-128
 2188 0a16 C1        		.byte	-63
 2189 0a17 E1        		.byte	-31
 2190 0a18 E1        		.byte	-31
 2191 0a19 F3        		.byte	-13
 2192 0a1a F3        		.byte	-13
 2193 0a1b FF        		.byte	-1
 2194 0a1c 7F        		.byte	127
 2195 0a1d 7F        		.byte	127
 2196 0a1e 3F        		.byte	63
 2197 0a1f 3F        		.byte	63
 2198 0a20 7F        		.byte	127
 2199 0a21 7F        		.byte	127
 2200 0a22 FF        		.byte	-1
 2201 0a23 FB        		.byte	-5
 2202 0a24 F3        		.byte	-13
 2203 0a25 E1        		.byte	-31
 2204 0a26 E1        		.byte	-31
 2205 0a27 C1        		.byte	-63
 2206 0a28 80        		.byte	-128
 2207 0a29 00        		.byte	0
 2208 0a2a 00        		.byte	0
 2209 0a2b 00        		.byte	0
 2210 0a2c 00        		.byte	0
 2211 0a2d 00        		.byte	0
 2212 0a2e 00        		.byte	0
 2213 0a2f 00        		.byte	0
 2214 0a30 00        		.byte	0
 2215 0a31 00        		.byte	0
 2216 0a32 00        		.byte	0
 2217 0a33 00        		.byte	0
 2218 0a34 00        		.byte	0
 2219 0a35 00        		.byte	0
 2220 0a36 00        		.byte	0
 2221 0a37 00        		.byte	0
 2222 0a38 00        		.byte	0
 2223 0a39 00        		.byte	0
 2224 0a3a 01        		.byte	1
 2225 0a3b FF        		.byte	-1
 2226 0a3c FF        		.byte	-1
 2227 0a3d FF        		.byte	-1
 2228 0a3e FF        		.byte	-1
 2229 0a3f FE        		.byte	-2
 2230 0a40 00        		.byte	0
 2231 0a41 00        		.byte	0
 2232 0a42 00        		.byte	0
 2233 0a43 00        		.byte	0
 2234 0a44 00        		.byte	0
 2235 0a45 00        		.byte	0
 2236 0a46 00        		.byte	0
 2237 0a47 00        		.byte	0
 2238 0a48 00        		.byte	0
 2239 0a49 00        		.byte	0
 2240 0a4a 00        		.byte	0
 2241 0a4b 00        		.byte	0
 2242 0a4c 00        		.byte	0
 2243 0a4d 00        		.byte	0
 2244 0a4e 00        		.byte	0
 2245 0a4f 00        		.byte	0
 2246 0a50 00        		.byte	0
 2247 0a51 00        		.byte	0
 2248 0a52 00        		.byte	0
 2249 0a53 00        		.byte	0
 2250 0a54 00        		.byte	0
 2251 0a55 00        		.byte	0
 2252 0a56 00        		.byte	0
 2253 0a57 00        		.byte	0
 2254 0a58 00        		.byte	0
 2255 0a59 00        		.byte	0
 2256 0a5a 00        		.byte	0
 2257 0a5b 00        		.byte	0
 2258 0a5c 00        		.byte	0
 2259 0a5d 00        		.byte	0
 2260 0a5e 00        		.byte	0
 2261 0a5f 00        		.byte	0
 2262 0a60 00        		.byte	0
 2263 0a61 00        		.byte	0
 2264 0a62 00        		.byte	0
 2265 0a63 00        		.byte	0
 2266 0a64 00        		.byte	0
 2267 0a65 00        		.byte	0
 2268 0a66 00        		.byte	0
 2269 0a67 00        		.byte	0
 2270 0a68 00        		.byte	0
 2271 0a69 00        		.byte	0
 2272 0a6a 00        		.byte	0
 2273 0a6b 00        		.byte	0
 2274 0a6c 00        		.byte	0
 2275 0a6d 00        		.byte	0
 2276 0a6e 00        		.byte	0
 2277 0a6f 00        		.byte	0
 2278 0a70 00        		.byte	0
 2279 0a71 00        		.byte	0
 2280 0a72 00        		.byte	0
 2281 0a73 00        		.byte	0
 2282 0a74 80        		.byte	-128
 2283 0a75 80        		.byte	-128
 2284 0a76 80        		.byte	-128
 2285 0a77 C0        		.byte	-64
 2286 0a78 C0        		.byte	-64
 2287 0a79 C0        		.byte	-64
 2288 0a7a C0        		.byte	-64
 2289 0a7b E0        		.byte	-32
 2290 0a7c E0        		.byte	-32
 2291 0a7d E0        		.byte	-32
 2292 0a7e F0        		.byte	-16
 2293 0a7f F3        		.byte	-13
 2294 0a80 FF        		.byte	-1
 2295 0a81 FF        		.byte	-1
 2296 0a82 FF        		.byte	-1
 2297 0a83 FE        		.byte	-2
 2298 0a84 F8        		.byte	-8
 2299 0a85 F8        		.byte	-8
 2300 0a86 78        		.byte	120
 2301 0a87 78        		.byte	120
 2302 0a88 78        		.byte	120
 2303 0a89 38        		.byte	56
 2304 0a8a 38        		.byte	56
 2305 0a8b 3C        		.byte	60
 2306 0a8c BC        		.byte	-68
 2307 0a8d 9C        		.byte	-100
 2308 0a8e FC        		.byte	-4
 2309 0a8f FC        		.byte	-4
 2310 0a90 FC        		.byte	-4
 2311 0a91 FC        		.byte	-4
 2312 0a92 FC        		.byte	-4
 2313 0a93 7E        		.byte	126
 2314 0a94 3F        		.byte	63
 2315 0a95 1F        		.byte	31
 2316 0a96 1F        		.byte	31
 2317 0a97 1F        		.byte	31
 2318 0a98 1F        		.byte	31
 2319 0a99 1F        		.byte	31
 2320 0a9a 1C        		.byte	28
 2321 0a9b 1C        		.byte	28
 2322 0a9c 1E        		.byte	30
 2323 0a9d 1E        		.byte	30
 2324 0a9e 1E        		.byte	30
 2325 0a9f 1E        		.byte	30
 2326 0aa0 1E        		.byte	30
 2327 0aa1 1E        		.byte	30
 2328 0aa2 1E        		.byte	30
 2329 0aa3 1C        		.byte	28
 2330 0aa4 1F        		.byte	31
 2331 0aa5 1F        		.byte	31
 2332 0aa6 1F        		.byte	31
 2333 0aa7 1F        		.byte	31
 2334 0aa8 3F        		.byte	63
 2335 0aa9 3F        		.byte	63
 2336 0aaa 7E        		.byte	126
 2337 0aab FE        		.byte	-2
 2338 0aac FC        		.byte	-4
 2339 0aad FC        		.byte	-4
 2340 0aae FC        		.byte	-4
 2341 0aaf FC        		.byte	-4
 2342 0ab0 FC        		.byte	-4
 2343 0ab1 BC        		.byte	-68
 2344 0ab2 3C        		.byte	60
 2345 0ab3 38        		.byte	56
 2346 0ab4 38        		.byte	56
 2347 0ab5 78        		.byte	120
 2348 0ab6 78        		.byte	120
 2349 0ab7 78        		.byte	120
 2350 0ab8 F8        		.byte	-8
 2351 0ab9 F8        		.byte	-8
 2352 0aba FC        		.byte	-4
 2353 0abb FF        		.byte	-1
 2354 0abc FF        		.byte	-1
 2355 0abd 7F        		.byte	127
 2356 0abe E7        		.byte	-25
 2357 0abf F1        		.byte	-15
 2358 0ac0 E0        		.byte	-32
 2359 0ac1 E0        		.byte	-32
 2360 0ac2 E0        		.byte	-32
 2361 0ac3 C0        		.byte	-64
 2362 0ac4 C0        		.byte	-64
 2363 0ac5 C0        		.byte	-64
 2364 0ac6 80        		.byte	-128
 2365 0ac7 80        		.byte	-128
 2366 0ac8 80        		.byte	-128
 2367 0ac9 80        		.byte	-128
 2368 0aca 80        		.byte	-128
 2369 0acb 00        		.byte	0
 2370 0acc 00        		.byte	0
 2371 0acd 00        		.byte	0
 2372 0ace 00        		.byte	0
 2373 0acf 00        		.byte	0
 2374 0ad0 00        		.byte	0
 2375 0ad1 00        		.byte	0
 2376 0ad2 00        		.byte	0
 2377 0ad3 00        		.byte	0
 2378 0ad4 00        		.byte	0
 2379 0ad5 00        		.byte	0
 2380 0ad6 00        		.byte	0
 2381 0ad7 00        		.byte	0
 2382 0ad8 00        		.byte	0
 2383 0ad9 00        		.byte	0
 2384 0ada 00        		.byte	0
 2385 0adb 00        		.byte	0
 2386 0adc 00        		.byte	0
 2387 0add 00        		.byte	0
 2388 0ade 00        		.byte	0
 2389 0adf 00        		.byte	0
 2390 0ae0 00        		.byte	0
 2391 0ae1 00        		.byte	0
 2392 0ae2 00        		.byte	0
 2393 0ae3 00        		.byte	0
 2394 0ae4 00        		.byte	0
 2395 0ae5 00        		.byte	0
 2396 0ae6 00        		.byte	0
 2397 0ae7 00        		.byte	0
 2398 0ae8 00        		.byte	0
 2399 0ae9 00        		.byte	0
 2400 0aea 80        		.byte	-128
 2401 0aeb E0        		.byte	-32
 2402 0aec E0        		.byte	-32
 2403 0aed F0        		.byte	-16
 2404 0aee FC        		.byte	-4
 2405 0aef FE        		.byte	-2
 2406 0af0 3E        		.byte	62
 2407 0af1 3E        		.byte	62
 2408 0af2 1F        		.byte	31
 2409 0af3 0F        		.byte	15
 2410 0af4 0F        		.byte	15
 2411 0af5 07        		.byte	7
 2412 0af6 07        		.byte	7
 2413 0af7 03        		.byte	3
 2414 0af8 01        		.byte	1
 2415 0af9 01        		.byte	1
 2416 0afa 01        		.byte	1
 2417 0afb 01        		.byte	1
 2418 0afc 00        		.byte	0
 2419 0afd 00        		.byte	0
 2420 0afe 00        		.byte	0
 2421 0aff 00        		.byte	0
 2422 0b00 00        		.byte	0
 2423 0b01 01        		.byte	1
 2424 0b02 0F        		.byte	15
 2425 0b03 3F        		.byte	63
 2426 0b04 3F        		.byte	63
 2427 0b05 FF        		.byte	-1
 2428 0b06 FF        		.byte	-1
 2429 0b07 FE        		.byte	-2
 2430 0b08 F8        		.byte	-8
 2431 0b09 F8        		.byte	-8
 2432 0b0a FC        		.byte	-4
 2433 0b0b FF        		.byte	-1
 2434 0b0c 7F        		.byte	127
 2435 0b0d 3F        		.byte	63
 2436 0b0e 0F        		.byte	15
 2437 0b0f 0F        		.byte	15
 2438 0b10 03        		.byte	3
 2439 0b11 01        		.byte	1
 2440 0b12 00        		.byte	0
 2441 0b13 C0        		.byte	-64
 2442 0b14 F0        		.byte	-16
 2443 0b15 FC        		.byte	-4
 2444 0b16 FE        		.byte	-2
 2445 0b17 FE        		.byte	-2
 2446 0b18 FE        		.byte	-2
 2447 0b19 FF        		.byte	-1
 2448 0b1a FF        		.byte	-1
 2449 0b1b FF        		.byte	-1
 2450 0b1c FF        		.byte	-1
 2451 0b1d FF        		.byte	-1
 2452 0b1e FF        		.byte	-1
 2453 0b1f FF        		.byte	-1
 2454 0b20 FF        		.byte	-1
 2455 0b21 FF        		.byte	-1
 2456 0b22 FF        		.byte	-1
 2457 0b23 FF        		.byte	-1
 2458 0b24 FF        		.byte	-1
 2459 0b25 FE        		.byte	-2
 2460 0b26 FE        		.byte	-2
 2461 0b27 FE        		.byte	-2
 2462 0b28 FC        		.byte	-4
 2463 0b29 F0        		.byte	-16
 2464 0b2a E0        		.byte	-32
 2465 0b2b 00        		.byte	0
 2466 0b2c 00        		.byte	0
 2467 0b2d 03        		.byte	3
 2468 0b2e 07        		.byte	7
 2469 0b2f 0F        		.byte	15
 2470 0b30 3F        		.byte	63
 2471 0b31 7F        		.byte	127
 2472 0b32 FE        		.byte	-2
 2473 0b33 FC        		.byte	-4
 2474 0b34 F8        		.byte	-8
 2475 0b35 F0        		.byte	-16
 2476 0b36 FE        		.byte	-2
 2477 0b37 FF        		.byte	-1
 2478 0b38 FF        		.byte	-1
 2479 0b39 3F        		.byte	63
 2480 0b3a 3F        		.byte	63
 2481 0b3b 0F        		.byte	15
 2482 0b3c 01        		.byte	1
 2483 0b3d 00        		.byte	0
 2484 0b3e 00        		.byte	0
 2485 0b3f 00        		.byte	0
 2486 0b40 00        		.byte	0
 2487 0b41 00        		.byte	0
 2488 0b42 00        		.byte	0
 2489 0b43 01        		.byte	1
 2490 0b44 01        		.byte	1
 2491 0b45 03        		.byte	3
 2492 0b46 03        		.byte	3
 2493 0b47 03        		.byte	3
 2494 0b48 07        		.byte	7
 2495 0b49 0F        		.byte	15
 2496 0b4a 0F        		.byte	15
 2497 0b4b 1F        		.byte	31
 2498 0b4c 1F        		.byte	31
 2499 0b4d 3E        		.byte	62
 2500 0b4e FE        		.byte	-2
 2501 0b4f FC        		.byte	-4
 2502 0b50 F0        		.byte	-16
 2503 0b51 E0        		.byte	-32
 2504 0b52 E0        		.byte	-32
 2505 0b53 C0        		.byte	-64
 2506 0b54 00        		.byte	0
 2507 0b55 00        		.byte	0
 2508 0b56 00        		.byte	0
 2509 0b57 00        		.byte	0
 2510 0b58 00        		.byte	0
 2511 0b59 00        		.byte	0
 2512 0b5a 00        		.byte	0
 2513 0b5b 00        		.byte	0
 2514 0b5c 00        		.byte	0
 2515 0b5d 00        		.byte	0
 2516 0b5e 00        		.byte	0
 2517 0b5f 00        		.byte	0
 2518 0b60 00        		.byte	0
 2519 0b61 00        		.byte	0
 2520 0b62 00        		.byte	0
 2521 0b63 00        		.byte	0
 2522 0b64 00        		.byte	0
 2523 0b65 00        		.byte	0
 2524 0b66 00        		.byte	0
 2525 0b67 00        		.byte	0
 2526 0b68 00        		.byte	0
 2527 0b69 00        		.byte	0
 2528 0b6a 01        		.byte	1
 2529 0b6b 07        		.byte	7
 2530 0b6c 07        		.byte	7
 2531 0b6d 0F        		.byte	15
 2532 0b6e 1F        		.byte	31
 2533 0b6f 3F        		.byte	63
 2534 0b70 7C        		.byte	124
 2535 0b71 78        		.byte	120
 2536 0b72 F8        		.byte	-8
 2537 0b73 F0        		.byte	-16
 2538 0b74 F0        		.byte	-16
 2539 0b75 E0        		.byte	-32
 2540 0b76 E0        		.byte	-32
 2541 0b77 E0        		.byte	-32
 2542 0b78 C0        		.byte	-64
 2543 0b79 80        		.byte	-128
 2544 0b7a 80        		.byte	-128
 2545 0b7b 80        		.byte	-128
 2546 0b7c 80        		.byte	-128
 2547 0b7d 00        		.byte	0
 2548 0b7e 00        		.byte	0
 2549 0b7f 00        		.byte	0
 2550 0b80 00        		.byte	0
 2551 0b81 80        		.byte	-128
 2552 0b82 F0        		.byte	-16
 2553 0b83 F8        		.byte	-8
 2554 0b84 FE        		.byte	-2
 2555 0b85 FF        		.byte	-1
 2556 0b86 FF        		.byte	-1
 2557 0b87 7F        		.byte	127
 2558 0b88 1F        		.byte	31
 2559 0b89 1F        		.byte	31
 2560 0b8a 1F        		.byte	31
 2561 0b8b FF        		.byte	-1
 2562 0b8c FE        		.byte	-2
 2563 0b8d F8        		.byte	-8
 2564 0b8e F0        		.byte	-16
 2565 0b8f F0        		.byte	-16
 2566 0b90 E0        		.byte	-32
 2567 0b91 80        		.byte	-128
 2568 0b92 00        		.byte	0
 2569 0b93 07        		.byte	7
 2570 0b94 0F        		.byte	15
 2571 0b95 1F        		.byte	31
 2572 0b96 3F        		.byte	63
 2573 0b97 3F        		.byte	63
 2574 0b98 7F        		.byte	127
 2575 0b99 7F        		.byte	127
 2576 0b9a 7F        		.byte	127
 2577 0b9b 7F        		.byte	127
 2578 0b9c FF        		.byte	-1
 2579 0b9d FF        		.byte	-1
 2580 0b9e FF        		.byte	-1
 2581 0b9f FF        		.byte	-1
 2582 0ba0 FF        		.byte	-1
 2583 0ba1 FF        		.byte	-1
 2584 0ba2 FF        		.byte	-1
 2585 0ba3 7F        		.byte	127
 2586 0ba4 7F        		.byte	127
 2587 0ba5 7F        		.byte	127
 2588 0ba6 7F        		.byte	127
 2589 0ba7 3F        		.byte	63
 2590 0ba8 1F        		.byte	31
 2591 0ba9 0F        		.byte	15
 2592 0baa 07        		.byte	7
 2593 0bab 00        		.byte	0
 2594 0bac 80        		.byte	-128
 2595 0bad C0        		.byte	-64
 2596 0bae E0        		.byte	-32
 2597 0baf F0        		.byte	-16
 2598 0bb0 F8        		.byte	-8
 2599 0bb1 FE        		.byte	-2
 2600 0bb2 7F        		.byte	127
 2601 0bb3 1F        		.byte	31
 2602 0bb4 1F        		.byte	31
 2603 0bb5 0F        		.byte	15
 2604 0bb6 3F        		.byte	63
 2605 0bb7 7F        		.byte	127
 2606 0bb8 FF        		.byte	-1
 2607 0bb9 FE        		.byte	-2
 2608 0bba FC        		.byte	-4
 2609 0bbb F0        		.byte	-16
 2610 0bbc 80        		.byte	-128
 2611 0bbd 00        		.byte	0
 2612 0bbe 00        		.byte	0
 2613 0bbf 00        		.byte	0
 2614 0bc0 00        		.byte	0
 2615 0bc1 80        		.byte	-128
 2616 0bc2 80        		.byte	-128
 2617 0bc3 80        		.byte	-128
 2618 0bc4 80        		.byte	-128
 2619 0bc5 C0        		.byte	-64
 2620 0bc6 E0        		.byte	-32
 2621 0bc7 E0        		.byte	-32
 2622 0bc8 E0        		.byte	-32
 2623 0bc9 F0        		.byte	-16
 2624 0bca F0        		.byte	-16
 2625 0bcb F8        		.byte	-8
 2626 0bcc 78        		.byte	120
 2627 0bcd 7C        		.byte	124
 2628 0bce 3F        		.byte	63
 2629 0bcf 1F        		.byte	31
 2630 0bd0 0F        		.byte	15
 2631 0bd1 0F        		.byte	15
 2632 0bd2 07        		.byte	7
 2633 0bd3 03        		.byte	3
 2634 0bd4 00        		.byte	0
 2635 0bd5 00        		.byte	0
 2636 0bd6 00        		.byte	0
 2637 0bd7 00        		.byte	0
 2638 0bd8 00        		.byte	0
 2639 0bd9 00        		.byte	0
 2640 0bda 00        		.byte	0
 2641 0bdb 00        		.byte	0
 2642 0bdc 00        		.byte	0
 2643 0bdd 00        		.byte	0
 2644 0bde 00        		.byte	0
 2645 0bdf 00        		.byte	0
 2646 0be0 00        		.byte	0
 2647 0be1 00        		.byte	0
 2648 0be2 00        		.byte	0
 2649 0be3 00        		.byte	0
 2650 0be4 00        		.byte	0
 2651 0be5 00        		.byte	0
 2652 0be6 00        		.byte	0
 2653 0be7 00        		.byte	0
 2654 0be8 00        		.byte	0
 2655 0be9 00        		.byte	0
 2656 0bea 00        		.byte	0
 2657 0beb 00        		.byte	0
 2658 0bec 00        		.byte	0
 2659 0bed 00        		.byte	0
 2660 0bee 00        		.byte	0
 2661 0bef 00        		.byte	0
 2662 0bf0 00        		.byte	0
 2663 0bf1 00        		.byte	0
 2664 0bf2 00        		.byte	0
 2665 0bf3 00        		.byte	0
 2666 0bf4 01        		.byte	1
 2667 0bf5 01        		.byte	1
 2668 0bf6 01        		.byte	1
 2669 0bf7 03        		.byte	3
 2670 0bf8 03        		.byte	3
 2671 0bf9 03        		.byte	3
 2672 0bfa 03        		.byte	3
 2673 0bfb 07        		.byte	7
 2674 0bfc 07        		.byte	7
 2675 0bfd 0F        		.byte	15
 2676 0bfe 0F        		.byte	15
 2677 0bff CF        		.byte	-49
 2678 0c00 FE        		.byte	-2
 2679 0c01 FF        		.byte	-1
 2680 0c02 FF        		.byte	-1
 2681 0c03 7F        		.byte	127
 2682 0c04 1F        		.byte	31
 2683 0c05 1F        		.byte	31
 2684 0c06 1C        		.byte	28
 2685 0c07 1C        		.byte	28
 2686 0c08 1C        		.byte	28
 2687 0c09 1C        		.byte	28
 2688 0c0a 1C        		.byte	28
 2689 0c0b 3C        		.byte	60
 2690 0c0c 3D        		.byte	61
 2691 0c0d 39        		.byte	57
 2692 0c0e 3F        		.byte	63
 2693 0c0f 3F        		.byte	63
 2694 0c10 3F        		.byte	63
 2695 0c11 3F        		.byte	63
 2696 0c12 3F        		.byte	63
 2697 0c13 7E        		.byte	126
 2698 0c14 FC        		.byte	-4
 2699 0c15 F8        		.byte	-8
 2700 0c16 F8        		.byte	-8
 2701 0c17 F8        		.byte	-8
 2702 0c18 F8        		.byte	-8
 2703 0c19 B8        		.byte	-72
 2704 0c1a B8        		.byte	-72
 2705 0c1b 38        		.byte	56
 2706 0c1c 38        		.byte	56
 2707 0c1d 38        		.byte	56
 2708 0c1e 38        		.byte	56
 2709 0c1f 38        		.byte	56
 2710 0c20 38        		.byte	56
 2711 0c21 38        		.byte	56
 2712 0c22 38        		.byte	56
 2713 0c23 B8        		.byte	-72
 2714 0c24 B8        		.byte	-72
 2715 0c25 F8        		.byte	-8
 2716 0c26 F8        		.byte	-8
 2717 0c27 F8        		.byte	-8
 2718 0c28 FC        		.byte	-4
 2719 0c29 FC        		.byte	-4
 2720 0c2a 7E        		.byte	126
 2721 0c2b 3F        		.byte	63
 2722 0c2c 3F        		.byte	63
 2723 0c2d 3F        		.byte	63
 2724 0c2e 3F        		.byte	63
 2725 0c2f 3F        		.byte	63
 2726 0c30 3F        		.byte	63
 2727 0c31 3D        		.byte	61
 2728 0c32 3C        		.byte	60
 2729 0c33 1C        		.byte	28
 2730 0c34 1C        		.byte	28
 2731 0c35 1C        		.byte	28
 2732 0c36 1C        		.byte	28
 2733 0c37 1C        		.byte	28
 2734 0c38 1F        		.byte	31
 2735 0c39 1F        		.byte	31
 2736 0c3a 3F        		.byte	63
 2737 0c3b FF        		.byte	-1
 2738 0c3c FF        		.byte	-1
 2739 0c3d FE        		.byte	-2
 2740 0c3e E7        		.byte	-25
 2741 0c3f 8F        		.byte	-113
 2742 0c40 0F        		.byte	15
 2743 0c41 07        		.byte	7
 2744 0c42 07        		.byte	7
 2745 0c43 03        		.byte	3
 2746 0c44 03        		.byte	3
 2747 0c45 03        		.byte	3
 2748 0c46 03        		.byte	3
 2749 0c47 01        		.byte	1
 2750 0c48 01        		.byte	1
 2751 0c49 01        		.byte	1
 2752 0c4a 00        		.byte	0
 2753 0c4b 00        		.byte	0
 2754 0c4c 00        		.byte	0
 2755 0c4d 00        		.byte	0
 2756 0c4e 00        		.byte	0
 2757 0c4f 00        		.byte	0
 2758 0c50 00        		.byte	0
 2759 0c51 00        		.byte	0
 2760 0c52 00        		.byte	0
 2761 0c53 00        		.byte	0
 2762 0c54 00        		.byte	0
 2763 0c55 00        		.byte	0
 2764 0c56 00        		.byte	0
 2765 0c57 00        		.byte	0
 2766 0c58 00        		.byte	0
 2767 0c59 00        		.byte	0
 2768 0c5a 00        		.byte	0
 2769 0c5b 00        		.byte	0
 2770 0c5c 00        		.byte	0
 2771 0c5d 00        		.byte	0
 2772 0c5e 00        		.byte	0
 2773 0c5f 00        		.byte	0
 2774 0c60 00        		.byte	0
 2775 0c61 00        		.byte	0
 2776 0c62 00        		.byte	0
 2777 0c63 00        		.byte	0
 2778 0c64 00        		.byte	0
 2779 0c65 00        		.byte	0
 2780 0c66 00        		.byte	0
 2781 0c67 00        		.byte	0
 2782 0c68 00        		.byte	0
 2783 0c69 00        		.byte	0
 2784 0c6a 00        		.byte	0
 2785 0c6b 00        		.byte	0
 2786 0c6c 00        		.byte	0
 2787 0c6d 00        		.byte	0
 2788 0c6e 00        		.byte	0
 2789 0c6f 00        		.byte	0
 2790 0c70 00        		.byte	0
 2791 0c71 00        		.byte	0
 2792 0c72 00        		.byte	0
 2793 0c73 00        		.byte	0
 2794 0c74 00        		.byte	0
 2795 0c75 00        		.byte	0
 2796 0c76 00        		.byte	0
 2797 0c77 00        		.byte	0
 2798 0c78 00        		.byte	0
 2799 0c79 00        		.byte	0
 2800 0c7a 00        		.byte	0
 2801 0c7b 00        		.byte	0
 2802 0c7c 00        		.byte	0
 2803 0c7d 00        		.byte	0
 2804 0c7e 1E        		.byte	30
 2805 0c7f 7F        		.byte	127
 2806 0c80 FF        		.byte	-1
 2807 0c81 FF        		.byte	-1
 2808 0c82 FF        		.byte	-1
 2809 0c83 80        		.byte	-128
 2810 0c84 80        		.byte	-128
 2811 0c85 00        		.byte	0
 2812 0c86 00        		.byte	0
 2813 0c87 00        		.byte	0
 2814 0c88 00        		.byte	0
 2815 0c89 00        		.byte	0
 2816 0c8a 00        		.byte	0
 2817 0c8b 00        		.byte	0
 2818 0c8c 00        		.byte	0
 2819 0c8d 00        		.byte	0
 2820 0c8e 00        		.byte	0
 2821 0c8f 00        		.byte	0
 2822 0c90 00        		.byte	0
 2823 0c91 00        		.byte	0
 2824 0c92 00        		.byte	0
 2825 0c93 00        		.byte	0
 2826 0c94 00        		.byte	0
 2827 0c95 81        		.byte	-127
 2828 0c96 83        		.byte	-125
 2829 0c97 83        		.byte	-125
 2830 0c98 C7        		.byte	-57
 2831 0c99 CF        		.byte	-49
 2832 0c9a CF        		.byte	-49
 2833 0c9b FF        		.byte	-1
 2834 0c9c FE        		.byte	-2
 2835 0c9d FE        		.byte	-2
 2836 0c9e 7C        		.byte	124
 2837 0c9f 7C        		.byte	124
 2838 0ca0 FE        		.byte	-2
 2839 0ca1 FE        		.byte	-2
 2840 0ca2 FF        		.byte	-1
 2841 0ca3 CF        		.byte	-49
 2842 0ca4 CF        		.byte	-49
 2843 0ca5 C7        		.byte	-57
 2844 0ca6 83        		.byte	-125
 2845 0ca7 83        		.byte	-125
 2846 0ca8 81        		.byte	-127
 2847 0ca9 00        		.byte	0
 2848 0caa 00        		.byte	0
 2849 0cab 00        		.byte	0
 2850 0cac 00        		.byte	0
 2851 0cad 00        		.byte	0
 2852 0cae 00        		.byte	0
 2853 0caf 00        		.byte	0
 2854 0cb0 00        		.byte	0
 2855 0cb1 00        		.byte	0
 2856 0cb2 00        		.byte	0
 2857 0cb3 00        		.byte	0
 2858 0cb4 00        		.byte	0
 2859 0cb5 00        		.byte	0
 2860 0cb6 00        		.byte	0
 2861 0cb7 00        		.byte	0
 2862 0cb8 00        		.byte	0
 2863 0cb9 00        		.byte	0
 2864 0cba 80        		.byte	-128
 2865 0cbb FF        		.byte	-1
 2866 0cbc FF        		.byte	-1
 2867 0cbd FF        		.byte	-1
 2868 0cbe FF        		.byte	-1
 2869 0cbf 3F        		.byte	63
 2870 0cc0 00        		.byte	0
 2871 0cc1 00        		.byte	0
 2872 0cc2 00        		.byte	0
 2873 0cc3 00        		.byte	0
 2874 0cc4 00        		.byte	0
 2875 0cc5 00        		.byte	0
 2876 0cc6 00        		.byte	0
 2877 0cc7 00        		.byte	0
 2878 0cc8 00        		.byte	0
 2879 0cc9 00        		.byte	0
 2880 0cca 00        		.byte	0
 2881 0ccb 00        		.byte	0
 2882 0ccc 00        		.byte	0
 2883 0ccd 00        		.byte	0
 2884 0cce 00        		.byte	0
 2885 0ccf 00        		.byte	0
 2886 0cd0 00        		.byte	0
 2887 0cd1 00        		.byte	0
 2888 0cd2 00        		.byte	0
 2889 0cd3 00        		.byte	0
 2890 0cd4 00        		.byte	0
 2891 0cd5 00        		.byte	0
 2892 0cd6 00        		.byte	0
 2893 0cd7 00        		.byte	0
 2894 0cd8 00        		.byte	0
 2895 0cd9 00        		.byte	0
 2896 0cda 00        		.byte	0
 2897 0cdb 00        		.byte	0
 2898 0cdc 00        		.byte	0
 2899 0cdd 00        		.byte	0
 2900 0cde 00        		.byte	0
 2901 0cdf 00        		.byte	0
 2902 0ce0 00        		.byte	0
 2903 0ce1 00        		.byte	0
 2904 0ce2 00        		.byte	0
 2905 0ce3 00        		.byte	0
 2906 0ce4 00        		.byte	0
 2907 0ce5 00        		.byte	0
 2908 0ce6 00        		.byte	0
 2909 0ce7 00        		.byte	0
 2910 0ce8 00        		.byte	0
 2911 0ce9 00        		.byte	0
 2912 0cea 00        		.byte	0
 2913 0ceb 00        		.byte	0
 2914 0cec 00        		.byte	0
 2915 0ced 00        		.byte	0
 2916 0cee 00        		.byte	0
 2917 0cef 00        		.byte	0
 2918 0cf0 00        		.byte	0
 2919 0cf1 00        		.byte	0
 2920 0cf2 00        		.byte	0
 2921 0cf3 00        		.byte	0
 2922 0cf4 00        		.byte	0
 2923 0cf5 00        		.byte	0
 2924 0cf6 00        		.byte	0
 2925 0cf7 00        		.byte	0
 2926 0cf8 00        		.byte	0
 2927 0cf9 00        		.byte	0
 2928 0cfa 00        		.byte	0
 2929 0cfb 00        		.byte	0
 2930 0cfc 00        		.byte	0
 2931 0cfd 00        		.byte	0
 2932 0cfe 00        		.byte	0
 2933 0cff 00        		.byte	0
 2934 0d00 03        		.byte	3
 2935 0d01 07        		.byte	7
 2936 0d02 0F        		.byte	15
 2937 0d03 0F        		.byte	15
 2938 0d04 1F        		.byte	31
 2939 0d05 1E        		.byte	30
 2940 0d06 1C        		.byte	28
 2941 0d07 3C        		.byte	60
 2942 0d08 3C        		.byte	60
 2943 0d09 38        		.byte	56
 2944 0d0a 38        		.byte	56
 2945 0d0b 38        		.byte	56
 2946 0d0c 38        		.byte	56
 2947 0d0d 3C        		.byte	60
 2948 0d0e 3C        		.byte	60
 2949 0d0f 1C        		.byte	28
 2950 0d10 1C        		.byte	28
 2951 0d11 1E        		.byte	30
 2952 0d12 1E        		.byte	30
 2953 0d13 1E        		.byte	30
 2954 0d14 1F        		.byte	31
 2955 0d15 07        		.byte	7
 2956 0d16 07        		.byte	7
 2957 0d17 07        		.byte	7
 2958 0d18 07        		.byte	7
 2959 0d19 03        		.byte	3
 2960 0d1a 03        		.byte	3
 2961 0d1b 01        		.byte	1
 2962 0d1c 01        		.byte	1
 2963 0d1d 00        		.byte	0
 2964 0d1e 00        		.byte	0
 2965 0d1f 00        		.byte	0
 2966 0d20 00        		.byte	0
 2967 0d21 01        		.byte	1
 2968 0d22 01        		.byte	1
 2969 0d23 03        		.byte	3
 2970 0d24 03        		.byte	3
 2971 0d25 07        		.byte	7
 2972 0d26 07        		.byte	7
 2973 0d27 07        		.byte	7
 2974 0d28 1F        		.byte	31
 2975 0d29 1F        		.byte	31
 2976 0d2a 3E        		.byte	62
 2977 0d2b 3E        		.byte	62
 2978 0d2c 3E        		.byte	62
 2979 0d2d 7C        		.byte	124
 2980 0d2e 7C        		.byte	124
 2981 0d2f 7C        		.byte	124
 2982 0d30 7C        		.byte	124
 2983 0d31 7C        		.byte	124
 2984 0d32 78        		.byte	120
 2985 0d33 78        		.byte	120
 2986 0d34 78        		.byte	120
 2987 0d35 3C        		.byte	60
 2988 0d36 3C        		.byte	60
 2989 0d37 3C        		.byte	60
 2990 0d38 3E        		.byte	62
 2991 0d39 3F        		.byte	63
 2992 0d3a 3F        		.byte	63
 2993 0d3b 1F        		.byte	31
 2994 0d3c 07        		.byte	7
 2995 0d3d 03        		.byte	3
 2996 0d3e 00        		.byte	0
 2997 0d3f 00        		.byte	0
 2998 0d40 00        		.byte	0
 2999 0d41 00        		.byte	0
 3000 0d42 00        		.byte	0
 3001 0d43 00        		.byte	0
 3002 0d44 00        		.byte	0
 3003 0d45 00        		.byte	0
 3004 0d46 00        		.byte	0
 3005 0d47 00        		.byte	0
 3006 0d48 00        		.byte	0
 3007 0d49 00        		.byte	0
 3008 0d4a 00        		.byte	0
 3009 0d4b 00        		.byte	0
 3010 0d4c 00        		.byte	0
 3011 0d4d 00        		.byte	0
 3012 0d4e 00        		.byte	0
 3013 0d4f 00        		.byte	0
 3014 0d50 00        		.byte	0
 3015 0d51 00        		.byte	0
 3016 0d52 00        		.byte	0
 3017 0d53 00        		.byte	0
 3018 0d54 00        		.byte	0
 3019 0d55 00        		.byte	0
 3020 0d56 00        		.byte	0
 3021 0d57 00        		.byte	0
 3022 0d58 00        		.byte	0
 3023 0d59 00        		.byte	0
 3024 0d5a 00        		.byte	0
 3025 0d5b 00        		.byte	0
 3026 0d5c 00        		.byte	0
 3027 0d5d 00        		.byte	0
 3028 0d5e 00        		.byte	0
 3029 0d5f 00        		.byte	0
 3030               	.global	strStop
 3033               	strStop:
 3034 0d60 00        		.byte	0
 3035 0d61 00        		.byte	0
 3036 0d62 00        		.byte	0
 3037 0d63 00        		.byte	0
 3038 0d64 00        		.byte	0
 3039 0d65 00        		.byte	0
 3040 0d66 00        		.byte	0
 3041 0d67 00        		.byte	0
 3042 0d68 00        		.byte	0
 3043 0d69 00        		.byte	0
 3044 0d6a 00        		.byte	0
 3045 0d6b 00        		.byte	0
 3046 0d6c 00        		.byte	0
 3047 0d6d 00        		.byte	0
 3048 0d6e 00        		.byte	0
 3049 0d6f 00        		.byte	0
 3050 0d70 00        		.byte	0
 3051 0d71 00        		.byte	0
 3052 0d72 00        		.byte	0
 3053 0d73 00        		.byte	0
 3054 0d74 00        		.byte	0
 3055 0d75 00        		.byte	0
 3056 0d76 00        		.byte	0
 3057 0d77 00        		.byte	0
 3058 0d78 00        		.byte	0
 3059 0d79 00        		.byte	0
 3060 0d7a 00        		.byte	0
 3061 0d7b 00        		.byte	0
 3062 0d7c 00        		.byte	0
 3063 0d7d 00        		.byte	0
 3064 0d7e 00        		.byte	0
 3065 0d7f 00        		.byte	0
 3066 0d80 00        		.byte	0
 3067 0d81 00        		.byte	0
 3068 0d82 00        		.byte	0
 3069 0d83 00        		.byte	0
 3070 0d84 00        		.byte	0
 3071 0d85 00        		.byte	0
 3072 0d86 00        		.byte	0
 3073 0d87 00        		.byte	0
 3074 0d88 00        		.byte	0
 3075 0d89 00        		.byte	0
 3076 0d8a 00        		.byte	0
 3077 0d8b 00        		.byte	0
 3078 0d8c 00        		.byte	0
 3079 0d8d 00        		.byte	0
 3080 0d8e 00        		.byte	0
 3081 0d8f 00        		.byte	0
 3082 0d90 00        		.byte	0
 3083 0d91 00        		.byte	0
 3084 0d92 00        		.byte	0
 3085 0d93 00        		.byte	0
 3086 0d94 00        		.byte	0
 3087 0d95 00        		.byte	0
 3088 0d96 00        		.byte	0
 3089 0d97 00        		.byte	0
 3090 0d98 00        		.byte	0
 3091 0d99 00        		.byte	0
 3092 0d9a 00        		.byte	0
 3093 0d9b 00        		.byte	0
 3094 0d9c 00        		.byte	0
 3095 0d9d 00        		.byte	0
 3096 0d9e 00        		.byte	0
 3097 0d9f 00        		.byte	0
 3098 0da0 00        		.byte	0
 3099 0da1 00        		.byte	0
 3100 0da2 00        		.byte	0
 3101 0da3 00        		.byte	0
 3102 0da4 00        		.byte	0
 3103 0da5 00        		.byte	0
 3104 0da6 00        		.byte	0
 3105 0da7 00        		.byte	0
 3106 0da8 00        		.byte	0
 3107 0da9 00        		.byte	0
 3108 0daa 00        		.byte	0
 3109 0dab 00        		.byte	0
 3110 0dac 00        		.byte	0
 3111 0dad 00        		.byte	0
 3112 0dae 00        		.byte	0
 3113 0daf 00        		.byte	0
 3114 0db0 00        		.byte	0
 3115 0db1 00        		.byte	0
 3116 0db2 00        		.byte	0
 3117 0db3 00        		.byte	0
 3118 0db4 00        		.byte	0
 3119 0db5 00        		.byte	0
 3120 0db6 00        		.byte	0
 3121 0db7 00        		.byte	0
 3122 0db8 00        		.byte	0
 3123 0db9 00        		.byte	0
 3124 0dba 00        		.byte	0
 3125 0dbb 00        		.byte	0
 3126 0dbc 00        		.byte	0
 3127 0dbd 00        		.byte	0
 3128 0dbe 00        		.byte	0
 3129 0dbf 00        		.byte	0
 3130 0dc0 00        		.byte	0
 3131 0dc1 00        		.byte	0
 3132 0dc2 00        		.byte	0
 3133 0dc3 00        		.byte	0
 3134 0dc4 00        		.byte	0
 3135 0dc5 00        		.byte	0
 3136 0dc6 00        		.byte	0
 3137 0dc7 00        		.byte	0
 3138 0dc8 00        		.byte	0
 3139 0dc9 00        		.byte	0
 3140 0dca 00        		.byte	0
 3141 0dcb 00        		.byte	0
 3142 0dcc 00        		.byte	0
 3143 0dcd 00        		.byte	0
 3144 0dce 00        		.byte	0
 3145 0dcf 00        		.byte	0
 3146 0dd0 00        		.byte	0
 3147 0dd1 00        		.byte	0
 3148 0dd2 00        		.byte	0
 3149 0dd3 00        		.byte	0
 3150 0dd4 00        		.byte	0
 3151 0dd5 00        		.byte	0
 3152 0dd6 00        		.byte	0
 3153 0dd7 00        		.byte	0
 3154 0dd8 00        		.byte	0
 3155 0dd9 00        		.byte	0
 3156 0dda 00        		.byte	0
 3157 0ddb 00        		.byte	0
 3158 0ddc 00        		.byte	0
 3159 0ddd 00        		.byte	0
 3160 0dde 00        		.byte	0
 3161 0ddf 00        		.byte	0
 3162 0de0 00        		.byte	0
 3163 0de1 00        		.byte	0
 3164 0de2 00        		.byte	0
 3165 0de3 00        		.byte	0
 3166 0de4 00        		.byte	0
 3167 0de5 00        		.byte	0
 3168 0de6 00        		.byte	0
 3169 0de7 00        		.byte	0
 3170 0de8 00        		.byte	0
 3171 0de9 00        		.byte	0
 3172 0dea 00        		.byte	0
 3173 0deb 00        		.byte	0
 3174 0dec 00        		.byte	0
 3175 0ded 00        		.byte	0
 3176 0dee 00        		.byte	0
 3177 0def 00        		.byte	0
 3178 0df0 00        		.byte	0
 3179 0df1 00        		.byte	0
 3180 0df2 00        		.byte	0
 3181 0df3 00        		.byte	0
 3182 0df4 00        		.byte	0
 3183 0df5 00        		.byte	0
 3184 0df6 00        		.byte	0
 3185 0df7 00        		.byte	0
 3186 0df8 00        		.byte	0
 3187 0df9 00        		.byte	0
 3188 0dfa 80        		.byte	-128
 3189 0dfb 80        		.byte	-128
 3190 0dfc 80        		.byte	-128
 3191 0dfd 00        		.byte	0
 3192 0dfe 00        		.byte	0
 3193 0dff 00        		.byte	0
 3194 0e00 00        		.byte	0
 3195 0e01 00        		.byte	0
 3196 0e02 00        		.byte	0
 3197 0e03 00        		.byte	0
 3198 0e04 00        		.byte	0
 3199 0e05 00        		.byte	0
 3200 0e06 00        		.byte	0
 3201 0e07 00        		.byte	0
 3202 0e08 00        		.byte	0
 3203 0e09 00        		.byte	0
 3204 0e0a 00        		.byte	0
 3205 0e0b 00        		.byte	0
 3206 0e0c 00        		.byte	0
 3207 0e0d 00        		.byte	0
 3208 0e0e 00        		.byte	0
 3209 0e0f 00        		.byte	0
 3210 0e10 00        		.byte	0
 3211 0e11 00        		.byte	0
 3212 0e12 00        		.byte	0
 3213 0e13 00        		.byte	0
 3214 0e14 00        		.byte	0
 3215 0e15 00        		.byte	0
 3216 0e16 00        		.byte	0
 3217 0e17 00        		.byte	0
 3218 0e18 00        		.byte	0
 3219 0e19 00        		.byte	0
 3220 0e1a 00        		.byte	0
 3221 0e1b 00        		.byte	0
 3222 0e1c 00        		.byte	0
 3223 0e1d 00        		.byte	0
 3224 0e1e 00        		.byte	0
 3225 0e1f 00        		.byte	0
 3226 0e20 00        		.byte	0
 3227 0e21 00        		.byte	0
 3228 0e22 00        		.byte	0
 3229 0e23 00        		.byte	0
 3230 0e24 00        		.byte	0
 3231 0e25 00        		.byte	0
 3232 0e26 00        		.byte	0
 3233 0e27 00        		.byte	0
 3234 0e28 00        		.byte	0
 3235 0e29 00        		.byte	0
 3236 0e2a 00        		.byte	0
 3237 0e2b 00        		.byte	0
 3238 0e2c 00        		.byte	0
 3239 0e2d 00        		.byte	0
 3240 0e2e 00        		.byte	0
 3241 0e2f 00        		.byte	0
 3242 0e30 00        		.byte	0
 3243 0e31 00        		.byte	0
 3244 0e32 00        		.byte	0
 3245 0e33 00        		.byte	0
 3246 0e34 00        		.byte	0
 3247 0e35 00        		.byte	0
 3248 0e36 00        		.byte	0
 3249 0e37 00        		.byte	0
 3250 0e38 00        		.byte	0
 3251 0e39 00        		.byte	0
 3252 0e3a 00        		.byte	0
 3253 0e3b 00        		.byte	0
 3254 0e3c 00        		.byte	0
 3255 0e3d 00        		.byte	0
 3256 0e3e 00        		.byte	0
 3257 0e3f 00        		.byte	0
 3258 0e40 00        		.byte	0
 3259 0e41 00        		.byte	0
 3260 0e42 00        		.byte	0
 3261 0e43 00        		.byte	0
 3262 0e44 00        		.byte	0
 3263 0e45 00        		.byte	0
 3264 0e46 00        		.byte	0
 3265 0e47 00        		.byte	0
 3266 0e48 00        		.byte	0
 3267 0e49 00        		.byte	0
 3268 0e4a 00        		.byte	0
 3269 0e4b 00        		.byte	0
 3270 0e4c 00        		.byte	0
 3271 0e4d 00        		.byte	0
 3272 0e4e 00        		.byte	0
 3273 0e4f 00        		.byte	0
 3274 0e50 00        		.byte	0
 3275 0e51 00        		.byte	0
 3276 0e52 00        		.byte	0
 3277 0e53 00        		.byte	0
 3278 0e54 00        		.byte	0
 3279 0e55 00        		.byte	0
 3280 0e56 00        		.byte	0
 3281 0e57 00        		.byte	0
 3282 0e58 00        		.byte	0
 3283 0e59 00        		.byte	0
 3284 0e5a 00        		.byte	0
 3285 0e5b 00        		.byte	0
 3286 0e5c 00        		.byte	0
 3287 0e5d 00        		.byte	0
 3288 0e5e 00        		.byte	0
 3289 0e5f 00        		.byte	0
 3290 0e60 00        		.byte	0
 3291 0e61 00        		.byte	0
 3292 0e62 00        		.byte	0
 3293 0e63 00        		.byte	0
 3294 0e64 00        		.byte	0
 3295 0e65 00        		.byte	0
 3296 0e66 00        		.byte	0
 3297 0e67 00        		.byte	0
 3298 0e68 00        		.byte	0
 3299 0e69 80        		.byte	-128
 3300 0e6a E0        		.byte	-32
 3301 0e6b F0        		.byte	-16
 3302 0e6c FC        		.byte	-4
 3303 0e6d FE        		.byte	-2
 3304 0e6e FF        		.byte	-1
 3305 0e6f FF        		.byte	-1
 3306 0e70 3F        		.byte	63
 3307 0e71 00        		.byte	0
 3308 0e72 00        		.byte	0
 3309 0e73 00        		.byte	0
 3310 0e74 00        		.byte	0
 3311 0e75 C0        		.byte	-64
 3312 0e76 E0        		.byte	-32
 3313 0e77 F8        		.byte	-8
 3314 0e78 FE        		.byte	-2
 3315 0e79 FF        		.byte	-1
 3316 0e7a FF        		.byte	-1
 3317 0e7b FF        		.byte	-1
 3318 0e7c 1F        		.byte	31
 3319 0e7d 03        		.byte	3
 3320 0e7e 00        		.byte	0
 3321 0e7f 00        		.byte	0
 3322 0e80 80        		.byte	-128
 3323 0e81 E0        		.byte	-32
 3324 0e82 E0        		.byte	-32
 3325 0e83 F0        		.byte	-16
 3326 0e84 F0        		.byte	-16
 3327 0e85 F8        		.byte	-8
 3328 0e86 F8        		.byte	-8
 3329 0e87 F8        		.byte	-8
 3330 0e88 F8        		.byte	-8
 3331 0e89 F8        		.byte	-8
 3332 0e8a F8        		.byte	-8
 3333 0e8b F8        		.byte	-8
 3334 0e8c F8        		.byte	-8
 3335 0e8d 78        		.byte	120
 3336 0e8e 78        		.byte	120
 3337 0e8f 78        		.byte	120
 3338 0e90 78        		.byte	120
 3339 0e91 38        		.byte	56
 3340 0e92 38        		.byte	56
 3341 0e93 38        		.byte	56
 3342 0e94 18        		.byte	24
 3343 0e95 10        		.byte	16
 3344 0e96 10        		.byte	16
 3345 0e97 D0        		.byte	-48
 3346 0e98 F0        		.byte	-16
 3347 0e99 F0        		.byte	-16
 3348 0e9a FC        		.byte	-4
 3349 0e9b FE        		.byte	-2
 3350 0e9c FF        		.byte	-1
 3351 0e9d FF        		.byte	-1
 3352 0e9e 3F        		.byte	63
 3353 0e9f 00        		.byte	0
 3354 0ea0 00        		.byte	0
 3355 0ea1 00        		.byte	0
 3356 0ea2 00        		.byte	0
 3357 0ea3 00        		.byte	0
 3358 0ea4 00        		.byte	0
 3359 0ea5 00        		.byte	0
 3360 0ea6 00        		.byte	0
 3361 0ea7 00        		.byte	0
 3362 0ea8 00        		.byte	0
 3363 0ea9 00        		.byte	0
 3364 0eaa 00        		.byte	0
 3365 0eab 00        		.byte	0
 3366 0eac 00        		.byte	0
 3367 0ead C0        		.byte	-64
 3368 0eae E0        		.byte	-32
 3369 0eaf F0        		.byte	-16
 3370 0eb0 FC        		.byte	-4
 3371 0eb1 FE        		.byte	-2
 3372 0eb2 FF        		.byte	-1
 3373 0eb3 FF        		.byte	-1
 3374 0eb4 3F        		.byte	63
 3375 0eb5 00        		.byte	0
 3376 0eb6 00        		.byte	0
 3377 0eb7 00        		.byte	0
 3378 0eb8 00        		.byte	0
 3379 0eb9 00        		.byte	0
 3380 0eba 00        		.byte	0
 3381 0ebb 00        		.byte	0
 3382 0ebc 00        		.byte	0
 3383 0ebd 00        		.byte	0
 3384 0ebe 00        		.byte	0
 3385 0ebf 00        		.byte	0
 3386 0ec0 00        		.byte	0
 3387 0ec1 00        		.byte	0
 3388 0ec2 00        		.byte	0
 3389 0ec3 00        		.byte	0
 3390 0ec4 00        		.byte	0
 3391 0ec5 00        		.byte	0
 3392 0ec6 80        		.byte	-128
 3393 0ec7 C0        		.byte	-64
 3394 0ec8 C0        		.byte	-64
 3395 0ec9 E0        		.byte	-32
 3396 0eca E0        		.byte	-32
 3397 0ecb F0        		.byte	-16
 3398 0ecc F0        		.byte	-16
 3399 0ecd F0        		.byte	-16
 3400 0ece F0        		.byte	-16
 3401 0ecf 00        		.byte	0
 3402 0ed0 00        		.byte	0
 3403 0ed1 00        		.byte	0
 3404 0ed2 00        		.byte	0
 3405 0ed3 00        		.byte	0
 3406 0ed4 00        		.byte	0
 3407 0ed5 00        		.byte	0
 3408 0ed6 00        		.byte	0
 3409 0ed7 00        		.byte	0
 3410 0ed8 00        		.byte	0
 3411 0ed9 00        		.byte	0
 3412 0eda 00        		.byte	0
 3413 0edb 80        		.byte	-128
 3414 0edc C0        		.byte	-64
 3415 0edd E0        		.byte	-32
 3416 0ede F8        		.byte	-8
 3417 0edf FC        		.byte	-4
 3418 0ee0 00        		.byte	0
 3419 0ee1 00        		.byte	0
 3420 0ee2 00        		.byte	0
 3421 0ee3 00        		.byte	0
 3422 0ee4 00        		.byte	0
 3423 0ee5 80        		.byte	-128
 3424 0ee6 E0        		.byte	-32
 3425 0ee7 F8        		.byte	-8
 3426 0ee8 FE        		.byte	-2
 3427 0ee9 FF        		.byte	-1
 3428 0eea FF        		.byte	-1
 3429 0eeb FF        		.byte	-1
 3430 0eec FF        		.byte	-1
 3431 0eed EF        		.byte	-17
 3432 0eee E3        		.byte	-29
 3433 0eef E0        		.byte	-32
 3434 0ef0 E0        		.byte	-32
 3435 0ef1 E0        		.byte	-32
 3436 0ef2 F0        		.byte	-16
 3437 0ef3 FC        		.byte	-4
 3438 0ef4 FF        		.byte	-1
 3439 0ef5 FF        		.byte	-1
 3440 0ef6 FF        		.byte	-1
 3441 0ef7 FF        		.byte	-1
 3442 0ef8 7F        		.byte	127
 3443 0ef9 6F        		.byte	111
 3444 0efa 63        		.byte	99
 3445 0efb 40        		.byte	64
 3446 0efc 00        		.byte	0
 3447 0efd C0        		.byte	-64
 3448 0efe F0        		.byte	-16
 3449 0eff F8        		.byte	-8
 3450 0f00 FE        		.byte	-2
 3451 0f01 FF        		.byte	-1
 3452 0f02 FF        		.byte	-1
 3453 0f03 FF        		.byte	-1
 3454 0f04 FF        		.byte	-1
 3455 0f05 EF        		.byte	-17
 3456 0f06 E3        		.byte	-29
 3457 0f07 E1        		.byte	-31
 3458 0f08 E1        		.byte	-31
 3459 0f09 61        		.byte	97
 3460 0f0a 40        		.byte	64
 3461 0f0b 40        		.byte	64
 3462 0f0c 00        		.byte	0
 3463 0f0d 00        		.byte	0
 3464 0f0e 00        		.byte	0
 3465 0f0f 00        		.byte	0
 3466 0f10 00        		.byte	0
 3467 0f11 00        		.byte	0
 3468 0f12 C0        		.byte	-64
 3469 0f13 E0        		.byte	-32
 3470 0f14 F8        		.byte	-8
 3471 0f15 FE        		.byte	-2
 3472 0f16 FF        		.byte	-1
 3473 0f17 FF        		.byte	-1
 3474 0f18 7F        		.byte	127
 3475 0f19 3F        		.byte	63
 3476 0f1a 1F        		.byte	31
 3477 0f1b 07        		.byte	7
 3478 0f1c 03        		.byte	3
 3479 0f1d 00        		.byte	0
 3480 0f1e 00        		.byte	0
 3481 0f1f 00        		.byte	0
 3482 0f20 00        		.byte	0
 3483 0f21 00        		.byte	0
 3484 0f22 00        		.byte	0
 3485 0f23 00        		.byte	0
 3486 0f24 00        		.byte	0
 3487 0f25 00        		.byte	0
 3488 0f26 00        		.byte	0
 3489 0f27 00        		.byte	0
 3490 0f28 C0        		.byte	-64
 3491 0f29 E0        		.byte	-32
 3492 0f2a F8        		.byte	-8
 3493 0f2b FE        		.byte	-2
 3494 0f2c FF        		.byte	-1
 3495 0f2d FF        		.byte	-1
 3496 0f2e 7F        		.byte	127
 3497 0f2f 3F        		.byte	63
 3498 0f30 1F        		.byte	31
 3499 0f31 07        		.byte	7
 3500 0f32 03        		.byte	3
 3501 0f33 00        		.byte	0
 3502 0f34 00        		.byte	0
 3503 0f35 00        		.byte	0
 3504 0f36 00        		.byte	0
 3505 0f37 00        		.byte	0
 3506 0f38 00        		.byte	0
 3507 0f39 00        		.byte	0
 3508 0f3a 00        		.byte	0
 3509 0f3b 00        		.byte	0
 3510 0f3c 00        		.byte	0
 3511 0f3d 80        		.byte	-128
 3512 0f3e C0        		.byte	-64
 3513 0f3f E0        		.byte	-32
 3514 0f40 F0        		.byte	-16
 3515 0f41 F8        		.byte	-8
 3516 0f42 FC        		.byte	-4
 3517 0f43 FE        		.byte	-2
 3518 0f44 FF        		.byte	-1
 3519 0f45 7F        		.byte	127
 3520 0f46 1F        		.byte	31
 3521 0f47 0F        		.byte	15
 3522 0f48 07        		.byte	7
 3523 0f49 03        		.byte	3
 3524 0f4a 07        		.byte	7
 3525 0f4b 1F        		.byte	31
 3526 0f4c FF        		.byte	-1
 3527 0f4d FF        		.byte	-1
 3528 0f4e FF        		.byte	-1
 3529 0f4f FF        		.byte	-1
 3530 0f50 FC        		.byte	-4
 3531 0f51 00        		.byte	0
 3532 0f52 00        		.byte	0
 3533 0f53 00        		.byte	0
 3534 0f54 00        		.byte	0
 3535 0f55 00        		.byte	0
 3536 0f56 00        		.byte	0
 3537 0f57 C0        		.byte	-64
 3538 0f58 F0        		.byte	-16
 3539 0f59 FC        		.byte	-4
 3540 0f5a FE        		.byte	-2
 3541 0f5b 3F        		.byte	63
 3542 0f5c 1F        		.byte	31
 3543 0f5d 07        		.byte	7
 3544 0f5e 03        		.byte	3
 3545 0f5f 01        		.byte	1
 3546 0f60 00        		.byte	0
 3547 0f61 00        		.byte	0
 3548 0f62 00        		.byte	0
 3549 0f63 E0        		.byte	-32
 3550 0f64 FC        		.byte	-4
 3551 0f65 FF        		.byte	-1
 3552 0f66 FF        		.byte	-1
 3553 0f67 FF        		.byte	-1
 3554 0f68 3F        		.byte	63
 3555 0f69 0F        		.byte	15
 3556 0f6a 03        		.byte	3
 3557 0f6b 01        		.byte	1
 3558 0f6c 01        		.byte	1
 3559 0f6d 01        		.byte	1
 3560 0f6e C1        		.byte	-63
 3561 0f6f F8        		.byte	-8
 3562 0f70 FE        		.byte	-2
 3563 0f71 FF        		.byte	-1
 3564 0f72 FF        		.byte	-1
 3565 0f73 7F        		.byte	127
 3566 0f74 1F        		.byte	31
 3567 0f75 07        		.byte	7
 3568 0f76 01        		.byte	1
 3569 0f77 00        		.byte	0
 3570 0f78 00        		.byte	0
 3571 0f79 80        		.byte	-128
 3572 0f7a F0        		.byte	-16
 3573 0f7b FC        		.byte	-4
 3574 0f7c FF        		.byte	-1
 3575 0f7d FF        		.byte	-1
 3576 0f7e FF        		.byte	-1
 3577 0f7f 3F        		.byte	63
 3578 0f80 0F        		.byte	15
 3579 0f81 03        		.byte	3
 3580 0f82 01        		.byte	1
 3581 0f83 01        		.byte	1
 3582 0f84 01        		.byte	1
 3583 0f85 01        		.byte	1
 3584 0f86 80        		.byte	-128
 3585 0f87 80        		.byte	-128
 3586 0f88 80        		.byte	-128
 3587 0f89 C0        		.byte	-64
 3588 0f8a 40        		.byte	64
 3589 0f8b 00        		.byte	0
 3590 0f8c 00        		.byte	0
 3591 0f8d 00        		.byte	0
 3592 0f8e C0        		.byte	-64
 3593 0f8f F0        		.byte	-16
 3594 0f90 FC        		.byte	-4
 3595 0f91 FF        		.byte	-1
 3596 0f92 FF        		.byte	-1
 3597 0f93 3F        		.byte	63
 3598 0f94 0F        		.byte	15
 3599 0f95 07        		.byte	7
 3600 0f96 03        		.byte	3
 3601 0f97 01        		.byte	1
 3602 0f98 00        		.byte	0
 3603 0f99 00        		.byte	0
 3604 0f9a 00        		.byte	0
 3605 0f9b 00        		.byte	0
 3606 0f9c 00        		.byte	0
 3607 0f9d 00        		.byte	0
 3608 0f9e 00        		.byte	0
 3609 0f9f 00        		.byte	0
 3610 0fa0 00        		.byte	0
 3611 0fa1 00        		.byte	0
 3612 0fa2 00        		.byte	0
 3613 0fa3 00        		.byte	0
 3614 0fa4 C0        		.byte	-64
 3615 0fa5 F0        		.byte	-16
 3616 0fa6 FC        		.byte	-4
 3617 0fa7 FF        		.byte	-1
 3618 0fa8 FF        		.byte	-1
 3619 0fa9 3F        		.byte	63
 3620 0faa 0F        		.byte	15
 3621 0fab 07        		.byte	7
 3622 0fac 03        		.byte	3
 3623 0fad 01        		.byte	1
 3624 0fae 00        		.byte	0
 3625 0faf 00        		.byte	0
 3626 0fb0 00        		.byte	0
 3627 0fb1 00        		.byte	0
 3628 0fb2 00        		.byte	0
 3629 0fb3 00        		.byte	0
 3630 0fb4 00        		.byte	0
 3631 0fb5 00        		.byte	0
 3632 0fb6 00        		.byte	0
 3633 0fb7 00        		.byte	0
 3634 0fb8 00        		.byte	0
 3635 0fb9 00        		.byte	0
 3636 0fba E0        		.byte	-32
 3637 0fbb FC        		.byte	-4
 3638 0fbc FE        		.byte	-2
 3639 0fbd FF        		.byte	-1
 3640 0fbe FF        		.byte	-1
 3641 0fbf FF        		.byte	-1
 3642 0fc0 1F        		.byte	31
 3643 0fc1 0F        		.byte	15
 3644 0fc2 07        		.byte	7
 3645 0fc3 01        		.byte	1
 3646 0fc4 00        		.byte	0
 3647 0fc5 00        		.byte	0
 3648 0fc6 00        		.byte	0
 3649 0fc7 00        		.byte	0
 3650 0fc8 80        		.byte	-128
 3651 0fc9 E0        		.byte	-32
 3652 0fca F8        		.byte	-8
 3653 0fcb FF        		.byte	-1
 3654 0fcc FF        		.byte	-1
 3655 0fcd FF        		.byte	-1
 3656 0fce 7F        		.byte	127
 3657 0fcf 3F        		.byte	63
 3658 0fd0 0F        		.byte	15
 3659 0fd1 00        		.byte	0
 3660 0fd2 80        		.byte	-128
 3661 0fd3 80        		.byte	-128
 3662 0fd4 A0        		.byte	-96
 3663 0fd5 BC        		.byte	-68
 3664 0fd6 3F        		.byte	63
 3665 0fd7 0F        		.byte	15
 3666 0fd8 03        		.byte	3
 3667 0fd9 01        		.byte	1
 3668 0fda 00        		.byte	0
 3669 0fdb 00        		.byte	0
 3670 0fdc 00        		.byte	0
 3671 0fdd 00        		.byte	0
 3672 0fde 00        		.byte	0
 3673 0fdf 00        		.byte	0
 3674 0fe0 00        		.byte	0
 3675 0fe1 F8        		.byte	-8
 3676 0fe2 FF        		.byte	-1
 3677 0fe3 7F        		.byte	127
 3678 0fe4 1F        		.byte	31
 3679 0fe5 07        		.byte	7
 3680 0fe6 01        		.byte	1
 3681 0fe7 00        		.byte	0
 3682 0fe8 00        		.byte	0
 3683 0fe9 00        		.byte	0
 3684 0fea 00        		.byte	0
 3685 0feb 00        		.byte	0
 3686 0fec 00        		.byte	0
 3687 0fed 38        		.byte	56
 3688 0fee 7F        		.byte	127
 3689 0fef 7F        		.byte	127
 3690 0ff0 3F        		.byte	63
 3691 0ff1 1F        		.byte	31
 3692 0ff2 07        		.byte	7
 3693 0ff3 00        		.byte	0
 3694 0ff4 00        		.byte	0
 3695 0ff5 00        		.byte	0
 3696 0ff6 00        		.byte	0
 3697 0ff7 00        		.byte	0
 3698 0ff8 00        		.byte	0
 3699 0ff9 03        		.byte	3
 3700 0ffa 0F        		.byte	15
 3701 0ffb 0F        		.byte	15
 3702 0ffc 0F        		.byte	15
 3703 0ffd 1F        		.byte	31
 3704 0ffe 1F        		.byte	31
 3705 0fff 1F        		.byte	31
 3706 1000 1F        		.byte	31
 3707 1001 0F        		.byte	15
 3708 1002 0F        		.byte	15
 3709 1003 0F        		.byte	15
 3710 1004 07        		.byte	7
 3711 1005 07        		.byte	7
 3712 1006 03        		.byte	3
 3713 1007 03        		.byte	3
 3714 1008 01        		.byte	1
 3715 1009 00        		.byte	0
 3716 100a 00        		.byte	0
 3717 100b 00        		.byte	0
 3718 100c 00        		.byte	0
 3719 100d 04        		.byte	4
 3720 100e 1F        		.byte	31
 3721 100f 1F        		.byte	31
 3722 1010 1F        		.byte	31
 3723 1011 3F        		.byte	63
 3724 1012 3E        		.byte	62
 3725 1013 3E        		.byte	62
 3726 1014 3E        		.byte	62
 3727 1015 3E        		.byte	62
 3728 1016 3E        		.byte	62
 3729 1017 1E        		.byte	30
 3730 1018 1E        		.byte	30
 3731 1019 1E        		.byte	30
 3732 101a 1E        		.byte	30
 3733 101b 1E        		.byte	30
 3734 101c 1E        		.byte	30
 3735 101d 1E        		.byte	30
 3736 101e 0E        		.byte	14
 3737 101f 0E        		.byte	14
 3738 1020 0C        		.byte	12
 3739 1021 04        		.byte	4
 3740 1022 04        		.byte	4
 3741 1023 04        		.byte	4
 3742 1024 1F        		.byte	31
 3743 1025 1F        		.byte	31
 3744 1026 1F        		.byte	31
 3745 1027 3F        		.byte	63
 3746 1028 3E        		.byte	62
 3747 1029 3E        		.byte	62
 3748 102a 3E        		.byte	62
 3749 102b 3E        		.byte	62
 3750 102c 3E        		.byte	62
 3751 102d 1E        		.byte	30
 3752 102e 1E        		.byte	30
 3753 102f 1E        		.byte	30
 3754 1030 1E        		.byte	30
 3755 1031 1E        		.byte	30
 3756 1032 1E        		.byte	30
 3757 1033 1E        		.byte	30
 3758 1034 0E        		.byte	14
 3759 1035 0E        		.byte	14
 3760 1036 0C        		.byte	12
 3761 1037 04        		.byte	4
 3762 1038 04        		.byte	4
 3763 1039 04        		.byte	4
 3764 103a 00        		.byte	0
 3765 103b 07        		.byte	7
 3766 103c 0F        		.byte	15
 3767 103d 0F        		.byte	15
 3768 103e 1F        		.byte	31
 3769 103f 1F        		.byte	31
 3770 1040 1E        		.byte	30
 3771 1041 3E        		.byte	62
 3772 1042 3E        		.byte	62
 3773 1043 1E        		.byte	30
 3774 1044 1E        		.byte	30
 3775 1045 1E        		.byte	30
 3776 1046 1F        		.byte	31
 3777 1047 0F        		.byte	15
 3778 1048 0F        		.byte	15
 3779 1049 0F        		.byte	15
 3780 104a 07        		.byte	7
 3781 104b 03        		.byte	3
 3782 104c 03        		.byte	3
 3783 104d 01        		.byte	1
 3784 104e 00        		.byte	0
 3785 104f 00        		.byte	0
 3786 1050 06        		.byte	6
 3787 1051 0F        		.byte	15
 3788 1052 1F        		.byte	31
 3789 1053 1F        		.byte	31
 3790 1054 0F        		.byte	15
 3791 1055 0F        		.byte	15
 3792 1056 06        		.byte	6
 3793 1057 00        		.byte	0
 3794 1058 00        		.byte	0
 3795 1059 00        		.byte	0
 3796 105a 00        		.byte	0
 3797 105b 00        		.byte	0
 3798 105c 00        		.byte	0
 3799 105d 00        		.byte	0
 3800 105e 00        		.byte	0
 3801 105f 00        		.byte	0
 3802 1060 00        		.byte	0
 3803 1061 00        		.byte	0
 3804 1062 00        		.byte	0
 3805 1063 00        		.byte	0
 3806 1064 00        		.byte	0
 3807 1065 00        		.byte	0
 3808 1066 00        		.byte	0
 3809 1067 00        		.byte	0
 3810 1068 00        		.byte	0
 3811 1069 00        		.byte	0
 3812 106a 00        		.byte	0
 3813 106b 00        		.byte	0
 3814 106c 00        		.byte	0
 3815 106d 00        		.byte	0
 3816 106e 00        		.byte	0
 3817 106f 00        		.byte	0
 3818 1070 00        		.byte	0
 3819 1071 00        		.byte	0
 3820 1072 00        		.byte	0
 3821 1073 00        		.byte	0
 3822 1074 00        		.byte	0
 3823 1075 00        		.byte	0
 3824 1076 00        		.byte	0
 3825 1077 00        		.byte	0
 3826 1078 00        		.byte	0
 3827 1079 00        		.byte	0
 3828 107a 00        		.byte	0
 3829 107b 00        		.byte	0
 3830 107c 00        		.byte	0
 3831 107d 00        		.byte	0
 3832 107e 00        		.byte	0
 3833 107f 00        		.byte	0
 3834 1080 00        		.byte	0
 3835 1081 00        		.byte	0
 3836 1082 00        		.byte	0
 3837 1083 00        		.byte	0
 3838 1084 00        		.byte	0
 3839 1085 00        		.byte	0
 3840 1086 00        		.byte	0
 3841 1087 00        		.byte	0
 3842 1088 00        		.byte	0
 3843 1089 00        		.byte	0
 3844 108a 00        		.byte	0
 3845 108b 00        		.byte	0
 3846 108c 00        		.byte	0
 3847 108d 00        		.byte	0
 3848 108e 00        		.byte	0
 3849 108f 00        		.byte	0
 3850 1090 00        		.byte	0
 3851 1091 00        		.byte	0
 3852 1092 00        		.byte	0
 3853 1093 00        		.byte	0
 3854 1094 00        		.byte	0
 3855 1095 00        		.byte	0
 3856 1096 00        		.byte	0
 3857 1097 00        		.byte	0
 3858 1098 00        		.byte	0
 3859 1099 00        		.byte	0
 3860 109a 00        		.byte	0
 3861 109b 00        		.byte	0
 3862 109c 00        		.byte	0
 3863 109d 00        		.byte	0
 3864 109e 00        		.byte	0
 3865 109f 00        		.byte	0
 3866 10a0 00        		.byte	0
 3867 10a1 00        		.byte	0
 3868 10a2 00        		.byte	0
 3869 10a3 00        		.byte	0
 3870 10a4 00        		.byte	0
 3871 10a5 00        		.byte	0
 3872 10a6 00        		.byte	0
 3873 10a7 00        		.byte	0
 3874 10a8 00        		.byte	0
 3875 10a9 00        		.byte	0
 3876 10aa 00        		.byte	0
 3877 10ab 00        		.byte	0
 3878 10ac 00        		.byte	0
 3879 10ad 00        		.byte	0
 3880 10ae 00        		.byte	0
 3881 10af 00        		.byte	0
 3882 10b0 00        		.byte	0
 3883 10b1 00        		.byte	0
 3884 10b2 00        		.byte	0
 3885 10b3 00        		.byte	0
 3886 10b4 00        		.byte	0
 3887 10b5 00        		.byte	0
 3888 10b6 00        		.byte	0
 3889 10b7 00        		.byte	0
 3890 10b8 00        		.byte	0
 3891 10b9 00        		.byte	0
 3892 10ba 00        		.byte	0
 3893 10bb 00        		.byte	0
 3894 10bc 00        		.byte	0
 3895 10bd 00        		.byte	0
 3896 10be 00        		.byte	0
 3897 10bf 00        		.byte	0
 3898 10c0 00        		.byte	0
 3899 10c1 00        		.byte	0
 3900 10c2 00        		.byte	0
 3901 10c3 00        		.byte	0
 3902 10c4 00        		.byte	0
 3903 10c5 00        		.byte	0
 3904 10c6 00        		.byte	0
 3905 10c7 00        		.byte	0
 3906 10c8 00        		.byte	0
 3907 10c9 00        		.byte	0
 3908 10ca 00        		.byte	0
 3909 10cb 00        		.byte	0
 3910 10cc 00        		.byte	0
 3911 10cd 00        		.byte	0
 3912 10ce 00        		.byte	0
 3913 10cf 00        		.byte	0
 3914 10d0 00        		.byte	0
 3915 10d1 00        		.byte	0
 3916 10d2 00        		.byte	0
 3917 10d3 00        		.byte	0
 3918 10d4 00        		.byte	0
 3919 10d5 00        		.byte	0
 3920 10d6 00        		.byte	0
 3921 10d7 00        		.byte	0
 3922 10d8 00        		.byte	0
 3923 10d9 00        		.byte	0
 3924 10da 00        		.byte	0
 3925 10db 00        		.byte	0
 3926 10dc 00        		.byte	0
 3927 10dd 00        		.byte	0
 3928 10de 00        		.byte	0
 3929 10df 00        		.byte	0
 3930 10e0 00        		.byte	0
 3931 10e1 00        		.byte	0
 3932 10e2 00        		.byte	0
 3933 10e3 00        		.byte	0
 3934 10e4 00        		.byte	0
 3935 10e5 00        		.byte	0
 3936 10e6 00        		.byte	0
 3937 10e7 00        		.byte	0
 3938 10e8 00        		.byte	0
 3939 10e9 00        		.byte	0
 3940 10ea 00        		.byte	0
 3941 10eb 00        		.byte	0
 3942 10ec 00        		.byte	0
 3943 10ed 00        		.byte	0
 3944 10ee 00        		.byte	0
 3945 10ef 00        		.byte	0
 3946 10f0 00        		.byte	0
 3947 10f1 00        		.byte	0
 3948 10f2 00        		.byte	0
 3949 10f3 00        		.byte	0
 3950 10f4 00        		.byte	0
 3951 10f5 00        		.byte	0
 3952 10f6 00        		.byte	0
 3953 10f7 00        		.byte	0
 3954 10f8 00        		.byte	0
 3955 10f9 00        		.byte	0
 3956 10fa 00        		.byte	0
 3957 10fb 00        		.byte	0
 3958 10fc 00        		.byte	0
 3959 10fd 00        		.byte	0
 3960 10fe 00        		.byte	0
 3961 10ff 00        		.byte	0
 3962 1100 00        		.byte	0
 3963 1101 00        		.byte	0
 3964 1102 00        		.byte	0
 3965 1103 00        		.byte	0
 3966 1104 00        		.byte	0
 3967 1105 00        		.byte	0
 3968 1106 00        		.byte	0
 3969 1107 00        		.byte	0
 3970 1108 00        		.byte	0
 3971 1109 00        		.byte	0
 3972 110a 00        		.byte	0
 3973 110b 00        		.byte	0
 3974 110c 00        		.byte	0
 3975 110d 00        		.byte	0
 3976 110e 00        		.byte	0
 3977 110f 00        		.byte	0
 3978 1110 00        		.byte	0
 3979 1111 00        		.byte	0
 3980 1112 00        		.byte	0
 3981 1113 00        		.byte	0
 3982 1114 00        		.byte	0
 3983 1115 00        		.byte	0
 3984 1116 00        		.byte	0
 3985 1117 00        		.byte	0
 3986 1118 00        		.byte	0
 3987 1119 00        		.byte	0
 3988 111a 00        		.byte	0
 3989 111b 00        		.byte	0
 3990 111c 00        		.byte	0
 3991 111d 00        		.byte	0
 3992 111e 00        		.byte	0
 3993 111f 00        		.byte	0
 3994 1120 00        		.byte	0
 3995 1121 00        		.byte	0
 3996 1122 00        		.byte	0
 3997 1123 00        		.byte	0
 3998 1124 00        		.byte	0
 3999 1125 00        		.byte	0
 4000 1126 00        		.byte	0
 4001 1127 00        		.byte	0
 4002 1128 00        		.byte	0
 4003 1129 00        		.byte	0
 4004 112a 00        		.byte	0
 4005 112b 00        		.byte	0
 4006 112c 00        		.byte	0
 4007 112d 00        		.byte	0
 4008 112e 00        		.byte	0
 4009 112f 00        		.byte	0
 4010 1130 00        		.byte	0
 4011 1131 00        		.byte	0
 4012 1132 00        		.byte	0
 4013 1133 00        		.byte	0
 4014 1134 00        		.byte	0
 4015 1135 00        		.byte	0
 4016 1136 00        		.byte	0
 4017 1137 00        		.byte	0
 4018 1138 00        		.byte	0
 4019 1139 00        		.byte	0
 4020 113a 00        		.byte	0
 4021 113b 00        		.byte	0
 4022 113c 00        		.byte	0
 4023 113d 00        		.byte	0
 4024 113e 00        		.byte	0
 4025 113f 00        		.byte	0
 4026 1140 00        		.byte	0
 4027 1141 00        		.byte	0
 4028 1142 00        		.byte	0
 4029 1143 00        		.byte	0
 4030 1144 00        		.byte	0
 4031 1145 00        		.byte	0
 4032 1146 00        		.byte	0
 4033 1147 00        		.byte	0
 4034 1148 00        		.byte	0
 4035 1149 00        		.byte	0
 4036 114a 00        		.byte	0
 4037 114b 00        		.byte	0
 4038 114c 00        		.byte	0
 4039 114d 00        		.byte	0
 4040 114e 00        		.byte	0
 4041 114f 00        		.byte	0
 4042 1150 00        		.byte	0
 4043 1151 00        		.byte	0
 4044 1152 00        		.byte	0
 4045 1153 00        		.byte	0
 4046 1154 00        		.byte	0
 4047 1155 00        		.byte	0
 4048 1156 00        		.byte	0
 4049 1157 00        		.byte	0
 4050 1158 00        		.byte	0
 4051 1159 00        		.byte	0
 4052 115a 00        		.byte	0
 4053 115b 00        		.byte	0
 4054 115c 00        		.byte	0
 4055 115d 00        		.byte	0
 4056 115e 00        		.byte	0
 4057 115f 00        		.byte	0
 4061               	.global	uTock
 4062               		.data
 4065               	uTock:
 4066 0000 3701      		.word	311
 4067               	.global	uState
 4068               	.global	uState
 4069               		.section .bss
 4072               	uState:
 4073 0000 00        		.skip 1,0
 4074               	.global	uTmrState
 4075               		.data
 4078               	uTmrState:
 4079 0002 D2        		.byte	-46
 4080               	.global	uBtnUpTmr
 4081               	.global	uBtnUpTmr
 4082               		.section .bss
 4085               	uBtnUpTmr:
 4086 0001 00        		.skip 1,0
 4087               	.global	uBtnDwnTmr
 4088               	.global	uBtnDwnTmr
 4091               	uBtnDwnTmr:
 4092 0002 00        		.skip 1,0
 4093               	.global	uBtnEnterTmr
 4094               	.global	uBtnEnterTmr
 4097               	uBtnEnterTmr:
 4098 0003 00        		.skip 1,0
 4099               	.global	uBob
 4100               		.data
 4103               	uBob:
 4104 0003 0A        		.byte	10
 4105               	.global	uTmrGeneral
 4108               	uTmrGeneral:
 4109 0004 0A        		.byte	10
 4110               	.global	uContrast
 4113               	uContrast:
 4114 0005 30        		.byte	48
 4115               	.global	boolSoundAlarm
 4116               	.global	boolSoundAlarm
 4117               		.section .bss
 4120               	boolSoundAlarm:
 4121 0004 00        		.skip 1,0
 4122               	.global	boolAlarmOn
 4123               	.global	boolAlarmOn
 4126               	boolAlarmOn:
 4127 0005 00        		.skip 1,0
 4128               	.global	boolPowerupBlink
 4129               		.data
 4132               	boolPowerupBlink:
 4133 0006 01        		.byte	1
 4134               	.global	uRefreshDisplay
 4135               	.global	uRefreshDisplay
 4136               		.section .bss
 4139               	uRefreshDisplay:
 4140 0006 00        		.skip 1,0
 4141               	.global	EEKey
 4142               		.section	.eeprom,"a",@progbits
 4145               	EEKey:
 4146 0000 FFFF      		.word	-1
 4147               	.global	EEMinute
 4150               	EEMinute:
 4151 0002 FFFF      		.word	-1
 4152               	.global	EEHour
 4155               	EEHour:
 4156 0004 FFFF      		.word	-1
 4157               	.global	EEPhotoTriggerValue
 4160               	EEPhotoTriggerValue:
 4161 0006 FFFF      		.word	-1
 4162               	.global	EEBacklightOnHour
 4165               	EEBacklightOnHour:
 4166 0008 FF        		.byte	-1
 4167               	.global	EEBacklightOffHour
 4170               	EEBacklightOffHour:
 4171 0009 FF        		.byte	-1
 4173               		.text
 4177               	.global	set_line
 4179               	set_line:
 4181               	.Ltext1:
   1:lcd.h         **** /*
   2:lcd.h         **** Author:  Matt Meerian
   3:lcd.h         **** Date:  December 22, 2004
   4:lcd.h         **** Target Processor:  ATMEGA8535 from Atmel
   5:lcd.h         **** Languate used:  AVR GCC compiler (in the "C" language)
   6:lcd.h         **** Overview:
   7:lcd.h         ****         This file contains functions for basic operation of the 128x64 pixel,
   8:lcd.h         ****         2.8", blue and white, LCD from Optrex.  (Part Number F-51553GNBJ-LW-AB)  The
   9:lcd.h         ****         hardware interface will be through a demo board from Apollo Display.  (Part
  10:lcd.h         ****         Number:  F-51553-Eval
  11:lcd.h         **** 		The display will use the serial interface to drive the LCD.  The LCD is
  12:lcd.h         **** 		set to the "80 series" (intel) interface.
  13:lcd.h         **** */
  14:lcd.h         **** 
  15:lcd.h         **** #include <define.h>
  16:lcd.h         **** 
  17:lcd.h         **** void set_line(unsigned char uLineNumber);      //set the line of text to write
  18:lcd.h         **** 	// on the graphical LCD
  19:lcd.h         **** void write_data(unsigned char uLCDData);		//write data to the graphical LCD
  20:lcd.h         **** void send_serial_data(unsigned char uLCDSerial);	//write a command or data
  21:lcd.h         **** 	// serially to the display
  22:lcd.h         **** void write_char(unsigned char uWriteLcdChar, bool boolCharInvert);	//write a character to the LCD
  23:lcd.h         **** void clear_display(void);	//clear the entire LCD display
  24:lcd.h         **** unsigned char get_status(void);	//NOT USED!!  get the status from the graphical LCD
  25:lcd.h         **** void moveCursorToColumn(unsigned char uCurSpaces);	//move to a location on the current row
  26:lcd.h         **** void write_pixel_spaces(unsigned char uPixelSpaces);	//write white spaces to the current row on the
  27:lcd.h         **** 
  28:lcd.h         **** 
  29:lcd.h         **** //----------------------------------------------------------------------------
  30:lcd.h         **** //Routine:     InitLCD  (Initialize the LCD)
  31:lcd.h         **** //
  32:lcd.h         **** //Function:    initialization of the Optrex F-51553, 2.8 inch graphical LCD.
  33:lcd.h         **** //
  34:lcd.h         **** //Varibles passed:
  35:lcd.h         **** //       none
  36:lcd.h         **** //Returns:
  37:lcd.h         **** //       none
  38:lcd.h         **** //----------------------------------------------------------------------------
  39:lcd.h         **** 
  40:lcd.h         **** 
  41:lcd.h         **** 
  42:lcd.h         **** //----------------------------------------------------------------------------
  43:lcd.h         **** //Routine:     set_line (set the line number of text to write to the LCD)
  44:lcd.h         **** //
  45:lcd.h         **** //Function:
  46:lcd.h         **** //			Sets the current line for the display to write.  The column is
  47:lcd.h         **** //			set to zero
  48:lcd.h         **** //Varibles passed:
  49:lcd.h         **** //       none
  50:lcd.h         **** //Returns:
  51:lcd.h         **** //       none
  52:lcd.h         **** //----------------------------------------------------------------------------
  53:lcd.h         **** void set_line(unsigned char uLineNumber)
  54:lcd.h         **** {
 4183               	.LM1:
 4184               	/* prologue: frame size=1 */
 4185 0000 CF93      		push r28
 4186 0002 DF93      		push r29
 4187 0004 CDB7      		in r28,__SP_L__
 4188 0006 DEB7      		in r29,__SP_H__
 4189 0008 2197      		sbiw r28,1
 4190 000a 0FB6      		in __tmp_reg__,__SREG__
 4191 000c F894      		cli
 4192 000e DEBF      		out __SP_H__,r29
 4193 0010 0FBE      		out __SREG__,__tmp_reg__
 4194 0012 CDBF      		out __SP_L__,r28
 4195               	/* prologue end (size=10) */
 4196 0014 8983      		std Y+1,r24
  55:lcd.h         ****     //unsigned char uTango=0;
  56:lcd.h         ****     write_command(0x10);	//column address high
 4198               	.LM2:
 4199 0016 80E1      		ldi r24,lo8(16)
 4200 0018 0E94 0000 		call write_command
  57:lcd.h         ****     write_command(0x00);	//column address low
 4202               	.LM3:
 4203 001c 80E0      		ldi r24,lo8(0)
 4204 001e 0E94 0000 		call write_command
  58:lcd.h         **** 
  59:lcd.h         ****     uLineNumber=uLineNumber+0xb0;   //add an offset of B0h to the line number
 4206               	.LM4:
 4207 0022 80EB      		ldi r24,lo8(-80)
 4208 0024 9981      		ldd r25,Y+1
 4209 0026 890F      		add r24,r25
 4210 0028 8983      		std Y+1,r24
  60:lcd.h         ****     write_command(uLineNumber);
 4212               	.LM5:
 4213 002a 8981      		ldd r24,Y+1
 4214 002c 0E94 0000 		call write_command
 4215               	/* epilogue: frame size=1 */
 4216 0030 2196      		adiw r28,1
 4217 0032 0FB6      		in __tmp_reg__,__SREG__
 4218 0034 F894      		cli
 4219 0036 DEBF      		out __SP_H__,r29
 4220 0038 0FBE      		out __SREG__,__tmp_reg__
 4221 003a CDBF      		out __SP_L__,r28
 4222 003c DF91      		pop r29
 4223 003e CF91      		pop r28
 4224 0040 0895      		ret
 4225               	/* epilogue end (size=9) */
 4226               	/* function set_line size 33 (14) */
 4230               	.global	write_data
 4232               	write_data:
  61:lcd.h         ****     //NOTE:  in the orginal 8051 assembly code from Apollo Display this routine fell through
  62:lcd.h         ****     //  to the write_command function.
  63:lcd.h         **** }
  64:lcd.h         **** 
  65:lcd.h         **** 
  66:lcd.h         **** //----------------------------------------------------------------------------
  67:lcd.h         **** //Routine:     write_data (write data to the graphical LCD)
  68:lcd.h         **** //
  69:lcd.h         **** //Function:
  70:lcd.h         **** //		This function serially writes data to the LCD display
  71:lcd.h         **** //Varibles passed:
  72:lcd.h         **** //       none
  73:lcd.h         **** //Returns:
  74:lcd.h         **** //       none
  75:lcd.h         **** //----------------------------------------------------------------------------
  76:lcd.h         **** void write_data(unsigned char uLCDData)
  77:lcd.h         **** {
 4234               	.LM6:
 4235               	/* prologue: frame size=1 */
 4236 0042 CF93      		push r28
 4237 0044 DF93      		push r29
 4238 0046 CDB7      		in r28,__SP_L__
 4239 0048 DEB7      		in r29,__SP_H__
 4240 004a 2197      		sbiw r28,1
 4241 004c 0FB6      		in __tmp_reg__,__SREG__
 4242 004e F894      		cli
 4243 0050 DEBF      		out __SP_H__,r29
 4244 0052 0FBE      		out __SREG__,__tmp_reg__
 4245 0054 CDBF      		out __SP_L__,r28
 4246               	/* prologue end (size=10) */
 4247 0056 8983      		std Y+1,r24
  78:lcd.h         ****     sbi(defLCDContPort,defLcdRD);       //change state on the read line of the LCD
 4249               	.LM7:
 4250 0058 8091 3800 		lds r24,56
 4251 005c 8061      		ori r24,lo8(16)
 4252 005e 8093 3800 		sts 56,r24
  79:lcd.h         ****     sbi(defLCDContPort,defLcdA0);       //set A0 on the LCD for a command
 4254               	.LM8:
 4255 0062 8091 3800 		lds r24,56
 4256 0066 8460      		ori r24,lo8(4)
 4257 0068 8093 3800 		sts 56,r24
  80:lcd.h         ****     cbi(defLCDContPort,defLcdCS1);      //clear the Chip Select on the LCD for
 4259               	.LM9:
 4260 006c 8091 3800 		lds r24,56
 4261 0070 8E7F      		andi r24,lo8(-2)
 4262 0072 8093 3800 		sts 56,r24
  81:lcd.h         ****     cbi(defLCDContPort,defLcdWR);       //change state on the Write line of the LCD
 4264               	.LM10:
 4265 0076 8091 3800 		lds r24,56
 4266 007a 877F      		andi r24,lo8(-9)
 4267 007c 8093 3800 		sts 56,r24
  82:lcd.h         **** 	send_serial_data(uLCDData);					//send the data to the LCD serially
 4269               	.LM11:
 4270 0080 8981      		ldd r24,Y+1
 4271 0082 0E94 0000 		call send_serial_data
  83:lcd.h         ****     sbi(defLCDContPort,defLcdWR);
 4273               	.LM12:
 4274 0086 8091 3800 		lds r24,56
 4275 008a 8860      		ori r24,lo8(8)
 4276 008c 8093 3800 		sts 56,r24
  84:lcd.h         ****     sbi(defLCDContPort,defLcdCS1);      //now set the Chip Select on the LCD
 4278               	.LM13:
 4279 0090 8091 3800 		lds r24,56
 4280 0094 8160      		ori r24,lo8(1)
 4281 0096 8093 3800 		sts 56,r24
  85:lcd.h         ****     cbi(defLCDContPort,defLcdRD);       //change state on the read line of the LCD
 4283               	.LM14:
 4284 009a 8091 3800 		lds r24,56
 4285 009e 8F7E      		andi r24,lo8(-17)
 4286 00a0 8093 3800 		sts 56,r24
 4287               	/* epilogue: frame size=1 */
 4288 00a4 2196      		adiw r28,1
 4289 00a6 0FB6      		in __tmp_reg__,__SREG__
 4290 00a8 F894      		cli
 4291 00aa DEBF      		out __SP_H__,r29
 4292 00ac 0FBE      		out __SREG__,__tmp_reg__
 4293 00ae CDBF      		out __SP_L__,r28
 4294 00b0 DF91      		pop r29
 4295 00b2 CF91      		pop r28
 4296 00b4 0895      		ret
 4297               	/* epilogue end (size=9) */
 4298               	/* function write_data size 58 (39) */
 4302               	.global	send_serial_data
 4304               	send_serial_data:
  86:lcd.h         **** }
  87:lcd.h         **** 
  88:lcd.h         **** 
  89:lcd.h         **** //----------------------------------------------------------------------------
  90:lcd.h         **** //Routine:     send_serial_data  (send serial data to the LCD)
  91:lcd.h         **** //
  92:lcd.h         **** //Function:
  93:lcd.h         **** //
  94:lcd.h         **** //Varibles passed:
  95:lcd.h         **** //       none
  96:lcd.h         **** //Returns:
  97:lcd.h         **** //       none
  98:lcd.h         **** //----------------------------------------------------------------------------
  99:lcd.h         **** void send_serial_data(unsigned char uLCDSerial)
 100:lcd.h         **** {
 4306               	.LM15:
 4307               	/* prologue: frame size=3 */
 4308 00b6 CF93      		push r28
 4309 00b8 DF93      		push r29
 4310 00ba CDB7      		in r28,__SP_L__
 4311 00bc DEB7      		in r29,__SP_H__
 4312 00be 2397      		sbiw r28,3
 4313 00c0 0FB6      		in __tmp_reg__,__SREG__
 4314 00c2 F894      		cli
 4315 00c4 DEBF      		out __SP_H__,r29
 4316 00c6 0FBE      		out __SREG__,__tmp_reg__
 4317 00c8 CDBF      		out __SP_L__,r28
 4318               	/* prologue end (size=10) */
 4319 00ca 8983      		std Y+1,r24
 101:lcd.h         **** 	unsigned char uBitCount;
 102:lcd.h         **** 	unsigned char uLCDTempSerial;
 103:lcd.h         **** 
 104:lcd.h         **** 	uLCDTempSerial=uLCDSerial;	//get the data
 4321               	.LM16:
 4322 00cc 8981      		ldd r24,Y+1
 4323 00ce 8B83      		std Y+3,r24
 105:lcd.h         **** 	uLCDTempSerial=uLCDTempSerial & 0x80;		//clear all the bits but D7
 4325               	.LM17:
 4326 00d0 90E8      		ldi r25,lo8(-128)
 4327 00d2 8B81      		ldd r24,Y+3
 4328 00d4 8923      		and r24,r25
 4329 00d6 8B83      		std Y+3,r24
 106:lcd.h         **** 
 107:lcd.h         ****     //outp(uLCDTempSerial,defLCDDataPort);   //ouput data
 108:lcd.h         **** 	if(uLCDTempSerial==0x80)
 4331               	.LM18:
 4332 00d8 8B81      		ldd r24,Y+3
 4333 00da 8038      		cpi r24,lo8(-128)
 4334 00dc 31F4      		brne .L4
 109:lcd.h         **** 	{
 110:lcd.h         **** 		sbi(defLCDDataPort,defLcdS1);
 4336               	.LM19:
 4337 00de 8091 3B00 		lds r24,59
 4338 00e2 8068      		ori r24,lo8(-128)
 4339 00e4 8093 3B00 		sts 59,r24
 4340 00e8 06C0      		rjmp .L5
 4341               	.L4:
 111:lcd.h         **** 	}
 112:lcd.h         **** 	else
 113:lcd.h         **** 	{
 114:lcd.h         **** 		cbi(defLCDDataPort,defLcdS1);
 4343               	.LM20:
 4344 00ea 8FE7      		ldi r24,lo8(127)
 4345 00ec 9091 3B00 		lds r25,59
 4346 00f0 8923      		and r24,r25
 4347 00f2 8093 3B00 		sts 59,r24
 4348               	.L5:
 115:lcd.h         **** 	}
 116:lcd.h         **** 	asm("nop");
 4350               	.LM21:
 4351               	/* #APP */
 4352 00f6 0000      		nop
 117:lcd.h         **** 	cbi(defLCDDataPort,defLcdSCL);	//clear the clock
 4354               	.LM22:
 4355               	/* #NOAPP */
 4356 00f8 8091 3B00 		lds r24,59
 4357 00fc 8F7B      		andi r24,lo8(-65)
 4358 00fe 8093 3B00 		sts 59,r24
 118:lcd.h         **** 	asm("nop");
 4360               	.LM23:
 4361               	/* #APP */
 4362 0102 0000      		nop
 119:lcd.h         **** 	sbi(defLCDDataPort,defLcdSCL);	//set the clock
 4364               	.LM24:
 4365               	/* #NOAPP */
 4366 0104 8091 3B00 		lds r24,59
 4367 0108 8064      		ori r24,lo8(64)
 4368 010a 8093 3B00 		sts 59,r24
 120:lcd.h         **** 	for(uBitCount=0;uBitCount<7;uBitCount++)
 4370               	.LM25:
 4371 010e 1A82      		std Y+2,__zero_reg__
 4372               	.L6:
 4373 0110 8A81      		ldd r24,Y+2
 4374 0112 8730      		cpi r24,lo8(7)
 4375 0114 50F5      		brsh .L3
 121:lcd.h         **** 	{
 122:lcd.h         **** 		uLCDTempSerial=uLCDSerial;	//get the data
 4377               	.LM26:
 4378 0116 8981      		ldd r24,Y+1
 4379 0118 8B83      		std Y+3,r24
 123:lcd.h         **** 		uLCDTempSerial = uLCDTempSerial << 1;       // shift Bits one left
 4381               	.LM27:
 4382 011a 8B81      		ldd r24,Y+3
 4383 011c 880F      		lsl r24
 4384 011e 8B83      		std Y+3,r24
 124:lcd.h         **** 		uLCDSerial=uLCDTempSerial;	//save the data
 4386               	.LM28:
 4387 0120 8B81      		ldd r24,Y+3
 4388 0122 8983      		std Y+1,r24
 125:lcd.h         **** 		uLCDTempSerial=uLCDTempSerial & 0x80;		//clear all the bits but D7
 4390               	.LM29:
 4391 0124 90E8      		ldi r25,lo8(-128)
 4392 0126 8B81      		ldd r24,Y+3
 4393 0128 8923      		and r24,r25
 4394 012a 8B83      		std Y+3,r24
 126:lcd.h         **** 		//outp(uLCDTempSerial,defLCDDataPort);   //ouput data
 127:lcd.h         **** 		if(uLCDTempSerial==0x80)
 4396               	.LM30:
 4397 012c 8B81      		ldd r24,Y+3
 4398 012e 8038      		cpi r24,lo8(-128)
 4399 0130 31F4      		brne .L9
 128:lcd.h         **** 		{
 129:lcd.h         **** 			sbi(defLCDDataPort,defLcdS1);
 4401               	.LM31:
 4402 0132 8091 3B00 		lds r24,59
 4403 0136 8068      		ori r24,lo8(-128)
 4404 0138 8093 3B00 		sts 59,r24
 4405 013c 06C0      		rjmp .L10
 4406               	.L9:
 130:lcd.h         **** 		}
 131:lcd.h         **** 		else
 132:lcd.h         **** 		{
 133:lcd.h         **** 			cbi(defLCDDataPort,defLcdS1);
 4408               	.LM32:
 4409 013e 8FE7      		ldi r24,lo8(127)
 4410 0140 9091 3B00 		lds r25,59
 4411 0144 8923      		and r24,r25
 4412 0146 8093 3B00 		sts 59,r24
 4413               	.L10:
 134:lcd.h         **** 		}
 135:lcd.h         **** 		asm("nop");
 4415               	.LM33:
 4416               	/* #APP */
 4417 014a 0000      		nop
 136:lcd.h         **** 		cbi(defLCDDataPort,defLcdSCL);	//clear the clock
 4419               	.LM34:
 4420               	/* #NOAPP */
 4421 014c 8091 3B00 		lds r24,59
 4422 0150 8F7B      		andi r24,lo8(-65)
 4423 0152 8093 3B00 		sts 59,r24
 137:lcd.h         **** 		asm("nop");
 4425               	.LM35:
 4426               	/* #APP */
 4427 0156 0000      		nop
 138:lcd.h         **** 		sbi(defLCDDataPort,defLcdSCL);	//set the clock
 4429               	.LM36:
 4430               	/* #NOAPP */
 4431 0158 8091 3B00 		lds r24,59
 4432 015c 8064      		ori r24,lo8(64)
 4433 015e 8093 3B00 		sts 59,r24
 4435               	.LM37:
 4436 0162 8A81      		ldd r24,Y+2
 4437 0164 8F5F      		subi r24,lo8(-(1))
 4438 0166 8A83      		std Y+2,r24
 4439 0168 D3CF      		rjmp .L6
 4440               	.L3:
 4441               	/* epilogue: frame size=3 */
 4442 016a 2396      		adiw r28,3
 4443 016c 0FB6      		in __tmp_reg__,__SREG__
 4444 016e F894      		cli
 4445 0170 DEBF      		out __SP_H__,r29
 4446 0172 0FBE      		out __SREG__,__tmp_reg__
 4447 0174 CDBF      		out __SP_L__,r28
 4448 0176 DF91      		pop r29
 4449 0178 CF91      		pop r28
 4450 017a 0895      		ret
 4451               	/* epilogue end (size=9) */
 4452               	/* function send_serial_data size 103 (84) */
 4459               	.global	write_char
 4461               	write_char:
 139:lcd.h         **** 	}
 140:lcd.h         **** }
 141:lcd.h         **** 
 142:lcd.h         **** //----------------------------------------------------------------------------
 143:lcd.h         **** //Routine:     write_char (write an ASCII character to the display)
 144:lcd.h         **** //
 145:lcd.h         **** //Function:
 146:lcd.h         **** //
 147:lcd.h         **** //       The font file starts at zero, a space.
 148:lcd.h         **** //		Note:  The routine set_line(XX); needs to be called to set the line for
 149:lcd.h         **** //			characters to be displayed upon.
 150:lcd.h         **** //
 151:lcd.h         **** //Varibles passed:
 152:lcd.h         **** //       uWriteLcdChar (the character to write to the LCD)
 153:lcd.h         **** //Returns:
 154:lcd.h         **** //       none
 155:lcd.h         **** //----------------------------------------------------------------------------
 156:lcd.h         **** void write_char(unsigned char uWriteLcdChar, bool boolCharInvert)
 157:lcd.h         **** {
 4463               	.LM38:
 4464               	/* prologue: frame size=9 */
 4465 017c CF93      		push r28
 4466 017e DF93      		push r29
 4467 0180 CDB7      		in r28,__SP_L__
 4468 0182 DEB7      		in r29,__SP_H__
 4469 0184 2997      		sbiw r28,9
 4470 0186 0FB6      		in __tmp_reg__,__SREG__
 4471 0188 F894      		cli
 4472 018a DEBF      		out __SP_H__,r29
 4473 018c 0FBE      		out __SREG__,__tmp_reg__
 4474 018e CDBF      		out __SP_L__,r28
 4475               	/* prologue end (size=10) */
 4476 0190 8983      		std Y+1,r24
 4477 0192 6A83      		std Y+2,r22
 158:lcd.h         **** 	unsigned char uLoaded=0;
 4479               	.LM39:
 4480 0194 1B82      		std Y+3,__zero_reg__
 159:lcd.h         **** 	unsigned char uDelta;
 160:lcd.h         **** 	unsigned int intEpsilon;
 161:lcd.h         **** 
 162:lcd.h         **** 	for(uLoaded=0;uLoaded<5;uLoaded++)
 4482               	.LM40:
 4483 0196 1B82      		std Y+3,__zero_reg__
 4484               	.L12:
 4486               	.LM41:
 4487 0198 8B81      		ldd r24,Y+3
 4488 019a 8530      		cpi r24,lo8(5)
 4489 019c 38F5      		brsh .L13
 163:lcd.h         **** 	{
 164:lcd.h         **** 		intEpsilon=(uWriteLcdChar*5)+uLoaded;	//figure out the offset to the slice of the character
 4491               	.LM42:
 4492 019e 9981      		ldd r25,Y+1
 4493 01a0 85E0      		ldi r24,lo8(5)
 4494 01a2 989F      		mul r25,r24
 4495 01a4 9001      		movw r18,r0
 4496 01a6 1124      		clr r1
 4497 01a8 8B81      		ldd r24,Y+3
 4498 01aa 9927      		clr r25
 4499 01ac 820F      		add r24,r18
 4500 01ae 931F      		adc r25,r19
 4501 01b0 8D83      		std Y+5,r24
 4502 01b2 9E83      		std Y+6,r25
 4503               	.LBB2:
 165:lcd.h         **** 		uDelta=PRG_RDB(&font5x7[intEpsilon]);	//get the raw data character data out of flash
 4505               	.LM43:
 4506 01b4 2D81      		ldd r18,Y+5
 4507 01b6 3E81      		ldd r19,Y+6
 4508 01b8 C901      		movw r24,r18
 4509 01ba 820F      		add r24,r18
 4510 01bc 931F      		adc r25,r19
 4511 01be 8050      		subi r24,lo8(-(font5x7))
 4512 01c0 9040      		sbci r25,hi8(-(font5x7))
 4513 01c2 8F83      		std Y+7,r24
 4514 01c4 9887      		std Y+8,r25
 4515 01c6 EF81      		ldd r30,Y+7
 4516 01c8 F885      		ldd r31,Y+8
 4517               	/* #APP */
 4518 01ca 8491      		lpm r24, Z
 4519               		
 4520               	/* #NOAPP */
 4521 01cc 8987      		std Y+9,r24
 4522               	.LBE2:
 4523 01ce 8985      		ldd r24,Y+9
 4524 01d0 8C83      		std Y+4,r24
 166:lcd.h         **** 		if(boolCharInvert)
 4526               	.LM44:
 4527 01d2 8A81      		ldd r24,Y+2
 4528 01d4 8823      		tst r24
 4529 01d6 19F0      		breq .L15
 167:lcd.h         **** 		{
 168:lcd.h         **** 			uDelta=uDelta^255;
 4531               	.LM45:
 4532 01d8 8C81      		ldd r24,Y+4
 4533 01da 8095      		com r24
 4534 01dc 8C83      		std Y+4,r24
 4535               	.L15:
 169:lcd.h         **** 		}
 170:lcd.h         **** 		write_data(uDelta);		//write the data to the display
 4537               	.LM46:
 4538 01de 8C81      		ldd r24,Y+4
 4539 01e0 0E94 0000 		call write_data
 4541               	.LM47:
 4542 01e4 8B81      		ldd r24,Y+3
 4543 01e6 8F5F      		subi r24,lo8(-(1))
 4544 01e8 8B83      		std Y+3,r24
 4545 01ea D6CF      		rjmp .L12
 4546               	.L13:
 171:lcd.h         **** 	}
 172:lcd.h         **** 
 173:lcd.h         **** 	if(boolCharInvert)	//a blue character on a white background
 4548               	.LM48:
 4549 01ec 8A81      		ldd r24,Y+2
 4550 01ee 8823      		tst r24
 4551 01f0 21F0      		breq .L16
 174:lcd.h         **** 	{
 175:lcd.h         **** 		write_data(0xff);	//this puts a verticle, on pixel space between characters
 4553               	.LM49:
 4554 01f2 8FEF      		ldi r24,lo8(-1)
 4555 01f4 0E94 0000 		call write_data
 4556 01f8 03C0      		rjmp .L11
 4557               	.L16:
 176:lcd.h         **** 	}
 177:lcd.h         **** 	else	//a white character on a blue background
 178:lcd.h         **** 	{
 179:lcd.h         **** 		write_data(0x00);	//This puts a verticle, off pixel space between characters
 4559               	.LM50:
 4560 01fa 80E0      		ldi r24,lo8(0)
 4561 01fc 0E94 0000 		call write_data
 4562               	.L11:
 4563               	/* epilogue: frame size=9 */
 4564 0200 2996      		adiw r28,9
 4565 0202 0FB6      		in __tmp_reg__,__SREG__
 4566 0204 F894      		cli
 4567 0206 DEBF      		out __SP_H__,r29
 4568 0208 0FBE      		out __SREG__,__tmp_reg__
 4569 020a CDBF      		out __SP_L__,r28
 4570 020c DF91      		pop r29
 4571 020e CF91      		pop r28
 4572 0210 0895      		ret
 4573               	/* epilogue end (size=9) */
 4574               	/* function write_char size 78 (59) */
 4584               	.global	clear_display
 4586               	clear_display:
 180:lcd.h         **** 	}
 181:lcd.h         **** 
 182:lcd.h         **** }
 183:lcd.h         **** 
 184:lcd.h         **** //----------------------------------------------------------------------------
 185:lcd.h         **** //Routine:     clear_display (clears the currently displayed screen)
 186:lcd.h         **** //
 187:lcd.h         **** //Function:
 188:lcd.h         **** //
 189:lcd.h         **** //		This function steps through the 8 rows on the 128x64 pixel LCD display and
 190:lcd.h         **** //		turns off all the display bits.
 191:lcd.h         **** //
 192:lcd.h         **** //Varibles passed:
 193:lcd.h         **** //       none
 194:lcd.h         **** //Returns:
 195:lcd.h         **** //       none
 196:lcd.h         **** //----------------------------------------------------------------------------
 197:lcd.h         **** void clear_display(void)
 198:lcd.h         **** {
 4588               	.LM51:
 4589               	/* prologue: frame size=2 */
 4590 0212 CF93      		push r28
 4591 0214 DF93      		push r29
 4592 0216 CDB7      		in r28,__SP_L__
 4593 0218 DEB7      		in r29,__SP_H__
 4594 021a 2297      		sbiw r28,2
 4595 021c 0FB6      		in __tmp_reg__,__SREG__
 4596 021e F894      		cli
 4597 0220 DEBF      		out __SP_H__,r29
 4598 0222 0FBE      		out __SREG__,__tmp_reg__
 4599 0224 CDBF      		out __SP_L__,r28
 4600               	/* prologue end (size=10) */
 199:lcd.h         **** 	unsigned char uVertPix=0;
 4602               	.LM52:
 4603 0226 1982      		std Y+1,__zero_reg__
 200:lcd.h         **** 	unsigned char uCurrLine=0;
 4605               	.LM53:
 4606 0228 1A82      		std Y+2,__zero_reg__
 201:lcd.h         **** 
 202:lcd.h         **** 	for(uCurrLine=0;uCurrLine<8;uCurrLine++)
 4608               	.LM54:
 4609 022a 1A82      		std Y+2,__zero_reg__
 4610               	.L19:
 4612               	.LM55:
 4613 022c 8A81      		ldd r24,Y+2
 4614 022e 8830      		cpi r24,lo8(8)
 4615 0230 90F4      		brsh .L18
 203:lcd.h         **** 	{
 204:lcd.h         **** 		set_line(uCurrLine);	//sets the current line to display information upon
 4617               	.LM56:
 4618 0232 8A81      		ldd r24,Y+2
 4619 0234 0E94 0000 		call set_line
 205:lcd.h         **** 		for(uVertPix=0;uVertPix<=128;uVertPix++)	//step through the 128 bytes on each row on the LCD
 4621               	.LM57:
 4622 0238 1982      		std Y+1,__zero_reg__
 4623               	.L22:
 4624 023a 8981      		ldd r24,Y+1
 4625 023c 8138      		cpi r24,lo8(-127)
 4626 023e 38F4      		brsh .L21
 206:lcd.h         **** 		{
 207:lcd.h         **** 			write_data(0);		//clear off the current byte in the LCD
 4628               	.LM58:
 4629 0240 80E0      		ldi r24,lo8(0)
 4630 0242 0E94 0000 		call write_data
 4632               	.LM59:
 4633 0246 8981      		ldd r24,Y+1
 4634 0248 8F5F      		subi r24,lo8(-(1))
 4635 024a 8983      		std Y+1,r24
 4636 024c F6CF      		rjmp .L22
 4637               	.L21:
 4639               	.LM60:
 4640 024e 8A81      		ldd r24,Y+2
 4641 0250 8F5F      		subi r24,lo8(-(1))
 4642 0252 8A83      		std Y+2,r24
 4643 0254 EBCF      		rjmp .L19
 4644               	.L18:
 4645               	/* epilogue: frame size=2 */
 4646 0256 2296      		adiw r28,2
 4647 0258 0FB6      		in __tmp_reg__,__SREG__
 4648 025a F894      		cli
 4649 025c DEBF      		out __SP_H__,r29
 4650 025e 0FBE      		out __SREG__,__tmp_reg__
 4651 0260 CDBF      		out __SP_L__,r28
 4652 0262 DF91      		pop r29
 4653 0264 CF91      		pop r28
 4654 0266 0895      		ret
 4655               	/* epilogue end (size=9) */
 4656               	/* function clear_display size 43 (24) */
 4661               	.global	get_status
 4663               	get_status:
 208:lcd.h         **** 		}
 209:lcd.h         **** 	}
 210:lcd.h         **** }
 211:lcd.h         **** 
 212:lcd.h         **** //----------------------------------------------------------------------------
 213:lcd.h         **** //Routine:     get_status (get the status from the graphical LCD)
 214:lcd.h         **** //
 215:lcd.h         **** //Function:
 216:lcd.h         **** //		Is this only for a parallel bus?
 217:lcd.h         **** //Varibles passed:
 218:lcd.h         **** //       none
 219:lcd.h         **** //Returns:
 220:lcd.h         **** //       none
 221:lcd.h         **** //----------------------------------------------------------------------------
 222:lcd.h         **** unsigned char get_status(void)
 223:lcd.h         **** {
 4665               	.LM61:
 4666               	/* prologue: frame size=1 */
 4667 0268 CF93      		push r28
 4668 026a DF93      		push r29
 4669 026c CDB7      		in r28,__SP_L__
 4670 026e DEB7      		in r29,__SP_H__
 4671 0270 2197      		sbiw r28,1
 4672 0272 0FB6      		in __tmp_reg__,__SREG__
 4673 0274 F894      		cli
 4674 0276 DEBF      		out __SP_H__,r29
 4675 0278 0FBE      		out __SREG__,__tmp_reg__
 4676 027a CDBF      		out __SP_L__,r28
 4677               	/* prologue end (size=10) */
 224:lcd.h         ****     unsigned char uLCDStatus;
 225:lcd.h         **** 
 226:lcd.h         ****     //outp(0xFF,defLCDDataPort);   //release the data bus
 227:lcd.h         **** 	sbi(defLCDDataPort,defLcdS1);
 4679               	.LM62:
 4680 027c 8091 3B00 		lds r24,59
 4681 0280 8068      		ori r24,lo8(-128)
 4682 0282 8093 3B00 		sts 59,r24
 228:lcd.h         **** 	sbi(defLCDDataPort,defLcdSCL);
 4684               	.LM63:
 4685 0286 8091 3B00 		lds r24,59
 4686 028a 8064      		ori r24,lo8(64)
 4687 028c 8093 3B00 		sts 59,r24
 229:lcd.h         **** 
 230:lcd.h         ****     cbi(defLCDContPort,defLcdA0);       //clear A0 on the LCD for a command
 4689               	.LM64:
 4690 0290 8091 3800 		lds r24,56
 4691 0294 8B7F      		andi r24,lo8(-5)
 4692 0296 8093 3800 		sts 56,r24
 231:lcd.h         ****     cbi(defLCDContPort,defLcdCS1);      //clear the Chip Select on the LCD for
 4694               	.LM65:
 4695 029a 8091 3800 		lds r24,56
 4696 029e 8E7F      		andi r24,lo8(-2)
 4697 02a0 8093 3800 		sts 56,r24
 232:lcd.h         ****     cbi(defLCDContPort,defLcdRD);       //clear the Read line on the LCD
 4699               	.LM66:
 4700 02a4 8091 3800 		lds r24,56
 4701 02a8 8F7E      		andi r24,lo8(-17)
 4702 02aa 8093 3800 		sts 56,r24
 233:lcd.h         ****     uLCDStatus=inp(defLCDDataPort);
 4704               	.LM67:
 4705 02ae 8091 3B00 		lds r24,59
 4706 02b2 8983      		std Y+1,r24
 234:lcd.h         ****     sbi(defLCDContPort,defLcdRD);       //set the Read line on the LCD
 4708               	.LM68:
 4709 02b4 8091 3800 		lds r24,56
 4710 02b8 8061      		ori r24,lo8(16)
 4711 02ba 8093 3800 		sts 56,r24
 235:lcd.h         ****     sbi(defLCDContPort,defLcdCS1);      //set the Chip Select line on the LCD
 4713               	.LM69:
 4714 02be 8091 3800 		lds r24,56
 4715 02c2 8160      		ori r24,lo8(1)
 4716 02c4 8093 3800 		sts 56,r24
 236:lcd.h         ****     return(uLCDStatus);
 4718               	.LM70:
 4719 02c8 8981      		ldd r24,Y+1
 4720 02ca 9927      		clr r25
 4721               	/* epilogue: frame size=1 */
 4722 02cc 2196      		adiw r28,1
 4723 02ce 0FB6      		in __tmp_reg__,__SREG__
 4724 02d0 F894      		cli
 4725 02d2 DEBF      		out __SP_H__,r29
 4726 02d4 0FBE      		out __SREG__,__tmp_reg__
 4727 02d6 CDBF      		out __SP_L__,r28
 4728 02d8 DF91      		pop r29
 4729 02da CF91      		pop r28
 4730 02dc 0895      		ret
 4731               	/* epilogue end (size=9) */
 4732               	/* function get_status size 59 (40) */
 4737               	.global	moveCursorToColumn
 4739               	moveCursorToColumn:
 237:lcd.h         **** }
 238:lcd.h         **** 
 239:lcd.h         **** //----------------------------------------------------------------------------
 240:lcd.h         **** //Routine:     moveCursorToColumn (moves the cursor to a specific location
 241:lcd.h         **** //
 242:lcd.h         **** //Function:
 243:lcd.h         **** //				This function moves the current cursor on the row to whatever
 244:lcd.h         **** //				column number is passed to it.  The command to the LCD to move the
 245:lcd.h         **** //				cursor takes two bytes.  The high byte is in the format 0x1* and the
 246:lcd.h         **** //				low byte is in the format 0x0*.  (where * is a number from 0x00 to
 247:lcd.h         **** //				0x0f.
 248:lcd.h         **** //Varibles passed:
 249:lcd.h         **** //       uCurSpaces (the number of spaces from the left of the display)
 250:lcd.h         **** //Returns:
 251:lcd.h         **** //       none
 252:lcd.h         **** //----------------------------------------------------------------------------
 253:lcd.h         **** void moveCursorToColumn(unsigned char uCurSpaces)
 254:lcd.h         **** {
 4741               	.LM71:
 4742               	/* prologue: frame size=2 */
 4743 02de CF93      		push r28
 4744 02e0 DF93      		push r29
 4745 02e2 CDB7      		in r28,__SP_L__
 4746 02e4 DEB7      		in r29,__SP_H__
 4747 02e6 2297      		sbiw r28,2
 4748 02e8 0FB6      		in __tmp_reg__,__SREG__
 4749 02ea F894      		cli
 4750 02ec DEBF      		out __SP_H__,r29
 4751 02ee 0FBE      		out __SREG__,__tmp_reg__
 4752 02f0 CDBF      		out __SP_L__,r28
 4753               	/* prologue end (size=10) */
 4754 02f2 8983      		std Y+1,r24
 255:lcd.h         **** 	unsigned char x;
 256:lcd.h         **** 
 257:lcd.h         **** 	x=uCurSpaces & 0xF0;	//first, we get rid of the low nibble
 4756               	.LM72:
 4757 02f4 90EF      		ldi r25,lo8(-16)
 4758 02f6 8981      		ldd r24,Y+1
 4759 02f8 8923      		and r24,r25
 4760 02fa 8A83      		std Y+2,r24
 258:lcd.h         **** 	x=x>>1;		//then, we shift the high nibble down to the low nibble
 4762               	.LM73:
 4763 02fc 8A81      		ldd r24,Y+2
 4764 02fe 8695      		lsr r24
 4765 0300 8A83      		std Y+2,r24
 259:lcd.h         **** 	x=x>>1;
 4767               	.LM74:
 4768 0302 8A81      		ldd r24,Y+2
 4769 0304 8695      		lsr r24
 4770 0306 8A83      		std Y+2,r24
 260:lcd.h         **** 	x=x>>1;
 4772               	.LM75:
 4773 0308 8A81      		ldd r24,Y+2
 4774 030a 8695      		lsr r24
 4775 030c 8A83      		std Y+2,r24
 261:lcd.h         **** 	x=x>>1;
 4777               	.LM76:
 4778 030e 8A81      		ldd r24,Y+2
 4779 0310 8695      		lsr r24
 4780 0312 8A83      		std Y+2,r24
 262:lcd.h         **** 	x=x+0x10;	//we then add 0x10 to it to tell the LCD it is a column address
 4782               	.LM77:
 4783 0314 8A81      		ldd r24,Y+2
 4784 0316 805F      		subi r24,lo8(-(16))
 4785 0318 8A83      		std Y+2,r24
 263:lcd.h         **** 	write_command(x);	//set the high byte of the column address
 4787               	.LM78:
 4788 031a 8A81      		ldd r24,Y+2
 4789 031c 0E94 0000 		call write_command
 264:lcd.h         **** 	x=uCurSpaces & 0x0F;	//next, we get rid of the orginal high nibble
 4791               	.LM79:
 4792 0320 8981      		ldd r24,Y+1
 4793 0322 8F70      		andi r24,lo8(15)
 4794 0324 8A83      		std Y+2,r24
 265:lcd.h         **** 	write_command(x);	//set the low byte of the column address
 4796               	.LM80:
 4797 0326 8A81      		ldd r24,Y+2
 4798 0328 0E94 0000 		call write_command
 4799               	/* epilogue: frame size=2 */
 4800 032c 2296      		adiw r28,2
 4801 032e 0FB6      		in __tmp_reg__,__SREG__
 4802 0330 F894      		cli
 4803 0332 DEBF      		out __SP_H__,r29
 4804 0334 0FBE      		out __SREG__,__tmp_reg__
 4805 0336 CDBF      		out __SP_L__,r28
 4806 0338 DF91      		pop r29
 4807 033a CF91      		pop r28
 4808 033c 0895      		ret
 4809               	/* epilogue end (size=9) */
 4810               	/* function moveCursorToColumn size 48 (29) */
 4815               	.global	write_pixel_spaces
 4817               	write_pixel_spaces:
 266:lcd.h         **** }
 267:lcd.h         **** 
 268:lcd.h         **** //----------------------------------------------------------------------------
 269:lcd.h         **** //Routine:     write_pixel_spaces (write spaces to a row)
 270:lcd.h         **** //
 271:lcd.h         **** //Function:
 272:lcd.h         **** //			This function fills pixels with white spaces.  For Example,
 273:lcd.h         **** //			if the number passed to it is one, it writes in 8 verticle pixels that
 274:lcd.h         **** //			are not active on the current row.
 275:lcd.h         **** //Varibles passed:
 276:lcd.h         **** //       uPixelSpaces
 277:lcd.h         **** //Returns:
 278:lcd.h         **** //       none
 279:lcd.h         **** //----------------------------------------------------------------------------
 280:lcd.h         **** void write_pixel_spaces(unsigned char uPixelSpaces)
 281:lcd.h         **** {
 4819               	.LM81:
 4820               	/* prologue: frame size=2 */
 4821 033e CF93      		push r28
 4822 0340 DF93      		push r29
 4823 0342 CDB7      		in r28,__SP_L__
 4824 0344 DEB7      		in r29,__SP_H__
 4825 0346 2297      		sbiw r28,2
 4826 0348 0FB6      		in __tmp_reg__,__SREG__
 4827 034a F894      		cli
 4828 034c DEBF      		out __SP_H__,r29
 4829 034e 0FBE      		out __SREG__,__tmp_reg__
 4830 0350 CDBF      		out __SP_L__,r28
 4831               	/* prologue end (size=10) */
 4832 0352 8983      		std Y+1,r24
 282:lcd.h         **** 	unsigned char r;
 283:lcd.h         **** 
 284:lcd.h         **** 	for(r=0;r<uPixelSpaces;r++)
 4834               	.LM82:
 4835 0354 1A82      		std Y+2,__zero_reg__
 4836               	.L28:
 4838               	.LM83:
 4839 0356 9A81      		ldd r25,Y+2
 4840 0358 8981      		ldd r24,Y+1
 4841 035a 9817      		cp r25,r24
 4842 035c 38F4      		brsh .L27
 285:lcd.h         **** 	{
 286:lcd.h         **** 		write_data(00);		//write the data to the display
 4844               	.LM84:
 4845 035e 80E0      		ldi r24,lo8(0)
 4846 0360 0E94 0000 		call write_data
 4848               	.LM85:
 4849 0364 8A81      		ldd r24,Y+2
 4850 0366 8F5F      		subi r24,lo8(-(1))
 4851 0368 8A83      		std Y+2,r24
 4852 036a F5CF      		rjmp .L28
 4853               	.L27:
 4854               	/* epilogue: frame size=2 */
 4855 036c 2296      		adiw r28,2
 4856 036e 0FB6      		in __tmp_reg__,__SREG__
 4857 0370 F894      		cli
 4858 0372 DEBF      		out __SP_H__,r29
 4859 0374 0FBE      		out __SREG__,__tmp_reg__
 4860 0376 CDBF      		out __SP_L__,r28
 4861 0378 DF91      		pop r29
 4862 037a CF91      		pop r28
 4863 037c 0895      		ret
 4864               	/* epilogue end (size=9) */
 4865               	/* function write_pixel_spaces size 32 (13) */
 4871               	.global	alphabet
 4873               	alphabet:
 4875               	.Ltext2:
   1:display.h     **** /*
   2:display.h     **** Author:  Matt Meerian
   3:display.h     **** Date:  January 21, 2005
   4:display.h     **** Target Processor:  ATMEGA8535 from Atmel
   5:display.h     **** Languate used:  AVR GCC compiler (in the "C" language)
   6:display.h     **** Overview:
   7:display.h     **** 	This file will be used to test the basic operation of the 128x64 pixel,
   8:display.h     **** 	2.8", blue and white, LCD from Optrex.  (Part Number F-51553GNBJ-LW-AB)  The
   9:display.h     **** 	hardware interface will be through a demo board from Apollo Display.  (Part
  10:display.h     **** 	Number:  F-51553-Eval
  11:display.h     **** 	Writes different things to the LCD screen.
  12:display.h     **** */
  13:display.h     **** 
  14:display.h     **** //#include <define.h>
  15:display.h     **** 
  16:display.h     **** void alphabet(void);		//display the alphabet
  17:display.h     **** void kustom_image(void);
  18:display.h     **** void stop_image(void);
  19:display.h     **** void BigDigits(unsigned char uStartRow, unsigned char uStartColumn, unsigned int intNumber, unsigne
  20:display.h     **** void write_eagle_display(void);	//write a bit-mapped image to the LCD
  21:display.h     **** void drawText(unsigned char *pts,unsigned char uPosition, unsigned char uRow, bool boolInvert);
  22:display.h     **** void subLargeCOlon(unsigned char uStartRow, unsigned char uStartColumn, bool boolInvert);
  23:display.h     **** 
  24:display.h     **** //----------------------------------------------------------------------------
  25:display.h     **** //Routine:     alphabet ()
  26:display.h     **** //
  27:display.h     **** //Function:
  28:display.h     **** //		This writes all the characters in the font set to the LCD display.
  29:display.h     **** //		Starts at the top left of the screen and ends at the bottom right
  30:display.h     **** //		of the screen
  31:display.h     **** //
  32:display.h     **** //Varibles passed:
  33:display.h     **** //       none
  34:display.h     **** //Returns:
  35:display.h     **** //       none
  36:display.h     **** //----------------------------------------------------------------------------
  37:display.h     **** void alphabet(void)
  38:display.h     **** {	
 4877               	.LM86:
 4878               	/* prologue: frame size=10 */
 4879 037e CF93      		push r28
 4880 0380 DF93      		push r29
 4881 0382 CDB7      		in r28,__SP_L__
 4882 0384 DEB7      		in r29,__SP_H__
 4883 0386 2A97      		sbiw r28,10
 4884 0388 0FB6      		in __tmp_reg__,__SREG__
 4885 038a F894      		cli
 4886 038c DEBF      		out __SP_H__,r29
 4887 038e 0FBE      		out __SREG__,__tmp_reg__
 4888 0390 CDBF      		out __SP_L__,r28
 4889               	/* prologue end (size=10) */
  39:display.h     **** 	unsigned char uAlphaLine=0;
 4891               	.LM87:
 4892 0392 1982      		std Y+1,__zero_reg__
  40:display.h     **** 	unsigned char uAlpha;
  41:display.h     **** 	unsigned char uBeta;
  42:display.h     **** 	unsigned char uGama=0x00;
 4894               	.LM88:
 4895 0394 1C82      		std Y+4,__zero_reg__
  43:display.h     **** 	unsigned char uDelta;
  44:display.h     **** 	unsigned int intEpsilon;
  45:display.h     **** 
  46:display.h     **** 	for(uAlphaLine=0;uAlphaLine<8;uAlphaLine++)
 4897               	.LM89:
 4898 0396 1982      		std Y+1,__zero_reg__
 4899               	.L32:
 4901               	.LM90:
 4902 0398 8981      		ldd r24,Y+1
 4903 039a 8830      		cpi r24,lo8(8)
 4904 039c 08F0      		brlo .+2
 4905 039e 3EC0      		rjmp .L31
  47:display.h     **** 	{
  48:display.h     **** 		set_line(uAlphaLine);	//set the line for writing
 4907               	.LM91:
 4908 03a0 8981      		ldd r24,Y+1
 4909 03a2 0E94 0000 		call set_line
  49:display.h     **** 		for(uAlpha=0;uAlpha<21;uAlpha++)
 4911               	.LM92:
 4912 03a6 1A82      		std Y+2,__zero_reg__
 4913               	.L35:
 4914 03a8 8A81      		ldd r24,Y+2
 4915 03aa 8531      		cpi r24,lo8(21)
 4916 03ac 98F5      		brsh .L34
  50:display.h     **** 		{			
  51:display.h     **** 			if(uGama>95)	//have we got to the end of the font set?
 4918               	.LM93:
 4919 03ae 8C81      		ldd r24,Y+4
 4920 03b0 8036      		cpi r24,lo8(96)
 4921 03b2 08F0      		brlo .L38
  52:display.h     **** 			{
  53:display.h     **** 				uGama=0x00;	//yes, we got to the end, reset the font character counter
 4923               	.LM94:
 4924 03b4 1C82      		std Y+4,__zero_reg__
 4925               	.L38:
  54:display.h     **** 			}
  55:display.h     **** 			for(uBeta=0;uBeta<5;uBeta++)	//This steps through the 5 characters for the ASCII character
 4927               	.LM95:
 4928 03b6 1B82      		std Y+3,__zero_reg__
 4929               	.L39:
 4930 03b8 8B81      		ldd r24,Y+3
 4931 03ba 8530      		cpi r24,lo8(5)
 4932 03bc 08F5      		brsh .L40
  56:display.h     **** 			{
  57:display.h     **** 				intEpsilon=(uGama*5)+uBeta;	//figure out the offset to the slice of the character
 4934               	.LM96:
 4935 03be 9C81      		ldd r25,Y+4
 4936 03c0 85E0      		ldi r24,lo8(5)
 4937 03c2 989F      		mul r25,r24
 4938 03c4 9001      		movw r18,r0
 4939 03c6 1124      		clr r1
 4940 03c8 8B81      		ldd r24,Y+3
 4941 03ca 9927      		clr r25
 4942 03cc 820F      		add r24,r18
 4943 03ce 931F      		adc r25,r19
 4944 03d0 8E83      		std Y+6,r24
 4945 03d2 9F83      		std Y+7,r25
 4946               	.LBB3:
  58:display.h     **** 				uDelta=PRG_RDB(&font5x7[intEpsilon]);	//get the raw data character data out of flash
 4948               	.LM97:
 4949 03d4 2E81      		ldd r18,Y+6
 4950 03d6 3F81      		ldd r19,Y+7
 4951 03d8 C901      		movw r24,r18
 4952 03da 820F      		add r24,r18
 4953 03dc 931F      		adc r25,r19
 4954 03de 8050      		subi r24,lo8(-(font5x7))
 4955 03e0 9040      		sbci r25,hi8(-(font5x7))
 4956 03e2 8887      		std Y+8,r24
 4957 03e4 9987      		std Y+9,r25
 4958 03e6 E885      		ldd r30,Y+8
 4959 03e8 F985      		ldd r31,Y+9
 4960               	/* #APP */
 4961 03ea 8491      		lpm r24, Z
 4962               		
 4963               	/* #NOAPP */
 4964 03ec 8A87      		std Y+10,r24
 4965               	.LBE3:
 4966 03ee 8A85      		ldd r24,Y+10
 4967 03f0 8D83      		std Y+5,r24
  59:display.h     **** 				write_data(uDelta);		//write the data to the display
 4969               	.LM98:
 4970 03f2 8D81      		ldd r24,Y+5
 4971 03f4 0E94 0000 		call write_data
 4973               	.LM99:
 4974 03f8 8B81      		ldd r24,Y+3
 4975 03fa 8F5F      		subi r24,lo8(-(1))
 4976 03fc 8B83      		std Y+3,r24
 4977 03fe DCCF      		rjmp .L39
 4978               	.L40:
  60:display.h     **** 			}
  61:display.h     **** 			write_data(0);	//put in a space between characters
 4980               	.LM100:
 4981 0400 80E0      		ldi r24,lo8(0)
 4982 0402 0E94 0000 		call write_data
  62:display.h     **** 			uGama=uGama+1;
 4984               	.LM101:
 4985 0406 8C81      		ldd r24,Y+4
 4986 0408 8F5F      		subi r24,lo8(-(1))
 4987 040a 8C83      		std Y+4,r24
 4989               	.LM102:
 4990 040c 8A81      		ldd r24,Y+2
 4991 040e 8F5F      		subi r24,lo8(-(1))
 4992 0410 8A83      		std Y+2,r24
 4993 0412 CACF      		rjmp .L35
 4994               	.L34:
 4996               	.LM103:
 4997 0414 8981      		ldd r24,Y+1
 4998 0416 8F5F      		subi r24,lo8(-(1))
 4999 0418 8983      		std Y+1,r24
 5000 041a BECF      		rjmp .L32
 5001               	.L31:
 5002               	/* epilogue: frame size=10 */
 5003 041c 2A96      		adiw r28,10
 5004 041e 0FB6      		in __tmp_reg__,__SREG__
 5005 0420 F894      		cli
 5006 0422 DEBF      		out __SP_H__,r29
 5007 0424 0FBE      		out __SREG__,__tmp_reg__
 5008 0426 CDBF      		out __SP_L__,r28
 5009 0428 DF91      		pop r29
 5010 042a CF91      		pop r28
 5011 042c 0895      		ret
 5012               	/* epilogue end (size=9) */
 5013               	/* function alphabet size 91 (72) */
 5026               	.global	kustom_image
 5028               	kustom_image:
  63:display.h     **** 		}
  64:display.h     **** 	}
  65:display.h     **** }
  66:display.h     **** 
  67:display.h     **** //----------------------------------------------------------------------------
  68:display.h     **** //Routine:     kustom_image (write the kustom signals logo to the full screen)
  69:display.h     **** //
  70:display.h     **** //Function:
  71:display.h     **** //
  72:display.h     **** //Varibles passed:
  73:display.h     **** //       none
  74:display.h     **** //Returns:
  75:display.h     **** //       none
  76:display.h     **** //----------------------------------------------------------------------------
  77:display.h     **** void kustom_image(void)
  78:display.h     **** {
 5030               	.LM104:
 5031               	/* prologue: frame size=6 */
 5032 042e CF93      		push r28
 5033 0430 DF93      		push r29
 5034 0432 CDB7      		in r28,__SP_L__
 5035 0434 DEB7      		in r29,__SP_H__
 5036 0436 2697      		sbiw r28,6
 5037 0438 0FB6      		in __tmp_reg__,__SREG__
 5038 043a F894      		cli
 5039 043c DEBF      		out __SP_H__,r29
 5040 043e 0FBE      		out __SREG__,__tmp_reg__
 5041 0440 CDBF      		out __SP_L__,r28
 5042               	/* prologue end (size=10) */
  79:display.h     **** 	unsigned int uByteCounter;		//count off every byte, there are 128 bytes in each row
  80:display.h     **** 	unsigned char uRowCounter;		//count off all 8 rows on the screen
  81:display.h     **** 	
  82:display.h     **** 	for(uRowCounter=0;uRowCounter<8;uRowCounter++)		//there are 8 rows to write
 5044               	.LM105:
 5045 0442 1B82      		std Y+3,__zero_reg__
 5046               	.L43:
 5048               	.LM106:
 5049 0444 8B81      		ldd r24,Y+3
 5050 0446 8830      		cpi r24,lo8(8)
 5051 0448 58F5      		brsh .L42
  83:display.h     **** 	{
  84:display.h     **** 		set_line(uRowCounter);	//set the row for writing
 5053               	.LM107:
 5054 044a 8B81      		ldd r24,Y+3
 5055 044c 0E94 0000 		call set_line
  85:display.h     **** 		for(uByteCounter=0;uByteCounter<127;uByteCounter++)	//128 bytes of data in each row
 5057               	.LM108:
 5058 0450 1982      		std Y+1,__zero_reg__
 5059 0452 1A82      		std Y+2,__zero_reg__
 5060               	.L46:
 5061 0454 8981      		ldd r24,Y+1
 5062 0456 9A81      		ldd r25,Y+2
 5063 0458 8F37      		cpi r24,127
 5064 045a 9105      		cpc r25,__zero_reg__
 5065 045c E8F4      		brsh .L45
 5066               	.LBB4:
  86:display.h     **** 		{
  87:display.h     **** 			write_data(PRG_RDB(&strKustom[(128*uRowCounter)+uByteCounter]));	//get the raw data
 5068               	.LM109:
 5069 045e 8B81      		ldd r24,Y+3
 5070 0460 9927      		clr r25
 5071 0462 9C01      		movw r18,r24
 5072 0464 3695      		lsr r19
 5073 0466 322F      		mov r19,r18
 5074 0468 2227      		clr r18
 5075 046a 3795      		ror r19
 5076 046c 2795      		ror r18
 5077 046e 8981      		ldd r24,Y+1
 5078 0470 9A81      		ldd r25,Y+2
 5079 0472 820F      		add r24,r18
 5080 0474 931F      		adc r25,r19
 5081 0476 8050      		subi r24,lo8(-(strKustom))
 5082 0478 9040      		sbci r25,hi8(-(strKustom))
 5083 047a 8C83      		std Y+4,r24
 5084 047c 9D83      		std Y+5,r25
 5085 047e EC81      		ldd r30,Y+4
 5086 0480 FD81      		ldd r31,Y+5
 5087               	/* #APP */
 5088 0482 8491      		lpm r24, Z
 5089               		
 5090               	/* #NOAPP */
 5091 0484 8E83      		std Y+6,r24
 5092               	.LBE4:
 5093 0486 8E81      		ldd r24,Y+6
 5094 0488 0E94 0000 		call write_data
 5096               	.LM110:
 5097 048c 8981      		ldd r24,Y+1
 5098 048e 9A81      		ldd r25,Y+2
 5099 0490 0196      		adiw r24,1
 5100 0492 8983      		std Y+1,r24
 5101 0494 9A83      		std Y+2,r25
 5102 0496 DECF      		rjmp .L46
 5103               	.L45:
 5105               	.LM111:
 5106 0498 8B81      		ldd r24,Y+3
 5107 049a 8F5F      		subi r24,lo8(-(1))
 5108 049c 8B83      		std Y+3,r24
 5109 049e D2CF      		rjmp .L43
 5110               	.L42:
 5111               	/* epilogue: frame size=6 */
 5112 04a0 2696      		adiw r28,6
 5113 04a2 0FB6      		in __tmp_reg__,__SREG__
 5114 04a4 F894      		cli
 5115 04a6 DEBF      		out __SP_H__,r29
 5116 04a8 0FBE      		out __SREG__,__tmp_reg__
 5117 04aa CDBF      		out __SP_L__,r28
 5118 04ac DF91      		pop r29
 5119 04ae CF91      		pop r28
 5120 04b0 0895      		ret
 5121               	/* epilogue end (size=9) */
 5122               	/* function kustom_image size 69 (50) */
 5131               	.global	stop_image
 5133               	stop_image:
  88:display.h     **** 			//  character data out of flash, 128 bytes for each row of data.
  89:display.h     **** 		}
  90:display.h     **** 	}
  91:display.h     **** }
  92:display.h     **** 
  93:display.h     **** void stop_image(void)
  94:display.h     **** {
 5135               	.LM112:
 5136               	/* prologue: frame size=6 */
 5137 04b2 CF93      		push r28
 5138 04b4 DF93      		push r29
 5139 04b6 CDB7      		in r28,__SP_L__
 5140 04b8 DEB7      		in r29,__SP_H__
 5141 04ba 2697      		sbiw r28,6
 5142 04bc 0FB6      		in __tmp_reg__,__SREG__
 5143 04be F894      		cli
 5144 04c0 DEBF      		out __SP_H__,r29
 5145 04c2 0FBE      		out __SREG__,__tmp_reg__
 5146 04c4 CDBF      		out __SP_L__,r28
 5147               	/* prologue end (size=10) */
  95:display.h     **** 	unsigned int uByteCounter;		//count off every byte, there are 128 bytes in each row
  96:display.h     **** 	unsigned char uRowCounter;		//count off all 8 rows on the screen
  97:display.h     **** 	
  98:display.h     **** 	for(uRowCounter=0;uRowCounter<8;uRowCounter++)		//there are 8 rows to write
 5149               	.LM113:
 5150 04c6 1B82      		std Y+3,__zero_reg__
 5151               	.L50:
 5153               	.LM114:
 5154 04c8 8B81      		ldd r24,Y+3
 5155 04ca 8830      		cpi r24,lo8(8)
 5156 04cc 58F5      		brsh .L49
  99:display.h     **** 	{
 100:display.h     **** 		set_line(uRowCounter);	//set the row for writing
 5158               	.LM115:
 5159 04ce 8B81      		ldd r24,Y+3
 5160 04d0 0E94 0000 		call set_line
 101:display.h     **** 		for(uByteCounter=0;uByteCounter<127;uByteCounter++)	//128 bytes of data in each row
 5162               	.LM116:
 5163 04d4 1982      		std Y+1,__zero_reg__
 5164 04d6 1A82      		std Y+2,__zero_reg__
 5165               	.L53:
 5166 04d8 8981      		ldd r24,Y+1
 5167 04da 9A81      		ldd r25,Y+2
 5168 04dc 8F37      		cpi r24,127
 5169 04de 9105      		cpc r25,__zero_reg__
 5170 04e0 E8F4      		brsh .L52
 5171               	.LBB5:
 102:display.h     **** 		{
 103:display.h     **** 			write_data(PRG_RDB(&strStop[(128*uRowCounter)+uByteCounter]));	//get the raw data
 5173               	.LM117:
 5174 04e2 8B81      		ldd r24,Y+3
 5175 04e4 9927      		clr r25
 5176 04e6 9C01      		movw r18,r24
 5177 04e8 3695      		lsr r19
 5178 04ea 322F      		mov r19,r18
 5179 04ec 2227      		clr r18
 5180 04ee 3795      		ror r19
 5181 04f0 2795      		ror r18
 5182 04f2 8981      		ldd r24,Y+1
 5183 04f4 9A81      		ldd r25,Y+2
 5184 04f6 820F      		add r24,r18
 5185 04f8 931F      		adc r25,r19
 5186 04fa 8050      		subi r24,lo8(-(strStop))
 5187 04fc 9040      		sbci r25,hi8(-(strStop))
 5188 04fe 8C83      		std Y+4,r24
 5189 0500 9D83      		std Y+5,r25
 5190 0502 EC81      		ldd r30,Y+4
 5191 0504 FD81      		ldd r31,Y+5
 5192               	/* #APP */
 5193 0506 8491      		lpm r24, Z
 5194               		
 5195               	/* #NOAPP */
 5196 0508 8E83      		std Y+6,r24
 5197               	.LBE5:
 5198 050a 8E81      		ldd r24,Y+6
 5199 050c 0E94 0000 		call write_data
 5201               	.LM118:
 5202 0510 8981      		ldd r24,Y+1
 5203 0512 9A81      		ldd r25,Y+2
 5204 0514 0196      		adiw r24,1
 5205 0516 8983      		std Y+1,r24
 5206 0518 9A83      		std Y+2,r25
 5207 051a DECF      		rjmp .L53
 5208               	.L52:
 5210               	.LM119:
 5211 051c 8B81      		ldd r24,Y+3
 5212 051e 8F5F      		subi r24,lo8(-(1))
 5213 0520 8B83      		std Y+3,r24
 5214 0522 D2CF      		rjmp .L50
 5215               	.L49:
 5216               	/* epilogue: frame size=6 */
 5217 0524 2696      		adiw r28,6
 5218 0526 0FB6      		in __tmp_reg__,__SREG__
 5219 0528 F894      		cli
 5220 052a DEBF      		out __SP_H__,r29
 5221 052c 0FBE      		out __SREG__,__tmp_reg__
 5222 052e CDBF      		out __SP_L__,r28
 5223 0530 DF91      		pop r29
 5224 0532 CF91      		pop r28
 5225 0534 0895      		ret
 5226               	/* epilogue end (size=9) */
 5227               	/* function stop_image size 69 (50) */
 5241               	.global	BigDigits
 5243               	BigDigits:
 104:display.h     **** 			//  character data out of flash, 128 bytes for each row of data.
 105:display.h     **** 		}
 106:display.h     **** 	}
 107:display.h     **** }
 108:display.h     **** 
 109:display.h     **** 
 110:display.h     **** //Parameters for the passed variables:
 111:display.h     **** //	uStartRow: 0 to 7, the start row of the big text
 112:display.h     **** //	uStartColum:  0 to 112, the pixel count to start the number from the left side of the display
 113:display.h     **** //  IntNumber:  0 to 999, the number to display in big pixels
 114:display.h     **** //	uPeriodPos:  NOT IMPLIMENTED:  0 to 6, the position to display the period, ".", in the number
 115:display.h     **** //  boolInvert: if true, blue on a white background, if false, white on a blue background
 116:display.h     **** 
 117:display.h     **** void BigDigits(unsigned char uStartRow, unsigned char uStartColumn, unsigned int intNumber, unsigne
 118:display.h     **** {
 5245               	.LM120:
 5246               	/* prologue: frame size=17 */
 5247 0536 0F93      		push r16
 5248 0538 CF93      		push r28
 5249 053a DF93      		push r29
 5250 053c CDB7      		in r28,__SP_L__
 5251 053e DEB7      		in r29,__SP_H__
 5252 0540 6197      		sbiw r28,17
 5253 0542 0FB6      		in __tmp_reg__,__SREG__
 5254 0544 F894      		cli
 5255 0546 DEBF      		out __SP_H__,r29
 5256 0548 0FBE      		out __SREG__,__tmp_reg__
 5257 054a CDBF      		out __SP_L__,r28
 5258               	/* prologue end (size=11) */
 5259 054c 8983      		std Y+1,r24
 5260 054e 6A83      		std Y+2,r22
 5261 0550 4B83      		std Y+3,r20
 5262 0552 5C83      		std Y+4,r21
 5263 0554 2D83      		std Y+5,r18
 5264 0556 0E83      		std Y+6,r16
 119:display.h     **** 	unsigned char uAlpha;
 120:display.h     **** 	unsigned char uBeta;
 121:display.h     **** 	unsigned char uGamma;
 122:display.h     **** 	
 123:display.h     **** 	unsigned int intTor;
 124:display.h     **** 	unsigned int intS;
 125:display.h     **** 	
 126:display.h     **** 	bool boolFirstNonZero=false;
 5266               	.LM121:
 5267 0558 1E86      		std Y+14,__zero_reg__
 127:display.h     **** 
 128:display.h     **** 	integerToArray(intNumber);	//convert the big font number to a string
 5269               	.LM122:
 5270 055a 8B81      		ldd r24,Y+3
 5271 055c 9C81      		ldd r25,Y+4
 5272 055e 0E94 0000 		call integerToArray
 129:display.h     **** 	set_line(uStartRow);		//set the line for writing a string of characters
 5274               	.LM123:
 5275 0562 8981      		ldd r24,Y+1
 5276 0564 0E94 0000 		call set_line
 130:display.h     **** 	moveCursorToColumn(uStartColumn);	//write white spaces to get to the right column
 5278               	.LM124:
 5279 0568 8A81      		ldd r24,Y+2
 5280 056a 0E94 0000 		call moveCursorToColumn
 131:display.h     **** 	boolFirstNonZero=false;	//preperation for the blanking the leading zeros
 5282               	.LM125:
 5283 056e 1E86      		std Y+14,__zero_reg__
 132:display.h     **** 	for(uGamma=1;uGamma<4;uGamma++)	//this for loop writes the top 1/3 of each of the 3 digits
 5285               	.LM126:
 5286 0570 81E0      		ldi r24,lo8(1)
 5287 0572 8987      		std Y+9,r24
 5288               	.L57:
 5290               	.LM127:
 5291 0574 8985      		ldd r24,Y+9
 5292 0576 8430      		cpi r24,lo8(4)
 5293 0578 08F0      		brlo .+2
 5294 057a 67C0      		rjmp .L58
 133:display.h     **** 	{
 134:display.h     **** 		uBeta=str[uGamma]-0x30;		//convert the number into an ASCII character
 5296               	.LM128:
 5297 057c 8985      		ldd r24,Y+9
 5298 057e 9927      		clr r25
 5299 0580 FC01      		movw r30,r24
 5300 0582 E050      		subi r30,lo8(-(str))
 5301 0584 F040      		sbci r31,hi8(-(str))
 5302 0586 8081      		ld r24,Z
 5303 0588 8053      		subi r24,lo8(-(-48))
 5304 058a 8887      		std Y+8,r24
 135:display.h     **** 		if(uBeta==0 && uGamma==1)	//if there is a zero in the hundreds place, then write a blank space
 5306               	.LM129:
 5307 058c 8885      		ldd r24,Y+8
 5308 058e 8823      		tst r24
 5309 0590 39F4      		brne .L60
 5310 0592 8985      		ldd r24,Y+9
 5311 0594 8130      		cpi r24,lo8(1)
 5312 0596 21F4      		brne .L60
 136:display.h     **** 		{
 137:display.h     **** 			write_pixel_spaces(15);	//write white spaces to get to the right column
 5314               	.LM130:
 5315 0598 8FE0      		ldi r24,lo8(15)
 5316 059a 0E94 0000 		call write_pixel_spaces
 5317 059e 51C0      		rjmp .L59
 5318               	.L60:
 138:display.h     **** 		}
 139:display.h     **** 		else if(uBeta==0 && uGamma==2 && boolFirstNonZero==false && uNumbersDisplayed<2)
 5320               	.LM131:
 5321 05a0 8885      		ldd r24,Y+8
 5322 05a2 8823      		tst r24
 5323 05a4 69F4      		brne .L62
 5324 05a6 8985      		ldd r24,Y+9
 5325 05a8 8230      		cpi r24,lo8(2)
 5326 05aa 51F4      		brne .L62
 5327 05ac 8E85      		ldd r24,Y+14
 5328 05ae 8823      		tst r24
 5329 05b0 39F4      		brne .L62
 5330 05b2 8D81      		ldd r24,Y+5
 5331 05b4 8230      		cpi r24,lo8(2)
 5332 05b6 20F4      		brsh .L62
 140:display.h     **** 		//go write spaces if the hundreds digit was zero and tens digit is zero
 141:display.h     **** 		{
 142:display.h     **** 			write_pixel_spaces(15);	//write white spaces to get to the right column
 5334               	.LM132:
 5335 05b8 8FE0      		ldi r24,lo8(15)
 5336 05ba 0E94 0000 		call write_pixel_spaces
 5337 05be 41C0      		rjmp .L59
 5338               	.L62:
 143:display.h     **** 		}
 144:display.h     **** 		else if(uBeta==0 && uGamma==3 && boolFirstNonZero==false && uNumbersDisplayed<1)
 5340               	.LM133:
 5341 05c0 8885      		ldd r24,Y+8
 5342 05c2 8823      		tst r24
 5343 05c4 69F4      		brne .L64
 5344 05c6 8985      		ldd r24,Y+9
 5345 05c8 8330      		cpi r24,lo8(3)
 5346 05ca 51F4      		brne .L64
 5347 05cc 8E85      		ldd r24,Y+14
 5348 05ce 8823      		tst r24
 5349 05d0 39F4      		brne .L64
 5350 05d2 8D81      		ldd r24,Y+5
 5351 05d4 8823      		tst r24
 5352 05d6 21F4      		brne .L64
 145:display.h     **** 		//go write spaces if the hundreds digit was zero, the tens digit is zero, 
 146:display.h     **** 		//  and the ones digit is zero
 147:display.h     **** 		{
 148:display.h     **** 			//moveCursorToColumn(uStartColumn+15);	//write white spaces to get to the right column
 149:display.h     **** 			write_pixel_spaces(15);	//write white spaces to get to the right column
 5354               	.LM134:
 5355 05d8 8FE0      		ldi r24,lo8(15)
 5356 05da 0E94 0000 		call write_pixel_spaces
 5357 05de 31C0      		rjmp .L59
 5358               	.L64:
 150:display.h     **** 		}
 151:display.h     **** 		else
 152:display.h     **** 		{
 153:display.h     **** 			boolFirstNonZero=true;	//we must have had our first non-zero digit
 5360               	.LM135:
 5361 05e0 81E0      		ldi r24,lo8(1)
 5362 05e2 8E87      		std Y+14,r24
 154:display.h     **** 			for(uAlpha=0;uAlpha<15;uAlpha++)	//get the top 16 bytes out of flash for the current digit
 5364               	.LM136:
 5365 05e4 1F82      		std Y+7,__zero_reg__
 5366               	.L66:
 5367 05e6 8F81      		ldd r24,Y+7
 5368 05e8 8F30      		cpi r24,lo8(15)
 5369 05ea 58F5      		brsh .L59
 155:display.h     **** 			{		
 156:display.h     **** 				intTor=(uBeta*48)+uAlpha;	//calculate the offset to the character we need
 5371               	.LM137:
 5372 05ec 9885      		ldd r25,Y+8
 5373 05ee 80E3      		ldi r24,lo8(48)
 5374 05f0 989F      		mul r25,r24
 5375 05f2 9001      		movw r18,r0
 5376 05f4 1124      		clr r1
 5377 05f6 8F81      		ldd r24,Y+7
 5378 05f8 9927      		clr r25
 5379 05fa 820F      		add r24,r18
 5380 05fc 931F      		adc r25,r19
 5381 05fe 8A87      		std Y+10,r24
 5382 0600 9B87      		std Y+11,r25
 5383               	.LBB6:
 157:display.h     **** 				intS=PRG_RDB(&strBigFont0[intTor]);	//get the raw data character data out of flash
 5385               	.LM138:
 5386 0602 8A85      		ldd r24,Y+10
 5387 0604 9B85      		ldd r25,Y+11
 5388 0606 8050      		subi r24,lo8(-(strBigFont0))
 5389 0608 9040      		sbci r25,hi8(-(strBigFont0))
 5390 060a 8F87      		std Y+15,r24
 5391 060c 988B      		std Y+16,r25
 5392 060e EF85      		ldd r30,Y+15
 5393 0610 F889      		ldd r31,Y+16
 5394               	/* #APP */
 5395 0612 8491      		lpm r24, Z
 5396               		
 5397               	/* #NOAPP */
 5398 0614 898B      		std Y+17,r24
 5399               	.LBE6:
 5400 0616 8989      		ldd r24,Y+17
 5401 0618 9927      		clr r25
 5402 061a 8C87      		std Y+12,r24
 5403 061c 9D87      		std Y+13,r25
 158:display.h     **** 				if(boolInvert)
 5405               	.LM139:
 5406 061e 8E81      		ldd r24,Y+6
 5407 0620 8823      		tst r24
 5408 0622 41F0      		breq .L69
 159:display.h     **** 				{
 160:display.h     **** 					intS=intS^255;
 5410               	.LM140:
 5411 0624 8C85      		ldd r24,Y+12
 5412 0626 9D85      		ldd r25,Y+13
 5413 0628 2FEF      		ldi r18,lo8(255)
 5414 062a 30E0      		ldi r19,hi8(255)
 5415 062c 8227      		eor r24,r18
 5416 062e 9327      		eor r25,r19
 5417 0630 8C87      		std Y+12,r24
 5418 0632 9D87      		std Y+13,r25
 5419               	.L69:
 161:display.h     **** 				}
 162:display.h     **** 				write_data(intS);		//write the data to the display
 5421               	.LM141:
 5422 0634 8C85      		ldd r24,Y+12
 5423 0636 0E94 0000 		call write_data
 5425               	.LM142:
 5426 063a 8F81      		ldd r24,Y+7
 5427 063c 8F5F      		subi r24,lo8(-(1))
 5428 063e 8F83      		std Y+7,r24
 5429 0640 D2CF      		rjmp .L66
 5430               	.L59:
 5432               	.LM143:
 5433 0642 8985      		ldd r24,Y+9
 5434 0644 8F5F      		subi r24,lo8(-(1))
 5435 0646 8987      		std Y+9,r24
 5436 0648 95CF      		rjmp .L57
 5437               	.L58:
 163:display.h     **** 			}
 164:display.h     **** 		}
 165:display.h     **** 	}
 166:display.h     **** 	set_line(uStartRow+1);		//set the line for writing a string of characters
 5439               	.LM144:
 5440 064a 8981      		ldd r24,Y+1
 5441 064c 8F5F      		subi r24,lo8(-(1))
 5442 064e 0E94 0000 		call set_line
 167:display.h     **** 	moveCursorToColumn(uStartColumn);
 5444               	.LM145:
 5445 0652 8A81      		ldd r24,Y+2
 5446 0654 0E94 0000 		call moveCursorToColumn
 168:display.h     **** 	boolFirstNonZero=false;	//preperation for the blanking the leading zeros
 5448               	.LM146:
 5449 0658 1E86      		std Y+14,__zero_reg__
 169:display.h     **** 	for(uGamma=1;uGamma<4;uGamma++)	//this for loop writes the middle 1/3 of each of the 3 digits
 5451               	.LM147:
 5452 065a 81E0      		ldi r24,lo8(1)
 5453 065c 8987      		std Y+9,r24
 5454               	.L70:
 5455 065e 8985      		ldd r24,Y+9
 5456 0660 8430      		cpi r24,lo8(4)
 5457 0662 08F0      		brlo .+2
 5458 0664 68C0      		rjmp .L71
 170:display.h     **** 	{
 171:display.h     **** 		uBeta=str[uGamma]-0x30;
 5460               	.LM148:
 5461 0666 8985      		ldd r24,Y+9
 5462 0668 9927      		clr r25
 5463 066a FC01      		movw r30,r24
 5464 066c E050      		subi r30,lo8(-(str))
 5465 066e F040      		sbci r31,hi8(-(str))
 5466 0670 8081      		ld r24,Z
 5467 0672 8053      		subi r24,lo8(-(-48))
 5468 0674 8887      		std Y+8,r24
 172:display.h     **** 		if(uBeta==0 && uGamma==1)	//if there is a zero in the hundreds place, then write a blank space
 5470               	.LM149:
 5471 0676 8885      		ldd r24,Y+8
 5472 0678 8823      		tst r24
 5473 067a 39F4      		brne .L73
 5474 067c 8985      		ldd r24,Y+9
 5475 067e 8130      		cpi r24,lo8(1)
 5476 0680 21F4      		brne .L73
 173:display.h     **** 		{
 174:display.h     **** 			write_pixel_spaces(15);	//write white spaces to get to the right column
 5478               	.LM150:
 5479 0682 8FE0      		ldi r24,lo8(15)
 5480 0684 0E94 0000 		call write_pixel_spaces
 5481 0688 52C0      		rjmp .L72
 5482               	.L73:
 175:display.h     **** 		}
 176:display.h     **** 		else if(uBeta==0 && uGamma==2 && boolFirstNonZero==false && uNumbersDisplayed<2)
 5484               	.LM151:
 5485 068a 8885      		ldd r24,Y+8
 5486 068c 8823      		tst r24
 5487 068e 69F4      		brne .L75
 5488 0690 8985      		ldd r24,Y+9
 5489 0692 8230      		cpi r24,lo8(2)
 5490 0694 51F4      		brne .L75
 5491 0696 8E85      		ldd r24,Y+14
 5492 0698 8823      		tst r24
 5493 069a 39F4      		brne .L75
 5494 069c 8D81      		ldd r24,Y+5
 5495 069e 8230      		cpi r24,lo8(2)
 5496 06a0 20F4      		brsh .L75
 177:display.h     **** 		//go write spaces if the hundreds digit was zero and tens digit is zero
 178:display.h     **** 		{
 179:display.h     **** 			write_pixel_spaces(15);	//write white spaces to get to the right column
 5498               	.LM152:
 5499 06a2 8FE0      		ldi r24,lo8(15)
 5500 06a4 0E94 0000 		call write_pixel_spaces
 5501 06a8 42C0      		rjmp .L72
 5502               	.L75:
 180:display.h     **** 		}
 181:display.h     **** 		else if(uBeta==0 && uGamma==3 && boolFirstNonZero==false && uNumbersDisplayed<1)
 5504               	.LM153:
 5505 06aa 8885      		ldd r24,Y+8
 5506 06ac 8823      		tst r24
 5507 06ae 69F4      		brne .L77
 5508 06b0 8985      		ldd r24,Y+9
 5509 06b2 8330      		cpi r24,lo8(3)
 5510 06b4 51F4      		brne .L77
 5511 06b6 8E85      		ldd r24,Y+14
 5512 06b8 8823      		tst r24
 5513 06ba 39F4      		brne .L77
 5514 06bc 8D81      		ldd r24,Y+5
 5515 06be 8823      		tst r24
 5516 06c0 21F4      		brne .L77
 182:display.h     **** 		//go write spaces if the hundreds digit was zero, the tens digit is zero, 
 183:display.h     **** 		//  and the ones digit is zero
 184:display.h     **** 		{
 185:display.h     **** 			write_pixel_spaces(15);	//write white spaces to get to the right column
 5518               	.LM154:
 5519 06c2 8FE0      		ldi r24,lo8(15)
 5520 06c4 0E94 0000 		call write_pixel_spaces
 5521 06c8 32C0      		rjmp .L72
 5522               	.L77:
 186:display.h     **** 		}
 187:display.h     **** 		else
 188:display.h     **** 		{
 189:display.h     **** 			boolFirstNonZero=true;
 5524               	.LM155:
 5525 06ca 81E0      		ldi r24,lo8(1)
 5526 06cc 8E87      		std Y+14,r24
 190:display.h     **** 			for(uAlpha=16;uAlpha<31;uAlpha++)	//get the middle 16 bytes out of flash for the current digit
 5528               	.LM156:
 5529 06ce 80E1      		ldi r24,lo8(16)
 5530 06d0 8F83      		std Y+7,r24
 5531               	.L79:
 5532 06d2 8F81      		ldd r24,Y+7
 5533 06d4 8F31      		cpi r24,lo8(31)
 5534 06d6 58F5      		brsh .L72
 191:display.h     **** 			{		
 192:display.h     **** 				intTor=(uBeta*48)+uAlpha;	//calculate the offset to the character we need
 5536               	.LM157:
 5537 06d8 9885      		ldd r25,Y+8
 5538 06da 80E3      		ldi r24,lo8(48)
 5539 06dc 989F      		mul r25,r24
 5540 06de 9001      		movw r18,r0
 5541 06e0 1124      		clr r1
 5542 06e2 8F81      		ldd r24,Y+7
 5543 06e4 9927      		clr r25
 5544 06e6 820F      		add r24,r18
 5545 06e8 931F      		adc r25,r19
 5546 06ea 8A87      		std Y+10,r24
 5547 06ec 9B87      		std Y+11,r25
 5548               	.LBB7:
 193:display.h     **** 				intS=PRG_RDB(&strBigFont0[intTor]);	//get the raw data character data out of flash
 5550               	.LM158:
 5551 06ee 8A85      		ldd r24,Y+10
 5552 06f0 9B85      		ldd r25,Y+11
 5553 06f2 8050      		subi r24,lo8(-(strBigFont0))
 5554 06f4 9040      		sbci r25,hi8(-(strBigFont0))
 5555 06f6 8F87      		std Y+15,r24
 5556 06f8 988B      		std Y+16,r25
 5557 06fa EF85      		ldd r30,Y+15
 5558 06fc F889      		ldd r31,Y+16
 5559               	/* #APP */
 5560 06fe 8491      		lpm r24, Z
 5561               		
 5562               	/* #NOAPP */
 5563 0700 898B      		std Y+17,r24
 5564               	.LBE7:
 5565 0702 8989      		ldd r24,Y+17
 5566 0704 9927      		clr r25
 5567 0706 8C87      		std Y+12,r24
 5568 0708 9D87      		std Y+13,r25
 194:display.h     **** 				if(boolInvert)
 5570               	.LM159:
 5571 070a 8E81      		ldd r24,Y+6
 5572 070c 8823      		tst r24
 5573 070e 41F0      		breq .L82
 195:display.h     **** 				{
 196:display.h     **** 					intS=intS^255;
 5575               	.LM160:
 5576 0710 8C85      		ldd r24,Y+12
 5577 0712 9D85      		ldd r25,Y+13
 5578 0714 2FEF      		ldi r18,lo8(255)
 5579 0716 30E0      		ldi r19,hi8(255)
 5580 0718 8227      		eor r24,r18
 5581 071a 9327      		eor r25,r19
 5582 071c 8C87      		std Y+12,r24
 5583 071e 9D87      		std Y+13,r25
 5584               	.L82:
 197:display.h     **** 				}
 198:display.h     **** 				write_data(intS);		//write the data to the display
 5586               	.LM161:
 5587 0720 8C85      		ldd r24,Y+12
 5588 0722 0E94 0000 		call write_data
 5590               	.LM162:
 5591 0726 8F81      		ldd r24,Y+7
 5592 0728 8F5F      		subi r24,lo8(-(1))
 5593 072a 8F83      		std Y+7,r24
 5594 072c D2CF      		rjmp .L79
 5595               	.L72:
 5597               	.LM163:
 5598 072e 8985      		ldd r24,Y+9
 5599 0730 8F5F      		subi r24,lo8(-(1))
 5600 0732 8987      		std Y+9,r24
 5601 0734 94CF      		rjmp .L70
 5602               	.L71:
 199:display.h     **** 			}
 200:display.h     **** 		}
 201:display.h     **** 	}
 202:display.h     **** 	set_line(uStartRow+2);		//set the line for writing a string of characters
 5604               	.LM164:
 5605 0736 8981      		ldd r24,Y+1
 5606 0738 8E5F      		subi r24,lo8(-(2))
 5607 073a 0E94 0000 		call set_line
 203:display.h     **** 	moveCursorToColumn(uStartColumn);
 5609               	.LM165:
 5610 073e 8A81      		ldd r24,Y+2
 5611 0740 0E94 0000 		call moveCursorToColumn
 204:display.h     **** 	boolFirstNonZero=false;	//preperation for the blanking the leading zeros
 5613               	.LM166:
 5614 0744 1E86      		std Y+14,__zero_reg__
 205:display.h     **** 	for(uGamma=1;uGamma<4;uGamma++)	//this loop writes the bottom 1/3 of each of the 3 digits
 5616               	.LM167:
 5617 0746 81E0      		ldi r24,lo8(1)
 5618 0748 8987      		std Y+9,r24
 5619               	.L83:
 5620 074a 8985      		ldd r24,Y+9
 5621 074c 8430      		cpi r24,lo8(4)
 5622 074e 08F0      		brlo .+2
 5623 0750 68C0      		rjmp .L56
 206:display.h     **** 	{
 207:display.h     **** 		uBeta=str[uGamma]-0x30;		//convert the number into an ASCII character
 5625               	.LM168:
 5626 0752 8985      		ldd r24,Y+9
 5627 0754 9927      		clr r25
 5628 0756 FC01      		movw r30,r24
 5629 0758 E050      		subi r30,lo8(-(str))
 5630 075a F040      		sbci r31,hi8(-(str))
 5631 075c 8081      		ld r24,Z
 5632 075e 8053      		subi r24,lo8(-(-48))
 5633 0760 8887      		std Y+8,r24
 208:display.h     **** 		if(uBeta==0 && uGamma==1)	//if there is a zero in the hundreds place, then write a blank space
 5635               	.LM169:
 5636 0762 8885      		ldd r24,Y+8
 5637 0764 8823      		tst r24
 5638 0766 39F4      		brne .L86
 5639 0768 8985      		ldd r24,Y+9
 5640 076a 8130      		cpi r24,lo8(1)
 5641 076c 21F4      		brne .L86
 209:display.h     **** 		{
 210:display.h     **** 			write_pixel_spaces(15);	//write white spaces to get to the right column
 5643               	.LM170:
 5644 076e 8FE0      		ldi r24,lo8(15)
 5645 0770 0E94 0000 		call write_pixel_spaces
 5646 0774 52C0      		rjmp .L85
 5647               	.L86:
 211:display.h     **** 		}
 212:display.h     **** 		else if(uBeta==0 && uGamma==2 && boolFirstNonZero==false && uNumbersDisplayed<2)
 5649               	.LM171:
 5650 0776 8885      		ldd r24,Y+8
 5651 0778 8823      		tst r24
 5652 077a 69F4      		brne .L88
 5653 077c 8985      		ldd r24,Y+9
 5654 077e 8230      		cpi r24,lo8(2)
 5655 0780 51F4      		brne .L88
 5656 0782 8E85      		ldd r24,Y+14
 5657 0784 8823      		tst r24
 5658 0786 39F4      		brne .L88
 5659 0788 8D81      		ldd r24,Y+5
 5660 078a 8230      		cpi r24,lo8(2)
 5661 078c 20F4      		brsh .L88
 213:display.h     **** 		//go write spaces if the hundreds digit was zero and tens digit is zero
 214:display.h     **** 		{
 215:display.h     **** 			write_pixel_spaces(15);	//write white spaces to get to the right column
 5663               	.LM172:
 5664 078e 8FE0      		ldi r24,lo8(15)
 5665 0790 0E94 0000 		call write_pixel_spaces
 5666 0794 42C0      		rjmp .L85
 5667               	.L88:
 216:display.h     **** 		}
 217:display.h     **** 		else if(uBeta==0 && uGamma==3 && boolFirstNonZero==false && uNumbersDisplayed<1)
 5669               	.LM173:
 5670 0796 8885      		ldd r24,Y+8
 5671 0798 8823      		tst r24
 5672 079a 69F4      		brne .L90
 5673 079c 8985      		ldd r24,Y+9
 5674 079e 8330      		cpi r24,lo8(3)
 5675 07a0 51F4      		brne .L90
 5676 07a2 8E85      		ldd r24,Y+14
 5677 07a4 8823      		tst r24
 5678 07a6 39F4      		brne .L90
 5679 07a8 8D81      		ldd r24,Y+5
 5680 07aa 8823      		tst r24
 5681 07ac 21F4      		brne .L90
 218:display.h     **** 		//go write spaces if the hundreds digit was zero, the tens digit is zero, 
 219:display.h     **** 		//  and the ones digit is zero
 220:display.h     **** 		{
 221:display.h     **** 			write_pixel_spaces(15);	//write white spaces to get to the right column
 5683               	.LM174:
 5684 07ae 8FE0      		ldi r24,lo8(15)
 5685 07b0 0E94 0000 		call write_pixel_spaces
 5686 07b4 32C0      		rjmp .L85
 5687               	.L90:
 222:display.h     **** 		}
 223:display.h     **** 		else
 224:display.h     **** 		{
 225:display.h     **** 			boolFirstNonZero=true;
 5689               	.LM175:
 5690 07b6 81E0      		ldi r24,lo8(1)
 5691 07b8 8E87      		std Y+14,r24
 226:display.h     **** 			for(uAlpha=32;uAlpha<47;uAlpha++)	//get the bottom 16 bytes out of flash for the current digit
 5693               	.LM176:
 5694 07ba 80E2      		ldi r24,lo8(32)
 5695 07bc 8F83      		std Y+7,r24
 5696               	.L92:
 5697 07be 8F81      		ldd r24,Y+7
 5698 07c0 8F32      		cpi r24,lo8(47)
 5699 07c2 58F5      		brsh .L85
 227:display.h     **** 			{		
 228:display.h     **** 				intTor=(uBeta*48)+uAlpha;	//calculate the offset to the character we need
 5701               	.LM177:
 5702 07c4 9885      		ldd r25,Y+8
 5703 07c6 80E3      		ldi r24,lo8(48)
 5704 07c8 989F      		mul r25,r24
 5705 07ca 9001      		movw r18,r0
 5706 07cc 1124      		clr r1
 5707 07ce 8F81      		ldd r24,Y+7
 5708 07d0 9927      		clr r25
 5709 07d2 820F      		add r24,r18
 5710 07d4 931F      		adc r25,r19
 5711 07d6 8A87      		std Y+10,r24
 5712 07d8 9B87      		std Y+11,r25
 5713               	.LBB8:
 229:display.h     **** 				intS=PRG_RDB(&strBigFont0[intTor]);	//get the raw data character data out of flash
 5715               	.LM178:
 5716 07da 8A85      		ldd r24,Y+10
 5717 07dc 9B85      		ldd r25,Y+11
 5718 07de 8050      		subi r24,lo8(-(strBigFont0))
 5719 07e0 9040      		sbci r25,hi8(-(strBigFont0))
 5720 07e2 8F87      		std Y+15,r24
 5721 07e4 988B      		std Y+16,r25
 5722 07e6 EF85      		ldd r30,Y+15
 5723 07e8 F889      		ldd r31,Y+16
 5724               	/* #APP */
 5725 07ea 8491      		lpm r24, Z
 5726               		
 5727               	/* #NOAPP */
 5728 07ec 898B      		std Y+17,r24
 5729               	.LBE8:
 5730 07ee 8989      		ldd r24,Y+17
 5731 07f0 9927      		clr r25
 5732 07f2 8C87      		std Y+12,r24
 5733 07f4 9D87      		std Y+13,r25
 230:display.h     **** 				if(boolInvert)
 5735               	.LM179:
 5736 07f6 8E81      		ldd r24,Y+6
 5737 07f8 8823      		tst r24
 5738 07fa 41F0      		breq .L95
 231:display.h     **** 				{
 232:display.h     **** 					intS=intS^255;	//inverts the background with forground color, This exclusive or's the value fr
 5740               	.LM180:
 5741 07fc 8C85      		ldd r24,Y+12
 5742 07fe 9D85      		ldd r25,Y+13
 5743 0800 2FEF      		ldi r18,lo8(255)
 5744 0802 30E0      		ldi r19,hi8(255)
 5745 0804 8227      		eor r24,r18
 5746 0806 9327      		eor r25,r19
 5747 0808 8C87      		std Y+12,r24
 5748 080a 9D87      		std Y+13,r25
 5749               	.L95:
 233:display.h     **** 				}
 234:display.h     **** 				write_data(intS);		//write the data to the display
 5751               	.LM181:
 5752 080c 8C85      		ldd r24,Y+12
 5753 080e 0E94 0000 		call write_data
 5755               	.LM182:
 5756 0812 8F81      		ldd r24,Y+7
 5757 0814 8F5F      		subi r24,lo8(-(1))
 5758 0816 8F83      		std Y+7,r24
 5759 0818 D2CF      		rjmp .L92
 5760               	.L85:
 5762               	.LM183:
 5763 081a 8985      		ldd r24,Y+9
 5764 081c 8F5F      		subi r24,lo8(-(1))
 5765 081e 8987      		std Y+9,r24
 5766 0820 94CF      		rjmp .L83
 5767               	.L56:
 5768               	/* epilogue: frame size=17 */
 5769 0822 6196      		adiw r28,17
 5770 0824 0FB6      		in __tmp_reg__,__SREG__
 5771 0826 F894      		cli
 5772 0828 DEBF      		out __SP_H__,r29
 5773 082a 0FBE      		out __SREG__,__tmp_reg__
 5774 082c CDBF      		out __SP_L__,r28
 5775 082e DF91      		pop r29
 5776 0830 CF91      		pop r28
 5777 0832 0F91      		pop r16
 5778 0834 0895      		ret
 5779               	/* epilogue end (size=10) */
 5780               	/* function BigDigits size 393 (372) */
 5801               	.global	write_eagle_display
 5803               	write_eagle_display:
 235:display.h     **** 			}
 236:display.h     **** 		}
 237:display.h     **** 	}
 238:display.h     **** }
 239:display.h     **** 
 240:display.h     **** //----------------------------------------------------------------------------
 241:display.h     **** //Routine:     write_eagle_display (write a bit-mapped image to the graphical LCD)
 242:display.h     **** //
 243:display.h     **** //Function:
 244:display.h     **** //
 245:display.h     **** //Varibles passed:
 246:display.h     **** //       none
 247:display.h     **** //Returns:
 248:display.h     **** //       none
 249:display.h     **** //----------------------------------------------------------------------------
 250:display.h     **** void write_eagle_display(void)
 251:display.h     **** {
 5805               	.LM184:
 5806               	/* prologue: frame size=0 */
 5807 0836 0F93      		push r16
 5808 0838 CF93      		push r28
 5809 083a DF93      		push r29
 5810 083c CDB7      		in r28,__SP_L__
 5811 083e DEB7      		in r29,__SP_H__
 5812               	/* prologue end (size=5) */
 252:display.h     **** 	//drawText(string to print, column to start on, line (row) to put the text upon, invert the colors
 253:display.h     **** 	//drawText((unsigned char *)strPatrol,93,0,false);
 254:display.h     **** 	//drawText((unsigned char *)strTarget,10,0,false);
 255:display.h     **** 	//drawText((unsigned char *)strLock,55,4,false);
 256:display.h     **** 
 257:display.h     **** 	//BigDigits(unsigned char uStartRow, unsigned char uStartColumn, unsigned int intNumber, unsigned 
 258:display.h     **** 
 259:display.h     **** 	//BigDigits(5,40,156,0,true);
 260:display.h     **** 
 261:display.h     **** 	//write an example time to the display
 262:display.h     **** 	BigDigits(1,50,59,0,false);
 5814               	.LM185:
 5815 0840 00E0      		ldi r16,lo8(0)
 5816 0842 20E0      		ldi r18,lo8(0)
 5817 0844 4BE3      		ldi r20,lo8(59)
 5818 0846 50E0      		ldi r21,hi8(59)
 5819 0848 62E3      		ldi r22,lo8(50)
 5820 084a 81E0      		ldi r24,lo8(1)
 5821 084c 0E94 0000 		call BigDigits
 263:display.h     **** 	subLargeCOlon(1,52,false);
 5823               	.LM186:
 5824 0850 40E0      		ldi r20,lo8(0)
 5825 0852 64E3      		ldi r22,lo8(52)
 5826 0854 81E0      		ldi r24,lo8(1)
 5827 0856 0E94 0000 		call subLargeCOlon
 264:display.h     **** 	BigDigits(1,10,12,0,false);
 5829               	.LM187:
 5830 085a 00E0      		ldi r16,lo8(0)
 5831 085c 20E0      		ldi r18,lo8(0)
 5832 085e 4CE0      		ldi r20,lo8(12)
 5833 0860 50E0      		ldi r21,hi8(12)
 5834 0862 6AE0      		ldi r22,lo8(10)
 5835 0864 81E0      		ldi r24,lo8(1)
 5836 0866 0E94 0000 		call BigDigits
 5837               	/* epilogue: frame size=0 */
 5838 086a DF91      		pop r29
 5839 086c CF91      		pop r28
 5840 086e 0F91      		pop r16
 5841 0870 0895      		ret
 5842               	/* epilogue end (size=4) */
 5843               	/* function write_eagle_display size 30 (21) */
 5850               	.global	drawText
 5852               	drawText:
 265:display.h     **** }
 266:display.h     **** 
 267:display.h     **** 
 268:display.h     **** //----------------------------------------------------------------------------
 269:display.h     **** //Routine:     drawText (prints an array of 5x7 characters to the LCD)
 270:display.h     **** //
 271:display.h     **** //Function:
 272:display.h     **** //		This function draws a string of data to the LCD in 5x7 pixel format.
 273:display.h     **** //		The X (column) and Y (row) position is passed to the array.  The position
 274:display.h     **** //		numbers start from the upper left hand corner of the display.
 275:display.h     **** //
 276:display.h     **** //Varibles passed:
 277:display.h     **** //      unsigned char *pts:  This is a pointer to the array that will be printing to the LCD
 278:display.h     **** //		unsigned char uPosition:  (value =0 to 120) this is the number of pixels from the left side of 
 279:display.h     **** //			screen that the text will start.  (it sets the column start position of the text)
 280:display.h     **** //		unsigned char uRow:  (value = 0 to 7) this sets the row the text will be printed upon.
 281:display.h     **** //		ubool boolInvert:  When false- white characters on a blue background
 282:display.h     **** //			when true - blue characters on a white background.
 283:display.h     **** //Returns:
 284:display.h     **** //       none
 285:display.h     **** //----------------------------------------------------------------------------
 286:display.h     **** void drawText(unsigned char *pts,unsigned char uPosition,unsigned char uRow, bool boolInvert)
 287:display.h     **** {
 5854               	.LM188:
 5855               	/* prologue: frame size=9 */
 5856 0872 CF93      		push r28
 5857 0874 DF93      		push r29
 5858 0876 CDB7      		in r28,__SP_L__
 5859 0878 DEB7      		in r29,__SP_H__
 5860 087a 2997      		sbiw r28,9
 5861 087c 0FB6      		in __tmp_reg__,__SREG__
 5862 087e F894      		cli
 5863 0880 DEBF      		out __SP_H__,r29
 5864 0882 0FBE      		out __SREG__,__tmp_reg__
 5865 0884 CDBF      		out __SP_L__,r28
 5866               	/* prologue end (size=10) */
 5867 0886 8983      		std Y+1,r24
 5868 0888 9A83      		std Y+2,r25
 5869 088a 6B83      		std Y+3,r22
 5870 088c 4C83      		std Y+4,r20
 5871 088e 2D83      		std Y+5,r18
 288:display.h     **** 	unsigned char x=0;
 5873               	.LM189:
 5874 0890 1E82      		std Y+6,__zero_reg__
 289:display.h     **** 
 290:display.h     **** 	if(uRow!=255 && uPosition!=255)	//when the row and column is 255, do not set the cursor position, 
 5876               	.LM190:
 5877 0892 8C81      		ldd r24,Y+4
 5878 0894 8F3F      		cpi r24,lo8(-1)
 5879 0896 49F0      		breq .L98
 5881               	.LM191:
 5882 0898 8B81      		ldd r24,Y+3
 5883 089a 8F3F      		cpi r24,lo8(-1)
 5884 089c 31F0      		breq .L98
 291:display.h     **** 	{
 292:display.h     **** 		set_line(uRow);	//set the line (row) for writing
 5886               	.LM192:
 5887 089e 8C81      		ldd r24,Y+4
 5888 08a0 0E94 0000 		call set_line
 293:display.h     **** 		moveCursorToColumn(uPosition);	//set the number of pixels from the left to start writing.
 5890               	.LM193:
 5891 08a4 8B81      		ldd r24,Y+3
 5892 08a6 0E94 0000 		call moveCursorToColumn
 5893               	.L98:
 294:display.h     **** 	}
 295:display.h     **** 	if(boolInvert)	//a blue character on a white background
 5895               	.LM194:
 5896 08aa 8D81      		ldd r24,Y+5
 5897 08ac 8823      		tst r24
 5898 08ae 19F0      		breq .L100
 296:display.h     **** 	{
 297:display.h     **** 		write_data(0xff);	//this puts a verticle, one pixel space between characters
 5900               	.LM195:
 5901 08b0 8FEF      		ldi r24,lo8(-1)
 5902 08b2 0E94 0000 		call write_data
 5903               	.L100:
 298:display.h     **** 	}
 299:display.h     **** 
 300:display.h     **** 	while(x!=0xff)		//The array will be terminated with a 0xFF character
 5905               	.LM196:
 5906 08b6 8E81      		ldd r24,Y+6
 5907 08b8 8F3F      		cpi r24,lo8(-1)
 5908 08ba C1F0      		breq .L101
 5909               	.LBB9:
 301:display.h     **** 	{
 302:display.h     **** 		x=PRG_RDB(pts);		//get the byte out of flash based upon the pointer,
 5911               	.LM197:
 5912 08bc 8981      		ldd r24,Y+1
 5913 08be 9A81      		ldd r25,Y+2
 5914 08c0 8F83      		std Y+7,r24
 5915 08c2 9887      		std Y+8,r25
 5916 08c4 EF81      		ldd r30,Y+7
 5917 08c6 F885      		ldd r31,Y+8
 5918               	/* #APP */
 5919 08c8 8491      		lpm r24, Z
 5920               		
 5921               	/* #NOAPP */
 5922 08ca 8987      		std Y+9,r24
 5923               	.LBE9:
 5924 08cc 8985      		ldd r24,Y+9
 5925 08ce 8E83      		std Y+6,r24
 303:display.h     **** 		if(x!=0xff)		//have we reached the end of the display array?
 5927               	.LM198:
 5928 08d0 8E81      		ldd r24,Y+6
 5929 08d2 8F3F      		cpi r24,lo8(-1)
 5930 08d4 81F3      		breq .L100
 304:display.h     **** 		{
 305:display.h     **** 			write_char(x-32,boolInvert);	//adjust the character to the font table and 
 5932               	.LM199:
 5933 08d6 8E81      		ldd r24,Y+6
 5934 08d8 8052      		subi r24,lo8(-(-32))
 5935 08da 6D81      		ldd r22,Y+5
 5936 08dc 0E94 0000 		call write_char
 306:display.h     **** 				// then write it to the screen.
 307:display.h     **** 			pts++;	//advance the pointer to the flash table in preparation for the next reading.
 5938               	.LM200:
 5939 08e0 8981      		ldd r24,Y+1
 5940 08e2 9A81      		ldd r25,Y+2
 5941 08e4 0196      		adiw r24,1
 5942 08e6 8983      		std Y+1,r24
 5943 08e8 9A83      		std Y+2,r25
 5944 08ea E5CF      		rjmp .L100
 5945               	.L101:
 308:display.h     **** 		}
 309:display.h     **** 	}
 310:display.h     **** 	if(!boolInvert)	//a blue character on a white background, takes off the 8 pixels on the end of the
 5947               	.LM201:
 5948 08ec 8D81      		ldd r24,Y+5
 5949 08ee 8823      		tst r24
 5950 08f0 19F4      		brne .L97
 311:display.h     **** 	{
 312:display.h     **** 		write_data(0x00);	//this puts a verticle, on pixel space after the line has printed
 5952               	.LM202:
 5953 08f2 80E0      		ldi r24,lo8(0)
 5954 08f4 0E94 0000 		call write_data
 5955               	.L97:
 5956               	/* epilogue: frame size=9 */
 5957 08f8 2996      		adiw r28,9
 5958 08fa 0FB6      		in __tmp_reg__,__SREG__
 5959 08fc F894      		cli
 5960 08fe DEBF      		out __SP_H__,r29
 5961 0900 0FBE      		out __SREG__,__tmp_reg__
 5962 0902 CDBF      		out __SP_L__,r28
 5963 0904 DF91      		pop r29
 5964 0906 CF91      		pop r28
 5965 0908 0895      		ret
 5966               	/* epilogue end (size=9) */
 5967               	/* function drawText size 79 (60) */
 5978               	.global	subLargeCOlon
 5980               	subLargeCOlon:
 313:display.h     **** 	}
 314:display.h     **** 
 315:display.h     **** }
 316:display.h     **** 
 317:display.h     **** 
 318:display.h     **** //Parameters for the passed variables:
 319:display.h     **** //	uStartRow: 0 to 7, the start row of the big text
 320:display.h     **** //	uStartColum:  0 to 112, the pixel count to start the number from the left side of the display
 321:display.h     **** //  boolInvert: if true, blue on a white background, if false, white on a blue background
 322:display.h     **** void subLargeCOlon(unsigned char uStartRow, unsigned char uStartColumn, bool boolInvert)
 323:display.h     **** {
 5982               	.LM203:
 5983               	/* prologue: frame size=10 */
 5984 090a CF93      		push r28
 5985 090c DF93      		push r29
 5986 090e CDB7      		in r28,__SP_L__
 5987 0910 DEB7      		in r29,__SP_H__
 5988 0912 2A97      		sbiw r28,10
 5989 0914 0FB6      		in __tmp_reg__,__SREG__
 5990 0916 F894      		cli
 5991 0918 DEBF      		out __SP_H__,r29
 5992 091a 0FBE      		out __SREG__,__tmp_reg__
 5993 091c CDBF      		out __SP_L__,r28
 5994               	/* prologue end (size=10) */
 5995 091e 8983      		std Y+1,r24
 5996 0920 6A83      		std Y+2,r22
 5997 0922 4B83      		std Y+3,r20
 324:display.h     **** 	unsigned char uAlpha;
 325:display.h     **** 	unsigned int intS;
 326:display.h     **** 	
 327:display.h     **** 	bool boolFirstNonZero=false;
 5999               	.LM204:
 6000 0924 1F82      		std Y+7,__zero_reg__
 328:display.h     **** 
 329:display.h     **** 	set_line(uStartRow);		//set the line for writing a string of characters
 6002               	.LM205:
 6003 0926 8981      		ldd r24,Y+1
 6004 0928 0E94 0000 		call set_line
 330:display.h     **** 	moveCursorToColumn(uStartColumn);	//write white spaces to get to the right column
 6006               	.LM206:
 6007 092c 8A81      		ldd r24,Y+2
 6008 092e 0E94 0000 		call moveCursorToColumn
 331:display.h     **** 	boolFirstNonZero=true;	//we must have had our first non-zero digit
 6010               	.LM207:
 6011 0932 81E0      		ldi r24,lo8(1)
 6012 0934 8F83      		std Y+7,r24
 332:display.h     **** 	for(uAlpha=0;uAlpha<15;uAlpha++)	//get the top 16 bytes out of flash for the current digit
 6014               	.LM208:
 6015 0936 1C82      		std Y+4,__zero_reg__
 6016               	.L105:
 6018               	.LM209:
 6019 0938 8C81      		ldd r24,Y+4
 6020 093a 8F30      		cpi r24,lo8(15)
 6021 093c 00F5      		brsh .L106
 6022               	.LBB10:
 333:display.h     **** 	{		
 334:display.h     **** 		intS=PRG_RDB(&strBigFontColon[uAlpha]);	//get the raw data character data out of flash
 6024               	.LM210:
 6025 093e 8C81      		ldd r24,Y+4
 6026 0940 9927      		clr r25
 6027 0942 8050      		subi r24,lo8(-(strBigFontColon))
 6028 0944 9040      		sbci r25,hi8(-(strBigFontColon))
 6029 0946 8887      		std Y+8,r24
 6030 0948 9987      		std Y+9,r25
 6031 094a E885      		ldd r30,Y+8
 6032 094c F985      		ldd r31,Y+9
 6033               	/* #APP */
 6034 094e 8491      		lpm r24, Z
 6035               		
 6036               	/* #NOAPP */
 6037 0950 8A87      		std Y+10,r24
 6038               	.LBE10:
 6039 0952 8A85      		ldd r24,Y+10
 6040 0954 9927      		clr r25
 6041 0956 8D83      		std Y+5,r24
 6042 0958 9E83      		std Y+6,r25
 335:display.h     **** 		if(boolInvert)
 6044               	.LM211:
 6045 095a 8B81      		ldd r24,Y+3
 6046 095c 8823      		tst r24
 6047 095e 41F0      		breq .L108
 336:display.h     **** 		{
 337:display.h     **** 			intS=intS^255;
 6049               	.LM212:
 6050 0960 8D81      		ldd r24,Y+5
 6051 0962 9E81      		ldd r25,Y+6
 6052 0964 2FEF      		ldi r18,lo8(255)
 6053 0966 30E0      		ldi r19,hi8(255)
 6054 0968 8227      		eor r24,r18
 6055 096a 9327      		eor r25,r19
 6056 096c 8D83      		std Y+5,r24
 6057 096e 9E83      		std Y+6,r25
 6058               	.L108:
 338:display.h     **** 		}
 339:display.h     **** 		write_data(intS);		//write the data to the display
 6060               	.LM213:
 6061 0970 8D81      		ldd r24,Y+5
 6062 0972 0E94 0000 		call write_data
 6064               	.LM214:
 6065 0976 8C81      		ldd r24,Y+4
 6066 0978 8F5F      		subi r24,lo8(-(1))
 6067 097a 8C83      		std Y+4,r24
 6068 097c DDCF      		rjmp .L105
 6069               	.L106:
 340:display.h     **** 	}
 341:display.h     **** 	set_line(uStartRow+1);		//set the line for writing a string of characters
 6071               	.LM215:
 6072 097e 8981      		ldd r24,Y+1
 6073 0980 8F5F      		subi r24,lo8(-(1))
 6074 0982 0E94 0000 		call set_line
 342:display.h     **** 	moveCursorToColumn(uStartColumn);
 6076               	.LM216:
 6077 0986 8A81      		ldd r24,Y+2
 6078 0988 0E94 0000 		call moveCursorToColumn
 343:display.h     **** 	for(uAlpha=16;uAlpha<31;uAlpha++)	//get the middle 16 bytes out of flash for the current digit
 6080               	.LM217:
 6081 098c 80E1      		ldi r24,lo8(16)
 6082 098e 8C83      		std Y+4,r24
 6083               	.L109:
 6084 0990 8C81      		ldd r24,Y+4
 6085 0992 8F31      		cpi r24,lo8(31)
 6086 0994 00F5      		brsh .L110
 6087               	.LBB11:
 344:display.h     **** 	{		
 345:display.h     **** 		intS=PRG_RDB(&strBigFontColon[uAlpha]);	//get the raw data character data out of flash
 6089               	.LM218:
 6090 0996 8C81      		ldd r24,Y+4
 6091 0998 9927      		clr r25
 6092 099a 8050      		subi r24,lo8(-(strBigFontColon))
 6093 099c 9040      		sbci r25,hi8(-(strBigFontColon))
 6094 099e 8887      		std Y+8,r24
 6095 09a0 9987      		std Y+9,r25
 6096 09a2 E885      		ldd r30,Y+8
 6097 09a4 F985      		ldd r31,Y+9
 6098               	/* #APP */
 6099 09a6 8491      		lpm r24, Z
 6100               		
 6101               	/* #NOAPP */
 6102 09a8 8A87      		std Y+10,r24
 6103               	.LBE11:
 6104 09aa 8A85      		ldd r24,Y+10
 6105 09ac 9927      		clr r25
 6106 09ae 8D83      		std Y+5,r24
 6107 09b0 9E83      		std Y+6,r25
 346:display.h     **** 		if(boolInvert)
 6109               	.LM219:
 6110 09b2 8B81      		ldd r24,Y+3
 6111 09b4 8823      		tst r24
 6112 09b6 41F0      		breq .L112
 347:display.h     **** 		{
 348:display.h     **** 			intS=intS^255;
 6114               	.LM220:
 6115 09b8 8D81      		ldd r24,Y+5
 6116 09ba 9E81      		ldd r25,Y+6
 6117 09bc 2FEF      		ldi r18,lo8(255)
 6118 09be 30E0      		ldi r19,hi8(255)
 6119 09c0 8227      		eor r24,r18
 6120 09c2 9327      		eor r25,r19
 6121 09c4 8D83      		std Y+5,r24
 6122 09c6 9E83      		std Y+6,r25
 6123               	.L112:
 349:display.h     **** 		}
 350:display.h     **** 		write_data(intS);		//write the data to the display
 6125               	.LM221:
 6126 09c8 8D81      		ldd r24,Y+5
 6127 09ca 0E94 0000 		call write_data
 6129               	.LM222:
 6130 09ce 8C81      		ldd r24,Y+4
 6131 09d0 8F5F      		subi r24,lo8(-(1))
 6132 09d2 8C83      		std Y+4,r24
 6133 09d4 DDCF      		rjmp .L109
 6134               	.L110:
 351:display.h     **** 	}
 352:display.h     **** 	set_line(uStartRow+2);		//set the line for writing a string of characters
 6136               	.LM223:
 6137 09d6 8981      		ldd r24,Y+1
 6138 09d8 8E5F      		subi r24,lo8(-(2))
 6139 09da 0E94 0000 		call set_line
 353:display.h     **** 	moveCursorToColumn(uStartColumn);
 6141               	.LM224:
 6142 09de 8A81      		ldd r24,Y+2
 6143 09e0 0E94 0000 		call moveCursorToColumn
 354:display.h     **** 	boolFirstNonZero=false;	//preperation for the blanking the leading zeros
 6145               	.LM225:
 6146 09e4 1F82      		std Y+7,__zero_reg__
 355:display.h     **** 	boolFirstNonZero=true;
 6148               	.LM226:
 6149 09e6 81E0      		ldi r24,lo8(1)
 6150 09e8 8F83      		std Y+7,r24
 356:display.h     **** 	for(uAlpha=32;uAlpha<47;uAlpha++)	//get the bottom 16 bytes out of flash for the current digit
 6152               	.LM227:
 6153 09ea 80E2      		ldi r24,lo8(32)
 6154 09ec 8C83      		std Y+4,r24
 6155               	.L113:
 6156 09ee 8C81      		ldd r24,Y+4
 6157 09f0 8F32      		cpi r24,lo8(47)
 6158 09f2 00F5      		brsh .L104
 6159               	.LBB12:
 357:display.h     **** 	{		
 358:display.h     **** 		intS=PRG_RDB(&strBigFontColon[uAlpha]);	//get the raw data character data out of flash
 6161               	.LM228:
 6162 09f4 8C81      		ldd r24,Y+4
 6163 09f6 9927      		clr r25
 6164 09f8 8050      		subi r24,lo8(-(strBigFontColon))
 6165 09fa 9040      		sbci r25,hi8(-(strBigFontColon))
 6166 09fc 8887      		std Y+8,r24
 6167 09fe 9987      		std Y+9,r25
 6168 0a00 E885      		ldd r30,Y+8
 6169 0a02 F985      		ldd r31,Y+9
 6170               	/* #APP */
 6171 0a04 8491      		lpm r24, Z
 6172               		
 6173               	/* #NOAPP */
 6174 0a06 8A87      		std Y+10,r24
 6175               	.LBE12:
 6176 0a08 8A85      		ldd r24,Y+10
 6177 0a0a 9927      		clr r25
 6178 0a0c 8D83      		std Y+5,r24
 6179 0a0e 9E83      		std Y+6,r25
 359:display.h     **** 		if(boolInvert)
 6181               	.LM229:
 6182 0a10 8B81      		ldd r24,Y+3
 6183 0a12 8823      		tst r24
 6184 0a14 41F0      		breq .L116
 360:display.h     **** 		{
 361:display.h     **** 			intS=intS^255;	//inverts the background with forground color, This exclusive or's the value from
 6186               	.LM230:
 6187 0a16 8D81      		ldd r24,Y+5
 6188 0a18 9E81      		ldd r25,Y+6
 6189 0a1a 2FEF      		ldi r18,lo8(255)
 6190 0a1c 30E0      		ldi r19,hi8(255)
 6191 0a1e 8227      		eor r24,r18
 6192 0a20 9327      		eor r25,r19
 6193 0a22 8D83      		std Y+5,r24
 6194 0a24 9E83      		std Y+6,r25
 6195               	.L116:
 362:display.h     **** 		}
 363:display.h     **** 		write_data(intS);		//write the data to the display
 6197               	.LM231:
 6198 0a26 8D81      		ldd r24,Y+5
 6199 0a28 0E94 0000 		call write_data
 6201               	.LM232:
 6202 0a2c 8C81      		ldd r24,Y+4
 6203 0a2e 8F5F      		subi r24,lo8(-(1))
 6204 0a30 8C83      		std Y+4,r24
 6205 0a32 DDCF      		rjmp .L113
 6206               	.L104:
 6207               	/* epilogue: frame size=10 */
 6208 0a34 2A96      		adiw r28,10
 6209 0a36 0FB6      		in __tmp_reg__,__SREG__
 6210 0a38 F894      		cli
 6211 0a3a DEBF      		out __SP_H__,r29
 6212 0a3c 0FBE      		out __SREG__,__tmp_reg__
 6213 0a3e CDBF      		out __SP_L__,r28
 6214 0a40 DF91      		pop r29
 6215 0a42 CF91      		pop r28
 6216 0a44 0895      		ret
 6217               	/* epilogue end (size=9) */
 6218               	/* function subLargeCOlon size 167 (148) */
 6241               	.global	paintMenu
 6243               	paintMenu:
 6245               	.Ltext3:
   1:menu.h        **** /*
   2:menu.h        **** Author:  Matt Meerian
   3:menu.h        **** Date:  January 21, 2005
   4:menu.h        **** Target Processor:  ATMEGA8535 from Atmel
   5:menu.h        **** Languate used:  AVR GCC compiler (in the "C" language)
   6:menu.h        **** Overview:
   7:menu.h        **** 	This file will be used to test the basic operation of the 128x64 pixel,
   8:menu.h        **** 	2.8", blue and white, LCD from Optrex.  (Part Number F-51553GNBJ-LW-AB)  The
   9:menu.h        **** 	hardware interface will be through a demo board from Apollo Display.  (Part
  10:menu.h        **** 	Number:  F-51553-Eval
  11:menu.h        **** 	Handles the basic painting and matence of the menus.
  12:menu.h        **** */
  13:menu.h        **** 
  14:menu.h        **** 
  15:menu.h        **** //#include <define.h>
  16:menu.h        **** 
  17:menu.h        **** void paintMenu(unsigned char *pts,unsigned char uMinHighlight,unsigned char uMaxHighLight);
  18:menu.h        **** 
  19:menu.h        **** //----------------------------------------------------------------------------
  20:menu.h        **** //Routine:     paintMenu(paints the menus when there is a change)
  21:menu.h        **** //
  22:menu.h        **** //Function:
  23:menu.h        **** //		This routine handles painting the menus.  (all 8 lines)  A highlight bar can be 
  24:menu.h        **** //		moved up and down.
  25:menu.h        **** //
  26:menu.h        **** //Varibles passed:
  27:menu.h        **** //      unsigned char *pts:  This is the pointer to the 2D array to print the full menu screen
  28:menu.h        **** //		unsigned char uMinHighlight:  the text lines on the LCD are numbered 0 to 7, starting
  29:menu.h        **** //			from the top down.  This is the closest that the highlight can go to line 0.
  30:menu.h        **** //		unsigned char uMaxHighlight:  the text lines on the LCD are numbered 0 to 7, starting
  31:menu.h        **** //			from the top down.  This is the closest that the highlight can go to line 7. 
  32:menu.h        **** //			(the bottom of the screen)
  33:menu.h        **** //Returns:
  34:menu.h        **** //       none
  35:menu.h        **** //----------------------------------------------------------------------------
  36:menu.h        **** void paintMenu(unsigned char *pts,unsigned char uMinHighlight,unsigned char uMaxHighlight)
  37:menu.h        **** {
 6247               	.LM233:
 6248               	/* prologue: frame size=5 */
 6249 0a46 CF93      		push r28
 6250 0a48 DF93      		push r29
 6251 0a4a CDB7      		in r28,__SP_L__
 6252 0a4c DEB7      		in r29,__SP_H__
 6253 0a4e 2597      		sbiw r28,5
 6254 0a50 0FB6      		in __tmp_reg__,__SREG__
 6255 0a52 F894      		cli
 6256 0a54 DEBF      		out __SP_H__,r29
 6257 0a56 0FBE      		out __SREG__,__tmp_reg__
 6258 0a58 CDBF      		out __SP_L__,r28
 6259               	/* prologue end (size=10) */
 6260 0a5a 8983      		std Y+1,r24
 6261 0a5c 9A83      		std Y+2,r25
 6262 0a5e 6B83      		std Y+3,r22
 6263 0a60 4C83      		std Y+4,r20
  38:menu.h        **** 	unsigned char x;
  39:menu.h        **** 	
  40:menu.h        **** 	if(uMinHighlight != 0 && uMaxHighlight != 0)	//do not put up the highlight when 
 6265               	.LM234:
 6266 0a62 8B81      		ldd r24,Y+3
 6267 0a64 8823      		tst r24
 6268 0a66 99F0      		breq .L118
 6270               	.LM235:
 6271 0a68 8C81      		ldd r24,Y+4
 6272 0a6a 8823      		tst r24
 6273 0a6c 81F0      		breq .L118
  41:menu.h        **** 		// the min and max highlight value is 0 and 0.
  42:menu.h        **** 	{
  43:menu.h        **** 		if(uSelectedLine > uMaxHighlight)	//have we reached the bottom of the area to highlight?
 6275               	.LM236:
 6276 0a6e 9091 0000 		lds r25,uSelectedLine
 6277 0a72 8C81      		ldd r24,Y+4
 6278 0a74 8917      		cp r24,r25
 6279 0a76 18F4      		brsh .L119
  44:menu.h        **** 		{
  45:menu.h        **** 			uSelectedLine=uMinHighlight;	//yes, circle back around to the top of the area we can highlight
 6281               	.LM237:
 6282 0a78 8B81      		ldd r24,Y+3
 6283 0a7a 8093 0000 		sts uSelectedLine,r24
 6284               	.L119:
  46:menu.h        **** 		}
  47:menu.h        **** 		if(uSelectedLine < uMinHighlight)	//have we reached the top of the area to highlight?
 6286               	.LM238:
 6287 0a7e 9091 0000 		lds r25,uSelectedLine
 6288 0a82 8B81      		ldd r24,Y+3
 6289 0a84 9817      		cp r25,r24
 6290 0a86 18F4      		brsh .L118
  48:menu.h        **** 		{
  49:menu.h        **** 			uSelectedLine=uMaxHighlight;	//yes, circle back around to the bottom of the area we can hightlig
 6292               	.LM239:
 6293 0a88 8C81      		ldd r24,Y+4
 6294 0a8a 8093 0000 		sts uSelectedLine,r24
 6295               	.L118:
  50:menu.h        **** 		}
  51:menu.h        **** 	}
  52:menu.h        **** 	//the next line draws the title line on the menu
  53:menu.h        **** 	drawText(&pts[0],0,0,false);	//string, column, line, inverted
 6297               	.LM240:
 6298 0a8e 20E0      		ldi r18,lo8(0)
 6299 0a90 40E0      		ldi r20,lo8(0)
 6300 0a92 60E0      		ldi r22,lo8(0)
 6301 0a94 8981      		ldd r24,Y+1
 6302 0a96 9A81      		ldd r25,Y+2
 6303 0a98 0E94 0000 		call drawText
  54:menu.h        **** 	//The next line was "for(x=1;x<7;x++)" when there was soft button labels
  55:menu.h        **** 	for(x=1;x<8;x++)	//This steps through the main area on lines 1 to 7
 6305               	.LM241:
 6306 0a9c 81E0      		ldi r24,lo8(1)
 6307 0a9e 8D83      		std Y+5,r24
 6308               	.L121:
 6309 0aa0 8D81      		ldd r24,Y+5
 6310 0aa2 8830      		cpi r24,lo8(8)
 6311 0aa4 60F5      		brsh .L117
  56:menu.h        **** 	{		
  57:menu.h        **** 		if(uMinHighlight != 0 && uMaxHighlight != 0 && uSelectedLine==x)
 6313               	.LM242:
 6314 0aa6 8B81      		ldd r24,Y+3
 6315 0aa8 8823      		tst r24
 6316 0aaa B9F0      		breq .L124
 6317 0aac 8C81      		ldd r24,Y+4
 6318 0aae 8823      		tst r24
 6319 0ab0 A1F0      		breq .L124
 6320 0ab2 9091 0000 		lds r25,uSelectedLine
 6321 0ab6 8D81      		ldd r24,Y+5
 6322 0ab8 9817      		cp r25,r24
 6323 0aba 79F4      		brne .L124
  58:menu.h        **** 		{	//only go in here when we are reached the highlighted line, there is only one
  59:menu.h        **** 			//This prints the non highlighted lines, 22 is the offset in the 2d 
  60:menu.h        **** 			// table to the line we want to display
  61:menu.h        **** 			drawText(&pts[x*22],defTab,x,true);	//string, column, line, inverted
 6325               	.LM243:
 6326 0abc 9D81      		ldd r25,Y+5
 6327 0abe 86E1      		ldi r24,lo8(22)
 6328 0ac0 989F      		mul r25,r24
 6329 0ac2 9001      		movw r18,r0
 6330 0ac4 1124      		clr r1
 6331 0ac6 8981      		ldd r24,Y+1
 6332 0ac8 9A81      		ldd r25,Y+2
 6333 0aca 820F      		add r24,r18
 6334 0acc 931F      		adc r25,r19
 6335 0ace 21E0      		ldi r18,lo8(1)
 6336 0ad0 4D81      		ldd r20,Y+5
 6337 0ad2 6AE0      		ldi r22,lo8(10)
 6338 0ad4 0E94 0000 		call drawText
 6339 0ad8 0EC0      		rjmp .L123
 6340               	.L124:
  62:menu.h        **** 			/*
  63:menu.h        **** 			if(uState==50 && (x==1 || x==2))	
  64:menu.h        **** 			{	//go in here if we are in the main menu, on the audio (line 1) or range (line 2) line
  65:menu.h        **** 				if(x==1)	//we must be on the audio line
  66:menu.h        **** 				{
  67:menu.h        **** 					write_char(uAudio+0x10,true);	//write the highlighted audio value to 
  68:menu.h        **** 						// the end of "AUDIO = "
  69:menu.h        **** 				}
  70:menu.h        **** 				if(x==2)
  71:menu.h        **** 				{
  72:menu.h        **** 					write_char(uRange+0x10,true);	//write the highlighted range value to
  73:menu.h        **** 						// the end of "RANGE = "
  74:menu.h        **** 				}
  75:menu.h        **** 			}*/
  76:menu.h        **** 		}
  77:menu.h        **** 		else
  78:menu.h        **** 		{	//print all the non highlighted menu items
  79:menu.h        **** 			drawText(&pts[x*22],defTab,x,false);	//string, column, line, inverted
 6342               	.LM244:
 6343 0ada 9D81      		ldd r25,Y+5
 6344 0adc 86E1      		ldi r24,lo8(22)
 6345 0ade 989F      		mul r25,r24
 6346 0ae0 9001      		movw r18,r0
 6347 0ae2 1124      		clr r1
 6348 0ae4 8981      		ldd r24,Y+1
 6349 0ae6 9A81      		ldd r25,Y+2
 6350 0ae8 820F      		add r24,r18
 6351 0aea 931F      		adc r25,r19
 6352 0aec 20E0      		ldi r18,lo8(0)
 6353 0aee 4D81      		ldd r20,Y+5
 6354 0af0 6AE0      		ldi r22,lo8(10)
 6355 0af2 0E94 0000 		call drawText
 6356               	.L123:
 6358               	.LM245:
 6359 0af6 8D81      		ldd r24,Y+5
 6360 0af8 8F5F      		subi r24,lo8(-(1))
 6361 0afa 8D83      		std Y+5,r24
 6362 0afc D1CF      		rjmp .L121
 6363               	.L117:
 6364               	/* epilogue: frame size=5 */
 6365 0afe 2596      		adiw r28,5
 6366 0b00 0FB6      		in __tmp_reg__,__SREG__
 6367 0b02 F894      		cli
 6368 0b04 DEBF      		out __SP_H__,r29
 6369 0b06 0FBE      		out __SREG__,__tmp_reg__
 6370 0b08 CDBF      		out __SP_L__,r28
 6371 0b0a DF91      		pop r29
 6372 0b0c CF91      		pop r28
 6373 0b0e 0895      		ret
 6374               	/* epilogue end (size=9) */
 6375               	/* function paintMenu size 101 (82) */
 6381               	.global	uCinit
 6383               	uCinit:
 6385               	.Ltext4:
   1:misc.h        **** //unsigned char segTblReturn(unsigned char uLookMeUp);
   2:misc.h        **** void uCinit(void);		//initialization routine for the ATMEGA8535
   3:misc.h        **** //void clearRecStr(void);
   4:misc.h        **** 
   5:misc.h        **** 
   6:misc.h        **** //This takes the 7-segment LED code from the Eagle counting unit and converts it into a
   7:misc.h        **** // number from 0 to 9.
   8:misc.h        **** /*
   9:misc.h        **** unsigned char segTblReturn(unsigned char uLookMeUp)
  10:misc.h        **** {
  11:misc.h        **** 	u08 x;
  12:misc.h        **** 	
  13:misc.h        **** 	for(x=0;x<10;x++)
  14:misc.h        **** 	{
  15:misc.h        **** 		if(PRG_RDB(&strSegTbl[x])==uLookMeUp)	
  16:misc.h        **** 		{
  17:misc.h        **** 			return(x);	//we found the number in the 7 segment LED lookup table
  18:misc.h        **** 		}
  19:misc.h        **** 	}
  20:misc.h        **** 	return(0);	//we did not find the number in the lookup table
  21:misc.h        **** }
  22:misc.h        **** */
  23:misc.h        **** 
  24:misc.h        **** //----------------------------------------------------------------------------
  25:misc.h        **** //Routine:     uCinit  (initialization of the microcontroller)
  26:misc.h        **** //
  27:misc.h        **** //Function:    initialize the I/O lines, timers, interrupts, etc.
  28:misc.h        **** //
  29:misc.h        **** //Varibles passed:
  30:misc.h        **** //       none
  31:misc.h        **** //Returns:
  32:misc.h        **** //       none
  33:misc.h        **** //----------------------------------------------------------------------------
  34:misc.h        **** void uCinit(void)
  35:misc.h        **** {
 6387               	.LM246:
 6388               	/* prologue: frame size=0 */
 6389 0b10 CF93      		push r28
 6390 0b12 DF93      		push r29
 6391 0b14 CDB7      		in r28,__SP_L__
 6392 0b16 DEB7      		in r29,__SP_H__
 6393               	/* prologue end (size=4) */
  36:misc.h        ****    outp(0xF0,DDRA);           //PortA, Pin 5 is an ADC input
 6395               	.LM247:
 6396 0b18 80EF      		ldi r24,lo8(-16)
 6397 0b1a 8093 3A00 		sts 58,r24
  37:misc.h        ****    outp(0x0F,PORTA);			//enable the pull up resistor for the POrtA, Pin 5
 6399               	.LM248:
 6400 0b1e 8FE0      		ldi r24,lo8(15)
 6401 0b20 8093 3B00 		sts 59,r24
  38:misc.h        ****    outp(0x1F,DDRB);           //only the push buttons are input pins
 6403               	.LM249:
 6404 0b24 8FE1      		ldi r24,lo8(31)
 6405 0b26 8093 3700 		sts 55,r24
  39:misc.h        ****    outp(0xE0,PORTB);          //enable pull-up resistors
 6407               	.LM250:
 6408 0b2a 80EE      		ldi r24,lo8(-32)
 6409 0b2c 8093 3800 		sts 56,r24
  40:misc.h        ****    outp(0xFF,DDRC);           //use all pins on PortA for output
 6411               	.LM251:
 6412 0b30 8FEF      		ldi r24,lo8(-1)
 6413 0b32 8093 3400 		sts 52,r24
  41:misc.h        ****    //outp(0xFC,PORTC);          //the pullup resistors are on all pins except the LCD control lines
  42:misc.h        ****    outp(0xF1,DDRD);           //Portd is mostly inputs, except for the backlight enable, and the au
 6415               	.LM252:
 6416 0b36 81EF      		ldi r24,lo8(-15)
 6417 0b38 8093 3100 		sts 49,r24
  43:misc.h        ****    outp(0x0E,PORTD);          //PortD has allmost all the pullup resistors enabled
 6419               	.LM253:
 6420 0b3c 8EE0      		ldi r24,lo8(14)
 6421 0b3e 8093 3200 		sts 50,r24
  44:misc.h        ****    
  45:misc.h        ****    cbi(defLCDContPort,defLcdRES);       //keep the display in reset
 6423               	.LM254:
 6424 0b42 8091 3800 		lds r24,56
 6425 0b46 8D7F      		andi r24,lo8(-3)
 6426 0b48 8093 3800 		sts 56,r24
  46:misc.h        ****    //8 bit timer 0 initialization, used for the 20mS tock.
  47:misc.h        ****     outp((1<<TOIE0) | (1<<TOIE2), TIMSK);   //enable timer 0 and timer 2 overflow
 6428               	.LM255:
 6429 0b4c 81E4      		ldi r24,lo8(65)
 6430 0b4e 8093 5900 		sts 89,r24
  48:misc.h        ****     outp(0,TCNT0);             // reset TCNT0
 6432               	.LM256:
 6433 0b52 1092 5200 		sts 82,__zero_reg__
  49:misc.h        ****     outp(1,TCCR0);             // count with cpu clock/1024
 6435               	.LM257:
 6436 0b56 81E0      		ldi r24,lo8(1)
 6437 0b58 8093 5300 		sts 83,r24
  50:misc.h        **** 	
  51:misc.h        **** 	//ADC input
  52:misc.h        **** 	ADMUX=0x00;
 6439               	.LM258:
 6440 0b5c 1092 2700 		sts 39,__zero_reg__
  53:misc.h        **** 	ADCSRA=0x86;
 6442               	.LM259:
 6443 0b60 86E8      		ldi r24,lo8(-122)
 6444 0b62 8093 2600 		sts 38,r24
  54:misc.h        **** 	SFIOR&=0x00; 	
 6446               	.LM260:
 6447 0b66 8091 5000 		lds r24,80
 6448 0b6a 1092 5000 		sts 80,__zero_reg__
  55:misc.h        **** 
  56:misc.h        **** 
  57:misc.h        **** 	//8 bit timer 1 initialization, used for the 32.768KHz crystal (Real Time Clock)
  58:misc.h        **** 	outp((1<<CS20) | (1<<CS22), TCCR2);	//divide by 128 for timer counter 2
 6450               	.LM261:
 6451 0b6e 85E0      		ldi r24,lo8(5)
 6452 0b70 8093 4500 		sts 69,r24
  59:misc.h        ****     ASSR = (1<<AS2);        // select asynchronous operation of Timer2
 6454               	.LM262:
 6455 0b74 88E0      		ldi r24,lo8(8)
 6456 0b76 8093 4200 		sts 66,r24
 6457               	.L127:
  60:misc.h        ****     while((ASSR & 0x01) | (ASSR & 0x04));       // wait for TCN2UB and TCR2UB to be cleared
 6459               	.LM263:
 6460 0b7a 8091 4200 		lds r24,66
 6461 0b7e 9927      		clr r25
 6462 0b80 9C01      		movw r18,r24
 6463 0b82 2170      		andi r18,lo8(1)
 6464 0b84 3070      		andi r19,hi8(1)
 6465 0b86 8091 4200 		lds r24,66
 6466 0b8a 9927      		clr r25
 6467 0b8c 8470      		andi r24,lo8(4)
 6468 0b8e 9070      		andi r25,hi8(4)
 6469 0b90 822B      		or r24,r18
 6470 0b92 932B      		or r25,r19
 6471 0b94 0097      		sbiw r24,0
 6472 0b96 09F0      		breq .L128
 6473 0b98 F0CF      		rjmp .L127
 6474               	.L128:
  61:misc.h        **** 	
  62:misc.h        ****     //external interrupt 0 initialization, for pulse from the eagle counting unit
  63:misc.h        **** 	/*
  64:misc.h        **** 	outp((1<<INT0), GIMSK);    // enable external int0
  65:misc.h        **** 	outp((1<<ISC00)|(1<<ISC01), MCUCR);    // rising egde on int0 generates the interrupt
  66:misc.h        **** 	outp((1<<ISC00), MCUCR);    //a change on int0 generates an interrupt
  67:misc.h        **** 	*/
  68:misc.h        ****     //set OC1A pin as output, required for output toggling
  69:misc.h        ****     //DDRD = _BV(PD5);
  70:misc.h        **** 
  71:misc.h        ****     //enable 8 bit PWM, select inverted PWM
  72:misc.h        ****     //TCCR1A =  _BV(PWM10) | _BV(COM1A1) | _BV(COM1A0);
  73:misc.h        ****     
  74:misc.h        ****     // timer1 running on 1/8 MCU clock with clear timer/counter1 on Compare Match
  75:misc.h        ****     // PWM frequency will be MCU clock / 8 / 512, e.g. with 4Mhz Crystal 977 Hz.
  76:misc.h        **** //    TCCR1B = _BV(CS11) | _BV(CTC1);
  77:misc.h        **** 	//if (eeprom_rb(EEKey1)!=defKey1 || eeprom_rb(EEKey2)!=defKey2 || eeprom_rb(EEKey3)!=defKey3)
  78:misc.h        **** 	//{
  79:misc.h        **** 
  80:misc.h        **** 
  81:misc.h        **** /*
  82:misc.h        **** 	intAlarmMin=eeprom_read_word(&MyEepVar);
  83:misc.h        **** 	if(intAlarmMin>59)
  84:misc.h        **** 	{
  85:misc.h        **** 		intAlarmMin=1;
  86:misc.h        **** 	}
  87:misc.h        **** 	intAlarmHour=eeprom_read_word(&defAlarmHour);
  88:misc.h        **** 	if(intAlarmHour>23)
  89:misc.h        **** 	{
  90:misc.h        **** 		intAlarmHour=6;
  91:misc.h        **** 	}
  92:misc.h        **** */
  93:misc.h        **** //	OCR1AL = 50;
  94:misc.h        **** 
  95:misc.h        **** //Get values stored in EEPROM
  96:misc.h        **** 	if(eeprom_read_word((uint16_t*)&EEKey) != 789)		//have we written to the EEPROM before?
 6476               	.LM264:
 6477 0b9a 80E0      		ldi r24,lo8(EEKey)
 6478 0b9c 90E0      		ldi r25,hi8(EEKey)
 6479 0b9e 0E94 0000 		call eeprom_read_word
 6480 0ba2 23E0      		ldi r18,hi8(789)
 6481 0ba4 8531      		cpi r24,lo8(789)
 6482 0ba6 9207      		cpc r25,r18
 6483 0ba8 11F1      		breq .L129
  97:misc.h        **** 	{
  98:misc.h        **** 		eeprom_write_word((uint16_t*)&EEKey,789);	//set the key value to let us know that we have written
 6485               	.LM265:
 6486 0baa 65E1      		ldi r22,lo8(789)
 6487 0bac 73E0      		ldi r23,hi8(789)
 6488 0bae 80E0      		ldi r24,lo8(EEKey)
 6489 0bb0 90E0      		ldi r25,hi8(EEKey)
 6490 0bb2 0E94 0000 		call eeprom_write_word
  99:misc.h        **** 		eeprom_write_word((uint16_t*)&EEMinute,6);	//set all of the default EEPROM values
 6492               	.LM266:
 6493 0bb6 66E0      		ldi r22,lo8(6)
 6494 0bb8 70E0      		ldi r23,hi8(6)
 6495 0bba 80E0      		ldi r24,lo8(EEMinute)
 6496 0bbc 90E0      		ldi r25,hi8(EEMinute)
 6497 0bbe 0E94 0000 		call eeprom_write_word
 100:misc.h        **** 		eeprom_write_word((uint16_t*)&EEHour,6);
 6499               	.LM267:
 6500 0bc2 66E0      		ldi r22,lo8(6)
 6501 0bc4 70E0      		ldi r23,hi8(6)
 6502 0bc6 80E0      		ldi r24,lo8(EEHour)
 6503 0bc8 90E0      		ldi r25,hi8(EEHour)
 6504 0bca 0E94 0000 		call eeprom_write_word
 101:misc.h        **** 		eeprom_write_word((uint16_t*)&EEPhotoTriggerValue,600);
 6506               	.LM268:
 6507 0bce 68E5      		ldi r22,lo8(600)
 6508 0bd0 72E0      		ldi r23,hi8(600)
 6509 0bd2 80E0      		ldi r24,lo8(EEPhotoTriggerValue)
 6510 0bd4 90E0      		ldi r25,hi8(EEPhotoTriggerValue)
 6511 0bd6 0E94 0000 		call eeprom_write_word
 102:misc.h        **** 		eeprom_write_byte((u08*)&EEBacklightOnHour,6);
 6513               	.LM269:
 6514 0bda 66E0      		ldi r22,lo8(6)
 6515 0bdc 80E0      		ldi r24,lo8(EEBacklightOnHour)
 6516 0bde 90E0      		ldi r25,hi8(EEBacklightOnHour)
 6517 0be0 0E94 0000 		call eeprom_write_byte
 103:misc.h        **** 		eeprom_write_byte((u08*)&EEBacklightOffHour,22);	
 6519               	.LM270:
 6520 0be4 66E1      		ldi r22,lo8(22)
 6521 0be6 80E0      		ldi r24,lo8(EEBacklightOffHour)
 6522 0be8 90E0      		ldi r25,hi8(EEBacklightOffHour)
 6523 0bea 0E94 0000 		call eeprom_write_byte
 6524               	.L129:
 104:misc.h        **** 	}
 105:misc.h        **** 	intAlarmMin = eeprom_read_word((uint16_t*)&EEMinute);	//Get the Alarm minute out of EERPOM
 6526               	.LM271:
 6527 0bee 80E0      		ldi r24,lo8(EEMinute)
 6528 0bf0 90E0      		ldi r25,hi8(EEMinute)
 6529 0bf2 0E94 0000 		call eeprom_read_word
 6530 0bf6 9093 0000 		sts (intAlarmMin)+1,r25
 6531 0bfa 8093 0000 		sts intAlarmMin,r24
 106:misc.h        **** 	if(intAlarmMin>59)		//Is the Alarm Minute an illegal value?
 6533               	.LM272:
 6534 0bfe 8091 0000 		lds r24,intAlarmMin
 6535 0c02 9091 0000 		lds r25,(intAlarmMin)+1
 6536 0c06 8C33      		cpi r24,60
 6537 0c08 9105      		cpc r25,__zero_reg__
 6538 0c0a 30F0      		brlo .L130
 107:misc.h        **** 	{
 108:misc.h        **** 		intAlarmMin=5;	//yes, then reset the alarm minute to a legal value
 6540               	.LM273:
 6541 0c0c 85E0      		ldi r24,lo8(5)
 6542 0c0e 90E0      		ldi r25,hi8(5)
 6543 0c10 9093 0000 		sts (intAlarmMin)+1,r25
 6544 0c14 8093 0000 		sts intAlarmMin,r24
 6545               	.L130:
 109:misc.h        **** 	}
 110:misc.h        **** 	intAlarmHour = eeprom_read_word((uint16_t*)&EEHour);	//get the alarm hour out of EEPROM
 6547               	.LM274:
 6548 0c18 80E0      		ldi r24,lo8(EEHour)
 6549 0c1a 90E0      		ldi r25,hi8(EEHour)
 6550 0c1c 0E94 0000 		call eeprom_read_word
 6551 0c20 9093 0000 		sts (intAlarmHour)+1,r25
 6552 0c24 8093 0000 		sts intAlarmHour,r24
 111:misc.h        **** 	if(intAlarmHour>23)		//is the alarm hour an illegal value?
 6554               	.LM275:
 6555 0c28 8091 0000 		lds r24,intAlarmHour
 6556 0c2c 9091 0000 		lds r25,(intAlarmHour)+1
 6557 0c30 8831      		cpi r24,24
 6558 0c32 9105      		cpc r25,__zero_reg__
 6559 0c34 30F0      		brlo .L131
 112:misc.h        **** 	{
 113:misc.h        **** 		intAlarmHour=5;		//yes, then reset the alarm hour to a legal value
 6561               	.LM276:
 6562 0c36 85E0      		ldi r24,lo8(5)
 6563 0c38 90E0      		ldi r25,hi8(5)
 6564 0c3a 9093 0000 		sts (intAlarmHour)+1,r25
 6565 0c3e 8093 0000 		sts intAlarmHour,r24
 6566               	.L131:
 114:misc.h        **** 	}
 115:misc.h        **** 	intUserPhotoTriggerValue = eeprom_read_word((uint16_t*)&EEPhotoTriggerValue);	//get the alarm hour
 6568               	.LM277:
 6569 0c42 80E0      		ldi r24,lo8(EEPhotoTriggerValue)
 6570 0c44 90E0      		ldi r25,hi8(EEPhotoTriggerValue)
 6571 0c46 0E94 0000 		call eeprom_read_word
 6572 0c4a 9093 0000 		sts (intUserPhotoTriggerValue)+1,r25
 6573 0c4e 8093 0000 		sts intUserPhotoTriggerValue,r24
 116:misc.h        **** 	if(intUserPhotoTriggerValue>1000)		//is the intUserPhotoTriggerValue an illegal value?
 6575               	.LM278:
 6576 0c52 8091 0000 		lds r24,intUserPhotoTriggerValue
 6577 0c56 9091 0000 		lds r25,(intUserPhotoTriggerValue)+1
 6578 0c5a 23E0      		ldi r18,hi8(1001)
 6579 0c5c 893E      		cpi r24,lo8(1001)
 6580 0c5e 9207      		cpc r25,r18
 6581 0c60 30F0      		brlo .L132
 117:misc.h        **** 	{
 118:misc.h        **** 		intUserPhotoTriggerValue=500;		//yes, then reset the intUserPhotoTriggerValue to a legal value
 6583               	.LM279:
 6584 0c62 84EF      		ldi r24,lo8(500)
 6585 0c64 91E0      		ldi r25,hi8(500)
 6586 0c66 9093 0000 		sts (intUserPhotoTriggerValue)+1,r25
 6587 0c6a 8093 0000 		sts intUserPhotoTriggerValue,r24
 6588               	.L132:
 119:misc.h        **** 	}
 120:misc.h        **** 	uBacklightOnHour = eeprom_read_byte((u08*)&EEBacklightOnHour);		//get the backlight on time out of
 6590               	.LM280:
 6591 0c6e 80E0      		ldi r24,lo8(EEBacklightOnHour)
 6592 0c70 90E0      		ldi r25,hi8(EEBacklightOnHour)
 6593 0c72 0E94 0000 		call eeprom_read_byte
 6594 0c76 8093 0000 		sts uBacklightOnHour,r24
 121:misc.h        **** 	if(uBacklightOnHour>23)		//is the backlight on hour an illegal value?
 6596               	.LM281:
 6597 0c7a 8091 0000 		lds r24,uBacklightOnHour
 6598 0c7e 8831      		cpi r24,lo8(24)
 6599 0c80 18F0      		brlo .L133
 122:misc.h        **** 	{
 123:misc.h        **** 		uBacklightOnHour=6;		//yes, then reset the ram value to a legal value
 6601               	.LM282:
 6602 0c82 86E0      		ldi r24,lo8(6)
 6603 0c84 8093 0000 		sts uBacklightOnHour,r24
 6604               	.L133:
 124:misc.h        **** 	}
 125:misc.h        **** 	uBacklightOffHour = eeprom_read_byte((u08*)&EEBacklightOffHour);	//get the backlight off time out 
 6606               	.LM283:
 6607 0c88 80E0      		ldi r24,lo8(EEBacklightOffHour)
 6608 0c8a 90E0      		ldi r25,hi8(EEBacklightOffHour)
 6609 0c8c 0E94 0000 		call eeprom_read_byte
 6610 0c90 8093 0000 		sts uBacklightOffHour,r24
 126:misc.h        **** 	if(uBacklightOffHour>23)	//is the backlight off hour an illegal value?
 6612               	.LM284:
 6613 0c94 8091 0000 		lds r24,uBacklightOffHour
 6614 0c98 8831      		cpi r24,lo8(24)
 6615 0c9a 18F0      		brlo .L126
 127:misc.h        **** 	{
 128:misc.h        **** 		uBacklightOffHour=22;	//yes then reset the ram value to a legal value
 6617               	.LM285:
 6618 0c9c 86E1      		ldi r24,lo8(22)
 6619 0c9e 8093 0000 		sts uBacklightOffHour,r24
 6620               	.L126:
 6621               	/* epilogue: frame size=0 */
 6622 0ca2 DF91      		pop r29
 6623 0ca4 CF91      		pop r28
 6624 0ca6 0895      		ret
 6625               	/* epilogue end (size=3) */
 6626               	/* function uCinit size 204 (197) */
 6630               	.global	__vector_11
 6632               	__vector_11:
 6634               	.Ltext5:
   1:main.c        **** /*
   2:main.c        **** Author:  Matt Meerian
   3:main.c        **** Date:  July 11, 2005
   4:main.c        **** Target Processor:  ATMEGA32 from Atmel
   5:main.c        **** Language used:  AVR GCC compiler (in the "C" language)
   6:main.c        **** Overview:
   7:main.c        **** 	This file will be used to test the basic operation of the 128x64 pixel,
   8:main.c        **** 	2.8", blue and white, LCD from Optrex.  (Part Number F-51553GNBJ-LW-AB)  
   9:main.c        **** 	The end use for this code is an alarm clock.  
  10:main.c        **** Hardware:  009-0009-00 (this is my board)	
  11:main.c        **** compiler:  WINAVR avr-gcc (GCC) 3.4.1 (it is listed as 20040720 on the install file)
  12:main.c        **** debugger:  AVR studio 4.11 build 401
  13:main.c        **** Text Editor used:  Programmers Notepad, version: 2.0.5.32
  14:main.c        **** */
  15:main.c        **** 
  16:main.c        **** #include <io.h>
  17:main.c        **** #include <interrupt.h>  //used to allow interrupts
  18:main.c        **** #include <sig-avr.h>
  19:main.c        **** #include <stdbool.h>    //this file allows boolean data types in "C"
  20:main.c        **** #include <pgmspace.h>   //must be included to store arrays in FLASH?
  21:main.c        **** #include <eeprom.h>     //used for writing to the EEPROM
  22:main.c        **** #include <wdt.h>        //for the watchdog timer
  23:main.c        **** #include <string.h>		//for strlen
  24:main.c        **** #include <progmem.h>
  25:main.c        **** #include <stdlib.h>		//for the itoa function
  26:main.c        **** //my header files
  27:main.c        **** #include <define.h>		//defines for the current project, of course.
  28:main.c        **** #include <flash.h>		//contains strings that go into flash for the LCD
  29:main.c        **** 
  30:main.c        **** //subroutine definitions
  31:main.c        **** void integerToArray(unsigned int intNumToString);
  32:main.c        **** void SrvTock(void);
  33:main.c        **** //void write_land_char(unsigned char uWriteLcdChar, bool boolCharInvert);	//write a character to th
  34:main.c        **** void write_command(unsigned char uLcdCommand);    //write a command to the graphical LCD
  35:main.c        **** void write_date(unsigned char uStartColumn,unsigned char uRow, unsigned char uBlank, bool boolInver
  36:main.c        **** void write_small_numbers(unsigned int intSmallNum, bool boolBlankZero, unsigned char uNumbersDispla
  37:main.c        **** void ShowLargeTime(unsigned char uStartColumn, unsigned char uRow);
  38:main.c        **** void ShowLargeAlarmTime(unsigned char uStartColumn, unsigned char uRow);
  39:main.c        **** unsigned char not_leap(void); //check for leap year
  40:main.c        **** 
  41:main.c        **** void InitLCD(void);		//initialize the LCD
  42:main.c        **** void setBacklightOffTime(void);
  43:main.c        **** void setBacklightOnTime(void);
  44:main.c        **** 
  45:main.c        **** 
  46:main.c        **** /*---------------------------------------------------------------------------*/
  47:main.c        **** 
  48:main.c        **** //Declair the data types
  49:main.c        **** typedef unsigned char u08;  //A character, 8 bits
  50:main.c        **** typedef unsigned short u16; //a short integer, big endian 16 bits, 0 to 65535
  51:main.c        **** typedef bool ubool;         //a boolean, true or false, must include the header file "stdbool.h"
  52:main.c        **** 
  53:main.c        **** /*global varibles*/
  54:main.c        **** //The volatile keyword should be used when a variable is used in an interrupt routine
  55:main.c        **** volatile u16 uTock=defTock;	//A counter used for the 20mS tock
  56:main.c        **** u08 uState=0;		//the state for the state machine
  57:main.c        **** u08 uTmrState=210;	//a state timer
  58:main.c        **** u08 uBtnUpTmr=0;		//A debounce timer for button 1
  59:main.c        **** u08 uBtnDwnTmr=0;		//A debounce timer for button 2
  60:main.c        **** u08 uBtnEnterTmr=0;		//A debounce timer for button 3
  61:main.c        **** u08 uBob=10;
  62:main.c        **** u08 uTmrGeneral=10;
  63:main.c        **** u08 uSelectedLine;		//keeps track of which line the user highlights in the menu
  64:main.c        **** u08 uContrast=0x30;
  65:main.c        **** unsigned char str[5];		//for the interger to string routine
  66:main.c        **** unsigned char *pts;
  67:main.c        **** u08 uTimeSetState;		//a sub-state timer
  68:main.c        **** unsigned int intAlarmMin;
  69:main.c        **** unsigned int intAlarmHour;
  70:main.c        **** bool boolSoundAlarm=false;		//The alarm is set to fire when true
  71:main.c        **** bool boolAlarmOn=false;			//The alarm is going off when true
  72:main.c        **** bool boolPowerupBlink=true;	//Blink the display when the unit is first powered up and the time has 
  73:main.c        **** unsigned int intUserPhotoTriggerValue;		//sets the initial user photocell trigger value
  74:main.c        **** u08 uBacklightOnHour;				//This holds the hour the backlight comes on in the morning
  75:main.c        **** u08 uBacklightOffHour;			//This holds the hour the backlight goes off in the evening, 22 is 10pm
  76:main.c        **** unsigned int intPhotocellValue;	//stores the 10 bit ADC photocell value
  77:main.c        **** u08 uRefreshDisplay=0;
  78:main.c        **** const int EEKey __attribute__ ((section (".eeprom"))) = 0xFFFF;
  79:main.c        **** const int EEMinute __attribute__ ((section (".eeprom"))) = 0xFFFF;
  80:main.c        **** const int EEHour __attribute__ ((section (".eeprom"))) = 0xFFFF;
  81:main.c        **** const int EEPhotoTriggerValue __attribute__ ((section (".eeprom"))) = 0xFFFF;
  82:main.c        **** const unsigned char EEBacklightOnHour __attribute__ ((section (".eeprom"))) = 0xFF;
  83:main.c        **** const unsigned char EEBacklightOffHour __attribute__ ((section (".eeprom"))) = 0xFF;
  84:main.c        **** 
  85:main.c        **** 
  86:main.c        **** typedef struct{
  87:main.c        **** unsigned int intSec; //enter the current time, date, month, and year
  88:main.c        **** unsigned int intMin;
  89:main.c        **** unsigned int intHour;
  90:main.c        **** unsigned int intDay;
  91:main.c        **** unsigned int intMonth;
  92:main.c        **** unsigned int intYear;
  93:main.c        **** }time;
  94:main.c        **** time t;
  95:main.c        **** 
  96:main.c        **** /*
  97:main.c        **** const char strOne[] PROGMEM = "Fool";
  98:main.c        **** const char strTwo[] PROGMEM = "heck";
  99:main.c        **** 
 100:main.c        **** PGM_P array[2] PROGMEM = {
 101:main.c        **** 	strOne,
 102:main.c        **** 	strTwo
 103:main.c        **** };
 104:main.c        **** */
 105:main.c        **** 	
 106:main.c        **** #include "lcd.h"		//contains routines specific for the Optrex, 128x64 pixel display
 107:main.c        **** #include "display.h"
 108:main.c        **** #include "menu.h"
 109:main.c        **** #include "misc.h"
 110:main.c        **** 
 111:main.c        **** 
 112:main.c        **** //**************************************************************************
 113:main.c        **** //----------------------------------------------------------------------------
 114:main.c        **** //Routine:     signal(sig_overflow0)  (timer 0 overflow interrupt)
 115:main.c        **** //
 116:main.c        **** //Function:    signal handler for tcnt0 overflow interrupt
 117:main.c        **** //              happens every 64.39 microseconds
 118:main.c        **** //Varibles passed:
 119:main.c        **** //       none
 120:main.c        **** //Returns:
 121:main.c        **** //       none
 122:main.c        **** //----------------------------------------------------------------------------
 123:main.c        **** SIGNAL(SIG_OVERFLOW0)
 124:main.c        **** {
 6636               	.LM286:
 6637               	/* prologue: frame size=0 */
 6638 0ca8 1F92      		push __zero_reg__
 6639 0caa 0F92      		push __tmp_reg__
 6640 0cac 0FB6      		in __tmp_reg__,__SREG__
 6641 0cae 0F92      		push __tmp_reg__
 6642 0cb0 1124      		clr __zero_reg__
 6643 0cb2 8F93      		push r24
 6644 0cb4 9F93      		push r25
 6645 0cb6 CF93      		push r28
 6646 0cb8 DF93      		push r29
 6647 0cba CDB7      		in r28,__SP_L__
 6648 0cbc DEB7      		in r29,__SP_H__
 6649               	/* prologue end (size=11) */
 125:main.c        **** 	if (uTock > 0)
 6651               	.LM287:
 6652 0cbe 8091 0000 		lds r24,uTock
 6653 0cc2 9091 0000 		lds r25,(uTock)+1
 6654 0cc6 0097      		sbiw r24,0
 6655 0cc8 49F0      		breq .L135
 126:main.c        **** 	{
 127:main.c        ****       uTock--;      //This counts down to a 20ms tock.  (which is run in the main loop)
 6657               	.LM288:
 6658 0cca 8091 0000 		lds r24,uTock
 6659 0cce 9091 0000 		lds r25,(uTock)+1
 6660 0cd2 0197      		sbiw r24,1
 6661 0cd4 9093 0000 		sts (uTock)+1,r25
 6662 0cd8 8093 0000 		sts uTock,r24
 6663               	.L135:
 6664               	/* epilogue: frame size=0 */
 6665 0cdc DF91      		pop r29
 6666 0cde CF91      		pop r28
 6667 0ce0 9F91      		pop r25
 6668 0ce2 8F91      		pop r24
 6669 0ce4 0F90      		pop __tmp_reg__
 6670 0ce6 0FBE      		out __SREG__,__tmp_reg__
 6671 0ce8 0F90      		pop __tmp_reg__
 6672 0cea 1F90      		pop __zero_reg__
 6673 0cec 1895      		reti
 6674               	/* epilogue end (size=9) */
 6675               	/* function __vector_11 size 35 (15) */
 6678               	.global	__vector_5
 6680               	__vector_5:
 128:main.c        **** 	}
 129:main.c        **** }
 130:main.c        **** 
 131:main.c        **** //----------------------------------------------------------------------------
 132:main.c        **** //Routine:     signal(sig_overflow2)  (timer 2 overflow interrupt)
 133:main.c        **** //
 134:main.c        **** //Function:    signal handler for tcnt2 overflow interrupt
 135:main.c        **** //              happens every second.  This is based upon the 32.768 KHz crystal
 136:main.c        **** //Varibles passed:
 137:main.c        **** //       none
 138:main.c        **** //Returns:
 139:main.c        **** //       none
 140:main.c        **** //----------------------------------------------------------------------------
 141:main.c        **** SIGNAL(SIG_OVERFLOW2)	//timer 2 overflow
 142:main.c        **** {
 6682               	.LM289:
 6683               	/* prologue: frame size=0 */
 6684 0cee 1F92      		push __zero_reg__
 6685 0cf0 0F92      		push __tmp_reg__
 6686 0cf2 0FB6      		in __tmp_reg__,__SREG__
 6687 0cf4 0F92      		push __tmp_reg__
 6688 0cf6 1124      		clr __zero_reg__
 6689 0cf8 2F93      		push r18
 6690 0cfa 3F93      		push r19
 6691 0cfc 4F93      		push r20
 6692 0cfe 5F93      		push r21
 6693 0d00 6F93      		push r22
 6694 0d02 7F93      		push r23
 6695 0d04 8F93      		push r24
 6696 0d06 9F93      		push r25
 6697 0d08 AF93      		push r26
 6698 0d0a BF93      		push r27
 6699 0d0c EF93      		push r30
 6700 0d0e FF93      		push r31
 6701 0d10 CF93      		push r28
 6702 0d12 DF93      		push r29
 6703 0d14 CDB7      		in r28,__SP_L__
 6704 0d16 DEB7      		in r29,__SP_H__
 6705               	/* prologue end (size=21) */
 143:main.c        **** 	if(uState!=60)	//when we are in the "set time" state, don't advance the time
 6707               	.LM290:
 6708 0d18 8091 0000 		lds r24,uState
 6709 0d1c 8C33      		cpi r24,lo8(60)
 6710 0d1e 09F4      		brne .+2
 6711 0d20 D8C0      		rjmp .L137
 144:main.c        **** 	{
 145:main.c        **** 		if (++t.intSec==60) //keep track of time, date, month, and year
 6713               	.LM291:
 6714 0d22 8091 0000 		lds r24,t
 6715 0d26 9091 0000 		lds r25,(t)+1
 6716 0d2a 0196      		adiw r24,1
 6717 0d2c 9093 0000 		sts (t)+1,r25
 6718 0d30 8093 0000 		sts t,r24
 6719 0d34 8C33      		cpi r24,60
 6720 0d36 9105      		cpc r25,__zero_reg__
 6721 0d38 09F0      		breq .+2
 6722 0d3a CBC0      		rjmp .L137
 146:main.c        **** 		{
 147:main.c        **** 			t.intSec=0;
 6724               	.LM292:
 6725 0d3c 1092 0000 		sts (t)+1,__zero_reg__
 6726 0d40 1092 0000 		sts t,__zero_reg__
 148:main.c        **** 			if (++t.intMin==60)
 6728               	.LM293:
 6729 0d44 8091 0000 		lds r24,t+2
 6730 0d48 9091 0000 		lds r25,(t+2)+1
 6731 0d4c 0196      		adiw r24,1
 6732 0d4e 9093 0000 		sts (t+2)+1,r25
 6733 0d52 8093 0000 		sts t+2,r24
 6734 0d56 8C33      		cpi r24,60
 6735 0d58 9105      		cpc r25,__zero_reg__
 6736 0d5a 09F0      		breq .+2
 6737 0d5c BAC0      		rjmp .L137
 149:main.c        **** 			{
 150:main.c        **** 				t.intMin=0;
 6739               	.LM294:
 6740 0d5e 1092 0000 		sts (t+2)+1,__zero_reg__
 6741 0d62 1092 0000 		sts t+2,__zero_reg__
 151:main.c        **** 				if (++t.intHour==24)
 6743               	.LM295:
 6744 0d66 8091 0000 		lds r24,t+4
 6745 0d6a 9091 0000 		lds r25,(t+4)+1
 6746 0d6e 0196      		adiw r24,1
 6747 0d70 9093 0000 		sts (t+4)+1,r25
 6748 0d74 8093 0000 		sts t+4,r24
 6749 0d78 8831      		cpi r24,24
 6750 0d7a 9105      		cpc r25,__zero_reg__
 6751 0d7c 09F0      		breq .+2
 6752 0d7e A9C0      		rjmp .L137
 152:main.c        **** 				{
 153:main.c        **** 					t.intHour=0;
 6754               	.LM296:
 6755 0d80 1092 0000 		sts (t+4)+1,__zero_reg__
 6756 0d84 1092 0000 		sts t+4,__zero_reg__
 154:main.c        **** 					if (++t.intDay==32)
 6758               	.LM297:
 6759 0d88 8091 0000 		lds r24,t+6
 6760 0d8c 9091 0000 		lds r25,(t+6)+1
 6761 0d90 0196      		adiw r24,1
 6762 0d92 9093 0000 		sts (t+6)+1,r25
 6763 0d96 8093 0000 		sts t+6,r24
 6764 0d9a 8032      		cpi r24,32
 6765 0d9c 9105      		cpc r25,__zero_reg__
 6766 0d9e 81F4      		brne .L142
 155:main.c        **** 					{
 156:main.c        **** 						t.intMonth++;
 6768               	.LM298:
 6769 0da0 8091 0000 		lds r24,t+8
 6770 0da4 9091 0000 		lds r25,(t+8)+1
 6771 0da8 0196      		adiw r24,1
 6772 0daa 9093 0000 		sts (t+8)+1,r25
 6773 0dae 8093 0000 		sts t+8,r24
 157:main.c        **** 						t.intDay=1;
 6775               	.LM299:
 6776 0db2 81E0      		ldi r24,lo8(1)
 6777 0db4 90E0      		ldi r25,hi8(1)
 6778 0db6 9093 0000 		sts (t+6)+1,r25
 6779 0dba 8093 0000 		sts t+6,r24
 6780 0dbe 73C0      		rjmp .L143
 6781               	.L142:
 158:main.c        **** 					}
 159:main.c        **** 					else if (t.intDay==31)
 6783               	.LM300:
 6784 0dc0 8091 0000 		lds r24,t+6
 6785 0dc4 9091 0000 		lds r25,(t+6)+1
 6786 0dc8 8F31      		cpi r24,31
 6787 0dca 9105      		cpc r25,__zero_reg__
 6788 0dcc 69F5      		brne .L144
 160:main.c        **** 					{
 161:main.c        **** 						if ((t.intMonth==4) || (t.intMonth==6) || (t.intMonth==9) || (t.intMonth==11))
 6790               	.LM301:
 6791 0dce 8091 0000 		lds r24,t+8
 6792 0dd2 9091 0000 		lds r25,(t+8)+1
 6793 0dd6 8430      		cpi r24,4
 6794 0dd8 9105      		cpc r25,__zero_reg__
 6795 0dda B1F0      		breq .L146
 6796 0ddc 8091 0000 		lds r24,t+8
 6797 0de0 9091 0000 		lds r25,(t+8)+1
 6798 0de4 8630      		cpi r24,6
 6799 0de6 9105      		cpc r25,__zero_reg__
 6800 0de8 79F0      		breq .L146
 6801 0dea 8091 0000 		lds r24,t+8
 6802 0dee 9091 0000 		lds r25,(t+8)+1
 6803 0df2 8930      		cpi r24,9
 6804 0df4 9105      		cpc r25,__zero_reg__
 6805 0df6 41F0      		breq .L146
 6806 0df8 8091 0000 		lds r24,t+8
 6807 0dfc 9091 0000 		lds r25,(t+8)+1
 6808 0e00 8B30      		cpi r24,11
 6809 0e02 9105      		cpc r25,__zero_reg__
 6810 0e04 09F0      		breq .L146
 6811 0e06 4FC0      		rjmp .L143
 6812               	.L146:
 162:main.c        **** 						{
 163:main.c        **** 							t.intMonth++;
 6814               	.LM302:
 6815 0e08 8091 0000 		lds r24,t+8
 6816 0e0c 9091 0000 		lds r25,(t+8)+1
 6817 0e10 0196      		adiw r24,1
 6818 0e12 9093 0000 		sts (t+8)+1,r25
 6819 0e16 8093 0000 		sts t+8,r24
 164:main.c        **** 							t.intDay=1;
 6821               	.LM303:
 6822 0e1a 81E0      		ldi r24,lo8(1)
 6823 0e1c 90E0      		ldi r25,hi8(1)
 6824 0e1e 9093 0000 		sts (t+6)+1,r25
 6825 0e22 8093 0000 		sts t+6,r24
 6826 0e26 3FC0      		rjmp .L143
 6827               	.L144:
 165:main.c        **** 						}
 166:main.c        **** 					}
 167:main.c        **** 					else if (t.intDay==30)
 6829               	.LM304:
 6830 0e28 8091 0000 		lds r24,t+6
 6831 0e2c 9091 0000 		lds r25,(t+6)+1
 6832 0e30 8E31      		cpi r24,30
 6833 0e32 9105      		cpc r25,__zero_reg__
 6834 0e34 B9F4      		brne .L148
 168:main.c        **** 					{
 169:main.c        **** 						if(t.intMonth==2)
 6836               	.LM305:
 6837 0e36 8091 0000 		lds r24,t+8
 6838 0e3a 9091 0000 		lds r25,(t+8)+1
 6839 0e3e 8230      		cpi r24,2
 6840 0e40 9105      		cpc r25,__zero_reg__
 6841 0e42 89F5      		brne .L143
 170:main.c        **** 						{
 171:main.c        **** 							t.intMonth++;
 6843               	.LM306:
 6844 0e44 8091 0000 		lds r24,t+8
 6845 0e48 9091 0000 		lds r25,(t+8)+1
 6846 0e4c 0196      		adiw r24,1
 6847 0e4e 9093 0000 		sts (t+8)+1,r25
 6848 0e52 8093 0000 		sts t+8,r24
 172:main.c        **** 							t.intDay=1;
 6850               	.LM307:
 6851 0e56 81E0      		ldi r24,lo8(1)
 6852 0e58 90E0      		ldi r25,hi8(1)
 6853 0e5a 9093 0000 		sts (t+6)+1,r25
 6854 0e5e 8093 0000 		sts t+6,r24
 6855 0e62 21C0      		rjmp .L143
 6856               	.L148:
 173:main.c        **** 						}
 174:main.c        **** 					}
 175:main.c        **** 					else if (t.intDay==29)
 6858               	.LM308:
 6859 0e64 8091 0000 		lds r24,t+6
 6860 0e68 9091 0000 		lds r25,(t+6)+1
 6861 0e6c 8D31      		cpi r24,29
 6862 0e6e 9105      		cpc r25,__zero_reg__
 6863 0e70 D1F4      		brne .L143
 176:main.c        **** 					{
 177:main.c        **** 						if((t.intMonth==2) && (not_leap()))
 6865               	.LM309:
 6866 0e72 8091 0000 		lds r24,t+8
 6867 0e76 9091 0000 		lds r25,(t+8)+1
 6868 0e7a 8230      		cpi r24,2
 6869 0e7c 9105      		cpc r25,__zero_reg__
 6870 0e7e 99F4      		brne .L143
 6871 0e80 0E94 0000 		call not_leap
 6872 0e84 8823      		tst r24
 6873 0e86 79F0      		breq .L143
 178:main.c        **** 						{
 179:main.c        **** 							t.intMonth++;
 6875               	.LM310:
 6876 0e88 8091 0000 		lds r24,t+8
 6877 0e8c 9091 0000 		lds r25,(t+8)+1
 6878 0e90 0196      		adiw r24,1
 6879 0e92 9093 0000 		sts (t+8)+1,r25
 6880 0e96 8093 0000 		sts t+8,r24
 180:main.c        **** 							t.intDay=1;
 6882               	.LM311:
 6883 0e9a 81E0      		ldi r24,lo8(1)
 6884 0e9c 90E0      		ldi r25,hi8(1)
 6885 0e9e 9093 0000 		sts (t+6)+1,r25
 6886 0ea2 8093 0000 		sts t+6,r24
 6887               	.L143:
 181:main.c        **** 						}
 182:main.c        **** 					}
 183:main.c        **** 					if (t.intMonth==13)
 6889               	.LM312:
 6890 0ea6 8091 0000 		lds r24,t+8
 6891 0eaa 9091 0000 		lds r25,(t+8)+1
 6892 0eae 8D30      		cpi r24,13
 6893 0eb0 9105      		cpc r25,__zero_reg__
 6894 0eb2 79F4      		brne .L137
 184:main.c        **** 					{
 185:main.c        **** 						t.intMonth=1;
 6896               	.LM313:
 6897 0eb4 81E0      		ldi r24,lo8(1)
 6898 0eb6 90E0      		ldi r25,hi8(1)
 6899 0eb8 9093 0000 		sts (t+8)+1,r25
 6900 0ebc 8093 0000 		sts t+8,r24
 186:main.c        **** 						t.intYear++;
 6902               	.LM314:
 6903 0ec0 8091 0000 		lds r24,t+10
 6904 0ec4 9091 0000 		lds r25,(t+10)+1
 6905 0ec8 0196      		adiw r24,1
 6906 0eca 9093 0000 		sts (t+10)+1,r25
 6907 0ece 8093 0000 		sts t+10,r24
 6908               	.L137:
 6909               	/* epilogue: frame size=0 */
 6910 0ed2 DF91      		pop r29
 6911 0ed4 CF91      		pop r28
 6912 0ed6 FF91      		pop r31
 6913 0ed8 EF91      		pop r30
 6914 0eda BF91      		pop r27
 6915 0edc AF91      		pop r26
 6916 0ede 9F91      		pop r25
 6917 0ee0 8F91      		pop r24
 6918 0ee2 7F91      		pop r23
 6919 0ee4 6F91      		pop r22
 6920 0ee6 5F91      		pop r21
 6921 0ee8 4F91      		pop r20
 6922 0eea 3F91      		pop r19
 6923 0eec 2F91      		pop r18
 6924 0eee 0F90      		pop __tmp_reg__
 6925 0ef0 0FBE      		out __SREG__,__tmp_reg__
 6926 0ef2 0F90      		pop __tmp_reg__
 6927 0ef4 1F90      		pop __zero_reg__
 6928 0ef6 1895      		reti
 6929               	/* epilogue end (size=19) */
 6930               	/* function __vector_5 size 261 (221) */
 6933               	.global	__vector_13
 6935               	__vector_13:
 187:main.c        **** 					}
 188:main.c        **** 				}
 189:main.c        **** 			}
 190:main.c        **** 		}
 191:main.c        **** 	}	
 192:main.c        **** }
 193:main.c        **** 
 194:main.c        **** 
 195:main.c        **** SIGNAL(SIG_UART_RECV)      
 196:main.c        **** /* signal handler for receive complete interrupt */
 197:main.c        **** {
 6937               	.LM315:
 6938               	/* prologue: frame size=0 */
 6939 0ef8 1F92      		push __zero_reg__
 6940 0efa 0F92      		push __tmp_reg__
 6941 0efc 0FB6      		in __tmp_reg__,__SREG__
 6942 0efe 0F92      		push __tmp_reg__
 6943 0f00 1124      		clr __zero_reg__
 6944 0f02 CF93      		push r28
 6945 0f04 DF93      		push r29
 6946 0f06 CDB7      		in r28,__SP_L__
 6947 0f08 DEB7      		in r29,__SP_H__
 6948               	/* prologue end (size=9) */
 6949               	/* epilogue: frame size=0 */
 6950 0f0a DF91      		pop r29
 6951 0f0c CF91      		pop r28
 6952 0f0e 0F90      		pop __tmp_reg__
 6953 0f10 0FBE      		out __SREG__,__tmp_reg__
 6954 0f12 0F90      		pop __tmp_reg__
 6955 0f14 1F90      		pop __zero_reg__
 6956 0f16 1895      		reti
 6957               	/* epilogue end (size=7) */
 6958               	/* function __vector_13 size 16 (0) */
 6961               	.global	__vector_1
 6963               	__vector_1:
 198:main.c        ****     //register unsigned char inByte;
 199:main.c        **** 
 200:main.c        ****     //inByte = inp(UDR);        /* read byte for UART data buffer */
 201:main.c        **** }
 202:main.c        **** 
 203:main.c        **** //----------------------------------------------------------------------------
 204:main.c        **** //Routine:		SIGNAL(SIG_INTERRUPT0)	(signal handler for external interrupt int0)
 205:main.c        **** //
 206:main.c        **** //Function:		
 207:main.c        **** //             
 208:main.c        **** //
 209:main.c        **** //Varibles passed:
 210:main.c        **** //       none
 211:main.c        **** //Returns:
 212:main.c        **** //       integer (no idea where this integer is returned to)
 213:main.c        **** SIGNAL(SIG_INTERRUPT0)     
 214:main.c        **** {
 6965               	.LM316:
 6966               	/* prologue: frame size=0 */
 6967 0f18 1F92      		push __zero_reg__
 6968 0f1a 0F92      		push __tmp_reg__
 6969 0f1c 0FB6      		in __tmp_reg__,__SREG__
 6970 0f1e 0F92      		push __tmp_reg__
 6971 0f20 1124      		clr __zero_reg__
 6972 0f22 CF93      		push r28
 6973 0f24 DF93      		push r29
 6974 0f26 CDB7      		in r28,__SP_L__
 6975 0f28 DEB7      		in r29,__SP_H__
 6976               	/* prologue end (size=9) */
 6977               	/* epilogue: frame size=0 */
 6978 0f2a DF91      		pop r29
 6979 0f2c CF91      		pop r28
 6980 0f2e 0F90      		pop __tmp_reg__
 6981 0f30 0FBE      		out __SREG__,__tmp_reg__
 6982 0f32 0F90      		pop __tmp_reg__
 6983 0f34 1F90      		pop __zero_reg__
 6984 0f36 1895      		reti
 6985               	/* epilogue end (size=7) */
 6986               	/* function __vector_1 size 16 (0) */
 6989               	.global	main
 6991               	main:
 215:main.c        **** }
 216:main.c        **** 
 217:main.c        **** 
 218:main.c        **** //----------------------------------------------------------------------------
 219:main.c        **** //Routine:     main (the main loop of the program)
 220:main.c        **** //
 221:main.c        **** //Function:    This is where to program will exicute until an interrupt happens or
 222:main.c        **** //              someone yanks the power plug.
 223:main.c        **** //
 224:main.c        **** //Varibles passed:
 225:main.c        **** //       none
 226:main.c        **** //Returns:
 227:main.c        **** //       integer (no idea where this integer is returned to)
 228:main.c        **** //----------------------------------------------------------------------------
 229:main.c        **** // Main loop
 230:main.c        **** int main( void )
 231:main.c        **** {
 6993               	.LM317:
 6994               	/* prologue: frame size=0 */
 6995 0f38 C0E0      		ldi r28,lo8(__stack - 0)
 6996 0f3a D0E0      		ldi r29,hi8(__stack - 0)
 6997 0f3c DEBF      		out __SP_H__,r29
 6998 0f3e CDBF      		out __SP_L__,r28
 6999               	/* prologue end (size=4) */
 232:main.c        **** 	wdt_reset();	//reset the watchdog
 7001               	.LM318:
 7002               	/* #APP */
 7003 0f40 A895      		wdr
 233:main.c        **** 	uCinit();		//go through the initialization process for the microcontroller
 7005               	.LM319:
 7006               	/* #NOAPP */
 7007 0f42 0E94 0000 		call uCinit
 234:main.c        **** 	InitLCD();		//initialize the graphical LCD, lcd.h file
 7009               	.LM320:
 7010 0f46 0E94 0000 		call InitLCD
 235:main.c        **** 	sei();        // enable interrupts
 7012               	.LM321:
 7013               	/* #APP */
 7014 0f4a 7894      		sei
 236:main.c        **** 	sbi(PORTD,defBacklightOn);	//turn on the backlight
 7016               	.LM322:
 7017               	/* #NOAPP */
 7018 0f4c 8091 3200 		lds r24,50
 7019 0f50 8068      		ori r24,lo8(-128)
 7020 0f52 8093 3200 		sts 50,r24
 237:main.c        **** 	t.intDay=1;		//It is the first day of the month on powerup
 7022               	.LM323:
 7023 0f56 81E0      		ldi r24,lo8(1)
 7024 0f58 90E0      		ldi r25,hi8(1)
 7025 0f5a 9093 0000 		sts (t+6)+1,r25
 7026 0f5e 8093 0000 		sts t+6,r24
 238:main.c        **** 	t.intMonth=1;	//It is January on powerup
 7028               	.LM324:
 7029 0f62 81E0      		ldi r24,lo8(1)
 7030 0f64 90E0      		ldi r25,hi8(1)
 7031 0f66 9093 0000 		sts (t+8)+1,r25
 7032 0f6a 8093 0000 		sts t+8,r24
 239:main.c        **** 	t.intYear=5;		//start out at 2005 (the t.year variable only keeps track of the last 3 digits)
 7034               	.LM325:
 7035 0f6e 85E0      		ldi r24,lo8(5)
 7036 0f70 90E0      		ldi r25,hi8(5)
 7037 0f72 9093 0000 		sts (t+10)+1,r25
 7038 0f76 8093 0000 		sts t+10,r24
 7039               	.L157:
 240:main.c        **** 	while(1)       // go into an infinite loop here
 241:main.c        **** 	{
 242:main.c        ****         SrvTock();        //go to the tock every 20ms
 7041               	.LM326:
 7042 0f7a 0E94 0000 		call SrvTock
 7043 0f7e FDCF      		rjmp .L157
 7044               	/* epilogue: frame size=0 */
 7045               	/* epilogue: noreturn */
 7046               	/* epilogue end (size=0) */
 7047               	/* function main size 38 (34) */
 7050               	.global	not_leap
 7052               	not_leap:
 243:main.c        **** 	}
 244:main.c        **** 	return 0; 
 245:main.c        **** }
 246:main.c        **** 
 247:main.c        **** //----------------------------------------------------------------------------
 248:main.c        **** //Routine:       not_leap
 249:main.c        **** //
 250:main.c        **** //Function:      This routine is used for determining if it is not a leap year.
 251:main.c        **** //
 252:main.c        **** //Varibles passed:
 253:main.c        **** //       none
 254:main.c        **** //Returns:
 255:main.c        **** //       returns a true if it is not a leap year
 256:main.c        **** //		 returns a false if it is a leap year
 257:main.c        **** //----------------------------------------------------------------------------
 258:main.c        **** unsigned char not_leap(void) //check for leap year
 259:main.c        **** {
 7054               	.LM327:
 7055               	/* prologue: frame size=2 */
 7056 0f80 CF93      		push r28
 7057 0f82 DF93      		push r29
 7058 0f84 CDB7      		in r28,__SP_L__
 7059 0f86 DEB7      		in r29,__SP_H__
 7060 0f88 2297      		sbiw r28,2
 7061 0f8a 0FB6      		in __tmp_reg__,__SREG__
 7062 0f8c F894      		cli
 7063 0f8e DEBF      		out __SP_H__,r29
 7064 0f90 0FBE      		out __SREG__,__tmp_reg__
 7065 0f92 CDBF      		out __SP_L__,r28
 7066               	/* prologue end (size=10) */
 260:main.c        **** 	if (!(t.intYear%100))
 7068               	.LM328:
 7069 0f94 8091 0000 		lds r24,t+10
 7070 0f98 9091 0000 		lds r25,(t+10)+1
 7071 0f9c 24E6      		ldi r18,lo8(100)
 7072 0f9e 30E0      		ldi r19,hi8(100)
 7073 0fa0 B901      		movw r22,r18
 7074 0fa2 0E94 0000 		call __udivmodhi4
 7075 0fa6 0097      		sbiw r24,0
 7076 0fa8 69F4      		brne .L160
 261:main.c        **** 		return (char)(t.intYear%400);
 7078               	.LM329:
 7079 0faa 8091 0000 		lds r24,t+10
 7080 0fae 9091 0000 		lds r25,(t+10)+1
 7081 0fb2 20E9      		ldi r18,lo8(400)
 7082 0fb4 31E0      		ldi r19,hi8(400)
 7083 0fb6 B901      		movw r22,r18
 7084 0fb8 0E94 0000 		call __udivmodhi4
 7085 0fbc 9927      		clr r25
 7086 0fbe 8983      		std Y+1,r24
 7087 0fc0 9A83      		std Y+2,r25
 7088 0fc2 09C0      		rjmp .L159
 7089               	.L160:
 262:main.c        **** 	else
 263:main.c        **** 		return (char)(t.intYear%4);
 7091               	.LM330:
 7092 0fc4 8091 0000 		lds r24,t+10
 7093 0fc8 9091 0000 		lds r25,(t+10)+1
 7094 0fcc 8370      		andi r24,lo8(3)
 7095 0fce 9070      		andi r25,hi8(3)
 7096 0fd0 9927      		clr r25
 7097 0fd2 8983      		std Y+1,r24
 7098 0fd4 9A83      		std Y+2,r25
 7099               	.L159:
 264:main.c        **** }
 7101               	.LM331:
 7102 0fd6 8981      		ldd r24,Y+1
 7103 0fd8 9A81      		ldd r25,Y+2
 7104               	/* epilogue: frame size=2 */
 7105 0fda 2296      		adiw r28,2
 7106 0fdc 0FB6      		in __tmp_reg__,__SREG__
 7107 0fde F894      		cli
 7108 0fe0 DEBF      		out __SP_H__,r29
 7109 0fe2 0FBE      		out __SREG__,__tmp_reg__
 7110 0fe4 CDBF      		out __SP_L__,r28
 7111 0fe6 DF91      		pop r29
 7112 0fe8 CF91      		pop r28
 7113 0fea 0895      		ret
 7114               	/* epilogue end (size=9) */
 7115               	/* function not_leap size 54 (35) */
 7117               		.data
 7118               	.LC0:
 7119 0007 3030 3030 		.string	"0000"
 7119      00
 7120               		.text
 7123               	.global	integerToArray
 7125               	integerToArray:
 265:main.c        **** 
 266:main.c        **** //----------------------------------------------------------------------------
 267:main.c        **** //Routine:       my_itoa  (my interger to array conversion)
 268:main.c        **** //
 269:main.c        **** //Function:      Takes an integer and moves it into an array.
 270:main.c        **** //                Otherwise known as binary to BCD conversion in assembly.
 271:main.c        **** //                This routine was copied off of a newsgroup.
 272:main.c        **** //                The binary value is passed to the routine and the destination
 273:main.c        **** //                is a string called str
 274:main.c        **** //
 275:main.c        **** //Varibles passed:
 276:main.c        **** //       arg:  a character to be converted to BCD
 277:main.c        **** //Returns:
 278:main.c        **** //       none
 279:main.c        **** //----------------------------------------------------------------------------
 280:main.c        **** void integerToArray(unsigned int intNumToString)
 281:main.c        **** {
 7127               	.LM332:
 7128               	/* prologue: frame size=8 */
 7129 0fec CF93      		push r28
 7130 0fee DF93      		push r29
 7131 0ff0 CDB7      		in r28,__SP_L__
 7132 0ff2 DEB7      		in r29,__SP_H__
 7133 0ff4 2897      		sbiw r28,8
 7134 0ff6 0FB6      		in __tmp_reg__,__SREG__
 7135 0ff8 F894      		cli
 7136 0ffa DEBF      		out __SP_H__,r29
 7137 0ffc 0FBE      		out __SREG__,__tmp_reg__
 7138 0ffe CDBF      		out __SP_L__,r28
 7139               	/* prologue end (size=10) */
 7140 1000 8983      		std Y+1,r24
 7141 1002 9A83      		std Y+2,r25
 282:main.c        ****     int minus = 0;
 7143               	.LM333:
 7144 1004 1B82      		std Y+3,__zero_reg__
 7145 1006 1C82      		std Y+4,__zero_reg__
 283:main.c        ****     int d;
 284:main.c        ****     char *ptr;
 285:main.c        **** 
 286:main.c        ****     strcpy (str,"0000");
 7147               	.LM334:
 7148 1008 60E0      		ldi r22,lo8(.LC0)
 7149 100a 70E0      		ldi r23,hi8(.LC0)
 7150 100c 80E0      		ldi r24,lo8(str)
 7151 100e 90E0      		ldi r25,hi8(str)
 7152 1010 0E94 0000 		call strcpy
 287:main.c        ****     ptr = &str[sizeof(str) -1];
 7154               	.LM335:
 7155 1014 80E0      		ldi r24,lo8(str+4)
 7156 1016 90E0      		ldi r25,hi8(str+4)
 7157 1018 8F83      		std Y+7,r24
 7158 101a 9887      		std Y+8,r25
 288:main.c        ****     *ptr-- = '\0';
 7160               	.LM336:
 7161 101c DE01      		movw r26,r28
 7162 101e 1796      		adiw r26,7
 7163 1020 8D91      		ld r24,X+
 7164 1022 9C91      		ld r25,X
 7165 1024 1197      		sbiw r26,1
 7166 1026 FC01      		movw r30,r24
 7167 1028 1082      		st Z,__zero_reg__
 7168 102a 0197      		sbiw r24,1
 7169 102c 8D93      		st X+,r24
 7170 102e 9C93      		st X,r25
 7171 1030 1197      		sbiw r26,1
 7172               	.L164:
 289:main.c        ****     if (intNumToString < 0)
 290:main.c        ****     {
 291:main.c        ****           minus = 1; intNumToString = -intNumToString;
 292:main.c        ****     }
 293:main.c        ****     while (intNumToString > 0)
 7174               	.LM337:
 7175 1032 8981      		ldd r24,Y+1
 7176 1034 9A81      		ldd r25,Y+2
 7177 1036 0097      		sbiw r24,0
 7178 1038 09F1      		breq .L165
 294:main.c        ****     {
 295:main.c        ****          d = intNumToString % 10;
 7180               	.LM338:
 7181 103a 8981      		ldd r24,Y+1
 7182 103c 9A81      		ldd r25,Y+2
 7183 103e 2AE0      		ldi r18,lo8(10)
 7184 1040 30E0      		ldi r19,hi8(10)
 7185 1042 B901      		movw r22,r18
 7186 1044 0E94 0000 		call __udivmodhi4
 7187 1048 8D83      		std Y+5,r24
 7188 104a 9E83      		std Y+6,r25
 296:main.c        ****          *ptr-- = d + '0';
 7190               	.LM339:
 7191 104c DE01      		movw r26,r28
 7192 104e 1796      		adiw r26,7
 7193 1050 8D91      		ld r24,X+
 7194 1052 9C91      		ld r25,X
 7195 1054 1197      		sbiw r26,1
 7196 1056 2D81      		ldd r18,Y+5
 7197 1058 205D      		subi r18,lo8(-(48))
 7198 105a FC01      		movw r30,r24
 7199 105c 2083      		st Z,r18
 7200 105e 0197      		sbiw r24,1
 7201 1060 8D93      		st X+,r24
 7202 1062 9C93      		st X,r25
 7203 1064 1197      		sbiw r26,1
 297:main.c        ****          intNumToString /= 10;
 7205               	.LM340:
 7206 1066 8981      		ldd r24,Y+1
 7207 1068 9A81      		ldd r25,Y+2
 7208 106a 2AE0      		ldi r18,lo8(10)
 7209 106c 30E0      		ldi r19,hi8(10)
 7210 106e B901      		movw r22,r18
 7211 1070 0E94 0000 		call __udivmodhi4
 7212 1074 CB01      		movw r24,r22
 7213 1076 8983      		std Y+1,r24
 7214 1078 9A83      		std Y+2,r25
 7215 107a DBCF      		rjmp .L164
 7216               	.L165:
 298:main.c        ****      }
 299:main.c        ****     if (minus)
 7218               	.LM341:
 7219 107c 8B81      		ldd r24,Y+3
 7220 107e 9C81      		ldd r25,Y+4
 7221 1080 0097      		sbiw r24,0
 7222 1082 29F0      		breq .L166
 300:main.c        ****         *ptr = '-';
 7224               	.LM342:
 7225 1084 EF81      		ldd r30,Y+7
 7226 1086 F885      		ldd r31,Y+8
 7227 1088 8DE2      		ldi r24,lo8(45)
 7228 108a 8083      		st Z,r24
 7229 108c 05C0      		rjmp .L162
 7230               	.L166:
 301:main.c        ****     else
 302:main.c        ****         ptr++;
 7232               	.LM343:
 7233 108e 8F81      		ldd r24,Y+7
 7234 1090 9885      		ldd r25,Y+8
 7235 1092 0196      		adiw r24,1
 7236 1094 8F83      		std Y+7,r24
 7237 1096 9887      		std Y+8,r25
 7238               	.L162:
 7239               	/* epilogue: frame size=8 */
 7240 1098 2896      		adiw r28,8
 7241 109a 0FB6      		in __tmp_reg__,__SREG__
 7242 109c F894      		cli
 7243 109e DEBF      		out __SP_H__,r29
 7244 10a0 0FBE      		out __SREG__,__tmp_reg__
 7245 10a2 CDBF      		out __SP_L__,r28
 7246 10a4 DF91      		pop r29
 7247 10a6 CF91      		pop r28
 7248 10a8 0895      		ret
 7249               	/* epilogue end (size=9) */
 7250               	/* function integerToArray size 95 (76) */
 7256               	.global	SrvTock
 7258               	SrvTock:
 303:main.c        **** }
 304:main.c        **** 
 305:main.c        **** 
 306:main.c        **** //----------------------------------------------------------------------------
 307:main.c        **** //Routine:       SrvTock  (Service the tock)
 308:main.c        **** //
 309:main.c        **** //Function:      Exicute the tock every 20mS from the main loop.
 310:main.c        **** //
 311:main.c        **** //
 312:main.c        **** //Varibles passed:
 313:main.c        **** //       none
 314:main.c        **** //Returns:
 315:main.c        **** //       none
 316:main.c        **** //----------------------------------------------------------------------------
 317:main.c        **** void SrvTock(void)
 318:main.c        **** {
 7260               	.LM344:
 7261               	/* prologue: frame size=20 */
 7262 10aa 0F93      		push r16
 7263 10ac CF93      		push r28
 7264 10ae DF93      		push r29
 7265 10b0 CDB7      		in r28,__SP_L__
 7266 10b2 DEB7      		in r29,__SP_H__
 7267 10b4 6497      		sbiw r28,20
 7268 10b6 0FB6      		in __tmp_reg__,__SREG__
 7269 10b8 F894      		cli
 7270 10ba DEBF      		out __SP_H__,r29
 7271 10bc 0FBE      		out __SREG__,__tmp_reg__
 7272 10be CDBF      		out __SP_L__,r28
 7273               	/* prologue end (size=11) */
 319:main.c        ****     //unsigned char uCanteen;
 320:main.c        **** 	//bool boolNewData=false;
 321:main.c        **** 
 322:main.c        ****     if (uTock == 0)
 7275               	.LM345:
 7276 10c0 8091 0000 		lds r24,uTock
 7277 10c4 9091 0000 		lds r25,(uTock)+1
 7278 10c8 0097      		sbiw r24,0
 7279 10ca 11F0      		breq .+4
 7280 10cc 0C94 0000 		jmp .L168
 323:main.c        ****     {
 324:main.c        ****         uTock = defTock;   //reload the Tock (20mS) timer
 7282               	.LM346:
 7283 10d0 87E3      		ldi r24,lo8(311)
 7284 10d2 91E0      		ldi r25,hi8(311)
 7285 10d4 9093 0000 		sts (uTock)+1,r25
 7286 10d8 8093 0000 		sts uTock,r24
 325:main.c        ****         if(uBtnUpTmr!=0)     //the debounce timer for Menu Button 1
 7288               	.LM347:
 7289 10dc 8091 0000 		lds r24,uBtnUpTmr
 7290 10e0 8823      		tst r24
 7291 10e2 29F0      		breq .L170
 326:main.c        ****         {
 327:main.c        ****             uBtnUpTmr--;     //decrement the menu button 1 debounce timer
 7293               	.LM348:
 7294 10e4 8091 0000 		lds r24,uBtnUpTmr
 7295 10e8 8150      		subi r24,lo8(-(-1))
 7296 10ea 8093 0000 		sts uBtnUpTmr,r24
 7297               	.L170:
 328:main.c        ****         }
 329:main.c        ****         if(uBtnDwnTmr!=0)     //the debounce timer for Menu Button 2
 7299               	.LM349:
 7300 10ee 8091 0000 		lds r24,uBtnDwnTmr
 7301 10f2 8823      		tst r24
 7302 10f4 29F0      		breq .L171
 330:main.c        ****         {
 331:main.c        ****             uBtnDwnTmr--;     //decrement the menu button 2 debounce timer
 7304               	.LM350:
 7305 10f6 8091 0000 		lds r24,uBtnDwnTmr
 7306 10fa 8150      		subi r24,lo8(-(-1))
 7307 10fc 8093 0000 		sts uBtnDwnTmr,r24
 7308               	.L171:
 332:main.c        ****         }
 333:main.c        ****         if(uBtnEnterTmr!=0)     //the debounce timer for Menu Button 3
 7310               	.LM351:
 7311 1100 8091 0000 		lds r24,uBtnEnterTmr
 7312 1104 8823      		tst r24
 7313 1106 29F0      		breq .L172
 334:main.c        ****         {
 335:main.c        ****             uBtnEnterTmr--;     //decrement the menu button 3 debounce timer
 7315               	.LM352:
 7316 1108 8091 0000 		lds r24,uBtnEnterTmr
 7317 110c 8150      		subi r24,lo8(-(-1))
 7318 110e 8093 0000 		sts uBtnEnterTmr,r24
 7319               	.L172:
 336:main.c        ****         }
 337:main.c        **** 
 338:main.c        ****         switch (uState)
 7321               	.LM353:
 7322 1112 8091 0000 		lds r24,uState
 7323 1116 282F      		mov r18,r24
 7324 1118 3327      		clr r19
 7325 111a 2B8B      		std Y+19,r18
 7326 111c 3C8B      		std Y+20,r19
 7327 111e 8B89      		ldd r24,Y+19
 7328 1120 9C89      		ldd r25,Y+20
 7329 1122 8C33      		cpi r24,60
 7330 1124 9105      		cpc r25,__zero_reg__
 7331 1126 09F4      		brne .+2
 7332 1128 EDC2      		rjmp .L228
 7333 112a 2B89      		ldd r18,Y+19
 7334 112c 3C89      		ldd r19,Y+20
 7335 112e 2D33      		cpi r18,61
 7336 1130 3105      		cpc r19,__zero_reg__
 7337 1132 CCF4      		brge .L352
 7338 1134 8B89      		ldd r24,Y+19
 7339 1136 9C89      		ldd r25,Y+20
 7340 1138 8230      		cpi r24,2
 7341 113a 9105      		cpc r25,__zero_reg__
 7342 113c 09F4      		brne .+2
 7343 113e 4FC0      		rjmp .L178
 7344 1140 2B89      		ldd r18,Y+19
 7345 1142 3C89      		ldd r19,Y+20
 7346 1144 2330      		cpi r18,3
 7347 1146 3105      		cpc r19,__zero_reg__
 7348 1148 34F4      		brge .L353
 7349 114a 8B89      		ldd r24,Y+19
 7350 114c 9C89      		ldd r25,Y+20
 7351 114e 0097      		sbiw r24,0
 7352 1150 29F1      		breq .L174
 7353 1152 0C94 0000 		jmp .L168
 7354               	.L353:
 7355 1156 2B89      		ldd r18,Y+19
 7356 1158 3C89      		ldd r19,Y+20
 7357 115a 2233      		cpi r18,50
 7358 115c 3105      		cpc r19,__zero_reg__
 7359 115e 09F4      		brne .+2
 7360 1160 E6C1      		rjmp .L212
 7361 1162 0C94 0000 		jmp .L168
 7362               	.L352:
 7363 1166 8B89      		ldd r24,Y+19
 7364 1168 9C89      		ldd r25,Y+20
 7365 116a 8E33      		cpi r24,62
 7366 116c 9105      		cpc r25,__zero_reg__
 7367 116e 09F4      		brne .+2
 7368 1170 6DC6      		rjmp .L311
 7369 1172 2B89      		ldd r18,Y+19
 7370 1174 3C89      		ldd r19,Y+20
 7371 1176 2E33      		cpi r18,62
 7372 1178 3105      		cpc r19,__zero_reg__
 7373 117a 0CF4      		brge .+2
 7374 117c 2AC5      		rjmp .L283
 7375 117e 8B89      		ldd r24,Y+19
 7376 1180 9C89      		ldd r25,Y+20
 7377 1182 8F33      		cpi r24,63
 7378 1184 9105      		cpc r25,__zero_reg__
 7379 1186 09F4      		brne .+2
 7380 1188 5DC7      		rjmp .L337
 7381 118a 2B89      		ldd r18,Y+19
 7382 118c 3C89      		ldd r19,Y+20
 7383 118e 2034      		cpi r18,64
 7384 1190 3105      		cpc r19,__zero_reg__
 7385 1192 11F4      		brne .+4
 7386 1194 0C94 0000 		jmp .L347
 7387 1198 0C94 0000 		jmp .L168
 7388               	.L174:
 339:main.c        ****         {
 340:main.c        ****             case 0:  //Does the current state match state 0?
 341:main.c        ****                 if(uTmrState==200) 
 7390               	.LM354:
 7391 119c 8091 0000 		lds r24,uTmrState
 7392 11a0 883C      		cpi r24,lo8(-56)
 7393 11a2 11F4      		brne .L175
 342:main.c        ****                 {
 343:main.c        **** 					stop_image();		//write the stop image
 7395               	.LM355:
 7396 11a4 0E94 0000 		call stop_image
 7397               	.L175:
 344:main.c        **** 				}
 345:main.c        ****                 if(uTmrState==100) 
 7399               	.LM356:
 7400 11a8 8091 0000 		lds r24,uTmrState
 7401 11ac 8436      		cpi r24,lo8(100)
 7402 11ae 11F4      		brne .L176
 346:main.c        ****                 {
 347:main.c        **** 					kustom_image();		//write the K((( logo to the screen
 7404               	.LM357:
 7405 11b0 0E94 0000 		call kustom_image
 7406               	.L176:
 348:main.c        **** 				}
 349:main.c        ****                 uTmrState--;
 7408               	.LM358:
 7409 11b4 8091 0000 		lds r24,uTmrState
 7410 11b8 8150      		subi r24,lo8(-(-1))
 7411 11ba 8093 0000 		sts uTmrState,r24
 350:main.c        ****                 
 351:main.c        ****                 if(uTmrState==0)
 7413               	.LM359:
 7414 11be 8091 0000 		lds r24,uTmrState
 7415 11c2 8823      		tst r24
 7416 11c4 11F0      		breq .+4
 7417 11c6 0C94 0000 		jmp .L168
 352:main.c        ****                 {
 353:main.c        **** 					clear_display();	//clear the whole display
 7419               	.LM360:
 7420 11ca 0E94 0000 		call clear_display
 354:main.c        **** 					uTmrState=1;
 7422               	.LM361:
 7423 11ce 81E0      		ldi r24,lo8(1)
 7424 11d0 8093 0000 		sts uTmrState,r24
 355:main.c        **** 					uState=2;
 7426               	.LM362:
 7427 11d4 82E0      		ldi r24,lo8(2)
 7428 11d6 8093 0000 		sts uState,r24
 356:main.c        **** 					//write_eagle_display();		//This writes a  big 1 through 9 to the display
 357:main.c        ****                 }
 358:main.c        ****             break;
 7430               	.LM363:
 7431 11da 0C94 0000 		jmp .L168
 7432               	.L178:
 359:main.c        **** 			
 360:main.c        **** 			case 2:		//This shows the main clock display
 361:main.c        ****                 if(uTmrState==0)
 7434               	.LM364:
 7435 11de 8091 0000 		lds r24,uTmrState
 7436 11e2 8823      		tst r24
 7437 11e4 09F0      		breq .+2
 7438 11e6 EAC0      		rjmp .L179
 362:main.c        ****                 {
 363:main.c        **** 					//uTmrState = 255;	//Go in here every (.02)(255) = 5.1 seconds
 364:main.c        **** 					if(boolPowerupBlink==true)
 7440               	.LM365:
 7441 11e8 8091 0000 		lds r24,boolPowerupBlink
 7442 11ec 9927      		clr r25
 7443 11ee 8130      		cpi r24,1
 7444 11f0 9105      		cpc r25,__zero_reg__
 7445 11f2 49F4      		brne .L180
 365:main.c        **** 					{
 366:main.c        **** 						uTmrState = 75;		//update the display at much higher rate when the time has not been set
 7447               	.LM366:
 7448 11f4 8BE4      		ldi r24,lo8(75)
 7449 11f6 8093 0000 		sts uTmrState,r24
 367:main.c        **** 						sbi(defPORTD,defBacklightOn);	//always have the backlight on when we are  in the powerup flas
 7451               	.LM367:
 7452 11fa 8091 3200 		lds r24,50
 7453 11fe 8068      		ori r24,lo8(-128)
 7454 1200 8093 3200 		sts 50,r24
 7455 1204 37C0      		rjmp .L181
 7456               	.L180:
 368:main.c        **** 					}
 369:main.c        **** 					else
 370:main.c        **** 					{
 371:main.c        **** 						uTmrState = 255;	//Go in here every (.02)(255) = 5.1 seconds, update the display
 7458               	.LM368:
 7459 1206 8FEF      		ldi r24,lo8(-1)
 7460 1208 8093 0000 		sts uTmrState,r24
 372:main.c        **** 						if(uBacklightOffHour<=t.intHour || uBacklightOnHour>t.intHour)	//is it nighttime?
 7462               	.LM369:
 7463 120c 8091 0000 		lds r24,uBacklightOffHour
 7464 1210 282F      		mov r18,r24
 7465 1212 3327      		clr r19
 7466 1214 8091 0000 		lds r24,t+4
 7467 1218 9091 0000 		lds r25,(t+4)+1
 7468 121c 8217      		cp r24,r18
 7469 121e 9307      		cpc r25,r19
 7470 1220 60F4      		brsh .L183
 7471 1222 8091 0000 		lds r24,uBacklightOnHour
 7472 1226 282F      		mov r18,r24
 7473 1228 3327      		clr r19
 7474 122a 8091 0000 		lds r24,t+4
 7475 122e 9091 0000 		lds r25,(t+4)+1
 7476 1232 8217      		cp r24,r18
 7477 1234 9307      		cpc r25,r19
 7478 1236 08F0      		brlo .L183
 7479 1238 18C0      		rjmp .L182
 7480               	.L183:
 373:main.c        **** 						{	
 374:main.c        **** 							if(intPhotocellValue>intUserPhotoTriggerValue)	//is it dark out?
 7482               	.LM370:
 7483 123a 2091 0000 		lds r18,intPhotocellValue
 7484 123e 3091 0000 		lds r19,(intPhotocellValue)+1
 7485 1242 8091 0000 		lds r24,intUserPhotoTriggerValue
 7486 1246 9091 0000 		lds r25,(intUserPhotoTriggerValue)+1
 7487 124a 8217      		cp r24,r18
 7488 124c 9307      		cpc r25,r19
 7489 124e 38F4      		brsh .L184
 375:main.c        **** 							{
 376:main.c        **** 								cbi(defPORTD,defBacklightOn);	//turn off the backlight
 7491               	.LM371:
 7492 1250 8FE7      		ldi r24,lo8(127)
 7493 1252 9091 3200 		lds r25,50
 7494 1256 8923      		and r24,r25
 7495 1258 8093 3200 		sts 50,r24
 7496 125c 0BC0      		rjmp .L181
 7497               	.L184:
 377:main.c        **** 							}
 378:main.c        **** 							else	//it is not dark out
 379:main.c        **** 							{
 380:main.c        **** 								sbi(defPORTD,defBacklightOn);	//so, turn on the backlight
 7499               	.LM372:
 7500 125e 8091 3200 		lds r24,50
 7501 1262 8068      		ori r24,lo8(-128)
 7502 1264 8093 3200 		sts 50,r24
 7503 1268 05C0      		rjmp .L181
 7504               	.L182:
 381:main.c        **** 							}
 382:main.c        **** 						}
 383:main.c        **** 						else	//it is not nighttime, so turn on the backlight during the day
 384:main.c        **** 						{
 385:main.c        **** 							sbi(defPORTD,defBacklightOn);	//turn on the backlight
 7506               	.LM373:
 7507 126a 8091 3200 		lds r24,50
 7508 126e 8068      		ori r24,lo8(-128)
 7509 1270 8093 3200 		sts 50,r24
 7510               	.L181:
 386:main.c        **** 						}
 387:main.c        **** 					}
 388:main.c        **** 
 389:main.c        **** 					if(t.intHour<8)	//This moves the time and date every 8 hours to prevent screen burn in
 7512               	.LM374:
 7513 1274 8091 0000 		lds r24,t+4
 7514 1278 9091 0000 		lds r25,(t+4)+1
 7515 127c 8830      		cpi r24,8
 7516 127e 9105      		cpc r25,__zero_reg__
 7517 1280 30F5      		brsh .L187
 390:main.c        **** 					{
 391:main.c        **** 						if(uRefreshDisplay!=0)	//when we enter this 8 hour time period, the display needs to be clear
 7519               	.LM375:
 7520 1282 8091 0000 		lds r24,uRefreshDisplay
 7521 1286 8823      		tst r24
 7522 1288 21F0      		breq .L188
 392:main.c        **** 						{
 393:main.c        **** 							uRefreshDisplay=0;	//do not go in here again for this 8 hour period
 7524               	.LM376:
 7525 128a 1092 0000 		sts uRefreshDisplay,__zero_reg__
 394:main.c        **** 							clear_display();	//clear the whole display
 7527               	.LM377:
 7528 128e 0E94 0000 		call clear_display
 7529               	.L188:
 395:main.c        **** 						}
 396:main.c        **** 						ShowLargeTime(20,3);		//uStartColumn, uRow
 7531               	.LM378:
 7532 1292 63E0      		ldi r22,lo8(3)
 7533 1294 84E1      		ldi r24,lo8(20)
 7534 1296 0E94 0000 		call ShowLargeTime
 397:main.c        **** 						if(boolAlarmOn==false)	//Is the alarm off?
 7536               	.LM379:
 7537 129a 8091 0000 		lds r24,boolAlarmOn
 7538 129e 8823      		tst r24
 7539 12a0 41F4      		brne .L189
 398:main.c        **** 						{
 399:main.c        **** 							drawText((unsigned char *)strAlarmOff,40,6,false);	//show alarm on/off state (column, row)
 7541               	.LM380:
 7542 12a2 20E0      		ldi r18,lo8(0)
 7543 12a4 46E0      		ldi r20,lo8(6)
 7544 12a6 68E2      		ldi r22,lo8(40)
 7545 12a8 80E0      		ldi r24,lo8(strAlarmOff)
 7546 12aa 90E0      		ldi r25,hi8(strAlarmOff)
 7547 12ac 0E94 0000 		call drawText
 7548 12b0 07C0      		rjmp .L190
 7549               	.L189:
 400:main.c        **** 						}
 401:main.c        **** 						else
 402:main.c        **** 						{
 403:main.c        **** 							drawText((unsigned char *)strAlarmOn,40,6,false);	//show that the alarm is on (column, row)
 7551               	.LM381:
 7552 12b2 20E0      		ldi r18,lo8(0)
 7553 12b4 46E0      		ldi r20,lo8(6)
 7554 12b6 68E2      		ldi r22,lo8(40)
 7555 12b8 80E0      		ldi r24,lo8(strAlarmOn)
 7556 12ba 90E0      		ldi r25,hi8(strAlarmOn)
 7557 12bc 0E94 0000 		call drawText
 7558               	.L190:
 404:main.c        **** 						}
 405:main.c        **** 							
 406:main.c        **** 						write_date(30,7,0,false);	//show the month, day, and year (column, row, numbers to blank)
 7560               	.LM382:
 7561 12c0 20E0      		ldi r18,lo8(0)
 7562 12c2 40E0      		ldi r20,lo8(0)
 7563 12c4 67E0      		ldi r22,lo8(7)
 7564 12c6 8EE1      		ldi r24,lo8(30)
 7565 12c8 0E94 0000 		call write_date
 7566 12cc 54C0      		rjmp .L191
 7567               	.L187:
 407:main.c        **** 					}
 408:main.c        **** 					else if(t.intHour<16)	//This moves the time and date every 8 hours to prevent screen burn in
 7569               	.LM383:
 7570 12ce 8091 0000 		lds r24,t+4
 7571 12d2 9091 0000 		lds r25,(t+4)+1
 7572 12d6 8031      		cpi r24,16
 7573 12d8 9105      		cpc r25,__zero_reg__
 7574 12da 38F5      		brsh .L192
 409:main.c        **** 					{
 410:main.c        **** 						if(uRefreshDisplay!=1)	//when we enter this 8 hour time period, the display needs to be clear
 7576               	.LM384:
 7577 12dc 8091 0000 		lds r24,uRefreshDisplay
 7578 12e0 8130      		cpi r24,lo8(1)
 7579 12e2 29F0      		breq .L193
 411:main.c        **** 						{
 412:main.c        **** 							uRefreshDisplay=1;	//do not go in here again for this 8 hour period
 7581               	.LM385:
 7582 12e4 81E0      		ldi r24,lo8(1)
 7583 12e6 8093 0000 		sts uRefreshDisplay,r24
 413:main.c        **** 							clear_display();	//clear the whole display
 7585               	.LM386:
 7586 12ea 0E94 0000 		call clear_display
 7587               	.L193:
 414:main.c        **** 						}
 415:main.c        **** 						ShowLargeTime(0,2);		//uStartColumn, uRow
 7589               	.LM387:
 7590 12ee 62E0      		ldi r22,lo8(2)
 7591 12f0 80E0      		ldi r24,lo8(0)
 7592 12f2 0E94 0000 		call ShowLargeTime
 416:main.c        **** 						if(boolAlarmOn==false)	//Is the alarm off?
 7594               	.LM388:
 7595 12f6 8091 0000 		lds r24,boolAlarmOn
 7596 12fa 8823      		tst r24
 7597 12fc 41F4      		brne .L194
 417:main.c        **** 						{
 418:main.c        **** 							drawText((unsigned char *)strAlarmOff,0,6,false);	//show alarm on/off state (column, row)
 7599               	.LM389:
 7600 12fe 20E0      		ldi r18,lo8(0)
 7601 1300 46E0      		ldi r20,lo8(6)
 7602 1302 60E0      		ldi r22,lo8(0)
 7603 1304 80E0      		ldi r24,lo8(strAlarmOff)
 7604 1306 90E0      		ldi r25,hi8(strAlarmOff)
 7605 1308 0E94 0000 		call drawText
 7606 130c 07C0      		rjmp .L195
 7607               	.L194:
 419:main.c        **** 						}
 420:main.c        **** 						else
 421:main.c        **** 						{
 422:main.c        **** 							drawText((unsigned char *)strAlarmOn,0,6,false);	//show that the alarm is on (column, row)
 7609               	.LM390:
 7610 130e 20E0      		ldi r18,lo8(0)
 7611 1310 46E0      		ldi r20,lo8(6)
 7612 1312 60E0      		ldi r22,lo8(0)
 7613 1314 80E0      		ldi r24,lo8(strAlarmOn)
 7614 1316 90E0      		ldi r25,hi8(strAlarmOn)
 7615 1318 0E94 0000 		call drawText
 7616               	.L195:
 423:main.c        **** 						}
 424:main.c        **** 						write_date(0,7,0,false);	//show the month, day, and year (column, row, numbers to blank)
 7618               	.LM391:
 7619 131c 20E0      		ldi r18,lo8(0)
 7620 131e 40E0      		ldi r20,lo8(0)
 7621 1320 67E0      		ldi r22,lo8(7)
 7622 1322 80E0      		ldi r24,lo8(0)
 7623 1324 0E94 0000 		call write_date
 7624 1328 26C0      		rjmp .L191
 7625               	.L192:
 425:main.c        **** 					}
 426:main.c        **** 					else	//This moves the time and date every 8 hours to prevent screen burn in
 427:main.c        **** 					{
 428:main.c        **** 						if(uRefreshDisplay!=2)	//when we enter this 8 hour time period, the display needs to be clear
 7627               	.LM392:
 7628 132a 8091 0000 		lds r24,uRefreshDisplay
 7629 132e 8230      		cpi r24,lo8(2)
 7630 1330 29F0      		breq .L197
 429:main.c        **** 						{
 430:main.c        **** 							uRefreshDisplay=2;	//do not go in here again for this 8 hour period
 7632               	.LM393:
 7633 1332 82E0      		ldi r24,lo8(2)
 7634 1334 8093 0000 		sts uRefreshDisplay,r24
 431:main.c        **** 							clear_display();	//clear the whole display
 7636               	.LM394:
 7637 1338 0E94 0000 		call clear_display
 7638               	.L197:
 432:main.c        **** 						}
 433:main.c        **** 						ShowLargeTime(0,0);		//uStartColumn, uRow
 7640               	.LM395:
 7641 133c 60E0      		ldi r22,lo8(0)
 7642 133e 80E0      		ldi r24,lo8(0)
 7643 1340 0E94 0000 		call ShowLargeTime
 434:main.c        **** 						if(boolAlarmOn==false)	//Is the alarm off?
 7645               	.LM396:
 7646 1344 8091 0000 		lds r24,boolAlarmOn
 7647 1348 8823      		tst r24
 7648 134a 41F4      		brne .L198
 435:main.c        **** 						{
 436:main.c        **** 							drawText((unsigned char *)strAlarmOff,10,6,false);	//show alarm on/off state (column, row)
 7650               	.LM397:
 7651 134c 20E0      		ldi r18,lo8(0)
 7652 134e 46E0      		ldi r20,lo8(6)
 7653 1350 6AE0      		ldi r22,lo8(10)
 7654 1352 80E0      		ldi r24,lo8(strAlarmOff)
 7655 1354 90E0      		ldi r25,hi8(strAlarmOff)
 7656 1356 0E94 0000 		call drawText
 7657 135a 07C0      		rjmp .L199
 7658               	.L198:
 437:main.c        **** 						}
 438:main.c        **** 						else
 439:main.c        **** 						{
 440:main.c        **** 							drawText((unsigned char *)strAlarmOn,10,6,false);	//show that the alarm is on (column, row)
 7660               	.LM398:
 7661 135c 20E0      		ldi r18,lo8(0)
 7662 135e 46E0      		ldi r20,lo8(6)
 7663 1360 6AE0      		ldi r22,lo8(10)
 7664 1362 80E0      		ldi r24,lo8(strAlarmOn)
 7665 1364 90E0      		ldi r25,hi8(strAlarmOn)
 7666 1366 0E94 0000 		call drawText
 7667               	.L199:
 441:main.c        **** 						}
 442:main.c        **** 						write_date(defTab,7,0,false);	//show the month, day, and year (column, row, numbers to blank)
 7669               	.LM399:
 7670 136a 20E0      		ldi r18,lo8(0)
 7671 136c 40E0      		ldi r20,lo8(0)
 7672 136e 67E0      		ldi r22,lo8(7)
 7673 1370 8AE0      		ldi r24,lo8(10)
 7674 1372 0E94 0000 		call write_date
 7675               	.L191:
 443:main.c        **** 					}
 444:main.c        **** 					if((intAlarmHour==t.intHour) && (intAlarmMin==t.intMin) && (boolAlarmOn==true))
 7677               	.LM400:
 7678 1376 2091 0000 		lds r18,t+4
 7679 137a 3091 0000 		lds r19,(t+4)+1
 7680 137e 8091 0000 		lds r24,intAlarmHour
 7681 1382 9091 0000 		lds r25,(intAlarmHour)+1
 7682 1386 2817      		cp r18,r24
 7683 1388 3907      		cpc r19,r25
 7684 138a 09F0      		breq .+2
 7685 138c 5CC0      		rjmp .L201
 7686 138e 2091 0000 		lds r18,t+2
 7687 1392 3091 0000 		lds r19,(t+2)+1
 7688 1396 8091 0000 		lds r24,intAlarmMin
 7689 139a 9091 0000 		lds r25,(intAlarmMin)+1
 7690 139e 2817      		cp r18,r24
 7691 13a0 3907      		cpc r19,r25
 7692 13a2 09F0      		breq .+2
 7693 13a4 50C0      		rjmp .L201
 7694 13a6 8091 0000 		lds r24,boolAlarmOn
 7695 13aa 9927      		clr r25
 7696 13ac 8130      		cpi r24,1
 7697 13ae 9105      		cpc r25,__zero_reg__
 7698 13b0 09F0      		breq .+2
 7699 13b2 49C0      		rjmp .L201
 445:main.c        **** 					{	//sound the alarm if it is correct hour, minute, and if the alarm is enabled
 446:main.c        **** 						boolSoundAlarm=true;	//sound the alarm!!!
 7701               	.LM401:
 7702 13b4 81E0      		ldi r24,lo8(1)
 7703 13b6 8093 0000 		sts boolSoundAlarm,r24
 7704 13ba 45C0      		rjmp .L201
 7705               	.L179:
 447:main.c        **** 					}
 448:main.c        ****                 }
 449:main.c        **** 				else
 450:main.c        **** 				{
 451:main.c        **** 	                uTmrState--;	//count down to the next time we can update the LCD display
 7707               	.LM402:
 7708 13bc 8091 0000 		lds r24,uTmrState
 7709 13c0 8150      		subi r24,lo8(-(-1))
 7710 13c2 8093 0000 		sts uTmrState,r24
 452:main.c        **** 					
 453:main.c        **** 					if(uTmrState==15)
 7712               	.LM403:
 7713 13c6 8091 0000 		lds r24,uTmrState
 7714 13ca 8F30      		cpi r24,lo8(15)
 7715 13cc 39F4      		brne .L202
 454:main.c        **** 					{
 455:main.c        **** 						ADMUX=0;	//select analog channel 0 for the ADC conversion
 7717               	.LM404:
 7718 13ce 1092 2700 		sts 39,__zero_reg__
 456:main.c        **** 						ADCSRA|=0x40;	//start the ADC conversion process
 7720               	.LM405:
 7721 13d2 8091 2600 		lds r24,38
 7722 13d6 8064      		ori r24,lo8(64)
 7723 13d8 8093 2600 		sts 38,r24
 7724               	.L202:
 457:main.c        **** 					}
 458:main.c        **** 					if(uTmrState==10)
 7726               	.LM406:
 7727 13dc 8091 0000 		lds r24,uTmrState
 7728 13e0 8A30      		cpi r24,lo8(10)
 7729 13e2 81F4      		brne .L203
 459:main.c        **** 					{
 460:main.c        **** 						uTmrGeneral=40;
 7731               	.LM407:
 7732 13e4 88E2      		ldi r24,lo8(40)
 7733 13e6 8093 0000 		sts uTmrGeneral,r24
 461:main.c        **** 						ADCSRA|=0x10;	//return the ADC, the 10 bit value is stored in the integer ADC
 7735               	.LM408:
 7736 13ea 8091 2600 		lds r24,38
 7737 13ee 8061      		ori r24,lo8(16)
 7738 13f0 8093 2600 		sts 38,r24
 462:main.c        **** 						intPhotocellValue=ADC;	//get the ADC value and store it
 7740               	.LM409:
 7741 13f4 8091 2400 		lds r24,36
 7742 13f8 9091 2500 		lds r25,(36)+1
 7743 13fc 9093 0000 		sts (intPhotocellValue)+1,r25
 7744 1400 8093 0000 		sts intPhotocellValue,r24
 7745               	.L203:
 463:main.c        **** 					}
 464:main.c        **** 					if(uTmrState==50 && boolPowerupBlink==true)	//blink the whole display when the unit has just
 7747               	.LM410:
 7748 1404 8091 0000 		lds r24,uTmrState
 7749 1408 8233      		cpi r24,lo8(50)
 7750 140a 41F4      		brne .L204
 7751 140c 8091 0000 		lds r24,boolPowerupBlink
 7752 1410 9927      		clr r25
 7753 1412 8130      		cpi r24,1
 7754 1414 9105      		cpc r25,__zero_reg__
 7755 1416 11F4      		brne .L204
 465:main.c        **** 					{		// been powered up and the time has not been set
 466:main.c        **** 						clear_display();	//clear the whole display
 7757               	.LM411:
 7758 1418 0E94 0000 		call clear_display
 7759               	.L204:
 467:main.c        **** 					}
 468:main.c        **** 					if((boolSoundAlarm==true) && (uTmrState<15))	//Is it time to turn on the alarm, boolAlarmOn 
 7761               	.LM412:
 7762 141c 8091 0000 		lds r24,boolSoundAlarm
 7763 1420 9927      		clr r25
 7764 1422 8130      		cpi r24,1
 7765 1424 9105      		cpc r25,__zero_reg__
 7766 1426 51F4      		brne .L205
 7767 1428 8091 0000 		lds r24,uTmrState
 7768 142c 8F30      		cpi r24,lo8(15)
 7769 142e 30F4      		brsh .L205
 469:main.c        **** 					{							//	for the alarm clock?
 470:main.c        **** 						sbi(defPORTD,defAlarmPin);	//take the I/O pin high to sound the alarm
 7771               	.LM413:
 7772 1430 8091 3200 		lds r24,50
 7773 1434 8160      		ori r24,lo8(1)
 7774 1436 8093 3200 		sts 50,r24
 7775 143a 05C0      		rjmp .L201
 7776               	.L205:
 471:main.c        **** 					}
 472:main.c        **** 					else
 473:main.c        **** 					{
 474:main.c        **** 						cbi(defPORTD,defAlarmPin);	//this turns off the alarm for a few seconds
 7778               	.LM414:
 7779 143c 8091 3200 		lds r24,50
 7780 1440 8E7F      		andi r24,lo8(-2)
 7781 1442 8093 3200 		sts 50,r24
 7782               	.L201:
 475:main.c        **** 					}
 476:main.c        **** 				}
 477:main.c        ****                 if(bit_is_clear(defPushBtnPort,defUpBtn) && uBtnUpTmr==0)  //is the Menu button 1 p
 7784               	.LM415:
 7785 1446 8091 3900 		lds r24,57
 7786 144a 9927      		clr r25
 7787 144c 9695      		lsr r25
 7788 144e 8795      		ror r24
 7789 1450 9695      		lsr r25
 7790 1452 8795      		ror r24
 7791 1454 8170      		andi r24,lo8(1)
 7792 1456 9070      		andi r25,hi8(1)
 7793 1458 0097      		sbiw r24,0
 7794 145a A9F4      		brne .L207
 7795 145c 8091 0000 		lds r24,uBtnUpTmr
 7796 1460 8823      		tst r24
 7797 1462 89F4      		brne .L207
 478:main.c        **** 				{				
 479:main.c        **** 					boolSoundAlarm=false;	//when any button is pressed, turn off the alarm
 7799               	.LM416:
 7800 1464 1092 0000 		sts boolSoundAlarm,__zero_reg__
 480:main.c        **** 					boolPowerupBlink=false;		//don't blink the time on powerup anymore
 7802               	.LM417:
 7803 1468 1092 0000 		sts boolPowerupBlink,__zero_reg__
 481:main.c        **** 					cbi(defPORTD,defAlarmPin);	//this turns off the alarm off, the bool value above too
 7805               	.LM418:
 7806 146c 8091 3200 		lds r24,50
 7807 1470 8E7F      		andi r24,lo8(-2)
 7808 1472 8093 3200 		sts 50,r24
 482:main.c        **** 					sbi(defPORTD,defBacklightOn);	//turn on the backlight, when a button is pressed
 7810               	.LM419:
 7811 1476 8091 3200 		lds r24,50
 7812 147a 8068      		ori r24,lo8(-128)
 7813 147c 8093 3200 		sts 50,r24
 483:main.c        **** 					uBtnUpTmr=defBtnDbn;   //load up the debounce timer, so we don't immediately go back in here
 7815               	.LM420:
 7816 1480 8EE0      		ldi r24,lo8(14)
 7817 1482 8093 0000 		sts uBtnUpTmr,r24
 7818               	.L207:
 484:main.c        **** 				}
 485:main.c        ****                 if(bit_is_clear(defPushBtnPort,defDownBtn) && uBtnDwnTmr==0)  //is the Menu button 
 7820               	.LM421:
 7821 1486 8091 3900 		lds r24,57
 7822 148a 9927      		clr r25
 7823 148c 9695      		lsr r25
 7824 148e 8795      		ror r24
 7825 1490 9695      		lsr r25
 7826 1492 8795      		ror r24
 7827 1494 9695      		lsr r25
 7828 1496 8795      		ror r24
 7829 1498 8170      		andi r24,lo8(1)
 7830 149a 9070      		andi r25,hi8(1)
 7831 149c 0097      		sbiw r24,0
 7832 149e A9F4      		brne .L208
 7833 14a0 8091 0000 		lds r24,uBtnDwnTmr
 7834 14a4 8823      		tst r24
 7835 14a6 89F4      		brne .L208
 486:main.c        **** 				{
 487:main.c        **** 					boolSoundAlarm=false;	//when any button is pressed, turn off the alarm
 7837               	.LM422:
 7838 14a8 1092 0000 		sts boolSoundAlarm,__zero_reg__
 488:main.c        **** 					boolPowerupBlink=false;		//don't blink the time on powerup anymore
 7840               	.LM423:
 7841 14ac 1092 0000 		sts boolPowerupBlink,__zero_reg__
 489:main.c        **** 					cbi(defPORTD,defAlarmPin);	//this turns off the alarm off, the bool value above too
 7843               	.LM424:
 7844 14b0 8091 3200 		lds r24,50
 7845 14b4 8E7F      		andi r24,lo8(-2)
 7846 14b6 8093 3200 		sts 50,r24
 490:main.c        **** 					sbi(defPORTD,defBacklightOn);	//turn on the backlight, when a button is pressed
 7848               	.LM425:
 7849 14ba 8091 3200 		lds r24,50
 7850 14be 8068      		ori r24,lo8(-128)
 7851 14c0 8093 3200 		sts 50,r24
 491:main.c        **** 					uBtnDwnTmr=defBtnDbn;   //load up the debounce timer, so we don't immediately go back in here
 7853               	.LM426:
 7854 14c4 8EE0      		ldi r24,lo8(14)
 7855 14c6 8093 0000 		sts uBtnDwnTmr,r24
 7856               	.L208:
 492:main.c        **** 				}
 493:main.c        ****                 if(bit_is_clear(defPushBtnPort,defEnterBtn) && uBtnEnterTmr==0)  //is the Menu butt
 7858               	.LM427:
 7859 14ca 8091 3900 		lds r24,57
 7860 14ce 9927      		clr r25
 7861 14d0 9695      		lsr r25
 7862 14d2 8795      		ror r24
 7863 14d4 8170      		andi r24,lo8(1)
 7864 14d6 9070      		andi r25,hi8(1)
 7865 14d8 0097      		sbiw r24,0
 7866 14da 09F0      		breq .+2
 7867 14dc 13C7      		rjmp .L168
 7868 14de 8091 0000 		lds r24,uBtnEnterTmr
 7869 14e2 8823      		tst r24
 7870 14e4 09F0      		breq .+2
 7871 14e6 0EC7      		rjmp .L168
 494:main.c        **** 				{
 495:main.c        **** 					sbi(defPORTD,defBacklightOn);	//turn on the backlight, when a button is pressed
 7873               	.LM428:
 7874 14e8 8091 3200 		lds r24,50
 7875 14ec 8068      		ori r24,lo8(-128)
 7876 14ee 8093 3200 		sts 50,r24
 496:main.c        **** 					boolPowerupBlink=false;		//don't blink the time since the menu has been entered
 7878               	.LM429:
 7879 14f2 1092 0000 		sts boolPowerupBlink,__zero_reg__
 497:main.c        **** 					if(boolSoundAlarm == true)	//is the alarm sounding?
 7881               	.LM430:
 7882 14f6 8091 0000 		lds r24,boolSoundAlarm
 7883 14fa 9927      		clr r25
 7884 14fc 8130      		cpi r24,1
 7885 14fe 9105      		cpc r25,__zero_reg__
 7886 1500 41F4      		brne .L210
 498:main.c        **** 					{	//the alarm is sounding, turn it off!
 499:main.c        **** 						boolSoundAlarm=false;	//when any button is pressed, turn off the alarm
 7888               	.LM431:
 7889 1502 1092 0000 		sts boolSoundAlarm,__zero_reg__
 500:main.c        **** 						cbi(defPORTD,defAlarmPin);	//this turns off the alarm off, the bool value above too
 7891               	.LM432:
 7892 1506 8091 3200 		lds r24,50
 7893 150a 8E7F      		andi r24,lo8(-2)
 7894 150c 8093 3200 		sts 50,r24
 7895 1510 09C0      		rjmp .L211
 7896               	.L210:
 501:main.c        **** 					}
 502:main.c        **** 					else	//the alarm is not sounding
 503:main.c        **** 					{
 504:main.c        **** 						uBtnEnterTmr=defBtnDbn;   //load up the debounce timer, so we don't immediately go back in he
 7898               	.LM433:
 7899 1512 8EE0      		ldi r24,lo8(14)
 7900 1514 8093 0000 		sts uBtnEnterTmr,r24
 505:main.c        **** 						uState=50;
 7902               	.LM434:
 7903 1518 82E3      		ldi r24,lo8(50)
 7904 151a 8093 0000 		sts uState,r24
 506:main.c        **** 						uSelectedLine=1;	//start out with the alarm set button highlighted
 7906               	.LM435:
 7907 151e 81E0      		ldi r24,lo8(1)
 7908 1520 8093 0000 		sts uSelectedLine,r24
 7909               	.L211:
 507:main.c        **** 					}
 508:main.c        ****                     uTmrState=defStateTm;       //reload the state timer to stay in this state
 7911               	.LM436:
 7912 1524 88EC      		ldi r24,lo8(-56)
 7913 1526 8093 0000 		sts uTmrState,r24
 509:main.c        **** 				}
 510:main.c        **** 			break;
 7915               	.LM437:
 7916 152a 0C94 0000 		jmp .L168
 7917               	.L212:
 511:main.c        **** 
 512:main.c        **** 			case 50:	//displays the main menu, allows the user to make a selection from the main menu
 513:main.c        **** 				if(bit_is_clear(defPushBtnPort,defUpBtn) && uBtnUpTmr==0)  //is the Menu button 1 pressed?
 7919               	.LM438:
 7920 152e 8091 3900 		lds r24,57
 7921 1532 9927      		clr r25
 7922 1534 9695      		lsr r25
 7923 1536 8795      		ror r24
 7924 1538 9695      		lsr r25
 7925 153a 8795      		ror r24
 7926 153c 8170      		andi r24,lo8(1)
 7927 153e 9070      		andi r25,hi8(1)
 7928 1540 0097      		sbiw r24,0
 7929 1542 91F4      		brne .L213
 7930 1544 8091 0000 		lds r24,uBtnUpTmr
 7931 1548 8823      		tst r24
 7932 154a 71F4      		brne .L213
 514:main.c        **** 				{				
 515:main.c        **** 					uSelectedLine--;
 7934               	.LM439:
 7935 154c 8091 0000 		lds r24,uSelectedLine
 7936 1550 8150      		subi r24,lo8(-(-1))
 7937 1552 8093 0000 		sts uSelectedLine,r24
 516:main.c        **** 					paintMenu((unsigned char *)str50,defState50HighlightMin,defState50HighlightMax);
 7939               	.LM440:
 7940 1556 47E0      		ldi r20,lo8(7)
 7941 1558 61E0      		ldi r22,lo8(1)
 7942 155a 80E0      		ldi r24,lo8(str50)
 7943 155c 90E0      		ldi r25,hi8(str50)
 7944 155e 0E94 0000 		call paintMenu
 517:main.c        **** 					uBtnUpTmr=defBtnDbn;	//load up the debounce timer, so we don't immediately go back in here
 7946               	.LM441:
 7947 1562 8EE0      		ldi r24,lo8(14)
 7948 1564 8093 0000 		sts uBtnUpTmr,r24
 7949               	.L213:
 518:main.c        **** 				}
 519:main.c        **** 				if(bit_is_clear(defPushBtnPort,defDownBtn) && uBtnDwnTmr==0)  //is the Menu button 2 pressed?
 7951               	.LM442:
 7952 1568 8091 3900 		lds r24,57
 7953 156c 9927      		clr r25
 7954 156e 9695      		lsr r25
 7955 1570 8795      		ror r24
 7956 1572 9695      		lsr r25
 7957 1574 8795      		ror r24
 7958 1576 9695      		lsr r25
 7959 1578 8795      		ror r24
 7960 157a 8170      		andi r24,lo8(1)
 7961 157c 9070      		andi r25,hi8(1)
 7962 157e 0097      		sbiw r24,0
 7963 1580 91F4      		brne .L214
 7964 1582 8091 0000 		lds r24,uBtnDwnTmr
 7965 1586 8823      		tst r24
 7966 1588 71F4      		brne .L214
 520:main.c        **** 				{
 521:main.c        **** 					uSelectedLine++;
 7968               	.LM443:
 7969 158a 8091 0000 		lds r24,uSelectedLine
 7970 158e 8F5F      		subi r24,lo8(-(1))
 7971 1590 8093 0000 		sts uSelectedLine,r24
 522:main.c        **** 					paintMenu((unsigned char *)str50,defState50HighlightMin,defState50HighlightMax);
 7973               	.LM444:
 7974 1594 47E0      		ldi r20,lo8(7)
 7975 1596 61E0      		ldi r22,lo8(1)
 7976 1598 80E0      		ldi r24,lo8(str50)
 7977 159a 90E0      		ldi r25,hi8(str50)
 7978 159c 0E94 0000 		call paintMenu
 523:main.c        **** 					uBtnDwnTmr=defBtnDbn;	//load up the debounce timer, so we don't immediately go back in here
 7980               	.LM445:
 7981 15a0 8EE0      		ldi r24,lo8(14)
 7982 15a2 8093 0000 		sts uBtnDwnTmr,r24
 7983               	.L214:
 524:main.c        **** 				}
 525:main.c        **** 				if(bit_is_clear(defPushBtnPort,defEnterBtn) && uBtnEnterTmr==0)  //is the Menu button 2 pressed
 7985               	.LM446:
 7986 15a6 8091 3900 		lds r24,57
 7987 15aa 9927      		clr r25
 7988 15ac 9695      		lsr r25
 7989 15ae 8795      		ror r24
 7990 15b0 8170      		andi r24,lo8(1)
 7991 15b2 9070      		andi r25,hi8(1)
 7992 15b4 0097      		sbiw r24,0
 7993 15b6 09F0      		breq .+2
 7994 15b8 92C0      		rjmp .L215
 7995 15ba 8091 0000 		lds r24,uBtnEnterTmr
 7996 15be 8823      		tst r24
 7997 15c0 09F0      		breq .+2
 7998 15c2 8DC0      		rjmp .L215
 526:main.c        **** 				{	
 527:main.c        **** 			        switch (uSelectedLine)	//the set button was pressed
 8000               	.LM447:
 8001 15c4 8091 0000 		lds r24,uSelectedLine
 8002 15c8 282F      		mov r18,r24
 8003 15ca 3327      		clr r19
 8004 15cc 2983      		std Y+1,r18
 8005 15ce 3A83      		std Y+2,r19
 8006 15d0 8981      		ldd r24,Y+1
 8007 15d2 9A81      		ldd r25,Y+2
 8008 15d4 8430      		cpi r24,4
 8009 15d6 9105      		cpc r25,__zero_reg__
 8010 15d8 09F4      		brne .+2
 8011 15da 5EC0      		rjmp .L222
 8012 15dc 2981      		ldd r18,Y+1
 8013 15de 3A81      		ldd r19,Y+2
 8014 15e0 2530      		cpi r18,5
 8015 15e2 3105      		cpc r19,__zero_reg__
 8016 15e4 84F4      		brge .L226
 8017 15e6 8981      		ldd r24,Y+1
 8018 15e8 9A81      		ldd r25,Y+2
 8019 15ea 8230      		cpi r24,2
 8020 15ec 9105      		cpc r25,__zero_reg__
 8021 15ee 81F1      		breq .L220
 8022 15f0 2981      		ldd r18,Y+1
 8023 15f2 3A81      		ldd r19,Y+2
 8024 15f4 2330      		cpi r18,3
 8025 15f6 3105      		cpc r19,__zero_reg__
 8026 15f8 ECF5      		brge .L221
 8027 15fa 8981      		ldd r24,Y+1
 8028 15fc 9A81      		ldd r25,Y+2
 8029 15fe 8130      		cpi r24,1
 8030 1600 9105      		cpc r25,__zero_reg__
 8031 1602 A1F0      		breq .L217
 8032 1604 69C0      		rjmp .L216
 8033               	.L226:
 8034 1606 2981      		ldd r18,Y+1
 8035 1608 3A81      		ldd r19,Y+2
 8036 160a 2630      		cpi r18,6
 8037 160c 3105      		cpc r19,__zero_reg__
 8038 160e 09F4      		brne .+2
 8039 1610 57C0      		rjmp .L224
 8040 1612 8981      		ldd r24,Y+1
 8041 1614 9A81      		ldd r25,Y+2
 8042 1616 8630      		cpi r24,6
 8043 1618 9105      		cpc r25,__zero_reg__
 8044 161a 0CF4      		brge .+2
 8045 161c 48C0      		rjmp .L223
 8046 161e 2981      		ldd r18,Y+1
 8047 1620 3A81      		ldd r19,Y+2
 8048 1622 2730      		cpi r18,7
 8049 1624 3105      		cpc r19,__zero_reg__
 8050 1626 09F4      		brne .+2
 8051 1628 52C0      		rjmp .L225
 8052 162a 56C0      		rjmp .L216
 8053               	.L217:
 528:main.c        **** 					{
 529:main.c        **** 						case 1:		//Set the Alarm On/off
 530:main.c        **** 							if(boolAlarmOn==true)	//was the alarm on?
 8055               	.LM448:
 8056 162c 8091 0000 		lds r24,boolAlarmOn
 8057 1630 9927      		clr r25
 8058 1632 8130      		cpi r24,1
 8059 1634 9105      		cpc r25,__zero_reg__
 8060 1636 19F4      		brne .L218
 531:main.c        **** 							{
 532:main.c        **** 								boolAlarmOn=false;	//if so, then turn off the alarm
 8062               	.LM449:
 8063 1638 1092 0000 		sts boolAlarmOn,__zero_reg__
 8064 163c 03C0      		rjmp .L219
 8065               	.L218:
 533:main.c        **** 							}
 534:main.c        **** 							else
 535:main.c        **** 							{
 536:main.c        **** 								boolAlarmOn=true;	//the alarm was not on, so turn on the alarm
 8067               	.LM450:
 8068 163e 81E0      		ldi r24,lo8(1)
 8069 1640 8093 0000 		sts boolAlarmOn,r24
 8070               	.L219:
 537:main.c        **** 							}
 538:main.c        **** 							uTmrState=3;	//This lets state 2 paint the screen correctly
 8072               	.LM451:
 8073 1644 83E0      		ldi r24,lo8(3)
 8074 1646 8093 0000 		sts uTmrState,r24
 539:main.c        **** 							uState=0;		//go back to main clock display, clearing the display first
 8076               	.LM452:
 8077 164a 1092 0000 		sts uState,__zero_reg__
 540:main.c        **** 						break;
 8079               	.LM453:
 8080 164e 44C0      		rjmp .L216
 8081               	.L220:
 541:main.c        **** 						case 2:		//Set the Clock
 542:main.c        **** 							clear_display();	//clear the whole display
 8083               	.LM454:
 8084 1650 0E94 0000 		call clear_display
 543:main.c        **** 							uTimeSetState=0;	//start out in the set the hour state
 8086               	.LM455:
 8087 1654 1092 0000 		sts uTimeSetState,__zero_reg__
 544:main.c        **** 							uState=60;		//move to the set-the-clock state
 8089               	.LM456:
 8090 1658 8CE3      		ldi r24,lo8(60)
 8091 165a 8093 0000 		sts uState,r24
 545:main.c        **** 							uTmrState=5;
 8093               	.LM457:
 8094 165e 85E0      		ldi r24,lo8(5)
 8095 1660 8093 0000 		sts uTmrState,r24
 546:main.c        **** 							drawText((unsigned char *)strSetTheTime,0,0,false);		//show the "set the time" title
 8097               	.LM458:
 8098 1664 20E0      		ldi r18,lo8(0)
 8099 1666 40E0      		ldi r20,lo8(0)
 8100 1668 60E0      		ldi r22,lo8(0)
 8101 166a 80E0      		ldi r24,lo8(strSetTheTime)
 8102 166c 90E0      		ldi r25,hi8(strSetTheTime)
 8103 166e 0E94 0000 		call drawText
 547:main.c        **** 						break;
 8105               	.LM459:
 8106 1672 32C0      		rjmp .L216
 8107               	.L221:
 548:main.c        **** 						case 3:		//Set the Alarm time
 549:main.c        **** 							clear_display();	//clear the whole display
 8109               	.LM460:
 8110 1674 0E94 0000 		call clear_display
 550:main.c        **** 							uTimeSetState=0;	//start out in the set the alarm hour state
 8112               	.LM461:
 8113 1678 1092 0000 		sts uTimeSetState,__zero_reg__
 551:main.c        **** 							uState=61;		//move to the set-the-alarm state
 8115               	.LM462:
 8116 167c 8DE3      		ldi r24,lo8(61)
 8117 167e 8093 0000 		sts uState,r24
 552:main.c        **** 							uTmrState=5;
 8119               	.LM463:
 8120 1682 85E0      		ldi r24,lo8(5)
 8121 1684 8093 0000 		sts uTmrState,r24
 553:main.c        **** 							drawText((unsigned char *)strSetTheAlarm,0,0,false);		//show the "set the Alarm" title
 8123               	.LM464:
 8124 1688 20E0      		ldi r18,lo8(0)
 8125 168a 40E0      		ldi r20,lo8(0)
 8126 168c 60E0      		ldi r22,lo8(0)
 8127 168e 80E0      		ldi r24,lo8(strSetTheAlarm)
 8128 1690 90E0      		ldi r25,hi8(strSetTheAlarm)
 8129 1692 0E94 0000 		call drawText
 554:main.c        **** 						break;
 8131               	.LM465:
 8132 1696 20C0      		rjmp .L216
 8133               	.L222:
 555:main.c        **** 						case 4:		//set the backlight times
 556:main.c        **** 							uState=62;
 8135               	.LM466:
 8136 1698 8EE3      		ldi r24,lo8(62)
 8137 169a 8093 0000 		sts uState,r24
 557:main.c        **** 							clear_display();	//clear the whole display
 8139               	.LM467:
 8140 169e 0E94 0000 		call clear_display
 558:main.c        **** 							uTimeSetState=0;	//set the "backlight off time" first
 8142               	.LM468:
 8143 16a2 1092 0000 		sts uTimeSetState,__zero_reg__
 559:main.c        **** 							uTmrState=defStateTm+2;		//allow the new state to paint the new screen
 8145               	.LM469:
 8146 16a6 8AEC      		ldi r24,lo8(-54)
 8147 16a8 8093 0000 		sts uTmrState,r24
 560:main.c        **** 						break;
 8149               	.LM470:
 8150 16ac 15C0      		rjmp .L216
 8151               	.L223:
 561:main.c        **** 						case 5:		//set the photo trigger value
 562:main.c        **** 							uState=63;
 8153               	.LM471:
 8154 16ae 8FE3      		ldi r24,lo8(63)
 8155 16b0 8093 0000 		sts uState,r24
 563:main.c        **** 							clear_display();	//clear the whole display
 8157               	.LM472:
 8158 16b4 0E94 0000 		call clear_display
 564:main.c        **** 							uTmrState=defStateTm+2;		//allow the new state to paint the new screen
 8160               	.LM473:
 8161 16b8 8AEC      		ldi r24,lo8(-54)
 8162 16ba 8093 0000 		sts uTmrState,r24
 565:main.c        **** 						break;
 8164               	.LM474:
 8165 16be 0CC0      		rjmp .L216
 8166               	.L224:
 566:main.c        **** 						case 6:		//Show the "About this clock" information
 567:main.c        **** 							uState=64;
 8168               	.LM475:
 8169 16c0 80E4      		ldi r24,lo8(64)
 8170 16c2 8093 0000 		sts uState,r24
 568:main.c        **** 							uTmrState=5;
 8172               	.LM476:
 8173 16c6 85E0      		ldi r24,lo8(5)
 8174 16c8 8093 0000 		sts uTmrState,r24
 569:main.c        **** 						break;
 8176               	.LM477:
 8177 16cc 05C0      		rjmp .L216
 8178               	.L225:
 570:main.c        **** 						case 7:		//the exit button
 571:main.c        **** 							uTmrState=3;	//This lets state 0 paint the screen correctly
 8180               	.LM478:
 8181 16ce 83E0      		ldi r24,lo8(3)
 8182 16d0 8093 0000 		sts uTmrState,r24
 572:main.c        **** 							uState=0;	//go back to the main display, clearing the display first
 8184               	.LM479:
 8185 16d4 1092 0000 		sts uState,__zero_reg__
 8186               	.L216:
 573:main.c        **** 						break;
 574:main.c        **** 					}
 575:main.c        **** 					uBtnEnterTmr=defBtnDbn;   //load up the debounce timer, so we don't immediately go back in her
 8188               	.LM480:
 8189 16d8 8EE0      		ldi r24,lo8(14)
 8190 16da 8093 0000 		sts uBtnEnterTmr,r24
 8191               	.L215:
 576:main.c        **** 				}
 577:main.c        **** 				if(uTmrState==defStateTm)
 8193               	.LM481:
 8194 16de 8091 0000 		lds r24,uTmrState
 8195 16e2 883C      		cpi r24,lo8(-56)
 8196 16e4 09F0      		breq .+2
 8197 16e6 0EC6      		rjmp .L168
 578:main.c        **** 				{
 579:main.c        **** 					clear_display();	//clear the whole display
 8199               	.LM482:
 8200 16e8 0E94 0000 		call clear_display
 580:main.c        **** 					paintMenu((unsigned char *)str50,defState50HighlightMin,defState50HighlightMax);	//string, col
 8202               	.LM483:
 8203 16ec 47E0      		ldi r20,lo8(7)
 8204 16ee 61E0      		ldi r22,lo8(1)
 8205 16f0 80E0      		ldi r24,lo8(str50)
 8206 16f2 90E0      		ldi r25,hi8(str50)
 8207 16f4 0E94 0000 		call paintMenu
 581:main.c        **** 					uTmrState--;	//don't go in here again
 8209               	.LM484:
 8210 16f8 8091 0000 		lds r24,uTmrState
 8211 16fc 8150      		subi r24,lo8(-(-1))
 8212 16fe 8093 0000 		sts uTmrState,r24
 582:main.c        **** 				}
 583:main.c        **** 			break;
 8214               	.LM485:
 8215 1702 00C6      		rjmp .L168
 8216               	.L228:
 584:main.c        **** 			
 585:main.c        **** 			//uTimeSetState = 0 set the hour
 586:main.c        **** 			//uTimeSetState = 1 set the minute
 587:main.c        **** 			//uTimeSetState = 2 set the month
 588:main.c        **** 			//uTimeSetState = 3 set the day
 589:main.c        **** 			//uTimeSetState = 4 set the year
 590:main.c        **** 			case 60:	//We are going to set the time
 591:main.c        **** 				//has the up button been pressed?
 592:main.c        **** 				if(bit_is_clear(defPushBtnPort,defUpBtn) && uBtnUpTmr==0)  //is the Menu button 1 pressed?
 8218               	.LM486:
 8219 1704 8091 3900 		lds r24,57
 8220 1708 9927      		clr r25
 8221 170a 9695      		lsr r25
 8222 170c 8795      		ror r24
 8223 170e 9695      		lsr r25
 8224 1710 8795      		ror r24
 8225 1712 8170      		andi r24,lo8(1)
 8226 1714 9070      		andi r25,hi8(1)
 8227 1716 0097      		sbiw r24,0
 8228 1718 09F0      		breq .+2
 8229 171a BAC0      		rjmp .L229
 8230 171c 8091 0000 		lds r24,uBtnUpTmr
 8231 1720 8823      		tst r24
 8232 1722 09F0      		breq .+2
 8233 1724 B5C0      		rjmp .L229
 593:main.c        **** 				{
 594:main.c        **** 					switch(uTimeSetState)	//what are we going to set?
 8235               	.LM487:
 8236 1726 8091 0000 		lds r24,uTimeSetState
 8237 172a 282F      		mov r18,r24
 8238 172c 3327      		clr r19
 8239 172e 2B83      		std Y+3,r18
 8240 1730 3C83      		std Y+4,r19
 8241 1732 8B81      		ldd r24,Y+3
 8242 1734 9C81      		ldd r25,Y+4
 8243 1736 8230      		cpi r24,2
 8244 1738 9105      		cpc r25,__zero_reg__
 8245 173a 09F4      		brne .+2
 8246 173c 50C0      		rjmp .L237
 8247 173e 2B81      		ldd r18,Y+3
 8248 1740 3C81      		ldd r19,Y+4
 8249 1742 2330      		cpi r18,3
 8250 1744 3105      		cpc r19,__zero_reg__
 8251 1746 54F4      		brge .L245
 8252 1748 8B81      		ldd r24,Y+3
 8253 174a 9C81      		ldd r25,Y+4
 8254 174c 0097      		sbiw r24,0
 8255 174e 99F0      		breq .L231
 8256 1750 2B81      		ldd r18,Y+3
 8257 1752 3C81      		ldd r19,Y+4
 8258 1754 2130      		cpi r18,1
 8259 1756 3105      		cpc r19,__zero_reg__
 8260 1758 41F1      		breq .L234
 8261 175a 94C0      		rjmp .L230
 8262               	.L245:
 8263 175c 8B81      		ldd r24,Y+3
 8264 175e 9C81      		ldd r25,Y+4
 8265 1760 8330      		cpi r24,3
 8266 1762 9105      		cpc r25,__zero_reg__
 8267 1764 09F4      		brne .+2
 8268 1766 59C0      		rjmp .L240
 8269 1768 2B81      		ldd r18,Y+3
 8270 176a 3C81      		ldd r19,Y+4
 8271 176c 2430      		cpi r18,4
 8272 176e 3105      		cpc r19,__zero_reg__
 8273 1770 09F4      		brne .+2
 8274 1772 71C0      		rjmp .L243
 8275 1774 87C0      		rjmp .L230
 8276               	.L231:
 595:main.c        **** 					{
 596:main.c        **** 						case 0:		//set the hour
 597:main.c        **** 							if(t.intHour<23)		//have we reached the maximum hour count?
 8278               	.LM488:
 8279 1776 8091 0000 		lds r24,t+4
 8280 177a 9091 0000 		lds r25,(t+4)+1
 8281 177e 8731      		cpi r24,23
 8282 1780 9105      		cpc r25,__zero_reg__
 8283 1782 50F4      		brsh .L232
 598:main.c        **** 							{
 599:main.c        **** 								t.intHour++;		//no, increment the hour
 8285               	.LM489:
 8286 1784 8091 0000 		lds r24,t+4
 8287 1788 9091 0000 		lds r25,(t+4)+1
 8288 178c 0196      		adiw r24,1
 8289 178e 9093 0000 		sts (t+4)+1,r25
 8290 1792 8093 0000 		sts t+4,r24
 8291 1796 04C0      		rjmp .L233
 8292               	.L232:
 600:main.c        **** 							}
 601:main.c        **** 							else	
 602:main.c        **** 							{
 603:main.c        **** 								t.intHour=0;		//reset the hour count since we have reached the 23rd hour
 8294               	.LM490:
 8295 1798 1092 0000 		sts (t+4)+1,__zero_reg__
 8296 179c 1092 0000 		sts t+4,__zero_reg__
 8297               	.L233:
 604:main.c        **** 							}
 605:main.c        **** 							ShowLargeTime(0,2);		//uStartColumn, uRow
 8299               	.LM491:
 8300 17a0 62E0      		ldi r22,lo8(2)
 8301 17a2 80E0      		ldi r24,lo8(0)
 8302 17a4 0E94 0000 		call ShowLargeTime
 606:main.c        **** 
 607:main.c        **** 						break;
 8304               	.LM492:
 8305 17a8 6DC0      		rjmp .L230
 8306               	.L234:
 608:main.c        **** 						case 1:		//set the minute
 609:main.c        **** 							if(t.intMin<59)		//have we reached the maximum minute count?
 8308               	.LM493:
 8309 17aa 8091 0000 		lds r24,t+2
 8310 17ae 9091 0000 		lds r25,(t+2)+1
 8311 17b2 8B33      		cpi r24,59
 8312 17b4 9105      		cpc r25,__zero_reg__
 8313 17b6 50F4      		brsh .L235
 610:main.c        **** 							{
 611:main.c        **** 								t.intMin++;		//no, then increment the minute
 8315               	.LM494:
 8316 17b8 8091 0000 		lds r24,t+2
 8317 17bc 9091 0000 		lds r25,(t+2)+1
 8318 17c0 0196      		adiw r24,1
 8319 17c2 9093 0000 		sts (t+2)+1,r25
 8320 17c6 8093 0000 		sts t+2,r24
 8321 17ca 04C0      		rjmp .L236
 8322               	.L235:
 612:main.c        **** 							}
 613:main.c        **** 							else		
 614:main.c        **** 							{
 615:main.c        **** 								t.intMin=0;		//reset the hour count since we have reached the 59th minute
 8324               	.LM495:
 8325 17cc 1092 0000 		sts (t+2)+1,__zero_reg__
 8326 17d0 1092 0000 		sts t+2,__zero_reg__
 8327               	.L236:
 616:main.c        **** 							}
 617:main.c        **** 							ShowLargeTime(0,2);		//uStartColumn, uRow
 8329               	.LM496:
 8330 17d4 62E0      		ldi r22,lo8(2)
 8331 17d6 80E0      		ldi r24,lo8(0)
 8332 17d8 0E94 0000 		call ShowLargeTime
 618:main.c        **** 						break;
 8334               	.LM497:
 8335 17dc 53C0      		rjmp .L230
 8336               	.L237:
 619:main.c        **** 						case 2:		//set the month
 620:main.c        **** 							if(t.intMonth<12)		//have we reached passed december?
 8338               	.LM498:
 8339 17de 8091 0000 		lds r24,t+8
 8340 17e2 9091 0000 		lds r25,(t+8)+1
 8341 17e6 8C30      		cpi r24,12
 8342 17e8 9105      		cpc r25,__zero_reg__
 8343 17ea 50F4      		brsh .L238
 621:main.c        **** 							{
 622:main.c        **** 								t.intMonth++;		//no, then increment the month
 8345               	.LM499:
 8346 17ec 8091 0000 		lds r24,t+8
 8347 17f0 9091 0000 		lds r25,(t+8)+1
 8348 17f4 0196      		adiw r24,1
 8349 17f6 9093 0000 		sts (t+8)+1,r25
 8350 17fa 8093 0000 		sts t+8,r24
 8351 17fe 06C0      		rjmp .L239
 8352               	.L238:
 623:main.c        **** 							}
 624:main.c        **** 							else
 625:main.c        **** 							{
 626:main.c        **** 								t.intMonth=1;		//yes, then reset the month to January
 8354               	.LM500:
 8355 1800 81E0      		ldi r24,lo8(1)
 8356 1802 90E0      		ldi r25,hi8(1)
 8357 1804 9093 0000 		sts (t+8)+1,r25
 8358 1808 8093 0000 		sts t+8,r24
 8359               	.L239:
 627:main.c        **** 							}
 628:main.c        **** 							write_date(defTab,7,0,false);
 8361               	.LM501:
 8362 180c 20E0      		ldi r18,lo8(0)
 8363 180e 40E0      		ldi r20,lo8(0)
 8364 1810 67E0      		ldi r22,lo8(7)
 8365 1812 8AE0      		ldi r24,lo8(10)
 8366 1814 0E94 0000 		call write_date
 629:main.c        **** 						break;
 8368               	.LM502:
 8369 1818 35C0      		rjmp .L230
 8370               	.L240:
 630:main.c        **** 						case 3:		//set the day
 631:main.c        **** 							if(t.intDay<31)		//have we reached the maximum day?
 8372               	.LM503:
 8373 181a 8091 0000 		lds r24,t+6
 8374 181e 9091 0000 		lds r25,(t+6)+1
 8375 1822 8F31      		cpi r24,31
 8376 1824 9105      		cpc r25,__zero_reg__
 8377 1826 50F4      		brsh .L241
 632:main.c        **** 							{
 633:main.c        **** 								t.intDay++;		//no, then increment the day
 8379               	.LM504:
 8380 1828 8091 0000 		lds r24,t+6
 8381 182c 9091 0000 		lds r25,(t+6)+1
 8382 1830 0196      		adiw r24,1
 8383 1832 9093 0000 		sts (t+6)+1,r25
 8384 1836 8093 0000 		sts t+6,r24
 8385 183a 06C0      		rjmp .L242
 8386               	.L241:
 634:main.c        **** 							}
 635:main.c        **** 							else
 636:main.c        **** 							{
 637:main.c        **** 								t.intDay=1;		//yes, then reset the day to the start of the month
 8388               	.LM505:
 8389 183c 81E0      		ldi r24,lo8(1)
 8390 183e 90E0      		ldi r25,hi8(1)
 8391 1840 9093 0000 		sts (t+6)+1,r25
 8392 1844 8093 0000 		sts t+6,r24
 8393               	.L242:
 638:main.c        **** 							}
 639:main.c        **** 							write_date(defTab,7,0,false);
 8395               	.LM506:
 8396 1848 20E0      		ldi r18,lo8(0)
 8397 184a 40E0      		ldi r20,lo8(0)
 8398 184c 67E0      		ldi r22,lo8(7)
 8399 184e 8AE0      		ldi r24,lo8(10)
 8400 1850 0E94 0000 		call write_date
 640:main.c        **** 						break;
 8402               	.LM507:
 8403 1854 17C0      		rjmp .L230
 8404               	.L243:
 641:main.c        **** 						case 4:		//set the year
 642:main.c        **** 							if(t.intYear<999)		//have we reached the maximum year number?
 8406               	.LM508:
 8407 1856 8091 0000 		lds r24,t+10
 8408 185a 9091 0000 		lds r25,(t+10)+1
 8409 185e 33E0      		ldi r19,hi8(999)
 8410 1860 873E      		cpi r24,lo8(999)
 8411 1862 9307      		cpc r25,r19
 8412 1864 48F4      		brsh .L244
 643:main.c        **** 							{
 644:main.c        **** 								t.intYear++;		//no, then increment the year
 8414               	.LM509:
 8415 1866 8091 0000 		lds r24,t+10
 8416 186a 9091 0000 		lds r25,(t+10)+1
 8417 186e 0196      		adiw r24,1
 8418 1870 9093 0000 		sts (t+10)+1,r25
 8419 1874 8093 0000 		sts t+10,r24
 8420               	.L244:
 645:main.c        **** 							}
 646:main.c        **** 							write_date(defTab,7,0,false);
 8422               	.LM510:
 8423 1878 20E0      		ldi r18,lo8(0)
 8424 187a 40E0      		ldi r20,lo8(0)
 8425 187c 67E0      		ldi r22,lo8(7)
 8426 187e 8AE0      		ldi r24,lo8(10)
 8427 1880 0E94 0000 		call write_date
 8428               	.L230:
 647:main.c        **** 						break;
 648:main.c        **** 					}
 649:main.c        **** 					uTmrState=defDlyAfterBtnPress; //load up the blink timer for the range level number
 8430               	.LM511:
 8431 1884 86E9      		ldi r24,lo8(-106)
 8432 1886 8093 0000 		sts uTmrState,r24
 650:main.c        **** 					uBtnUpTmr=defBtnDbn;	//load up the debounce timer, so we don't immediately go back in here
 8434               	.LM512:
 8435 188a 8EE0      		ldi r24,lo8(14)
 8436 188c 8093 0000 		sts uBtnUpTmr,r24
 8437               	.L229:
 651:main.c        **** 				}
 652:main.c        **** 				//has the down button been pressed?
 653:main.c        **** 				if(bit_is_clear(defPushBtnPort,defDownBtn) && uBtnDwnTmr==0)  //is the Menu button 2 pressed?
 8439               	.LM513:
 8440 1890 8091 3900 		lds r24,57
 8441 1894 9927      		clr r25
 8442 1896 9695      		lsr r25
 8443 1898 8795      		ror r24
 8444 189a 9695      		lsr r25
 8445 189c 8795      		ror r24
 8446 189e 9695      		lsr r25
 8447 18a0 8795      		ror r24
 8448 18a2 8170      		andi r24,lo8(1)
 8449 18a4 9070      		andi r25,hi8(1)
 8450 18a6 0097      		sbiw r24,0
 8451 18a8 09F0      		breq .+2
 8452 18aa BBC0      		rjmp .L246
 8453 18ac 8091 0000 		lds r24,uBtnDwnTmr
 8454 18b0 8823      		tst r24
 8455 18b2 09F0      		breq .+2
 8456 18b4 B6C0      		rjmp .L246
 654:main.c        **** 				{
 655:main.c        **** 					switch(uTimeSetState)	//what are we going to set?
 8458               	.LM514:
 8459 18b6 8091 0000 		lds r24,uTimeSetState
 8460 18ba 282F      		mov r18,r24
 8461 18bc 3327      		clr r19
 8462 18be 2D83      		std Y+5,r18
 8463 18c0 3E83      		std Y+6,r19
 8464 18c2 8D81      		ldd r24,Y+5
 8465 18c4 9E81      		ldd r25,Y+6
 8466 18c6 8230      		cpi r24,2
 8467 18c8 9105      		cpc r25,__zero_reg__
 8468 18ca 09F4      		brne .+2
 8469 18cc 52C0      		rjmp .L254
 8470 18ce 2D81      		ldd r18,Y+5
 8471 18d0 3E81      		ldd r19,Y+6
 8472 18d2 2330      		cpi r18,3
 8473 18d4 3105      		cpc r19,__zero_reg__
 8474 18d6 54F4      		brge .L262
 8475 18d8 8D81      		ldd r24,Y+5
 8476 18da 9E81      		ldd r25,Y+6
 8477 18dc 0097      		sbiw r24,0
 8478 18de 99F0      		breq .L248
 8479 18e0 2D81      		ldd r18,Y+5
 8480 18e2 3E81      		ldd r19,Y+6
 8481 18e4 2130      		cpi r18,1
 8482 18e6 3105      		cpc r19,__zero_reg__
 8483 18e8 49F1      		breq .L251
 8484 18ea 95C0      		rjmp .L247
 8485               	.L262:
 8486 18ec 8D81      		ldd r24,Y+5
 8487 18ee 9E81      		ldd r25,Y+6
 8488 18f0 8330      		cpi r24,3
 8489 18f2 9105      		cpc r25,__zero_reg__
 8490 18f4 09F4      		brne .+2
 8491 18f6 5BC0      		rjmp .L257
 8492 18f8 2D81      		ldd r18,Y+5
 8493 18fa 3E81      		ldd r19,Y+6
 8494 18fc 2430      		cpi r18,4
 8495 18fe 3105      		cpc r19,__zero_reg__
 8496 1900 09F4      		brne .+2
 8497 1902 73C0      		rjmp .L260
 8498 1904 88C0      		rjmp .L247
 8499               	.L248:
 656:main.c        **** 					{
 657:main.c        **** 						case 0:		//set the hour
 658:main.c        **** 							if(t.intHour!=0)		//have we reached the minimum day?
 8501               	.LM515:
 8502 1906 8091 0000 		lds r24,t+4
 8503 190a 9091 0000 		lds r25,(t+4)+1
 8504 190e 0097      		sbiw r24,0
 8505 1910 51F0      		breq .L249
 659:main.c        **** 							{
 660:main.c        **** 								t.intHour--;		//no, then decrement the day
 8507               	.LM516:
 8508 1912 8091 0000 		lds r24,t+4
 8509 1916 9091 0000 		lds r25,(t+4)+1
 8510 191a 0197      		sbiw r24,1
 8511 191c 9093 0000 		sts (t+4)+1,r25
 8512 1920 8093 0000 		sts t+4,r24
 8513 1924 06C0      		rjmp .L250
 8514               	.L249:
 661:main.c        **** 							}
 662:main.c        **** 							else
 663:main.c        **** 							{
 664:main.c        **** 								t.intHour=23;		//yes, then rese the hour to the highest possible value
 8516               	.LM517:
 8517 1926 87E1      		ldi r24,lo8(23)
 8518 1928 90E0      		ldi r25,hi8(23)
 8519 192a 9093 0000 		sts (t+4)+1,r25
 8520 192e 8093 0000 		sts t+4,r24
 8521               	.L250:
 665:main.c        **** 							}
 666:main.c        **** 							ShowLargeTime(0,2);		//uStartColumn, uRow
 8523               	.LM518:
 8524 1932 62E0      		ldi r22,lo8(2)
 8525 1934 80E0      		ldi r24,lo8(0)
 8526 1936 0E94 0000 		call ShowLargeTime
 667:main.c        **** 						break;
 8528               	.LM519:
 8529 193a 6DC0      		rjmp .L247
 8530               	.L251:
 668:main.c        **** 						case 1:		//set the minute
 669:main.c        **** 							if(t.intMin!=0)		//have we reached the minimum minute?
 8532               	.LM520:
 8533 193c 8091 0000 		lds r24,t+2
 8534 1940 9091 0000 		lds r25,(t+2)+1
 8535 1944 0097      		sbiw r24,0
 8536 1946 51F0      		breq .L252
 670:main.c        **** 							{
 671:main.c        **** 								t.intMin--;		//no, then decrement the minute
 8538               	.LM521:
 8539 1948 8091 0000 		lds r24,t+2
 8540 194c 9091 0000 		lds r25,(t+2)+1
 8541 1950 0197      		sbiw r24,1
 8542 1952 9093 0000 		sts (t+2)+1,r25
 8543 1956 8093 0000 		sts t+2,r24
 8544 195a 06C0      		rjmp .L253
 8545               	.L252:
 672:main.c        **** 							}
 673:main.c        **** 							else
 674:main.c        **** 							{
 675:main.c        **** 								t.intMin=59;		//yes, then reset the minute to highest possible value
 8547               	.LM522:
 8548 195c 8BE3      		ldi r24,lo8(59)
 8549 195e 90E0      		ldi r25,hi8(59)
 8550 1960 9093 0000 		sts (t+2)+1,r25
 8551 1964 8093 0000 		sts t+2,r24
 8552               	.L253:
 676:main.c        **** 							}
 677:main.c        **** 							ShowLargeTime(0,2);		//uStartColumn, uRow
 8554               	.LM523:
 8555 1968 62E0      		ldi r22,lo8(2)
 8556 196a 80E0      		ldi r24,lo8(0)
 8557 196c 0E94 0000 		call ShowLargeTime
 678:main.c        **** 						break;
 8559               	.LM524:
 8560 1970 52C0      		rjmp .L247
 8561               	.L254:
 679:main.c        **** 						case 2:		//set the month
 680:main.c        **** 							if(t.intMonth!=1)		//have we reached the minimum month
 8563               	.LM525:
 8564 1972 8091 0000 		lds r24,t+8
 8565 1976 9091 0000 		lds r25,(t+8)+1
 8566 197a 8130      		cpi r24,1
 8567 197c 9105      		cpc r25,__zero_reg__
 8568 197e 51F0      		breq .L255
 681:main.c        **** 							{
 682:main.c        **** 								t.intMonth--;			//no, then decrement the month
 8570               	.LM526:
 8571 1980 8091 0000 		lds r24,t+8
 8572 1984 9091 0000 		lds r25,(t+8)+1
 8573 1988 0197      		sbiw r24,1
 8574 198a 9093 0000 		sts (t+8)+1,r25
 8575 198e 8093 0000 		sts t+8,r24
 8576 1992 06C0      		rjmp .L256
 8577               	.L255:
 683:main.c        **** 							}
 684:main.c        **** 							else
 685:main.c        **** 							{
 686:main.c        **** 								t.intMonth=12;		//yes, then reset the month to decmenber
 8579               	.LM527:
 8580 1994 8CE0      		ldi r24,lo8(12)
 8581 1996 90E0      		ldi r25,hi8(12)
 8582 1998 9093 0000 		sts (t+8)+1,r25
 8583 199c 8093 0000 		sts t+8,r24
 8584               	.L256:
 687:main.c        **** 							}
 688:main.c        **** 							write_date(defTab,7,0,false);
 8586               	.LM528:
 8587 19a0 20E0      		ldi r18,lo8(0)
 8588 19a2 40E0      		ldi r20,lo8(0)
 8589 19a4 67E0      		ldi r22,lo8(7)
 8590 19a6 8AE0      		ldi r24,lo8(10)
 8591 19a8 0E94 0000 		call write_date
 689:main.c        **** 						break;
 8593               	.LM529:
 8594 19ac 34C0      		rjmp .L247
 8595               	.L257:
 690:main.c        **** 						case 3:		//set the day
 691:main.c        **** 							if(t.intDay!=1)		//have we reached the minimum day?
 8597               	.LM530:
 8598 19ae 8091 0000 		lds r24,t+6
 8599 19b2 9091 0000 		lds r25,(t+6)+1
 8600 19b6 8130      		cpi r24,1
 8601 19b8 9105      		cpc r25,__zero_reg__
 8602 19ba 51F0      		breq .L258
 692:main.c        **** 							{
 693:main.c        **** 								t.intDay--;		//no, then decrement the day
 8604               	.LM531:
 8605 19bc 8091 0000 		lds r24,t+6
 8606 19c0 9091 0000 		lds r25,(t+6)+1
 8607 19c4 0197      		sbiw r24,1
 8608 19c6 9093 0000 		sts (t+6)+1,r25
 8609 19ca 8093 0000 		sts t+6,r24
 8610 19ce 06C0      		rjmp .L259
 8611               	.L258:
 694:main.c        **** 							}
 695:main.c        **** 							else
 696:main.c        **** 							{
 697:main.c        **** 								t.intDay=31;		//yes, then reset the day to the highest possible value
 8613               	.LM532:
 8614 19d0 8FE1      		ldi r24,lo8(31)
 8615 19d2 90E0      		ldi r25,hi8(31)
 8616 19d4 9093 0000 		sts (t+6)+1,r25
 8617 19d8 8093 0000 		sts t+6,r24
 8618               	.L259:
 698:main.c        **** 							}
 699:main.c        **** 							write_date(defTab,7,0,false);
 8620               	.LM533:
 8621 19dc 20E0      		ldi r18,lo8(0)
 8622 19de 40E0      		ldi r20,lo8(0)
 8623 19e0 67E0      		ldi r22,lo8(7)
 8624 19e2 8AE0      		ldi r24,lo8(10)
 8625 19e4 0E94 0000 		call write_date
 700:main.c        **** 						break;
 8627               	.LM534:
 8628 19e8 16C0      		rjmp .L247
 8629               	.L260:
 701:main.c        **** 						case 4:		//set the year
 702:main.c        **** 							if(t.intYear>1)		//have we reached before 2005?  (intYear only holds the last 3 digits of th
 8631               	.LM535:
 8632 19ea 8091 0000 		lds r24,t+10
 8633 19ee 9091 0000 		lds r25,(t+10)+1
 8634 19f2 8230      		cpi r24,2
 8635 19f4 9105      		cpc r25,__zero_reg__
 8636 19f6 48F0      		brlo .L261
 703:main.c        **** 							{
 704:main.c        **** 								t.intYear--;		//no, then decrement the year
 8638               	.LM536:
 8639 19f8 8091 0000 		lds r24,t+10
 8640 19fc 9091 0000 		lds r25,(t+10)+1
 8641 1a00 0197      		sbiw r24,1
 8642 1a02 9093 0000 		sts (t+10)+1,r25
 8643 1a06 8093 0000 		sts t+10,r24
 8644               	.L261:
 705:main.c        **** 							}
 706:main.c        **** 							write_date(defTab,7,0,false);
 8646               	.LM537:
 8647 1a0a 20E0      		ldi r18,lo8(0)
 8648 1a0c 40E0      		ldi r20,lo8(0)
 8649 1a0e 67E0      		ldi r22,lo8(7)
 8650 1a10 8AE0      		ldi r24,lo8(10)
 8651 1a12 0E94 0000 		call write_date
 8652               	.L247:
 707:main.c        **** 						break;
 708:main.c        **** 					}
 709:main.c        **** 					uTmrState=defDlyAfterBtnPress; //load up the blink timer for the range level number
 8654               	.LM538:
 8655 1a16 86E9      		ldi r24,lo8(-106)
 8656 1a18 8093 0000 		sts uTmrState,r24
 710:main.c        **** 					uBtnDwnTmr=defBtnDbn;	//load up the debounce timer, so we don't immediately go back in here
 8658               	.LM539:
 8659 1a1c 8EE0      		ldi r24,lo8(14)
 8660 1a1e 8093 0000 		sts uBtnDwnTmr,r24
 8661               	.L246:
 711:main.c        **** 				}
 712:main.c        **** 				//has the enter button been pressed?
 713:main.c        **** 				if(bit_is_clear(defPushBtnPort,defEnterBtn) && uBtnEnterTmr==0)  //is the Menu button 2 pressed
 8663               	.LM540:
 8664 1a22 8091 3900 		lds r24,57
 8665 1a26 9927      		clr r25
 8666 1a28 9695      		lsr r25
 8667 1a2a 8795      		ror r24
 8668 1a2c 8170      		andi r24,lo8(1)
 8669 1a2e 9070      		andi r25,hi8(1)
 8670 1a30 0097      		sbiw r24,0
 8671 1a32 21F5      		brne .L263
 8672 1a34 8091 0000 		lds r24,uBtnEnterTmr
 8673 1a38 8823      		tst r24
 8674 1a3a 01F5      		brne .L263
 714:main.c        **** 				{		//exit out of the set time
 715:main.c        **** 					uTimeSetState++;
 8676               	.LM541:
 8677 1a3c 8091 0000 		lds r24,uTimeSetState
 8678 1a40 8F5F      		subi r24,lo8(-(1))
 8679 1a42 8093 0000 		sts uTimeSetState,r24
 716:main.c        **** 					if (uTimeSetState == 2)	//refresh the time when we go to change the month
 8681               	.LM542:
 8682 1a46 8091 0000 		lds r24,uTimeSetState
 8683 1a4a 8230      		cpi r24,lo8(2)
 8684 1a4c 21F4      		brne .L264
 717:main.c        **** 					{
 718:main.c        **** 						ShowLargeTime(0,2);		//uStartColumn, uRow
 8686               	.LM543:
 8687 1a4e 62E0      		ldi r22,lo8(2)
 8688 1a50 80E0      		ldi r24,lo8(0)
 8689 1a52 0E94 0000 		call ShowLargeTime
 8690               	.L264:
 719:main.c        **** 					}
 720:main.c        **** 					uTmrState=defSettingBlinkOff+1;		//as soon as the the enter button is pressed, the next thing 
 8692               	.LM544:
 8693 1a56 81E5      		ldi r24,lo8(81)
 8694 1a58 8093 0000 		sts uTmrState,r24
 721:main.c        **** 					if(uTimeSetState > 4)
 8696               	.LM545:
 8697 1a5c 8091 0000 		lds r24,uTimeSetState
 8698 1a60 8530      		cpi r24,lo8(5)
 8699 1a62 48F0      		brlo .L265
 722:main.c        **** 					{
 723:main.c        **** 						uState=50;	//go back to the main menu state
 8701               	.LM546:
 8702 1a64 82E3      		ldi r24,lo8(50)
 8703 1a66 8093 0000 		sts uState,r24
 724:main.c        **** 						uSelectedLine=defState50HighlightMax;	//set the highlighted line for the next state
 8705               	.LM547:
 8706 1a6a 87E0      		ldi r24,lo8(7)
 8707 1a6c 8093 0000 		sts uSelectedLine,r24
 725:main.c        **** 						uTmrState=defStateTm+1;       //reload the state timer to stay in this state
 8709               	.LM548:
 8710 1a70 89EC      		ldi r24,lo8(-55)
 8711 1a72 8093 0000 		sts uTmrState,r24
 8712               	.L265:
 726:main.c        **** 					}
 727:main.c        **** 					uBtnEnterTmr=defBtnDbn;   //load up the debounce timer, so we don't immediately go back in her
 8714               	.LM549:
 8715 1a76 8EE0      		ldi r24,lo8(14)
 8716 1a78 8093 0000 		sts uBtnEnterTmr,r24
 8717               	.L263:
 728:main.c        **** 				}
 729:main.c        **** 				uTmrState--;	//count down to a blink for the range number
 8719               	.LM550:
 8720 1a7c 8091 0000 		lds r24,uTmrState
 8721 1a80 8150      		subi r24,lo8(-(-1))
 8722 1a82 8093 0000 		sts uTmrState,r24
 730:main.c        **** 				if(uTmrState==0)
 8724               	.LM551:
 8725 1a86 8091 0000 		lds r24,uTmrState
 8726 1a8a 8823      		tst r24
 8727 1a8c 19F4      		brne .L266
 731:main.c        **** 				{
 732:main.c        **** 					uTmrState=defSettingBlinkOff;	//reset the range blinking number
 8729               	.LM552:
 8730 1a8e 80E5      		ldi r24,lo8(80)
 8731 1a90 8093 0000 		sts uTmrState,r24
 8732               	.L266:
 733:main.c        **** 				}
 734:main.c        **** 				if(uTmrState==defSettingBlinkOff)	//this code turns off the character that is blinking
 8734               	.LM553:
 8735 1a94 8091 0000 		lds r24,uTmrState
 8736 1a98 8035      		cpi r24,lo8(80)
 8737 1a9a 09F0      		breq .+2
 8738 1a9c 4BC0      		rjmp .L267
 735:main.c        **** 				{
 736:main.c        **** 					switch(uTimeSetState)	//what are we going to set?
 8740               	.LM554:
 8741 1a9e 8091 0000 		lds r24,uTimeSetState
 8742 1aa2 282F      		mov r18,r24
 8743 1aa4 3327      		clr r19
 8744 1aa6 2F83      		std Y+7,r18
 8745 1aa8 3887      		std Y+8,r19
 8746 1aaa 8F81      		ldd r24,Y+7
 8747 1aac 9885      		ldd r25,Y+8
 8748 1aae 8230      		cpi r24,2
 8749 1ab0 9105      		cpc r25,__zero_reg__
 8750 1ab2 61F1      		breq .L271
 8751 1ab4 2F81      		ldd r18,Y+7
 8752 1ab6 3885      		ldd r19,Y+8
 8753 1ab8 2330      		cpi r18,3
 8754 1aba 3105      		cpc r19,__zero_reg__
 8755 1abc 54F4      		brge .L274
 8756 1abe 8F81      		ldd r24,Y+7
 8757 1ac0 9885      		ldd r25,Y+8
 8758 1ac2 0097      		sbiw r24,0
 8759 1ac4 89F0      		breq .L269
 8760 1ac6 2F81      		ldd r18,Y+7
 8761 1ac8 3885      		ldd r19,Y+8
 8762 1aca 2130      		cpi r18,1
 8763 1acc 3105      		cpc r19,__zero_reg__
 8764 1ace A9F0      		breq .L270
 8765 1ad0 31C0      		rjmp .L267
 8766               	.L274:
 8767 1ad2 8F81      		ldd r24,Y+7
 8768 1ad4 9885      		ldd r25,Y+8
 8769 1ad6 8330      		cpi r24,3
 8770 1ad8 9105      		cpc r25,__zero_reg__
 8771 1ada F9F0      		breq .L272
 8772 1adc 2F81      		ldd r18,Y+7
 8773 1ade 3885      		ldd r19,Y+8
 8774 1ae0 2430      		cpi r18,4
 8775 1ae2 3105      		cpc r19,__zero_reg__
 8776 1ae4 09F1      		breq .L273
 8777 1ae6 26C0      		rjmp .L267
 8778               	.L269:
 737:main.c        **** 					{
 738:main.c        **** 						case 0:		//set the hour
 739:main.c        **** 							BigDigits(2,0,0,0,false);
 8780               	.LM555:
 8781 1ae8 00E0      		ldi r16,lo8(0)
 8782 1aea 20E0      		ldi r18,lo8(0)
 8783 1aec 40E0      		ldi r20,lo8(0)
 8784 1aee 50E0      		ldi r21,hi8(0)
 8785 1af0 60E0      		ldi r22,lo8(0)
 8786 1af2 82E0      		ldi r24,lo8(2)
 8787 1af4 0E94 0000 		call BigDigits
 740:main.c        **** 						break;
 8789               	.LM556:
 8790 1af8 1DC0      		rjmp .L267
 8791               	.L270:
 741:main.c        **** 						case 1:		//set the minute
 742:main.c        **** 							BigDigits(2,61,0,0,false);		//the column was 60
 8793               	.LM557:
 8794 1afa 00E0      		ldi r16,lo8(0)
 8795 1afc 20E0      		ldi r18,lo8(0)
 8796 1afe 40E0      		ldi r20,lo8(0)
 8797 1b00 50E0      		ldi r21,hi8(0)
 8798 1b02 6DE3      		ldi r22,lo8(61)
 8799 1b04 82E0      		ldi r24,lo8(2)
 8800 1b06 0E94 0000 		call BigDigits
 743:main.c        **** 						break;
 8802               	.LM558:
 8803 1b0a 14C0      		rjmp .L267
 8804               	.L271:
 744:main.c        **** 						case 2:		//set the month
 745:main.c        **** 							write_date(defTab,7,1,false);
 8806               	.LM559:
 8807 1b0c 20E0      		ldi r18,lo8(0)
 8808 1b0e 41E0      		ldi r20,lo8(1)
 8809 1b10 67E0      		ldi r22,lo8(7)
 8810 1b12 8AE0      		ldi r24,lo8(10)
 8811 1b14 0E94 0000 		call write_date
 746:main.c        **** 						break;
 8813               	.LM560:
 8814 1b18 0DC0      		rjmp .L267
 8815               	.L272:
 747:main.c        **** 						case 3:		//set the day
 748:main.c        **** 							write_date(defTab,7,2,false);
 8817               	.LM561:
 8818 1b1a 20E0      		ldi r18,lo8(0)
 8819 1b1c 42E0      		ldi r20,lo8(2)
 8820 1b1e 67E0      		ldi r22,lo8(7)
 8821 1b20 8AE0      		ldi r24,lo8(10)
 8822 1b22 0E94 0000 		call write_date
 749:main.c        **** 						break;
 8824               	.LM562:
 8825 1b26 06C0      		rjmp .L267
 8826               	.L273:
 750:main.c        **** 						case 4:		//set the year
 751:main.c        **** 							write_date(defTab,7,3,false);
 8828               	.LM563:
 8829 1b28 20E0      		ldi r18,lo8(0)
 8830 1b2a 43E0      		ldi r20,lo8(3)
 8831 1b2c 67E0      		ldi r22,lo8(7)
 8832 1b2e 8AE0      		ldi r24,lo8(10)
 8833 1b30 0E94 0000 		call write_date
 8834               	.L267:
 752:main.c        **** 						break;
 753:main.c        **** 					}
 754:main.c        **** 				}
 755:main.c        **** 				if(uTmrState==defSettingBlinkOn)	//this code turns on the character that is blinking
 8836               	.LM564:
 8837 1b34 8091 0000 		lds r24,uTmrState
 8838 1b38 8832      		cpi r24,lo8(40)
 8839 1b3a 09F0      		breq .+2
 8840 1b3c E3C3      		rjmp .L168
 756:main.c        **** 				{
 757:main.c        **** 					switch(uTimeSetState)	//what are we going to set?
 8842               	.LM565:
 8843 1b3e 8091 0000 		lds r24,uTimeSetState
 8844 1b42 282F      		mov r18,r24
 8845 1b44 3327      		clr r19
 8846 1b46 2987      		std Y+9,r18
 8847 1b48 3A87      		std Y+10,r19
 8848 1b4a 8985      		ldd r24,Y+9
 8849 1b4c 9A85      		ldd r25,Y+10
 8850 1b4e 8230      		cpi r24,2
 8851 1b50 9105      		cpc r25,__zero_reg__
 8852 1b52 51F1      		breq .L279
 8853 1b54 2985      		ldd r18,Y+9
 8854 1b56 3A85      		ldd r19,Y+10
 8855 1b58 2330      		cpi r18,3
 8856 1b5a 3105      		cpc r19,__zero_reg__
 8857 1b5c 54F4      		brge .L282
 8858 1b5e 8985      		ldd r24,Y+9
 8859 1b60 9A85      		ldd r25,Y+10
 8860 1b62 0097      		sbiw r24,0
 8861 1b64 89F0      		breq .L277
 8862 1b66 2985      		ldd r18,Y+9
 8863 1b68 3A85      		ldd r19,Y+10
 8864 1b6a 2130      		cpi r18,1
 8865 1b6c 3105      		cpc r19,__zero_reg__
 8866 1b6e B9F0      		breq .L278
 8867 1b70 C9C3      		rjmp .L168
 8868               	.L282:
 8869 1b72 8985      		ldd r24,Y+9
 8870 1b74 9A85      		ldd r25,Y+10
 8871 1b76 8330      		cpi r24,3
 8872 1b78 9105      		cpc r25,__zero_reg__
 8873 1b7a E9F0      		breq .L280
 8874 1b7c 2985      		ldd r18,Y+9
 8875 1b7e 3A85      		ldd r19,Y+10
 8876 1b80 2430      		cpi r18,4
 8877 1b82 3105      		cpc r19,__zero_reg__
 8878 1b84 F9F0      		breq .L281
 8879 1b86 BEC3      		rjmp .L168
 8880               	.L277:
 758:main.c        **** 					{
 759:main.c        **** 						case 0:		//set the hour
 760:main.c        **** 							ShowLargeTime(0,2);		//uStartColumn, uRow
 8882               	.LM566:
 8883 1b88 62E0      		ldi r22,lo8(2)
 8884 1b8a 80E0      		ldi r24,lo8(0)
 8885 1b8c 0E94 0000 		call ShowLargeTime
 761:main.c        **** 							write_date(defTab,7,0,false);
 8887               	.LM567:
 8888 1b90 20E0      		ldi r18,lo8(0)
 8889 1b92 40E0      		ldi r20,lo8(0)
 8890 1b94 67E0      		ldi r22,lo8(7)
 8891 1b96 8AE0      		ldi r24,lo8(10)
 8892 1b98 0E94 0000 		call write_date
 762:main.c        **** 						break;
 8894               	.LM568:
 8895 1b9c B3C3      		rjmp .L168
 8896               	.L278:
 763:main.c        **** 						case 1:		//set the minute
 764:main.c        **** 							ShowLargeTime(0,2);		//uStartColumn, uRow
 8898               	.LM569:
 8899 1b9e 62E0      		ldi r22,lo8(2)
 8900 1ba0 80E0      		ldi r24,lo8(0)
 8901 1ba2 0E94 0000 		call ShowLargeTime
 765:main.c        **** 						break;
 8903               	.LM570:
 8904 1ba6 AEC3      		rjmp .L168
 8905               	.L279:
 766:main.c        **** 						case 2:		//set the month
 767:main.c        **** 							write_date(defTab,7,0,false);
 8907               	.LM571:
 8908 1ba8 20E0      		ldi r18,lo8(0)
 8909 1baa 40E0      		ldi r20,lo8(0)
 8910 1bac 67E0      		ldi r22,lo8(7)
 8911 1bae 8AE0      		ldi r24,lo8(10)
 8912 1bb0 0E94 0000 		call write_date
 768:main.c        **** 						break;
 8914               	.LM572:
 8915 1bb4 A7C3      		rjmp .L168
 8916               	.L280:
 769:main.c        **** 						case 3:		//set the day
 770:main.c        **** 							write_date(defTab,7,0,false);
 8918               	.LM573:
 8919 1bb6 20E0      		ldi r18,lo8(0)
 8920 1bb8 40E0      		ldi r20,lo8(0)
 8921 1bba 67E0      		ldi r22,lo8(7)
 8922 1bbc 8AE0      		ldi r24,lo8(10)
 8923 1bbe 0E94 0000 		call write_date
 771:main.c        **** 						break;
 8925               	.LM574:
 8926 1bc2 A0C3      		rjmp .L168
 8927               	.L281:
 772:main.c        **** 						case 4:		//set the year
 773:main.c        **** 							write_date(defTab,7,0,false);
 8929               	.LM575:
 8930 1bc4 20E0      		ldi r18,lo8(0)
 8931 1bc6 40E0      		ldi r20,lo8(0)
 8932 1bc8 67E0      		ldi r22,lo8(7)
 8933 1bca 8AE0      		ldi r24,lo8(10)
 8934 1bcc 0E94 0000 		call write_date
 774:main.c        **** 						break;
 775:main.c        **** 					}
 776:main.c        **** 				}				
 777:main.c        **** 			break;
 8936               	.LM576:
 8937 1bd0 99C3      		rjmp .L168
 8938               	.L283:
 778:main.c        **** 
 779:main.c        **** 			//uTimeSetState = 0 set the hour
 780:main.c        **** 			//uTimeSetState = 1 set the minute
 781:main.c        **** 			//intAlarmMin
 782:main.c        **** 			//intAlarmHour
 783:main.c        **** 			case 61:	//We are going to set the alarm clock time
 784:main.c        **** 				//has the up button been pressed?
 785:main.c        **** 				if(bit_is_clear(defPushBtnPort,defUpBtn) && uBtnUpTmr==0)  //is the Menu button 1 pressed?
 8940               	.LM577:
 8941 1bd2 8091 3900 		lds r24,57
 8942 1bd6 9927      		clr r25
 8943 1bd8 9695      		lsr r25
 8944 1bda 8795      		ror r24
 8945 1bdc 9695      		lsr r25
 8946 1bde 8795      		ror r24
 8947 1be0 8170      		andi r24,lo8(1)
 8948 1be2 9070      		andi r25,hi8(1)
 8949 1be4 0097      		sbiw r24,0
 8950 1be6 09F0      		breq .+2
 8951 1be8 4EC0      		rjmp .L284
 8952 1bea 8091 0000 		lds r24,uBtnUpTmr
 8953 1bee 8823      		tst r24
 8954 1bf0 09F0      		breq .+2
 8955 1bf2 49C0      		rjmp .L284
 786:main.c        **** 				{
 787:main.c        **** 					switch(uTimeSetState)	//what are we going to set?
 8957               	.LM578:
 8958 1bf4 8091 0000 		lds r24,uTimeSetState
 8959 1bf8 282F      		mov r18,r24
 8960 1bfa 3327      		clr r19
 8961 1bfc 2B87      		std Y+11,r18
 8962 1bfe 3C87      		std Y+12,r19
 8963 1c00 8B85      		ldd r24,Y+11
 8964 1c02 9C85      		ldd r25,Y+12
 8965 1c04 0097      		sbiw r24,0
 8966 1c06 31F0      		breq .L286
 8967 1c08 2B85      		ldd r18,Y+11
 8968 1c0a 3C85      		ldd r19,Y+12
 8969 1c0c 2130      		cpi r18,1
 8970 1c0e 3105      		cpc r19,__zero_reg__
 8971 1c10 D9F0      		breq .L289
 8972 1c12 33C0      		rjmp .L285
 8973               	.L286:
 788:main.c        **** 					{
 789:main.c        **** 						case 0:		//set the hour
 790:main.c        **** 							if(intAlarmHour<23)		//have we reached the maximum hour count?
 8975               	.LM579:
 8976 1c14 8091 0000 		lds r24,intAlarmHour
 8977 1c18 9091 0000 		lds r25,(intAlarmHour)+1
 8978 1c1c 8731      		cpi r24,23
 8979 1c1e 9105      		cpc r25,__zero_reg__
 8980 1c20 50F4      		brsh .L287
 791:main.c        **** 							{
 792:main.c        **** 								intAlarmHour++;		//no, increment the hour
 8982               	.LM580:
 8983 1c22 8091 0000 		lds r24,intAlarmHour
 8984 1c26 9091 0000 		lds r25,(intAlarmHour)+1
 8985 1c2a 0196      		adiw r24,1
 8986 1c2c 9093 0000 		sts (intAlarmHour)+1,r25
 8987 1c30 8093 0000 		sts intAlarmHour,r24
 8988 1c34 04C0      		rjmp .L288
 8989               	.L287:
 793:main.c        **** 							}
 794:main.c        **** 							else	
 795:main.c        **** 							{
 796:main.c        **** 								intAlarmHour=0;		//reset the hour count since we have reached the 23rd hour
 8991               	.LM581:
 8992 1c36 1092 0000 		sts (intAlarmHour)+1,__zero_reg__
 8993 1c3a 1092 0000 		sts intAlarmHour,__zero_reg__
 8994               	.L288:
 797:main.c        **** 							}
 798:main.c        **** 							ShowLargeAlarmTime(0,2);		//uStartColumn, uRow
 8996               	.LM582:
 8997 1c3e 62E0      		ldi r22,lo8(2)
 8998 1c40 80E0      		ldi r24,lo8(0)
 8999 1c42 0E94 0000 		call ShowLargeAlarmTime
 799:main.c        **** 
 800:main.c        **** 						break;
 9001               	.LM583:
 9002 1c46 19C0      		rjmp .L285
 9003               	.L289:
 801:main.c        **** 						case 1:		//set the minute
 802:main.c        **** 							if(intAlarmMin<59)		//have we reached the maximum minute count?
 9005               	.LM584:
 9006 1c48 8091 0000 		lds r24,intAlarmMin
 9007 1c4c 9091 0000 		lds r25,(intAlarmMin)+1
 9008 1c50 8B33      		cpi r24,59
 9009 1c52 9105      		cpc r25,__zero_reg__
 9010 1c54 50F4      		brsh .L290
 803:main.c        **** 							{
 804:main.c        **** 								intAlarmMin++;		//no, then increment the minute
 9012               	.LM585:
 9013 1c56 8091 0000 		lds r24,intAlarmMin
 9014 1c5a 9091 0000 		lds r25,(intAlarmMin)+1
 9015 1c5e 0196      		adiw r24,1
 9016 1c60 9093 0000 		sts (intAlarmMin)+1,r25
 9017 1c64 8093 0000 		sts intAlarmMin,r24
 9018 1c68 04C0      		rjmp .L291
 9019               	.L290:
 805:main.c        **** 							}
 806:main.c        **** 							else		
 807:main.c        **** 							{
 808:main.c        **** 								intAlarmMin=0;		//reset the hour count since we have reached the 59th minute
 9021               	.LM586:
 9022 1c6a 1092 0000 		sts (intAlarmMin)+1,__zero_reg__
 9023 1c6e 1092 0000 		sts intAlarmMin,__zero_reg__
 9024               	.L291:
 809:main.c        **** 							}
 810:main.c        **** 							ShowLargeAlarmTime(0,2);		//uStartColumn, uRow
 9026               	.LM587:
 9027 1c72 62E0      		ldi r22,lo8(2)
 9028 1c74 80E0      		ldi r24,lo8(0)
 9029 1c76 0E94 0000 		call ShowLargeAlarmTime
 9030               	.L285:
 811:main.c        **** 						break;
 812:main.c        **** 					}
 813:main.c        **** 					uTmrState=defDlyAfterBtnPress; //load up the blink timer for the range level number
 9032               	.LM588:
 9033 1c7a 86E9      		ldi r24,lo8(-106)
 9034 1c7c 8093 0000 		sts uTmrState,r24
 814:main.c        **** 					uBtnUpTmr=defBtnDbn;	//load up the debounce timer, so we don't immediately go back in here
 9036               	.LM589:
 9037 1c80 8EE0      		ldi r24,lo8(14)
 9038 1c82 8093 0000 		sts uBtnUpTmr,r24
 9039               	.L284:
 815:main.c        **** 				}
 816:main.c        **** 				//has the down button been pressed?
 817:main.c        **** 				if(bit_is_clear(defPushBtnPort,defDownBtn) && uBtnDwnTmr==0)  //is the Menu button 2 pressed?
 9041               	.LM590:
 9042 1c86 8091 3900 		lds r24,57
 9043 1c8a 9927      		clr r25
 9044 1c8c 9695      		lsr r25
 9045 1c8e 8795      		ror r24
 9046 1c90 9695      		lsr r25
 9047 1c92 8795      		ror r24
 9048 1c94 9695      		lsr r25
 9049 1c96 8795      		ror r24
 9050 1c98 8170      		andi r24,lo8(1)
 9051 1c9a 9070      		andi r25,hi8(1)
 9052 1c9c 0097      		sbiw r24,0
 9053 1c9e 09F0      		breq .+2
 9054 1ca0 50C0      		rjmp .L292
 9055 1ca2 8091 0000 		lds r24,uBtnDwnTmr
 9056 1ca6 8823      		tst r24
 9057 1ca8 09F0      		breq .+2
 9058 1caa 4BC0      		rjmp .L292
 818:main.c        **** 				{
 819:main.c        **** 					switch(uTimeSetState)	//what are we going to set?
 9060               	.LM591:
 9061 1cac 8091 0000 		lds r24,uTimeSetState
 9062 1cb0 282F      		mov r18,r24
 9063 1cb2 3327      		clr r19
 9064 1cb4 2D87      		std Y+13,r18
 9065 1cb6 3E87      		std Y+14,r19
 9066 1cb8 8D85      		ldd r24,Y+13
 9067 1cba 9E85      		ldd r25,Y+14
 9068 1cbc 0097      		sbiw r24,0
 9069 1cbe 31F0      		breq .L294
 9070 1cc0 2D85      		ldd r18,Y+13
 9071 1cc2 3E85      		ldd r19,Y+14
 9072 1cc4 2130      		cpi r18,1
 9073 1cc6 3105      		cpc r19,__zero_reg__
 9074 1cc8 E1F0      		breq .L297
 9075 1cca 35C0      		rjmp .L293
 9076               	.L294:
 820:main.c        **** 					{
 821:main.c        **** 						case 0:		//set the hour
 822:main.c        **** 							if(intAlarmHour!=0)		//have we reached the minimum day?
 9078               	.LM592:
 9079 1ccc 8091 0000 		lds r24,intAlarmHour
 9080 1cd0 9091 0000 		lds r25,(intAlarmHour)+1
 9081 1cd4 0097      		sbiw r24,0
 9082 1cd6 51F0      		breq .L295
 823:main.c        **** 							{
 824:main.c        **** 								intAlarmHour--;		//no, then decrement the day
 9084               	.LM593:
 9085 1cd8 8091 0000 		lds r24,intAlarmHour
 9086 1cdc 9091 0000 		lds r25,(intAlarmHour)+1
 9087 1ce0 0197      		sbiw r24,1
 9088 1ce2 9093 0000 		sts (intAlarmHour)+1,r25
 9089 1ce6 8093 0000 		sts intAlarmHour,r24
 9090 1cea 06C0      		rjmp .L296
 9091               	.L295:
 825:main.c        **** 							}
 826:main.c        **** 							else
 827:main.c        **** 							{
 828:main.c        **** 								intAlarmHour=23;		//yes, then rese the hour to the highest possible value
 9093               	.LM594:
 9094 1cec 87E1      		ldi r24,lo8(23)
 9095 1cee 90E0      		ldi r25,hi8(23)
 9096 1cf0 9093 0000 		sts (intAlarmHour)+1,r25
 9097 1cf4 8093 0000 		sts intAlarmHour,r24
 9098               	.L296:
 829:main.c        **** 							}
 830:main.c        **** 							ShowLargeAlarmTime(0,2);		//uStartColumn, uRow
 9100               	.LM595:
 9101 1cf8 62E0      		ldi r22,lo8(2)
 9102 1cfa 80E0      		ldi r24,lo8(0)
 9103 1cfc 0E94 0000 		call ShowLargeAlarmTime
 831:main.c        **** 						break;
 9105               	.LM596:
 9106 1d00 1AC0      		rjmp .L293
 9107               	.L297:
 832:main.c        **** 						case 1:		//set the minute
 833:main.c        **** 							if(intAlarmMin!=0)		//have we reached the minimum minute?
 9109               	.LM597:
 9110 1d02 8091 0000 		lds r24,intAlarmMin
 9111 1d06 9091 0000 		lds r25,(intAlarmMin)+1
 9112 1d0a 0097      		sbiw r24,0
 9113 1d0c 51F0      		breq .L298
 834:main.c        **** 							{
 835:main.c        **** 								intAlarmMin--;		//no, then decrement the minute
 9115               	.LM598:
 9116 1d0e 8091 0000 		lds r24,intAlarmMin
 9117 1d12 9091 0000 		lds r25,(intAlarmMin)+1
 9118 1d16 0197      		sbiw r24,1
 9119 1d18 9093 0000 		sts (intAlarmMin)+1,r25
 9120 1d1c 8093 0000 		sts intAlarmMin,r24
 9121 1d20 06C0      		rjmp .L299
 9122               	.L298:
 836:main.c        **** 							}
 837:main.c        **** 							else
 838:main.c        **** 							{
 839:main.c        **** 								intAlarmMin=59;		//yes, then reset the minute to highest possible value
 9124               	.LM599:
 9125 1d22 8BE3      		ldi r24,lo8(59)
 9126 1d24 90E0      		ldi r25,hi8(59)
 9127 1d26 9093 0000 		sts (intAlarmMin)+1,r25
 9128 1d2a 8093 0000 		sts intAlarmMin,r24
 9129               	.L299:
 840:main.c        **** 							}
 841:main.c        **** 							ShowLargeAlarmTime(0,2);		//uStartColumn, uRow
 9131               	.LM600:
 9132 1d2e 62E0      		ldi r22,lo8(2)
 9133 1d30 80E0      		ldi r24,lo8(0)
 9134 1d32 0E94 0000 		call ShowLargeAlarmTime
 9135               	.L293:
 842:main.c        **** 						break;
 843:main.c        **** 					}
 844:main.c        **** 					uTmrState=defDlyAfterBtnPress; //load up the blink timer for the range level number
 9137               	.LM601:
 9138 1d36 86E9      		ldi r24,lo8(-106)
 9139 1d38 8093 0000 		sts uTmrState,r24
 845:main.c        **** 					uBtnDwnTmr=defBtnDbn;	//load up the debounce timer, so we don't immediately go back in here
 9141               	.LM602:
 9142 1d3c 8EE0      		ldi r24,lo8(14)
 9143 1d3e 8093 0000 		sts uBtnDwnTmr,r24
 9144               	.L292:
 846:main.c        **** 				}
 847:main.c        **** 				//has the enter button been pressed?
 848:main.c        **** 				if(bit_is_clear(defPushBtnPort,defEnterBtn) && uBtnEnterTmr==0)  //is the Menu button 2 pressed
 9146               	.LM603:
 9147 1d42 8091 3900 		lds r24,57
 9148 1d46 9927      		clr r25
 9149 1d48 9695      		lsr r25
 9150 1d4a 8795      		ror r24
 9151 1d4c 8170      		andi r24,lo8(1)
 9152 1d4e 9070      		andi r25,hi8(1)
 9153 1d50 0097      		sbiw r24,0
 9154 1d52 61F5      		brne .L300
 9155 1d54 8091 0000 		lds r24,uBtnEnterTmr
 9156 1d58 8823      		tst r24
 9157 1d5a 41F5      		brne .L300
 849:main.c        **** 				{		//exit out of the set time
 850:main.c        **** 					uTimeSetState++;
 9159               	.LM604:
 9160 1d5c 8091 0000 		lds r24,uTimeSetState
 9161 1d60 8F5F      		subi r24,lo8(-(1))
 9162 1d62 8093 0000 		sts uTimeSetState,r24
 851:main.c        **** 					uTmrState=defSettingBlinkOff+1;		//as soon as the the enter button is pressed, the next thing 
 9164               	.LM605:
 9165 1d66 81E5      		ldi r24,lo8(81)
 9166 1d68 8093 0000 		sts uTmrState,r24
 852:main.c        **** 					if(uTimeSetState > 1)
 9168               	.LM606:
 9169 1d6c 8091 0000 		lds r24,uTimeSetState
 9170 1d70 8230      		cpi r24,lo8(2)
 9171 1d72 C8F0      		brlo .L301
 853:main.c        **** 					{
 854:main.c        **** 						eeprom_write_word((uint16_t*)&EEHour,intAlarmHour);	//store the alarm hour in EEPROM when the
 9173               	.LM607:
 9174 1d74 6091 0000 		lds r22,intAlarmHour
 9175 1d78 7091 0000 		lds r23,(intAlarmHour)+1
 9176 1d7c 80E0      		ldi r24,lo8(EEHour)
 9177 1d7e 90E0      		ldi r25,hi8(EEHour)
 9178 1d80 0E94 0000 		call eeprom_write_word
 855:main.c        **** 						eeprom_write_word((uint16_t*)&EEMinute,intAlarmMin);	//store the alarm minute in EEPROM when 
 9180               	.LM608:
 9181 1d84 6091 0000 		lds r22,intAlarmMin
 9182 1d88 7091 0000 		lds r23,(intAlarmMin)+1
 9183 1d8c 80E0      		ldi r24,lo8(EEMinute)
 9184 1d8e 90E0      		ldi r25,hi8(EEMinute)
 9185 1d90 0E94 0000 		call eeprom_write_word
 856:main.c        **** 						uState=50;	//go back to the main menu state
 9187               	.LM609:
 9188 1d94 82E3      		ldi r24,lo8(50)
 9189 1d96 8093 0000 		sts uState,r24
 857:main.c        **** 						uSelectedLine=defState50HighlightMax;	//set the highlighted line for the next state
 9191               	.LM610:
 9192 1d9a 87E0      		ldi r24,lo8(7)
 9193 1d9c 8093 0000 		sts uSelectedLine,r24
 858:main.c        **** 						uTmrState=defStateTm+1;       //reload the state timer to stay in this state
 9195               	.LM611:
 9196 1da0 89EC      		ldi r24,lo8(-55)
 9197 1da2 8093 0000 		sts uTmrState,r24
 9198               	.L301:
 859:main.c        **** 					}
 860:main.c        **** 					uBtnEnterTmr=defBtnDbn;   //load up the debounce timer, so we don't immediately go back in her
 9200               	.LM612:
 9201 1da6 8EE0      		ldi r24,lo8(14)
 9202 1da8 8093 0000 		sts uBtnEnterTmr,r24
 9203               	.L300:
 861:main.c        **** 				}
 862:main.c        **** 				uTmrState--;	//count down to a blink for the range number
 9205               	.LM613:
 9206 1dac 8091 0000 		lds r24,uTmrState
 9207 1db0 8150      		subi r24,lo8(-(-1))
 9208 1db2 8093 0000 		sts uTmrState,r24
 863:main.c        **** 				if(uTmrState==0)
 9210               	.LM614:
 9211 1db6 8091 0000 		lds r24,uTmrState
 9212 1dba 8823      		tst r24
 9213 1dbc 19F4      		brne .L302
 864:main.c        **** 				{
 865:main.c        **** 					uTmrState=defSettingBlinkOff;	//reset the range blinking number
 9215               	.LM615:
 9216 1dbe 80E5      		ldi r24,lo8(80)
 9217 1dc0 8093 0000 		sts uTmrState,r24
 9218               	.L302:
 866:main.c        **** 				}
 867:main.c        **** 				if(uTmrState==defSettingBlinkOff)	//this code turns off the character that is blinking
 9220               	.LM616:
 9221 1dc4 8091 0000 		lds r24,uTmrState
 9222 1dc8 8035      		cpi r24,lo8(80)
 9223 1dca 09F5      		brne .L303
 868:main.c        **** 				{
 869:main.c        **** 					switch(uTimeSetState)	//what are we going to set?
 9225               	.LM617:
 9226 1dcc 8091 0000 		lds r24,uTimeSetState
 9227 1dd0 282F      		mov r18,r24
 9228 1dd2 3327      		clr r19
 9229 1dd4 2F87      		std Y+15,r18
 9230 1dd6 388B      		std Y+16,r19
 9231 1dd8 8F85      		ldd r24,Y+15
 9232 1dda 9889      		ldd r25,Y+16
 9233 1ddc 0097      		sbiw r24,0
 9234 1dde 31F0      		breq .L305
 9235 1de0 2F85      		ldd r18,Y+15
 9236 1de2 3889      		ldd r19,Y+16
 9237 1de4 2130      		cpi r18,1
 9238 1de6 3105      		cpc r19,__zero_reg__
 9239 1de8 51F0      		breq .L306
 9240 1dea 11C0      		rjmp .L303
 9241               	.L305:
 870:main.c        **** 					{
 871:main.c        **** 						case 0:		//set the hour
 872:main.c        **** 							BigDigits(2,0,0,0,false);
 9243               	.LM618:
 9244 1dec 00E0      		ldi r16,lo8(0)
 9245 1dee 20E0      		ldi r18,lo8(0)
 9246 1df0 40E0      		ldi r20,lo8(0)
 9247 1df2 50E0      		ldi r21,hi8(0)
 9248 1df4 60E0      		ldi r22,lo8(0)
 9249 1df6 82E0      		ldi r24,lo8(2)
 9250 1df8 0E94 0000 		call BigDigits
 873:main.c        **** 						break;
 9252               	.LM619:
 9253 1dfc 08C0      		rjmp .L303
 9254               	.L306:
 874:main.c        **** 						case 1:		//set the minute
 875:main.c        **** 							BigDigits(2,61,0,0,false);		//the column was 60
 9256               	.LM620:
 9257 1dfe 00E0      		ldi r16,lo8(0)
 9258 1e00 20E0      		ldi r18,lo8(0)
 9259 1e02 40E0      		ldi r20,lo8(0)
 9260 1e04 50E0      		ldi r21,hi8(0)
 9261 1e06 6DE3      		ldi r22,lo8(61)
 9262 1e08 82E0      		ldi r24,lo8(2)
 9263 1e0a 0E94 0000 		call BigDigits
 9264               	.L303:
 876:main.c        **** 						break;
 877:main.c        **** 					}
 878:main.c        **** 				}
 879:main.c        **** 				if(uTmrState==defSettingBlinkOn)	//this code turns on the character that is blinking
 9266               	.LM621:
 9267 1e0e 8091 0000 		lds r24,uTmrState
 9268 1e12 8832      		cpi r24,lo8(40)
 9269 1e14 09F0      		breq .+2
 9270 1e16 76C2      		rjmp .L168
 880:main.c        **** 				{
 881:main.c        **** 					switch(uTimeSetState)	//what are we going to set?
 9272               	.LM622:
 9273 1e18 8091 0000 		lds r24,uTimeSetState
 9274 1e1c 282F      		mov r18,r24
 9275 1e1e 3327      		clr r19
 9276 1e20 298B      		std Y+17,r18
 9277 1e22 3A8B      		std Y+18,r19
 9278 1e24 8989      		ldd r24,Y+17
 9279 1e26 9A89      		ldd r25,Y+18
 9280 1e28 0097      		sbiw r24,0
 9281 1e2a 31F0      		breq .L309
 9282 1e2c 2989      		ldd r18,Y+17
 9283 1e2e 3A89      		ldd r19,Y+18
 9284 1e30 2130      		cpi r18,1
 9285 1e32 3105      		cpc r19,__zero_reg__
 9286 1e34 31F0      		breq .L310
 9287 1e36 66C2      		rjmp .L168
 9288               	.L309:
 882:main.c        **** 					{
 883:main.c        **** 						case 0:		//set the hour
 884:main.c        **** 							ShowLargeAlarmTime(0,2);		//uStartColumn, uRow
 9290               	.LM623:
 9291 1e38 62E0      		ldi r22,lo8(2)
 9292 1e3a 80E0      		ldi r24,lo8(0)
 9293 1e3c 0E94 0000 		call ShowLargeAlarmTime
 885:main.c        **** 						break;
 9295               	.LM624:
 9296 1e40 61C2      		rjmp .L168
 9297               	.L310:
 886:main.c        **** 						case 1:		//set the minute
 887:main.c        **** 							ShowLargeAlarmTime(0,2);		//uStartColumn, uRow
 9299               	.LM625:
 9300 1e42 62E0      		ldi r22,lo8(2)
 9301 1e44 80E0      		ldi r24,lo8(0)
 9302 1e46 0E94 0000 		call ShowLargeAlarmTime
 888:main.c        **** 						break;
 889:main.c        **** 					}
 890:main.c        **** 				}				
 891:main.c        **** 			break;
 9304               	.LM626:
 9305 1e4a 5CC2      		rjmp .L168
 9306               	.L311:
 892:main.c        **** 
 893:main.c        **** 			case 62:	//sets the backlight on and off times
 894:main.c        ****                 if(bit_is_clear(defPushBtnPort,defUpBtn) && uBtnUpTmr==0)  //is the Menu button 1 p
 9308               	.LM627:
 9309 1e4c 8091 3900 		lds r24,57
 9310 1e50 9927      		clr r25
 9311 1e52 9695      		lsr r25
 9312 1e54 8795      		ror r24
 9313 1e56 9695      		lsr r25
 9314 1e58 8795      		ror r24
 9315 1e5a 8170      		andi r24,lo8(1)
 9316 1e5c 9070      		andi r25,hi8(1)
 9317 1e5e 0097      		sbiw r24,0
 9318 1e60 71F5      		brne .L312
 9319 1e62 8091 0000 		lds r24,uBtnUpTmr
 9320 1e66 8823      		tst r24
 9321 1e68 51F5      		brne .L312
 895:main.c        ****                 {
 896:main.c        **** 					if(uTimeSetState==0)	//are we setting the backlight off time?
 9323               	.LM628:
 9324 1e6a 8091 0000 		lds r24,uTimeSetState
 9325 1e6e 8823      		tst r24
 9326 1e70 71F4      		brne .L313
 897:main.c        **** 					{
 898:main.c        **** 						if(uBacklightOffHour==23)	//is it time to cycle the hour back around?
 9328               	.LM629:
 9329 1e72 8091 0000 		lds r24,uBacklightOffHour
 9330 1e76 8731      		cpi r24,lo8(23)
 9331 1e78 19F4      		brne .L314
 899:main.c        **** 						{
 900:main.c        **** 							uBacklightOffHour=0;
 9333               	.LM630:
 9334 1e7a 1092 0000 		sts uBacklightOffHour,__zero_reg__
 9335 1e7e 05C0      		rjmp .L315
 9336               	.L314:
 901:main.c        **** 						}
 902:main.c        **** 						else
 903:main.c        **** 						{
 904:main.c        **** 							uBacklightOffHour++;	//increase the hour
 9338               	.LM631:
 9339 1e80 8091 0000 		lds r24,uBacklightOffHour
 9340 1e84 8F5F      		subi r24,lo8(-(1))
 9341 1e86 8093 0000 		sts uBacklightOffHour,r24
 9342               	.L315:
 905:main.c        **** 						}
 906:main.c        **** 						setBacklightOffTime();		//show the new backlight off hour on the display
 9344               	.LM632:
 9345 1e8a 0E94 0000 		call setBacklightOffTime
 9346               	.L313:
 907:main.c        **** 					}
 908:main.c        **** 					if(uTimeSetState==1)	//are we setting the backlight on time?
 9348               	.LM633:
 9349 1e8e 8091 0000 		lds r24,uTimeSetState
 9350 1e92 8130      		cpi r24,lo8(1)
 9351 1e94 71F4      		brne .L316
 909:main.c        **** 					{
 910:main.c        **** 						if(uBacklightOnHour==23)	//is it time to cycle the backlight on hour around?
 9353               	.LM634:
 9354 1e96 8091 0000 		lds r24,uBacklightOnHour
 9355 1e9a 8731      		cpi r24,lo8(23)
 9356 1e9c 19F4      		brne .L317
 911:main.c        **** 						{
 912:main.c        **** 							uBacklightOnHour=0;
 9358               	.LM635:
 9359 1e9e 1092 0000 		sts uBacklightOnHour,__zero_reg__
 9360 1ea2 05C0      		rjmp .L318
 9361               	.L317:
 913:main.c        **** 						}
 914:main.c        **** 						else
 915:main.c        **** 						{
 916:main.c        **** 							uBacklightOnHour++;		//increase the backlight on hour
 9363               	.LM636:
 9364 1ea4 8091 0000 		lds r24,uBacklightOnHour
 9365 1ea8 8F5F      		subi r24,lo8(-(1))
 9366 1eaa 8093 0000 		sts uBacklightOnHour,r24
 9367               	.L318:
 917:main.c        **** 						}
 918:main.c        **** 						setBacklightOnTime();	//update the backlight on time on the the display
 9369               	.LM637:
 9370 1eae 0E94 0000 		call setBacklightOnTime
 9371               	.L316:
 919:main.c        **** 					}
 920:main.c        ****                     uTmrState=defDlyAfterBtnPress;  //load up the blink timer
 9373               	.LM638:
 9374 1eb2 86E9      		ldi r24,lo8(-106)
 9375 1eb4 8093 0000 		sts uTmrState,r24
 921:main.c        ****                     uBtnUpTmr=defBtnDbn;    //load up the debounce timer, so we don't immediately g
 9377               	.LM639:
 9378 1eb8 8EE0      		ldi r24,lo8(14)
 9379 1eba 8093 0000 		sts uBtnUpTmr,r24
 9380               	.L312:
 922:main.c        **** 				}
 923:main.c        ****                 //has the down button been pressed?
 924:main.c        ****                 if(bit_is_clear(defPushBtnPort,defDownBtn) && uBtnDwnTmr==0)  //is the Menu button 
 9382               	.LM640:
 9383 1ebe 8091 3900 		lds r24,57
 9384 1ec2 9927      		clr r25
 9385 1ec4 9695      		lsr r25
 9386 1ec6 8795      		ror r24
 9387 1ec8 9695      		lsr r25
 9388 1eca 8795      		ror r24
 9389 1ecc 9695      		lsr r25
 9390 1ece 8795      		ror r24
 9391 1ed0 8170      		andi r24,lo8(1)
 9392 1ed2 9070      		andi r25,hi8(1)
 9393 1ed4 0097      		sbiw r24,0
 9394 1ed6 81F5      		brne .L319
 9395 1ed8 8091 0000 		lds r24,uBtnDwnTmr
 9396 1edc 8823      		tst r24
 9397 1ede 61F5      		brne .L319
 925:main.c        ****                 {
 926:main.c        **** 					if(uTimeSetState==0)
 9399               	.LM641:
 9400 1ee0 8091 0000 		lds r24,uTimeSetState
 9401 1ee4 8823      		tst r24
 9402 1ee6 79F4      		brne .L320
 927:main.c        **** 					{
 928:main.c        **** 						if(uBacklightOffHour==0)
 9404               	.LM642:
 9405 1ee8 8091 0000 		lds r24,uBacklightOffHour
 9406 1eec 8823      		tst r24
 9407 1eee 21F4      		brne .L321
 929:main.c        **** 						{
 930:main.c        **** 							uBacklightOffHour=23;
 9409               	.LM643:
 9410 1ef0 87E1      		ldi r24,lo8(23)
 9411 1ef2 8093 0000 		sts uBacklightOffHour,r24
 9412 1ef6 05C0      		rjmp .L322
 9413               	.L321:
 931:main.c        **** 						}
 932:main.c        **** 						else
 933:main.c        **** 						{
 934:main.c        **** 							uBacklightOffHour--;
 9415               	.LM644:
 9416 1ef8 8091 0000 		lds r24,uBacklightOffHour
 9417 1efc 8150      		subi r24,lo8(-(-1))
 9418 1efe 8093 0000 		sts uBacklightOffHour,r24
 9419               	.L322:
 935:main.c        **** 						}
 936:main.c        **** 						setBacklightOffTime();
 9421               	.LM645:
 9422 1f02 0E94 0000 		call setBacklightOffTime
 9423               	.L320:
 937:main.c        **** 					}
 938:main.c        **** 					if(uTimeSetState==1)
 9425               	.LM646:
 9426 1f06 8091 0000 		lds r24,uTimeSetState
 9427 1f0a 8130      		cpi r24,lo8(1)
 9428 1f0c 79F4      		brne .L323
 939:main.c        **** 					{
 940:main.c        **** 						if(uBacklightOnHour==0)
 9430               	.LM647:
 9431 1f0e 8091 0000 		lds r24,uBacklightOnHour
 9432 1f12 8823      		tst r24
 9433 1f14 21F4      		brne .L324
 941:main.c        **** 						{
 942:main.c        **** 							uBacklightOnHour=23;
 9435               	.LM648:
 9436 1f16 87E1      		ldi r24,lo8(23)
 9437 1f18 8093 0000 		sts uBacklightOnHour,r24
 9438 1f1c 05C0      		rjmp .L325
 9439               	.L324:
 943:main.c        **** 						}
 944:main.c        **** 						else
 945:main.c        **** 						{
 946:main.c        **** 							uBacklightOnHour--;
 9441               	.LM649:
 9442 1f1e 8091 0000 		lds r24,uBacklightOnHour
 9443 1f22 8150      		subi r24,lo8(-(-1))
 9444 1f24 8093 0000 		sts uBacklightOnHour,r24
 9445               	.L325:
 947:main.c        **** 						}
 948:main.c        **** 						setBacklightOnTime();
 9447               	.LM650:
 9448 1f28 0E94 0000 		call setBacklightOnTime
 9449               	.L323:
 949:main.c        **** 					}
 950:main.c        ****                     uTmrState=defDlyAfterBtnPress;  //load up the blink timer
 9451               	.LM651:
 9452 1f2c 86E9      		ldi r24,lo8(-106)
 9453 1f2e 8093 0000 		sts uTmrState,r24
 951:main.c        ****                     uBtnDwnTmr=defBtnDbn;   //load up the debounce timer, so we don't immediately g
 9455               	.LM652:
 9456 1f32 8EE0      		ldi r24,lo8(14)
 9457 1f34 8093 0000 		sts uBtnDwnTmr,r24
 9458               	.L319:
 952:main.c        **** 				}                
 953:main.c        **** 				//has the enter button been pressed?
 954:main.c        ****                 if(bit_is_clear(defPushBtnPort,defEnterBtn) && uBtnEnterTmr==0)  //is the Menu butt
 9460               	.LM653:
 9461 1f38 8091 3900 		lds r24,57
 9462 1f3c 9927      		clr r25
 9463 1f3e 9695      		lsr r25
 9464 1f40 8795      		ror r24
 9465 1f42 8170      		andi r24,lo8(1)
 9466 1f44 9070      		andi r25,hi8(1)
 9467 1f46 0097      		sbiw r24,0
 9468 1f48 31F5      		brne .L326
 9469 1f4a 8091 0000 		lds r24,uBtnEnterTmr
 9470 1f4e 8823      		tst r24
 9471 1f50 11F5      		brne .L326
 955:main.c        ****                 {   //pressing the enter button takes us back to the main menu
 956:main.c        **** 					if(uTimeSetState==0)
 9473               	.LM654:
 9474 1f52 8091 0000 		lds r24,uTimeSetState
 9475 1f56 8823      		tst r24
 9476 1f58 31F4      		brne .L327
 957:main.c        **** 					{
 958:main.c        **** 						uTimeSetState=1;	//go allow the user to set the backlight on time
 9478               	.LM655:
 9479 1f5a 81E0      		ldi r24,lo8(1)
 9480 1f5c 8093 0000 		sts uTimeSetState,r24
 959:main.c        **** 						//if the display is blinking this makes sure the value is written when we go to set the backl
 960:main.c        **** 						setBacklightOffTime();	//update the backlight on time on the the display
 9482               	.LM656:
 9483 1f60 0E94 0000 		call setBacklightOffTime
 9484 1f64 15C0      		rjmp .L328
 9485               	.L327:
 961:main.c        **** 					}
 962:main.c        **** 					else
 963:main.c        **** 					{
 964:main.c        **** 						eeprom_write_byte((u08*)&EEBacklightOnHour,uBacklightOnHour);	//store the backlight Hour on v
 9487               	.LM657:
 9488 1f66 6091 0000 		lds r22,uBacklightOnHour
 9489 1f6a 80E0      		ldi r24,lo8(EEBacklightOnHour)
 9490 1f6c 90E0      		ldi r25,hi8(EEBacklightOnHour)
 9491 1f6e 0E94 0000 		call eeprom_write_byte
 965:main.c        **** 						eeprom_write_byte((u08*)&EEBacklightOffHour,uBacklightOffHour);//store the backlight on hour 
 9493               	.LM658:
 9494 1f72 6091 0000 		lds r22,uBacklightOffHour
 9495 1f76 80E0      		ldi r24,lo8(EEBacklightOffHour)
 9496 1f78 90E0      		ldi r25,hi8(EEBacklightOffHour)
 9497 1f7a 0E94 0000 		call eeprom_write_byte
 966:main.c        **** 						uState=50;      //go back to the Main Menu
 9499               	.LM659:
 9500 1f7e 82E3      		ldi r24,lo8(50)
 9501 1f80 8093 0000 		sts uState,r24
 967:main.c        **** 						uTmrState=defStateTm+1;       //reload the state timer
 9503               	.LM660:
 9504 1f84 89EC      		ldi r24,lo8(-55)
 9505 1f86 8093 0000 		sts uTmrState,r24
 968:main.c        **** 						uSelectedLine=defState50HighlightMax;	//when we get back to the main menu, the exit button wi
 9507               	.LM661:
 9508 1f8a 87E0      		ldi r24,lo8(7)
 9509 1f8c 8093 0000 		sts uSelectedLine,r24
 9510               	.L328:
 969:main.c        **** 					}
 970:main.c        ****                     uBtnEnterTmr=defBtnDbn;   //load up the debounce timer, so we don't immediately
 9512               	.LM662:
 9513 1f90 8EE0      		ldi r24,lo8(14)
 9514 1f92 8093 0000 		sts uBtnEnterTmr,r24
 9515               	.L326:
 971:main.c        ****                 }				
 972:main.c        ****                 //from here to the break blinks the Trigger Value
 973:main.c        ****                 uTmrState--;    //count down to a blink
 9517               	.LM663:
 9518 1f96 8091 0000 		lds r24,uTmrState
 9519 1f9a 8150      		subi r24,lo8(-(-1))
 9520 1f9c 8093 0000 		sts uTmrState,r24
 974:main.c        ****                 if(uTmrState==0)
 9522               	.LM664:
 9523 1fa0 8091 0000 		lds r24,uTmrState
 9524 1fa4 8823      		tst r24
 9525 1fa6 19F4      		brne .L329
 975:main.c        ****                 {
 976:main.c        ****                     uTmrState=defSettingBlinkOff;   //reset the number blinking timer
 9527               	.LM665:
 9528 1fa8 80E5      		ldi r24,lo8(80)
 9529 1faa 8093 0000 		sts uTmrState,r24
 9530               	.L329:
 977:main.c        ****                 }
 978:main.c        ****                 if(uTmrState==defSettingBlinkOff)   //turn off the number
 9532               	.LM666:
 9533 1fae 8091 0000 		lds r24,uTmrState
 9534 1fb2 8035      		cpi r24,lo8(80)
 9535 1fb4 89F4      		brne .L330
 979:main.c        ****                 {
 980:main.c        **** 					if(uTimeSetState==0)
 9537               	.LM667:
 9538 1fb6 8091 0000 		lds r24,uTimeSetState
 9539 1fba 8823      		tst r24
 9540 1fbc 39F4      		brne .L331
 981:main.c        **** 					{
 982:main.c        **** 						set_line(2);	//The trigger value is on line 5
 9542               	.LM668:
 9543 1fbe 82E0      		ldi r24,lo8(2)
 9544 1fc0 0E94 0000 		call set_line
 983:main.c        **** 						write_pixel_spaces(33); //write over the digits that are not used anymore
 9546               	.LM669:
 9547 1fc4 81E2      		ldi r24,lo8(33)
 9548 1fc6 0E94 0000 		call write_pixel_spaces
 9549 1fca 06C0      		rjmp .L330
 9550               	.L331:
 984:main.c        **** 					}
 985:main.c        **** 					else
 986:main.c        **** 					{
 987:main.c        **** 						set_line(5);	//The trigger value is on line 5
 9552               	.LM670:
 9553 1fcc 85E0      		ldi r24,lo8(5)
 9554 1fce 0E94 0000 		call set_line
 988:main.c        **** 						write_pixel_spaces(33); //write over the digits that are not used anymore
 9556               	.LM671:
 9557 1fd2 81E2      		ldi r24,lo8(33)
 9558 1fd4 0E94 0000 		call write_pixel_spaces
 9559               	.L330:
 989:main.c        **** 					}
 990:main.c        ****                 }
 991:main.c        ****                 if(uTmrState==defSettingBlinkOn)    //make the minimum Speed number visible
 9561               	.LM672:
 9562 1fd8 8091 0000 		lds r24,uTmrState
 9563 1fdc 8832      		cpi r24,lo8(40)
 9564 1fde 49F4      		brne .L333
 992:main.c        ****                 {
 993:main.c        **** 					if(uTimeSetState==0)
 9566               	.LM673:
 9567 1fe0 8091 0000 		lds r24,uTimeSetState
 9568 1fe4 8823      		tst r24
 9569 1fe6 19F4      		brne .L334
 994:main.c        **** 					{
 995:main.c        **** 						setBacklightOffTime();
 9571               	.LM674:
 9572 1fe8 0E94 0000 		call setBacklightOffTime
 9573 1fec 02C0      		rjmp .L333
 9574               	.L334:
 996:main.c        **** 					}
 997:main.c        **** 					else
 998:main.c        **** 					{
 999:main.c        **** 						setBacklightOnTime();
 9576               	.LM675:
 9577 1fee 0E94 0000 		call setBacklightOnTime
 9578               	.L333:
1000:main.c        **** 					}
1001:main.c        ****                 }
1002:main.c        **** 				if(uTmrState>defStateTm)	//paint the new screen for the backlight on and off times
 9580               	.LM676:
 9581 1ff2 8091 0000 		lds r24,uTmrState
 9582 1ff6 893C      		cpi r24,lo8(-55)
 9583 1ff8 08F4      		brsh .+2
 9584 1ffa 84C1      		rjmp .L168
1003:main.c        **** 				{
1004:main.c        **** 					drawText((unsigned char *)strBacklightOffTime,0,0,false);	//colum, row, no highlight
 9586               	.LM677:
 9587 1ffc 20E0      		ldi r18,lo8(0)
 9588 1ffe 40E0      		ldi r20,lo8(0)
 9589 2000 60E0      		ldi r22,lo8(0)
 9590 2002 80E0      		ldi r24,lo8(strBacklightOffTime)
 9591 2004 90E0      		ldi r25,hi8(strBacklightOffTime)
 9592 2006 0E94 0000 		call drawText
1005:main.c        **** 					drawText((unsigned char *)strUsuallyTen,defTab,1,false);	//colum, row, no highlight
 9594               	.LM678:
 9595 200a 20E0      		ldi r18,lo8(0)
 9596 200c 41E0      		ldi r20,lo8(1)
 9597 200e 6AE0      		ldi r22,lo8(10)
 9598 2010 80E0      		ldi r24,lo8(strUsuallyTen)
 9599 2012 90E0      		ldi r25,hi8(strUsuallyTen)
 9600 2014 0E94 0000 		call drawText
1006:main.c        **** 					setBacklightOffTime();
 9602               	.LM679:
 9603 2018 0E94 0000 		call setBacklightOffTime
1007:main.c        **** 					drawText((unsigned char *)strBacklightOnTime,0,3,false);	//colum, row, no highlight
 9605               	.LM680:
 9606 201c 20E0      		ldi r18,lo8(0)
 9607 201e 43E0      		ldi r20,lo8(3)
 9608 2020 60E0      		ldi r22,lo8(0)
 9609 2022 80E0      		ldi r24,lo8(strBacklightOnTime)
 9610 2024 90E0      		ldi r25,hi8(strBacklightOnTime)
 9611 2026 0E94 0000 		call drawText
1008:main.c        **** 					drawText((unsigned char *)strUsuallySix,defTab,4,false);	//colum, row, no highlight
 9613               	.LM681:
 9614 202a 20E0      		ldi r18,lo8(0)
 9615 202c 44E0      		ldi r20,lo8(4)
 9616 202e 6AE0      		ldi r22,lo8(10)
 9617 2030 80E0      		ldi r24,lo8(strUsuallySix)
 9618 2032 90E0      		ldi r25,hi8(strUsuallySix)
 9619 2034 0E94 0000 		call drawText
1009:main.c        **** 					setBacklightOnTime();
 9621               	.LM682:
 9622 2038 0E94 0000 		call setBacklightOnTime
1010:main.c        **** 					uTmrState=defSettingBlinkOff+1;	//don't go in here again and start the blining of the active b
 9624               	.LM683:
 9625 203c 81E5      		ldi r24,lo8(81)
 9626 203e 8093 0000 		sts uTmrState,r24
1011:main.c        **** 				}			
1012:main.c        **** 			break;
 9628               	.LM684:
 9629 2042 60C1      		rjmp .L168
 9630               	.L337:
1013:main.c        **** 
1014:main.c        **** 			case 63:	//allows the user to change the photo trigger value
1015:main.c        ****                 if(bit_is_clear(defPushBtnPort,defUpBtn) && uBtnUpTmr==0)  //is the Menu button 1 p
 9632               	.LM685:
 9633 2044 8091 3900 		lds r24,57
 9634 2048 9927      		clr r25
 9635 204a 9695      		lsr r25
 9636 204c 8795      		ror r24
 9637 204e 9695      		lsr r25
 9638 2050 8795      		ror r24
 9639 2052 8170      		andi r24,lo8(1)
 9640 2054 9070      		andi r25,hi8(1)
 9641 2056 0097      		sbiw r24,0
 9642 2058 49F5      		brne .L338
 9643 205a 8091 0000 		lds r24,uBtnUpTmr
 9644 205e 8823      		tst r24
 9645 2060 29F5      		brne .L338
1016:main.c        ****                 {
1017:main.c        **** 					if(intUserPhotoTriggerValue<975)
 9647               	.LM686:
 9648 2062 8091 0000 		lds r24,intUserPhotoTriggerValue
 9649 2066 9091 0000 		lds r25,(intUserPhotoTriggerValue)+1
 9650 206a 33E0      		ldi r19,hi8(975)
 9651 206c 8F3C      		cpi r24,lo8(975)
 9652 206e 9307      		cpc r25,r19
 9653 2070 48F4      		brsh .L339
1018:main.c        **** 					{
1019:main.c        **** 						intUserPhotoTriggerValue=intUserPhotoTriggerValue+25;
 9655               	.LM687:
 9656 2072 8091 0000 		lds r24,intUserPhotoTriggerValue
 9657 2076 9091 0000 		lds r25,(intUserPhotoTriggerValue)+1
 9658 207a 4996      		adiw r24,25
 9659 207c 9093 0000 		sts (intUserPhotoTriggerValue)+1,r25
 9660 2080 8093 0000 		sts intUserPhotoTriggerValue,r24
 9661               	.L339:
1020:main.c        **** 					}
1021:main.c        **** 					set_line(5);
 9663               	.LM688:
 9664 2084 85E0      		ldi r24,lo8(5)
 9665 2086 0E94 0000 		call set_line
1022:main.c        ****                     write_pixel_spaces(20);
 9667               	.LM689:
 9668 208a 84E1      		ldi r24,lo8(20)
 9669 208c 0E94 0000 		call write_pixel_spaces
1023:main.c        **** 					write_small_numbers(intUserPhotoTriggerValue,false,3);	//
 9671               	.LM690:
 9672 2090 43E0      		ldi r20,lo8(3)
 9673 2092 60E0      		ldi r22,lo8(0)
 9674 2094 8091 0000 		lds r24,intUserPhotoTriggerValue
 9675 2098 9091 0000 		lds r25,(intUserPhotoTriggerValue)+1
 9676 209c 0E94 0000 		call write_small_numbers
1024:main.c        **** 
1025:main.c        ****                     uTmrState=defDlyAfterBtnPress;  //load up the blink timer
 9678               	.LM691:
 9679 20a0 86E9      		ldi r24,lo8(-106)
 9680 20a2 8093 0000 		sts uTmrState,r24
1026:main.c        ****                     uBtnUpTmr=defBtnDbn;    //load up the debounce timer, so we don't immediately g
 9682               	.LM692:
 9683 20a6 8EE0      		ldi r24,lo8(14)
 9684 20a8 8093 0000 		sts uBtnUpTmr,r24
 9685               	.L338:
1027:main.c        **** 				}
1028:main.c        ****                 //has the down button been pressed?
1029:main.c        ****                 if(bit_is_clear(defPushBtnPort,defDownBtn) && uBtnDwnTmr==0)  //is the Menu button 
 9687               	.LM693:
 9688 20ac 8091 3900 		lds r24,57
 9689 20b0 9927      		clr r25
 9690 20b2 9695      		lsr r25
 9691 20b4 8795      		ror r24
 9692 20b6 9695      		lsr r25
 9693 20b8 8795      		ror r24
 9694 20ba 9695      		lsr r25
 9695 20bc 8795      		ror r24
 9696 20be 8170      		andi r24,lo8(1)
 9697 20c0 9070      		andi r25,hi8(1)
 9698 20c2 0097      		sbiw r24,0
 9699 20c4 41F5      		brne .L340
 9700 20c6 8091 0000 		lds r24,uBtnDwnTmr
 9701 20ca 8823      		tst r24
 9702 20cc 21F5      		brne .L340
1030:main.c        ****                 {
1031:main.c        **** 					if(intUserPhotoTriggerValue>25)
 9704               	.LM694:
 9705 20ce 8091 0000 		lds r24,intUserPhotoTriggerValue
 9706 20d2 9091 0000 		lds r25,(intUserPhotoTriggerValue)+1
 9707 20d6 8A31      		cpi r24,26
 9708 20d8 9105      		cpc r25,__zero_reg__
 9709 20da 48F0      		brlo .L341
1032:main.c        **** 					{
1033:main.c        **** 						intUserPhotoTriggerValue=intUserPhotoTriggerValue-25;
 9711               	.LM695:
 9712 20dc 8091 0000 		lds r24,intUserPhotoTriggerValue
 9713 20e0 9091 0000 		lds r25,(intUserPhotoTriggerValue)+1
 9714 20e4 4997      		sbiw r24,25
 9715 20e6 9093 0000 		sts (intUserPhotoTriggerValue)+1,r25
 9716 20ea 8093 0000 		sts intUserPhotoTriggerValue,r24
 9717               	.L341:
1034:main.c        **** 					}
1035:main.c        **** 					set_line(5);
 9719               	.LM696:
 9720 20ee 85E0      		ldi r24,lo8(5)
 9721 20f0 0E94 0000 		call set_line
1036:main.c        ****                     write_pixel_spaces(20);
 9723               	.LM697:
 9724 20f4 84E1      		ldi r24,lo8(20)
 9725 20f6 0E94 0000 		call write_pixel_spaces
1037:main.c        **** 					write_small_numbers(intUserPhotoTriggerValue,false,3);	//
 9727               	.LM698:
 9728 20fa 43E0      		ldi r20,lo8(3)
 9729 20fc 60E0      		ldi r22,lo8(0)
 9730 20fe 8091 0000 		lds r24,intUserPhotoTriggerValue
 9731 2102 9091 0000 		lds r25,(intUserPhotoTriggerValue)+1
 9732 2106 0E94 0000 		call write_small_numbers
1038:main.c        ****                     uTmrState=defDlyAfterBtnPress;  //load up the blink timer
 9734               	.LM699:
 9735 210a 86E9      		ldi r24,lo8(-106)
 9736 210c 8093 0000 		sts uTmrState,r24
1039:main.c        ****                     uBtnDwnTmr=defBtnDbn;   //load up the debounce timer, so we don't immediately g
 9738               	.LM700:
 9739 2110 8EE0      		ldi r24,lo8(14)
 9740 2112 8093 0000 		sts uBtnDwnTmr,r24
 9741               	.L340:
1040:main.c        **** 				}
1041:main.c        ****                 //has the enter button been pressed?
1042:main.c        ****                 if(bit_is_clear(defPushBtnPort,defEnterBtn) && uBtnEnterTmr==0)  //is the Menu butt
 9743               	.LM701:
 9744 2116 8091 3900 		lds r24,57
 9745 211a 9927      		clr r25
 9746 211c 9695      		lsr r25
 9747 211e 8795      		ror r24
 9748 2120 8170      		andi r24,lo8(1)
 9749 2122 9070      		andi r25,hi8(1)
 9750 2124 0097      		sbiw r24,0
 9751 2126 C1F4      		brne .L342
 9752 2128 8091 0000 		lds r24,uBtnEnterTmr
 9753 212c 8823      		tst r24
 9754 212e A1F4      		brne .L342
1043:main.c        ****                 {   //pressing the enter button takes us back to the main menu
1044:main.c        **** 					eeprom_write_word((uint16_t*)&EEPhotoTriggerValue,intUserPhotoTriggerValue);	//store the photo
 9756               	.LM702:
 9757 2130 6091 0000 		lds r22,intUserPhotoTriggerValue
 9758 2134 7091 0000 		lds r23,(intUserPhotoTriggerValue)+1
 9759 2138 80E0      		ldi r24,lo8(EEPhotoTriggerValue)
 9760 213a 90E0      		ldi r25,hi8(EEPhotoTriggerValue)
 9761 213c 0E94 0000 		call eeprom_write_word
1045:main.c        ****                     uState=50;      //go back to the Main Menu
 9763               	.LM703:
 9764 2140 82E3      		ldi r24,lo8(50)
 9765 2142 8093 0000 		sts uState,r24
1046:main.c        ****                     uTmrState=defStateTm+1;       //reload the state timer
 9767               	.LM704:
 9768 2146 89EC      		ldi r24,lo8(-55)
 9769 2148 8093 0000 		sts uTmrState,r24
1047:main.c        **** 					uSelectedLine=defState50HighlightMax;	//when we get back to the main menu, the exit button wil
 9771               	.LM705:
 9772 214c 87E0      		ldi r24,lo8(7)
 9773 214e 8093 0000 		sts uSelectedLine,r24
1048:main.c        ****                     uBtnEnterTmr=defBtnDbn;   //load up the debounce timer, so we don't immediately
 9775               	.LM706:
 9776 2152 8EE0      		ldi r24,lo8(14)
 9777 2154 8093 0000 		sts uBtnEnterTmr,r24
 9778               	.L342:
1049:main.c        ****                 }
1050:main.c        ****                 //from here to the break blinks the Trigger Value
1051:main.c        ****                 uTmrState--;    //count down to a blink
 9780               	.LM707:
 9781 2158 8091 0000 		lds r24,uTmrState
 9782 215c 8150      		subi r24,lo8(-(-1))
 9783 215e 8093 0000 		sts uTmrState,r24
1052:main.c        ****                 if(uTmrState==0)
 9785               	.LM708:
 9786 2162 8091 0000 		lds r24,uTmrState
 9787 2166 8823      		tst r24
 9788 2168 19F4      		brne .L343
1053:main.c        ****                 {
1054:main.c        ****                     uTmrState=defSettingBlinkOff;   //reset the number blinking timer
 9790               	.LM709:
 9791 216a 80E5      		ldi r24,lo8(80)
 9792 216c 8093 0000 		sts uTmrState,r24
 9793               	.L343:
1055:main.c        ****                 }
1056:main.c        ****                 if(uTmrState==defSettingBlinkOff)   //turn off the number
 9795               	.LM710:
 9796 2170 8091 0000 		lds r24,uTmrState
 9797 2174 8035      		cpi r24,lo8(80)
 9798 2176 69F4      		brne .L344
1057:main.c        ****                 {
1058:main.c        **** 					set_line(5);	//The trigger value is on line 5
 9800               	.LM711:
 9801 2178 85E0      		ldi r24,lo8(5)
 9802 217a 0E94 0000 		call set_line
1059:main.c        ****                     write_pixel_spaces(90); //write over the digits that are not used anymore
 9804               	.LM712:
 9805 217e 8AE5      		ldi r24,lo8(90)
 9806 2180 0E94 0000 		call write_pixel_spaces
1060:main.c        **** 					ADMUX=0;	//select analog channel 0 for the ADC conversion
 9808               	.LM713:
 9809 2184 1092 2700 		sts 39,__zero_reg__
1061:main.c        **** 					ADCSRA|=0x40;	//start the ADC conversion process
 9811               	.LM714:
 9812 2188 8091 2600 		lds r24,38
 9813 218c 8064      		ori r24,lo8(64)
 9814 218e 8093 2600 		sts 38,r24
 9815               	.L344:
1062:main.c        ****                 }
1063:main.c        ****                 if(uTmrState==defSettingBlinkOn)    //make the minimum Speed number visible
 9817               	.LM715:
 9818 2192 8091 0000 		lds r24,uTmrState
 9819 2196 8832      		cpi r24,lo8(40)
 9820 2198 81F5      		brne .L345
1064:main.c        ****                 {
1065:main.c        **** 					uTmrGeneral=40;
 9822               	.LM716:
 9823 219a 88E2      		ldi r24,lo8(40)
 9824 219c 8093 0000 		sts uTmrGeneral,r24
1066:main.c        **** 					ADCSRA|=0x10;	//return the ADC, the 10 bit value is stored in the integer ADC
 9826               	.LM717:
 9827 21a0 8091 2600 		lds r24,38
 9828 21a4 8061      		ori r24,lo8(16)
 9829 21a6 8093 2600 		sts 38,r24
1067:main.c        ****                     drawText((unsigned char *)strPhotocellReading,defTab,3,false);	//put up the lab
 9831               	.LM718:
 9832 21aa 20E0      		ldi r18,lo8(0)
 9833 21ac 43E0      		ldi r20,lo8(3)
 9834 21ae 6AE0      		ldi r22,lo8(10)
 9835 21b0 80E0      		ldi r24,lo8(strPhotocellReading)
 9836 21b2 90E0      		ldi r25,hi8(strPhotocellReading)
 9837 21b4 0E94 0000 		call drawText
1068:main.c        **** 					write_char(0x00,false);	//A white space 
 9839               	.LM719:
 9840 21b8 60E0      		ldi r22,lo8(0)
 9841 21ba 80E0      		ldi r24,lo8(0)
 9842 21bc 0E94 0000 		call write_char
1069:main.c        **** 					write_small_numbers(ADC,false,3);	//write the 3 digit ADC
 9844               	.LM720:
 9845 21c0 43E0      		ldi r20,lo8(3)
 9846 21c2 60E0      		ldi r22,lo8(0)
 9847 21c4 8091 2400 		lds r24,36
 9848 21c8 9091 2500 		lds r25,(36)+1
 9849 21cc 0E94 0000 		call write_small_numbers
1070:main.c        **** 					drawText((unsigned char *)strSetTriggerValue,defTab,4,false);	//colum, row, no highlight
 9851               	.LM721:
 9852 21d0 20E0      		ldi r18,lo8(0)
 9853 21d2 44E0      		ldi r20,lo8(4)
 9854 21d4 6AE0      		ldi r22,lo8(10)
 9855 21d6 80E0      		ldi r24,lo8(strSetTriggerValue)
 9856 21d8 90E0      		ldi r25,hi8(strSetTriggerValue)
 9857 21da 0E94 0000 		call drawText
1071:main.c        **** 					set_line(5);
 9859               	.LM722:
 9860 21de 85E0      		ldi r24,lo8(5)
 9861 21e0 0E94 0000 		call set_line
1072:main.c        ****                     write_pixel_spaces(20);
 9863               	.LM723:
 9864 21e4 84E1      		ldi r24,lo8(20)
 9865 21e6 0E94 0000 		call write_pixel_spaces
1073:main.c        **** 					write_small_numbers(intUserPhotoTriggerValue,false,3);	//
 9867               	.LM724:
 9868 21ea 43E0      		ldi r20,lo8(3)
 9869 21ec 60E0      		ldi r22,lo8(0)
 9870 21ee 8091 0000 		lds r24,intUserPhotoTriggerValue
 9871 21f2 9091 0000 		lds r25,(intUserPhotoTriggerValue)+1
 9872 21f6 0E94 0000 		call write_small_numbers
 9873               	.L345:
1074:main.c        ****                 }
1075:main.c        **** 				if(uTmrState>defStateTm)	//paint the new screen
 9875               	.LM725:
 9876 21fa 8091 0000 		lds r24,uTmrState
 9877 21fe 893C      		cpi r24,lo8(-55)
 9878 2200 08F4      		brsh .+2
 9879 2202 80C0      		rjmp .L168
1076:main.c        **** 				{
1077:main.c        **** 					drawText((unsigned char *)strPhotoTriggerValue,0,0,false);	//colum, row, no highlight
 9881               	.LM726:
 9882 2204 20E0      		ldi r18,lo8(0)
 9883 2206 40E0      		ldi r20,lo8(0)
 9884 2208 60E0      		ldi r22,lo8(0)
 9885 220a 80E0      		ldi r24,lo8(strPhotoTriggerValue)
 9886 220c 90E0      		ldi r25,hi8(strPhotoTriggerValue)
 9887 220e 0E94 0000 		call drawText
1078:main.c        **** 					drawText((unsigned char *)strDarkRoom,defTab,1,false);	//colum, row, no highlight
 9889               	.LM727:
 9890 2212 20E0      		ldi r18,lo8(0)
 9891 2214 41E0      		ldi r20,lo8(1)
 9892 2216 6AE0      		ldi r22,lo8(10)
 9893 2218 80E0      		ldi r24,lo8(strDarkRoom)
 9894 221a 90E0      		ldi r25,hi8(strDarkRoom)
 9895 221c 0E94 0000 		call drawText
1079:main.c        **** 					drawText((unsigned char *)strBrightRoom,defTab,2,false);	//colum, row, no highlight
 9897               	.LM728:
 9898 2220 20E0      		ldi r18,lo8(0)
 9899 2222 42E0      		ldi r20,lo8(2)
 9900 2224 6AE0      		ldi r22,lo8(10)
 9901 2226 80E0      		ldi r24,lo8(strBrightRoom)
 9902 2228 90E0      		ldi r25,hi8(strBrightRoom)
 9903 222a 0E94 0000 		call drawText
1080:main.c        **** 					drawText((unsigned char *)strPhotocellReading,defTab,3,false);	//colum, row, no highlight
 9905               	.LM729:
 9906 222e 20E0      		ldi r18,lo8(0)
 9907 2230 43E0      		ldi r20,lo8(3)
 9908 2232 6AE0      		ldi r22,lo8(10)
 9909 2234 80E0      		ldi r24,lo8(strPhotocellReading)
 9910 2236 90E0      		ldi r25,hi8(strPhotocellReading)
 9911 2238 0E94 0000 		call drawText
1081:main.c        **** 					drawText((unsigned char *)strSetTriggerValue,defTab,4,false);	//colum, row, no highlight
 9913               	.LM730:
 9914 223c 20E0      		ldi r18,lo8(0)
 9915 223e 44E0      		ldi r20,lo8(4)
 9916 2240 6AE0      		ldi r22,lo8(10)
 9917 2242 80E0      		ldi r24,lo8(strSetTriggerValue)
 9918 2244 90E0      		ldi r25,hi8(strSetTriggerValue)
 9919 2246 0E94 0000 		call drawText
1082:main.c        **** 					uTmrState=defSettingBlinkOff+1;	//don't go in here again and 
 9921               	.LM731:
 9922 224a 81E5      		ldi r24,lo8(81)
 9923 224c 8093 0000 		sts uTmrState,r24
1083:main.c        **** 				}
1084:main.c        **** 			break;
 9925               	.LM732:
 9926 2250 59C0      		rjmp .L168
 9927               	.L347:
1085:main.c        **** 
1086:main.c        **** 			case 64:	//This puts up the "about this clock" information
1087:main.c        **** 				if(bit_is_clear(defPushBtnPort,defUpBtn) && uBtnUpTmr==0)  //is the Menu button 1 pressed?
 9929               	.LM733:
 9930 2252 8091 3900 		lds r24,57
 9931 2256 9927      		clr r25
 9932 2258 9695      		lsr r25
 9933 225a 8795      		ror r24
 9934 225c 9695      		lsr r25
 9935 225e 8795      		ror r24
 9936 2260 8170      		andi r24,lo8(1)
 9937 2262 9070      		andi r25,hi8(1)
 9938 2264 0097      		sbiw r24,0
 9939 2266 69F4      		brne .L348
 9940 2268 8091 0000 		lds r24,uBtnUpTmr
 9941 226c 8823      		tst r24
 9942 226e 49F4      		brne .L348
1088:main.c        **** 				{				
1089:main.c        **** 					uTmrState=defStateTm;
 9944               	.LM734:
 9945 2270 88EC      		ldi r24,lo8(-56)
 9946 2272 8093 0000 		sts uTmrState,r24
1090:main.c        **** 					uState=50;			//go back to the main menu
 9948               	.LM735:
 9949 2276 82E3      		ldi r24,lo8(50)
 9950 2278 8093 0000 		sts uState,r24
1091:main.c        **** 					uBtnUpTmr=defBtnDbn;   	//load up the debounce timer, so we don't immediately go back in here
 9952               	.LM736:
 9953 227c 8EE0      		ldi r24,lo8(14)
 9954 227e 8093 0000 		sts uBtnUpTmr,r24
 9955               	.L348:
1092:main.c        **** 				}
1093:main.c        **** 				if(bit_is_clear(defPushBtnPort,defDownBtn) && uBtnDwnTmr==0)  //is the Menu button 2 pressed?
 9957               	.LM737:
 9958 2282 8091 3900 		lds r24,57
 9959 2286 9927      		clr r25
 9960 2288 9695      		lsr r25
 9961 228a 8795      		ror r24
 9962 228c 9695      		lsr r25
 9963 228e 8795      		ror r24
 9964 2290 9695      		lsr r25
 9965 2292 8795      		ror r24
 9966 2294 8170      		andi r24,lo8(1)
 9967 2296 9070      		andi r25,hi8(1)
 9968 2298 0097      		sbiw r24,0
 9969 229a 69F4      		brne .L349
 9970 229c 8091 0000 		lds r24,uBtnDwnTmr
 9971 22a0 8823      		tst r24
 9972 22a2 49F4      		brne .L349
1094:main.c        **** 				{
1095:main.c        **** 					uTmrState=defStateTm;
 9974               	.LM738:
 9975 22a4 88EC      		ldi r24,lo8(-56)
 9976 22a6 8093 0000 		sts uTmrState,r24
1096:main.c        **** 					uState=50;			//go back to the main menu
 9978               	.LM739:
 9979 22aa 82E3      		ldi r24,lo8(50)
 9980 22ac 8093 0000 		sts uState,r24
1097:main.c        **** 					uBtnDwnTmr=defBtnDbn;   	//load up the debounce timer, so we don't immediately go back in here
 9982               	.LM740:
 9983 22b0 8EE0      		ldi r24,lo8(14)
 9984 22b2 8093 0000 		sts uBtnDwnTmr,r24
 9985               	.L349:
1098:main.c        **** 				}
1099:main.c        **** 				if(bit_is_clear(defPushBtnPort,defEnterBtn) && uBtnEnterTmr==0)  //is the Menu button 2 pressed
 9987               	.LM741:
 9988 22b6 8091 3900 		lds r24,57
 9989 22ba 9927      		clr r25
 9990 22bc 9695      		lsr r25
 9991 22be 8795      		ror r24
 9992 22c0 8170      		andi r24,lo8(1)
 9993 22c2 9070      		andi r25,hi8(1)
 9994 22c4 0097      		sbiw r24,0
 9995 22c6 69F4      		brne .L350
 9996 22c8 8091 0000 		lds r24,uBtnEnterTmr
 9997 22cc 8823      		tst r24
 9998 22ce 49F4      		brne .L350
1100:main.c        **** 				{	
1101:main.c        **** 					uTmrState=defStateTm;
 10000               	.LM742:
 10001 22d0 88EC      		ldi r24,lo8(-56)
 10002 22d2 8093 0000 		sts uTmrState,r24
1102:main.c        **** 					uState=50;			//go back to the main menu
 10004               	.LM743:
 10005 22d6 82E3      		ldi r24,lo8(50)
 10006 22d8 8093 0000 		sts uState,r24
1103:main.c        **** 					uBtnEnterTmr=defBtnDbn;   	//load up the debounce timer, so we don't immediately go back in he
 10008               	.LM744:
 10009 22dc 8EE0      		ldi r24,lo8(14)
 10010 22de 8093 0000 		sts uBtnEnterTmr,r24
 10011               	.L350:
1104:main.c        **** 				}
1105:main.c        **** 				if(uTmrState==5)
 10013               	.LM745:
 10014 22e2 8091 0000 		lds r24,uTmrState
 10015 22e6 8530      		cpi r24,lo8(5)
 10016 22e8 69F4      		brne .L168
1106:main.c        **** 				{
1107:main.c        **** 					clear_display();	//clear the whole display
 10018               	.LM746:
 10019 22ea 0E94 0000 		call clear_display
1108:main.c        **** 					paintMenu((unsigned char *)str64,defState64HighlightMin,defState64HighlightMax);	//string, col
 10021               	.LM747:
 10022 22ee 40E0      		ldi r20,lo8(0)
 10023 22f0 60E0      		ldi r22,lo8(0)
 10024 22f2 80E0      		ldi r24,lo8(str64)
 10025 22f4 90E0      		ldi r25,hi8(str64)
 10026 22f6 0E94 0000 		call paintMenu
1109:main.c        **** 					uTmrState--;	//don't go in here again
 10028               	.LM748:
 10029 22fa 8091 0000 		lds r24,uTmrState
 10030 22fe 8150      		subi r24,lo8(-(-1))
 10031 2300 8093 0000 		sts uTmrState,r24
 10032               	.L168:
 10033               	/* epilogue: frame size=20 */
 10034 2304 6496      		adiw r28,20
 10035 2306 0FB6      		in __tmp_reg__,__SREG__
 10036 2308 F894      		cli
 10037 230a DEBF      		out __SP_H__,r29
 10038 230c 0FBE      		out __SREG__,__tmp_reg__
 10039 230e CDBF      		out __SP_L__,r28
 10040 2310 DF91      		pop r29
 10041 2312 CF91      		pop r28
 10042 2314 0F91      		pop r16
 10043 2316 0895      		ret
 10044               	/* epilogue end (size=10) */
 10045               	/* function SrvTock size 2363 (2342) */
 10048               	.global	InitLCD
 10050               	InitLCD:
1110:main.c        **** 				}
1111:main.c        **** 			break;
1112:main.c        **** 
1113:main.c        **** 		}
1114:main.c        **** 	}
1115:main.c        **** }
1116:main.c        **** 
1117:main.c        **** void InitLCD(void)
1118:main.c        **** {
 10052               	.LM749:
 10053               	/* prologue: frame size=0 */
 10054 2318 CF93      		push r28
 10055 231a DF93      		push r29
 10056 231c CDB7      		in r28,__SP_L__
 10057 231e DEB7      		in r29,__SP_H__
 10058               	/* prologue end (size=4) */
1119:main.c        **** //	u08 uEVR=0x20;
1120:main.c        **** //	u08 uRR=0x27;
1121:main.c        **** 	
1122:main.c        **** 	sbi(defLCDContPort,defLcdRES);       //take the display out of reset
 10060               	.LM750:
 10061 2320 8091 3800 		lds r24,56
 10062 2324 8260      		ori r24,lo8(2)
 10063 2326 8093 3800 		sts 56,r24
1123:main.c        **** 
1124:main.c        **** 	write_command(0xe2);		//reset display, datasheet
 10065               	.LM751:
 10066 232a 82EE      		ldi r24,lo8(-30)
 10067 232c 0E94 0000 		call write_command
1125:main.c        **** 	//write_command(0xa2);		//lcd bias setting, not used for the old oprex display!!!!
1126:main.c        **** 	write_command(0xa1);		//reverse segment driver select, must be set to 0xa1.
 10069               	.LM752:
 10070 2330 81EA      		ldi r24,lo8(-95)
 10071 2332 0E94 0000 		call write_command
1127:main.c        **** 	write_command(0xc0);		//common output normal, datasheet
 10073               	.LM753:
 10074 2336 80EC      		ldi r24,lo8(-64)
 10075 2338 0E94 0000 		call write_command
1128:main.c        **** 	write_command(0xa6);
 10077               	.LM754:
 10078 233c 86EA      		ldi r24,lo8(-90)
 10079 233e 0E94 0000 		call write_command
1129:main.c        **** 	//write_command(0xc8);
1130:main.c        **** 	#ifdef defS1D15605			//older Optrex displays, F-51553
1131:main.c        **** 		write_command(0x24);	//v5 resistor ratio, S1D15605 driver IC
 10081               	.LM755:
 10082 2342 84E2      		ldi r24,lo8(36)
 10083 2344 0E94 0000 		call write_command
1132:main.c        **** 	#else						//new Optrex Displays, F-51852
1133:main.c        **** 		write_command(0xe6);	//Driver on/off, NJU6676 driver IC
1134:main.c        **** 	#endif
1135:main.c        **** 	write_command(0x81);		//electronic volume set, datasheet
 10085               	.LM756:
 10086 2348 81E8      		ldi r24,lo8(-127)
 10087 234a 0E94 0000 		call write_command
1136:main.c        **** 	#ifdef defS1D15605			//older Optrex displays, F-51553
1137:main.c        **** 		write_command(0x10);		//electronic volume init, datasheet
 10089               	.LM757:
 10090 234e 80E1      		ldi r24,lo8(16)
 10091 2350 0E94 0000 		call write_command
1138:main.c        **** 	#else						//new Optrex Displays, F-51852
1139:main.c        **** 		write_command(0x20);	//the second part of the electronic volume set
1140:main.c        **** 	#endif
1141:main.c        **** 	write_command(0x2f);		//power control, datasheet:  turn on everything
 10093               	.LM758:
 10094 2354 8FE2      		ldi r24,lo8(47)
 10095 2356 0E94 0000 		call write_command
1142:main.c        **** 	write_command(0x40);		//start line set, datasheet:  start on line address 0
 10097               	.LM759:
 10098 235a 80E4      		ldi r24,lo8(64)
 10099 235c 0E94 0000 		call write_command
1143:main.c        **** 	write_command(0xb0);		//page address set, datasheet: page address 0
 10101               	.LM760:
 10102 2360 80EB      		ldi r24,lo8(-80)
 10103 2362 0E94 0000 		call write_command
1144:main.c        **** 	write_command(0x10);		//column address high, datasheet
 10105               	.LM761:
 10106 2366 80E1      		ldi r24,lo8(16)
 10107 2368 0E94 0000 		call write_command
1145:main.c        **** 	write_command(0x00);		//column address low, datasheet
 10109               	.LM762:
 10110 236c 80E0      		ldi r24,lo8(0)
 10111 236e 0E94 0000 		call write_command
1146:main.c        **** 	write_command(0xaf);		//turn on the display, in datasheet
 10113               	.LM763:
 10114 2372 8FEA      		ldi r24,lo8(-81)
 10115 2374 0E94 0000 		call write_command
1147:main.c        **** 	#ifdef defS1D15605			//older Optrex displays, F-51553
1148:main.c        **** 		write_command(0x1b);	//v5 resistor ratio, S1D15605 driver IC
 10117               	.LM764:
 10118 2378 8BE1      		ldi r24,lo8(27)
 10119 237a 0E94 0000 		call write_command
1149:main.c        **** 	#else						//new Optrex Displays, F-51852
1150:main.c        **** 		write_command(uRR);	//resistor ratio, was 0x27!!!!!!
1151:main.c        **** 		write_command(0xe7);	//Driver on/off, NJU6676 driver IC
1152:main.c        **** 	#endif
1153:main.c        **** 	write_command(0x81);		//electronic volume set
 10121               	.LM765:
 10122 237e 81E8      		ldi r24,lo8(-127)
 10123 2380 0E94 0000 		call write_command
1154:main.c        **** 	#ifdef defS1D15605			//older Optrex displays, F-51553
1155:main.c        **** 		write_command(0x30);	//the second part of the electronic volume set
 10125               	.LM766:
 10126 2384 80E3      		ldi r24,lo8(48)
 10127 2386 0E94 0000 		call write_command
 10128               	/* epilogue: frame size=0 */
 10129 238a DF91      		pop r29
 10130 238c CF91      		pop r28
 10131 238e 0895      		ret
 10132               	/* epilogue end (size=3) */
 10133               	/* function InitLCD size 60 (53) */
 10137               	.global	write_command
 10139               	write_command:
1156:main.c        **** 	#else						//new Optrex Displays, F-51852
1157:main.c        **** 		write_command(uEVR);	//the second part of the electronic volume set, was 0x20!!!!!
1158:main.c        **** 	#endif
1159:main.c        **** 
1160:main.c        **** /*
1161:main.c        **** 	//These are the commands that TVI Electronics uses to initialize the Optrex LCD
1162:main.c        **** 	write_command(0xA3);	//LCD bias 1/7th (0xA3)
1163:main.c        **** 	write_command(0xA1);	//ADC select reverse
1164:main.c        **** 	write_command(0xC0);	//common output normal
1165:main.c        **** 	write_command(0xA6);	//display normal
1166:main.c        **** 	write_command(0x26);	//V5 resistor ratio
1167:main.c        **** 	write_command(0x81);	//electronic volume set
1168:main.c        **** 	write_command(0x20);	//electronic volume init
1169:main.c        **** 	write_command(0x2F);	//power control set
1170:main.c        **** 	
1171:main.c        **** //	write_command(0x40);		//start line set, datasheet:  start on line address 0
1172:main.c        **** //	write_command(0xb0);		//page address set, datasheet: page address 0
1173:main.c        **** //	write_command(0x10);		//column address high, datasheet
1174:main.c        **** //	write_command(0x00);		//column address low, datasheet
1175:main.c        **** 	
1176:main.c        **** 	write_command(0xAF);	//display on
1177:main.c        **** */
1178:main.c        **** }
1179:main.c        **** 
1180:main.c        **** //----------------------------------------------------------------------------
1181:main.c        **** //Routine:     write_command (write a command to the graphical LCD)
1182:main.c        **** //
1183:main.c        **** //Function:
1184:main.c        **** //			This function serially writes a command to the Optrex LCD
1185:main.c        **** //Varibles passed:
1186:main.c        **** //       uLcdCommand:  The control command to send to the LCD
1187:main.c        **** //Returns:
1188:main.c        **** //       none
1189:main.c        **** //----------------------------------------------------------------------------
1190:main.c        **** void write_command(unsigned char uLcdCommand)
1191:main.c        **** {
 10141               	.LM767:
 10142               	/* prologue: frame size=1 */
 10143 2390 CF93      		push r28
 10144 2392 DF93      		push r29
 10145 2394 CDB7      		in r28,__SP_L__
 10146 2396 DEB7      		in r29,__SP_H__
 10147 2398 2197      		sbiw r28,1
 10148 239a 0FB6      		in __tmp_reg__,__SREG__
 10149 239c F894      		cli
 10150 239e DEBF      		out __SP_H__,r29
 10151 23a0 0FBE      		out __SREG__,__tmp_reg__
 10152 23a2 CDBF      		out __SP_L__,r28
 10153               	/* prologue end (size=10) */
 10154 23a4 8983      		std Y+1,r24
1192:main.c        ****     sbi(defLCDContPort,defLcdRD);       //change state on the read line of the LCD
 10156               	.LM768:
 10157 23a6 8091 3800 		lds r24,56
 10158 23aa 8061      		ori r24,lo8(16)
 10159 23ac 8093 3800 		sts 56,r24
1193:main.c        ****     cbi(defLCDContPort,defLcdA0);       //clear A0 on the LCD for a command
 10161               	.LM769:
 10162 23b0 8091 3800 		lds r24,56
 10163 23b4 8B7F      		andi r24,lo8(-5)
 10164 23b6 8093 3800 		sts 56,r24
1194:main.c        ****     cbi(defLCDContPort,defLcdCS1);      //clear the Chip Select on the LCD for
 10166               	.LM770:
 10167 23ba 8091 3800 		lds r24,56
 10168 23be 8E7F      		andi r24,lo8(-2)
 10169 23c0 8093 3800 		sts 56,r24
1195:main.c        ****     cbi(defLCDContPort,defLcdWR);       //change state on the Write line of the LCD
 10171               	.LM771:
 10172 23c4 8091 3800 		lds r24,56
 10173 23c8 877F      		andi r24,lo8(-9)
 10174 23ca 8093 3800 		sts 56,r24
1196:main.c        **** 	send_serial_data(uLcdCommand);					//send the data to the LCD serially
 10176               	.LM772:
 10177 23ce 8981      		ldd r24,Y+1
 10178 23d0 0E94 0000 		call send_serial_data
1197:main.c        ****     sbi(defLCDContPort,defLcdWR);		//we are done writing to the LCD
 10180               	.LM773:
 10181 23d4 8091 3800 		lds r24,56
 10182 23d8 8860      		ori r24,lo8(8)
 10183 23da 8093 3800 		sts 56,r24
1198:main.c        ****     sbi(defLCDContPort,defLcdCS1);      //now set the Chip Select on the LCD
 10185               	.LM774:
 10186 23de 8091 3800 		lds r24,56
 10187 23e2 8160      		ori r24,lo8(1)
 10188 23e4 8093 3800 		sts 56,r24
1199:main.c        ****     cbi(defLCDContPort,defLcdRD);       //change state on the read line of the LCD
 10190               	.LM775:
 10191 23e8 8091 3800 		lds r24,56
 10192 23ec 8F7E      		andi r24,lo8(-17)
 10193 23ee 8093 3800 		sts 56,r24
 10194               	/* epilogue: frame size=1 */
 10195 23f2 2196      		adiw r28,1
 10196 23f4 0FB6      		in __tmp_reg__,__SREG__
 10197 23f6 F894      		cli
 10198 23f8 DEBF      		out __SP_H__,r29
 10199 23fa 0FBE      		out __SREG__,__tmp_reg__
 10200 23fc CDBF      		out __SP_L__,r28
 10201 23fe DF91      		pop r29
 10202 2400 CF91      		pop r28
 10203 2402 0895      		ret
 10204               	/* epilogue end (size=9) */
 10205               	/* function write_command size 58 (39) */
 10212               	.global	write_date
 10214               	write_date:
1200:main.c        **** }
1201:main.c        **** 
1202:main.c        **** //----------------------------------------------------------------------------
1203:main.c        **** //Routine:     write_date
1204:main.c        **** //
1205:main.c        **** //Function:		This subroutine takes the current month, day and year and puts
1206:main.c        **** //		it on the bottom of line of the LCD display.  The format is "month" 
1207:main.c        **** //		(abbreviated), day (two digits), and the year (The year always starts
1208:main.c        **** //		with the number 2, and then three digits)
1209:main.c        **** //			
1210:main.c        **** //Varibles passed:
1211:main.c        **** //		uStartRow: 0 to 7, the start row of the big text
1212:main.c        **** //		uStartColum:  0 to 112, the pixel count to start the number from the left side of the display
1213:main.c        **** //		uBlank:  Blank the month day or year
1214:main.c        **** //			=0  don't blank anything
1215:main.c        **** //			=1  Blank the Month
1216:main.c        **** //			=2  Blank the day
1217:main.c        **** //			=3  Blank the year
1218:main.c        **** //  	boolInvert: if true, blue on a white background, if false, white on a blue background
1219:main.c        **** //Returns:
1220:main.c        **** //       none
1221:main.c        **** //----------------------------------------------------------------------------
1222:main.c        **** void write_date(unsigned char uStartColumn,unsigned char uRow, unsigned char uBlank,bool boolInvert
1223:main.c        **** {
 10216               	.LM776:
 10217               	/* prologue: frame size=6 */
 10218 2404 CF93      		push r28
 10219 2406 DF93      		push r29
 10220 2408 CDB7      		in r28,__SP_L__
 10221 240a DEB7      		in r29,__SP_H__
 10222 240c 2697      		sbiw r28,6
 10223 240e 0FB6      		in __tmp_reg__,__SREG__
 10224 2410 F894      		cli
 10225 2412 DEBF      		out __SP_H__,r29
 10226 2414 0FBE      		out __SREG__,__tmp_reg__
 10227 2416 CDBF      		out __SP_L__,r28
 10228               	/* prologue end (size=10) */
 10229 2418 8983      		std Y+1,r24
 10230 241a 6A83      		std Y+2,r22
 10231 241c 4B83      		std Y+3,r20
 10232 241e 2C83      		std Y+4,r18
1224:main.c        **** 	set_line(uRow);		//set the line for writing a string of characters
 10234               	.LM777:
 10235 2420 8A81      		ldd r24,Y+2
 10236 2422 0E94 0000 		call set_line
1225:main.c        **** 	moveCursorToColumn(uStartColumn);	//write white spaces to get to the right column
 10238               	.LM778:
 10239 2426 8981      		ldd r24,Y+1
 10240 2428 0E94 0000 		call moveCursorToColumn
1226:main.c        **** 	if(uBlank != 1)	//go in here if we are not blanking the month
 10242               	.LM779:
 10243 242c 8B81      		ldd r24,Y+3
 10244 242e 8130      		cpi r24,lo8(1)
 10245 2430 09F4      		brne .+2
 10246 2432 C5C0      		rjmp .L357
1227:main.c        **** 	{
1228:main.c        **** 		switch(t.intMonth)	//find the month string based upon an integer
 10248               	.LM780:
 10249 2434 8091 0000 		lds r24,t+8
 10250 2438 9091 0000 		lds r25,(t+8)+1
 10251 243c 8D83      		std Y+5,r24
 10252 243e 9E83      		std Y+6,r25
 10253 2440 8D81      		ldd r24,Y+5
 10254 2442 9E81      		ldd r25,Y+6
 10255 2444 8630      		cpi r24,6
 10256 2446 9105      		cpc r25,__zero_reg__
 10257 2448 09F4      		brne .+2
 10258 244a 7DC0      		rjmp .L364
 10259 244c 8D81      		ldd r24,Y+5
 10260 244e 9E81      		ldd r25,Y+6
 10261 2450 8730      		cpi r24,7
 10262 2452 9105      		cpc r25,__zero_reg__
 10263 2454 28F5      		brsh .L371
 10264 2456 8D81      		ldd r24,Y+5
 10265 2458 9E81      		ldd r25,Y+6
 10266 245a 8330      		cpi r24,3
 10267 245c 9105      		cpc r25,__zero_reg__
 10268 245e 09F4      		brne .+2
 10269 2460 5AC0      		rjmp .L361
 10270 2462 8D81      		ldd r24,Y+5
 10271 2464 9E81      		ldd r25,Y+6
 10272 2466 8430      		cpi r24,4
 10273 2468 9105      		cpc r25,__zero_reg__
 10274 246a 68F4      		brsh .L372
 10275 246c 8D81      		ldd r24,Y+5
 10276 246e 9E81      		ldd r25,Y+6
 10277 2470 8130      		cpi r24,1
 10278 2472 9105      		cpc r25,__zero_reg__
 10279 2474 09F4      		brne .+2
 10280 2476 3FC0      		rjmp .L359
 10281 2478 8D81      		ldd r24,Y+5
 10282 247a 9E81      		ldd r25,Y+6
 10283 247c 8230      		cpi r24,2
 10284 247e 9105      		cpc r25,__zero_reg__
 10285 2480 09F4      		brne .+2
 10286 2482 41C0      		rjmp .L360
 10287 2484 97C0      		rjmp .L358
 10288               	.L372:
 10289 2486 8D81      		ldd r24,Y+5
 10290 2488 9E81      		ldd r25,Y+6
 10291 248a 8430      		cpi r24,4
 10292 248c 9105      		cpc r25,__zero_reg__
 10293 248e 09F4      		brne .+2
 10294 2490 4AC0      		rjmp .L362
 10295 2492 8D81      		ldd r24,Y+5
 10296 2494 9E81      		ldd r25,Y+6
 10297 2496 8530      		cpi r24,5
 10298 2498 9105      		cpc r25,__zero_reg__
 10299 249a 09F4      		brne .+2
 10300 249c 4CC0      		rjmp .L363
 10301 249e 8AC0      		rjmp .L358
 10302               	.L371:
 10303 24a0 8D81      		ldd r24,Y+5
 10304 24a2 9E81      		ldd r25,Y+6
 10305 24a4 8930      		cpi r24,9
 10306 24a6 9105      		cpc r25,__zero_reg__
 10307 24a8 09F4      		brne .+2
 10308 24aa 65C0      		rjmp .L367
 10309 24ac 8D81      		ldd r24,Y+5
 10310 24ae 9E81      		ldd r25,Y+6
 10311 24b0 8A30      		cpi r24,10
 10312 24b2 9105      		cpc r25,__zero_reg__
 10313 24b4 68F4      		brsh .L373
 10314 24b6 8D81      		ldd r24,Y+5
 10315 24b8 9E81      		ldd r25,Y+6
 10316 24ba 8730      		cpi r24,7
 10317 24bc 9105      		cpc r25,__zero_reg__
 10318 24be 09F4      		brne .+2
 10319 24c0 4AC0      		rjmp .L365
 10320 24c2 8D81      		ldd r24,Y+5
 10321 24c4 9E81      		ldd r25,Y+6
 10322 24c6 8830      		cpi r24,8
 10323 24c8 9105      		cpc r25,__zero_reg__
 10324 24ca 09F4      		brne .+2
 10325 24cc 4CC0      		rjmp .L366
 10326 24ce 72C0      		rjmp .L358
 10327               	.L373:
 10328 24d0 8D81      		ldd r24,Y+5
 10329 24d2 9E81      		ldd r25,Y+6
 10330 24d4 8B30      		cpi r24,11
 10331 24d6 9105      		cpc r25,__zero_reg__
 10332 24d8 09F4      		brne .+2
 10333 24da 5DC0      		rjmp .L369
 10334 24dc 8D81      		ldd r24,Y+5
 10335 24de 9E81      		ldd r25,Y+6
 10336 24e0 8B30      		cpi r24,11
 10337 24e2 9105      		cpc r25,__zero_reg__
 10338 24e4 08F4      		brsh .+2
 10339 24e6 4FC0      		rjmp .L368
 10340 24e8 8D81      		ldd r24,Y+5
 10341 24ea 9E81      		ldd r25,Y+6
 10342 24ec 8C30      		cpi r24,12
 10343 24ee 9105      		cpc r25,__zero_reg__
 10344 24f0 09F4      		brne .+2
 10345 24f2 59C0      		rjmp .L370
 10346 24f4 5FC0      		rjmp .L358
 10347               	.L359:
1229:main.c        **** 		{
1230:main.c        **** 			case 1:		//January
1231:main.c        **** 				drawText((unsigned char *)strJan,uStartColumn,uRow,boolInvert);	//show the month on the display
 10349               	.LM781:
 10350 24f6 2C81      		ldd r18,Y+4
 10351 24f8 4A81      		ldd r20,Y+2
 10352 24fa 6981      		ldd r22,Y+1
 10353 24fc 80E0      		ldi r24,lo8(strJan)
 10354 24fe 90E0      		ldi r25,hi8(strJan)
 10355 2500 0E94 0000 		call drawText
1232:main.c        **** 			break;
 10357               	.LM782:
 10358 2504 57C0      		rjmp .L358
 10359               	.L360:
1233:main.c        **** 			case 2:		//February
1234:main.c        **** 				drawText((unsigned char *)strFeb,uStartColumn,uRow,boolInvert);	//show the month on the display
 10361               	.LM783:
 10362 2506 2C81      		ldd r18,Y+4
 10363 2508 4A81      		ldd r20,Y+2
 10364 250a 6981      		ldd r22,Y+1
 10365 250c 80E0      		ldi r24,lo8(strFeb)
 10366 250e 90E0      		ldi r25,hi8(strFeb)
 10367 2510 0E94 0000 		call drawText
1235:main.c        **** 			break;
 10369               	.LM784:
 10370 2514 4FC0      		rjmp .L358
 10371               	.L361:
1236:main.c        **** 			case 3:		//March
1237:main.c        **** 				drawText((unsigned char *)strMarch,uStartColumn,uRow,boolInvert);	//show the month on the displ
 10373               	.LM785:
 10374 2516 2C81      		ldd r18,Y+4
 10375 2518 4A81      		ldd r20,Y+2
 10376 251a 6981      		ldd r22,Y+1
 10377 251c 80E0      		ldi r24,lo8(strMarch)
 10378 251e 90E0      		ldi r25,hi8(strMarch)
 10379 2520 0E94 0000 		call drawText
1238:main.c        **** 			break;
 10381               	.LM786:
 10382 2524 47C0      		rjmp .L358
 10383               	.L362:
1239:main.c        **** 			case 4:		//April
1240:main.c        **** 				drawText((unsigned char *)strApril,uStartColumn,uRow,boolInvert);	//show the month on the displ
 10385               	.LM787:
 10386 2526 2C81      		ldd r18,Y+4
 10387 2528 4A81      		ldd r20,Y+2
 10388 252a 6981      		ldd r22,Y+1
 10389 252c 80E0      		ldi r24,lo8(strApril)
 10390 252e 90E0      		ldi r25,hi8(strApril)
 10391 2530 0E94 0000 		call drawText
1241:main.c        **** 			break;
 10393               	.LM788:
 10394 2534 3FC0      		rjmp .L358
 10395               	.L363:
1242:main.c        **** 			case 5:
1243:main.c        **** 				drawText((unsigned char *)strMay,uStartColumn,uRow,boolInvert);	//show the month on the display
 10397               	.LM789:
 10398 2536 2C81      		ldd r18,Y+4
 10399 2538 4A81      		ldd r20,Y+2
 10400 253a 6981      		ldd r22,Y+1
 10401 253c 80E0      		ldi r24,lo8(strMay)
 10402 253e 90E0      		ldi r25,hi8(strMay)
 10403 2540 0E94 0000 		call drawText
1244:main.c        **** 			break;
 10405               	.LM790:
 10406 2544 37C0      		rjmp .L358
 10407               	.L364:
1245:main.c        **** 			case 6:
1246:main.c        **** 				drawText((unsigned char *)strJune,uStartColumn,uRow,boolInvert);	//show the month on the displa
 10409               	.LM791:
 10410 2546 2C81      		ldd r18,Y+4
 10411 2548 4A81      		ldd r20,Y+2
 10412 254a 6981      		ldd r22,Y+1
 10413 254c 80E0      		ldi r24,lo8(strJune)
 10414 254e 90E0      		ldi r25,hi8(strJune)
 10415 2550 0E94 0000 		call drawText
1247:main.c        **** 			break;
 10417               	.LM792:
 10418 2554 2FC0      		rjmp .L358
 10419               	.L365:
1248:main.c        **** 			case 7:
1249:main.c        **** 				drawText((unsigned char *)strJuly,uStartColumn,uRow,boolInvert);	//show the month on the displa
 10421               	.LM793:
 10422 2556 2C81      		ldd r18,Y+4
 10423 2558 4A81      		ldd r20,Y+2
 10424 255a 6981      		ldd r22,Y+1
 10425 255c 80E0      		ldi r24,lo8(strJuly)
 10426 255e 90E0      		ldi r25,hi8(strJuly)
 10427 2560 0E94 0000 		call drawText
1250:main.c        **** 			break;
 10429               	.LM794:
 10430 2564 27C0      		rjmp .L358
 10431               	.L366:
1251:main.c        **** 			case 8:
1252:main.c        **** 				drawText((unsigned char *)strAug,uStartColumn,uRow,boolInvert);	//show the month on the display
 10433               	.LM795:
 10434 2566 2C81      		ldd r18,Y+4
 10435 2568 4A81      		ldd r20,Y+2
 10436 256a 6981      		ldd r22,Y+1
 10437 256c 80E0      		ldi r24,lo8(strAug)
 10438 256e 90E0      		ldi r25,hi8(strAug)
 10439 2570 0E94 0000 		call drawText
1253:main.c        **** 			break;
 10441               	.LM796:
 10442 2574 1FC0      		rjmp .L358
 10443               	.L367:
1254:main.c        **** 			case 9:
1255:main.c        **** 				drawText((unsigned char *)strSept,uStartColumn,uRow,boolInvert);	//show the month on the displa
 10445               	.LM797:
 10446 2576 2C81      		ldd r18,Y+4
 10447 2578 4A81      		ldd r20,Y+2
 10448 257a 6981      		ldd r22,Y+1
 10449 257c 80E0      		ldi r24,lo8(strSept)
 10450 257e 90E0      		ldi r25,hi8(strSept)
 10451 2580 0E94 0000 		call drawText
1256:main.c        **** 			break;
 10453               	.LM798:
 10454 2584 17C0      		rjmp .L358
 10455               	.L368:
1257:main.c        **** 			case 10:
1258:main.c        **** 				drawText((unsigned char *)strOct,uStartColumn,uRow,boolInvert);	//show the month on the display
 10457               	.LM799:
 10458 2586 2C81      		ldd r18,Y+4
 10459 2588 4A81      		ldd r20,Y+2
 10460 258a 6981      		ldd r22,Y+1
 10461 258c 80E0      		ldi r24,lo8(strOct)
 10462 258e 90E0      		ldi r25,hi8(strOct)
 10463 2590 0E94 0000 		call drawText
1259:main.c        **** 			break;
 10465               	.LM800:
 10466 2594 0FC0      		rjmp .L358
 10467               	.L369:
1260:main.c        **** 			case 11:		//November
1261:main.c        **** 				drawText((unsigned char *)strNov,uStartColumn,uRow,boolInvert);	//show the month on the display
 10469               	.LM801:
 10470 2596 2C81      		ldd r18,Y+4
 10471 2598 4A81      		ldd r20,Y+2
 10472 259a 6981      		ldd r22,Y+1
 10473 259c 80E0      		ldi r24,lo8(strNov)
 10474 259e 90E0      		ldi r25,hi8(strNov)
 10475 25a0 0E94 0000 		call drawText
1262:main.c        **** 			break;
 10477               	.LM802:
 10478 25a4 07C0      		rjmp .L358
 10479               	.L370:
1263:main.c        **** 			case 12:		//December
1264:main.c        **** 				drawText((unsigned char *)strDec,uStartColumn,uRow,boolInvert);	//show the month on the display
 10481               	.LM803:
 10482 25a6 2C81      		ldd r18,Y+4
 10483 25a8 4A81      		ldd r20,Y+2
 10484 25aa 6981      		ldd r22,Y+1
 10485 25ac 80E0      		ldi r24,lo8(strDec)
 10486 25ae 90E0      		ldi r25,hi8(strDec)
 10487 25b0 0E94 0000 		call drawText
 10488               	.L358:
1265:main.c        **** 			break;
1266:main.c        **** 		}
1267:main.c        **** 		write_char(0x00,false);	//write a space between the month and day
 10490               	.LM804:
 10491 25b4 60E0      		ldi r22,lo8(0)
 10492 25b6 80E0      		ldi r24,lo8(0)
 10493 25b8 0E94 0000 		call write_char
 10494 25bc 17C0      		rjmp .L374
 10495               	.L357:
1268:main.c        **** 	}
1269:main.c        **** 	else	//we are putting spaces in for the month
1270:main.c        **** 	{
1271:main.c        **** 		write_char(0x00,false);	//A white space to keep the day and year in their right place
 10497               	.LM805:
 10498 25be 60E0      		ldi r22,lo8(0)
 10499 25c0 80E0      		ldi r24,lo8(0)
 10500 25c2 0E94 0000 		call write_char
1272:main.c        **** 		write_char(0x00,false);
 10502               	.LM806:
 10503 25c6 60E0      		ldi r22,lo8(0)
 10504 25c8 80E0      		ldi r24,lo8(0)
 10505 25ca 0E94 0000 		call write_char
1273:main.c        **** 		write_char(0x00,false);
 10507               	.LM807:
 10508 25ce 60E0      		ldi r22,lo8(0)
 10509 25d0 80E0      		ldi r24,lo8(0)
 10510 25d2 0E94 0000 		call write_char
1274:main.c        **** 		write_char(0x00,false);
 10512               	.LM808:
 10513 25d6 60E0      		ldi r22,lo8(0)
 10514 25d8 80E0      		ldi r24,lo8(0)
 10515 25da 0E94 0000 		call write_char
1275:main.c        **** 		write_char(0x00,false);
 10517               	.LM809:
 10518 25de 60E0      		ldi r22,lo8(0)
 10519 25e0 80E0      		ldi r24,lo8(0)
 10520 25e2 0E94 0000 		call write_char
1276:main.c        **** 		write_data(0x00);		//this puts a verticle, one pixel space to keep the day and year in their corr
 10522               	.LM810:
 10523 25e6 80E0      		ldi r24,lo8(0)
 10524 25e8 0E94 0000 		call write_data
 10525               	.L374:
1277:main.c        **** 
1278:main.c        **** 	}
1279:main.c        **** 	if(uBlank!=2)	//are we blanking the day?
 10527               	.LM811:
 10528 25ec 8B81      		ldd r24,Y+3
 10529 25ee 8230      		cpi r24,lo8(2)
 10530 25f0 69F0      		breq .L375
1280:main.c        **** 	{
1281:main.c        **** 		write_small_numbers(t.intDay,false,2);	//put the day after the month, suppress leading 0
 10532               	.LM812:
 10533 25f2 42E0      		ldi r20,lo8(2)
 10534 25f4 60E0      		ldi r22,lo8(0)
 10535 25f6 8091 0000 		lds r24,t+6
 10536 25fa 9091 0000 		lds r25,(t+6)+1
 10537 25fe 0E94 0000 		call write_small_numbers
1282:main.c        **** 		write_char(12,false);	//This is a comma to display after the day
 10539               	.LM813:
 10540 2602 60E0      		ldi r22,lo8(0)
 10541 2604 8CE0      		ldi r24,lo8(12)
 10542 2606 0E94 0000 		call write_char
 10543 260a 0CC0      		rjmp .L376
 10544               	.L375:
1283:main.c        **** 	}
1284:main.c        **** 	else	//yes, we are putting up spaces where the day should be
1285:main.c        **** 	{
1286:main.c        **** 		write_char(0x00,false);	//A white space
 10546               	.LM814:
 10547 260c 60E0      		ldi r22,lo8(0)
 10548 260e 80E0      		ldi r24,lo8(0)
 10549 2610 0E94 0000 		call write_char
1287:main.c        **** 		write_char(0x00,false);	//A white space
 10551               	.LM815:
 10552 2614 60E0      		ldi r22,lo8(0)
 10553 2616 80E0      		ldi r24,lo8(0)
 10554 2618 0E94 0000 		call write_char
1288:main.c        **** 		write_char(0x00,false);	//A white space
 10556               	.LM816:
 10557 261c 60E0      		ldi r22,lo8(0)
 10558 261e 80E0      		ldi r24,lo8(0)
 10559 2620 0E94 0000 		call write_char
 10560               	.L376:
1289:main.c        **** 	}	
1290:main.c        **** 	if(uBlank!=3)	//are we blanking the year?
 10562               	.LM817:
 10563 2624 8B81      		ldd r24,Y+3
 10564 2626 8330      		cpi r24,lo8(3)
 10565 2628 89F0      		breq .L377
1291:main.c        **** 	{
1292:main.c        **** 		write_char(0x00,false);	//A white space after comma, between the day and year
 10567               	.LM818:
 10568 262a 60E0      		ldi r22,lo8(0)
 10569 262c 80E0      		ldi r24,lo8(0)
 10570 262e 0E94 0000 		call write_char
1293:main.c        **** 		write_char(18,false);		// put up a "2" for the first digit in year
 10572               	.LM819:
 10573 2632 60E0      		ldi r22,lo8(0)
 10574 2634 82E1      		ldi r24,lo8(18)
 10575 2636 0E94 0000 		call write_char
1294:main.c        **** 		write_small_numbers(t.intYear,false,3);	//put up the last three digits of the year, don't suppres
 10577               	.LM820:
 10578 263a 43E0      		ldi r20,lo8(3)
 10579 263c 60E0      		ldi r22,lo8(0)
 10580 263e 8091 0000 		lds r24,t+10
 10581 2642 9091 0000 		lds r25,(t+10)+1
 10582 2646 0E94 0000 		call write_small_numbers
 10583 264a 14C0      		rjmp .L356
 10584               	.L377:
1295:main.c        **** 	}
1296:main.c        **** 	else	//yes, we are blanking the year
1297:main.c        **** 	{
1298:main.c        **** 		write_char(0x00,false);	//A white space to cover whatever was there.
 10586               	.LM821:
 10587 264c 60E0      		ldi r22,lo8(0)
 10588 264e 80E0      		ldi r24,lo8(0)
 10589 2650 0E94 0000 		call write_char
1299:main.c        **** 		write_char(0x00,false);	//A white space 
 10591               	.LM822:
 10592 2654 60E0      		ldi r22,lo8(0)
 10593 2656 80E0      		ldi r24,lo8(0)
 10594 2658 0E94 0000 		call write_char
1300:main.c        **** 		write_char(0x00,false);	//A white space 
 10596               	.LM823:
 10597 265c 60E0      		ldi r22,lo8(0)
 10598 265e 80E0      		ldi r24,lo8(0)
 10599 2660 0E94 0000 		call write_char
1301:main.c        **** 		write_char(0x00,false);	//A white space 
 10601               	.LM824:
 10602 2664 60E0      		ldi r22,lo8(0)
 10603 2666 80E0      		ldi r24,lo8(0)
 10604 2668 0E94 0000 		call write_char
1302:main.c        **** 		write_char(0x00,false);	//A white space 
 10606               	.LM825:
 10607 266c 60E0      		ldi r22,lo8(0)
 10608 266e 80E0      		ldi r24,lo8(0)
 10609 2670 0E94 0000 		call write_char
 10610               	.L356:
 10611               	/* epilogue: frame size=6 */
 10612 2674 2696      		adiw r28,6
 10613 2676 0FB6      		in __tmp_reg__,__SREG__
 10614 2678 F894      		cli
 10615 267a DEBF      		out __SP_H__,r29
 10616 267c 0FBE      		out __SREG__,__tmp_reg__
 10617 267e CDBF      		out __SP_L__,r28
 10618 2680 DF91      		pop r29
 10619 2682 CF91      		pop r28
 10620 2684 0895      		ret
 10621               	/* epilogue end (size=9) */
 10622               	/* function write_date size 321 (302) */
 10628               	.global	write_small_numbers
 10630               	write_small_numbers:
1303:main.c        **** 	}
1304:main.c        **** }
1305:main.c        **** 
1306:main.c        **** //----------------------------------------------------------------------------
1307:main.c        **** //Routine:     write_small_numbers
1308:main.c        **** //
1309:main.c        **** //Function:		This routine takes a integer that is passed to it and displays
1310:main.c        **** //		the integer on the LCD.  It does this by doing a BCD conversion on the
1311:main.c        **** //		the integer.  The maximum input value is 999 and the lowest input value
1312:main.c        **** //		is 0.  (the number is displayed in 5x7 format)
1313:main.c        **** //			
1314:main.c        **** //Varibles passed:
1315:main.c        **** //		intSmallNum: 0 to 999, This number will be displayed on the LCD
1316:main.c        **** //		boolBlankZero:  if true, then blank the leading zeros
1317:main.c        **** //		uNumbersDisplayed:  1= one number displayed
1318:main.c        **** //			2=two numbers displayed
1319:main.c        **** //			3= three numbers displayed
1320:main.c        **** //Returns:
1321:main.c        **** //       none
1322:main.c        **** //----------------------------------------------------------------------------
1323:main.c        **** void write_small_numbers(unsigned int intSmallNum, bool boolBlankZero, unsigned char uNumbersDispla
1324:main.c        **** {
 10632               	.LM826:
 10633               	/* prologue: frame size=6 */
 10634 2686 CF93      		push r28
 10635 2688 DF93      		push r29
 10636 268a CDB7      		in r28,__SP_L__
 10637 268c DEB7      		in r29,__SP_H__
 10638 268e 2697      		sbiw r28,6
 10639 2690 0FB6      		in __tmp_reg__,__SREG__
 10640 2692 F894      		cli
 10641 2694 DEBF      		out __SP_H__,r29
 10642 2696 0FBE      		out __SREG__,__tmp_reg__
 10643 2698 CDBF      		out __SP_L__,r28
 10644               	/* prologue end (size=10) */
 10645 269a 8983      		std Y+1,r24
 10646 269c 9A83      		std Y+2,r25
 10647 269e 6B83      		std Y+3,r22
 10648 26a0 4C83      		std Y+4,r20
1325:main.c        **** 	unsigned char uGamma;
1326:main.c        **** 	unsigned char uBeta;
1327:main.c        **** 	
1328:main.c        **** 	
1329:main.c        **** 	integerToArray(intSmallNum);	//take an integer and convert (BCD) it into a 3 byte array
 10650               	.LM827:
 10651 26a2 8981      		ldd r24,Y+1
 10652 26a4 9A81      		ldd r25,Y+2
 10653 26a6 0E94 0000 		call integerToArray
1330:main.c        **** 	for(uGamma=1;uGamma<4;uGamma++)	//loop through the 3 digits in the array
 10655               	.LM828:
 10656 26aa 81E0      		ldi r24,lo8(1)
 10657 26ac 8D83      		std Y+5,r24
 10658               	.L380:
 10660               	.LM829:
 10661 26ae 8D81      		ldd r24,Y+5
 10662 26b0 8430      		cpi r24,lo8(4)
 10663 26b2 98F5      		brsh .L379
1331:main.c        **** 	{
1332:main.c        **** 		uBeta=str[uGamma]-32;		//convert a number in the array into an ASCII character
 10665               	.LM830:
 10666 26b4 8D81      		ldd r24,Y+5
 10667 26b6 9927      		clr r25
 10668 26b8 FC01      		movw r30,r24
 10669 26ba E050      		subi r30,lo8(-(str))
 10670 26bc F040      		sbci r31,hi8(-(str))
 10671 26be 8081      		ld r24,Z
 10672 26c0 8052      		subi r24,lo8(-(-32))
 10673 26c2 8E83      		std Y+6,r24
1333:main.c        **** 		if(boolBlankZero==false || uBeta!=16)	//do we need to blank the leading zeros?
 10675               	.LM831:
 10676 26c4 8B81      		ldd r24,Y+3
 10677 26c6 8823      		tst r24
 10678 26c8 21F0      		breq .L384
 10679 26ca 8E81      		ldd r24,Y+6
 10680 26cc 8031      		cpi r24,lo8(16)
 10681 26ce 09F4      		brne .L384
 10682 26d0 20C0      		rjmp .L382
 10683               	.L384:
1334:main.c        **** 		{
1335:main.c        **** 			if(uNumbersDisplayed==1 && uGamma==3)	//go in here only if we are displaying one digit
 10685               	.LM832:
 10686 26d2 8C81      		ldd r24,Y+4
 10687 26d4 8130      		cpi r24,lo8(1)
 10688 26d6 41F4      		brne .L385
 10689 26d8 8D81      		ldd r24,Y+5
 10690 26da 8330      		cpi r24,lo8(3)
 10691 26dc 29F4      		brne .L385
1336:main.c        **** 			{
1337:main.c        **** 				write_char(uBeta,false);	//put the character on the LCD
 10693               	.LM833:
 10694 26de 60E0      		ldi r22,lo8(0)
 10695 26e0 8E81      		ldd r24,Y+6
 10696 26e2 0E94 0000 		call write_char
 10697 26e6 15C0      		rjmp .L382
 10698               	.L385:
1338:main.c        **** 			}
1339:main.c        **** 			else if(uNumbersDisplayed ==2 && uGamma>=2)	//go in here only if we are displaying two digits
 10700               	.LM834:
 10701 26e8 8C81      		ldd r24,Y+4
 10702 26ea 8230      		cpi r24,lo8(2)
 10703 26ec 41F4      		brne .L387
 10704 26ee 8D81      		ldd r24,Y+5
 10705 26f0 8230      		cpi r24,lo8(2)
 10706 26f2 28F0      		brlo .L387
1340:main.c        **** 			{
1341:main.c        **** 				write_char(uBeta,false);	//put the character on the LCD
 10708               	.LM835:
 10709 26f4 60E0      		ldi r22,lo8(0)
 10710 26f6 8E81      		ldd r24,Y+6
 10711 26f8 0E94 0000 		call write_char
 10712 26fc 0AC0      		rjmp .L382
 10713               	.L387:
1342:main.c        **** 			}
1343:main.c        **** 			else if(uNumbersDisplayed ==3 && uGamma>=1)	//go in here only if we are displaying three digits
 10715               	.LM836:
 10716 26fe 8C81      		ldd r24,Y+4
 10717 2700 8330      		cpi r24,lo8(3)
 10718 2702 39F4      		brne .L382
 10719 2704 8D81      		ldd r24,Y+5
 10720 2706 8823      		tst r24
 10721 2708 21F0      		breq .L382
1344:main.c        **** 			{
1345:main.c        **** 				write_char(uBeta,false);	//put the character on the LCD
 10723               	.LM837:
 10724 270a 60E0      		ldi r22,lo8(0)
 10725 270c 8E81      		ldd r24,Y+6
 10726 270e 0E94 0000 		call write_char
 10727               	.L382:
 10729               	.LM838:
 10730 2712 8D81      		ldd r24,Y+5
 10731 2714 8F5F      		subi r24,lo8(-(1))
 10732 2716 8D83      		std Y+5,r24
 10733 2718 CACF      		rjmp .L380
 10734               	.L379:
 10735               	/* epilogue: frame size=6 */
 10736 271a 2696      		adiw r28,6
 10737 271c 0FB6      		in __tmp_reg__,__SREG__
 10738 271e F894      		cli
 10739 2720 DEBF      		out __SP_H__,r29
 10740 2722 0FBE      		out __SREG__,__tmp_reg__
 10741 2724 CDBF      		out __SP_L__,r28
 10742 2726 DF91      		pop r29
 10743 2728 CF91      		pop r28
 10744 272a 0895      		ret
 10745               	/* epilogue end (size=9) */
 10746               	/* function write_small_numbers size 84 (65) */
 10753               	.global	ShowLargeTime
 10755               	ShowLargeTime:
1346:main.c        **** 			}
1347:main.c        **** 		}
1348:main.c        **** 	}
1349:main.c        **** }
1350:main.c        **** 
1351:main.c        **** //----------------------------------------------------------------------------
1352:main.c        **** //Routine:     showLargeTime
1353:main.c        **** //
1354:main.c        **** //Function:		This routine displays the current time in large numbers,
1355:main.c        **** //		which is 24x16 format.  It displays AM or PM in small letters depending
1356:main.c        **** //		on the time of day.
1357:main.c        **** //			
1358:main.c        **** //Varibles passed:
1359:main.c        **** //		uStartColumn:  sets the upperleft hand X position of the time
1360:main.c        **** //		uRow:  sets the upper left hand Y pistion of the time
1361:main.c        **** //
1362:main.c        **** //Returns:
1363:main.c        **** //       none
1364:main.c        **** //----------------------------------------------------------------------------
1365:main.c        **** void ShowLargeTime(unsigned char uStartColumn, unsigned char uRow)
1366:main.c        **** {
 10757               	.LM839:
 10758               	/* prologue: frame size=4 */
 10759 272c 0F93      		push r16
 10760 272e CF93      		push r28
 10761 2730 DF93      		push r29
 10762 2732 CDB7      		in r28,__SP_L__
 10763 2734 DEB7      		in r29,__SP_H__
 10764 2736 2497      		sbiw r28,4
 10765 2738 0FB6      		in __tmp_reg__,__SREG__
 10766 273a F894      		cli
 10767 273c DEBF      		out __SP_H__,r29
 10768 273e 0FBE      		out __SREG__,__tmp_reg__
 10769 2740 CDBF      		out __SP_L__,r28
 10770               	/* prologue end (size=11) */
 10771 2742 8983      		std Y+1,r24
 10772 2744 6A83      		std Y+2,r22
1367:main.c        **** 	unsigned int intTempHour;
1368:main.c        **** 
1369:main.c        **** 	if(t.intHour>11)	//Do we need to set the PM notification?
 10774               	.LM840:
 10775 2746 8091 0000 		lds r24,t+4
 10776 274a 9091 0000 		lds r25,(t+4)+1
 10777 274e 8C30      		cpi r24,12
 10778 2750 9105      		cpc r25,__zero_reg__
 10779 2752 C8F0      		brlo .L391
1370:main.c        **** 	{
1371:main.c        **** 		intTempHour=t.intHour-12;	//yes, set the hours to approapriate time
 10781               	.LM841:
 10782 2754 8091 0000 		lds r24,t+4
 10783 2758 9091 0000 		lds r25,(t+4)+1
 10784 275c 0C97      		sbiw r24,12
 10785 275e 8B83      		std Y+3,r24
 10786 2760 9C83      		std Y+4,r25
1372:main.c        **** 		if(intTempHour==0)		//show 12 instead of the zero hour
 10788               	.LM842:
 10789 2762 8B81      		ldd r24,Y+3
 10790 2764 9C81      		ldd r25,Y+4
 10791 2766 0097      		sbiw r24,0
 10792 2768 21F4      		brne .L392
1373:main.c        **** 		{
1374:main.c        **** 			intTempHour=12;
 10794               	.LM843:
 10795 276a 8CE0      		ldi r24,lo8(12)
 10796 276c 90E0      		ldi r25,hi8(12)
 10797 276e 8B83      		std Y+3,r24
 10798 2770 9C83      		std Y+4,r25
 10799               	.L392:
1375:main.c        **** 		}
1376:main.c        **** 		drawText((unsigned char *)strPM,uStartColumn+95,uRow,false);	//show the PM indication
 10801               	.LM844:
 10802 2772 8981      		ldd r24,Y+1
 10803 2774 815A      		subi r24,lo8(-(95))
 10804 2776 20E0      		ldi r18,lo8(0)
 10805 2778 4A81      		ldd r20,Y+2
 10806 277a 682F      		mov r22,r24
 10807 277c 80E0      		ldi r24,lo8(strPM)
 10808 277e 90E0      		ldi r25,hi8(strPM)
 10809 2780 0E94 0000 		call drawText
 10810 2784 17C0      		rjmp .L393
 10811               	.L391:
1377:main.c        **** 	}
1378:main.c        **** 	else	//show the AM notification
1379:main.c        **** 	{
1380:main.c        **** 		intTempHour=t.intHour;	
 10813               	.LM845:
 10814 2786 8091 0000 		lds r24,t+4
 10815 278a 9091 0000 		lds r25,(t+4)+1
 10816 278e 8B83      		std Y+3,r24
 10817 2790 9C83      		std Y+4,r25
1381:main.c        **** 		if(intTempHour==0)
 10819               	.LM846:
 10820 2792 8B81      		ldd r24,Y+3
 10821 2794 9C81      		ldd r25,Y+4
 10822 2796 0097      		sbiw r24,0
 10823 2798 21F4      		brne .L394
1382:main.c        **** 		{
1383:main.c        **** 			intTempHour=12;	//show 12 instead of the 0 hour
 10825               	.LM847:
 10826 279a 8CE0      		ldi r24,lo8(12)
 10827 279c 90E0      		ldi r25,hi8(12)
 10828 279e 8B83      		std Y+3,r24
 10829 27a0 9C83      		std Y+4,r25
 10830               	.L394:
1384:main.c        **** 		}
1385:main.c        **** 		drawText((unsigned char *)strAM,uStartColumn+95,uRow,false);	//show the AM notification
 10832               	.LM848:
 10833 27a2 8981      		ldd r24,Y+1
 10834 27a4 815A      		subi r24,lo8(-(95))
 10835 27a6 20E0      		ldi r18,lo8(0)
 10836 27a8 4A81      		ldd r20,Y+2
 10837 27aa 682F      		mov r22,r24
 10838 27ac 80E0      		ldi r24,lo8(strAM)
 10839 27ae 90E0      		ldi r25,hi8(strAM)
 10840 27b0 0E94 0000 		call drawText
 10841               	.L393:
1386:main.c        **** 	}
1387:main.c        **** 	BigDigits(uRow,uStartColumn+45,t.intMin,2,false);	//show the minute 45 pixels after the start of t
 10843               	.LM849:
 10844 27b4 8981      		ldd r24,Y+1
 10845 27b6 835D      		subi r24,lo8(-(45))
 10846 27b8 00E0      		ldi r16,lo8(0)
 10847 27ba 22E0      		ldi r18,lo8(2)
 10848 27bc 4091 0000 		lds r20,t+2
 10849 27c0 5091 0000 		lds r21,(t+2)+1
 10850 27c4 682F      		mov r22,r24
 10851 27c6 8A81      		ldd r24,Y+2
 10852 27c8 0E94 0000 		call BigDigits
1388:main.c        **** 	subLargeCOlon(uRow,uStartColumn+45,false);		//show the colon between the hour and minute
 10854               	.LM850:
 10855 27cc 8981      		ldd r24,Y+1
 10856 27ce 835D      		subi r24,lo8(-(45))
 10857 27d0 40E0      		ldi r20,lo8(0)
 10858 27d2 682F      		mov r22,r24
 10859 27d4 8A81      		ldd r24,Y+2
 10860 27d6 0E94 0000 		call subLargeCOlon
1389:main.c        **** 	BigDigits(uRow,uStartColumn,intTempHour,0,false);	//show the hour, we don't need to see the 0 in t
 10862               	.LM851:
 10863 27da 00E0      		ldi r16,lo8(0)
 10864 27dc 20E0      		ldi r18,lo8(0)
 10865 27de 4B81      		ldd r20,Y+3
 10866 27e0 5C81      		ldd r21,Y+4
 10867 27e2 6981      		ldd r22,Y+1
 10868 27e4 8A81      		ldd r24,Y+2
 10869 27e6 0E94 0000 		call BigDigits
 10870               	/* epilogue: frame size=4 */
 10871 27ea 2496      		adiw r28,4
 10872 27ec 0FB6      		in __tmp_reg__,__SREG__
 10873 27ee F894      		cli
 10874 27f0 DEBF      		out __SP_H__,r29
 10875 27f2 0FBE      		out __SREG__,__tmp_reg__
 10876 27f4 CDBF      		out __SP_L__,r28
 10877 27f6 DF91      		pop r29
 10878 27f8 CF91      		pop r28
 10879 27fa 0F91      		pop r16
 10880 27fc 0895      		ret
 10881               	/* epilogue end (size=10) */
 10882               	/* function ShowLargeTime size 105 (84) */
 10888               	.global	ShowLargeAlarmTime
 10890               	ShowLargeAlarmTime:
1390:main.c        **** 
1391:main.c        **** }
1392:main.c        **** 
1393:main.c        **** //----------------------------------------------------------------------------
1394:main.c        **** //Routine:     showLargeAlarmTime
1395:main.c        **** //
1396:main.c        **** //Function:		This routine displays the alarm time in large numbers,
1397:main.c        **** //		which is 24x16 format.  It displays AM or PM in small letters depending
1398:main.c        **** //		on the time of day.
1399:main.c        **** //			
1400:main.c        **** //Varibles passed:
1401:main.c        **** //		uStartColumn:  sets the upperleft hand X position of the time
1402:main.c        **** //		uRow:  sets the upper left hand Y pistion of the time
1403:main.c        **** //
1404:main.c        **** //Returns:
1405:main.c        **** //       none
1406:main.c        **** //----------------------------------------------------------------------------
1407:main.c        **** void ShowLargeAlarmTime(unsigned char uStartColumn, unsigned char uRow)
1408:main.c        **** {
 10892               	.LM852:
 10893               	/* prologue: frame size=4 */
 10894 27fe 0F93      		push r16
 10895 2800 CF93      		push r28
 10896 2802 DF93      		push r29
 10897 2804 CDB7      		in r28,__SP_L__
 10898 2806 DEB7      		in r29,__SP_H__
 10899 2808 2497      		sbiw r28,4
 10900 280a 0FB6      		in __tmp_reg__,__SREG__
 10901 280c F894      		cli
 10902 280e DEBF      		out __SP_H__,r29
 10903 2810 0FBE      		out __SREG__,__tmp_reg__
 10904 2812 CDBF      		out __SP_L__,r28
 10905               	/* prologue end (size=11) */
 10906 2814 8983      		std Y+1,r24
 10907 2816 6A83      		std Y+2,r22
1409:main.c        **** 	unsigned int intTempHour;
1410:main.c        **** 
1411:main.c        **** 	if(intAlarmHour>11)	//Do we need to set the PM notification?
 10909               	.LM853:
 10910 2818 8091 0000 		lds r24,intAlarmHour
 10911 281c 9091 0000 		lds r25,(intAlarmHour)+1
 10912 2820 8C30      		cpi r24,12
 10913 2822 9105      		cpc r25,__zero_reg__
 10914 2824 C8F0      		brlo .L396
1412:main.c        **** 	{
1413:main.c        **** 		intTempHour=intAlarmHour-12;	//yes, set the hours to approapriate time
 10916               	.LM854:
 10917 2826 8091 0000 		lds r24,intAlarmHour
 10918 282a 9091 0000 		lds r25,(intAlarmHour)+1
 10919 282e 0C97      		sbiw r24,12
 10920 2830 8B83      		std Y+3,r24
 10921 2832 9C83      		std Y+4,r25
1414:main.c        **** 		if(intTempHour==0)		//show 12 instead of the zero hour
 10923               	.LM855:
 10924 2834 8B81      		ldd r24,Y+3
 10925 2836 9C81      		ldd r25,Y+4
 10926 2838 0097      		sbiw r24,0
 10927 283a 21F4      		brne .L397
1415:main.c        **** 		{
1416:main.c        **** 			intTempHour=12;
 10929               	.LM856:
 10930 283c 8CE0      		ldi r24,lo8(12)
 10931 283e 90E0      		ldi r25,hi8(12)
 10932 2840 8B83      		std Y+3,r24
 10933 2842 9C83      		std Y+4,r25
 10934               	.L397:
1417:main.c        **** 		}
1418:main.c        **** 		drawText((unsigned char *)strPM,uStartColumn+95,uRow,false);	//show the PM indication
 10936               	.LM857:
 10937 2844 8981      		ldd r24,Y+1
 10938 2846 815A      		subi r24,lo8(-(95))
 10939 2848 20E0      		ldi r18,lo8(0)
 10940 284a 4A81      		ldd r20,Y+2
 10941 284c 682F      		mov r22,r24
 10942 284e 80E0      		ldi r24,lo8(strPM)
 10943 2850 90E0      		ldi r25,hi8(strPM)
 10944 2852 0E94 0000 		call drawText
 10945 2856 17C0      		rjmp .L398
 10946               	.L396:
1419:main.c        **** 	}
1420:main.c        **** 	else	//show the AM notification
1421:main.c        **** 	{
1422:main.c        **** 		intTempHour=intAlarmHour;	
 10948               	.LM858:
 10949 2858 8091 0000 		lds r24,intAlarmHour
 10950 285c 9091 0000 		lds r25,(intAlarmHour)+1
 10951 2860 8B83      		std Y+3,r24
 10952 2862 9C83      		std Y+4,r25
1423:main.c        **** 		if(intTempHour==0)
 10954               	.LM859:
 10955 2864 8B81      		ldd r24,Y+3
 10956 2866 9C81      		ldd r25,Y+4
 10957 2868 0097      		sbiw r24,0
 10958 286a 21F4      		brne .L399
1424:main.c        **** 		{
1425:main.c        **** 			intTempHour=12;	//show 12 instead of the 0 hour
 10960               	.LM860:
 10961 286c 8CE0      		ldi r24,lo8(12)
 10962 286e 90E0      		ldi r25,hi8(12)
 10963 2870 8B83      		std Y+3,r24
 10964 2872 9C83      		std Y+4,r25
 10965               	.L399:
1426:main.c        **** 		}
1427:main.c        **** 		drawText((unsigned char *)strAM,uStartColumn+95,uRow,false);	//show the AM notification
 10967               	.LM861:
 10968 2874 8981      		ldd r24,Y+1
 10969 2876 815A      		subi r24,lo8(-(95))
 10970 2878 20E0      		ldi r18,lo8(0)
 10971 287a 4A81      		ldd r20,Y+2
 10972 287c 682F      		mov r22,r24
 10973 287e 80E0      		ldi r24,lo8(strAM)
 10974 2880 90E0      		ldi r25,hi8(strAM)
 10975 2882 0E94 0000 		call drawText
 10976               	.L398:
1428:main.c        **** 	}
1429:main.c        **** 	BigDigits(uRow,uStartColumn+45,intAlarmMin,2,false);	//show the minute 45 pixels after the start o
 10978               	.LM862:
 10979 2886 8981      		ldd r24,Y+1
 10980 2888 835D      		subi r24,lo8(-(45))
 10981 288a 00E0      		ldi r16,lo8(0)
 10982 288c 22E0      		ldi r18,lo8(2)
 10983 288e 4091 0000 		lds r20,intAlarmMin
 10984 2892 5091 0000 		lds r21,(intAlarmMin)+1
 10985 2896 682F      		mov r22,r24
 10986 2898 8A81      		ldd r24,Y+2
 10987 289a 0E94 0000 		call BigDigits
1430:main.c        **** 	subLargeCOlon(uRow,uStartColumn+45,false);		//show the colon between the hour and minute
 10989               	.LM863:
 10990 289e 8981      		ldd r24,Y+1
 10991 28a0 835D      		subi r24,lo8(-(45))
 10992 28a2 40E0      		ldi r20,lo8(0)
 10993 28a4 682F      		mov r22,r24
 10994 28a6 8A81      		ldd r24,Y+2
 10995 28a8 0E94 0000 		call subLargeCOlon
1431:main.c        **** 	BigDigits(uRow,uStartColumn,intTempHour,0,false);	//show the hour, we don't need to see the 0 in t
 10997               	.LM864:
 10998 28ac 00E0      		ldi r16,lo8(0)
 10999 28ae 20E0      		ldi r18,lo8(0)
 11000 28b0 4B81      		ldd r20,Y+3
 11001 28b2 5C81      		ldd r21,Y+4
 11002 28b4 6981      		ldd r22,Y+1
 11003 28b6 8A81      		ldd r24,Y+2
 11004 28b8 0E94 0000 		call BigDigits
 11005               	/* epilogue: frame size=4 */
 11006 28bc 2496      		adiw r28,4
 11007 28be 0FB6      		in __tmp_reg__,__SREG__
 11008 28c0 F894      		cli
 11009 28c2 DEBF      		out __SP_H__,r29
 11010 28c4 0FBE      		out __SREG__,__tmp_reg__
 11011 28c6 CDBF      		out __SP_L__,r28
 11012 28c8 DF91      		pop r29
 11013 28ca CF91      		pop r28
 11014 28cc 0F91      		pop r16
 11015 28ce 0895      		ret
 11016               	/* epilogue end (size=10) */
 11017               	/* function ShowLargeAlarmTime size 105 (84) */
 11021               	.global	setBacklightOffTime
 11023               	setBacklightOffTime:
1432:main.c        **** 
1433:main.c        **** }
1434:main.c        **** 
1435:main.c        **** //----------------------------------------------------------------------------
1436:main.c        **** //Routine:     setBacklightOffTime
1437:main.c        **** //
1438:main.c        **** //Function:		This routine is for the "setting of the backlight times" menu selection.
1439:main.c        **** //		It formats line 2 (from the top of the screen) to allow the user to change the 
1440:main.c        **** //		backlight off hour.  It formats the line by putting up the hour, colon, the minute(00),
1441:main.c        **** //		and the AM or PM label.  
1442:main.c        **** //			
1443:main.c        **** //Varibles passed:
1444:main.c        **** //		none
1445:main.c        **** //
1446:main.c        **** //Returns:
1447:main.c        **** //      none
1448:main.c        **** //----------------------------------------------------------------------------
1449:main.c        **** void setBacklightOffTime(void)
1450:main.c        **** {
 11025               	.LM865:
 11026               	/* prologue: frame size=0 */
 11027 28d0 CF93      		push r28
 11028 28d2 DF93      		push r29
 11029 28d4 CDB7      		in r28,__SP_L__
 11030 28d6 DEB7      		in r29,__SP_H__
 11031               	/* prologue end (size=4) */
1451:main.c        **** 	set_line(2);	//line 2 will have the backlight off time, only the hour is adjustable
 11033               	.LM866:
 11034 28d8 82E0      		ldi r24,lo8(2)
 11035 28da 0E94 0000 		call set_line
1452:main.c        **** 	write_pixel_spaces(20);	//move in the left side of the screen a bit
 11037               	.LM867:
 11038 28de 84E1      		ldi r24,lo8(20)
 11039 28e0 0E94 0000 		call write_pixel_spaces
1453:main.c        **** 	if(uBacklightOffHour<=12)	//do we need to show the AM time?
 11041               	.LM868:
 11042 28e4 8091 0000 		lds r24,uBacklightOffHour
 11043 28e8 8D30      		cpi r24,lo8(13)
 11044 28ea 98F4      		brsh .L401
1454:main.c        **** 	{
1455:main.c        **** 		if(uBacklightOffHour==0)	//when the hour is zero, it is actually 12:00am
 11046               	.LM869:
 11047 28ec 8091 0000 		lds r24,uBacklightOffHour
 11048 28f0 8823      		tst r24
 11049 28f2 39F4      		brne .L402
1456:main.c        **** 		{
1457:main.c        **** 			write_small_numbers(12,false,2);	//show the AM time (hour)
 11051               	.LM870:
 11052 28f4 42E0      		ldi r20,lo8(2)
 11053 28f6 60E0      		ldi r22,lo8(0)
 11054 28f8 8CE0      		ldi r24,lo8(12)
 11055 28fa 90E0      		ldi r25,hi8(12)
 11056 28fc 0E94 0000 		call write_small_numbers
 11057 2900 10C0      		rjmp .L404
 11058               	.L402:
1458:main.c        **** 		}
1459:main.c        **** 		else
1460:main.c        **** 		{
1461:main.c        **** 			write_small_numbers(uBacklightOffHour,false,2);	//show the AM time (hour)
 11060               	.LM871:
 11061 2902 8091 0000 		lds r24,uBacklightOffHour
 11062 2906 9927      		clr r25
 11063 2908 42E0      		ldi r20,lo8(2)
 11064 290a 60E0      		ldi r22,lo8(0)
 11065 290c 0E94 0000 		call write_small_numbers
 11066 2910 08C0      		rjmp .L404
 11067               	.L401:
1462:main.c        **** 		}
1463:main.c        **** 	}
1464:main.c        **** 	else
1465:main.c        **** 	{
1466:main.c        **** 		write_small_numbers(uBacklightOffHour-12,false,2);	//show the pM time (hour)
 11069               	.LM872:
 11070 2912 8091 0000 		lds r24,uBacklightOffHour
 11071 2916 9927      		clr r25
 11072 2918 0C97      		sbiw r24,12
 11073 291a 42E0      		ldi r20,lo8(2)
 11074 291c 60E0      		ldi r22,lo8(0)
 11075 291e 0E94 0000 		call write_small_numbers
 11076               	.L404:
1467:main.c        **** 	}
1468:main.c        **** 	drawText((unsigned char *)strColonZero,255,255,false);	//colum, row, no highlight, show ":00" for 
 11078               	.LM873:
 11079 2922 20E0      		ldi r18,lo8(0)
 11080 2924 4FEF      		ldi r20,lo8(-1)
 11081 2926 6FEF      		ldi r22,lo8(-1)
 11082 2928 80E0      		ldi r24,lo8(strColonZero)
 11083 292a 90E0      		ldi r25,hi8(strColonZero)
 11084 292c 0E94 0000 		call drawText
1469:main.c        **** 	if(uBacklightOffHour<12)	//do we need to put up the AM or PM label?
 11086               	.LM874:
 11087 2930 8091 0000 		lds r24,uBacklightOffHour
 11088 2934 8C30      		cpi r24,lo8(12)
 11089 2936 40F4      		brsh .L405
1470:main.c        **** 	{
1471:main.c        **** 		drawText((unsigned char *)strAM,255,255,false);	//colum, row, no highlight, put up the AM label
 11091               	.LM875:
 11092 2938 20E0      		ldi r18,lo8(0)
 11093 293a 4FEF      		ldi r20,lo8(-1)
 11094 293c 6FEF      		ldi r22,lo8(-1)
 11095 293e 80E0      		ldi r24,lo8(strAM)
 11096 2940 90E0      		ldi r25,hi8(strAM)
 11097 2942 0E94 0000 		call drawText
 11098 2946 07C0      		rjmp .L400
 11099               	.L405:
1472:main.c        **** 	}
1473:main.c        **** 	else
1474:main.c        **** 	{
1475:main.c        **** 		drawText((unsigned char *)strPM,255,255,false);	//colum, row, no highlight, put up the PM label
 11101               	.LM876:
 11102 2948 20E0      		ldi r18,lo8(0)
 11103 294a 4FEF      		ldi r20,lo8(-1)
 11104 294c 6FEF      		ldi r22,lo8(-1)
 11105 294e 80E0      		ldi r24,lo8(strPM)
 11106 2950 90E0      		ldi r25,hi8(strPM)
 11107 2952 0E94 0000 		call drawText
 11108               	.L400:
 11109               	/* epilogue: frame size=0 */
 11110 2956 DF91      		pop r29
 11111 2958 CF91      		pop r28
 11112 295a 0895      		ret
 11113               	/* epilogue end (size=3) */
 11114               	/* function setBacklightOffTime size 70 (63) */
 11117               	.global	setBacklightOnTime
 11119               	setBacklightOnTime:
1476:main.c        **** 	}
1477:main.c        **** }
1478:main.c        **** 
1479:main.c        **** //----------------------------------------------------------------------------
1480:main.c        **** //Routine:     setBacklightOnTime
1481:main.c        **** //
1482:main.c        **** //Function:		This routine is for the "setting of the backlight times" menu selection.
1483:main.c        **** //		It formats line 5 (from the top of the screen) to allow the user to change the 
1484:main.c        **** //		backlight on hour.  It formats the line by putting up the hour, colon, the minute(00),
1485:main.c        **** //		and the AM or PM label.  
1486:main.c        **** //			
1487:main.c        **** //Varibles passed:
1488:main.c        **** //		none
1489:main.c        **** //
1490:main.c        **** //Returns:
1491:main.c        **** //      none
1492:main.c        **** //----------------------------------------------------------------------------
1493:main.c        **** void setBacklightOnTime(void)
1494:main.c        **** {
 11121               	.LM877:
 11122               	/* prologue: frame size=0 */
 11123 295c CF93      		push r28
 11124 295e DF93      		push r29
 11125 2960 CDB7      		in r28,__SP_L__
 11126 2962 DEB7      		in r29,__SP_H__
 11127               	/* prologue end (size=4) */
1495:main.c        **** 	set_line(5);	//line 5 will have the backlight on time, only the hour is adjustable
 11129               	.LM878:
 11130 2964 85E0      		ldi r24,lo8(5)
 11131 2966 0E94 0000 		call set_line
1496:main.c        **** 	write_pixel_spaces(20);	//move in the left side of the screen a bit
 11133               	.LM879:
 11134 296a 84E1      		ldi r24,lo8(20)
 11135 296c 0E94 0000 		call write_pixel_spaces
1497:main.c        **** 	if(uBacklightOnHour<=12)
 11137               	.LM880:
 11138 2970 8091 0000 		lds r24,uBacklightOnHour
 11139 2974 8D30      		cpi r24,lo8(13)
 11140 2976 98F4      		brsh .L408
1498:main.c        **** 	{
1499:main.c        **** 		if(uBacklightOnHour==0)		//when the hour is zero, it is actually 12:00am
 11142               	.LM881:
 11143 2978 8091 0000 		lds r24,uBacklightOnHour
 11144 297c 8823      		tst r24
 11145 297e 39F4      		brne .L409
1500:main.c        **** 		{
1501:main.c        **** 			write_small_numbers(12,false,2);	//show the AM time (hour)
 11147               	.LM882:
 11148 2980 42E0      		ldi r20,lo8(2)
 11149 2982 60E0      		ldi r22,lo8(0)
 11150 2984 8CE0      		ldi r24,lo8(12)
 11151 2986 90E0      		ldi r25,hi8(12)
 11152 2988 0E94 0000 		call write_small_numbers
 11153 298c 10C0      		rjmp .L411
 11154               	.L409:
1502:main.c        **** 		}
1503:main.c        **** 		else
1504:main.c        **** 		{
1505:main.c        **** 			write_small_numbers(uBacklightOnHour,false,2);	//show the AM time (hour)
 11156               	.LM883:
 11157 298e 8091 0000 		lds r24,uBacklightOnHour
 11158 2992 9927      		clr r25
 11159 2994 42E0      		ldi r20,lo8(2)
 11160 2996 60E0      		ldi r22,lo8(0)
 11161 2998 0E94 0000 		call write_small_numbers
 11162 299c 08C0      		rjmp .L411
 11163               	.L408:
1506:main.c        **** 		}
1507:main.c        **** 	}
1508:main.c        **** 	else
1509:main.c        **** 	{
1510:main.c        **** 		write_small_numbers(uBacklightOnHour-12,false,2);	//show the pM time (hour)
 11165               	.LM884:
 11166 299e 8091 0000 		lds r24,uBacklightOnHour
 11167 29a2 9927      		clr r25
 11168 29a4 0C97      		sbiw r24,12
 11169 29a6 42E0      		ldi r20,lo8(2)
 11170 29a8 60E0      		ldi r22,lo8(0)
 11171 29aa 0E94 0000 		call write_small_numbers
 11172               	.L411:
1511:main.c        **** 	}
1512:main.c        **** 	drawText((unsigned char *)strColonZero,255,255,false);	//colum, row, no highlight, show ":00" for 
 11174               	.LM885:
 11175 29ae 20E0      		ldi r18,lo8(0)
 11176 29b0 4FEF      		ldi r20,lo8(-1)
 11177 29b2 6FEF      		ldi r22,lo8(-1)
 11178 29b4 80E0      		ldi r24,lo8(strColonZero)
 11179 29b6 90E0      		ldi r25,hi8(strColonZero)
 11180 29b8 0E94 0000 		call drawText
1513:main.c        **** 	if(uBacklightOnHour<12)		//do we need to put up the AM or PM label?
 11182               	.LM886:
 11183 29bc 8091 0000 		lds r24,uBacklightOnHour
 11184 29c0 8C30      		cpi r24,lo8(12)
 11185 29c2 40F4      		brsh .L412
1514:main.c        **** 	{
1515:main.c        **** 		drawText((unsigned char *)strAM,255,255,false);	//colum, row, no highlight, put up the AM label
 11187               	.LM887:
 11188 29c4 20E0      		ldi r18,lo8(0)
 11189 29c6 4FEF      		ldi r20,lo8(-1)
 11190 29c8 6FEF      		ldi r22,lo8(-1)
 11191 29ca 80E0      		ldi r24,lo8(strAM)
 11192 29cc 90E0      		ldi r25,hi8(strAM)
 11193 29ce 0E94 0000 		call drawText
 11194 29d2 07C0      		rjmp .L407
 11195               	.L412:
1516:main.c        **** 	}
1517:main.c        **** 	else
1518:main.c        **** 	{
1519:main.c        **** 		drawText((unsigned char *)strPM,255,255,false);	//colum, row, no highlight, put up the PM label
 11197               	.LM888:
 11198 29d4 20E0      		ldi r18,lo8(0)
 11199 29d6 4FEF      		ldi r20,lo8(-1)
 11200 29d8 6FEF      		ldi r22,lo8(-1)
 11201 29da 80E0      		ldi r24,lo8(strPM)
 11202 29dc 90E0      		ldi r25,hi8(strPM)
 11203 29de 0E94 0000 		call drawText
 11204               	.L407:
 11205               	/* epilogue: frame size=0 */
 11206 29e2 DF91      		pop r29
 11207 29e4 CF91      		pop r28
 11208 29e6 0895      		ret
 11209               	/* epilogue end (size=3) */
 11210               	/* function setBacklightOnTime size 70 (63) */
 11212               		.comm uSelectedLine,1,1
 11213               		.comm str,5,1
 11214               		.comm pts,2,1
 11215               		.comm uTimeSetState,1,1
 11216               		.comm intAlarmMin,2,1
 11217               		.comm intAlarmHour,2,1
 11218               		.comm intUserPhotoTriggerValue,2,1
 11219               		.comm uBacklightOnHour,1,1
 11220               		.comm uBacklightOffHour,1,1
 11221               		.comm intPhotocellValue,2,1
 11222               		.comm t,12,1
 11298               		.text
 11300               	Letext:
 11301               	/* File "main.c": code 5408 = 0x1520 (4830), prologues 309, epilogues 269 */
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
                            *ABS*:0000003f __SREG__
                            *ABS*:0000003e __SP_H__
                            *ABS*:0000003d __SP_L__
                            *ABS*:00000000 __tmp_reg__
                            *ABS*:00000001 __zero_reg__
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:83     .progmem.data:00000000 font5x7
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:567    .progmem.data:000003c0 strSetTheTime
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:584    .progmem.data:000003cd strSetTheAlarm
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:602    .progmem.data:000003db strTarget
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:613    .progmem.data:000003e2 strLock
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:622    .progmem.data:000003e7 strPatrol
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:633    .progmem.data:000003ee strHow
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:650    .progmem.data:000003fb strAudio
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:663    .progmem.data:00000404 strRange
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:676    .progmem.data:0000040d strRequals
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:684    .progmem.data:00000411 strAlarmOff
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:698    .progmem.data:0000041b strAlarmOn
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:711    .progmem.data:00000424 strJan
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:720    .progmem.data:00000429 strFeb
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:729    .progmem.data:0000042e strMarch
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:738    .progmem.data:00000433 strApril
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:747    .progmem.data:00000438 strMay
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:756    .progmem.data:0000043d strJune
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:765    .progmem.data:00000442 strJuly
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:774    .progmem.data:00000447 strAug
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:783    .progmem.data:0000044c strSept
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:792    .progmem.data:00000451 strOct
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:801    .progmem.data:00000456 strNov
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:810    .progmem.data:0000045b strDec
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:819    .progmem.data:00000460 strAM
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:826    .progmem.data:00000463 strPM
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:833    .progmem.data:00000466 strPhotoTriggerValue
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:857    .progmem.data:0000047a strDarkRoom
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:875    .progmem.data:00000488 strBrightRoom
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:895    .progmem.data:00000498 strPhotocellReading
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:914    .progmem.data:000004a7 strSetTriggerValue
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:937    .progmem.data:000004ba strBacklightOffTime
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:960    .progmem.data:000004cd strBacklightOnTime
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:982    .progmem.data:000004df strUsuallyTen
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:1004   .progmem.data:000004f1 strUsuallySix
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:1025   .progmem.data:00000502 strColonZero
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:1033   .progmem.data:00000506 strBigFont0
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:1517   .progmem.data:000006e6 strBigFontPeriod
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:1569   .progmem.data:00000716 strBigFontColon
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:1621   .progmem.data:00000746 strSegTbl
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:1635   .progmem.data:00000750 str50
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:1757   .progmem.data:00000800 str51
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:1874   .progmem.data:000008b0 str64
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:2005   .progmem.data:00000960 strKustom
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:3033   .progmem.data:00000d60 strStop
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4065   .data:00000000 uTock
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4072   .bss:00000000 uState
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4078   .data:00000002 uTmrState
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4085   .bss:00000001 uBtnUpTmr
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4091   .bss:00000002 uBtnDwnTmr
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4097   .bss:00000003 uBtnEnterTmr
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4103   .data:00000003 uBob
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4108   .data:00000004 uTmrGeneral
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4113   .data:00000005 uContrast
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4120   .bss:00000004 boolSoundAlarm
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4126   .bss:00000005 boolAlarmOn
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4132   .data:00000006 boolPowerupBlink
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4139   .bss:00000006 uRefreshDisplay
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4145   .eeprom:00000000 EEKey
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4150   .eeprom:00000002 EEMinute
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4155   .eeprom:00000004 EEHour
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4160   .eeprom:00000006 EEPhotoTriggerValue
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4165   .eeprom:00000008 EEBacklightOnHour
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4170   .eeprom:00000009 EEBacklightOffHour
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4179   .text:00000000 set_line
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:10139  .text:00002390 write_command
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4232   .text:00000042 write_data
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4304   .text:000000b6 send_serial_data
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4461   .text:0000017c write_char
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4586   .text:00000212 clear_display
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4663   .text:00000268 get_status
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4739   .text:000002de moveCursorToColumn
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4817   .text:0000033e write_pixel_spaces
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:4873   .text:0000037e alphabet
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:5028   .text:0000042e kustom_image
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:5133   .text:000004b2 stop_image
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:5243   .text:00000536 BigDigits
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:7125   .text:00000fec integerToArray
                            *COM*:00000005 str
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:5803   .text:00000836 write_eagle_display
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:5980   .text:0000090a subLargeCOlon
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:5852   .text:00000872 drawText
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:6243   .text:00000a46 paintMenu
                            *COM*:00000001 uSelectedLine
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:6383   .text:00000b10 uCinit
                            *COM*:00000002 intAlarmMin
                            *COM*:00000002 intAlarmHour
                            *COM*:00000002 intUserPhotoTriggerValue
                            *COM*:00000001 uBacklightOnHour
                            *COM*:00000001 uBacklightOffHour
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:6632   .text:00000ca8 __vector_11
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:6680   .text:00000cee __vector_5
                            *COM*:0000000c t
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:7052   .text:00000f80 not_leap
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:6935   .text:00000ef8 __vector_13
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:6963   .text:00000f18 __vector_1
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:6991   .text:00000f38 main
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:10050  .text:00002318 InitLCD
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:7258   .text:000010aa SrvTock
                            *COM*:00000002 intPhotocellValue
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:10755  .text:0000272c ShowLargeTime
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:10214  .text:00002404 write_date
                            *COM*:00000001 uTimeSetState
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:10890  .text:000027fe ShowLargeAlarmTime
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:11023  .text:000028d0 setBacklightOffTime
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:11119  .text:0000295c setBacklightOnTime
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:10630  .text:00002686 write_small_numbers
                            *COM*:00000002 pts
C:\DOCUME~1\Owner\LOCALS~1\Temp/ccaebaaa.s:11300  .text:000029e8 Letext

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
eeprom_read_word
eeprom_write_word
eeprom_write_byte
eeprom_read_byte
__stack
__udivmodhi4
strcpy
