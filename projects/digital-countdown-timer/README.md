# digital countdown timer

Uploaded by arora_vaibhav on 2007-07-20 15:18:00 (rating 0 out of 5)

## Summary


This was a project undertaken by my colleague and me under  

Prof. D V GADRE ,who guided us throughout the process from conceptualization till its execution.


The Kitchen Timer is an electronic timer which uses Atmega -8L microcontroller running at 32 KHz frequency ,an external crystal, two Thumbwheel switches ,a buzzer ;for the alarm sound ;and a restart switch .It keeps time accurate to 1/10 of a second.


The timer incorporates the following components:-


 1. Microcontroller  

 An Atmega 8L microcontroller which uses an external crystal of 32 KHz for its clock frequency. 


2. Thumb Wheel Switches  

A couple of thumbwheel switches are used to set the alarm time of the timer clock. The thumb wheel switches provide the input time as a BCD number which is converted into the corresponding binary value explicitly in the program.


3. External Crystal  

The crystal running at 32 KHz is used to generate interrupts every 1 second, creating a real time clock.


4. Power supply  

The timer runs on a 3 V Lithium Manganese Dioxide Battery;  

CR-2032.


Features  

1. Power down mode  

When not in working state the microcontroller automatically goes into power down mode.


2. Any time restart  

The timer can be restarted at any time , even during the execution of a previous timer.


3. Low power consumption  

The timer consumes a very load current of 0.175 mA at running condition and 1ÂµA when in idle state. This causes the power consumption to drop down to almost 1/100 of the running mode power.


Operation


The microcontroller when idle goes into the power down state. The Thumb wheel switch has its output pins connected to the ports of microcontroller chip which have been initialized as input ports. The Thumbwheel switch provides logic zero value at input ports corresponding to the BCD value of the time selected. This value is read only when an interrupt is generated by pressing the switch, thus causing the chip to come into the normal running mode. At this point of time, the BCD value of the time is explicitly converted to its corresponding binary value and the timer countdown is initiated. The timer generates an overflow interrupt every second, providing a blink of LED for feedback purposes. This timer loads a flag to indicate the end of time interval. Now the buzzer goes off; the buzzer pattern utilizes the same timer in the chip but with different delay.  

The buzzer stops ringing after five rounds of beep patterns and the system goes into the power down mode again.


Source code  

//CODE FOR THE KITCHEN TIMER  

#include //include files  

#include //for timer overflow vect and INT0 vector  

typedef unsigned char byte;  

byte i=0,j=0;  

byte flag=0; /*  

flag :keeps an account of the current  

process  

flag=0 ;powerdown mode (idle state)  

flag=1 ;timer initited  

flag=2 ;end of the allocated time,  

alarm goes off  

flag=3 ;entire cycle of timer ends  

*/  

unsigned char time; //time :holds the value of the alarm time  

void buzzer(); //function initialisation for the buzzer pattern  

void delay(int var) //delay of 10ms for var=1  

{  

int i;  

byte j, k;  

for (i=0; i
for (k=0; k<249; k++)  

asm("NOP"); //no operation for 1 clock pulse  

9  

}  

/*------------------------EXTERNAL INTERRUPT0----------------------------------------------  

the BCD value at the thumb wheel switched is read;converted to binary and the timer is  

initiated  

*/  

ISR(INT0\_vect)  

{  

PORTB=0xFF;  

PORTC=0xFF;  

byte msb,lsb; //hold the MSB and LSB of the value at the thumb wheel  

switch  

msb=PINC; //rading the values from the desired PINs of the chip  

msb=~msb;  

msb&=0X0f;  

delay(1);  

lsb=PINB;  

lsb=~lsb;  

lsb&=0x0F;  

time=msb*10+lsb; //conversion to binary char value  

PORTD=0b11101111; //LED glows :indicates that the thumbwheel switch  

has been read  

delay(1);  

/*  

INITIALISE TIMER1 TO VALUE OF -32 SO THAT AN INTERRUPT IS GENERATED  

EVERY 1 sec FOR A CLOCK FREQUENCY AF 32 KHz  

*/  

if(flag==0 || flag==1)  

{  

//TCCR1A=0x00; //normal timer with top  

value OCRA1  

TCCR0=(\_BV(CS02)|\_BV(CS00)|\_BV(CS00)); //division of clock frequency by 1024  

TIMSK=\_BV(TOIE0); //ENABLE TIMER TO  

GENERATE THE INTERRUPT IN EVERY 1sec  

TCNT0=-32;  

10  

i=0;j=0;  

flag =1;  

}  

PORTD=0xFF;  

}  

//POWERDOWN MODE :CAUSES THE CHIP TO GO TO POWERDOWN MIDE  

WHEN IN IDLE STATE  

void powerdown()  

{  

PORTB=0xFF;  

PORTC=0xFF;  

MCUCR|=(1<<SE);  

asm("sleep");  

}  

//----------------------timer0 overflow interrupt---------------------------------------  

ISR(TIMER0\_OVF\_vect) //in every 1s  

{  

static byte m=0; // keeps a track of the timer values and gets  

incremented every minute  

if(flag==1)  

{  

PORTD=~(1<<PD4); /* provide an LED blink to provide  

constant feed back when the timer  

clock is running  

*/  

TCNT0=-32;  

if(i==60)  

{  

i=0;  

m+=1;  

}  

else  

i+=1;  

flag=(m==time)?2:1;  

11  

PORTD=0xFF;  

}  

// the buzzer pattern follows once the timer finishes  

if(flag==3&&j<=82)  

{  

TCNT0=-2;  

if(j%16==0||j%16==2||j%16==4||j%16==6||j%16==7||j%16==8)  

PORTD=~(1<<PD3);  

else  

PORTD=0xff;  

j+=1;  

if(j==80)  

{  

j=0;  

PORTD=0xFF;  

// settings for the sleep mode  

flag=0;  

m=0;  

}  

}  

}  

void main()  

{  

// initialisations  

TCCR0=0x00;  

flag=0;  

flag2=0;  

DDRC=0x00;  

PORTC=0XFF;  

DDRD=~(1<<PD2);  

PORTD=0xFF;  

DDRB=0x00;  

PORTB=0xFF;  

12  

// EXTERNAL INTERRUPTS ENABLED  

asm ("sei");  

MCUCR=0x00;  

GICR=\_BV(INT0);  

MCUCR=(1<<SM1); //powerdown mode settings  

powerdown();  

while(1)  

{  

if(flag==0)  

{  

TCCR0=0x00;  

flag=0;  

// powerdown mode function call  

powerdown();  

}  

if(flag==2)  

buzzer();  

}  

}  

void buzzer()  

{  

// TIMER INTIALISED FOR THE BUZZER PATTERN  

flag=3;  

TCCR0=(\_BV(CS00)|\_BV(CS02)|\_BV(CS00));  

TCNT0=-2;  

TIMSK=(\_BV(TOIE0));  

}

## Links

- [link to the block diagram](http://www.flickr.com/photos/10416487@N03/882264033/)

## Compilers

- AVR Studio 4

## Tags

- Complete code
- AVR Studio 4
