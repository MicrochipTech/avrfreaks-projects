
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000b4  00800100  0000ed62  00000df6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000d62  0000e000  0000e000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002b7  008001b4  008001b4  00000eaa  2**0
                  ALLOC
  3 .debug_aranges 000000c0  00000000  00000000  00000eaa  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000002d2  00000000  00000000  00000f6a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000ee4  00000000  00000000  0000123c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000077e  00000000  00000000  00002120  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000eb2  00000000  00000000  0000289e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001b0  00000000  00000000  00003750  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000475  00000000  00000000  00003900  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000006c0  00000000  00000000  00003d75  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000d8  00000000  00000000  00004435  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0000e000 <__vectors>:
    e000:	0c 94 46 70 	jmp	0xe08c	; 0xe08c <__ctors_end>
    e004:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e008:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e00c:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e010:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e014:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e018:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e01c:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e020:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e024:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e028:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e02c:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e030:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e034:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e038:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e03c:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e040:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e044:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e048:	0c 94 81 72 	jmp	0xe502	; 0xe502 <__vector_18>
    e04c:	0c 94 fc 72 	jmp	0xe5f8	; 0xe5f8 <__vector_19>
    e050:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e054:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e058:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e05c:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e060:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e064:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e068:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e06c:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e070:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e074:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e078:	0c 94 be 72 	jmp	0xe57c	; 0xe57c <__vector_30>
    e07c:	0c 94 44 73 	jmp	0xe688	; 0xe688 <__vector_31>
    e080:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e084:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>
    e088:	0c 94 63 70 	jmp	0xe0c6	; 0xe0c6 <__bad_interrupt>

0000e08c <__ctors_end>:
    e08c:	11 24       	eor	r1, r1
    e08e:	1f be       	out	0x3f, r1	; 63
    e090:	cf ef       	ldi	r28, 0xFF	; 255
    e092:	d0 e1       	ldi	r29, 0x10	; 16
    e094:	de bf       	out	0x3e, r29	; 62
    e096:	cd bf       	out	0x3d, r28	; 61

0000e098 <__do_copy_data>:
    e098:	11 e0       	ldi	r17, 0x01	; 1
    e09a:	a0 e0       	ldi	r26, 0x00	; 0
    e09c:	b1 e0       	ldi	r27, 0x01	; 1
    e09e:	e2 e6       	ldi	r30, 0x62	; 98
    e0a0:	fd ee       	ldi	r31, 0xED	; 237
    e0a2:	02 c0       	rjmp	.+4      	; 0xe0a8 <.do_copy_data_start>

0000e0a4 <.do_copy_data_loop>:
    e0a4:	05 90       	lpm	r0, Z+
    e0a6:	0d 92       	st	X+, r0

0000e0a8 <.do_copy_data_start>:
    e0a8:	a4 3b       	cpi	r26, 0xB4	; 180
    e0aa:	b1 07       	cpc	r27, r17
    e0ac:	d9 f7       	brne	.-10     	; 0xe0a4 <.do_copy_data_loop>

0000e0ae <__do_clear_bss>:
    e0ae:	14 e0       	ldi	r17, 0x04	; 4
    e0b0:	a4 eb       	ldi	r26, 0xB4	; 180
    e0b2:	b1 e0       	ldi	r27, 0x01	; 1
    e0b4:	01 c0       	rjmp	.+2      	; 0xe0b8 <.do_clear_bss_start>

0000e0b6 <.do_clear_bss_loop>:
    e0b6:	1d 92       	st	X+, r1

0000e0b8 <.do_clear_bss_start>:
    e0b8:	ab 36       	cpi	r26, 0x6B	; 107
    e0ba:	b1 07       	cpc	r27, r17
    e0bc:	e1 f7       	brne	.-8      	; 0xe0b6 <.do_clear_bss_loop>
    e0be:	0e 94 65 70 	call	0xe0ca	; 0xe0ca <main>
    e0c2:	0c 94 af 76 	jmp	0xed5e	; 0xed5e <_exit>

0000e0c6 <__bad_interrupt>:
    e0c6:	0c 94 00 70 	jmp	0xe000	; 0xe000 <__vectors>

0000e0ca <main>:
	void (*mainapp)(void)=NULL;
	extern volatile unsigned char uart_select; //1=uart0 2=uart1

// Main application routine.
int main(void)
{
    e0ca:	ef 92       	push	r14
    e0cc:	ff 92       	push	r15
    e0ce:	1f 93       	push	r17
    e0d0:	cf 93       	push	r28
    e0d2:	df 93       	push	r29
	int timeout;
	char *char_ptr, failed, finished;
	
	//disable interrupts
	cli();
    e0d4:	f8 94       	cli
	EIMSK =0;											//external int's
    e0d6:	19 be       	out	0x39, r1	; 57
	
	TIMSK=0;											//timer int's
    e0d8:	17 be       	out	0x37, r1	; 55
	
	SPCR &=~_BV(SPIE);									//spi int
    e0da:	6f 98       	cbi	0x0d, 7	; 13
	
	UCSR0B &=~(_BV(RXCIE0)+_BV(TXCIE0)+_BV(UDRIE0));	//uart0 ints
    e0dc:	8a b1       	in	r24, 0x0a	; 10
    e0de:	8f 71       	andi	r24, 0x1F	; 31
    e0e0:	8a b9       	out	0x0a, r24	; 10
	UCSR1B &=~(_BV(RXCIE1)+_BV(TXCIE1)+_BV(UDRIE1));	//uart1 ints
    e0e2:	80 91 9a 00 	lds	r24, 0x009A
    e0e6:	8f 71       	andi	r24, 0x1F	; 31
    e0e8:	80 93 9a 00 	sts	0x009A, r24
	
	TWCR &=~_BV(TWIE);									//two wire int
    e0ec:	80 91 74 00 	lds	r24, 0x0074
    e0f0:	8e 7f       	andi	r24, 0xFE	; 254
    e0f2:	80 93 74 00 	sts	0x0074, r24
	ACSR &=~_BV(ACIE);									//analog comparator
    e0f6:	43 98       	cbi	0x08, 3	; 8
	ADCSRA &=~_BV(ADIE);								//a2d
    e0f8:	33 98       	cbi	0x06, 3	; 6
	
	EECR &=~_BV(EERIE);									//EE
    e0fa:	e3 98       	cbi	0x1c, 3	; 28
	SPMCSR &=~_BV(SPMIE);								//SPM
    e0fc:	80 91 68 00 	lds	r24, 0x0068
    e100:	8f 77       	andi	r24, 0x7F	; 127
    e102:	80 93 68 00 	sts	0x0068, r24

	if(uart_init())	// detect ' ' on com 1 or 0, then configure that port
    e106:	0e 94 91 73 	call	0xe722	; 0xe722 <uart_init>
    e10a:	88 23       	and	r24, r24
    e10c:	09 f4       	brne	.+2      	; 0xe110 <main+0x46>
    e10e:	bb c0       	rjmp	.+374    	; 0xe286 <main+0x1bc>
	{
		MCUCR = _BV(IVCE);
    e110:	81 e0       	ldi	r24, 0x01	; 1
    e112:	85 bf       	out	0x35, r24	; 53
		MCUCR = _BV(IVSEL);
    e114:	82 e0       	ldi	r24, 0x02	; 2
    e116:	85 bf       	out	0x35, r24	; 53
		
		sei();
    e118:	78 94       	sei
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    e11a:	80 e4       	ldi	r24, 0x40	; 64
    e11c:	e8 2e       	mov	r14, r24
    e11e:	8c e9       	ldi	r24, 0x9C	; 156
    e120:	f8 2e       	mov	r15, r24
		do
		{
			timeout=TIMEOUT_ZPROMPT/0.010;
			UART_TX("\r\nMICKBOOT V1.2 Uart");
    e122:	80 e0       	ldi	r24, 0x00	; 0
    e124:	91 e0       	ldi	r25, 0x01	; 1
    e126:	0e 94 38 72 	call	0xe470	; 0xe470 <uart_write_string>
			
			if(UCSR1B & _BV(RXEN1))
    e12a:	80 91 9a 00 	lds	r24, 0x009A
    e12e:	84 ff       	sbrs	r24, 4
    e130:	03 c0       	rjmp	.+6      	; 0xe138 <main+0x6e>
				UART_TX("1");
    e132:	85 e1       	ldi	r24, 0x15	; 21
    e134:	91 e0       	ldi	r25, 0x01	; 1
    e136:	02 c0       	rjmp	.+4      	; 0xe13c <main+0x72>
			else
				UART_TX("0");
    e138:	87 e1       	ldi	r24, 0x17	; 23
    e13a:	91 e0       	ldi	r25, 0x01	; 1
    e13c:	0e 94 38 72 	call	0xe470	; 0xe470 <uart_write_string>
			
			UART_TX("\r\nSend Z\r\n");
    e140:	89 e1       	ldi	r24, 0x19	; 25
    e142:	91 e0       	ldi	r25, 0x01	; 1
    e144:	0e 94 38 72 	call	0xe470	; 0xe470 <uart_write_string>
    e148:	28 eb       	ldi	r18, 0xB8	; 184
    e14a:	3b e0       	ldi	r19, 0x0B	; 11
			
			finished=FALSE;
			failed=FALSE;
			do
			{
				if(uart_fifo_rx.bytes_used)
    e14c:	80 91 c5 02 	lds	r24, 0x02C5
    e150:	88 23       	and	r24, r24
    e152:	09 f4       	brne	.+2      	; 0xe156 <main+0x8c>
    e154:	70 c0       	rjmp	.+224    	; 0xe236 <main+0x16c>
				{
					timeout=TIMEOUT_ZPROMPT/0.010;
					if(fifo_read_char()=='Z')
    e156:	0e 94 cf 75 	call	0xeb9e	; 0xeb9e <fifo_read_char>
    e15a:	8a 35       	cpi	r24, 0x5A	; 90
    e15c:	a9 f7       	brne	.-22     	; 0xe148 <main+0x7e>
					{
						UART_TX("\r\nSend hex file in ASCII\r\n");
    e15e:	84 e2       	ldi	r24, 0x24	; 36
    e160:	91 e0       	ldi	r25, 0x01	; 1
    e162:	0e 94 38 72 	call	0xe470	; 0xe470 <uart_write_string>
						timeout=TIMEOUT_HEX_DATA/0.010;
						failed=FALSE;
						finished=FALSE;
						ihex_init();
    e166:	0e 94 a4 74 	call	0xe948	; 0xe948 <ihex_init>
    e16a:	c0 e7       	ldi	r28, 0x70	; 112
    e16c:	d7 e1       	ldi	r29, 0x17	; 23
						do
						{
							if(uart_fifo_rx.bytes_used)
    e16e:	80 91 c5 02 	lds	r24, 0x02C5
    e172:	88 23       	and	r24, r24
    e174:	09 f4       	brne	.+2      	; 0xe178 <main+0xae>
    e176:	41 c0       	rjmp	.+130    	; 0xe1fa <main+0x130>
							{
								timeout=TIMEOUT_HEX_DATA/0.010;
								ihex_char(fifo_read_char());
    e178:	0e 94 cf 75 	call	0xeb9e	; 0xeb9e <fifo_read_char>
    e17c:	0e 94 a0 75 	call	0xeb40	; 0xeb40 <ihex_char>
								if(ihex_byte_count)
    e180:	80 91 2e 04 	lds	r24, 0x042E
    e184:	88 23       	and	r24, r24
    e186:	39 f1       	breq	.+78     	; 0xe1d6 <main+0x10c>
    e188:	ce e1       	ldi	r28, 0x1E	; 30
    e18a:	d4 e0       	ldi	r29, 0x04	; 4
    e18c:	1b c0       	rjmp	.+54     	; 0xe1c4 <main+0xfa>
								{
									char_ptr = ihex_data;
									while(ihex_byte_count--)
										flash_byte(ihex_address++, *char_ptr++);
    e18e:	60 91 b8 01 	lds	r22, 0x01B8
    e192:	70 91 b9 01 	lds	r23, 0x01B9
    e196:	80 91 ba 01 	lds	r24, 0x01BA
    e19a:	90 91 bb 01 	lds	r25, 0x01BB
    e19e:	6f 5f       	subi	r22, 0xFF	; 255
    e1a0:	7f 4f       	sbci	r23, 0xFF	; 255
    e1a2:	8f 4f       	sbci	r24, 0xFF	; 255
    e1a4:	9f 4f       	sbci	r25, 0xFF	; 255
    e1a6:	60 93 b8 01 	sts	0x01B8, r22
    e1aa:	70 93 b9 01 	sts	0x01B9, r23
    e1ae:	80 93 ba 01 	sts	0x01BA, r24
    e1b2:	90 93 bb 01 	sts	0x01BB, r25
    e1b6:	61 50       	subi	r22, 0x01	; 1
    e1b8:	70 40       	sbci	r23, 0x00	; 0
    e1ba:	80 40       	sbci	r24, 0x00	; 0
    e1bc:	90 40       	sbci	r25, 0x00	; 0
    e1be:	49 91       	ld	r20, Y+
    e1c0:	0e 94 cc 71 	call	0xe398	; 0xe398 <flash_byte>
								timeout=TIMEOUT_HEX_DATA/0.010;
								ihex_char(fifo_read_char());
								if(ihex_byte_count)
								{
									char_ptr = ihex_data;
									while(ihex_byte_count--)
    e1c4:	80 91 2e 04 	lds	r24, 0x042E
    e1c8:	81 50       	subi	r24, 0x01	; 1
    e1ca:	80 93 2e 04 	sts	0x042E, r24
    e1ce:	8f 5f       	subi	r24, 0xFF	; 255
    e1d0:	f1 f6       	brne	.-68     	; 0xe18e <main+0xc4>
										flash_byte(ihex_address++, *char_ptr++);
									ihex_byte_count=0;
    e1d2:	10 92 2e 04 	sts	0x042E, r1
								};
								if(ihex_status==IHEX_STATUS_EOF)
    e1d6:	80 91 1d 04 	lds	r24, 0x041D
    e1da:	81 30       	cpi	r24, 0x01	; 1
    e1dc:	09 f0       	breq	.+2      	; 0xe1e0 <main+0x116>
    e1de:	60 c0       	rjmp	.+192    	; 0xe2a0 <main+0x1d6>
								{
									flash_finish();
    e1e0:	0e 94 c9 71 	call	0xe392	; 0xe392 <flash_finish>
									if(!writer_failed)
    e1e4:	80 91 b6 01 	lds	r24, 0x01B6
    e1e8:	88 23       	and	r24, r24
    e1ea:	09 f0       	breq	.+2      	; 0xe1ee <main+0x124>
    e1ec:	59 c0       	rjmp	.+178    	; 0xe2a0 <main+0x1d6>
									{
										UART_TX("Success!\r\n");
    e1ee:	8f e3       	ldi	r24, 0x3F	; 63
    e1f0:	91 e0       	ldi	r25, 0x01	; 1
    e1f2:	0e 94 38 72 	call	0xe470	; 0xe470 <uart_write_string>
    e1f6:	11 e0       	ldi	r17, 0x01	; 1
    e1f8:	54 c0       	rjmp	.+168    	; 0xe2a2 <main+0x1d8>
									};							
								};
							}
							else
							{
								timeout--;
    e1fa:	21 97       	sbiw	r28, 0x01	; 1
    e1fc:	c7 01       	movw	r24, r14
    e1fe:	01 97       	sbiw	r24, 0x01	; 1
    e200:	f1 f7       	brne	.-4      	; 0xe1fe <main+0x134>
								_delay_ms(10);
							};
							
							if(!timeout)	//if timeout looking for hex data, repeat Z prompt
    e202:	20 97       	sbiw	r28, 0x00	; 0
    e204:	11 f0       	breq	.+4      	; 0xe20a <main+0x140>
    e206:	90 e0       	ldi	r25, 0x00	; 0
    e208:	05 c0       	rjmp	.+10     	; 0xe214 <main+0x14a>
							{
								UART_TX("Timeout waiting for hex data\r\n");
    e20a:	8a e4       	ldi	r24, 0x4A	; 74
    e20c:	91 e0       	ldi	r25, 0x01	; 1
    e20e:	0e 94 38 72 	call	0xe470	; 0xe470 <uart_write_string>
    e212:	91 e0       	ldi	r25, 0x01	; 1
    e214:	10 e0       	ldi	r17, 0x00	; 0
								failed=TRUE;
							};
							
							if(ihex_status == IHEX_STATUS_ERROR)
    e216:	80 91 1d 04 	lds	r24, 0x041D
    e21a:	82 30       	cpi	r24, 0x02	; 2
    e21c:	29 f4       	brne	.+10     	; 0xe228 <main+0x15e>
							{
								UART_TX("Hex file ERROR!\r\n");
    e21e:	89 e6       	ldi	r24, 0x69	; 105
    e220:	91 e0       	ldi	r25, 0x01	; 1
    e222:	0e 94 38 72 	call	0xe470	; 0xe470 <uart_write_string>
    e226:	41 c0       	rjmp	.+130    	; 0xe2aa <main+0x1e0>
								failed=TRUE;
							};
							
						}while(!failed && !finished);
    e228:	99 23       	and	r25, r25
    e22a:	09 f0       	breq	.+2      	; 0xe22e <main+0x164>
    e22c:	3e c0       	rjmp	.+124    	; 0xe2aa <main+0x1e0>
    e22e:	11 23       	and	r17, r17
    e230:	09 f4       	brne	.+2      	; 0xe234 <main+0x16a>
    e232:	9d cf       	rjmp	.-198    	; 0xe16e <main+0xa4>
    e234:	0d c0       	rjmp	.+26     	; 0xe250 <main+0x186>
					};
				}
				else
				{
					timeout--;
    e236:	21 50       	subi	r18, 0x01	; 1
    e238:	30 40       	sbci	r19, 0x00	; 0
    e23a:	c7 01       	movw	r24, r14
    e23c:	01 97       	sbiw	r24, 0x01	; 1
    e23e:	f1 f7       	brne	.-4      	; 0xe23c <main+0x172>
					_delay_ms(10);
					if(!timeout)	//if timeout looking for Z, finish and run main app
    e240:	21 15       	cp	r18, r1
    e242:	31 05       	cpc	r19, r1
    e244:	09 f0       	breq	.+2      	; 0xe248 <main+0x17e>
    e246:	82 cf       	rjmp	.-252    	; 0xe14c <main+0x82>
					{
						finished=TRUE;
						UART_TX("Timeout waiting for Z\r\n");
    e248:	8b e7       	ldi	r24, 0x7B	; 123
    e24a:	91 e0       	ldi	r25, 0x01	; 1
    e24c:	0e 94 38 72 	call	0xe470	; 0xe470 <uart_write_string>
			}while(!failed && !finished);
			
		//repeat Z prompt until finished
		}while(!finished);
		
		UART_TX("RUNNING\r\n");
    e250:	83 e9       	ldi	r24, 0x93	; 147
    e252:	91 e0       	ldi	r25, 0x01	; 1
    e254:	0e 94 38 72 	call	0xe470	; 0xe470 <uart_write_string>
    e258:	88 e8       	ldi	r24, 0x88	; 136
    e25a:	93 e1       	ldi	r25, 0x13	; 19
    e25c:	20 e9       	ldi	r18, 0x90	; 144
    e25e:	31 e0       	ldi	r19, 0x01	; 1
    e260:	f9 01       	movw	r30, r18
    e262:	31 97       	sbiw	r30, 0x01	; 1
    e264:	f1 f7       	brne	.-4      	; 0xe262 <main+0x198>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    e266:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    e268:	d9 f7       	brne	.-10     	; 0xe260 <main+0x196>
		_delay_ms(500);
		cli();
    e26a:	f8 94       	cli
		MCUCR = _BV(IVCE);
    e26c:	81 e0       	ldi	r24, 0x01	; 1
    e26e:	85 bf       	out	0x35, r24	; 53
		MCUCR = 0;
    e270:	15 be       	out	0x35, r1	; 53
		wdt_enable(WDTO_15MS);
    e272:	28 e0       	ldi	r18, 0x08	; 8
    e274:	88 e1       	ldi	r24, 0x18	; 24
    e276:	90 e0       	ldi	r25, 0x00	; 0
    e278:	0f b6       	in	r0, 0x3f	; 63
    e27a:	f8 94       	cli
    e27c:	a8 95       	wdr
    e27e:	81 bd       	out	0x21, r24	; 33
    e280:	0f be       	out	0x3f, r0	; 63
    e282:	21 bd       	out	0x21, r18	; 33
    e284:	ff cf       	rjmp	.-2      	; 0xe284 <main+0x1ba>
		while(1);
		
		//once finished run main app
	};
	
	(*mainapp)();
    e286:	e0 91 b4 01 	lds	r30, 0x01B4
    e28a:	f0 91 b5 01 	lds	r31, 0x01B5
    e28e:	09 95       	icall

	return 0;
}
    e290:	80 e0       	ldi	r24, 0x00	; 0
    e292:	90 e0       	ldi	r25, 0x00	; 0
    e294:	df 91       	pop	r29
    e296:	cf 91       	pop	r28
    e298:	1f 91       	pop	r17
    e29a:	ff 90       	pop	r15
    e29c:	ef 90       	pop	r14
    e29e:	08 95       	ret
		while(1);
		
		//once finished run main app
	};
	
	(*mainapp)();
    e2a0:	10 e0       	ldi	r17, 0x00	; 0
    e2a2:	90 e0       	ldi	r25, 0x00	; 0
    e2a4:	c0 e7       	ldi	r28, 0x70	; 112
    e2a6:	d7 e1       	ldi	r29, 0x17	; 23
    e2a8:	b6 cf       	rjmp	.-148    	; 0xe216 <main+0x14c>
				
			//look for Z while not failed and not finished (a failure must repeat z prompt)
			}while(!failed && !finished);
			
		//repeat Z prompt until finished
		}while(!finished);
    e2aa:	11 23       	and	r17, r17
    e2ac:	09 f4       	brne	.+2      	; 0xe2b0 <main+0x1e6>
    e2ae:	39 cf       	rjmp	.-398    	; 0xe122 <main+0x58>
    e2b0:	cf cf       	rjmp	.-98     	; 0xe250 <main+0x186>

0000e2b2 <write_page>:
{
	write_page();
}

void write_page(void)
{		
    e2b2:	df 92       	push	r13
    e2b4:	ef 92       	push	r14
    e2b6:	ff 92       	push	r15
    e2b8:	0f 93       	push	r16
    e2ba:	1f 93       	push	r17
    e2bc:	cf 93       	push	r28
    e2be:	df 93       	push	r29
    e2c0:	1a e0       	ldi	r17, 0x0A	; 10
			tempint2=buffer_verify[tempint+1];
			tempint2<<=8;
			tempint2+=buffer_verify[tempint];
			ATOMIC_BLOCK(ATOMIC_FORCEON)
			{
				boot_page_fill(progmem_add, tempint2);	
    e2c2:	dd 24       	eor	r13, r13
    e2c4:	d3 94       	inc	r13
			tempint+=2;
		};
		
		ATOMIC_BLOCK(ATOMIC_FORCEON)
		{
			boot_page_erase(current_page);
    e2c6:	93 e0       	ldi	r25, 0x03	; 3
    e2c8:	e9 2e       	mov	r14, r25
		}
		boot_spm_busy_wait();      // Wait until the memory is erased.
		ATOMIC_BLOCK(ATOMIC_FORCEON)
		{
			boot_page_write(current_page);
    e2ca:	85 e0       	ldi	r24, 0x05	; 5
    e2cc:	f8 2e       	mov	r15, r24
		}
		boot_spm_busy_wait();      // Wait until the memory is programmed.
		
		progmem_add = current_page;
		boot_rww_enable();
    e2ce:	01 e1       	ldi	r16, 0x11	; 17
	unsigned int tempint, tempint2;
	
	do
	{
		//fill buffer
		progmem_add = current_page;
    e2d0:	20 91 b1 01 	lds	r18, 0x01B1
    e2d4:	30 91 b2 01 	lds	r19, 0x01B2
    e2d8:	a4 ec       	ldi	r26, 0xC4	; 196
    e2da:	b1 e0       	ldi	r27, 0x01	; 1
		tempint=0;
		while(tempint!=FLASH_PAGE_SIZE)
		{
			tempint2=buffer_verify[tempint+1];
			tempint2<<=8;
    e2dc:	11 96       	adiw	r26, 0x01	; 1
    e2de:	dc 91       	ld	r29, X
    e2e0:	11 97       	sbiw	r26, 0x01	; 1
    e2e2:	c0 e0       	ldi	r28, 0x00	; 0
    e2e4:	f8 94       	cli
			tempint2+=buffer_verify[tempint];
			ATOMIC_BLOCK(ATOMIC_FORCEON)
			{
				boot_page_fill(progmem_add, tempint2);	
    e2e6:	8c 91       	ld	r24, X
    e2e8:	ae 01       	movw	r20, r28
    e2ea:	48 0f       	add	r20, r24
    e2ec:	51 1d       	adc	r21, r1
    e2ee:	f9 01       	movw	r30, r18
    e2f0:	0a 01       	movw	r0, r20
    e2f2:	d0 92 68 00 	sts	0x0068, r13
    e2f6:	e8 95       	spm
    e2f8:	11 24       	eor	r1, r1
    e2fa:	78 94       	sei
			}
			progmem_add+=2;
    e2fc:	2e 5f       	subi	r18, 0xFE	; 254
    e2fe:	3f 4f       	sbci	r19, 0xFF	; 255
    e300:	12 96       	adiw	r26, 0x02	; 2
	do
	{
		//fill buffer
		progmem_add = current_page;
		tempint=0;
		while(tempint!=FLASH_PAGE_SIZE)
    e302:	f2 e0       	ldi	r31, 0x02	; 2
    e304:	a4 3c       	cpi	r26, 0xC4	; 196
    e306:	bf 07       	cpc	r27, r31
    e308:	49 f7       	brne	.-46     	; 0xe2dc <write_page+0x2a>
    e30a:	f8 94       	cli
			tempint+=2;
		};
		
		ATOMIC_BLOCK(ATOMIC_FORCEON)
		{
			boot_page_erase(current_page);
    e30c:	e0 91 b1 01 	lds	r30, 0x01B1
    e310:	f0 91 b2 01 	lds	r31, 0x01B2
    e314:	e0 92 68 00 	sts	0x0068, r14
    e318:	e8 95       	spm
    e31a:	78 94       	sei
		}
		boot_spm_busy_wait();      // Wait until the memory is erased.
    e31c:	80 91 68 00 	lds	r24, 0x0068
    e320:	80 fd       	sbrc	r24, 0
    e322:	fc cf       	rjmp	.-8      	; 0xe31c <write_page+0x6a>
    e324:	f8 94       	cli
		ATOMIC_BLOCK(ATOMIC_FORCEON)
		{
			boot_page_write(current_page);
    e326:	e0 91 b1 01 	lds	r30, 0x01B1
    e32a:	f0 91 b2 01 	lds	r31, 0x01B2
    e32e:	f0 92 68 00 	sts	0x0068, r15
    e332:	e8 95       	spm
    e334:	78 94       	sei
		}
		boot_spm_busy_wait();      // Wait until the memory is programmed.
    e336:	80 91 68 00 	lds	r24, 0x0068
    e33a:	80 fd       	sbrc	r24, 0
    e33c:	fc cf       	rjmp	.-8      	; 0xe336 <write_page+0x84>
		
		progmem_add = current_page;
		boot_rww_enable();
    e33e:	00 93 68 00 	sts	0x0068, r16
    e342:	e8 95       	spm
		
		if( memcmp_P(buffer_verify, (PGM_P)progmem_add, FLASH_PAGE_SIZE) )
    e344:	60 91 b1 01 	lds	r22, 0x01B1
    e348:	70 91 b2 01 	lds	r23, 0x01B2
    e34c:	84 ec       	ldi	r24, 0xC4	; 196
    e34e:	91 e0       	ldi	r25, 0x01	; 1
    e350:	40 e0       	ldi	r20, 0x00	; 0
    e352:	51 e0       	ldi	r21, 0x01	; 1
    e354:	0e 94 30 76 	call	0xec60	; 0xec60 <memcmp_P>
    e358:	89 2b       	or	r24, r25
    e35a:	11 f4       	brne	.+4      	; 0xe360 <write_page+0xae>
    e35c:	81 e0       	ldi	r24, 0x01	; 1
    e35e:	06 c0       	rjmp	.+12     	; 0xe36c <write_page+0xba>
		{
			UART_TX("Retrying\r\n");
    e360:	8d e9       	ldi	r24, 0x9D	; 157
    e362:	91 e0       	ldi	r25, 0x01	; 1
    e364:	0e 94 38 72 	call	0xe470	; 0xe470 <uart_write_string>
			retry--;
    e368:	11 50       	subi	r17, 0x01	; 1
    e36a:	80 e0       	ldi	r24, 0x00	; 0
		}
		else
			verified=TRUE;
			
	}while(retry && !verified);
    e36c:	11 23       	and	r17, r17
    e36e:	21 f0       	breq	.+8      	; 0xe378 <write_page+0xc6>
    e370:	88 23       	and	r24, r24
    e372:	09 f4       	brne	.+2      	; 0xe376 <write_page+0xc4>
    e374:	ad cf       	rjmp	.-166    	; 0xe2d0 <write_page+0x1e>
    e376:	05 c0       	rjmp	.+10     	; 0xe382 <write_page+0xd0>
	
	if(!verified)
    e378:	88 23       	and	r24, r24
    e37a:	19 f4       	brne	.+6      	; 0xe382 <write_page+0xd0>
		writer_failed=TRUE;
    e37c:	81 e0       	ldi	r24, 0x01	; 1
    e37e:	80 93 b6 01 	sts	0x01B6, r24
}
    e382:	df 91       	pop	r29
    e384:	cf 91       	pop	r28
    e386:	1f 91       	pop	r17
    e388:	0f 91       	pop	r16
    e38a:	ff 90       	pop	r15
    e38c:	ef 90       	pop	r14
    e38e:	df 90       	pop	r13
    e390:	08 95       	ret

0000e392 <flash_finish>:
	write_needed=TRUE;
}

void flash_finish(void)
{
	write_page();
    e392:	0e 94 59 71 	call	0xe2b2	; 0xe2b2 <write_page>
}
    e396:	08 95       	ret

0000e398 <flash_byte>:
	char memcmp_farP(void* ram_ptr, unsigned long progmem_add, unsigned int size);
	void write_page(void);

// call with bytes, builds pages and writes pages to flash.
void flash_byte(unsigned long address, char byte)
{
    e398:	df 92       	push	r13
    e39a:	ef 92       	push	r14
    e39c:	ff 92       	push	r15
    e39e:	0f 93       	push	r16
    e3a0:	1f 93       	push	r17
    e3a2:	df 93       	push	r29
    e3a4:	cf 93       	push	r28
    e3a6:	cd b7       	in	r28, 0x3d	; 61
    e3a8:	de b7       	in	r29, 0x3e	; 62
    e3aa:	2a 97       	sbiw	r28, 0x0a	; 10
    e3ac:	0f b6       	in	r0, 0x3f	; 63
    e3ae:	f8 94       	cli
    e3b0:	de bf       	out	0x3e, r29	; 62
    e3b2:	0f be       	out	0x3f, r0	; 63
    e3b4:	cd bf       	out	0x3d, r28	; 61
    e3b6:	7b 01       	movw	r14, r22
    e3b8:	8c 01       	movw	r16, r24
    e3ba:	d4 2e       	mov	r13, r20
	static char write_needed=FALSE;
	int tempint=0;
	unsigned int progmem_add;

	//new page?
	if((address & FLASH_PAGE_MASK) != current_page)
    e3bc:	9b 01       	movw	r18, r22
    e3be:	ac 01       	movw	r20, r24
    e3c0:	20 70       	andi	r18, 0x00	; 0
    e3c2:	40 70       	andi	r20, 0x00	; 0
    e3c4:	50 70       	andi	r21, 0x00	; 0
    e3c6:	80 91 b1 01 	lds	r24, 0x01B1
    e3ca:	90 91 b2 01 	lds	r25, 0x01B2
    e3ce:	a0 e0       	ldi	r26, 0x00	; 0
    e3d0:	b0 e0       	ldi	r27, 0x00	; 0
    e3d2:	28 17       	cp	r18, r24
    e3d4:	39 07       	cpc	r19, r25
    e3d6:	4a 07       	cpc	r20, r26
    e3d8:	5b 07       	cpc	r21, r27
    e3da:	a1 f1       	breq	.+104    	; 0xe444 <flash_byte+0xac>
	{
		//write previous page (if there is one)
		if(write_needed)
    e3dc:	80 91 b7 01 	lds	r24, 0x01B7
    e3e0:	88 23       	and	r24, r24
    e3e2:	11 f0       	breq	.+4      	; 0xe3e8 <flash_byte+0x50>
			write_page();
    e3e4:	0e 94 59 71 	call	0xe2b2	; 0xe2b2 <write_page>
		
		current_page = (unsigned int)address & FLASH_PAGE_MASK;
    e3e8:	c7 01       	movw	r24, r14
    e3ea:	80 70       	andi	r24, 0x00	; 0
    e3ec:	90 93 b2 01 	sts	0x01B2, r25
    e3f0:	80 93 b1 01 	sts	0x01B1, r24
		
		UART_TX("PAGE ");
    e3f4:	88 ea       	ldi	r24, 0xA8	; 168
    e3f6:	91 e0       	ldi	r25, 0x01	; 1
    e3f8:	0e 94 38 72 	call	0xe470	; 0xe470 <uart_write_string>
		UART_TX(ltoa(current_page, tempbuf, 16));
    e3fc:	60 91 b1 01 	lds	r22, 0x01B1
    e400:	70 91 b2 01 	lds	r23, 0x01B2
    e404:	80 e0       	ldi	r24, 0x00	; 0
    e406:	90 e0       	ldi	r25, 0x00	; 0
    e408:	ae 01       	movw	r20, r28
    e40a:	4f 5f       	subi	r20, 0xFF	; 255
    e40c:	5f 4f       	sbci	r21, 0xFF	; 255
    e40e:	20 e1       	ldi	r18, 0x10	; 16
    e410:	30 e0       	ldi	r19, 0x00	; 0
    e412:	0e 94 46 76 	call	0xec8c	; 0xec8c <ltoa>
    e416:	0e 94 38 72 	call	0xe470	; 0xe470 <uart_write_string>
		UART_TX("\r\n");
    e41a:	8e ea       	ldi	r24, 0xAE	; 174
    e41c:	91 e0       	ldi	r25, 0x01	; 1
    e41e:	0e 94 38 72 	call	0xe470	; 0xe470 <uart_write_string>
		
		//read new page into buffer
		progmem_add = current_page;
    e422:	e0 91 b1 01 	lds	r30, 0x01B1
    e426:	f0 91 b2 01 	lds	r31, 0x01B2
    e42a:	a4 ec       	ldi	r26, 0xC4	; 196
    e42c:	b1 e0       	ldi	r27, 0x01	; 1
		tempint=0;
		while(tempint!=FLASH_PAGE_SIZE)
			buffer_verify[tempint++]=pgm_read_byte(progmem_add++);
    e42e:	9f 01       	movw	r18, r30
    e430:	2f 5f       	subi	r18, 0xFF	; 255
    e432:	3f 4f       	sbci	r19, 0xFF	; 255
    e434:	84 91       	lpm	r24, Z+
    e436:	8d 93       	st	X+, r24
		UART_TX("\r\n");
		
		//read new page into buffer
		progmem_add = current_page;
		tempint=0;
		while(tempint!=FLASH_PAGE_SIZE)
    e438:	82 e0       	ldi	r24, 0x02	; 2
    e43a:	a4 3c       	cpi	r26, 0xC4	; 196
    e43c:	b8 07       	cpc	r27, r24
    e43e:	11 f0       	breq	.+4      	; 0xe444 <flash_byte+0xac>
    e440:	f9 01       	movw	r30, r18
    e442:	f5 cf       	rjmp	.-22     	; 0xe42e <flash_byte+0x96>
			buffer_verify[tempint++]=pgm_read_byte(progmem_add++);
	};

	buffer_verify[address&0xFF]=byte;
    e444:	f7 01       	movw	r30, r14
    e446:	f0 70       	andi	r31, 0x00	; 0
    e448:	ec 53       	subi	r30, 0x3C	; 60
    e44a:	fe 4f       	sbci	r31, 0xFE	; 254
    e44c:	d0 82       	st	Z, r13

	write_needed=TRUE;
    e44e:	81 e0       	ldi	r24, 0x01	; 1
    e450:	80 93 b7 01 	sts	0x01B7, r24
}
    e454:	2a 96       	adiw	r28, 0x0a	; 10
    e456:	0f b6       	in	r0, 0x3f	; 63
    e458:	f8 94       	cli
    e45a:	de bf       	out	0x3e, r29	; 62
    e45c:	0f be       	out	0x3f, r0	; 63
    e45e:	cd bf       	out	0x3d, r28	; 61
    e460:	cf 91       	pop	r28
    e462:	df 91       	pop	r29
    e464:	1f 91       	pop	r17
    e466:	0f 91       	pop	r16
    e468:	ff 90       	pop	r15
    e46a:	ef 90       	pop	r14
    e46c:	df 90       	pop	r13
    e46e:	08 95       	ret

0000e470 <uart_write_string>:
	};
	return found;
}

void uart_write_string(char*string)
{
    e470:	cf 93       	push	r28
    e472:	df 93       	push	r29
    e474:	ec 01       	movw	r28, r24
    e476:	37 c0       	rjmp	.+110    	; 0xe4e6 <uart_write_string+0x76>
	while(*string)
	{
		while(uart_fifo_tx.bytes_free==0);
    e478:	80 91 cf 03 	lds	r24, 0x03CF
    e47c:	88 23       	and	r24, r24
    e47e:	e1 f3       	breq	.-8      	; 0xe478 <uart_write_string+0x8>
		
		*((char*)uart_fifo_tx.head_ptr) = *string;
    e480:	e0 91 d1 03 	lds	r30, 0x03D1
    e484:	f0 91 d2 03 	lds	r31, 0x03D2
    e488:	90 83       	st	Z, r25
		uart_fifo_tx.head_ptr++;
    e48a:	80 91 d1 03 	lds	r24, 0x03D1
    e48e:	90 91 d2 03 	lds	r25, 0x03D2
    e492:	01 96       	adiw	r24, 0x01	; 1
    e494:	90 93 d2 03 	sts	0x03D2, r25
    e498:	80 93 d1 03 	sts	0x03D1, r24
		
		if(uart_fifo_tx.head_ptr == uart_fifo_tx.end)
    e49c:	20 91 d1 03 	lds	r18, 0x03D1
    e4a0:	30 91 d2 03 	lds	r19, 0x03D2
    e4a4:	80 91 d7 03 	lds	r24, 0x03D7
    e4a8:	90 91 d8 03 	lds	r25, 0x03D8
    e4ac:	28 17       	cp	r18, r24
    e4ae:	39 07       	cpc	r19, r25
    e4b0:	41 f4       	brne	.+16     	; 0xe4c2 <uart_write_string+0x52>
			uart_fifo_tx.head_ptr = uart_fifo_tx.start;
    e4b2:	80 91 d5 03 	lds	r24, 0x03D5
    e4b6:	90 91 d6 03 	lds	r25, 0x03D6
    e4ba:	90 93 d2 03 	sts	0x03D2, r25
    e4be:	80 93 d1 03 	sts	0x03D1, r24
    e4c2:	f8 94       	cli
		
		ATOMIC_BLOCK(ATOMIC_FORCEON)
		{
			uart_fifo_tx.bytes_free --;
    e4c4:	80 91 cf 03 	lds	r24, 0x03CF
    e4c8:	81 50       	subi	r24, 0x01	; 1
    e4ca:	80 93 cf 03 	sts	0x03CF, r24
			uart_fifo_tx.bytes_used ++;
    e4ce:	80 91 d0 03 	lds	r24, 0x03D0
    e4d2:	8f 5f       	subi	r24, 0xFF	; 255
    e4d4:	80 93 d0 03 	sts	0x03D0, r24
    e4d8:	78 94       	sei
		}
		
		uart_fifo_tx.post_fptr();
    e4da:	e0 91 d9 03 	lds	r30, 0x03D9
    e4de:	f0 91 da 03 	lds	r31, 0x03DA
    e4e2:	09 95       	icall
		string++;
    e4e4:	21 96       	adiw	r28, 0x01	; 1
	return found;
}

void uart_write_string(char*string)
{
	while(*string)
    e4e6:	98 81       	ld	r25, Y
    e4e8:	99 23       	and	r25, r25
    e4ea:	31 f6       	brne	.-116    	; 0xe478 <uart_write_string+0x8>
		}
		
		uart_fifo_tx.post_fptr();
		string++;
	};
}
    e4ec:	df 91       	pop	r29
    e4ee:	cf 91       	pop	r28
    e4f0:	08 95       	ret

0000e4f2 <uart0_isrtx_enable>:

void uart0_isrtx_enable(void)
{
	UCSR0B |= _BV(UDRIE0);	// tx interrupt
    e4f2:	55 9a       	sbi	0x0a, 5	; 10
}
    e4f4:	08 95       	ret

0000e4f6 <uart1_isrtx_enable>:

void uart1_isrtx_enable(void)
{
	UCSR1B |= _BV(UDRIE1);	// tx interrupt
    e4f6:	ea e9       	ldi	r30, 0x9A	; 154
    e4f8:	f0 e0       	ldi	r31, 0x00	; 0
    e4fa:	80 81       	ld	r24, Z
    e4fc:	80 62       	ori	r24, 0x20	; 32
    e4fe:	80 83       	st	Z, r24
}
    e500:	08 95       	ret

0000e502 <__vector_18>:

ISR(USART0_RX_vect)
{
    e502:	1f 92       	push	r1
    e504:	0f 92       	push	r0
    e506:	0f b6       	in	r0, 0x3f	; 63
    e508:	0f 92       	push	r0
    e50a:	11 24       	eor	r1, r1
    e50c:	2f 93       	push	r18
    e50e:	3f 93       	push	r19
    e510:	8f 93       	push	r24
    e512:	9f 93       	push	r25
    e514:	ef 93       	push	r30
    e516:	ff 93       	push	r31
	*((char*)uart_fifo_rx.head_ptr) = UDR0;
    e518:	e0 91 c6 02 	lds	r30, 0x02C6
    e51c:	f0 91 c7 02 	lds	r31, 0x02C7
    e520:	8c b1       	in	r24, 0x0c	; 12
    e522:	80 83       	st	Z, r24
	uart_fifo_rx.head_ptr++;
    e524:	80 91 c6 02 	lds	r24, 0x02C6
    e528:	90 91 c7 02 	lds	r25, 0x02C7
    e52c:	01 96       	adiw	r24, 0x01	; 1
    e52e:	90 93 c7 02 	sts	0x02C7, r25
    e532:	80 93 c6 02 	sts	0x02C6, r24

	if(uart_fifo_rx.head_ptr == uart_fifo_rx.end)
    e536:	20 91 c6 02 	lds	r18, 0x02C6
    e53a:	30 91 c7 02 	lds	r19, 0x02C7
    e53e:	80 91 cc 02 	lds	r24, 0x02CC
    e542:	90 91 cd 02 	lds	r25, 0x02CD
    e546:	28 17       	cp	r18, r24
    e548:	39 07       	cpc	r19, r25
    e54a:	41 f4       	brne	.+16     	; 0xe55c <__vector_18+0x5a>
		uart_fifo_rx.head_ptr = uart_fifo_rx.start;	
    e54c:	80 91 ca 02 	lds	r24, 0x02CA
    e550:	90 91 cb 02 	lds	r25, 0x02CB
    e554:	90 93 c7 02 	sts	0x02C7, r25
    e558:	80 93 c6 02 	sts	0x02C6, r24
	uart_fifo_rx.bytes_used ++;
    e55c:	80 91 c5 02 	lds	r24, 0x02C5
    e560:	8f 5f       	subi	r24, 0xFF	; 255
    e562:	80 93 c5 02 	sts	0x02C5, r24
}
    e566:	ff 91       	pop	r31
    e568:	ef 91       	pop	r30
    e56a:	9f 91       	pop	r25
    e56c:	8f 91       	pop	r24
    e56e:	3f 91       	pop	r19
    e570:	2f 91       	pop	r18
    e572:	0f 90       	pop	r0
    e574:	0f be       	out	0x3f, r0	; 63
    e576:	0f 90       	pop	r0
    e578:	1f 90       	pop	r1
    e57a:	18 95       	reti

0000e57c <__vector_30>:

ISR(USART1_RX_vect)
{
    e57c:	1f 92       	push	r1
    e57e:	0f 92       	push	r0
    e580:	0f b6       	in	r0, 0x3f	; 63
    e582:	0f 92       	push	r0
    e584:	11 24       	eor	r1, r1
    e586:	2f 93       	push	r18
    e588:	3f 93       	push	r19
    e58a:	8f 93       	push	r24
    e58c:	9f 93       	push	r25
    e58e:	ef 93       	push	r30
    e590:	ff 93       	push	r31
	*((char*)uart_fifo_rx.head_ptr) = UDR1;
    e592:	e0 91 c6 02 	lds	r30, 0x02C6
    e596:	f0 91 c7 02 	lds	r31, 0x02C7
    e59a:	80 91 9c 00 	lds	r24, 0x009C
    e59e:	80 83       	st	Z, r24
	uart_fifo_rx.head_ptr++;
    e5a0:	80 91 c6 02 	lds	r24, 0x02C6
    e5a4:	90 91 c7 02 	lds	r25, 0x02C7
    e5a8:	01 96       	adiw	r24, 0x01	; 1
    e5aa:	90 93 c7 02 	sts	0x02C7, r25
    e5ae:	80 93 c6 02 	sts	0x02C6, r24

	if(uart_fifo_rx.head_ptr == uart_fifo_rx.end)
    e5b2:	20 91 c6 02 	lds	r18, 0x02C6
    e5b6:	30 91 c7 02 	lds	r19, 0x02C7
    e5ba:	80 91 cc 02 	lds	r24, 0x02CC
    e5be:	90 91 cd 02 	lds	r25, 0x02CD
    e5c2:	28 17       	cp	r18, r24
    e5c4:	39 07       	cpc	r19, r25
    e5c6:	41 f4       	brne	.+16     	; 0xe5d8 <__vector_30+0x5c>
		uart_fifo_rx.head_ptr = uart_fifo_rx.start;	
    e5c8:	80 91 ca 02 	lds	r24, 0x02CA
    e5cc:	90 91 cb 02 	lds	r25, 0x02CB
    e5d0:	90 93 c7 02 	sts	0x02C7, r25
    e5d4:	80 93 c6 02 	sts	0x02C6, r24
	uart_fifo_rx.bytes_used ++;
    e5d8:	80 91 c5 02 	lds	r24, 0x02C5
    e5dc:	8f 5f       	subi	r24, 0xFF	; 255
    e5de:	80 93 c5 02 	sts	0x02C5, r24
}
    e5e2:	ff 91       	pop	r31
    e5e4:	ef 91       	pop	r30
    e5e6:	9f 91       	pop	r25
    e5e8:	8f 91       	pop	r24
    e5ea:	3f 91       	pop	r19
    e5ec:	2f 91       	pop	r18
    e5ee:	0f 90       	pop	r0
    e5f0:	0f be       	out	0x3f, r0	; 63
    e5f2:	0f 90       	pop	r0
    e5f4:	1f 90       	pop	r1
    e5f6:	18 95       	reti

0000e5f8 <__vector_19>:

ISR(USART0_UDRE_vect)
{
    e5f8:	1f 92       	push	r1
    e5fa:	0f 92       	push	r0
    e5fc:	0f b6       	in	r0, 0x3f	; 63
    e5fe:	0f 92       	push	r0
    e600:	11 24       	eor	r1, r1
    e602:	2f 93       	push	r18
    e604:	3f 93       	push	r19
    e606:	8f 93       	push	r24
    e608:	9f 93       	push	r25
    e60a:	ef 93       	push	r30
    e60c:	ff 93       	push	r31
	if(uart_fifo_tx.bytes_used==0)
    e60e:	80 91 d0 03 	lds	r24, 0x03D0
    e612:	88 23       	and	r24, r24
    e614:	11 f4       	brne	.+4      	; 0xe61a <__vector_19+0x22>
		UCSR0B &= ~_BV(UDRIE0);			// disable tx interrupt
    e616:	55 98       	cbi	0x0a, 5	; 10
    e618:	2c c0       	rjmp	.+88     	; 0xe672 <__vector_19+0x7a>
	else
	{
		UDR0=*((char*)uart_fifo_tx.tail_ptr);
    e61a:	e0 91 d3 03 	lds	r30, 0x03D3
    e61e:	f0 91 d4 03 	lds	r31, 0x03D4
    e622:	80 81       	ld	r24, Z
    e624:	8c b9       	out	0x0c, r24	; 12
		uart_fifo_tx.tail_ptr++;	
    e626:	80 91 d3 03 	lds	r24, 0x03D3
    e62a:	90 91 d4 03 	lds	r25, 0x03D4
    e62e:	01 96       	adiw	r24, 0x01	; 1
    e630:	90 93 d4 03 	sts	0x03D4, r25
    e634:	80 93 d3 03 	sts	0x03D3, r24
		
		if(uart_fifo_tx.tail_ptr == uart_fifo_tx.end)
    e638:	20 91 d3 03 	lds	r18, 0x03D3
    e63c:	30 91 d4 03 	lds	r19, 0x03D4
    e640:	80 91 d7 03 	lds	r24, 0x03D7
    e644:	90 91 d8 03 	lds	r25, 0x03D8
    e648:	28 17       	cp	r18, r24
    e64a:	39 07       	cpc	r19, r25
    e64c:	41 f4       	brne	.+16     	; 0xe65e <__vector_19+0x66>
			uart_fifo_tx.tail_ptr = uart_fifo_tx.start;
    e64e:	80 91 d5 03 	lds	r24, 0x03D5
    e652:	90 91 d6 03 	lds	r25, 0x03D6
    e656:	90 93 d4 03 	sts	0x03D4, r25
    e65a:	80 93 d3 03 	sts	0x03D3, r24
		
		uart_fifo_tx.bytes_free ++;
    e65e:	80 91 cf 03 	lds	r24, 0x03CF
    e662:	8f 5f       	subi	r24, 0xFF	; 255
    e664:	80 93 cf 03 	sts	0x03CF, r24
		uart_fifo_tx.bytes_used --;
    e668:	80 91 d0 03 	lds	r24, 0x03D0
    e66c:	81 50       	subi	r24, 0x01	; 1
    e66e:	80 93 d0 03 	sts	0x03D0, r24
	};
}
    e672:	ff 91       	pop	r31
    e674:	ef 91       	pop	r30
    e676:	9f 91       	pop	r25
    e678:	8f 91       	pop	r24
    e67a:	3f 91       	pop	r19
    e67c:	2f 91       	pop	r18
    e67e:	0f 90       	pop	r0
    e680:	0f be       	out	0x3f, r0	; 63
    e682:	0f 90       	pop	r0
    e684:	1f 90       	pop	r1
    e686:	18 95       	reti

0000e688 <__vector_31>:

ISR(USART1_UDRE_vect)
{
    e688:	1f 92       	push	r1
    e68a:	0f 92       	push	r0
    e68c:	0f b6       	in	r0, 0x3f	; 63
    e68e:	0f 92       	push	r0
    e690:	11 24       	eor	r1, r1
    e692:	2f 93       	push	r18
    e694:	3f 93       	push	r19
    e696:	8f 93       	push	r24
    e698:	9f 93       	push	r25
    e69a:	ef 93       	push	r30
    e69c:	ff 93       	push	r31
	if(uart_fifo_tx.bytes_used==0)
    e69e:	80 91 d0 03 	lds	r24, 0x03D0
    e6a2:	88 23       	and	r24, r24
    e6a4:	31 f4       	brne	.+12     	; 0xe6b2 <__vector_31+0x2a>
		UCSR1B &= ~_BV(UDRIE1);			// disable tx interrupt
    e6a6:	80 91 9a 00 	lds	r24, 0x009A
    e6aa:	8f 7d       	andi	r24, 0xDF	; 223
    e6ac:	80 93 9a 00 	sts	0x009A, r24
    e6b0:	2d c0       	rjmp	.+90     	; 0xe70c <__vector_31+0x84>
	else
	{
		UDR1=*((char*)uart_fifo_tx.tail_ptr);
    e6b2:	e0 91 d3 03 	lds	r30, 0x03D3
    e6b6:	f0 91 d4 03 	lds	r31, 0x03D4
    e6ba:	80 81       	ld	r24, Z
    e6bc:	80 93 9c 00 	sts	0x009C, r24
		uart_fifo_tx.tail_ptr++;
    e6c0:	80 91 d3 03 	lds	r24, 0x03D3
    e6c4:	90 91 d4 03 	lds	r25, 0x03D4
    e6c8:	01 96       	adiw	r24, 0x01	; 1
    e6ca:	90 93 d4 03 	sts	0x03D4, r25
    e6ce:	80 93 d3 03 	sts	0x03D3, r24
		
		if(uart_fifo_tx.tail_ptr == uart_fifo_tx.end)
    e6d2:	20 91 d3 03 	lds	r18, 0x03D3
    e6d6:	30 91 d4 03 	lds	r19, 0x03D4
    e6da:	80 91 d7 03 	lds	r24, 0x03D7
    e6de:	90 91 d8 03 	lds	r25, 0x03D8
    e6e2:	28 17       	cp	r18, r24
    e6e4:	39 07       	cpc	r19, r25
    e6e6:	41 f4       	brne	.+16     	; 0xe6f8 <__vector_31+0x70>
			uart_fifo_tx.tail_ptr = uart_fifo_tx.start;
    e6e8:	80 91 d5 03 	lds	r24, 0x03D5
    e6ec:	90 91 d6 03 	lds	r25, 0x03D6
    e6f0:	90 93 d4 03 	sts	0x03D4, r25
    e6f4:	80 93 d3 03 	sts	0x03D3, r24
		
		uart_fifo_tx.bytes_free ++;
    e6f8:	80 91 cf 03 	lds	r24, 0x03CF
    e6fc:	8f 5f       	subi	r24, 0xFF	; 255
    e6fe:	80 93 cf 03 	sts	0x03CF, r24
		uart_fifo_tx.bytes_used --;
    e702:	80 91 d0 03 	lds	r24, 0x03D0
    e706:	81 50       	subi	r24, 0x01	; 1
    e708:	80 93 d0 03 	sts	0x03D0, r24
	};
}
    e70c:	ff 91       	pop	r31
    e70e:	ef 91       	pop	r30
    e710:	9f 91       	pop	r25
    e712:	8f 91       	pop	r24
    e714:	3f 91       	pop	r19
    e716:	2f 91       	pop	r18
    e718:	0f 90       	pop	r0
    e71a:	0f be       	out	0x3f, r0	; 63
    e71c:	0f 90       	pop	r0
    e71e:	1f 90       	pop	r1
    e720:	18 95       	reti

0000e722 <uart_init>:

	struct fifo_control uart_fifo_tx;
	struct fifo_control uart_fifo_rx;

char uart_init(void)
{
    e722:	cf 93       	push	r28
    e724:	df 93       	push	r29
	int tempint;
	char found=FALSE;

	//Uart0 already configured? (means bootloader called from main app)
	if(UCSR0B & _BV(RXEN0))
    e726:	54 9b       	sbis	0x0a, 4	; 10
    e728:	08 c0       	rjmp	.+16     	; 0xe73a <uart_init+0x18>
	{
		UCSR0B |= _BV(RXCIE0);	// enable rx interrupt (writes to fifo)
    e72a:	57 9a       	sbi	0x0a, 7	; 10
		fifo_init(&uart_fifo_tx,UART_FIFO_TX_SIZE, uart0_isrtx_enable, uart_fifo_data_tx);
    e72c:	8f ec       	ldi	r24, 0xCF	; 207
    e72e:	93 e0       	ldi	r25, 0x03	; 3
    e730:	60 e4       	ldi	r22, 0x40	; 64
    e732:	70 e0       	ldi	r23, 0x00	; 0
    e734:	49 e7       	ldi	r20, 0x79	; 121
    e736:	52 e7       	ldi	r21, 0x72	; 114
    e738:	0f c0       	rjmp	.+30     	; 0xe758 <uart_init+0x36>
		fifo_init(&uart_fifo_rx,UART_FIFO_RX_SIZE, NULL, uart_fifo_data_rx);
		found=TRUE;
	}
	else if(UCSR1B & _BV(RXEN1))
    e73a:	80 91 9a 00 	lds	r24, 0x009A
    e73e:	84 ff       	sbrs	r24, 4
    e740:	1b c0       	rjmp	.+54     	; 0xe778 <uart_init+0x56>
	{
		UCSR1B |= _BV(RXCIE1);	// enable rx interrupt (writes to fifo)
    e742:	80 91 9a 00 	lds	r24, 0x009A
    e746:	80 68       	ori	r24, 0x80	; 128
    e748:	80 93 9a 00 	sts	0x009A, r24
		fifo_init(&uart_fifo_tx,UART_FIFO_TX_SIZE, uart1_isrtx_enable, uart_fifo_data_tx);
    e74c:	8f ec       	ldi	r24, 0xCF	; 207
    e74e:	93 e0       	ldi	r25, 0x03	; 3
    e750:	60 e4       	ldi	r22, 0x40	; 64
    e752:	70 e0       	ldi	r23, 0x00	; 0
    e754:	4b e7       	ldi	r20, 0x7B	; 123
    e756:	52 e7       	ldi	r21, 0x72	; 114
    e758:	2b ed       	ldi	r18, 0xDB	; 219
    e75a:	33 e0       	ldi	r19, 0x03	; 3
    e75c:	0e 94 16 76 	call	0xec2c	; 0xec2c <fifo_init>
		fifo_init(&uart_fifo_rx,UART_FIFO_RX_SIZE, NULL, uart_fifo_data_rx);
    e760:	84 ec       	ldi	r24, 0xC4	; 196
    e762:	92 e0       	ldi	r25, 0x02	; 2
    e764:	6f ef       	ldi	r22, 0xFF	; 255
    e766:	70 e0       	ldi	r23, 0x00	; 0
    e768:	40 e0       	ldi	r20, 0x00	; 0
    e76a:	50 e0       	ldi	r21, 0x00	; 0
    e76c:	20 ed       	ldi	r18, 0xD0	; 208
    e76e:	32 e0       	ldi	r19, 0x02	; 2
    e770:	0e 94 16 76 	call	0xec2c	; 0xec2c <fifo_init>
    e774:	91 e0       	ldi	r25, 0x01	; 1
    e776:	9b c0       	rjmp	.+310    	; 0xe8ae <uart_init+0x18c>
		found=TRUE;
	}
	else 
	{
		// Setup Uart0
		DDRE &=~_BV(PE0);		// UTX0 input
    e778:	10 98       	cbi	0x02, 0	; 2
		UCSR0B |= _BV(RXEN0);	// enable rx
    e77a:	54 9a       	sbi	0x0a, 4	; 10
		UCSR0B |= _BV(RXCIE0);	// enable rx interrupt (writes to fifo)
    e77c:	57 9a       	sbi	0x0a, 7	; 10
		UCSR0B &= ~_BV(UDRIE0);	// disable tx interrupt (for now)	
    e77e:	55 98       	cbi	0x0a, 5	; 10
		
		// Setup Uart1
		DDRD &=~_BV(PD2);		// URX1 input
    e780:	8a 98       	cbi	0x11, 2	; 17
		UCSR1B |= _BV(RXEN1);	// enable rx
    e782:	80 91 9a 00 	lds	r24, 0x009A
    e786:	80 61       	ori	r24, 0x10	; 16
    e788:	80 93 9a 00 	sts	0x009A, r24
		UCSR1B |= _BV(RXCIE1);	// enable rx interrupt (writes to fifo)
    e78c:	80 91 9a 00 	lds	r24, 0x009A
    e790:	80 68       	ori	r24, 0x80	; 128
    e792:	80 93 9a 00 	sts	0x009A, r24
		UCSR1B &= ~_BV(UDRIE1);	// disable tx interrupt (for now)	
    e796:	80 91 9a 00 	lds	r24, 0x009A
    e79a:	8f 7d       	andi	r24, 0xDF	; 223
    e79c:	80 93 9a 00 	sts	0x009A, r24
		
		#define BAUD_TOL	5
		#define BAUD		UART0BAUD
		#include <util/setbaud.h>
		UBRR0H = (char)(UBRR_VALUE>>8);
    e7a0:	10 92 90 00 	sts	0x0090, r1
		UBRR0L = (char)(UBRR_VALUE);
    e7a4:	97 e6       	ldi	r25, 0x67	; 103
    e7a6:	99 b9       	out	0x09, r25	; 9
		#if USE_2X
			UCSR0A |= _BV(U2X0);
		#else
			UCSR0A &= _BV(U2X0);
    e7a8:	8b b1       	in	r24, 0x0b	; 11
    e7aa:	82 70       	andi	r24, 0x02	; 2
    e7ac:	8b b9       	out	0x0b, r24	; 11
		#endif
		
		#undef	BAUD
		#define	BAUD		UART1BAUD
		#include <util/setbaud.h>
		UBRR1H = (char)(UBRR_VALUE>>8);
    e7ae:	10 92 98 00 	sts	0x0098, r1
		UBRR1L = (char)(UBRR_VALUE);
    e7b2:	90 93 99 00 	sts	0x0099, r25
		#if USE_2X
			UCSR1A |= _BV(U2X1);
		#else
			UCSR1A &= _BV(U2X1);
    e7b6:	80 91 9b 00 	lds	r24, 0x009B
    e7ba:	82 70       	andi	r24, 0x02	; 2
    e7bc:	80 93 9b 00 	sts	0x009B, r24
    e7c0:	88 ec       	ldi	r24, 0xC8	; 200
    e7c2:	90 e0       	ldi	r25, 0x00	; 0
    e7c4:	40 e0       	ldi	r20, 0x00	; 0
    e7c6:	c0 ea       	ldi	r28, 0xA0	; 160
    e7c8:	df e0       	ldi	r29, 0x0F	; 15
    e7ca:	59 c0       	rjmp	.+178    	; 0xe87e <uart_init+0x15c>
		#endif
		
		tempint=BOOTWINDOW;
		while(tempint--)
		{
			if(UCSR0A & _BV(RXC0))
    e7cc:	5f 9b       	sbis	0x0b, 7	; 11
    e7ce:	27 c0       	rjmp	.+78     	; 0xe81e <uart_init+0xfc>
			{
				if(UDR0==' ')
    e7d0:	8c b1       	in	r24, 0x0c	; 12
    e7d2:	80 32       	cpi	r24, 0x20	; 32
    e7d4:	21 f5       	brne	.+72     	; 0xe81e <uart_init+0xfc>
				{
					UCSR1B &=~_BV(RXEN1);	// disable rx
    e7d6:	80 91 9a 00 	lds	r24, 0x009A
    e7da:	8f 7e       	andi	r24, 0xEF	; 239
    e7dc:	80 93 9a 00 	sts	0x009A, r24
					UCSR1B &=~_BV(RXCIE1);	// disable rx interrupt (writes to fifo)
    e7e0:	80 91 9a 00 	lds	r24, 0x009A
    e7e4:	8f 77       	andi	r24, 0x7F	; 127
    e7e6:	80 93 9a 00 	sts	0x009A, r24
					fifo_init(&uart_fifo_tx,UART_FIFO_TX_SIZE, uart0_isrtx_enable, uart_fifo_data_tx);
    e7ea:	8f ec       	ldi	r24, 0xCF	; 207
    e7ec:	93 e0       	ldi	r25, 0x03	; 3
    e7ee:	60 e4       	ldi	r22, 0x40	; 64
    e7f0:	70 e0       	ldi	r23, 0x00	; 0
    e7f2:	49 e7       	ldi	r20, 0x79	; 121
    e7f4:	52 e7       	ldi	r21, 0x72	; 114
    e7f6:	2b ed       	ldi	r18, 0xDB	; 219
    e7f8:	33 e0       	ldi	r19, 0x03	; 3
    e7fa:	0e 94 16 76 	call	0xec2c	; 0xec2c <fifo_init>
					fifo_init(&uart_fifo_rx,UART_FIFO_RX_SIZE, NULL, uart_fifo_data_rx);
    e7fe:	84 ec       	ldi	r24, 0xC4	; 196
    e800:	92 e0       	ldi	r25, 0x02	; 2
    e802:	6f ef       	ldi	r22, 0xFF	; 255
    e804:	70 e0       	ldi	r23, 0x00	; 0
    e806:	40 e0       	ldi	r20, 0x00	; 0
    e808:	50 e0       	ldi	r21, 0x00	; 0
    e80a:	20 ed       	ldi	r18, 0xD0	; 208
    e80c:	32 e0       	ldi	r19, 0x02	; 2
    e80e:	0e 94 16 76 	call	0xec2c	; 0xec2c <fifo_init>
					DDRE |=_BV(PE1);		// UTX0 output
    e812:	11 9a       	sbi	0x02, 1	; 2
					UCSR0B |= _BV(TXEN0);	// enable tx
    e814:	53 9a       	sbi	0x0a, 3	; 10
					UCSR0B |= _BV(UDRIE0);	// enable tx interrupt
    e816:	55 9a       	sbi	0x0a, 5	; 10
    e818:	20 e0       	ldi	r18, 0x00	; 0
    e81a:	30 e0       	ldi	r19, 0x00	; 0
    e81c:	41 e0       	ldi	r20, 0x01	; 1
					tempint=0;
					found=TRUE;
				};
			};
			
			if(UCSR1A & _BV(RXC1))
    e81e:	80 91 9b 00 	lds	r24, 0x009B
    e822:	87 ff       	sbrs	r24, 7
    e824:	28 c0       	rjmp	.+80     	; 0xe876 <uart_init+0x154>
			{
				if(UDR1==' ')
    e826:	80 91 9c 00 	lds	r24, 0x009C
    e82a:	80 32       	cpi	r24, 0x20	; 32
    e82c:	21 f5       	brne	.+72     	; 0xe876 <uart_init+0x154>
				{
					UCSR0B &=~_BV(RXEN0);	// disable rx
    e82e:	54 98       	cbi	0x0a, 4	; 10
					UCSR0B &=~_BV(RXCIE0);	// disable rx interrupt (writes to fifo)
    e830:	57 98       	cbi	0x0a, 7	; 10
					fifo_init(&uart_fifo_tx,UART_FIFO_TX_SIZE, uart1_isrtx_enable, uart_fifo_data_tx);
    e832:	8f ec       	ldi	r24, 0xCF	; 207
    e834:	93 e0       	ldi	r25, 0x03	; 3
    e836:	60 e4       	ldi	r22, 0x40	; 64
    e838:	70 e0       	ldi	r23, 0x00	; 0
    e83a:	4b e7       	ldi	r20, 0x7B	; 123
    e83c:	52 e7       	ldi	r21, 0x72	; 114
    e83e:	2b ed       	ldi	r18, 0xDB	; 219
    e840:	33 e0       	ldi	r19, 0x03	; 3
    e842:	0e 94 16 76 	call	0xec2c	; 0xec2c <fifo_init>
					fifo_init(&uart_fifo_rx,UART_FIFO_RX_SIZE, NULL, uart_fifo_data_rx);
    e846:	84 ec       	ldi	r24, 0xC4	; 196
    e848:	92 e0       	ldi	r25, 0x02	; 2
    e84a:	6f ef       	ldi	r22, 0xFF	; 255
    e84c:	70 e0       	ldi	r23, 0x00	; 0
    e84e:	40 e0       	ldi	r20, 0x00	; 0
    e850:	50 e0       	ldi	r21, 0x00	; 0
    e852:	20 ed       	ldi	r18, 0xD0	; 208
    e854:	32 e0       	ldi	r19, 0x02	; 2
    e856:	0e 94 16 76 	call	0xec2c	; 0xec2c <fifo_init>
					DDRD |=_BV(PD3);		// UTX1 output
    e85a:	8b 9a       	sbi	0x11, 3	; 17
					UCSR1B |= _BV(TXEN1);	// enable tx
    e85c:	80 91 9a 00 	lds	r24, 0x009A
    e860:	88 60       	ori	r24, 0x08	; 8
    e862:	80 93 9a 00 	sts	0x009A, r24
					UCSR1B |= _BV(UDRIE1);	// enable tx interrupt
    e866:	80 91 9a 00 	lds	r24, 0x009A
    e86a:	80 62       	ori	r24, 0x20	; 32
    e86c:	80 93 9a 00 	sts	0x009A, r24
    e870:	20 e0       	ldi	r18, 0x00	; 0
    e872:	30 e0       	ldi	r19, 0x00	; 0
    e874:	41 e0       	ldi	r20, 0x01	; 1
    e876:	ce 01       	movw	r24, r28
    e878:	01 97       	sbiw	r24, 0x01	; 1
    e87a:	f1 f7       	brne	.-4      	; 0xe878 <uart_init+0x156>
    e87c:	c9 01       	movw	r24, r18
		#else
			UCSR1A &= _BV(U2X1);
		#endif
		
		tempint=BOOTWINDOW;
		while(tempint--)
    e87e:	9c 01       	movw	r18, r24
    e880:	21 50       	subi	r18, 0x01	; 1
    e882:	30 40       	sbci	r19, 0x00	; 0
    e884:	89 2b       	or	r24, r25
    e886:	09 f0       	breq	.+2      	; 0xe88a <uart_init+0x168>
    e888:	a1 cf       	rjmp	.-190    	; 0xe7cc <uart_init+0xaa>
    e88a:	94 2f       	mov	r25, r20
			};
			_delay_ms(1);
		};
	};
	
	if(!found)
    e88c:	44 23       	and	r20, r20
    e88e:	79 f4       	brne	.+30     	; 0xe8ae <uart_init+0x18c>
	{
		DDRD=0;
    e890:	11 ba       	out	0x11, r1	; 17
		UCSR0B=0;
    e892:	1a b8       	out	0x0a, r1	; 10
		UCSR1B=0;
    e894:	10 92 9a 00 	sts	0x009A, r1
	
		UBRR0H = 0;
    e898:	10 92 90 00 	sts	0x0090, r1
		UBRR0L = 0;
    e89c:	19 b8       	out	0x09, r1	; 9
		UBRR1H = 0;
    e89e:	10 92 98 00 	sts	0x0098, r1
		UBRR1L = 0;
    e8a2:	10 92 99 00 	sts	0x0099, r1
	
		UCSR0A =0x20;
    e8a6:	80 e2       	ldi	r24, 0x20	; 32
    e8a8:	8b b9       	out	0x0b, r24	; 11
		UCSR1A =0x20;	
    e8aa:	80 93 9b 00 	sts	0x009B, r24
	};
	return found;
}
    e8ae:	89 2f       	mov	r24, r25
    e8b0:	df 91       	pop	r29
    e8b2:	cf 91       	pop	r28
    e8b4:	08 95       	ret

0000e8b6 <hex2ascii>:

// call to print memory to a text buffer as hex data
// option=0, ############
// option=1, ##:##:##:##:##:## (used for MAC)
char* hex2ascii(char* textbuf, void* startadd, unsigned char length, unsigned char option)
{
    e8b6:	0f 93       	push	r16
    e8b8:	1f 93       	push	r17
    e8ba:	cf 93       	push	r28
    e8bc:	df 93       	push	r29
    e8be:	18 2f       	mov	r17, r24
    e8c0:	09 2f       	mov	r16, r25
    e8c2:	eb 01       	movw	r28, r22
    e8c4:	62 2f       	mov	r22, r18
	void* endadd = (unsigned char*)startadd+length;
    e8c6:	ce 01       	movw	r24, r28
    e8c8:	84 0f       	add	r24, r20
    e8ca:	91 1d       	adc	r25, r1
    e8cc:	ac 01       	movw	r20, r24
    e8ce:	21 2f       	mov	r18, r17
    e8d0:	30 2f       	mov	r19, r16
    e8d2:	c9 01       	movw	r24, r18
    e8d4:	fc 01       	movw	r30, r24
			textbuf[0]+=7;
		if(textbuf[1]>0x39)
			textbuf[1]+=7;
		textbuf+=2;
		if(option==1 && startadd != endadd)
			*textbuf++=':';
    e8d6:	2a e3       	ldi	r18, 0x3A	; 58
	char* retval = textbuf;

	unsigned char tempchar;
	do
	{
		tempchar=*(unsigned char*)startadd++;
    e8d8:	89 91       	ld	r24, Y+
		textbuf[0]=0x30+(tempchar>>4);
    e8da:	98 2f       	mov	r25, r24
    e8dc:	92 95       	swap	r25
    e8de:	9f 70       	andi	r25, 0x0F	; 15
    e8e0:	90 5d       	subi	r25, 0xD0	; 208
    e8e2:	df 01       	movw	r26, r30
    e8e4:	9d 93       	st	X+, r25
		textbuf[1]=0x30+(tempchar&0x0F);
    e8e6:	8f 70       	andi	r24, 0x0F	; 15
    e8e8:	80 5d       	subi	r24, 0xD0	; 208
    e8ea:	81 83       	std	Z+1, r24	; 0x01
		if(textbuf[0]>0x39)
    e8ec:	9a 33       	cpi	r25, 0x3A	; 58
    e8ee:	10 f0       	brcs	.+4      	; 0xe8f4 <hex2ascii+0x3e>
			textbuf[0]+=7;
    e8f0:	99 5f       	subi	r25, 0xF9	; 249
    e8f2:	90 83       	st	Z, r25
		if(textbuf[1]>0x39)
    e8f4:	8c 91       	ld	r24, X
    e8f6:	8a 33       	cpi	r24, 0x3A	; 58
    e8f8:	10 f0       	brcs	.+4      	; 0xe8fe <hex2ascii+0x48>
			textbuf[1]+=7;
    e8fa:	89 5f       	subi	r24, 0xF9	; 249
    e8fc:	8c 93       	st	X, r24
		textbuf+=2;
    e8fe:	32 96       	adiw	r30, 0x02	; 2
		if(option==1 && startadd != endadd)
    e900:	61 30       	cpi	r22, 0x01	; 1
    e902:	29 f4       	brne	.+10     	; 0xe90e <hex2ascii+0x58>
    e904:	c4 17       	cp	r28, r20
    e906:	d5 07       	cpc	r29, r21
    e908:	29 f0       	breq	.+10     	; 0xe914 <hex2ascii+0x5e>
			*textbuf++=':';
    e90a:	21 93       	st	Z+, r18
    e90c:	e5 cf       	rjmp	.-54     	; 0xe8d8 <hex2ascii+0x22>
	}while(startadd != endadd);
    e90e:	c4 17       	cp	r28, r20
    e910:	d5 07       	cpc	r29, r21
    e912:	11 f7       	brne	.-60     	; 0xe8d8 <hex2ascii+0x22>
	*textbuf++=0;
    e914:	10 82       	st	Z, r1
	return retval;
}
    e916:	81 2f       	mov	r24, r17
    e918:	90 2f       	mov	r25, r16
    e91a:	df 91       	pop	r29
    e91c:	cf 91       	pop	r28
    e91e:	1f 91       	pop	r17
    e920:	0f 91       	pop	r16
    e922:	08 95       	ret

0000e924 <read_bige_uint>:

unsigned int read_bige_uint(unsigned int bige)
{
    e924:	df 93       	push	r29
    e926:	cf 93       	push	r28
    e928:	00 d0       	rcall	.+0      	; 0xe92a <read_bige_uint+0x6>
    e92a:	cd b7       	in	r28, 0x3d	; 61
    e92c:	de b7       	in	r29, 0x3e	; 62
    e92e:	9a 83       	std	Y+2, r25	; 0x02
    e930:	89 83       	std	Y+1, r24	; 0x01
	unsigned int retval;
	retval = ((unsigned char*)&bige)[0];
	retval<<=8;
    e932:	38 2f       	mov	r19, r24
    e934:	20 e0       	ldi	r18, 0x00	; 0
    e936:	8a 81       	ldd	r24, Y+2	; 0x02
    e938:	28 0f       	add	r18, r24
    e93a:	31 1d       	adc	r19, r1
	retval+= ((unsigned char*)&bige)[1];
	return retval;
}
    e93c:	c9 01       	movw	r24, r18
    e93e:	0f 90       	pop	r0
    e940:	0f 90       	pop	r0
    e942:	cf 91       	pop	r28
    e944:	df 91       	pop	r29
    e946:	08 95       	ret

0000e948 <ihex_init>:
	char *line_ptr;

//call to initialise ihex parser
void ihex_init()
{
	ext_seg_add=0;
    e948:	10 92 bc 01 	sts	0x01BC, r1
    e94c:	10 92 bd 01 	sts	0x01BD, r1
    e950:	10 92 be 01 	sts	0x01BE, r1
    e954:	10 92 bf 01 	sts	0x01BF, r1
	ext_lin_add=0;
    e958:	10 92 c0 01 	sts	0x01C0, r1
    e95c:	10 92 c1 01 	sts	0x01C1, r1
    e960:	10 92 c2 01 	sts	0x01C2, r1
    e964:	10 92 c3 01 	sts	0x01C3, r1
	line_ptr=hexline.ascii;
    e968:	8f e2       	ldi	r24, 0x2F	; 47
    e96a:	94 e0       	ldi	r25, 0x04	; 4
    e96c:	90 93 1c 04 	sts	0x041C, r25
    e970:	80 93 1b 04 	sts	0x041B, r24
	*line_ptr=0;
    e974:	10 92 2f 04 	sts	0x042F, r1
	ihex_status=0;
    e978:	10 92 1d 04 	sts	0x041D, r1
}
    e97c:	08 95       	ret

0000e97e <ascii2hex>:
	else
		ihex_status=IHEX_STATUS_ERROR;
}

char ascii2hex(char* ascii)
{
    e97e:	fc 01       	movw	r30, r24
	char retval=0;
	if(ascii[0] > '9')
    e980:	80 81       	ld	r24, Z
    e982:	8a 33       	cpi	r24, 0x3A	; 58
    e984:	10 f0       	brcs	.+4      	; 0xe98a <ascii2hex+0xc>
		retval += 0x0A + ascii[0] -'A';
    e986:	87 53       	subi	r24, 0x37	; 55
    e988:	01 c0       	rjmp	.+2      	; 0xe98c <ascii2hex+0xe>
	else
		retval += 0x00 + ascii[0] -'0';
    e98a:	80 53       	subi	r24, 0x30	; 48
	retval<<=4;
    e98c:	98 2f       	mov	r25, r24
    e98e:	92 95       	swap	r25
    e990:	90 7f       	andi	r25, 0xF0	; 240
	if(ascii[1] > '9')
    e992:	81 81       	ldd	r24, Z+1	; 0x01
    e994:	8a 33       	cpi	r24, 0x3A	; 58
    e996:	18 f0       	brcs	.+6      	; 0xe99e <ascii2hex+0x20>
		retval += 0x0A + ascii[1] -'A';
    e998:	87 53       	subi	r24, 0x37	; 55
    e99a:	89 0f       	add	r24, r25
    e99c:	08 95       	ret
	else
		retval += 0x00 + ascii[1] -'0';
    e99e:	80 53       	subi	r24, 0x30	; 48
    e9a0:	89 0f       	add	r24, r25
	return retval;
}
    e9a2:	08 95       	ret

0000e9a4 <ihex_process_line>:
	};
}

//called from ihex_char when a hex line is complete
void ihex_process_line(void)
{
    e9a4:	ef 92       	push	r14
    e9a6:	ff 92       	push	r15
    e9a8:	0f 93       	push	r16
    e9aa:	1f 93       	push	r17
    e9ac:	cf 93       	push	r28
    e9ae:	df 93       	push	r29
	char byte_count, *target, *source, checksum;
	unsigned char index;

	//if valid size
	if(isxdigit(hexline.ascii[1]) && isxdigit(hexline.ascii[2]))
    e9b0:	80 91 30 04 	lds	r24, 0x0430
    e9b4:	90 e0       	ldi	r25, 0x00	; 0
    e9b6:	0e 94 25 76 	call	0xec4a	; 0xec4a <isxdigit>
    e9ba:	89 2b       	or	r24, r25
    e9bc:	71 f0       	breq	.+28     	; 0xe9da <ihex_process_line+0x36>
    e9be:	80 91 31 04 	lds	r24, 0x0431
    e9c2:	90 e0       	ldi	r25, 0x00	; 0
    e9c4:	0e 94 25 76 	call	0xec4a	; 0xec4a <isxdigit>
    e9c8:	89 2b       	or	r24, r25
    e9ca:	39 f0       	breq	.+14     	; 0xe9da <ihex_process_line+0x36>
		hexline.ihex.byte_count = ascii2hex(&hexline.ascii[1]);
    e9cc:	80 e3       	ldi	r24, 0x30	; 48
    e9ce:	94 e0       	ldi	r25, 0x04	; 4
    e9d0:	0e 94 bf 74 	call	0xe97e	; 0xe97e <ascii2hex>
    e9d4:	80 93 2f 04 	sts	0x042F, r24
    e9d8:	02 c0       	rjmp	.+4      	; 0xe9de <ihex_process_line+0x3a>
	else
		hexline.ihex.byte_count=0;
    e9da:	10 92 2f 04 	sts	0x042F, r1

	//convert ascii to hex
	byte_count=hexline.ihex.byte_count+sizeof(struct ihex_struct)-1;
    e9de:	e0 90 2f 04 	lds	r14, 0x042F
    e9e2:	84 e0       	ldi	r24, 0x04	; 4
    e9e4:	e8 0e       	add	r14, r24
	target = &hexline.raw[1];
	source = &hexline.ascii[3];	//skip : and length field
	if(byte_count > (MAXLEN-6)/2)	//MAXLEN -'CR' -':' -'0terminator' -'size low byte' -'size hi byte'
    e9e6:	eb e1       	ldi	r30, 0x1B	; 27
    e9e8:	ee 15       	cp	r30, r14
    e9ea:	08 f4       	brcc	.+2      	; 0xe9ee <ihex_process_line+0x4a>
    e9ec:	ee 24       	eor	r14, r14
    e9ee:	00 e3       	ldi	r16, 0x30	; 48
    e9f0:	14 e0       	ldi	r17, 0x04	; 4
    e9f2:	e8 01       	movw	r28, r16
    e9f4:	22 96       	adiw	r28, 0x02	; 2
    e9f6:	08 c0       	rjmp	.+16     	; 0xea08 <ihex_process_line+0x64>
		byte_count=0;
	while(byte_count)
	{
		*target++=ascii2hex(source);
    e9f8:	ce 01       	movw	r24, r28
    e9fa:	0e 94 bf 74 	call	0xe97e	; 0xe97e <ascii2hex>
    e9fe:	f8 01       	movw	r30, r16
    ea00:	81 93       	st	Z+, r24
    ea02:	8f 01       	movw	r16, r30
		source+=2;
    ea04:	22 96       	adiw	r28, 0x02	; 2
		byte_count--;
    ea06:	ea 94       	dec	r14
	byte_count=hexline.ihex.byte_count+sizeof(struct ihex_struct)-1;
	target = &hexline.raw[1];
	source = &hexline.ascii[3];	//skip : and length field
	if(byte_count > (MAXLEN-6)/2)	//MAXLEN -'CR' -':' -'0terminator' -'size low byte' -'size hi byte'
		byte_count=0;
	while(byte_count)
    ea08:	ee 20       	and	r14, r14
    ea0a:	b1 f7       	brne	.-20     	; 0xe9f8 <ihex_process_line+0x54>
		source+=2;
		byte_count--;
	};

	//test checksum
	byte_count=hexline.ihex.byte_count+sizeof(struct ihex_struct)-1;
    ea0c:	80 91 2f 04 	lds	r24, 0x042F
    ea10:	8c 5f       	subi	r24, 0xFC	; 252
    ea12:	ef e2       	ldi	r30, 0x2F	; 47
    ea14:	f4 e0       	ldi	r31, 0x04	; 4
    ea16:	20 e0       	ldi	r18, 0x00	; 0
	checksum=0;
	index=0;
	while(byte_count--)
    ea18:	90 e0       	ldi	r25, 0x00	; 0
    ea1a:	8e 0f       	add	r24, r30
    ea1c:	9f 1f       	adc	r25, r31
    ea1e:	02 c0       	rjmp	.+4      	; 0xea24 <ihex_process_line+0x80>
		checksum-=hexline.raw[index++];
    ea20:	23 1b       	sub	r18, r19
    ea22:	31 96       	adiw	r30, 0x01	; 1
    ea24:	30 81       	ld	r19, Z

	//test checksum
	byte_count=hexline.ihex.byte_count+sizeof(struct ihex_struct)-1;
	checksum=0;
	index=0;
	while(byte_count--)
    ea26:	e8 17       	cp	r30, r24
    ea28:	f9 07       	cpc	r31, r25
    ea2a:	d1 f7       	brne	.-12     	; 0xea20 <ihex_process_line+0x7c>
		checksum-=hexline.raw[index++];
	
	if(checksum == hexline.raw[index])
    ea2c:	23 17       	cp	r18, r19
    ea2e:	09 f0       	breq	.+2      	; 0xea32 <ihex_process_line+0x8e>
    ea30:	7d c0       	rjmp	.+250    	; 0xeb2c <ihex_process_line+0x188>
	{
		if(hexline.ihex.type == IHEX_TYPE_DATA)
    ea32:	80 91 32 04 	lds	r24, 0x0432
    ea36:	88 23       	and	r24, r24
    ea38:	c1 f5       	brne	.+112    	; 0xeaaa <ihex_process_line+0x106>
		{
			//calculate actual address
			ihex_address=(unsigned long)read_bige_uint(hexline.ihex.address);
    ea3a:	80 91 30 04 	lds	r24, 0x0430
    ea3e:	90 91 31 04 	lds	r25, 0x0431
    ea42:	0e 94 92 74 	call	0xe924	; 0xe924 <read_bige_uint>
			ihex_address+=ext_seg_add;
			ihex_address+=ext_lin_add;
    ea46:	20 91 c0 01 	lds	r18, 0x01C0
    ea4a:	30 91 c1 01 	lds	r19, 0x01C1
    ea4e:	40 91 c2 01 	lds	r20, 0x01C2
    ea52:	50 91 c3 01 	lds	r21, 0x01C3
    ea56:	e0 90 bc 01 	lds	r14, 0x01BC
    ea5a:	f0 90 bd 01 	lds	r15, 0x01BD
    ea5e:	00 91 be 01 	lds	r16, 0x01BE
    ea62:	10 91 bf 01 	lds	r17, 0x01BF
    ea66:	2e 0d       	add	r18, r14
    ea68:	3f 1d       	adc	r19, r15
    ea6a:	40 1f       	adc	r20, r16
    ea6c:	51 1f       	adc	r21, r17
    ea6e:	a0 e0       	ldi	r26, 0x00	; 0
    ea70:	b0 e0       	ldi	r27, 0x00	; 0
    ea72:	28 0f       	add	r18, r24
    ea74:	39 1f       	adc	r19, r25
    ea76:	4a 1f       	adc	r20, r26
    ea78:	5b 1f       	adc	r21, r27
    ea7a:	20 93 b8 01 	sts	0x01B8, r18
    ea7e:	30 93 b9 01 	sts	0x01B9, r19
    ea82:	40 93 ba 01 	sts	0x01BA, r20
    ea86:	50 93 bb 01 	sts	0x01BB, r21
			
			//copy data to output
			memcpy(ihex_data, hexline.ihex.data, hexline.ihex.byte_count);
    ea8a:	2e e1       	ldi	r18, 0x1E	; 30
    ea8c:	34 e0       	ldi	r19, 0x04	; 4
    ea8e:	40 91 2f 04 	lds	r20, 0x042F
    ea92:	e3 e3       	ldi	r30, 0x33	; 51
    ea94:	f4 e0       	ldi	r31, 0x04	; 4
    ea96:	c9 01       	movw	r24, r18
    ea98:	bf 01       	movw	r22, r30
    ea9a:	50 e0       	ldi	r21, 0x00	; 0
    ea9c:	0e 94 3d 76 	call	0xec7a	; 0xec7a <memcpy>
			//copy byte count to output
			ihex_byte_count=hexline.ihex.byte_count;
    eaa0:	80 91 2f 04 	lds	r24, 0x042F
    eaa4:	80 93 2e 04 	sts	0x042E, r24
    eaa8:	44 c0       	rjmp	.+136    	; 0xeb32 <ihex_process_line+0x18e>
		}
		else if(hexline.ihex.type == IHEX_TYPE_EXT_SEG_ADD)
    eaaa:	82 30       	cpi	r24, 0x02	; 2
    eaac:	f9 f4       	brne	.+62     	; 0xeaec <ihex_process_line+0x148>
		{
			ext_seg_add=hexline.ihex.data[0];
			ext_seg_add<<=8;
			ext_seg_add+=hexline.ihex.data[1];
			ext_seg_add<<=4;
    eaae:	80 91 33 04 	lds	r24, 0x0433
    eab2:	90 e0       	ldi	r25, 0x00	; 0
    eab4:	a0 e0       	ldi	r26, 0x00	; 0
    eab6:	b0 e0       	ldi	r27, 0x00	; 0
    eab8:	ba 2f       	mov	r27, r26
    eaba:	a9 2f       	mov	r26, r25
    eabc:	98 2f       	mov	r25, r24
    eabe:	88 27       	eor	r24, r24
    eac0:	20 91 34 04 	lds	r18, 0x0434
    eac4:	82 0f       	add	r24, r18
    eac6:	91 1d       	adc	r25, r1
    eac8:	a1 1d       	adc	r26, r1
    eaca:	b1 1d       	adc	r27, r1
    eacc:	44 e0       	ldi	r20, 0x04	; 4
    eace:	88 0f       	add	r24, r24
    ead0:	99 1f       	adc	r25, r25
    ead2:	aa 1f       	adc	r26, r26
    ead4:	bb 1f       	adc	r27, r27
    ead6:	4a 95       	dec	r20
    ead8:	d1 f7       	brne	.-12     	; 0xeace <ihex_process_line+0x12a>
    eada:	80 93 bc 01 	sts	0x01BC, r24
    eade:	90 93 bd 01 	sts	0x01BD, r25
    eae2:	a0 93 be 01 	sts	0x01BE, r26
    eae6:	b0 93 bf 01 	sts	0x01BF, r27
    eaea:	23 c0       	rjmp	.+70     	; 0xeb32 <ihex_process_line+0x18e>
		}
		else if(hexline.ihex.type == IHEX_TYPE_EXT_LIN_ADD)
    eaec:	84 30       	cpi	r24, 0x04	; 4
    eaee:	d9 f4       	brne	.+54     	; 0xeb26 <ihex_process_line+0x182>
		{
			ext_lin_add=hexline.ihex.data[0];
			ext_lin_add<<=8;
			ext_lin_add+=hexline.ihex.data[1];
			ext_lin_add<<=16;
    eaf0:	80 91 33 04 	lds	r24, 0x0433
    eaf4:	90 e0       	ldi	r25, 0x00	; 0
    eaf6:	a0 e0       	ldi	r26, 0x00	; 0
    eaf8:	b0 e0       	ldi	r27, 0x00	; 0
    eafa:	ba 2f       	mov	r27, r26
    eafc:	a9 2f       	mov	r26, r25
    eafe:	98 2f       	mov	r25, r24
    eb00:	88 27       	eor	r24, r24
    eb02:	20 91 34 04 	lds	r18, 0x0434
    eb06:	82 0f       	add	r24, r18
    eb08:	91 1d       	adc	r25, r1
    eb0a:	a1 1d       	adc	r26, r1
    eb0c:	b1 1d       	adc	r27, r1
    eb0e:	dc 01       	movw	r26, r24
    eb10:	99 27       	eor	r25, r25
    eb12:	88 27       	eor	r24, r24
    eb14:	80 93 c0 01 	sts	0x01C0, r24
    eb18:	90 93 c1 01 	sts	0x01C1, r25
    eb1c:	a0 93 c2 01 	sts	0x01C2, r26
    eb20:	b0 93 c3 01 	sts	0x01C3, r27
    eb24:	06 c0       	rjmp	.+12     	; 0xeb32 <ihex_process_line+0x18e>
		}
		else if(hexline.ihex.type == IHEX_TYPE_EOF)
    eb26:	81 30       	cpi	r24, 0x01	; 1
    eb28:	21 f4       	brne	.+8      	; 0xeb32 <ihex_process_line+0x18e>
    eb2a:	01 c0       	rjmp	.+2      	; 0xeb2e <ihex_process_line+0x18a>
			ihex_status=IHEX_STATUS_EOF;
	}
	else
		ihex_status=IHEX_STATUS_ERROR;
    eb2c:	82 e0       	ldi	r24, 0x02	; 2
    eb2e:	80 93 1d 04 	sts	0x041D, r24
}
    eb32:	df 91       	pop	r29
    eb34:	cf 91       	pop	r28
    eb36:	1f 91       	pop	r17
    eb38:	0f 91       	pop	r16
    eb3a:	ff 90       	pop	r15
    eb3c:	ef 90       	pop	r14
    eb3e:	08 95       	ret

0000eb40 <ihex_char>:
	ihex_status=0;
}

//characters are passed to this function
void ihex_char(char x)
{
    eb40:	98 2f       	mov	r25, r24
	//start of new line?
	if(x==':')
    eb42:	8a 33       	cpi	r24, 0x3A	; 58
    eb44:	59 f4       	brne	.+22     	; 0xeb5c <ihex_char+0x1c>
	{
		line_ptr=hexline.ascii;
		*line_ptr=x;
    eb46:	80 93 2f 04 	sts	0x042F, r24
		line_ptr++;
    eb4a:	80 e3       	ldi	r24, 0x30	; 48
    eb4c:	94 e0       	ldi	r25, 0x04	; 4
    eb4e:	90 93 1c 04 	sts	0x041C, r25
    eb52:	80 93 1b 04 	sts	0x041B, r24
		*line_ptr=0;
    eb56:	10 92 30 04 	sts	0x0430, r1
    eb5a:	08 95       	ret
	}
	//else if line in progress, append to line
	else if(hexline.ascii[0]==':')
    eb5c:	80 91 2f 04 	lds	r24, 0x042F
    eb60:	8a 33       	cpi	r24, 0x3A	; 58
    eb62:	e1 f4       	brne	.+56     	; 0xeb9c <ihex_char+0x5c>
	{
		if(line_ptr != &hexline.ascii[MAXLEN-1])
    eb64:	a0 91 1b 04 	lds	r26, 0x041B
    eb68:	b0 91 1c 04 	lds	r27, 0x041C
    eb6c:	84 e0       	ldi	r24, 0x04	; 4
    eb6e:	aa 36       	cpi	r26, 0x6A	; 106
    eb70:	b8 07       	cpc	r27, r24
    eb72:	41 f0       	breq	.+16     	; 0xeb84 <ihex_char+0x44>
		{
			*line_ptr++=x;
    eb74:	fd 01       	movw	r30, r26
    eb76:	91 93       	st	Z+, r25
    eb78:	f0 93 1c 04 	sts	0x041C, r31
    eb7c:	e0 93 1b 04 	sts	0x041B, r30
			*line_ptr=0;
    eb80:	11 96       	adiw	r26, 0x01	; 1
    eb82:	1c 92       	st	X, r1
		};
		if(x=='\r')
    eb84:	9d 30       	cpi	r25, 0x0D	; 13
    eb86:	51 f4       	brne	.+20     	; 0xeb9c <ihex_char+0x5c>
		{
			ihex_process_line();
    eb88:	0e 94 d2 74 	call	0xe9a4	; 0xe9a4 <ihex_process_line>
			line_ptr=hexline.ascii;
    eb8c:	8f e2       	ldi	r24, 0x2F	; 47
    eb8e:	94 e0       	ldi	r25, 0x04	; 4
    eb90:	90 93 1c 04 	sts	0x041C, r25
    eb94:	80 93 1b 04 	sts	0x041B, r24
			*line_ptr=0;
    eb98:	10 92 2f 04 	sts	0x042F, r1
    eb9c:	08 95       	ret

0000eb9e <fifo_read_char>:

char fifo_read_char(void)
{
	char retval=0;
	
	while(uart_fifo_rx.bytes_used==0);
    eb9e:	80 91 c5 02 	lds	r24, 0x02C5
    eba2:	88 23       	and	r24, r24
    eba4:	e1 f3       	breq	.-8      	; 0xeb9e <fifo_read_char>

	retval=*((char*)uart_fifo_rx.tail_ptr);
    eba6:	e0 91 c8 02 	lds	r30, 0x02C8
    ebaa:	f0 91 c9 02 	lds	r31, 0x02C9
    ebae:	e0 81       	ld	r30, Z
	uart_fifo_rx.tail_ptr++;	
    ebb0:	80 91 c8 02 	lds	r24, 0x02C8
    ebb4:	90 91 c9 02 	lds	r25, 0x02C9
    ebb8:	01 96       	adiw	r24, 0x01	; 1
    ebba:	90 93 c9 02 	sts	0x02C9, r25
    ebbe:	80 93 c8 02 	sts	0x02C8, r24
	
	if(uart_fifo_rx.tail_ptr == uart_fifo_rx.end)
    ebc2:	20 91 c8 02 	lds	r18, 0x02C8
    ebc6:	30 91 c9 02 	lds	r19, 0x02C9
    ebca:	80 91 cc 02 	lds	r24, 0x02CC
    ebce:	90 91 cd 02 	lds	r25, 0x02CD
    ebd2:	28 17       	cp	r18, r24
    ebd4:	39 07       	cpc	r19, r25
    ebd6:	41 f4       	brne	.+16     	; 0xebe8 <fifo_read_char+0x4a>
		uart_fifo_rx.tail_ptr = uart_fifo_rx.start;
    ebd8:	80 91 ca 02 	lds	r24, 0x02CA
    ebdc:	90 91 cb 02 	lds	r25, 0x02CB
    ebe0:	90 93 c9 02 	sts	0x02C9, r25
    ebe4:	80 93 c8 02 	sts	0x02C8, r24
    ebe8:	f8 94       	cli

	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		uart_fifo_rx.bytes_free ++;
    ebea:	80 91 c4 02 	lds	r24, 0x02C4
    ebee:	8f 5f       	subi	r24, 0xFF	; 255
    ebf0:	80 93 c4 02 	sts	0x02C4, r24
		uart_fifo_rx.bytes_used --;
    ebf4:	80 91 c5 02 	lds	r24, 0x02C5
    ebf8:	81 50       	subi	r24, 0x01	; 1
    ebfa:	80 93 c5 02 	sts	0x02C5, r24
    ebfe:	78 94       	sei
	}

	return retval;
}
    ec00:	8e 2f       	mov	r24, r30
    ec02:	08 95       	ret

0000ec04 <fifo_flush>:
	fifo_flush(obj);
} 

//100506, made atomic so pointers cannot be corrupted by ISR's
void fifo_flush(struct fifo_control *obj)
{
    ec04:	fc 01       	movw	r30, r24
	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
    ec06:	4f b7       	in	r20, 0x3f	; 63
    ec08:	f8 94       	cli
	{
		(*obj).tail_ptr = (*obj).start;
    ec0a:	86 81       	ldd	r24, Z+6	; 0x06
    ec0c:	97 81       	ldd	r25, Z+7	; 0x07
    ec0e:	95 83       	std	Z+5, r25	; 0x05
    ec10:	84 83       	std	Z+4, r24	; 0x04
		(*obj).head_ptr = (*obj).start;
    ec12:	86 81       	ldd	r24, Z+6	; 0x06
    ec14:	97 81       	ldd	r25, Z+7	; 0x07
    ec16:	93 83       	std	Z+3, r25	; 0x03
    ec18:	82 83       	std	Z+2, r24	; 0x02
		(*obj).bytes_free=(*obj).end-(*obj).start;
    ec1a:	80 85       	ldd	r24, Z+8	; 0x08
    ec1c:	91 85       	ldd	r25, Z+9	; 0x09
    ec1e:	26 81       	ldd	r18, Z+6	; 0x06
    ec20:	37 81       	ldd	r19, Z+7	; 0x07
    ec22:	82 1b       	sub	r24, r18
    ec24:	80 83       	st	Z, r24
		(*obj).bytes_used=0;
    ec26:	11 82       	std	Z+1, r1	; 0x01
    ec28:	4f bf       	out	0x3f, r20	; 63
	}
}
    ec2a:	08 95       	ret

0000ec2c <fifo_init>:
	return retval;
}


void fifo_init(struct fifo_control *obj, unsigned int size, void(*post_fptr)(void), void* data_space)
{
    ec2c:	fc 01       	movw	r30, r24
	(*obj).start = data_space;
    ec2e:	37 83       	std	Z+7, r19	; 0x07
    ec30:	26 83       	std	Z+6, r18	; 0x06
	(*obj).end=(*obj).start + size;		// note, end points to last item in buffer + 1
    ec32:	86 81       	ldd	r24, Z+6	; 0x06
    ec34:	97 81       	ldd	r25, Z+7	; 0x07
    ec36:	86 0f       	add	r24, r22
    ec38:	97 1f       	adc	r25, r23
    ec3a:	91 87       	std	Z+9, r25	; 0x09
    ec3c:	80 87       	std	Z+8, r24	; 0x08
	(*obj).post_fptr=post_fptr;
    ec3e:	53 87       	std	Z+11, r21	; 0x0b
    ec40:	42 87       	std	Z+10, r20	; 0x0a
	fifo_flush(obj);
    ec42:	cf 01       	movw	r24, r30
    ec44:	0e 94 02 76 	call	0xec04	; 0xec04 <fifo_flush>
} 
    ec48:	08 95       	ret

0000ec4a <isxdigit>:
    ec4a:	91 11       	cpse	r25, r1
    ec4c:	53 c0       	rjmp	.+166    	; 0xecf4 <__ctype_isfalse>
    ec4e:	80 53       	subi	r24, 0x30	; 48
    ec50:	8a 50       	subi	r24, 0x0A	; 10
    ec52:	28 f0       	brcs	.+10     	; 0xec5e <isxdigit+0x14>
    ec54:	86 5c       	subi	r24, 0xC6	; 198
    ec56:	80 62       	ori	r24, 0x20	; 32
    ec58:	81 56       	subi	r24, 0x61	; 97
    ec5a:	86 50       	subi	r24, 0x06	; 6
    ec5c:	b8 f7       	brcc	.-18     	; 0xec4c <isxdigit+0x2>
    ec5e:	08 95       	ret

0000ec60 <memcmp_P>:
    ec60:	fb 01       	movw	r30, r22
    ec62:	dc 01       	movw	r26, r24
    ec64:	04 c0       	rjmp	.+8      	; 0xec6e <memcmp_P+0xe>
    ec66:	8d 91       	ld	r24, X+
    ec68:	05 90       	lpm	r0, Z+
    ec6a:	80 19       	sub	r24, r0
    ec6c:	21 f4       	brne	.+8      	; 0xec76 <memcmp_P+0x16>
    ec6e:	41 50       	subi	r20, 0x01	; 1
    ec70:	50 40       	sbci	r21, 0x00	; 0
    ec72:	c8 f7       	brcc	.-14     	; 0xec66 <memcmp_P+0x6>
    ec74:	88 1b       	sub	r24, r24
    ec76:	99 0b       	sbc	r25, r25
    ec78:	08 95       	ret

0000ec7a <memcpy>:
    ec7a:	fb 01       	movw	r30, r22
    ec7c:	dc 01       	movw	r26, r24
    ec7e:	02 c0       	rjmp	.+4      	; 0xec84 <memcpy+0xa>
    ec80:	01 90       	ld	r0, Z+
    ec82:	0d 92       	st	X+, r0
    ec84:	41 50       	subi	r20, 0x01	; 1
    ec86:	50 40       	sbci	r21, 0x00	; 0
    ec88:	d8 f7       	brcc	.-10     	; 0xec80 <memcpy+0x6>
    ec8a:	08 95       	ret

0000ec8c <ltoa>:
    ec8c:	fa 01       	movw	r30, r20
    ec8e:	cf 93       	push	r28
    ec90:	ff 93       	push	r31
    ec92:	ef 93       	push	r30
    ec94:	22 30       	cpi	r18, 0x02	; 2
    ec96:	44 f1       	brlt	.+80     	; 0xece8 <ltoa+0x5c>
    ec98:	25 32       	cpi	r18, 0x25	; 37
    ec9a:	34 f5       	brge	.+76     	; 0xece8 <ltoa+0x5c>
    ec9c:	c2 2f       	mov	r28, r18
    ec9e:	e8 94       	clt
    eca0:	ca 30       	cpi	r28, 0x0A	; 10
    eca2:	49 f4       	brne	.+18     	; 0xecb6 <ltoa+0x2a>
    eca4:	97 fb       	bst	r25, 7
    eca6:	3e f4       	brtc	.+14     	; 0xecb6 <ltoa+0x2a>
    eca8:	90 95       	com	r25
    ecaa:	80 95       	com	r24
    ecac:	70 95       	com	r23
    ecae:	61 95       	neg	r22
    ecb0:	7f 4f       	sbci	r23, 0xFF	; 255
    ecb2:	8f 4f       	sbci	r24, 0xFF	; 255
    ecb4:	9f 4f       	sbci	r25, 0xFF	; 255
    ecb6:	2c 2f       	mov	r18, r28
    ecb8:	33 27       	eor	r19, r19
    ecba:	44 27       	eor	r20, r20
    ecbc:	55 27       	eor	r21, r21
    ecbe:	ff 93       	push	r31
    ecc0:	ef 93       	push	r30
    ecc2:	0e 94 8d 76 	call	0xed1a	; 0xed1a <__udivmodsi4>
    ecc6:	ef 91       	pop	r30
    ecc8:	ff 91       	pop	r31
    ecca:	60 5d       	subi	r22, 0xD0	; 208
    eccc:	6a 33       	cpi	r22, 0x3A	; 58
    ecce:	0c f0       	brlt	.+2      	; 0xecd2 <ltoa+0x46>
    ecd0:	69 5d       	subi	r22, 0xD9	; 217
    ecd2:	61 93       	st	Z+, r22
    ecd4:	b9 01       	movw	r22, r18
    ecd6:	ca 01       	movw	r24, r20
    ecd8:	60 50       	subi	r22, 0x00	; 0
    ecda:	70 40       	sbci	r23, 0x00	; 0
    ecdc:	80 40       	sbci	r24, 0x00	; 0
    ecde:	90 40       	sbci	r25, 0x00	; 0
    ece0:	51 f7       	brne	.-44     	; 0xecb6 <ltoa+0x2a>
    ece2:	16 f4       	brtc	.+4      	; 0xece8 <ltoa+0x5c>
    ece4:	cd e2       	ldi	r28, 0x2D	; 45
    ece6:	c1 93       	st	Z+, r28
    ece8:	10 82       	st	Z, r1
    ecea:	8f 91       	pop	r24
    ecec:	9f 91       	pop	r25
    ecee:	cf 91       	pop	r28
    ecf0:	0c 94 7d 76 	jmp	0xecfa	; 0xecfa <strrev>

0000ecf4 <__ctype_isfalse>:
    ecf4:	99 27       	eor	r25, r25
    ecf6:	88 27       	eor	r24, r24

0000ecf8 <__ctype_istrue>:
    ecf8:	08 95       	ret

0000ecfa <strrev>:
    ecfa:	dc 01       	movw	r26, r24
    ecfc:	fc 01       	movw	r30, r24
    ecfe:	67 2f       	mov	r22, r23
    ed00:	71 91       	ld	r23, Z+
    ed02:	77 23       	and	r23, r23
    ed04:	e1 f7       	brne	.-8      	; 0xecfe <strrev+0x4>
    ed06:	32 97       	sbiw	r30, 0x02	; 2
    ed08:	04 c0       	rjmp	.+8      	; 0xed12 <strrev+0x18>
    ed0a:	7c 91       	ld	r23, X
    ed0c:	6d 93       	st	X+, r22
    ed0e:	70 83       	st	Z, r23
    ed10:	62 91       	ld	r22, -Z
    ed12:	ae 17       	cp	r26, r30
    ed14:	bf 07       	cpc	r27, r31
    ed16:	c8 f3       	brcs	.-14     	; 0xed0a <strrev+0x10>
    ed18:	08 95       	ret

0000ed1a <__udivmodsi4>:
    ed1a:	a1 e2       	ldi	r26, 0x21	; 33
    ed1c:	1a 2e       	mov	r1, r26
    ed1e:	aa 1b       	sub	r26, r26
    ed20:	bb 1b       	sub	r27, r27
    ed22:	fd 01       	movw	r30, r26
    ed24:	0d c0       	rjmp	.+26     	; 0xed40 <__udivmodsi4_ep>

0000ed26 <__udivmodsi4_loop>:
    ed26:	aa 1f       	adc	r26, r26
    ed28:	bb 1f       	adc	r27, r27
    ed2a:	ee 1f       	adc	r30, r30
    ed2c:	ff 1f       	adc	r31, r31
    ed2e:	a2 17       	cp	r26, r18
    ed30:	b3 07       	cpc	r27, r19
    ed32:	e4 07       	cpc	r30, r20
    ed34:	f5 07       	cpc	r31, r21
    ed36:	20 f0       	brcs	.+8      	; 0xed40 <__udivmodsi4_ep>
    ed38:	a2 1b       	sub	r26, r18
    ed3a:	b3 0b       	sbc	r27, r19
    ed3c:	e4 0b       	sbc	r30, r20
    ed3e:	f5 0b       	sbc	r31, r21

0000ed40 <__udivmodsi4_ep>:
    ed40:	66 1f       	adc	r22, r22
    ed42:	77 1f       	adc	r23, r23
    ed44:	88 1f       	adc	r24, r24
    ed46:	99 1f       	adc	r25, r25
    ed48:	1a 94       	dec	r1
    ed4a:	69 f7       	brne	.-38     	; 0xed26 <__udivmodsi4_loop>
    ed4c:	60 95       	com	r22
    ed4e:	70 95       	com	r23
    ed50:	80 95       	com	r24
    ed52:	90 95       	com	r25
    ed54:	9b 01       	movw	r18, r22
    ed56:	ac 01       	movw	r20, r24
    ed58:	bd 01       	movw	r22, r26
    ed5a:	cf 01       	movw	r24, r30
    ed5c:	08 95       	ret

0000ed5e <_exit>:
    ed5e:	f8 94       	cli

0000ed60 <__stop_program>:
    ed60:	ff cf       	rjmp	.-2      	; 0xed60 <__stop_program>
