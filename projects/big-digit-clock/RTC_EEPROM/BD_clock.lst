
AVRASM ver. 2.1.2  BD_clock.asm Tue Jan 13 15:31:14 2015

BD_clock.asm(55): Including file 'M8def.inc'
                 
                 
                 ;  __ 10 digits plus colon & space   _adapted chars are 12 columns by 3 bytes (24 pixels) high
                 ;  _36 bytes per digit character     396 bytes total
                 ;   12/25/2014 9:39PM  Merry Christmas!
                 ;
                 ; Use Lucida Console font to see listings correctly.
                 ;
                 ;command line to assemble this file:
                 ;   C:\Program Files\Atmel\AVR Tools\AvrAssembler2\avrasm2 -fI  BD_clock.asm  -l BD_clock.lst -o BD_clock.hex
                 ; 
                 ; To set the real-time clock IC, adjust the values in the RTCdata array (above the Get_RTC routine),    
                 ;  uncomment the 'rcall SetRTC' line after initLoop0, assemble, and load.  Then re-assemble and load    
                 ;  with the 'rcall SetRTC' line re-commented.  Worst kludge that I've ever done, but it works.          
                 ;
                 ;==================================================================================================
                 ;
                 ;	   Atmel AVR Mega8  [8K flash / 1K SRAM [address range:0x100 to 0x4ff]/ 512 EEPROM]
                 ;                          _______
                 ;      reset/  Nokia_reset |1  28| PC5 SCL  to real time clock board
                 ;                      PD0 |2  27| PC4 SDA  to real time clock board 
                 ;                      PD1 |3  26| ADC3
                 ;                      PD2 |4  25| ADC2
                 ;                      PD3 |5  24| ADC1
                 ;                      PD4 |6  23| ADC0
                 ;                 +5V  VCC |7  22| GND
                 ;                      GND |8  21| AREF  +5V                ______
                 ;                      PB6 |9  20| AVCC  +5V           MISO |1  2| Vcc (nc)
                 ;                      PB7 |10 19| PB5  SCK	       SCLK |3  4| MOSI
                 ;                      PD5 |11 18| PB4  MOSI	       RST  |5  6| gnd
                 ;                      PD6 |12 17| PB3  MISO	            ------
                 ;                      PD7 |13 16| PB2  Nokia_SDIN           ISP
                 ;          Nokia_DC    PB0 |14 15| PB1  Nokia_SCLK
                 ;                          -------
                 ;==================================================================================================
                 ;
                 ; Differences between Mega8 and Mega328: IRQ vectors 16-bit, no GPIOR in Mega8, Peripheral reg locations.
                 
                 
                 .cseg
                 .org 0x0013
                 ;&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
                 ;   14 x 6 =                           1111 	;&
                 ;   84 total scr chars       01234567890123 	;&
000013 4442
000014 635f
000015 6f6c
000016 6b63
000017 612e
000018 6d73
000019 2020      Line0_OpenMsg:		.db "BD_clock.asm  "	;&
00001a 6544
00001b 2063
00001c 3632
00001d 202c
00001e 3032
00001f 3431
000020 2020      			.db "Dec 26, 2014  "	;&
000021 7562
000022 6c69
000023 3a64
000024 6420
000025 2020
000026 3176
000027 302e      			.db "build: d  v1.0"	;&
000028 2020
000029 2020
00002a 2020
00002b 2020
00002c 2020
00002d 2020
00002e 2020      			.db "              "	;&
00002f 6c41
000030 6e61
000031 5020
000032 6f72
000033 6162
000034 646e
000035 2074      			.db "Alan Probandt "	;&
000036 6f50
000037 7472
000038 616c
000039 646e
00003a 4f2c
00003b 2052
00003c 2020
00003d 0000      			.db "Portland,OR   ",0,0;&
                 ;&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
                 
                 
                 
                 .list
                 ;
                 ;======================================
                 ; TIMER equates  (for AVR Mega8)
                 ;--------------------------------------
                 .equ	clock			=  8000000	; AVR internal system clock [in Hertz]
                 .equ	OPENING_SCREEN_TIME 	=  3	; seconds
                 .equ	Contrast_Value		=  53
                 
                 .equ	HB_PRESCALE		=  256	; prescaler for 32 mS increment  using timer 1
                 .equ	HB_LOGIC		=  (1<<CS12) | (0<<CS11) | (0<<CS10)
                 .equ	HB_PER_SECOND		=  32	; Heartbeat periods per second. Each period is 31.25 milliSecond
                 .equ	LongPeriod 		=  (clock / HB_PRESCALE) / HB_PER_SECOND   ; HBS=32 >> 977 counts upward
                 
                 
                 ;##############################################################################################
                 ;
                 ;=======================================
                 ; LCD display equates for Nokia 5110
                 ;---------------------------------------
                 .equ	PIN_DC			=  0
                 .equ	PIN_SDIN		=  2
                 .equ	PIN_SCLK		=  1
                 .equ	PORT_DC			= PortB
                 .equ	PORT_SDIN		= PortB
                 .equ	PORT_SCLK		= PortB
                 .equ	DDR_DC			= DDRB
                 .equ	DDR_SDIN		= DDRB
                 .equ	DDR_SCLK		= DDRB
                 .equ	LCD_D			=  1		; Configuration for the LCD
                 .equ	LCD_CMD			=  0
                 .equ	LCD_X			= 84		; Size of the LCD
                 .equ	LCD_Y			= 48
                 .equ	NOKIA_STRING_SIZE	= 14
                 .equ	PIXELSperCHAR		=  6		; five dots and one space
                 .equ	NUM_ROWS_PER_CHAR	=  3
                 .equ	BIGCHARWIDTH            = 12
                 .equ	BIGSPACEOFFSET		= 11	; offset of beginning of space character data in BigDigits table
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 
                 .equ	LED_DDR		= DDRD
                 .equ	LED_PORT	= PORTD
                 .equ	LED_DEBUG	= 5
                 .equ	SLA_RTC		= 0xd0  ; 8-bit slave address 1101 for RealTimeClock IC: device address 000
                 .equ	RTC_STARTADDR	= 0	; only used by SetRTC
                 .equ	RTCreadSIZE	= 8	; 0x08 for DS1307 RTC IC: 0x0e when using DS3231 RTC IC
                 .equ	RTCwriteSIZE	= 8	; 0x08 for DS1307 RTC IC: 0x0e when using DS3231 RTC IC
                  .equ	TWISTOPDELAY	= 45 	; 135 cycles at 0.125uSec/cycle   16.8uSec
                 
                 
                 ;=====================================
                 ;
                 ;  	REGISTER Definitions
                 ;
                 ;=====================================
                 ;
                 ;; low register use   r0 - r15
                 .def	lowTemp0	= r2
                 .def	lowTemp1	= r3
                 .def	rBin1L		= r4
                 .def	rBin1H		= r5
                 .def	rBin2L		= r6
                 .def	rBin2H		= r7
                 .def	ColumnCounter	= r8
                 .def	wTemp0		= r10	; found in Nokia 5110 LCD routines
                 .def	wTemp1		= r11	; found in Nokia 5110 LCD routines
                 .def	counter		= r12	; found in PS2 keyboard routines
                 .def	SREGtemp 	= r14	; found in interrupt routines
                 .def	ZeroReg		= r15	; found in 16-bit add routines
                 
                 ;  upper registers   r16 - r31
                 .def	temp		= r16
                 .def	temp2		= r17
                 .def	temp3		= r18
                 .def	irqtemp		= r19
                 
                 
                 ; upper register pairs:  r31:r30--ZH:ZL  r29:r28--YH:YL  r27:r26--XH:XL
                 ;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                 
                 ;================================================================================================
                 ;
                 ;	SRAM Definitions
                 ;
                 ;================================================================================================
                 .dseg ; 1024 bytes SRAM in mega8  START = 0x0060  RAMEND= 0x045f
000060           HeartBeatCntr:		.byte	1  ; 0x060
000061           SecondCount:		.byte	1  ; 0x061
000062           HighSecCount:		.byte	1  ; 0x062
000063           PrevSecCount:		.byte	1  ; 0x063
000064           PrevHiSecCnt:		.byte	1  ; 0x064
000065           VarByteOne:		.byte	1  ; 0x065
000066           VarByteTwo:		.byte	1  ; 0x066
000067           VarByteThree:		.byte	1  ; 0x067
000068           PtrOneLow:		.byte	1  ; 0x068
000069           PtrOneHigh:		.byte	1  ; 0x069
00006a           DataByte:		.byte	1  ; 0x06a
00006b           Yposition:		.byte	1  ; 0x06b
00006c           Xposition:		.byte	1  ; 0x06c
00006d           TaskFlags:		.byte	1  ; 0x06d
                   .equ	T1_HeartBeat	= 7
                   .equ	TWIer_flag	= 6
                   .equ	BlinkLED	= 5
                   .equ	SetGetFlag 	= 4 ; clr is set routine, set is get routine
                 
00006e           ByteASChigh:		.byte	1  ; 0x06e
00006f           ByteASCLow:		.byte	1  ; 0x06f
000070           ExpectedTWSR:		.byte	1  ; 0x070
000071           ReceivedTWSR:		.byte	1  ; 0x071
000072           RTCBuffer:		.byte   18 ; 0x072
000084           ASCIIdigits:		.byte	5  ; 0x084
000089           ZeroLoc:		.byte	1  ; 0x089
00008a           resultL:		.byte	1  ; 0x08a
00008b           resultH:		.byte	1  ; 0x08b
00008c           TWIstep:		.byte	1  ; 0x08c
00008d           HighAddress:		.byte	1  ; 0x08c
00008e           LowAddress:		.byte	1  ; 0x08c
00008f           ReadBlockSize:		.byte	1  ; 0x08c
                 
000090           Page_Buffer:		.byte	128  ; 0x08c
                 
                 
                 
                 
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 
                 
                 .cseg
                 .org 0x0000
                 ;************************************************************************************************
                 ; interrupt vectors for Mega8
000000 c03f      	rjmp	reset		; rjmp reset is firmware-system-crash-handling code.
                 ; ***** INTERRUPT VECTORS ***********************************************************
000001 c03e      	rjmp	reset		; = 0x001  External Interrupt Request 0
000002 c03d      	rjmp	reset		; = 0x002  External Interrupt Request 1
000003 c03c      	rjmp	reset		; = 0x003  Timer/Counter2 Compare Match
000004 c03b      	rjmp	reset		; = 0x004  Timer/Counter2 Overflow
000005 c03a      	rjmp	reset		; = 0x005  Timer/Counter1 Capture Event
000006 c039      	rjmp	reset		; = 0x006  Timer/Counter1 Compare Match A
000007 c038      	rjmp	reset		; = 0x007  Timer/Counter1 Compare Match B
000008 c306      	rjmp	TIM1_OVF	; = 0x008  Timer/Counter1 Overflow
000009 c036      	rjmp	reset		; = 0x009  Timer/Counter0 Overflow
00000a c035      	rjmp	reset		; = 0x00a  Serial Transfer Complete
00000b c034      	rjmp	reset		; = 0x00b  USART, Rx Complete
00000c c033      	rjmp	reset		; = 0x00c  USART Data Register Empty
00000d c032      	rjmp	reset		; = 0x00d  USART, Tx Complete
00000e c031      	rjmp	reset		; = 0x00e  ADC Conversion Complete
00000f c030      	rjmp	reset		; = 0x00f  EEPROM Ready
000010 c02f      	rjmp	reset		; = 0x010  Analog Comparator
000011 c02e      	rjmp	reset		; = 0x011  2-wire Serial Interface
000012 c02d      	rjmp	reset		; = 0x012  Store Program Memory Ready
                 
                 ;=======================================================================================================
                 .org 0x040
                 reset:
000040 e004      	ldi	temp, high (RAMEND)	; On Mega8, need to initialize stack pointer to end of SRAM.
000041 bf0e      	out	SPH, temp		; Not needed on other Mega AVRs, but good idea to do
000042 e50f      	ldi	temp, low  (RAMEND)	; in case your embedded-system crash handler code jumps
000043 bf0d      	out	SPL, temp		; to reset (flash addr 000) instead of doing a hardware reset.
                 
                 ;----------------------------------------------------------------------------------------------
                 ; initialize Timer 1  16bit  32mSecond increments; overflows 32 times a second  HB_PER_SECOND
000044 e004      	ldi	temp, (1 << TOV1)
000045 bf08      	out	TIFR, temp              ; clear interrupt flag.  use TIFR1:0x16 for Mega328
000046 e004      	ldi	temp, (1 << TOIE1)
000047 bf09      	out	TIMSK, temp		; enable interrupt.   use TIMSK1:0x6f for Mega328
000048 ef0c      	ldi	temp, high (~LongPeriod ) ; write high byte of 16-bit value first
000049 bd0d      	out	TCNT1H, temp		; TCNT1H [Mega328= 0x85]
00004a e20f      	ldi	temp, low  (~LongPeriod )
00004b bd0c      	out	TCNT1L, temp 		; TCNT1L [Mega328= 0x84]
00004c e004      	ldi	temp, HB_LOGIC		; ( (1<<CS12) | (0<<CS11) | (0<<CS10) )
00004d bd0e      	out	TCCR1B, temp		; [Mega328:TCCR1B= 0x81] increment timer every 256 system clocks
00004e 2700      	clr	temp
00004f 9300 0060 	sts	HeartBeatCntr, temp
                 
                 ;----------------------------------------------------------------------------------------------
                 ; initialize TwoWire Interface
000051 e203      	ldi 	temp, 35		; cpu clock / (16 + (2*twbr) * prescale
000052 b900      	out	twbr, temp		; 8000000/86 = 93 KHz TWI/I2C clock rate
000053 e000      	ldi 	temp, 0x00		; prescale bits: 0 0   prescaler value = 1
000054 b901      	out 	twsr, temp		; TW status Reg.
000055 2700      	clr 	temp
000056 b902      	out 	twar, temp		; TW address Reg.  only used when Mega8 is a I2C slave
000057 e004      	ldi 	temp, (1 << TWEN)	; 0b00000100
000058 bf06      	out	twcr, temp 		; TW control Reg
                 
                 ;	(0<<TWINT)|(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|(0<<TWWC)|(1<<TWEN)|(0<<TWIE)
                 ;	   bit 7	6	5	    4	       3	2	   0
                 ; initial value all 0 at reset.
                 ;
                 ; control byte for 24LC512, 24LC256, 24LC128, 24LC64, -- 1010 control code, IC addr 3 bits (always 1 0 0), R/w bit
                 ;	ldi	temp,  0b10101001
                 ;	sts	ControlByte, temp
                 
                 ;  writing a logic 1 to TWINT is only way to clear this interrupt flag.
                 ;  It gets set when TWI has finished its current job.
                 ;  clearing TWINT starts the next operation of the TWI, so TWAR, TWSR,
                 ;  and TWDR must be ready before clearing TWINT.
                 ;
                 ;  if TWEA is set, then an ACK will be written by the TWI
                 ;   when a byte is received in Master Receiver mode.
                 ;----------------------------------------------------------------------------------------------
                 
                 
                 ; initialize global interrupt enable
000059 9478      	sei	; switch on the AVR general interrupt enabler
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 ;
                 ;
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 ; initialize application
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 ; initialize (usually clear) variables
00005a 24ff      	clr	ZeroReg
00005b 92f0 006d 	sts	TaskFlags,    ZeroReg
00005d 92f0 0089 	sts	ZeroLoc,      ZeroReg
00005f 92f0 0061 	sts	secondCount,  ZeroReg
000061 92f0 0063 	sts	PrevSecCount, ZeroReg
000063 92f0 0062 	sts	HighSecCount, ZeroReg
000065 92f0 0064 	sts	PrevHiSecCnt, ZeroReg
000067 92f0 006c 	sts	XPosition,    ZeroReg
000069 92f0 006b 	sts	YPosition,    ZeroReg
                 
00006b d0a7       	rcall	LCD_Initialize		; write seven commands to Nokia 5110
                 
00006c 2700      	clr	temp			; set display cursor to upper left of screen
00006d 9300 0065 	sts	VarByteOne, temp
00006f 9300 0066 	sts	VarByteTwo, temp
000071 d14b      	rcall	LCD_gotoXY
                 
                  ; display opening screen
000072 e000      	ldi	temp, high (Line0_OpenMsg << 1 )
000073 9300 0069 	sts	PtrOneHigh, temp
000075 e206      	ldi	temp, low  (Line0_OpenMsg << 1)
000076 9300 0068 	sts	PtrOneLow, temp
000078 d0cf      	rcall	LCD_stringP
                 
                 initLoop0:
000079 9100 0061 	lds	temp, secondCount
00007b 3003      	cpi	temp, OPENING_SCREEN_TIME
00007c f7e1      	brne	initLoop0
                 
00007d d107       	rcall	LCD_clear
                 
                 ;       rcall	SetRTC
                 ; to set the real-time clock IC, adjust the values in the RTCdata array (above the Get_RTC routine),            
                 ;  uncomment the 'rcall SetRTC' line after initLoop0, assemble, and load.  Then re-assemble and load            
                 ;  with the 'rcall SetRTC' line re-commented.  Worst kludge that I've ever done, but it works.
                 
                 
                 ;##############################################################################################
                 ;						;##############################################
                 ;  Main Code loop				;##############################################
                 ;						;##############################################
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;##############################################
                 main_loop:					;####					   ####
00007e 9100 006d 	lds	temp, TaskFlags			;####	 Heartbeat time?  32 a second	   ####
000080 ff07      	sbrs	temp, T1_HeartBeat		;####	 flicker LED; get pot values.	   ####
000081 c001      	rjmp	ml_noNew_HeartBeat 		;####					   ####
000082 d001      	rcall	HeartBeat_Period		;##############################################
                 ml_noNew_HeartBeat:				;##############################################
                 						;##############################################
                 						;##############################################
000083 cffa      	rjmp	main_loop			;##############################################
                 ;						;##############################################
                 ;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                 
                 
                 
                 
                 ;***************************************************************;**********
                 ;  HeartBeat   Branch to here HB_PER_SECOND 			; HeartBeat
                 ;    Branches here from main when mainloop detects		; HeartBeat
                 ;     TaskFlags:T1_Heartbeat is set.				; HeartBeat
                 ; 								; HeartBeat
                 ;  Checks for debug-indicator (quick flash of LED) is active.	; HeartBeat
                 ;  if yes, then turn on LED until next time HBcntr mod 32=0.	; HeartBeat
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; HeartBeat
                 HeartBeat_Period:						; HeartBeat
000084 930f      	push	temp						; HeartBeat
000085 93ff      	push	ZH						; HeartBeat
000086 93ef      	push	ZL						; HeartBeat
                 ;								; HeartBeat
000087 9100 006d 	lds	temp, TaskFlags ; turn off T1_HB flag		; HeartBeat
000089 770f      	cbr	temp, ( 1 << T1_HeartBeat )			; HeartBeat
00008a 9300 006d 	sts	TaskFlags, temp					; HeartBeat
                 ;								; HeartBeat
                 ; Check for active LED-flicker debugging-indicator =============; HeartBeat
                 HBP_isLEDblinkon: 						; HeartBeat
00008c 9100 006d 	lds	temp, TaskFlags					; HeartBeat
00008e ff05      	sbrs	temp, BlinkLED					; HeartBeat
00008f c00c      	rjmp	HBP_blinkExit					; HeartBeat
                 ;								; HeartBeat
                 ;	turn on LED for less than 1 sec	[only for debugging]	; HeartBeat
000090 9895      	cbi	LED_PORT, LED_DEBUG 				; HeartBeat
000091 9100 0060 	lds	temp, HeartBeatCntr  ; update 32/sec		; HeartBeat
000093 710f      	andi	temp, 0b00011111				; HeartBeat
000094 f009      	breq	HBP_LEDoff ; when HBcnt = 0			; HeartBeat
                 ;								; HeartBeat
000095 c006      	rjmp	HBP_blinkExit					; HeartBeat
                 ;;								; HeartBeat
                 HBP_LEDoff:	; turn off LED 					; HeartBeat
000096 9a95      	sbi	LED_PORT, LED_DEBUG 				; HeartBeat
000097 9100 006d 	lds	temp, TaskFlags					; HeartBeat
000099 7d0f      	cbr 	temp, ( 1 << BlinkLED)				; HeartBeat
00009a 9300 006d 	sts	TaskFlags, temp					; HeartBeat
                 ;								; HeartBeat
                 HBP_blinkExit:  ;===============================================; HeartBeat
                 								; HeartBeat
                 								; HeartBeat
                 ; Check for new secondCount value and display big digits	; HeartBeat
00009c 9100 0061 	lds	temp,  SecondCount	; incremented by 	; HeartBeat
00009e 9110 0063 	lds	temp2, PrevSecCount	; the T1_overflow IRQ	; HeartBeat
0000a0 1701      	cp	temp, temp2					; HeartBeat
0000a1 f021      	breq	HBP_exit					; HeartBeat
0000a2 9300 0063 	sts	PrevSecCount, temp				; HeartBeat
0000a4 d005      	rcall	GetRTC 		 				; HeartBeat
0000a5 d3a4      	rcall	ShowRealTime 					; HeartBeat
                 								; HeartBeat
                 HBP_exit:							; HeartBeat
0000a6 91ef      	pop	ZL						; HeartBeat
0000a7 91ff      	pop	ZH						; HeartBeat
0000a8 910f      	pop	temp						; HeartBeat
0000a9 9508      	ret							; HeartBeat
                 ;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;%%%%%%%%%%
                 
                 
                 
                 ;***************************************************************************************;
                 ; Get RTC (no error checking)								;
                 ; send:	-	SLA_RTC, TWISTOPDELAY							;
                 ; return:	RTC_Buffer (18 bytes in SRAM) loaded with data from i2C device.		;
                 ; 		Errors are written to the last line of the Nokia 5110 display.		;
                 ; uses::	temp, temp2, temp3, TaskFlags:SetGetFlag, TWIstep			;
                 ; calls: 	RTC_Wait, -error handling code calls display subroutines-		;
                 ; called by:	HeartBeat								;
                 ; size:		118 flash bytes								;
                 ;											;
                 ; Error triggers on START [display->'100800GBdStart'] when run after SetRTC routine.	;
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;
                 GetRTC:											;** Get_RTC_ne
0000aa e004      	ldi 	temp, (1 << TWEN)	; 0b00000100					;** Get_RTC_ne
0000ab bf06      	out	TWCR, temp 		;0x36   TW control Reg  turn on TWI unit	;** Get_RTC_ne
                 ;											;** Get_RTC_ne
0000ac e000      	ldi	temp, 0									;** Get_RTC_ne
0000ad 9300 008c 	sts	TWIstep, temp								;** Get_RTC_ne
0000af 9100 006d 	lds	temp, TaskFlags								;** Get_RTC_ne
0000b1 6100      	ori	temp, (1 << SetGetFlag)							;** Get_RTC_ne
0000b2 9300 006d 	sts	TaskFlags, temp								;** Get_RTC_ne
                 											;** Get_RTC_ne
0000b4 ea04      	ldi	temp, (1<<TWINT)|(1<<TWSTA)|(1<<TWEN)	;Transmit start cond		;** Get_RTC_ne
0000b5 bf06      	out	TWCR, temp	;  _________						;** Get_RTC_ne
0000b6 d02a      	rcall	GRTC_Wait	; SCL......|_____     Start       master asserts SDA	;** Get_RTC_ne
                 ;				;  ______	    Condition   while SCL is released	;** Get_RTC_ne
                 ;				; SDA   |________					;** Get_RTC_ne
                 ;---------------------------------------------------------------------------------------;** Get_RTC_ne
                 ; Send control byte [8-bit device code and R/_w bit] always after start condition.	;** Get_RTC_ne
                 ; RTC has device code 0xd0 and the read bit (bit0) is set.  : 0b11010001 [0xd1]		;** Get_RTC_ne
0000b7 ed00      	ldi	temp, SLA_RTC	; slave address 1101 for RTC: device address 000	;** Get_RTC_ne
0000b8 b903      	out	TWDR, temp	;0x03 							;** Get_RTC_ne
0000b9 e804      	ldi	temp, (1<<TWINT) | (1<<TWEN) ; clearing TWINT (write a 1) starts TWI	;** Get_RTC_ne
0000ba bf06      	out	TWCR, temp	;0x36  							;** Get_RTC_ne
0000bb d025      	rcall	GRTC_Wait								;** Get_RTC_ne
                 											;** Get_RTC_ne
                 ;---------------------------------------------------------------------------------------;** Get_RTC_ne
                 ;											;** Get_RTC_ne
                 ; Write Address.  TWDR should only be written when TWINT is high (TWI finished)		;** Get_RTC_ne
0000bc e000        	ldi	temp, 0 	; first RTC Address, seconds BCD value			;** Get_RTC_ne
0000bd b903        	out	TWDR, temp	;0x03							;** Get_RTC_ne
0000be e804        	ldi	temp, (1<<TWINT) | (1<<TWEN)						;** Get_RTC_ne
0000bf bf06        	out	TWCR, temp	;0x36							;** Get_RTC_ne
0000c0 d020        	rcall	GRTC_Wait								;** Get_RTC_ne
                   											;** Get_RTC_ne
                 ;----------------------------------------------						;** Get_RTC_ne
                 ;  This is a REPEATED START and it tells the slave that the				;** Get_RTC_ne
                 ;  write operation is aborted while keeping the address that was sent.			;** Get_RTC_ne
0000c1 ea04      	ldi	temp, (1<<TWINT) | (1<<TWSTA) | (1<<TWEN)				;** Get_RTC_ne
0000c2 bf06      	out	TWCR, temp	;0x36							;** Get_RTC_ne
0000c3 d01d      	rcall	GRTC_Wait								;** Get_RTC_ne
                 											;** Get_RTC_ne
                 ;----------------------------------------------						;** Get_RTC_ne
                 ; Send control byte [device code, address, and R/W bit=read]				;** Get_RTC_ne
                 ; 8-bit RTC SlaveAddress=0xd0 with read bit0 = 1					;** Get_RTC_ne
0000c4 ed00      	ldi	temp, SLA_RTC  ; slave address 1101 for EEPROM: device address 000	;** Get_RTC_ne
0000c5 6001      	ori	temp, 0b00000001	; set bit0 for reading from I2C device		;** Get_RTC_ne
0000c6 b903      	out	TWDR, temp	;0x03							;** Get_RTC_ne
0000c7 e804      	ldi	temp, (1<<TWINT) | (1<<TWEN)						;** Get_RTC_ne
0000c8 bf06      	out	TWCR, temp	;0x36							;** Get_RTC_ne
0000c9 d017      	rcall	GRTC_Wait								;** Get_RTC_ne
                 ; 											;** Get_RTC_ne
                 ;----------------------------------------------						;** Get_RTC_ne
                 ;  read RTC_readSIZE # of bytes [ 18 bytes for DS3231, 8 bytes for DS1307] from RTC	;** Get_RTC_ne
0000ca e0f0      	ldi	ZH, high (RTCBuffer)							;** Get_RTC_ne
0000cb e7e2      	ldi	ZL, low  (RTCBuffer)							;** Get_RTC_ne
0000cc e017      	ldi	temp2, RTCreadSIZE - 1	; read 2 with ACK, then 1 with NACK		;** Get_RTC_ne
                 											;** Get_RTC_ne
0000cd ec04      GRTC_1:	ldi	temp, (1<<TWINT) | (1<<TWEN) | (1<<TWEA) ;Read Data with Enable ACK	;** Get_RTC_ne
0000ce bf06      	out	TWCR, temp								;** Get_RTC_ne
0000cf d011      	rcall	GRTC_Wait								;** Get_RTC_ne
0000d0 b123      	in	temp3, TWDR	; store the data byte read from the EEPROM		;** Get_RTC_ne
0000d1 9321      	st	z+, temp3								;** Get_RTC_ne
                 											;** Get_RTC_ne
0000d2 951a      	dec	temp2									;** Get_RTC_ne
0000d3 f7c9      	brne	GRTC_1		; loop to read each byte in the EEPROM page		;** Get_RTC_ne
                 											;** Get_RTC_ne
                 ;  last byte read from EEPROM, so send NACK after receiving data bits			;** Get_RTC_ne
0000d4 e804      	ldi	temp, (1<<TWINT) | (1<<TWEN) ; | (0<<TWEA) ; Read Data with NACK	;** Get_RTC_ne
0000d5 bf06      	out	TWCR, temp	;0x36							;** Get_RTC_ne
0000d6 d00a      	rcall	GRTC_Wait								;** Get_RTC_ne
                 											;** Get_RTC_ne
0000d7 b123      	in	temp3, TWDR	; 0x03 store the data byte read from the EEPROM		;** Get_RTC_ne
0000d8 9321      	st	z+, temp3								;** Get_RTC_ne
                 											;** Get_RTC_ne
                 GRTC_STOP:										;** Get_RTC_ne
0000d9 e904      	ldi	temp, (1<<TWINT) | (1<<TWSTO) | (1<<TWEN) ; do STOP condition		;** Get_RTC_ne
0000da bf06      	out	TWCR, temp	;0x36							;** Get_RTC_ne
0000db e20d      	ldi	temp, TWISTOPDELAY	; @8 uSec delay					;** Get_RTC_ne
0000dc 950a      GRTC_2:	dec	temp									;** Get_RTC_ne
0000dd f7f1      	brne	GRTC_2			; wait TWI period after STOP before turning off	;** Get_RTC_ne
0000de e000      	ldi	temp, 0 ;(0<<TWEN)							;** Get_RTC_ne
0000df bf06      	out	TWCR, temp	;0x36	turn off TWI unit				;** Get_RTC_ne
                 											;** Get_RTC_ne
                 GRTC_exit:										;** Get_RTC_ne
0000e0 9508      	ret	;  exit point for Read_I2C_String subroutine				;** Get_RTC_ne
                 											;** Get_RTC_ne
                 											;** Get_RTC_ne
                 ;***************************************************************************************;** Get_RTC_ne
                 GRTC_Wait:										;** Get_RTC_ne
0000e1 b706      	in	temp, TWCR								;** Get_RTC_ne
0000e2 ff07      	sbrs	temp, TWINT	; TWINT set means TWI is ready for new command		;** Get_RTC_ne
0000e3 cffd      	rjmp	GRTC_Wait								;** Get_RTC_ne
0000e4 9508      	ret 			; TWINT is high now.  TWSR has a new valid value	;** Get_RTC_ne
                 ;											;** Get_RTC_ne
                 ;***** end of GetEEString (no error checking) routine  *********************************;** Get_RTC_ne
                 ;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;%%%%%%%%%
                 
                 
                 
                 ;RTCdata:	; for DS3231
                 ;	.db  0,59,50, 1,12, 8		; 012345   secs    min  hours   day    date   month
                 ;	.db 14, 0, 0, 0, 0, 0		; 6789ab   year  a1sec  a1min   a1hr   a1dy    a1mn
                 ;	.db  0, 0, 0, 0, 0, 0		; cdef01  a2sec  a2min   cntr  status  tmptrM tmptrL
                 ;
                 RTCdata: ;       |   0      |   1 ; for DS1307   in binary coded decimal
0000e5 0700      	.db 0b00000000,0b00000111 ;  secs  min   24-hour coded
                 ;                |   2 	    |   3
0000e6 0509      	.db 0b00001001,0b00000101 ;  hours day  [ bit6 set=12hr mode  bit5 set=PM/clr=AM ]
                 	 ;       |   4      |   5
0000e7 0c26      	.db 0b00100110,0b00001100 ;  date  month (NOT BCD)
                 	 ;       |   6     7
0000e8 1014      	.db 0b00010100 ,0x10	  ;  year  control
                 
                 
                 ;;**************************************************************************************;
                 ;; Set RTC	only used a few times to set time:data on RTC IC 			;
                 ;;											;
                 ;; send:	RTC_data								;
                 ;; return:	-									;
                 ;; uses regs:	temp, temp2, temp3							;
                 ;; calls: 	SRTC_wait, -error handling code calls NOkia 5110 display subroutines-	;
                 ;; called by:	initialApplication							;
                 ;; size:	194 flash bytes    ( with RTCdata)
                 ;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;
                 SetRTC:											;** Set_RTC
0000e9 e000      	ldi	temp, 0									;** Set_RTC
0000ea 9300 008c 	sts	TWIstep, temp								;** Set_RTC
0000ec 9100 006d 	lds	temp, TaskFlags								;** Set_RTC
0000ee 7e0f      	andi	temp, ~(1 << SetGetFlag)	; clear setgetflag for errors		;** Set_RTC
0000ef 9300 006d 	sts	TaskFlags, temp								;** Set_RTC
                 ;;											;** Set_RTC
                 ;	ldi	temp, (1<<TWINT)|(1<<TWSTA)|(1<<TWEN)	;Transmit start cond		;** Set_RTC
                 ;	out	TWCR, temp	;  ____________						;** Set_RTC
                 ;	rcall	SRTC_Wait	; SCL..........     Start       master pulls SDA low	;** Set_RTC
                 ;;				;  _______	    Condition   while SCL is hi (rel)	;** Set_RTC
                 ;;				; SDA    |_____						;** Set_RTC
                 ;	in	temp3, TWSR								;** Set_RTC
                 ;	andi	temp3, 0xF8								;** Set_RTC
                 ;	sts	ReceivedTWSR, temp3							;** Set_RTC
                 ;	ldi	temp,  0x08	; START condition created OK				;** Set_RTC
                 ;	sts	ExpectedTWSR, temp							;** Set_RTC
                 ;	cpse	temp3, temp	; Read SReg. 0x08 received (START sent)			;** Set_RTC
                 ;	rcall	SRTC_error	; TWIstep=0						;** Set_RTC
                 											;** Set_RTC
                 ;-------------------------------------------- 						;** Set_RTC
                 ; Send control byte [device code, address, and R/_w bit] always after start condition.	;** Set_RTC
                 ; DS3231 has device code 0xd0 with Write bit (bit0) = low				;** Set_RTC
0000f1 ed00      	ldi	temp, SLA_RTC	 ; ControlByte	bit0 clear for write			;** Set_RTC
0000f2 b903      	out	TWDR, temp	 ; in order to send memory address to serial EEPROM.	;** Set_RTC
0000f3 e804      	ldi	temp, (1<<TWINT) | (1<<TWEN) ; clearing TWINT (write a 1) starts TWI	;** Set_RTC
0000f4 bf06      	out	TWCR, temp								;** Set_RTC
0000f5 d019      	rcall	SRTC_Wait								;** Set_RTC
                 											;** Set_RTC
                 ;	ldi	temp, 1									;** Set_RTC
                 ;	sts	TWIstep, temp								;** Set_RTC
                 ;	in	temp3, TWSR								;** Set_RTC
                 ;	andi	temp3, 0xF8								;** Set_RTC
                 ;	sts	ReceivedTWSR, temp3							;** Set_RTC
                 ;	ldi	temp,  0x18	; 0x18 >> SLA+W send, ACK received			;** Set_RTC
                 ;	sts	ExpectedTWSR, temp							;** Set_RTC
                 ;	cpse	temp3, temp								;** Set_RTC
                 ;	rcall	SRTC_error	; ; TWIstep=1						;** Set_RTC
                 											;** Set_RTC
                 ;--------------------------------------------						;** Set_RTC
                 ; Write RTC Address.  									;** Set_RTC
0000f6 e000      	ldi	temp, RTC_STARTADDR							;** Set_RTC
0000f7 b903      	out	TWDR, temp								;** Set_RTC
0000f8 e804      	ldi	temp, (1<<TWINT) | (1<<TWEN)						;** Set_RTC
0000f9 bf06      	out	TWCR, temp								;** Set_RTC
0000fa d014      	rcall	SRTC_Wait								;** Set_RTC
                 											;** Set_RTC
                 ;	ldi	temp, 2									;** Set_RTC
                 ;	sts	TWIstep, temp								;** Set_RTC
                 ;	in	temp3, TWSR								;** Set_RTC
                 ;	andi	temp3, 0xF8								;** Set_RTC
                 ;	sts	ReceivedTWSR, temp3							;** Set_RTC
                 ;	ldi	temp,  0x28	; 0x28 >> data sent, ACK received OK			;** Set_RTC
                 ;	sts	ExpectedTWSR, temp							;** Set_RTC
                 ;	cpse	temp3, temp								;** Set_RTC
                 ;	rcall	SRTC_error	; TWIstep=2						;** Set_RTC
                 	 										;** Set_RTC
                 ;----------------------------------------------------------------			;** Set_RTC
                 ;  write 8 bytes to DS1307 from RTCdata flash array					;** Set_RTC
0000fb e0f1      	ldi	ZH, high (RTCdata << 1)							;** Set_RTC
0000fc ecea      	ldi	ZL, low  (RTCdata << 1)							;** Set_RTC
0000fd e018      	ldi	temp2, RTCwriteSIZE 	; write 15 bytes. Receive ACK after each.	;** Set_RTC
                 											;** Set_RTC
                 SRTC_1:											;** Set_RTC
0000fe 9105      	lpm	temp, z+								;** Set_RTC
0000ff b903      	out	TWDR, temp	 							;** Set_RTC
000100 ec04      	ldi	temp, (1<<TWINT) | (1<<TWEN) | (1<<TWEA) ; write Data with Enable ACK	;** Set_RTC
000101 bf06      	out	TWCR, temp								;** Set_RTC
000102 d00c      	rcall	SRTC_Wait								;** Set_RTC
                 											;** Set_RTC
                 ;	lds	temp, TWIstep								;** Set_RTC
                 ;	inc	temp									;** Set_RTC
                 ;	sts	TWIstep, temp								;** Set_RTC
                 ;											;** Set_RTC
                 ;	in	temp3, TWSR								;** Set_RTC
                 ;	andi	temp3, 0xF8								;** Set_RTC
                 ;	sts	ReceivedTWSR, temp3							;** Set_RTC
                 ;	ldi	temp,  0x28	; 0x28 Master Write w/ Acknowledge OK			;** Set_RTC
                 ;	sts	ExpectedTWSR, temp							;** Set_RTC
                 ;	cpse	temp3, temp								;** Set_RTC
                 ;	rcall	SRTC_error	;  TWIstep=3..21					;** Set_RTC
                 											;** Set_RTC
000103 951a      	dec	temp2									;** Set_RTC
000104 f7c9      	brne	SRTC_1		; loop to read each byte in the EEPROM page		;** Set_RTC
                 											;** Set_RTC
                 SRTC_STOP:										;** Set_RTC
000105 e904      	ldi	temp, (1<<TWINT) | (1<<TWSTO) | (1<<TWEN) ; do STOP condition		;** Set_RTC
000106 9300 0036 	sts	TWCR, temp								;** Set_RTC
000108 e20d      	ldi	temp, TWISTOPDELAY	;  actually @16 uSec delay			;** Set_RTC
000109 950a      SRTC_2:	dec	temp									;** Set_RTC
00010a f7f1      	brne	SRTC_2		; wait TWI period after STOP before turning off 	;** Set_RTC
00010b e000      	ldi	temp, 0 	; TWI unit (0 << TWEN).					;** Set_RTC
00010c 9300 0036 	sts	TWCR, temp								;** Set_RTC
                 											;** Set_RTC
                 SRTC_exit:										;** Set_RTC
00010e 9508      	ret	;  exit point for SetRTC routine					;** Set_RTC
                 											;** Set_RTC
                 ;SRTC_error:										;** Set_RTC
                 ;	rcall	doTWIerror								;** Set_RTC
                 ;	ret										;** Set_RTC
                 											;** Set_RTC
                 											;** Set_RTC
                 ;***************************************************************************************;** Set_RTC
                 SRTC_Wait:										;** Set_RTC
00010f b706      	in	temp, TWCR								;** Set_RTC
000110 ff07      	sbrs	temp, TWINT	; TWINT set means TWI is ready for new command		;** Set_RTC
000111 cffd      	rjmp	SRTC_Wait								;** Set_RTC
000112 9508      	ret 			; TWINT is high now.  TWSR has a new valid value.	;** Set_RTC
                 ;											;** Set_RTC
                 ;***************************************************************************************;** Set_RTC
                 
                 
                 ;***************************************************************; Nokia_5110
                 ;  Nokia 5110 graphics display routines:			; Nokia_5110
                 ;	Source code @600 bytes					; Nokia_5110
                 ;	plus font tables: ASCII chars 480 bytes			; Nokia_5110
                 ;	total:    @1100 bytes 					; Nokia_5110
                 ;  code unused by this application gets commented out		; Nokia_5110
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Nokia_5110
                 ;								; Nokia_5110
                 ;  In order to convert code from Arduino_C			; Nokia_5110
                 ;  into AVR assembler, I am using variables			; Nokia_5110
                 ;  in SRAM to store the function arguments			; Nokia_5110
                 ;  from the Ard_C code.  These are pre-named			; Nokia_5110
                 ;  as Var_ByteOne and Var_ByteTwo.  When main			; Nokia_5110
                 ;  asm code calls a subroutine that models			; Nokia_5110
                 ;  the actions of the Adr_C function, it first			; Nokia_5110
                 ;  loads the values of the arguments into the			; Nokia_5110
                 ;  SRAM variables set aside for this purpose.			; Nokia_5110
                 ;  Var_ByteOne:	     size= 1 byte each				; Nokia_5110
                 ;  Var_ByteTwo:							; Nokia_5110
                 ;  Ptr_OneLow:							; Nokia_5110
                 ;  Ptr_OneHigh:							; Nokia_5110
                 ;  								; Nokia_5110
                 ;  LCD__Initialize: 	; no arguments				; Nokia_5110
                 ;  LCD__stringP:	; Ptr_OneLow:Ptr_OneHigh = adr of strg	; Nokia_5110
                 ;  LCD__character:	; Var_ByteOne == char	   in flash	; Nokia_5110
                 ;  LCD__clear:		; no arguments				; Nokia_5110
                 ;  LCD__write:		; Var_ByteOne== 0=cmd;1=dt: Var_ByteTwo	; Nokia_5110
                 ;  LCD__gotoXY:		; Var_ByteOne= x : Var_ByteTwo = y	; Nokia_5110
                 ;  LCD__stringSRAM	; Ptr_OneLow:Ptr_OneHigh = adr str SRAM	; Nokia_5110
                 ;								; Nokia_5110
                 ; Hardware:							; Nokia_5110
                 ;	DDR__DC; DDR__SDIN; DDR__SCLK  				; Nokia_5110
                 ;	PORT__DC; PORT__SDIN; PORT__SCLK 			; Nokia_5110
                 ;	PIN__DC; PIN__SDIN; PIN__SCLK  				; Nokia_5110
                 ;_______________________________________________________________; Nokia_5110
                 ;	; Example Code						; Nokia_5110
                 ;								; Nokia_5110
                 ;  	; clear bottom line of Nokia display, 			; Nokia_5110
                 ;	ldi	temp, 0		; position cursor column 0-83	; Nokia_5110
                 ;	sts	Var_ByteOne, temp				; Nokia_5110
                 ;	ldi	temp, 5		; position Nokia cursor 0-5 	; Nokia_5110
                 ;	sts	Var_ByteTwo, temp ; display error msg 		; Nokia_5110
                 ;	rcall	LCD_gotoXY	;on Nokia 5110 bottom row	; Nokia_5110
                 ;	ldi	temp, high (ClearLine << 1)			; Nokia_5110
                 ;	sts	Ptr_OneHigh, temp ; erase bottom line		; Nokia_5110
                 ;	ldi	temp, low  (ClearLine << 1)			; Nokia_5110
                 ;	sts	Ptr_OneLow, temp				; Nokia_5110
                 ;	rcall	LCD__stringP					; Nokia_5110
                 ;								; Nokia_5110
                 ;	ClearLine:	.db "              ", 0, 0		; Nokia_5110
                 ;								; Nokia_5110
                 ;***************************************************************; Nokia_5110
                 LCD_Initialize:							; Nokia_5110
000113 9ab8      	sbi	DDR_DC,   PIN_DC  ; Nokia5110 control signals	; Nokia_5110
000114 9aba      	sbi	DDR_SDIN, PIN_SDIN	; can be on diff ports	; Nokia_5110
000115 9ab9      	sbi	DDR_SCLK, PIN_SCLK 	; DDRA  0x10 		; Nokia_5110
                 ;								; Nokia_5110
                 ;  LCD_write(LCD__CMD, 0x21);  	; LCD Extended Commands.	; Nokia_5110
000116 e000      	ldi	temp, LCD_CMD					; Nokia_5110
000117 9300 0065 	sts	VarByteOne, temp				; Nokia_5110
000119 e201      	ldi	temp, 0x21					; Nokia_5110
00011a 9300 0066 	sts	VarByteTwo, temp				; Nokia_5110
00011c d083      	rcall	LCD_write					; Nokia_5110
                 ;								; Nokia_5110
                 ;.equ	CONTRAST_VALUE	=  40					; Nokia_5110
00011d e000      	ldi	temp, LCD_CMD	; Set LCD Vop (Contrast).   	; Nokia_5110
00011e 9300 0065 	sts	VarByteOne, temp				; Nokia_5110
000120 eb05      	ldi	temp, 0x80 |  CONTRAST_VALUE			; Nokia_5110
000121 9300 0066 	sts	VarByteTwo, temp				; Nokia_5110
000123 d07c      	rcall	LCD_write					; Nokia_5110
                 ;								; Nokia_5110
000124 e000      	ldi	temp, LCD_CMD	; Set Temp coefficent. ;;0x04	; Nokia_5110
000125 9300 0065 	sts	VarByteOne, temp				; Nokia_5110
000127 e004      	ldi	temp, 0x04					; Nokia_5110
000128 9300 0066 	sts	VarByteTwo, temp				; Nokia_5110
00012a d075      	rcall	LCD_write					; Nokia_5110
                 ;								; Nokia_5110
00012b e000      	ldi	temp, LCD_CMD	; LCD bias mode 1:48. ;;0x14	; Nokia_5110
00012c 9300 0065 	sts	VarByteOne, temp				; Nokia_5110
00012e e104      	ldi	temp, 0x14					; Nokia_5110
00012f 9300 0066 	sts	VarByteTwo, temp				; Nokia_5110
000131 d06e      	rcall	LCD_write					; Nokia_5110
                 ;								; Nokia_5110
000132 e000      	ldi	temp, LCD_CMD	; LCD in normal mode.		; Nokia_5110
000133 9300 0065 	sts	VarByteOne, temp ; 0x0d for inverse		; Nokia_5110
000135 e00c      	ldi	temp, 0x0c					; Nokia_5110
000136 9300 0066 	sts	VarByteTwo, temp				; Nokia_5110
000138 d067      	rcall	LCD_write					; Nokia_5110
                 ;								; Nokia_5110
000139 e000      	ldi	temp, LCD_CMD	 ; LCD standard commands	; Nokia_5110
00013a 9300 0065 	sts	VarByteOne, temp				; Nokia_5110
00013c e200      	ldi	temp, 0x20					; Nokia_5110
00013d 9300 0066 	sts	VarByteTwo, temp				; Nokia_5110
00013f d060      	rcall	LCD_write					; Nokia_5110
                 ;								; Nokia_5110
000140 e000      	ldi	temp, LCD_CMD					; Nokia_5110
000141 9300 0065 	sts	VarByteOne, temp				; Nokia_5110
000143 e00c      	ldi	temp, 0x0c					; Nokia_5110
000144 9300 0066 	sts	VarByteTwo, temp				; Nokia_5110
000146 d059      	rcall	LCD_write					; Nokia_5110
                 ;								; Nokia_5110
000147 9508      	ret							; Nokia_5110
                 ;								; Nokia_5110
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Nokia_5110
                  								; Nokia_5110
                 ;***************************************************************; Nokia_5110
                 ;void Lcd__StringP(char *characters)  // string in prog flash	; Nokia_5110
                 ;{								; Nokia_5110
                 ;  while (*characters)						; Nokia_5110
                 ;  {								; Nokia_5110
                 ;    LcdCharacter(*characters++);				; Nokia_5110
                 ;  }								; Nokia_5110
                 ;}								; Nokia_5110
                 ;---------------------------------------------------------------; Nokia_5110
                 .equ	EEfont	= 0x000						; Nokia_5110
                 LCD_stringP:							; Nokia_5110
000148 93ff      	push	zh						; Nokia_5110
000149 93ef      	push	zl						; Nokia_5110
00014a 930f      	push	temp						; Nokia_5110
                 ;								; Nokia_5110
00014b 91f0 0069 	lds	zh, PtrOneHigh					; Nokia_5110
00014d 91e0 0068 	lds	zl, PtrOneLow 					; Nokia_5110
                 LstrP_0:							; Nokia_5110
00014f 9105      	lpm	temp, z+	;  dereferenced pointer 	; Nokia_5110
000150 2300      	tst	temp		;  value is in flash		; Nokia_5110
000151 f021      	breq	LstrP_exit					; Nokia_5110
                 ;								; Nokia_5110
000152 9300 0065 	sts	VarByteOne, temp				; Nokia_5110
000154 d005      	rcall	LCD_character					; Nokia_5110
                 ;								; Nokia_5110
000155 cff9      	rjmp	LstrP_0						; Nokia_5110
                 ;								; Nokia_5110
                 LstrP_exit:							; Nokia_5110
000156 910f      	pop	temp						; Nokia_5110
000157 91ef      	pop	zl						; Nokia_5110
000158 91ff      	pop	zh						; Nokia_5110
000159 9508      	ret							; Nokia_5110
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Nokia_5110
                 	 							; Nokia_5110
                 ;***************************************************************; Nokia_5110
                 ;void LcdCharacter			 			; Nokia_5110
                 ; character in Var_ByteOne [range 0x20 to 0x7f]			; Nokia_5110
                 ; subtract 0x20 and multiply by 5 to get table offset  		; Nokia_5110
                 ;  offset range [from ASCII_font begin] 0x00 to 0x27b {635}	; Nokia_5110
                 ;								; Nokia_5110
                 ;---------------------------------------------------------------; Nokia_5110
                 LCD_character:	; character in VarByteOne			; Nokia_5110
00015a 93ff      	push	zh						; Nokia_5110
00015b 93ef      	push	zl						; Nokia_5110
00015c 931f      	push	temp2						; Nokia_5110
00015d 932f      	push	temp3						; Nokia_5110
00015e 930f      	push	temp						; Nokia_5110
                 ;								; Nokia_5110
00015f 9110 0065 	lds	temp2, VarByteOne				; Nokia_5110
000161 5210      	subi	temp2, 0x20					; Nokia_5110
                 								; Nokia_5110
                 ;; When using in-line (not EEPROM) font, use lines from LCw	; Nokia_5110
                 ;;   to LCy and comment lines from LCy to LCz.			; Nokia_5110
                 ;; When font is stored in serial EEPROM, use lines from LCy	; Nokia_5110
                 ;;   to LCz and comment lines from LCy to LCz. Also you can	; Nokia_5110
                 ;;   comment out the ASCII_font data table.  But you must	; Nokia_5110
                 ;;   add the ReadPage routine.					; Nokia_5110
                 ;;								; Nokia_5110
                 ;; LCw:	_this line is always commented				; Nokia_5110
                 ;; multiply temp2 by 5 [number of bytes per bit-mapped char] 	; Nokia_5110
000162 2f21      	mov	temp3, temp2	; shift-and-add for MUL		; Nokia_5110
000163 2700      	clr	temp						; Nokia_5110
000164 0f11      	lsl	temp2 						; Nokia_5110
000165 1f00      	rol	temp						; Nokia_5110
000166 0f11      	lsl	temp2						; Nokia_5110
000167 1f00      	rol	temp						; Nokia_5110
000168 0f12      	add	temp2, temp3	;  low of offset into table	; Nokia_5110
000169 1d0f      	adc	temp, ZeroReg	; high of offset into table	; Nokia_5110
00016a e0f3      	ldi	ZH, high (ASCII_font << 1)			; Nokia_5110
00016b efe6      	ldi	ZL, low  (ASCII_font << 1) 			; Nokia_5110
00016c 0fe1      	add	ZL, temp2 ; ZH:ZL points to first of five bytes ; Nokia_5110
00016d 1ff0      	adc	ZH, temp					; Nokia_5110
00016e e025      	ldi	temp3, 5					; Nokia_5110
                 Lchar_loop:							; Nokia_5110
00016f 9105      	lpm	temp, z+					; Nokia_5110
                 ;;								; Nokia_5110
                 ;; LCy:	_this line is always commented				; Nokia_5110
                 ;;								; Nokia_5110
                 ;	clr	temp3 						; Nokia_5110
                 ;	lsl temp2    rol temp3    ; times 2 16-bit		; Nokia_5110
                 ;	lsl temp2    rol temp3    ; times 4 16-bit		; Nokia_5110
                 ;	lsl temp2    rol temp3    ; times 8 16-bit		; Nokia_5110
                 ;	ldi	ZH, high ( EEFont )				; Nokia_5110
                 ;	ldi	ZL, low  ( EEFont ) 				; Nokia_5110
                 ;	add	ZL, temp2 ; ZH:ZL points to first of 8 bytes 	; Nokia_5110
                 ;	adc	ZH, temp3					; Nokia_5110
                 ;	sts	HighAddress, ZH					; Nokia_5110
                 ;	sts	LowAddress,  ZL					; Nokia_5110
                 ;	ldi	temp, 8						; Nokia_5110
                 ;	sts	ReadBlockSize, temp				; Nokia_5110
                 ;	rcall	ReadPage  ; send High:lowAddress, ReadBlockSize	; Nokia_5110
                 ;	ldi	temp3, 5					; Nokia_5110
                 ;	ldi	ZH, high (Page_Buffer)				; Nokia_5110
                 ;	ldi	ZL, low  (Page_Buffer)				; Nokia_5110
                 ;Lchar_loop:							; Nokia_5110
                 ;	ld	temp, z+					; Nokia_5110
                 ;; LCz: _this line is always commented				; Nokia_5110
                 								; Nokia_5110
000170 9300 0066 	sts	VarByteTwo, temp				; Nokia_5110
000172 e001      	ldi	temp, LCD_D					; Nokia_5110
000173 9300 0065 	sts	VarByteOne, temp				; Nokia_5110
000175 d02a      	rcall	LCD_write					; Nokia_5110
                 								; Nokia_5110
000176 952a      	dec	temp3						; Nokia_5110
000177 f7b9      	brne	Lchar_loop					; Nokia_5110
                 ;								; Nokia_5110
000178 e001      	ldi	temp, LCD_D					; Nokia_5110
000179 9300 0065 	sts	VarByteOne, temp				; Nokia_5110
00017b e000      	ldi	temp, 0x00	; blank column			; Nokia_5110
00017c 9300 0066 	sts	VarByteTwo, temp				; Nokia_5110
00017e d021      	rcall	LCD_write					; Nokia_5110
                 ;								; Nokia_5110
00017f 910f      	pop	temp						; Nokia_5110
000180 912f      	pop	temp3						; Nokia_5110
000181 911f      	pop	temp2						; Nokia_5110
000182 91ef      	pop	zl						; Nokia_5110
000183 91ff      	pop	zh						; Nokia_5110
000184 9508      	ret							; Nokia_5110
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Nokia_5110
                 								; Nokia_5110
                 ;***************************************************************; Nokia_5110
                 ;void LcdClear(void)						; Nokia_5110
                 ;{								; Nokia_5110
                 ;  for (int index = 0; index < LCD_X * LCD_Y ; index++)		; Nokia_5110
                 ;  {								; Nokia_5110
                       ;    LCD_write(LCD_D, 0x00);				; Nokia_5110
                 ;  }								; Nokia_5110
                 ;}								; Nokia_5110
                 ;---------------------------------------------------------------; Nokia_5110
                 LCD_clear:							; Nokia_5110
000185 93ff      	push	zh						; Nokia_5110
000186 93ef      	push	zl						; Nokia_5110
000187 930f      	push	temp						; Nokia_5110
                 ;								; Nokia_5110
000188 2700      	clr	temp		; position cursor to top 	; Nokia_5110
000189 9300 0065 	sts	VarByteOne, temp				; Nokia_5110
00018b 9300 0066 	sts	VarByteTwo, temp				; Nokia_5110
00018d d02f      	rcall	LCD_gotoXY					; Nokia_5110
                 ;								; Nokia_5110
00018e e0f1      	ldi	zh, high  ( LCD_X * ( LCD_Y / 8) )		; Nokia_5110
00018f efe8      	ldi	zl, low   ( LCD_X * ( LCD_Y / 8) )		; Nokia_5110
                 ;								; Nokia_5110
                 L_clr0:								; Nokia_5110
000190 e001      	ldi	temp, LCD_D					; Nokia_5110
000191 9300 0065 	sts	VarByteOne, temp				; Nokia_5110
000193 e000      	ldi	temp, 0x00					; Nokia_5110
000194 9300 0066 	sts	VarByteTwo, temp				; Nokia_5110
000196 d009      	rcall	LCD_write					; Nokia_5110
                 ;								; Nokia_5110
000197 95ea      	dec	zl						; Nokia_5110
000198 f7b9      	brne	L_clr0						; Nokia_5110
000199 95fa      	dec	zh						; Nokia_5110
00019a 23ff      	tst	zh						; Nokia_5110
00019b f7a2      	brpl	L_clr0						; Nokia_5110
                 ;								; Nokia_5110
00019c 910f      	pop	temp						; Nokia_5110
00019d 91ef      	pop	zl						; Nokia_5110
00019e 91ff      	pop	zh						; Nokia_5110
                 ;								; Nokia_5110
00019f 9508      	ret							; Nokia_5110
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Nokia_5110
                 								; Nokia_5110
                 								; Nokia_5110
                 ;***************************************************************; Nokia_5110
                 LCD_write:; Var_ByteOne: dc {0=cmd;1=d}  :: Var_ByteTwo: data	; Nokia_5110
0001a0 932f      	push	temp3		; LOWEST LEVEL FUNCTION		; Nokia_5110
0001a1 931f      	push	temp2						; Nokia_5110
0001a2 930f      	push	temp						; Nokia_5110
                 ;								; Nokia_5110
0001a3 9120 0065 	lds	temp3, VarByteOne	; cmd=0; data=1		; Nokia_5110
0001a5 2322      	tst	temp3						; Nokia_5110
0001a6 f011      	breq	Lw1						; Nokia_5110
                 ;								; Nokia_5110
0001a7 9ac0      	sbi	PORT_DC, PIN_DC					; Nokia_5110
0001a8 c001      	rjmp	Lw2						; Nokia_5110
                 ;		; Nokia gLCD command  selected low on DC	; Nokia_5110
0001a9 98c0      Lw1:	cbi	PORT_DC, PIN_DC					; Nokia_5110
                 ;								; Nokia_5110
0001aa e008      Lw2:	ldi	temp, 8						; Nokia_5110
0001ab 9110 0066 	lds	temp2, VarByteTwo				; Nokia_5110
                 ;								; Nokia_5110
                 Lw_loop:							; Nokia_5110
0001ad 0f11      	lsl	temp2			; MSB first 		; Nokia_5110
0001ae f420      	brcc	Lw4						; Nokia_5110
                 ;	carry bit set						; Nokia_5110
0001af 9ac2      	sbi	PORT_SDIN, PIN_SDIN				; Nokia_5110
0001b0 9ac1      	sbi	PORT_SCLK, PIN_SCLK				; Nokia_5110
0001b1 98c1      	cbi	PORT_SCLK, PIN_SCLK				; Nokia_5110
0001b2 c003      	rjmp	Lw5						; Nokia_5110
                 Lw4:	; carry bit clear					; Nokia_5110
0001b3 98c2      	cbi	PORT_SDIN, PIN_SDIN				; Nokia_5110
0001b4 9ac1      	sbi	PORT_SCLK, PIN_SCLK				; Nokia_5110
0001b5 98c1      	cbi	PORT_SCLK, PIN_SCLK				; Nokia_5110
                 ;								; Nokia_5110
0001b6 950a      Lw5:	dec	temp						; Nokia_5110
0001b7 f009      	breq	Lw_exit						; Nokia_5110
0001b8 cff4      	rjmp	Lw_loop						; Nokia_5110
                 ;--------------------------					; Nokia_5110
                 ;								; Nokia_5110
                 Lw_exit:							; Nokia_5110
0001b9 910f      	pop	temp						; Nokia_5110
0001ba 911f      	pop	temp2						; Nokia_5110
0001bb 912f      	pop	temp3						; Nokia_5110
0001bc 9508      	ret							; Nokia_5110
                 ;								; Nokia_5110
                 ;								; Nokia_5110
                 ;;**************************************************************; Nokia_5110
                 ; * gotoXY routine to position cursor				; Nokia_5110
                 ; * byte offset is column X {Var_ByteOne}, row(y) {Var_ByteTwo}	; Nokia_5110
                 ; * x - range: 0 to 83		Display address=(y*84)+x	; Nokia_5110
                 ; * y - range: 0 to 5  						; Nokia_5110
                 ; *;								; Nokia_5110
                 ;void gotoXY(int x, int y)					; Nokia_5110
                 ;{								; Nokia_5110
                 ;  LCD_write( 0, 0x80 | x);  ;; Column.				; Nokia_5110
                 ;  LCD_write( 0, 0x40 | y);  ;; Row.				; Nokia_5110
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Nokia_5110
                 LCD_gotoXY:		; Var_ByteOne: x, Var_ByteTwo y)	; Nokia_5110
0001bd 930f      	push	temp						; Nokia_5110
0001be 922f      	push	lowTemp0					; Nokia_5110
0001bf 923f      	push	lowTemp1					; Nokia_5110
                 								; Nokia_5110
0001c0 9020 0065 	lds	lowTemp0, VarByteOne				; Nokia_5110
0001c2 9030 0066 	lds	lowTemp1, VarByteTwo				; Nokia_5110
                 								; Nokia_5110
0001c4 e000      	ldi	temp,  0					; Nokia_5110
0001c5 9300 0065 	sts	VarByteOne, temp				; Nokia_5110
0001c7 e800      	ldi	temp, 0x80					; Nokia_5110
0001c8 2902      	or	temp, lowTemp0	; x position offset 0-83	; Nokia_5110
0001c9 9300 0066 	sts	VarByteTwo, temp				; Nokia_5110
0001cb dfd4      	rcall	LCD_write					; Nokia_5110
                 								; Nokia_5110
0001cc e000      	ldi	temp,  0					; Nokia_5110
0001cd 9300 0065 	sts	VarByteOne, temp				; Nokia_5110
0001cf e400      	ldi	temp, 0x40					; Nokia_5110
0001d0 2903      	or	temp, lowTemp1	; y position offset 0-5		; Nokia_5110
0001d1 9300 0066 	sts	VarByteTwo, temp				; Nokia_5110
0001d3 dfcc      	rcall	LCD_write					; Nokia_5110
                 								; Nokia_5110
0001d4 903f      	pop	lowTemp1					; Nokia_5110
0001d5 902f      	pop	lowTemp0					; Nokia_5110
0001d6 910f      	pop	temp						; Nokia_5110
0001d7 9508      	ret							; Nokia_5110
                 								; Nokia_5110
                 ;;**************************************************************; Nokia_5110
                 ;;LCDStringSRAM     Display string being stored in SRAM.  	; Nokia_5110
                 ;;		String size fixed at 14 characters.		; Nokia_5110
                 ;;	send: 	Ptr_OneHigh:Ptr_OneLow				; Nokia_5110
                 ;;	uses:	Var_ByteOne					; Nokia_5110
                 ;;    registers: temp, temp2, ZH:ZL				; Nokia_5110
                 ;;	constants:  NOKIA_STRING_SIZE 				; Nokia_5110
                 ;;	calls:	LCD_character					; Nokia_5110
                 ;;  								; Nokia_5110
                 ;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Nokia_5110
                 ;LCD_stringSRAM: 						; Nokia_5110
                 ;	push	ZH						; Nokia_5110
                 ;	push	ZL						; Nokia_5110
                 ;	push	temp2						; Nokia_5110
                 ;	push	temp						; Nokia_5110
                 ;								; Nokia_5110
                 ;	lds	ZH, PtrOneHigh					; Nokia_5110
                 ;	lds	ZL, PtrOneLow					; Nokia_5110
                 ;	ldi	temp2, NOKIA_STRING_SIZE			; Nokia_5110
                 ;								; Nokia_5110
                 ;LstrS_0:; main difference from LcdStringP is the use of	; Nokia_5110
                 ;	ld	temp, z+   ; instead lpm instruction. DeRef-ed	; Nokia_5110
                 ;	sts	VarByteOne, temp; pointer value is in SRAM. 	; Nokia_5110
                 ;	rcall	LCD_character					; Nokia_5110
                 ;								; Nokia_5110
                 ;	dec	temp2	 					; Nokia_5110
                 ;	breq	LstrS_exit					; Nokia_5110
                 ;	rjmp	LstrS_0						; Nokia_5110
                 ;								; Nokia_5110
                 ;LstrS_exit:							; Nokia_5110
                 ;	pop	temp						; Nokia_5110
                 ;	pop	temp2						; Nokia_5110
                 ;	pop	ZL						; Nokia_5110
                 ;	pop	ZH						; Nokia_5110
                 ;	ret							; Nokia_5110
                 ;								; Nokia_5110
                 ;;**************************************************************; Nokia_5110
                 ;; LCDdisplayDecimal	replaces LEDdisplayParam [16x2 LCD]	; Nokia_5110
                 ;;   Display decimal number starting at LCD position		; Nokia_5110
                 ;;								; Nokia_5110
                 ;;   Call LCD_gotoXY before this routine			; Nokia_5110
                 ;; send:  Temp with 0-255 value					; Nokia_5110
                 ;;	 Temp3 with number of digits to display  		; Nokia_5110
                 ;; calls: Bin2ToAsc5, LCD_character		  		; Nokia_5110
                 ;;								; Nokia_5110
                 ;;**************************************************************; Nokia_5110
                 ;LCD_displayDecimal:						; Nokia_5110
                 ;	push	temp 						; Nokia_5110
                 ;	push	temp2						; Nokia_5110
                 ;	push	temp3						; Nokia_5110
                 ;	push	rBin1L						; Nokia_5110
                 ;	push	rBin1H						; Nokia_5110
                 ;	push	ZH						; Nokia_5110
                 ;	push	ZL						; Nokia_5110
                 ;								; Nokia_5110
                 ;	mov	rBin1L, temp					; Nokia_5110
                 ;	clr	rBin1H						; Nokia_5110
                 ;	ldi	ZH, high (ASCIIdigits)				; Nokia_5110
                 ;	ldi	ZL, low  (ASCIIdigits)				; Nokia_5110
                 ;; convert 16-bit binary to five digits				; Nokia_5110
                 ;	rcall	Bin2ToAsc5     					; Nokia_5110
                 ;; returns result in ASCIIdigits (five digits followed by 0x00) ; Nokia_5110
                 ;;	mov	temp, temp2					; Nokia_5110
                 ;	ldi	temp2, 5					; Nokia_5110
                 ;	sub	temp2, temp3					; Nokia_5110
                 ;	tst	temp2		 				; Nokia_5110
                 ;	breq	Ld1						; Nokia_5110
                 ;Ld0:	inc	ZL						; Nokia_5110
                 ;	dec	temp2						; Nokia_5110
                 ;	brne	Ld0						; Nokia_5110
                 ;Ld1:								; Nokia_5110
                 ;LD2: 	ld	temp, z+					; Nokia_5110
                 ;	tst	temp						; Nokia_5110
                 ; 	breq	Ld_exit						; Nokia_5110
                 ;	sts	VarByteOne, temp 				; Nokia_5110
                 ; 	rcall	LCD_character	 				; Nokia_5110
                 ; 	rjmp	Ld2						; Nokia_5110
                 ;								; Nokia_5110
                 ;Ld_exit:	 						; Nokia_5110
                 ;	pop	ZL						; Nokia_5110
                 ;	pop	ZH						; Nokia_5110
                 ;	pop	rBin1H						; Nokia_5110
                 ;	pop	rBin1L						; Nokia_5110
                 ;	pop	temp3						; Nokia_5110
                 ;	pop	temp2						; Nokia_5110
                 ;	pop	temp						; Nokia_5110
                 ;	ret							; Nokia_5110
                 ;                                                               ; Nokia_5110
                 ;***************************************************************; Nokia_5110
                 ; LCD__clearline	 					; Nokia_5110
                 ;   Display decimal number starting at LCD position		; Nokia_5110
                 ;								; Nokia_5110
                 ; send:  VarByteOne with line value (0-5)			; Nokia_5110
                 ;	 							; Nokia_5110
                 ;***************************************************************; Nokia_5110
                 LCD_clearline:							; Nokia_5110
0001d8 930f      	push	temp						; Nokia_5110
0001d9 931f      	push	temp2						; Nokia_5110
0001da 93ff      	push	ZH						; Nokia_5110
0001db 93ef      	push	ZL						; Nokia_5110
                 								; Nokia_5110
0001dc 9110 0065 	lds	temp2, VarByteOne				; Nokia_5110
0001de e0f3      	ldi	ZH, high (ClearLine << 1)			; Nokia_5110
0001df eee4      	ldi	ZL, low  (ClearLine << 1)			; Nokia_5110
                 								; Nokia_5110
0001e0 e000      	ldi	temp, 0						; Nokia_5110
0001e1 9300 0065 	sts	VarByteOne, temp				; Nokia_5110
0001e3 9310 0066 	sts	VarByteTwo, temp2				; Nokia_5110
0001e5 dfd7      	rcall	LCD_gotoXY					; Nokia_5110
                 Lclln_0:							; Nokia_5110
0001e6 9105      	lpm	temp, z+					; Nokia_5110
0001e7 2300      	tst	temp						; Nokia_5110
0001e8 f021      	breq	Lclln_1						; Nokia_5110
0001e9 9300 0065 	sts	VarByteOne, temp				; Nokia_5110
0001eb df6e      	rcall	LCD_character					; Nokia_5110
0001ec cff9      	rjmp	Lclln_0						; Nokia_5110
                 Lclln_1:							; Nokia_5110
                 								; Nokia_5110
0001ed 91ef      	pop	ZL						; Nokia_5110
0001ee 91ff      	pop	ZH						; Nokia_5110
0001ef 911f      	pop	temp2						; Nokia_5110
0001f0 910f      	pop	temp						; Nokia_5110
0001f1 9508      	ret							; Nokia_5110
                 								; Nokia_5110
0001f2 2020
0001f3 2020
0001f4 2020
0001f5 2020
0001f6 2020
0001f7 2020
0001f8 2020
0001f9 2020
0001fa 0000      ClearLine:  .db "                ",0,0				; Nokia_5110
                 								; Nokia_5110
                 								; Nokia_5110
                 ;###############################################################; Nokia_5110
                 ;								; Nokia_5110
                 ;  	Nokia 5110 Graphic Character Fonts			; Nokia_5110
                 ;								; Nokia_5110
                 ;###############################################################; Nokia_5110
                 ;								; Nokia_5110
                 ASCII_font:  ; 96 chars, 480 bytes of char data   5 columns by 7 rows per char   ; Nokia_5110
0001fb 0000
0001fc 0000
0001fd 0000
0001fe 5f00
0001ff 0000      .db  0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x5F, 0x00, 0x00 ; space  21 !  ; Nokia_5110
000200 0700
000201 0700
000202 1400
000203 147f
000204 147f      .db  0x00, 0x07, 0x00, 0x07, 0x00,   0x14, 0x7F, 0x14, 0x7F, 0x14 ; 22 "   23 #  ; Nokia_5110
000205 2a24
000206 2a7f
000207 2312
000208 0813
000209 6264      .db  0x24, 0x2A, 0x7F, 0x2A, 0x12,   0x23, 0x13, 0x08, 0x64, 0x62 ; 24 $   25 %  ; Nokia_5110
00020a 4936
00020b 2056
00020c 0050
00020d 0708
00020e 0003      .db  0x36, 0x49, 0x56, 0x20, 0x50,   0x00, 0x08, 0x07, 0x03, 0x00 ; 26 &   27 '  ; Nokia_5110
00020f 1c00
000210 4122
000211 0000
000212 2241
000213 001c      .db  0x00, 0x1C, 0x22, 0x41, 0x00,   0x00, 0x41, 0x22, 0x1C, 0x00 ; 28 (   29 )  ; Nokia_5110
000214 1c2a
000215 1c7f
000216 082a
000217 3e08
000218 0808      .db  0x2A, 0x1C, 0x7F, 0x1C, 0x2A,   0x08, 0x08, 0x3E, 0x08, 0x08 ; 2a *   2b +  ; Nokia_5110
000219 8000
00021a 3070
00021b 0800
00021c 0808
00021d 0808      .db  0x00, 0x80, 0x70, 0x30, 0x00,   0x08, 0x08, 0x08, 0x08, 0x08 ; 2c ,   2d -  ; Nokia_5110
00021e 0000
00021f 6060
000220 2000
000221 0810
000222 0204      .db  0x00, 0x00, 0x60, 0x60, 0x00,   0x20, 0x10, 0x08, 0x04, 0x02 ; 2e .   2f ;  ; Nokia_5110
000223 513e
000224 4549
000225 003e
000226 7f42
000227 0040      .db  0x3E, 0x51, 0x49, 0x45, 0x3E,   0x00, 0x42, 0x7F, 0x40, 0x00 ; 30 0   31 1  ; Nokia_5110
000228 4972
000229 4949
00022a 2146
00022b 4941
00022c 334d      .db  0x72, 0x49, 0x49, 0x49, 0x46,   0x21, 0x41, 0x49, 0x4D, 0x33 ; 32 2   33 3  ; Nokia_5110
00022d 1418
00022e 7f12
00022f 2710
000230 4545
000231 3945      .db  0x18, 0x14, 0x12, 0x7F, 0x10,   0x27, 0x45, 0x45, 0x45, 0x39 ; 34 4   35 5  ; Nokia_5110
000232 4a3c
000233 4949
000234 4131
000235 1121
000236 0709      .db  0x3C, 0x4A, 0x49, 0x49, 0x31,   0x41, 0x21, 0x11, 0x09, 0x07 ; 36 6   37 7  ; Nokia_5110
000237 4936
000238 4949
000239 4636
00023a 4949
00023b 1e29      .db  0x36, 0x49, 0x49, 0x49, 0x36,   0x46, 0x49, 0x49, 0x29, 0x1E ; 38 8   39 9  ; Nokia_5110
00023c 0000
00023d 0014
00023e 0000
00023f 3440
000240 0000      .db  0x00, 0x00, 0x14, 0x00, 0x00,   0x00, 0x40, 0x34, 0x00, 0x00 ; 3a :   3b ;  ; Nokia_5110
000241 0800
000242 2214
000243 1441
000244 1414
000245 1414      .db  0x00, 0x08, 0x14, 0x22, 0x41,   0x14, 0x14, 0x14, 0x14, 0x14 ; 3c <   3d =  ; Nokia_5110
000246 4100
000247 1422
000248 0208
000249 5901
00024a 0609      .db  0x00, 0x41, 0x22, 0x14, 0x08,   0x02, 0x01, 0x59, 0x09, 0x06 ; 3e >   3f ?  ; Nokia_5110
00024b 413e
00024c 595d
00024d 7c4e
00024e 1112
00024f 7c12      .db  0x3E, 0x41, 0x5D, 0x59, 0x4E,   0x7C, 0x12, 0x11, 0x12, 0x7C ; 40 @   41 A  ; Nokia_5110
000250 497f
000251 4949
000252 3e36
000253 4141
000254 2241      .db  0x7F, 0x49, 0x49, 0x49, 0x36,   0x3E, 0x41, 0x41, 0x41, 0x22 ; 42 B   43 C  ; Nokia_5110
000255 417f
000256 4141
000257 7f3e
000258 4949
000259 4149      .db  0x7F, 0x41, 0x41, 0x41, 0x3E,   0x7F, 0x49, 0x49, 0x49, 0x41 ; 44 D   45 E  ; Nokia_5110
00025a 097f
00025b 0909
00025c 3e01
00025d 4141
00025e 7351      .db  0x7F, 0x09, 0x09, 0x09, 0x01,   0x3E, 0x41, 0x41, 0x51, 0x73 ; 46 F   47 G  ; Nokia_5110
00025f 087f
000260 0808
000261 007f
000262 7f41
000263 0041      .db  0x7F, 0x08, 0x08, 0x08, 0x7F,   0x00, 0x41, 0x7F, 0x41, 0x00 ; 48 H   49 I  ; Nokia_5110
000264 4020
000265 3f41
000266 7f01
000267 1408
000268 4122      .db  0x20, 0x40, 0x41, 0x3F, 0x01,   0x7F, 0x08, 0x14, 0x22, 0x41 ; 4a J   4b K  ; Nokia_5110
000269 407f
00026a 4040
00026b 7f40
00026c 1c02
00026d 7f02      .db  0x7F, 0x40, 0x40, 0x40, 0x40,   0x7F, 0x02, 0x1C, 0x02, 0x7F ; 4c L   4d M  ; Nokia_5110
00026e 047f
00026f 1008
000270 3e7f
000271 4141
000272 3e41      .db  0x7F, 0x04, 0x08, 0x10, 0x7F,   0x3E, 0x41, 0x41, 0x41, 0x3E ; 4e N   4f O  ; Nokia_5110
000273 097f
000274 0909
000275 3e06
000276 5141
000277 5e21      .db  0x7F, 0x09, 0x09, 0x09, 0x06,   0x3E, 0x41, 0x51, 0x21, 0x5E ; 50 P   51 Q  ; Nokia_5110
000278 097f
000279 2919
00027a 2646
00027b 4949
00027c 3249      .db  0x7F, 0x09, 0x19, 0x29, 0x46,   0x26, 0x49, 0x49, 0x49, 0x32 ; 52 R   53 S  ; Nokia_5110
00027d 0103
00027e 017f
00027f 3f03
000280 4040
000281 3f40      .db  0x03, 0x01, 0x7F, 0x01, 0x03,   0x3F, 0x40, 0x40, 0x40, 0x3F ; 54 T   55 U  ; Nokia_5110
000282 201f
000283 2040
000284 3f1f
000285 3840
000286 3f40      .db  0x1F, 0x20, 0x40, 0x20, 0x1F,   0x3F, 0x40, 0x38, 0x40, 0x3F ; 56 V   57 W  ; Nokia_5110
000287 1463
000288 1408
000289 0363
00028a 7804
00028b 0304      .db  0x63, 0x14, 0x08, 0x14, 0x63,   0x03, 0x04, 0x78, 0x04, 0x03 ; 58 X   59 Y  ; Nokia_5110
00028c 5961
00028d 4d49
00028e 0043
00028f 417f
000290 4141      .db  0x61, 0x59, 0x49, 0x4D, 0x43,   0x00, 0x7F, 0x41, 0x41, 0x41 ; 5a Z   5b [  ; Nokia_5110
000291 0402
000292 1008
000293 0020
000294 4141
000295 7f41      .db  0x02, 0x04, 0x08, 0x10, 0x20,   0x00, 0x41, 0x41, 0x41, 0x7F ; 5c    5d ]  ; Nokia_5110
000296 0204
000297 0201
000298 4004
000299 4040
00029a 4040      .db  0x04, 0x02, 0x01, 0x02, 0x04,   0x40, 0x40, 0x40, 0x40, 0x40 ; 5e ^   5f _  ; Nokia_5110
00029b 0300
00029c 0807
00029d 2000
00029e 5454
00029f 4078      .db  0x00, 0x03, 0x07, 0x08, 0x00,   0x20, 0x54, 0x54, 0x78, 0x40 ; 60 `   61 a  ; Nokia_5110
0002a0 287f
0002a1 4444
0002a2 3838
0002a3 4444
0002a4 2844      .db  0x7F, 0x28, 0x44, 0x44, 0x38,   0x38, 0x44, 0x44, 0x44, 0x28 ; 62 b   63 c  ; Nokia_5110
0002a5 4438
0002a6 2844
0002a7 387f
0002a8 5454
0002a9 1854      .db  0x38, 0x44, 0x44, 0x28, 0x7F,   0x38, 0x54, 0x54, 0x54, 0x18 ; 64 d   65 e  ; Nokia_5110
0002aa 0800
0002ab 097e
0002ac 1802
0002ad a4a4
0002ae 789c      .db  0x00, 0x08, 0x7E, 0x09, 0x02,   0x18, 0xA4, 0xA4, 0x9C, 0x78 ; 66 f   67 g  ; Nokia_5110
0002af 087f
0002b0 0404
0002b1 0078
0002b2 7d44
0002b3 0040      .db  0x7F, 0x08, 0x04, 0x04, 0x78,   0x00, 0x44, 0x7D, 0x40, 0x00 ; 68 h   69 i  ; Nokia_5110
0002b4 4020
0002b5 3d40
0002b6 7f00
0002b7 2810
0002b8 0044      .db  0x20, 0x40, 0x40, 0x3D, 0x00,   0x7F, 0x10, 0x28, 0x44, 0x00 ; 6a j   6b k  ; Nokia_5110
0002b9 4100
0002ba 407f
0002bb 7c00
0002bc 7804
0002bd 7804      .db  0x00, 0x41, 0x7F, 0x40, 0x00,   0x7C, 0x04, 0x78, 0x04, 0x78 ; 6c l   6d m	 ; Nokia_5110
0002be 087c
0002bf 0404
0002c0 3878
0002c1 4444
0002c2 3844      .db  0x7C, 0x08, 0x04, 0x04, 0x78,   0x38, 0x44, 0x44, 0x44, 0x38 ; 6e n   6f o	 ; Nokia_5110
0002c3 18fc
0002c4 2424
0002c5 1818
0002c6 2424
0002c7 fc18      .db  0xFC, 0x18, 0x24, 0x24, 0x18,   0x18, 0x24, 0x24, 0x18, 0xFC ; 70 p   71 q	 ; Nokia_5110
0002c8 087c
0002c9 0404
0002ca 4808
0002cb 5454
0002cc 2454      .db  0x7C, 0x08, 0x04, 0x04, 0x08,   0x48, 0x54, 0x54, 0x54, 0x24 ; 72 r   73 s	 ; Nokia_5110
0002cd 0404
0002ce 443f
0002cf 3c24
0002d0 4040
0002d1 7c20      .db  0x04, 0x04, 0x3F, 0x44, 0x24,   0x3C, 0x40, 0x40, 0x20, 0x7C ; 74 t   75 u	 ; Nokia_5110
0002d2 201c
0002d3 2040
0002d4 3c1c
0002d5 3040
0002d6 3c40      .db  0x1C, 0x20, 0x40, 0x20, 0x1C,   0x3C, 0x40, 0x30, 0x40, 0x3C ; 76 v   77 w	 ; Nokia_5110
0002d7 2844
0002d8 2810
0002d9 4c44
0002da 9090
0002db 7c90      .db  0x44, 0x28, 0x10, 0x28, 0x44,   0x4C, 0x90, 0x90, 0x90, 0x7C ; 78 x   79 y	 ; Nokia_5110
0002dc 6444
0002dd 4c54
0002de 0044
0002df 3608
0002e0 0041      .db  0x44, 0x64, 0x54, 0x4C, 0x44,   0x00, 0x08, 0x36, 0x41, 0x00 ; 7a z   7b {	 ; Nokia_5110
0002e1 0000
0002e2 0077
0002e3 0000
0002e4 3641
0002e5 0008      .db  0x00, 0x00, 0x77, 0x00, 0x00,   0x00, 0x41, 0x36, 0x08, 0x00 ; 7c |   7d }	 ; Nokia_5110
0002e6 0102
0002e7 0402
0002e8 3c02
0002e9 2326
0002ea 3c26      .db  0x02, 0x01, 0x02, 0x04, 0x02,   0x3C, 0x26, 0x23, 0x26, 0x3C ; 7e ?   7f ?	 ; Nokia_5110
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Nokia_5110
                 ;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; Nokia_5110
                 
                 
                 ;********************************************************************************************
                 ;  Byte2Hex ASCII  Convert a byte to two hexidecimal ASCII characters.
                 ;
                 ; send:		DataByte
                 ; return:	{SRAM} ByteASChigh, ByteASClow
                 ; uses:		temp; ZH:ZL (non-destructive)
                 ;********************************************************************************************
                 Byte2HexASCII:
0002eb 93ff      	push	ZH
0002ec 93ef      	push	ZL
0002ed 930f      	push	temp
                 
0002ee 9100 006a 	lds	temp, DataByte
0002f0 9502      	swap	temp
0002f1 700f      	andi	temp, 0x0f
0002f2 e0f6      	ldi	ZH, high (hexchars << 1)
0002f3 e0ee      	ldi	ZL, low  (hexchars << 1)
0002f4 0fe0      	add	ZL, temp
0002f5 1dff      	adc	ZH, ZeroReg
0002f6 9104      	lpm	temp, z
0002f7 9300 006e 	sts	ByteASChigh, temp
                 
0002f9 9100 006a 	lds	temp, DataByte
0002fb 700f      	andi	temp, 0x0f
0002fc e0f6      	ldi	ZH, high (hexchars << 1)
0002fd e0ee      	ldi	ZL, low  (hexchars << 1)
0002fe 0fe0      	add	ZL, temp
0002ff 1dff      	adc	ZH, ZeroReg
000300 9104      	lpm	temp, z
000301 9300 006f 	sts	ByteASClow, temp
                 
000303 910f      	pop	temp
000304 91ef      	pop	ZL
000305 91ff      	pop	ZH
000306 9508      	ret
                 
000307 3130
000308 3332
000309 3534
00030a 3736
00030b 3938
00030c 4241
00030d 4443
00030e 4645      hexchars: .db "0123456789ABCDEF"
                 ;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;
                 
                 
                 
                 
                 ;***************************************************************;<> Interrupt_Routines
                 ;  Timer 1 overflow   set to activate every 31.25 milliseconds	;<> Interrupt_Routines
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;<> Interrupt_Routines
                 								;<> Interrupt_Routines
                 TIM1_OVF:							;<> Interrupt_Routines
00030f b6ef      	in	SREGtemp, SREG	; 0x3f				;<> Interrupt_Routines
                 								;<> Interrupt_Routines
000310 ef3c      	ldi	irqtemp, high (~LongPeriod)			;<> Interrupt_Routines
000311 bd3d      	out	TCNT1H, irqtemp  	; 0x6f			;<> Interrupt_Routines
000312 e23f      	ldi	irqtemp, low  (~LongPeriod)			;<> Interrupt_Routines
000313 bd3c      	out	TCNT1L,  irqtemp  	; 0x6e			;<> Interrupt_Routines
                 								;<> Interrupt_Routines
                 ;  set a flag for the main code to know that T1 IRQ happened	;<> Interrupt_Routines
000314 9130 006d 	lds	irqtemp, TaskFlags				;<> Interrupt_Routines
000316 6830      	sbr	irqtemp, (1 << T1_HeartBeat)			;<> Interrupt_Routines
000317 9330 006d 	sts	TaskFlags, irqtemp				;<> Interrupt_Routines
                 								;<> Interrupt_Routines
000319 9130 0060 	lds	irqtemp, HeartBeatCntr				;<> Interrupt_Routines
00031b 9533      	inc	irqtemp						;<> Interrupt_Routines
00031c 9330 0060 	sts	HeartBeatCntr, irqtemp				;<> Interrupt_Routines
                 								;<> Interrupt_Routines
                 ; check if HBcntr mod 32 == 0. If yes, inc SecondCount		;<> Interrupt_Routines
00031e 713f       	andi	irqtemp,  HB_PER_SECOND - 1    ; ### DEBUG	;<> Interrupt_Routines
00031f f461      	brne	T1ovf_exit					;<> Interrupt_Routines
                 								;<> Interrupt_Routines
000320 9130 0061 	lds	irqtemp, SecondCount  ; init to 0 by reset	;<> Interrupt_Routines
000322 9533      	inc	irqtemp						;<> Interrupt_Routines
000323 9330 0061 	sts	SecondCount, irqtemp				;<> Interrupt_Routines
000325 2333      	tst	irqtemp						;<> Interrupt_Routines
000326 f429      	brne	T1ovf_exit					;<> Interrupt_Routines
000327 9130 0062 	lds	irqtemp, HighSecCount ; init to 0 by reset	;<> Interrupt_Routines
000329 9533      	inc	irqtemp						;<> Interrupt_Routines
00032a 9330 0062 	sts	HighSecCount, irqtemp				;<> Interrupt_Routines
                 								;<> Interrupt_Routines
                 T1ovf_exit:							;<> Interrupt_Routines
00032c beef      	out	SREG, SREGtemp		;0x3f			;<> Interrupt_Routines
00032d 9518       	reti 							;<> Interrupt_Routines
                 								;<> Interrupt_Routines
                 ;***************************************************************;<> Interrupt_Routines
                 
                 
                 
                 
                 ;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;%% Math
                 ;    Math Routines							;%% Math
                 ;									;%% Math
                 ; Bin2ToAsc5			58 instructions	/ 116 bytes		;%% Math
                 ; ==========								;%% Math
                 ; converts a 16-bit-binary to a 5 digit ASCII-coded decimal		;%% Math
                 ; In: 16-bit-binary in rBin1H:rBin1L, ZH:ZL points to 'ASCIIdigits'	;%% Math
                 ;   in Static RAM, where the result goes to.				;%% Math
                 ; Out: Z points to the beginning of the ASCII string,			;%% Math
                 ;   16-bit number value in five bytes of ASCIIdigit buffer on return	;%% Math
                 ;   leading zeros are filled with blanks				;%% Math
                 ; Used registers: rBin1H:rBin1L (content is not changed),		;%% Math
                 ;   rBin2H:rBin2L (content is changed), temp{highreg}			;%% Math
                 ; Called subroutines: Bin2ToBcd5					;%% Math
                 ;									;%% Math
                 Bin2ToAsc5: ;								;%% Math
00032e d012      	rcall	Bin2ToBcd5	; convert binary to BCD			;%% Math
00032f e004      	ldi	temp, 4		; Counter is 4 leading digits		;%% Math
000330 2e60      	mov	rBin2L, temp						;%% Math
                 Bin2ToAsc5a:								;%% Math
000331 8100      	ld	temp, z		; read a BCD digit			;%% Math
000332 2300      	tst	temp		; check if leading zero			;%% Math
000333 f429      	brne	Bin2ToAsc5b	; No, found digit >0			;%% Math
000334 e200      	ldi	temp,' '	; overwrite with blank			;%% Math
000335 9301      	st	z+, temp	; store and set to next position	;%% Math
000336 946a      	dec	rBin2L		; decrement counter			;%% Math
000337 f7c9      	brne	Bin2ToAsc5a	; further leading blanks		;%% Math
000338 8100      	ld	temp, z		; Read the last BCD			;%% Math
                 Bin2ToAsc5b:								;%% Math
000339 9463      	inc	rBin2L		; one more char				;%% Math
                 Bin2ToAsc5c:								;%% Math
00033a 5d00      	subi	temp,-'0'	; Add ASCII-0				;%% Math
00033b 9301      	st	z+, temp	; store and inc pointer			;%% Math
00033c 8100      	ld	temp,z		; read next char			;%% Math
00033d 946a      	dec	rBin2L		; more chars?				;%% Math
00033e f7d9      	brne	Bin2ToAsc5c	; yes, go on				;%% Math
00033f 9735      	sbiw	ZL, 5		; Pointer to beginning of the BCD	;%% Math
000340 9508      	ret 			; done					;%% Math
                 									;%% Math
                 									;%% Math
                 ; Bin2ToBcd5								;%% Math
                 ; ==========								;%% Math
                 ; converts a 16-bit-binary to a 5-digit-BCD				;%% Math
                 ; In: 16-bit-binary in rBin1H:L, Z points to first digit		;%% Math
                 ;   where the result goes to						;%% Math
                 ; Out: 5-digit-BCD, Z points to first BCD-digit				;%% Math
                 ; Used registers: rBin1H:L (unchanged), rBin2H:L (changed),		;%% Math
                 ;   temp								;%% Math
                 ; Called subroutines: Bin2ToDigit					;%% Math
                 ;									;%% Math
                 Bin2ToBcd5:								;%% Math
000341 925f      	push	rBin1H		; Save number				;%% Math
000342 924f      	push	rBin1L							;%% Math
000343 e207      	ldi	temp, HIGH (10000) ; Start with ten thousands		;%% Math
000344 2e70      	mov	rBin2H,temp						;%% Math
000345 e100      	ldi	temp, LOW (10000)					;%% Math
000346 2e60      	mov	rBin2L,temp						;%% Math
000347 d014      	rcall	Bin2ToDigit	; Calculate digit			;%% Math
000348 e003      	ldi	temp, HIGH (1000) ; Next with thousands			;%% Math
000349 2e70      	mov	rBin2H,temp						;%% Math
00034a ee08      	ldi	temp, LOW (1000)					;%% Math
00034b 2e60      	mov	rBin2L, temp						;%% Math
00034c d00f      	rcall	Bin2ToDigit	; Calculate digit			;%% Math
00034d e000      	ldi	temp, HIGH (100); Next with hundreds			;%% Math
00034e 2e70      	mov	rBin2H, temp						;%% Math
00034f e604      	ldi	temp, LOW (100)						;%% Math
000350 2e60      	mov	rBin2L, temp						;%% Math
000351 d00a      	rcall	Bin2ToDigit	; Calculate digit			;%% Math
000352 e000      	ldi	temp, HIGH (10)	; Next with tens			;%% Math
000353 2e70      	mov	rBin2H, temp						;%% Math
000354 e00a      	ldi	temp, LOW (10)						;%% Math
000355 2e60      	mov	rBin2L, temp						;%% Math
000356 d005      	rcall	Bin2ToDigit	; Calculate digit			;%% Math
000357 8240      	st	z,rBin1L	; Remainder are ones			;%% Math
000358 9734      	sbiw	ZL, 4		; Put pointer to first BCD		;%% Math
000359 904f      	pop	rBin1L		; Restore original binary		;%% Math
00035a 905f      	pop	rBin1H							;%% Math
00035b 9508      	ret			; and return				;%% Math
                 									;%% Math
                 									;%% Math
                 ; Bin2ToDigit								;%% Math
                 ; ===========								;%% Math
                 ; converts one decimal digit by continued subtraction of a		;%% Math
                 ;   binary coded decimal						;%% Math
                 ; Used by: Bin2ToBcd5, Bin2ToAsc5, Bin2ToAsc				;%% Math
                 ; In:	16-bit-binary in rBin1H:L, binary coded decimal in		;%% Math
                 ;	rBin2H:L, Z points to current BCD digit				;%% Math
                 ; Out:	ZH:ZL points to location that has # of times rbin2 is in rBin1	;%% Math
                 ;	rBin1H:L (holds remainder of the binary),			;%% Math
                 ; Used registers:   rBin2H:L (unchanged), temp, ZH:ZL			;%% Math
                 ; Called subroutines: -							;%% Math
                 ;									;%% Math
                 Bin2ToDigit:								;%% Math
00035c 2700      	clr	temp		; digit count is zero			;%% Math
                 Bin2ToDigitA:								;%% Math
00035d 1457      	cp	rBin1H, rBin2H	; Number bigger than decimal?		;%% Math
00035e f038      	brcs	Bin2ToDigitC	; MSB smaller than decimal		;%% Math
00035f f411      	brne	Bin2ToDigitB	; MSB bigger than decimal		;%% Math
000360 1446      	cp	rBin1L, rBin2L	; LSB bigger or equal decimal		;%% Math
000361 f020      	brcs	Bin2ToDigitC	; LSB smaller than decimal		;%% Math
                 Bin2ToDigitB:								;%% Math
000362 1846      	sub	rBin1L, rBin2L	; Subtract LSB decimal			;%% Math
000363 0857      	sbc	rBin1H, rBin2H	; Subtract MSB decimal			;%% Math
000364 9503      	inc	temp		; Increment digit count			;%% Math
000365 cff7      	rjmp	Bin2ToDigitA	; Next loop				;%% Math
                 Bin2ToDigitC:								;%% Math
000366 9301      	st	z+, temp	; Save digit and increment		;%% Math
000367 9508      	ret 			; done					;%% Math
                 ;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;Math
                 
                 
                 ;******************************************************************************************************
                 ; LongDelay	counts T1 periods { 80 per second: 12.5mS period } for long do-nothing loops.
                 ;  used by Reset/initApplication for LCD message display timing.
                 ; send:	temp    --- 8MHz =0.125uS period  if timer1 prescaler=1024, then each timer1 interval is 128uS.
                 ; uses: temp2 (n_d) = number of 12.5mS periods to wait
                 ;******************************************************************************************************
                 LongDelay:
000368 931f      	push	temp2
                 
000369 9110 0060 	lds	temp2, HeartBeatCntr
00036b 0f10      	add	temp2, temp
00036c 9100 0060 LDly_1:	lds	temp, HeartBeatCntr
00036e 1301      	cpse	temp, temp2
00036f cffc      	rjmp	LDly_1
                 
000370 911f      	pop	temp2
000371 9508      	ret
                 ;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                 
                 
                 BigDigits:	; 12 columns * 3 rows * 12 characters  432 bytes
                 ;       0    1    2    3    4    5    6    7    8    9    a    b
000372 fefc
000373 0ffe
000374 0707
000375 0707
000376 fecf
000377 f8fc      .db	0xfc,0xfe,0xfe,0x0f,0x07,0x07,0x07,0x07,0xcf,0xfe,0xfc,0xf8	;character '0'
000378 ffff
000379 f0ff
00037a 3c78
00037b 0f1e
00037c ff07
00037d ffff      .db	0xff,0xff,0xff,0xf0,0x78,0x3c,0x1e,0x0f,0x07,0xff,0xff,0xff
00037e 7f3f
00037f f87f
000380 f0f0
000381 f0f0
000382 7ff8
000383 1f7f      .db	0x3f,0x7f,0x7f,0xf8,0xf0,0xf0,0xf0,0xf0,0xf8,0x7f,0x7f,0x1f
                 
000384 0000
000385 6040
000386 7870
000387 fefc
000388 ffff
000389 0000      .db     0x00,0x00,0x40,0x60,0x70,0x78,0xfc,0xfe,0xff,0xff,0x00,0x00	;character '1'
00038a 0000
00038b 0000
00038c 0000
00038d ffff
00038e ffff
00038f 0000      .db     0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x00
000390 0000
000391 0000
000392 0000
000393 ffff
000394 ffff
000395 0000      .db     0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x00
                 
000396 3c38
000397 0f3e
000398 0707
000399 0f07
00039a ff1f
00039b fcfe      .db     0x38,0x3c,0x3e,0x0f,0x07,0x07,0x07,0x0f,0x1f,0xff,0xfe,0xfc	;character '2'
00039c e0c0
00039d f0e0
00039e 7878
00039f 1e3c
0003a0 0f0f
0003a1 0307      .db     0xc0,0xe0,0xe0,0xf0,0x78,0x78,0x3c,0x1e,0x0f,0x0f,0x07,0x03
0003a2 ffff
0003a3 f0ff
0003a4 f0f0
0003a5 f0f0
0003a6 f0f0
0003a7 f0f0      .db     0xff,0xff,0xff,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0
                 
0003a8 3c38
0003a9 0f1e
0003aa 0f0f
0003ab 0f0f
0003ac fc1e
0003ad f0f8      .db	0x38,0x3c,0x1e,0x0f,0x0f,0x0f,0x0f,0x0f,0x1e,0xfc,0xf8,0xf0  	;character '3'
0003ae 0000
0003af 1e00
0003b0 1e1e
0003b1 3e1e
0003b2 ffff
0003b3 80e7      .db	0x00,0x00,0x00,0x1e,0x1e,0x1e,0x1e,0x3e,0xff,0xff,0xe7,0x80
0003b4 f878
0003b5 f0f0
0003b6 f0f0
0003b7 f0f0
0003b8 fff8
0003b9 1f7f      .db	0x78,0xf8,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf8,0xff,0x7f,0x1f
                 
0003ba 0000
0003bb 0000
0003bc c000
0003bd f8f0
0003be ff7e
0003bf ffff      .db	0x00,0x00,0x00,0x00,0x00,0xc0,0xf0,0xf8,0x7e,0xff,0xff,0xff	;character '4'
0003c0 f0e0
0003c1 bef8
0003c2 8f9f
0003c3 8183
0003c4 ff80
0003c5 ffff      .db	0xe0,0xf0,0xf8,0xbe,0x9f,0x8f,0x83,0x81,0x80,0xff,0xff,0xff
0003c6 0303
0003c7 0303
0003c8 0303
0003c9 0303
0003ca ff03
0003cb ffff      .db	0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0xff,0xff,0xff
                 
0003cc ffff
0003cd 87ff
0003ce 8787
0003cf 8787
0003d0 0787
0003d1 0707      .db     0xff,0xff,0xff,0x87,0x87,0x87,0x87,0x87,0x87,0x07,0x07,0x07 	;character '5'
0003d2 0707
0003d3 0303
0003d4 0303
0003d5 0303
0003d6 ff07
0003d7 fcff      .db     0x07,0x07,0x03,0x03,0x03,0x03,0x03,0x03,0x07,0xff,0xff,0xfc
0003d8 7c3c
0003d9 f078
0003da f0f0
0003db f0f0
0003dc 7f78
0003dd 1f3f      .db     0x3c,0x7c,0x78,0xf0,0xf0,0xf0,0xf0,0xf0,0x78,0x7f,0x3f,0x1f
                 
0003de fcf8
0003df 0ffe
0003e0 0707
0003e1 0707
0003e2 0f07
0003e3 1c1e      .db	0xf8,0xfc,0xfe,0x0f,0x07,0x07,0x07,0x07,0x07,0x0f,0x1e,0x1c	;character '6'
0003e4 ffff
0003e5 1eff
0003e6 0e0e
0003e7 0e0e
0003e8 fe1e
0003e9 f8fc      .db	0xff,0xff,0xff,0x1e,0x0e,0x0e,0x0e,0x0e,0x1e,0xfe,0xfc,0xf8
0003ea 7f3f
0003eb f07f
0003ec e0e0
0003ed e0e0
0003ee 7ff8
0003ef 1f3f      .db	0x3f,0x7f,0x7f,0xf0,0xe0,0xe0,0xe0,0xe0,0xf8,0x7f,0x3f,0x1f
                 
0003f0 0707
0003f1 0707
0003f2 0707
0003f3 0707
0003f4 ffff
0003f5 ffff      .db	0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0xff,0xff,0xff,0xff	;character '7'
0003f6 0000
0003f7 0000
0003f8 e080
0003f9 fef8
0003fa 1f7f
0003fb 030f      .db	0x00,0x00,0x00,0x00,0x80,0xe0,0xf8,0xfe,0x7f,0x1f,0x0f,0x03
0003fc c000
0003fd fef0
0003fe 1fff
0003ff 0107
000400 0000
000401 0000      .db	0x00,0xc0,0xf0,0xfe,0xff,0x1f,0x07,0x01,0x00,0x00,0x00,0x00
                 
000402 fef8
000403 07ff
000404 0707
000405 0707
000406 ff8f
000407 78fe      .db	0xf8,0xfe,0xff,0x07,0x07,0x07,0x07,0x07,0x8f,0xff,0xfe,0x78	;character '8'
000408 ffe0
000409 1fff
00040a 0e0e
00040b 1f0e
00040c ff3f
00040d e0f9      .db	0xe0,0xff,0xff,0x1f,0x0e,0x0e,0x0e,0x1f,0x3f,0xff,0xf9,0xe0
00040e 7f1f
00040f f07f
000410 e0e0
000411 f0e0
000412 7f78
000413 1f3f      .db	0x1f,0x7f,0x7f,0xf0,0xe0,0xe0,0xe0,0xf0,0x78,0x7f,0x3f,0x1f
                 
000414 fefc
000415 0fff
000416 0707
000417 0707
000418 ff0f
000419 f8fc      .db	0xfc,0xfe,0xff,0x0f,0x07,0x07,0x07,0x07,0x0f,0xff,0xfc,0xf8	;character '9'
00041a 3f1f
00041b 7c3f
00041c 7878
00041d 7878
00041e ff3c
00041f ffff      .db	0x1f,0x3f,0x3f,0x7c,0x78,0x78,0x78,0x78,0x3c,0xff,0xff,0xff
000420 7000
000421 f0f0
000422 f0f0
000423 7870
000424 3f7c
000425 0f3f      .db	0x00,0x70,0xf0,0xf0,0xf0,0xf0,0x70,0x78,0x7c,0x3f,0x3f,0x0f
                 
000426 0000
000427 6000
000428 f8f0
000429 f0f8
00042a 0060
00042b 0000      .db	0x00,0x00,0x00,0x60,0xf0,0xf8,0xf8,0xf0,0x60,0x00,0x00,0x00	;character ':'
00042c 0000
00042d 0000
00042e c180
00042f 80c1
000430 0000
000431 0000      .db	0x00,0x00,0x00,0x00,0x80,0xc1,0xc1,0x80,0x00,0x00,0x00,0x00
000432 0000
000433 0300
000434 0f07
000435 070f
000436 0003
000437 0000      .db	0x00,0x00,0x00,0x03,0x07,0x0f,0x0f,0x07,0x03,0x00,0x00,0x00
                 
000438 0000
000439 0000
00043a 0000
00043b 0000
00043c 0000
00043d 0000      .db     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	;character ' '
00043e 0000
00043f 0000
000440 0000
000441 0000
000442 0000
000443 0000      .db     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
000444 0000
000445 0000
000446 0000
000447 0000
000448 0000
000449 0000      .db     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 
                 
                 ;***************************************************************;
                 ; Show_RealTime   Display hours and minutes			;
                 ;								;
                 ;  send:  	RTCBuffer					;
                 ;  return:	-- 						;
                 ;  calls:	ShowBigDigit					;
                 ;			 					;
                 ;  constants:	BIG_CHARWIDTH					;
                 ;								;
                 ;  bit 7   6   5    4    3   2   1   0				;
                 ;00:  CH   10s seconds   -1s seconds-- ClockHalt (clear=osc on)	;
                 ;01:   0   10s minutes   -1s minutes--				;
                 ;02:             10 hr     1s hrs				;
                 ;03:                         ---day--- 				;
                 ;04:   0   0   10s date    1s date				;
                 ;05:   0   0   0   10s mns   1s mns				;
                 ;06      10s year           1s year				;
                 ;07: out  0    0 SQW=1   0  0  RS1  RS0				;
                 ;08-3F    RAM	 RAM   	 RAM	 RAM				;
                 ;---------------------------------------------------------------; Show_RealTime
                 ShowRealTime:  							; Show_RealTime
00044a 93ff      	push	ZH						; Show_RealTime
00044b 93ef      	push	ZL						; Show_RealTime
00044c 93df      	push	YH						; Show_RealTime
00044d 93cf      	push	YL						; Show_RealTime
00044e 932f      	push	temp3						; Show_RealTime
00044f 931f      	push	temp2						; Show_RealTime
000450 930f      	push	temp						; Show_RealTime
                 								; Show_RealTime
                 ;---------------------------------------------------------------; Show_RealTime
                 ; 								; Show_RealTime
                 ; write 10s of hours	       					; Show_RealTime
000451 e0f0              ldi	ZH, high (RTCBuffer+2)				; Show_RealTime
000452 e7e4              ldi	ZL, low  (RTCBuffer+2)				; Show_RealTime
000453 8100      	ld	temp, z 					; Show_RealTime
000454 9502      	swap	temp 						; Show_RealTime
000455 7003      	andi	temp, 0x03       				; Show_RealTime
000456 3000      	cpi	temp, 0       					; Show_RealTime
000457 f409      	brne	srt0a       					; Show_RealTime
000458 e00b      	ldi	temp, 11       					; Show_RealTime
000459 9300 006a srt0a:	sts	DataByte, temp 					; Show_RealTime
00045b e000      	ldi	temp, (0 * BIGCHARWIDTH) + 0			; Show_RealTime
00045c 9300 006c 	sts	Xposition, temp       				; Show_RealTime
00045e e000      	ldi	temp, 0       					; Show_RealTime
00045f 9300 006b 	sts	Yposition, temp       				; Show_RealTime
000461 d076      	rcall	ShowBigDigit  ;DataByte [BD offset] Xpos: Ypos	; Show_RealTime
                 ; 								; Show_RealTime
                 ; write 1s of hours	       					; Show_RealTime
000462 e0f0              ldi	ZH, high (RTCBuffer+2)				; Show_RealTime
000463 e7e4              ldi	ZL, low  (RTCBuffer+2)				; Show_RealTime
000464 8100      	ld	temp, z 					; Show_RealTime
000465 700f      	andi	temp, 0x0f       				; Show_RealTime
000466 9300 006a 	sts	DataByte, temp 					; Show_RealTime
000468 e00e      	ldi	temp, (1 * BIGCHARWIDTH) + 2			; Show_RealTime
000469 9300 006c 	sts	Xposition, temp       				; Show_RealTime
00046b e000      	ldi	temp, 0       					; Show_RealTime
00046c 9300 006b 	sts	Yposition, temp       				; Show_RealTime
00046e d069      	rcall	ShowBigDigit  ;DataByte [BD offset] Xpos: Ypos	; Show_RealTime
                 ; 								; Show_RealTime
                 ; write 10s of minutes	       					; Show_RealTime
00046f e0f0              ldi	ZH, high (RTCBuffer+1)				; Show_RealTime
000470 e7e3              ldi	ZL, low  (RTCBuffer+1)				; Show_RealTime
000471 8100      	ld	temp, z 					; Show_RealTime
000472 9502      	swap	temp 						; Show_RealTime
000473 700f      	andi	temp, 0x0f       				; Show_RealTime
000474 9300 006a 	sts	DataByte, temp 					; Show_RealTime
000476 e20a      	ldi	temp, (3 * BIGCHARWIDTH) + 6			; Show_RealTime
000477 9300 006c 	sts	Xposition, temp       				; Show_RealTime
000479 e000      	ldi	temp, 0       					; Show_RealTime
00047a 9300 006b 	sts	Yposition, temp       				; Show_RealTime
00047c d05b      	rcall	ShowBigDigit  ;DataByte [BD offset] Xpos: Ypos	; Show_RealTime
                 ; 								; Show_RealTime
                 ; write 1s of minutes	       					; Show_RealTime
00047d e0f0              ldi	ZH, high (RTCBuffer+1)				; Show_RealTime
00047e e7e3              ldi	ZL, low  (RTCBuffer+1)				; Show_RealTime
00047f 8100      	ld	temp, z 					; Show_RealTime
000480 700f      	andi	temp, 0x0f       				; Show_RealTime
000481 9300 006a 	sts	DataByte, temp 					; Show_RealTime
000483 e308      	ldi	temp, (4 * BIGCHARWIDTH) + 8			; Show_RealTime
000484 9300 006c 	sts	Xposition, temp       				; Show_RealTime
000486 e000      	ldi	temp, 0       					; Show_RealTime
000487 9300 006b 	sts	Yposition, temp       				; Show_RealTime
000489 d04e      	rcall	ShowBigDigit  ;DataByte [BD offset] Xpos: Ypos	; Show_RealTime
                 ; 								; Show_RealTime
                 ; write colon		       					; Show_RealTime
00048a e00a      	ldi	temp, 10					; Show_RealTime
00048b 9300 006a 	sts	DataByte, temp 					; Show_RealTime
00048d e10c      	ldi	temp, (2 * BIGCHARWIDTH) + 4			; Show_RealTime
00048e 9300 006c 	sts	Xposition, temp       				; Show_RealTime
000490 e000      	ldi	temp, 0       					; Show_RealTime
000491 9300 006b 	sts	Yposition, temp       				; Show_RealTime
000493 d044      	rcall	ShowBigDigit  ;DataByte [BD offset] Xpos: Ypos	; Show_RealTime
                 								; Show_RealTime
                 ; write 10s of seconds in small digits				; Show_RealTime
000494 e408      	ldi	temp, 72  ; NOkia 5110 pixel column		; Show_RealTime
000495 9300 0065 	sts	VarByteOne, temp       				; Show_RealTime
000497 e002      	ldi	temp, 2   ; NOkia 5110 row number		; Show_RealTime
000498 9300 0066 	sts	VarByteTwo, temp       				; Show_RealTime
00049a dd22      	rcall	LCD_gotoXY       				; Show_RealTime
                 				       				; Show_RealTime
00049b e0f0              ldi	ZH, high (RTCBuffer+0)				; Show_RealTime
00049c e7e2              ldi	ZL, low  (RTCBuffer+0)				; Show_RealTime
00049d 8100      	ld	temp, z 					; Show_RealTime
00049e 9502      	swap	temp 						; Show_RealTime
00049f 700f      	andi	temp, 0x0f       				; Show_RealTime
0004a0 6300      	ori	temp, 0x30  ; make it an ASCII digit		; Show_RealTime
0004a1 9300 0065 	sts	VarByteOne, temp 				; Show_RealTime
0004a3 dcb6      	rcall	LCD_character	       				; Show_RealTime
                 				       				; Show_RealTime
                 ; write 1s of seconds in small digits  				; Show_RealTime
0004a4 e40e      	ldi	temp, 78	 ; Nokia 5110 pixel column	; Show_RealTime
0004a5 9300 0065 	sts	VarByteOne, temp       				; Show_RealTime
0004a7 e002      	ldi	temp, 2    	 ; Nokia 5110 row number	; Show_RealTime
0004a8 9300 0066 	sts	VarByteTwo, temp       				; Show_RealTime
0004aa dd12      	rcall	LCD_gotoXY       				; Show_RealTime
                 				       				; Show_RealTime
0004ab e0f0              ldi	ZH, high (RTCBuffer+0)				; Show_RealTime
0004ac e7e2              ldi	ZL, low  (RTCBuffer+0)				; Show_RealTime
0004ad 8100      	ld	temp, z 					; Show_RealTime
0004ae 700f      	andi	temp, 0x0f       				; Show_RealTime
0004af 6300      	ori	temp, 0x30  ; make it an ASCII digit		; Show_RealTime
0004b0 9300 0065 	sts	VarByteOne, temp 				; Show_RealTime
0004b2 dca7      	rcall	LCD_character	       				; Show_RealTime
                 ; 								; Show_RealTime
                 ; write date -  month text     					; Show_RealTime
0004b3 e000      	ldi	temp, 0	* PIXELSperCHAR				; Show_RealTime
0004b4 9300 0065 	sts	VarByteOne, temp       				; Show_RealTime
0004b6 e004      	ldi	temp, 4 ; Nokia 5110 row number			; Show_RealTime
0004b7 9300 0066 	sts	VarByteTwo, temp       				; Show_RealTime
0004b9 dd03      	rcall	LCD_gotoXY       				; Show_RealTime
                 				       				; Show_RealTime
0004ba e0f0              ldi	ZH, high (RTCBuffer+5)				; Show_RealTime
0004bb e7e7              ldi	ZL, low  (RTCBuffer+5)				; Show_RealTime
0004bc 8100      	ld	temp, z	; not BCD, datasheet is wrong!		; Show_RealTime
0004bd 950a      	dec	temp	; month 0-11 instead of 1-12		; Show_RealTime
0004be d090      	rcall	DisplayArbLenStr				; Show_RealTime
                 								; Show_RealTime
                 ; write date -  date number					; Show_RealTime
0004bf e0f0      	ldi	ZH, high (RTCBuffer+4)				; Show_RealTime
0004c0 e7e6              ldi	ZL, low  (RTCBuffer+4)				; Show_RealTime
0004c1 8100              ld	temp, z 					; Show_RealTime
0004c2 9502              swap	temp						; Show_RealTime
0004c3 7003              andi	temp, 0x03					; Show_RealTime
0004c4 6300       	ori	temp, 0x30 ; make it an ASCII digit		; Show_RealTime
0004c5 9300 0065         sts	VarByteOne, temp				; Show_RealTime
0004c7 dc92              rcall	LCD_character					; Show_RealTime
0004c8 e0f0      	ldi	ZH, high (RTCBuffer+4)				; Show_RealTime
0004c9 e7e6      	ldi	ZL, low  (RTCBuffer+4)				; Show_RealTime
0004ca 8100      	ld	temp, z 					; Show_RealTime
0004cb 700f      	andi	temp, 0x0f					; Show_RealTime
0004cc 6300      	ori	temp, 0x30 ; make it an ASCII digit		; Show_RealTime
0004cd 9300 0065 	sts	VarByteOne, temp				; Show_RealTime
0004cf dc8a      	rcall	LCD_character					; Show_RealTime
                  								; Show_RealTime
                 srt_exit:							; Show_RealTime
0004d0 910f      	pop	temp 						; Show_RealTime
0004d1 911f      	pop	temp2						; Show_RealTime
0004d2 912f      	pop	temp3						; Show_RealTime
0004d3 91cf      	pop	YL						; Show_RealTime
0004d4 91df      	pop	YH 						; Show_RealTime
0004d5 91ef      	pop	ZL						; Show_RealTime
0004d6 91ff      	pop	ZH						; Show_RealTime
                 								; Show_RealTime
0004d7 9508      	ret							; Show_RealTime
                 								; Show_RealTime
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Show_RealTime
                 
                 
                 ;***************************************************************;
                 ; Show_BigDigit    						;
                 ;								;
                 ; called by:  ShowRealTime					;
                 ;								;
                 ; send:  DataByte [offset into BigDigit table]			;
                 ;	 Xposition: Yposition  [upper-left corner pixel]	;
                 ;								;
                 ; return:  -							;
                 ;								;
                 ; calls: LCD__gotoXY	uses: VarByteOne{x},VarByteTwo{y}	;
                 ;	 LCD__write	uses: VarByteOne{LCD_D}			;
                 ;			VarByteTwo{DataByte}			;
                 ;								;
                 ; constants:	BIGCHARWIDTH, NUM_ROWS_PER_CHAR			;
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;
                 ShowBigDigit:  ;DataByte [BD offset] Xpos: Ypos			; Show_BigDigit
0004d8 930f      	push	temp						; Show_BigDigit
0004d9 931f      	push	temp2						; Show_BigDigit
0004da 922f      	push	Lowtemp0					; Show_BigDigit
0004db 923f      	push	Lowtemp1					; Show_BigDigit
0004dc 93ff      	push	ZH						; Show_BigDigit
0004dd 93ef      	push	ZL						; Show_BigDigit
                 								; Show_BigDigit
                 ; multiply digit value by 36 to get offset into BD table.	; Show_BigDigit
0004de 9100 006a 	lds	temp, DataByte					; Show_BigDigit
                  ;								; Show_BigDigit
0004e0 e214      	ldi	temp2, 36	; comment these four lines	; Show_BigDigit
0004e1 9f01      	mul	temp, temp2	; for AVRs without MUL instr	; Show_BigDigit
0004e2 2d00      	mov	temp,  r0	; like the Tiny1634.		; Show_BigDigit
0004e3 2d11      	mov	temp2, r1	;				; Show_BigDigit
                 ; 	rcall	Multiply36	; uncomment these three lines	; Show_BigDigit
                 ;  	lds	temp,   resultL	; for AVRs without MUL instr	; Show_BigDigit
                 ; 	lds	temp2,  resultH		 			; Show_BigDigit
                 								; Show_BigDigit
0004e4 9040 006c 	lds	rBin1L, Xposition				; Show_BigDigit
0004e6 9240 0065 	sts	VarByteOne, rBin1L				; Show_BigDigit
0004e8 9040 006b 	lds	rBin1L, Yposition				; Show_BigDigit
0004ea 9240 0066 	sts	VarByteTwo, rBin1L				; Show_BigDigit
0004ec dcd0      	rcall	LCD_gotoXY 	; VarByteOne{x},VarByteTwo{y}	; Show_BigDigit
                 								; Show_BigDigit
0004ed e0f6      	ldi	ZH, high (BigDigits << 1)			; Show_BigDigit
0004ee eee4      	ldi	ZL, low  (BigDigits << 1)			; Show_BigDigit
0004ef 0fe0      	add	ZL, temp					; Show_BigDigit
0004f0 1ff1      	adc	ZH, temp2					; Show_BigDigit
                 ;---------------------------					; Show_BigDigit
                 ; write row one of three for 12-bytes of digit's bitmap data	; Show_BigDigit
0004f1 e01c      	ldi	temp2, BIGCHARWIDTH				; Show_BigDigit
0004f2 e001      	ldi	temp, LCD_D 					; Show_BigDigit
0004f3 9300 0065 	sts	VarByteOne, temp				; Show_BigDigit
0004f5 9105      sbd1:	lpm	temp, z+					; Show_BigDigit
0004f6 9300 0066 	sts	VarByteTwo, temp				; Show_BigDigit
0004f8 dca7      	rcall	LCD_write					; Show_BigDigit
0004f9 951a      	dec	temp2						; Show_BigDigit
0004fa f7d1      	brne	sbd1						; Show_BigDigit
0004fb 9100 006c  	lds	temp, Xposition					; Show_BigDigit
0004fd 9300 0065 	sts	VarByteOne, temp				; Show_BigDigit
0004ff 9100 006b 	lds	temp, Yposition 	       			; Show_BigDigit
000501 5f0f      	subi	temp, - 1	; add 1 by subtracting -1	; Show_BigDigit
000502 9300 0066 	sts	VarByteTwo, temp				; Show_BigDigit
000504 dcb8      	rcall	LCD_gotoXY 	 				; Show_BigDigit
                 ;---------------------------					; Show_BigDigit
                 ; write row two of three for 12-bytes of digit's bitmapped data	; Show_BigDigit
000505 e01c      	ldi	temp2, BIGCHARWIDTH	;12			; Show_BigDigit
000506 e001      	ldi	temp, LCD_D 			      		; Show_BigDigit
000507 9300 0065 	sts	VarByteOne, temp				; Show_BigDigit
000509 9105      sbd2:	lpm	temp, z+ ; z already points at correct data	; Show_BigDigit
00050a 9300 0066 	sts	VarByteTwo, temp				; Show_BigDigit
00050c dc93      	rcall	LCD_write					; Show_BigDigit
00050d 951a      	dec	temp2						; Show_BigDigit
00050e f7d1      	brne	sbd2						; Show_BigDigit
00050f 9100 006c  	lds	temp, Xposition					; Show_BigDigit
000511 9300 0065 	sts	VarByteOne, temp				; Show_BigDigit
000513 9100 006b 	lds	temp, Yposition  				; Show_BigDigit
000515 5f0e      	subi	temp, - 2 	; add 2 by subtracting -2	; Show_BigDigit
000516 9300 0066 	sts	VarByteTwo, temp				; Show_BigDigit
000518 dca4      	rcall	LCD_gotoXY 					; Show_BigDigit
                 ;---------------------------					; Show_BigDigit
                 ; write row three of three for 12-bytes of digit's bitmap data	; Show_BigDigit
000519 e01c      	ldi	temp2, BIGCHARWIDTH	;12			; Show_BigDigit
00051a e001      	ldi	temp, LCD_D 					; Show_BigDigit
00051b 9300 0065 	sts	VarByteOne, temp				; Show_BigDigit
00051d 9105      sbd3:	lpm	temp, z+					; Show_BigDigit
00051e 9300 0066 	sts	VarByteTwo, temp				; Show_BigDigit
000520 dc7f      	rcall	LCD_write					; Show_BigDigit
000521 951a      	dec	temp2						; Show_BigDigit
000522 f7d1      	brne	sbd3						; Show_BigDigit
                 								; Show_BigDigit
000523 e001      	ldi	temp, LCD_D 					; Show_BigDigit
000524 9300 0065 	sts	VarByteOne, temp				; Show_BigDigit
000526 e000      	ldi	temp, 0						; Show_BigDigit
000527 9300 0066 	sts	VarByteTwo, temp				; Show_BigDigit
000529 dc76      	rcall	LCD_write	; empty column			; Show_BigDigit
                 								; Show_BigDigit
                    								; Show_BigDigit
00052a 91ef      	pop	ZL						; Show_BigDigit
00052b 91ff      	pop	ZH						; Show_BigDigit
00052c 903f      	pop	Lowtemp1					; Show_BigDigit
00052d 902f      	pop	Lowtemp0					; Show_BigDigit
00052e 911f      	pop	temp2						; Show_BigDigit
00052f 910f      	pop	temp						; Show_BigDigit
000530 9508       	ret							; Show_BigDigit
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 
                 
                 ;**************************************************************** 
                 ; multiply digit value by 36 to get offset into BD table.	;
                 ;  this routine is for AVRs that don't have the MUL instruction	;
                 ;  for example, the Tiny1634					;
                 ;								;
                 ;   Each digit in the table has 36 bytes.			;
                 ;	n * 36 = (n * 32) + (n * 4)				;
                 ; send:		DataByte					;
                 ; return:	resultH:resultL		 			;
                 ;------------------------------------------------------------------------------
                 Multiply36:		 					; Multiply_36
000531 930f      	push	temp		 				; Multiply_36
000532 931f      	push	temp2		 				; Multiply_36
000533 924f      	push	rBin1L	 	 				; Multiply_36
000534 925f      	push	rBin1H	 	 				; Multiply_36
                 ;					 			; Multiply_36
000535 9100 006a 	lds	temp, DataByte		 			; Multiply_36
000537 2711      	clr	temp2					 	; Multiply_36
000538 0f00
000539 1f11       	lsl	temp    rol temp2       ; * 2		 	; Multiply_36
00053a 0f00
00053b 1f11      	lsl	temp    rol temp2       ; * 4		 	; Multiply_36
00053c 2e40      	mov	rBin1L, temp 		; save *4 high:low	; Multiply_36
00053d 2e51      	mov	rBin1H, temp2					; Multiply_36
00053e 0f00
00053f 1f11       	lsl	temp    rol temp2       ; * 8		 	; Multiply_36
000540 0f00
000541 1f11      	lsl	temp    rol temp2       ; * 16		 	; Multiply_36
000542 0f00
000543 1f11      	lsl	temp    rol temp2       ; * 32		 	; Multiply_36
000544 0d04      	add	temp,   rBin1L					; Multiply_36
000545 1d15      	adc	temp2,  rBin1H		; add *4 to *32		; Multiply_36
000546 9300 008a 	sts	resultL, temp		 			; Multiply_36
000548 9310 008b 	sts	resultH, temp2		 			; Multiply_36
                 					 			; Multiply_36
00054a 905f      	pop	rBin1H	 	 				; Multiply_36
00054b 904f      	pop	rBin1L	 	 				; Multiply_36
00054c 911f      	pop	temp2	 		 			; Multiply_36
00054d 910f      	pop	temp			 			; Multiply_36
00054e 9508      	ret							; Multiply_36
                 					 			; Multiply_36
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 
                 
                 
                 ;****************************************************************************************
                 ; Display_ArbLenStr  - select a message string from a set of multiple
                 ; 	 output strings of different lengths using an address table.
                 ;	 Display string at current Nokia 5110 X,Y position (upper-left of first char)
                 ;
                 ; initialize:  rcall LCD_gotoXY  VB1=X: VB2=Y position of Nokia 5110 cursor
                 ; send:   temp with the number of the message string to be output
                 ; return: -
                 ; uses:   ZH:ZL, temp, UART peripheral
                 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 DisplayArbLenStr:
00054f 931f      	push	temp2
000550 93ff      	push	ZH
000551 93ef      	push	ZL
                 
000552 e3e4      	ldi	ZL, low  (M_StrList << 1)
000553 e0fb      	ldi	ZH, high (M_StrList << 1)
000554 0f00      	lsl	temp ; multiply by 2
000555 0fe0      	add	ZL,temp
000556 1dff      	adc	ZH, zeroreg
000557 9105      	lpm	temp,  Z+ ; move to low addr byte after load
000558 9114      	lpm	temp2, Z
000559 2ff0      	mov	ZH, temp
00055a 2fe1      	mov	ZL, temp2
                 DALSlp:
00055b 9105       	lpm	temp, Z+
00055c 2300       	tst	temp
00055d f021       	breq	DM_exit
00055e 9300 0065 	sts	VarByteOne, temp
000560 dbf9      	rcall	LCD_character
000561 cff9      	rjmp	DALSlp
                 
                 DM_exit:
000562 91ef      	pop	ZL
000563 91ff      	pop	ZH
000564 911f      	pop	temp2
000565 9508      	ret
                 
                 
                 ;         01234567
000566 614a
000567 756e
000568 7261
000569 2079
00056a 0000      m1  : .db "January ",0,0
00056b 6546
00056c 7262
00056d 6175
00056e 7972
00056f 0020      m2  : .db "February ",0
000570 614d
000571 6372
000572 2068
000573 0000      m3  : .db "March ",0 ,0
000574 7041
000575 6972
000576 206c
000577 0000      m4  : .db "April ",0,0
000578 614d
000579 2079
00057a 0000      m5  : .db "May ",0,0
00057b 754a
00057c 656e
00057d 0020      m6  : .db "June ",0
00057e 754a
00057f 796c
000580 0020      m7  : .db "July ",0
000581 7541
000582 7567
000583 7473
000584 0020      m8  : .db "August ",0
000585 6553
000586 7470
000587 6d65
000588 6562
000589 2072
00058a 0000      m9  : .db "September ",0,0
00058b 634f
00058c 6f74
00058d 6562
00058e 2072
00058f 0000      m10 : .db "October ",0,0
000590 6f4e
000591 6576
000592 626d
000593 7265
000594 0020      m11 : .db "November ",0
000595 6544
000596 6563
000597 626d
000598 7265
000599 0020      m12 : .db "December ",0
                 
                 ;; data below used for debugging
                 ;m13 : .db "month 13 ",0
                 ;m14 : .db "month 14 ",0
                 ;m15 : .db "month 15 ",0
                 ;m16 : .db "month 16 ",0
                 ;m17 : .db "month 17 ",0
                 ;m18 : .db "month 18 ",0
                 ;m19 : .db "month 19 ",0
                 ;m20 : .db "month 20 ",0
                 ;m21 : .db "month 21 ",0
                 ;m22 : .db "month 22 ",0
                 ;m23 : .db "month 23 ",0
                 ;m24 : .db "month 24 ",0
                 ;m25 : .db "month 25 ",0
                 ;m26 : .db "month 26 ",0
                 ;m27 : .db "month 27 ",0
                 ;m28 : .db "month 28 ",0
                 ;m29 : .db "month 29 ",0
                 ;m30 : .db "month 30 ",0
                 ;m31 : .db "month 31 ",0
                 ;m32 : .db "month 32 ",0
                 ;m33 : .db "month 33 ",0
                 ;m34 : .db "month 34 ",0
                 ;m35 : .db "month 35 ",0
                 ;m36 : .db "month 36 ",0
                 
                 M_StrList:
00059a cc0a      .db high  (M1 << 1), low  (M1 << 1)
00059b d60a      .db high  (M2 << 1), low  (M2 << 1)
00059c e00a      .db high  (M3 << 1), low  (M3 << 1)
00059d e80a      .db high  (M4 << 1), low  (M4 << 1)
00059e f00a      .db high  (M5 << 1), low  (M5 << 1)
00059f f60a      .db high  (M6 << 1), low  (M6 << 1)
0005a0 fc0a      .db high  (M7 << 1), low  (M7 << 1)
0005a1 020b      .db high  (M8 << 1), low  (M8 << 1)
0005a2 0a0b      .db high  (M9 << 1), low  (M9 << 1)
0005a3 160b      .db high (M10 << 1), low (M10 << 1)
0005a4 200b      .db high (M11 << 1), low (M11 << 1)
0005a5 2a0b      .db high (M12 << 1), low (M12 << 1)
                 
                 ;; data below used for debugging
                 ;.db high (M13 << 1), low (M13 << 1)
                 ;.db high (M14 << 1), low (M14 << 1)
                 ;.db high (M15 << 1), low (M15 << 1)
                 ;.db high (M16 << 1), low (M16 << 1)
                 ;.db high (M17 << 1), low (M17 << 1)
                 ;.db high (M18 << 1), low (M18 << 1)
                 ;.db high (M19 << 1), low (M19 << 1)
                 ;.db high (M20 << 1), low (M20 << 1)
                 ;.db high (M21 << 1), low (M21 << 1)
                 ;.db high (M22 << 1), low (M22 << 1)
                 ;.db high (M23 << 1), low (M23 << 1)
                 ;.db high (M24 << 1), low (M24 << 1)
                 ;.db high (M25 << 1), low (M25 << 1)
                 ;.db high (M26 << 1), low (M26 << 1)
                 ;.db high (M27 << 1), low (M27 << 1)
                 ;.db high (M28 << 1), low (M28 << 1)
                 ;.db high (M29 << 1), low (M29 << 1)
                 ;.db high (M30 << 1), low (M30 << 1)
                 ;.db high (M31 << 1), low (M31 << 1)
                 ;.db high (M32 << 1), low (M32 << 1)
                 ;.db high (M33 << 1), low (M33 << 1)
                 ;.db high (M34 << 1), low (M34 << 1)
                 ;.db high (M35 << 1), low (M35 << 1)
                 ;.db high (M36 << 1), low (M36 << 1)
                 
                 
0005a6 2020
0005a7 2020
0005a8 2020
0005a9 2020
0005aa 2020
0005ab 2020
0005ac 2020
0005ad 4442
0005ae 635f
0005af 6f6c
0005b0 6b63
0005b1 612e
0005b2 6d73
0005b3 2020
0005b4 3176
0005b5 302e
0005b6 6120
0005b7 616c
0005b8 5f6e
0005b9 7270
0005ba 626f
0005bb 6e61
0005bc 7464
0005bd 7940
0005be 6861
0005bf 6f6f
0005c0 632e
0005c1 6d6f      inline_ID: .db "              BD_clock.asm  v1.0 alan_probandt@yahoo.com"
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega8 register use summary:
r0 :   1 r1 :   1 r2 :   6 r3 :   6 r4 :  13 r5 :   8 r6 :  10 r7 :   6 
r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 r13:   0 r14:   2 r15:  13 
r16: 358 r17:  57 r18:  16 r19:  18 r20:   0 r21:   0 r22:   0 r23:   0 
r24:   0 r25:   0 r26:   0 r27:   0 r28:   2 r29:   2 r30:  46 r31:  45 
x  :   0 y  :   0 z  :  30 
Registers used: 19 out of 35 (54.3%)

ATmega8 instruction use summary:
adc   :   7 add   :   8 adiw  :   0 and   :   0 andi  :  13 asr   :   0 
bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 brcc  :   1 brcs  :   2 
breq  :   7 brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 brie  :   0 
brlo  :   0 brlt  :   0 brmi  :   0 brne  :  17 brpl  :   1 brsh  :   0 
brtc  :   0 brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 bst   :   0 
cbi   :   5 cbr   :   2 clc   :   0 clh   :   0 cli   :   0 cln   :   0 
clr   :   8 cls   :   0 clt   :   0 clv   :   0 clz   :   0 com   :   0 
cp    :   3 cpc   :   0 cpi   :   2 cpse  :   1 dec   :  14 eor   :   0 
fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :   5 
inc   :   5 ld    :  12 ldd   :   0 ldi   : 139 lds   :  34 lpm   :  12 
lsl   :   9 lsr   :   0 mov   :  16 movw  :   0 mul   :   1 muls  :   0 
mulsu :   0 neg   :   0 nop   :   0 or    :   2 ori   :   6 out   :  33 
pop   :  50 push  :  50 rcall :  59 ret   :  21 reti  :   1 rjmp  :  33 
rol   :   7 ror   :   0 sbc   :   1 sbci  :   0 sbi   :   8 sbic  :   0 
sbis  :   0 sbiw  :   2 sbr   :   1 sbrc  :   0 sbrs  :   4 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   6 std   :   0 
sts   : 100 sub   :   1 subi  :   4 swap  :   5 tst   :   7 wdr   :   0 

Instructions used: 46 out of 108 (42.6%)

ATmega8 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000b84   1720   1224   2944    8192  35.9%
[.dseg] 0x000060 0x000110      0    176    176    1024  17.2%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
