
touchscreen.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000008  00800100  00001186  0000121a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001186  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000002  00800108  00800108  00001222  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  00001222  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000001e4  00000000  00000000  00001262  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000fe7  00000000  00000000  00001446  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000044d  00000000  00000000  0000242d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000a39  00000000  00000000  0000287a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001b0  00000000  00000000  000032b4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000002b3  00000000  00000000  00003464  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000c81  00000000  00000000  00003717  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000a8  00000000  00000000  00004398  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 e6 03 	jmp	0x7cc	; 0x7cc <__ctors_end>
       4:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
       8:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
       c:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      10:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      14:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      18:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      1c:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      20:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      24:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      28:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      2c:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      30:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      34:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      38:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      3c:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      40:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      44:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      48:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      4c:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      50:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      54:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      58:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      5c:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      60:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      64:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      68:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      6c:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      70:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      74:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      78:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      7c:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      80:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      84:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>
      88:	0c 94 06 04 	jmp	0x80c	; 0x80c <__bad_interrupt>

0000008c <hello>:
      8c:	20 c7 c0 cf d3 d1 ca 20 cf d0 ce d8 c5 cb 20 21      ...... ...... !
      9c:	21 21 20 00                                         !! .

000000a0 <mounting_FAT>:
      a0:	6d 6f 75 6e 74 69 6e 67 20 46 41 54 2d 00           mounting FAT-.

000000ae <move_to_DIR_SKINS>:
      ae:	6d 6f 76 65 20 74 6f 20 44 49 52 20 53 4b 49 4e     move to DIR SKIN
      be:	53 2d 20 00                                         S- .

000000c2 <s_hex>:
      c2:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF

000000d2 <s_palitra8bit>:
      d2:	00 80 14 90 02 82 11 da ba bb 44 64 84 a4 c4 e4     ..........Dd....
      e2:	08 28 48 68 88 a8 c8 e8 0c 2c 4c 6c 8c ac cc ec     .(Hh.....,Ll....
      f2:	10 30 50 70 90 b0 d0 f0 14 34 54 74 94 b4 d4 f4     .0Pp.....4Tt....
     102:	18 38 58 78 98 b8 d8 f8 1c 3c 5c 7c 9c bc dc fc     .8Xx.....<\|....
     112:	01 21 41 61 81 a1 c1 e1 05 25 45 65 85 a5 c5 e5     .!Aa.....%Ee....
     122:	09 29 49 69 89 a9 c9 e9 0d 2d 4d 6d 8d ad cd ed     .)Ii.....-Mm....
     132:	11 31 51 71 91 b1 d1 f1 15 35 55 75 95 b5 d5 f5     .1Qq.....5Uu....
     142:	19 39 59 79 99 b9 d9 f9 1d 3d 5d 7d 9d bd dd fd     .9Yy.....=]}....
     152:	02 22 42 62 82 a2 c2 e2 06 26 46 66 86 a6 c6 e6     ."Bb.....&Ff....
     162:	0a 2a 4a 6a 8a aa ca ea 0e 2e 4e 6e 8e ae ce ee     .*Jj......Nn....
     172:	12 32 52 72 92 b2 d2 f2 16 36 56 76 96 b6 d6 f6     .2Rr.....6Vv....
     182:	1a 3a 5a 7a 9a ba da fa 1e 3e 5e 7e 9e be de fe     .:Zz.....>^~....
     192:	03 23 43 63 83 a3 c3 e3 07 27 47 67 87 a7 c7 e7     .#Cc.....'Gg....
     1a2:	0b 2b 4b 6b 8b ab cb eb 0f 2f 4f 6f 8f af cf ef     .+Kk...../Oo....
     1b2:	13 33 53 73 93 b3 d3 f3 17 37 57 77 97 b7 d7 f7     .3Ss.....7Ww....
     1c2:	1b 3b 5b 7b 9b bb ff b6 91 e0 1c fc 03 e3 1f ff     .;[{............

000001d2 <s_apxFont6x8>:
     1d2:	00 00 00 00 00 00 3e 0a 34 00 3e 0c 18 3e 00 3e     ......>.4.>..>.>
     1e2:	22 1c 00 3e 20 20 00 3e 22 1c 00 24 2a 12 00 08     "..>  .>"..$*...
     1f2:	38 38 08 08 1c 22 22 22 1c 00 00 38 38 44 82 fe     88..."""...88D..
     202:	00 1c 3e 62 62 32 3a 2e 26 23 23 3e 00 00 00 00     ..>bb2:.&##>....
     212:	00 00 00 1c 3e 36 22 36 3e 3e 36 36 36 3e 00 00     ....>6"6>>666>..
     222:	00 00 00 00 63 55 4d 55 6b 18 18 08 1c 22 22 1c     ....cUMUk...."".
     232:	00 3e 0a 04 78 40 00 3e 0a 04 78 40 00 38 44 5f     .>..x@.>..x@.8D_
     242:	4e 44 00 38 44 44 5f 4e 00 3c 3c 3c 3c 00 00 3e     ND.8DD_N.<<<<..>
     252:	0a 04 78 40 00 3e 0a 04 78 40 44 40 38 00 04 7e     ..x@.>..x@D@8..~
     262:	00 7f 3e 1c 08 00 08 08 2a 1c 08 00 08 1c 2a 08     ..>.....*.....*.
     272:	08 00 08 08 2a 08 08 00 00 3c 20 00 00 00 08 14     ....*....< .....
     282:	00 14 08 00 08 0c 0e 0c 08 00 08 18 38 18 08 00     ............8...
	...
     29a:	5f 00 00 00 00 07 00 07 00 00 14 7f 14 7f 14 00     _...............
     2aa:	24 2a 7f 2a 12 00 23 13 08 64 62 00 36 49 55 22     $*.*..#..db.6IU"
     2ba:	50 00 00 05 03 00 00 00 00 1c 22 41 00 00 00 41     P........."A...A
     2ca:	22 1c 00 00 14 08 3e 08 14 00 08 08 3e 08 08 00     ".....>.....>...
     2da:	00 50 30 00 00 00 08 08 08 08 08 00 00 60 60 00     .P0..........``.
     2ea:	00 00 20 10 08 04 02 00 3e 51 49 45 3e 00 00 42     .. .....>QIE>..B
     2fa:	7f 40 00 00 42 61 51 49 46 00 21 41 45 4b 31 00     .@..BaQIF.!AEK1.
     30a:	18 14 12 7f 10 00 27 45 45 45 39 00 3c 4a 49 49     ......'EEE9.<JII
     31a:	30 00 01 71 09 05 03 00 36 49 49 49 36 00 06 49     0..q....6III6..I
     32a:	49 29 1e 00 00 36 36 00 00 00 00 56 36 00 00 00     I)...66....V6...
     33a:	08 14 22 41 00 00 14 14 14 14 14 00 00 41 22 14     .."A.........A".
     34a:	08 00 02 01 51 09 06 00 32 49 79 41 3e 00 7e 11     ....Q...2IyA>.~.
     35a:	11 11 7e 00 7f 49 49 49 36 00 3e 41 41 41 22 00     ..~..III6.>AAA".
     36a:	7f 41 41 22 1c 00 7f 49 49 49 41 00 7f 09 09 09     .AA"...IIIA.....
     37a:	01 00 3e 41 49 49 7a 00 7f 08 08 08 7f 00 00 41     ..>AIIz........A
     38a:	7f 41 00 00 20 40 41 3f 01 00 7f 08 14 22 41 00     .A.. @A?....."A.
     39a:	7f 40 40 40 40 00 7f 02 0c 02 7f 00 7f 04 08 10     .@@@@...........
     3aa:	7f 00 3e 41 41 41 3e 00 7f 09 09 09 06 00 3e 41     ..>AAA>.......>A
     3ba:	51 21 5e 00 7f 09 19 29 46 00 46 49 49 49 31 00     Q!^....)F.FIII1.
     3ca:	01 01 7f 01 01 00 3f 40 40 40 3f 00 1f 20 40 20     ......?@@@?.. @ 
     3da:	1f 00 3f 40 38 40 3f 00 63 14 08 14 63 00 07 08     ..?@8@?.c...c...
     3ea:	70 08 07 00 61 51 49 45 43 00 00 7f 41 41 00 00     p...aQIEC...AA..
     3fa:	02 04 08 10 20 00 00 41 41 7f 00 00 04 02 01 02     .... ..AA.......
     40a:	04 00 40 40 40 40 40 00 00 01 02 04 00 00 20 54     ..@@@@@....... T
     41a:	54 54 78 00 7f 48 44 44 38 00 38 44 44 44 20 00     TTx..HDD8.8DDD .
     42a:	38 44 44 48 7f 00 38 54 54 54 18 00 08 7e 09 01     8DDH..8TTT...~..
     43a:	02 00 0c 52 52 52 3e 00 7f 08 04 04 78 00 00 44     ...RRR>.....x..D
     44a:	7d 40 00 00 20 40 44 3d 00 00 7f 10 28 44 00 00     }@.. @D=....(D..
     45a:	00 41 7f 40 00 00 7c 04 18 04 78 00 7c 08 04 04     .A.@..|...x.|...
     46a:	78 00 38 44 44 44 38 00 7c 14 14 14 08 00 08 14     x.8DDD8.|.......
     47a:	14 18 7c 00 7c 08 04 04 08 00 48 54 54 54 20 00     ..|.|.....HTTT .
     48a:	04 3f 44 40 20 00 3c 40 40 20 7c 00 1c 20 40 20     .?D@ .<@@ |.. @ 
     49a:	1c 00 3c 40 30 40 3c 00 44 28 10 28 44 00 0c 50     ..<@0@<.D(.(D..P
     4aa:	50 50 3c 00 44 64 54 4c 44 00 00 08 36 41 00 00     PP<.DdTLD...6A..
     4ba:	00 00 7f 00 00 00 00 41 36 08 00 00 10 08 08 10     .......A6.......
     4ca:	08 00 78 46 41 46 78 00 78 14 12 11 7f 00 7f 45     ..xFAFx.x......E
     4da:	45 45 38 00 7f 49 49 49 36 00 7f 01 01 01 01 00     EE8..III6.......
     4ea:	70 1f 11 1f 70 00 7f 49 49 49 41 00 77 08 7f 08     p...p..IIIA.w...
     4fa:	77 00 22 41 49 49 36 00 7f 10 08 04 7f 00 7f 10     w."AII6.........
     50a:	09 04 7f 00 7f 08 14 22 41 00 40 3e 01 01 7f 00     ......."A.@>....
     51a:	7f 02 0c 02 7f 00 7f 08 08 08 7f 00 3e 41 41 41     ............>AAA
     52a:	3e 00 7f 01 01 01 7f 00 7f 11 11 11 0e 00 3e 41     >.............>A
     53a:	41 41 22 00 01 01 7f 01 01 00 07 48 48 48 3f 00     AA"........HHH?.
     54a:	1c 22 7f 22 1c 00 63 14 08 14 63 00 3f 20 20 20     ."."..c...c.?   
     55a:	7f 00 07 08 08 08 7f 00 7f 40 7f 40 7f 00 3f 20     .........@.@..? 
     56a:	3f 20 7f 00 01 7f 48 48 30 00 7f 48 30 00 7f 00     ? ....HH0..H0...
     57a:	7f 48 30 00 00 00 22 49 49 49 3e 00 7f 08 3e 41     .H0..."III>...>A
     58a:	3e 00 66 19 09 09 7f 00 20 54 54 54 78 00 28 54     >.f..... TTTx.(T
     59a:	54 54 24 00 38 54 54 58 20 00 24 54 54 54 48 00     TT$.8TTX .$TTTH.
     5aa:	18 a4 a4 a4 78 00 38 54 54 54 08 00 44 28 7c 28     ....x.8TTT..D(|(
     5ba:	44 00 28 44 54 54 28 00 3c 40 40 40 7c 00 3c 40     D.(DTT(.<@@@|.<@
     5ca:	44 42 7c 00 7c 10 10 28 44 00 40 20 18 04 7c 00     DB|.|..(D.@ ..|.
     5da:	7c 08 30 08 7c 00 7c 10 10 10 7c 00 38 44 44 44     |.0.|.|...|.8DDD
     5ea:	38 00 7c 04 04 04 78 00 fc 24 24 24 18 00 38 44     8.|...x..$$$..8D
     5fa:	44 44 28 00 7c 04 78 04 78 00 4c 90 90 90 7c 00     DD(.|.x.x.L...|.
     60a:	10 28 7c 28 10 00 44 28 10 28 44 00 3c 40 40 40     .(|(..D(.(D.<@@@
     61a:	7c 80 1c 20 20 20 7c 00 7c 40 7c 40 7c 00 7c 40     |..   |.|@|@|.|@
     62a:	7c 40 fc 00 04 7c 50 20 00 00 7c 50 20 00 7c 00     |@...|P ..|P .|.
     63a:	7c 50 20 00 00 00 44 54 54 54 38 00 7c 10 38 44     |P ...DTTT8.|.8D
     64a:	38 00 58 24 24 24 7c 00 00 00 00 00 00 00 00 00     8.X$$$|.........
	...

000007cc <__ctors_end>:
     7cc:	11 24       	eor	r1, r1
     7ce:	1f be       	out	0x3f, r1	; 63
     7d0:	cf ef       	ldi	r28, 0xFF	; 255
     7d2:	d0 e1       	ldi	r29, 0x10	; 16
     7d4:	de bf       	out	0x3e, r29	; 62
     7d6:	cd bf       	out	0x3d, r28	; 61

000007d8 <__do_copy_data>:
     7d8:	11 e0       	ldi	r17, 0x01	; 1
     7da:	a0 e0       	ldi	r26, 0x00	; 0
     7dc:	b1 e0       	ldi	r27, 0x01	; 1
     7de:	e6 e8       	ldi	r30, 0x86	; 134
     7e0:	f1 e1       	ldi	r31, 0x11	; 17
     7e2:	00 e0       	ldi	r16, 0x00	; 0
     7e4:	0b bf       	out	0x3b, r16	; 59
     7e6:	02 c0       	rjmp	.+4      	; 0x7ec <__do_copy_data+0x14>
     7e8:	07 90       	elpm	r0, Z+
     7ea:	0d 92       	st	X+, r0
     7ec:	a8 30       	cpi	r26, 0x08	; 8
     7ee:	b1 07       	cpc	r27, r17
     7f0:	d9 f7       	brne	.-10     	; 0x7e8 <__do_copy_data+0x10>
     7f2:	1b be       	out	0x3b, r1	; 59

000007f4 <__do_clear_bss>:
     7f4:	11 e0       	ldi	r17, 0x01	; 1
     7f6:	a8 e0       	ldi	r26, 0x08	; 8
     7f8:	b1 e0       	ldi	r27, 0x01	; 1
     7fa:	01 c0       	rjmp	.+2      	; 0x7fe <.do_clear_bss_start>

000007fc <.do_clear_bss_loop>:
     7fc:	1d 92       	st	X+, r1

000007fe <.do_clear_bss_start>:
     7fe:	aa 30       	cpi	r26, 0x0A	; 10
     800:	b1 07       	cpc	r27, r17
     802:	e1 f7       	brne	.-8      	; 0x7fc <.do_clear_bss_loop>
     804:	0e 94 47 07 	call	0xe8e	; 0xe8e <main>
     808:	0c 94 c1 08 	jmp	0x1182	; 0x1182 <_exit>

0000080c <__bad_interrupt>:
     80c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000810 <send_byte_>:
	send_byte_(data);

}

/////////////////////////////////////////////
void send_byte_(uint8_t data){
     810:	90 e0       	ldi	r25, 0x00	; 0
 byte i;

 for (i=0;i<8;i++)
  {
   CLK0
     812:	da 98       	cbi	0x1b, 2	; 27
   if  ((data&128)!=0) SDA1
     814:	87 ff       	sbrs	r24, 7
     816:	02 c0       	rjmp	.+4      	; 0x81c <send_byte_+0xc>
     818:	d9 9a       	sbi	0x1b, 1	; 27
     81a:	01 c0       	rjmp	.+2      	; 0x81e <send_byte_+0xe>
               else SDA0
     81c:	d9 98       	cbi	0x1b, 1	; 27
   data=data<<1; 
   CLK1 
     81e:	da 9a       	sbi	0x1b, 2	; 27

/////////////////////////////////////////////
void send_byte_(uint8_t data){
 byte i;

 for (i=0;i<8;i++)
     820:	9f 5f       	subi	r25, 0xFF	; 255
     822:	98 30       	cpi	r25, 0x08	; 8
     824:	11 f0       	breq	.+4      	; 0x82a <send_byte_+0x1a>
  {
   CLK0
   if  ((data&128)!=0) SDA1
               else SDA0
   data=data<<1; 
     826:	88 0f       	add	r24, r24
     828:	f4 cf       	rjmp	.-24     	; 0x812 <send_byte_+0x2>
     82a:	08 95       	ret

0000082c <send_data>:
}
/////////////////////////////////////////////

void send_data(uint8_t data) {

	CLK0
     82c:	da 98       	cbi	0x1b, 2	; 27
	SDA1
     82e:	d9 9a       	sbi	0x1b, 1	; 27
	CLK1
     830:	da 9a       	sbi	0x1b, 2	; 27

	send_byte_(data);
     832:	0e 94 08 04 	call	0x810	; 0x810 <send_byte_>

}
     836:	08 95       	ret

00000838 <send_cmd>:
//////////////////////////////////////////////////////////
//////////         Send_Byte/Cmd                //////////
//////////////////////////////////////////////////////////
void send_cmd(uint8_t data) {

	CLK0
     838:	da 98       	cbi	0x1b, 2	; 27
	SDA0
     83a:	d9 98       	cbi	0x1b, 1	; 27
	CLK1
     83c:	da 9a       	sbi	0x1b, 2	; 27
	send_byte_(data);
     83e:	0e 94 08 04 	call	0x810	; 0x810 <send_byte_>

}
     842:	08 95       	ret

00000844 <init_lcd>:
}
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////

void init_lcd(void) {
	SPIDDR=(1<<SDA)|(1<<CLK)|(1<<CS)|(1<<RESET); //Port-Direction Setup
     844:	8f e0       	ldi	r24, 0x0F	; 15
     846:	8a bb       	out	0x1a, r24	; 26


  // reset the display
  DDRA |= (1 << RST_BIT);
     848:	d0 9a       	sbi	0x1a, 0	; 26
  PORTA &= ~(1 << RST_BIT);
     84a:	d8 98       	cbi	0x1b, 0	; 27
     84c:	80 e0       	ldi	r24, 0x00	; 0
     84e:	90 e0       	ldi	r25, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     850:	26 e6       	ldi	r18, 0x66	; 102
     852:	3e e0       	ldi	r19, 0x0E	; 14
     854:	f9 01       	movw	r30, r18
     856:	31 97       	sbiw	r30, 0x01	; 1
     858:	f1 f7       	brne	.-4      	; 0x856 <init_lcd+0x12>


///////////////////////////////////
void waitms(int ms) {
  int i;
  for (i=0;i<ms;i++) _delay_ms(1);
     85a:	01 96       	adiw	r24, 0x01	; 1
     85c:	84 36       	cpi	r24, 0x64	; 100
     85e:	91 05       	cpc	r25, r1
     860:	c9 f7       	brne	.-14     	; 0x854 <init_lcd+0x10>
 waitms(100);
  PORTA |= (1 << RST_BIT);
     862:	d8 9a       	sbi	0x1b, 0	; 27
     864:	80 e0       	ldi	r24, 0x00	; 0
     866:	90 e0       	ldi	r25, 0x00	; 0
     868:	26 e6       	ldi	r18, 0x66	; 102
     86a:	3e e0       	ldi	r19, 0x0E	; 14
     86c:	f9 01       	movw	r30, r18
     86e:	31 97       	sbiw	r30, 0x01	; 1
     870:	f1 f7       	brne	.-4      	; 0x86e <init_lcd+0x2a>
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	84 36       	cpi	r24, 0x64	; 100
     876:	91 05       	cpc	r25, r1
     878:	c9 f7       	brne	.-14     	; 0x86c <init_lcd+0x28>
  waitms(100);


	send_cmd (0x01);  //Software Reset
     87a:	81 e0       	ldi	r24, 0x01	; 1
     87c:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
	send_cmd(0x11);  //Sleep Out
     880:	81 e1       	ldi	r24, 0x11	; 17
     882:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
 	send_cmd(0x03);  //Booster ON
     886:	83 e0       	ldi	r24, 0x03	; 3
     888:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
     88c:	80 e0       	ldi	r24, 0x00	; 0
     88e:	90 e0       	ldi	r25, 0x00	; 0
     890:	26 e6       	ldi	r18, 0x66	; 102
     892:	3e e0       	ldi	r19, 0x0E	; 14
     894:	f9 01       	movw	r30, r18
     896:	31 97       	sbiw	r30, 0x01	; 1
     898:	f1 f7       	brne	.-4      	; 0x896 <init_lcd+0x52>
     89a:	01 96       	adiw	r24, 0x01	; 1
     89c:	8a 30       	cpi	r24, 0x0A	; 10
     89e:	91 05       	cpc	r25, r1
     8a0:	c9 f7       	brne	.-14     	; 0x894 <init_lcd+0x50>
	waitms(10);
  send_cmd(0x29);  //Display On
     8a2:	89 e2       	ldi	r24, 0x29	; 41
     8a4:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
  send_cmd(0x13);  //Normal display mode
     8a8:	83 e1       	ldi	r24, 0x13	; 19
     8aa:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
  send_cmd(0x21);  //Display inversion on
     8ae:	81 e2       	ldi	r24, 0x21	; 33
     8b0:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
  send_cmd(0xBA);  //Data order
     8b4:	8a eb       	ldi	r24, 0xBA	; 186
     8b6:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
  send_cmd(0x36); //Memory data access control
     8ba:	86 e3       	ldi	r24, 0x36	; 54
     8bc:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
 //send_data(8|64);   //rgb + MirrorX
 send_data(8|128);   //rgb + MirrorY
     8c0:	88 e8       	ldi	r24, 0x88	; 136
     8c2:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
//	send_data(0x08);   //rgb 

	send_cmd(0x3A); 
     8c6:	8a e3       	ldi	r24, 0x3A	; 58
     8c8:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
	send_data(2);   //8-Bit per Pixel (default)
     8cc:	82 e0       	ldi	r24, 0x02	; 2
     8ce:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  // 0x03   12-bit/pixel
  // 0x05   16-bit/pixel

 // if 256-color mode, bytes represent RRRGGGBB; the following
 //    maps to 4-bit color for each value in range (0-7 R/G, 0-3 B) 
	send_cmd(RGBSET8);	// 256-color position set
     8d2:	8d e2       	ldi	r24, 0x2D	; 45
     8d4:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
  send_data(0x00);	// 000 RED
     8d8:	80 e0       	ldi	r24, 0x00	; 0
     8da:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x02);	// 001  
     8de:	82 e0       	ldi	r24, 0x02	; 2
     8e0:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x04);	// 010
     8e4:	84 e0       	ldi	r24, 0x04	; 4
     8e6:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x06);	// 011
     8ea:	86 e0       	ldi	r24, 0x06	; 6
     8ec:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x08);	// 100
     8f0:	88 e0       	ldi	r24, 0x08	; 8
     8f2:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x0a);	// 101
     8f6:	8a e0       	ldi	r24, 0x0A	; 10
     8f8:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x0c);	// 110
     8fc:	8c e0       	ldi	r24, 0x0C	; 12
     8fe:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x0f);	// 111
     902:	8f e0       	ldi	r24, 0x0F	; 15
     904:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x00);	// 000 GREEN
     908:	80 e0       	ldi	r24, 0x00	; 0
     90a:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x02);	// 001  
     90e:	82 e0       	ldi	r24, 0x02	; 2
     910:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x04);	// 010
     914:	84 e0       	ldi	r24, 0x04	; 4
     916:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x06);	// 011
     91a:	86 e0       	ldi	r24, 0x06	; 6
     91c:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x08);	// 100
     920:	88 e0       	ldi	r24, 0x08	; 8
     922:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x0a);	// 101
     926:	8a e0       	ldi	r24, 0x0A	; 10
     928:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x0c);	// 110
     92c:	8c e0       	ldi	r24, 0x0C	; 12
     92e:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x0f);	// 111
     932:	8f e0       	ldi	r24, 0x0F	; 15
     934:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x00);	//  00 BLUE
     938:	80 e0       	ldi	r24, 0x00	; 0
     93a:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x06);	//  01
     93e:	86 e0       	ldi	r24, 0x06	; 6
     940:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x09);	//  10
     944:	89 e0       	ldi	r24, 0x09	; 9
     946:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
  send_data(  0x0f);	//  11
     94a:	8f e0       	ldi	r24, 0x0F	; 15
     94c:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>

  //Set Constrast
  //send_cmd(0x25);
  //send_data(63);

  send_cmd(0x2C);  //Memory Write
     950:	8c e2       	ldi	r24, 0x2C	; 44
     952:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
//	send_cmd (0x36);//  0x36  //;Memory data acces control
//	send_data(0x28);// 0x20-MADCTL_VERT

//	clrscr(0,0,132,132,31);

}
     956:	08 95       	ret

00000958 <window>:

/////////////////////////////////////////////


void window(uint8_t x, uint8_t y, uint8_t dx, uint8_t dy)
{
     958:	ef 92       	push	r14
     95a:	ff 92       	push	r15
     95c:	0f 93       	push	r16
     95e:	1f 93       	push	r17
     960:	18 2f       	mov	r17, r24
     962:	f6 2e       	mov	r15, r22
     964:	04 2f       	mov	r16, r20
     966:	e2 2e       	mov	r14, r18

	send_cmd (CASET);
     968:	8a e2       	ldi	r24, 0x2A	; 42
     96a:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
	send_data(x);	
     96e:	81 2f       	mov	r24, r17
     970:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
	send_data(dx);
     974:	80 2f       	mov	r24, r16
     976:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
		
	send_cmd (PASET);	
     97a:	8b e2       	ldi	r24, 0x2B	; 43
     97c:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
	send_data(y);
     980:	8f 2d       	mov	r24, r15
     982:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
	send_data(dy);
     986:	8e 2d       	mov	r24, r14
     988:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
	send_cmd (RAMWR);	
     98c:	8c e2       	ldi	r24, 0x2C	; 44
     98e:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
	
}
     992:	1f 91       	pop	r17
     994:	0f 91       	pop	r16
     996:	ff 90       	pop	r15
     998:	ef 90       	pop	r14
     99a:	08 95       	ret

0000099c <putch>:


///////////////////////////////////////////////////////////////////////
//////////////  PRINT_CHAR   //////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
uint8_t putch(uint8_t x, uint8_t y, char c, uint8_t fg, uint8_t bg) {
     99c:	9f 92       	push	r9
     99e:	af 92       	push	r10
     9a0:	bf 92       	push	r11
     9a2:	cf 92       	push	r12
     9a4:	df 92       	push	r13
     9a6:	ef 92       	push	r14
     9a8:	ff 92       	push	r15
     9aa:	0f 93       	push	r16
     9ac:	1f 93       	push	r17
     9ae:	cf 93       	push	r28
     9b0:	df 93       	push	r29
     9b2:	b8 2e       	mov	r11, r24
     9b4:	16 2f       	mov	r17, r22
     9b6:	f4 2e       	mov	r15, r20
     9b8:	92 2e       	mov	r9, r18
     9ba:	a0 2e       	mov	r10, r16

	send_cmd (0x36);//  0x36  //;Memory data acces control
     9bc:	86 e3       	ldi	r24, 0x36	; 54
     9be:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
	send_data(0x28);//MADCTL_VERT);// 0x20-MADCTL_VERT
     9c2:	88 e2       	ldi	r24, 0x28	; 40
     9c4:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>

	window(x,y,x+5,y+7);
     9c8:	4b 2d       	mov	r20, r11
     9ca:	4b 5f       	subi	r20, 0xFB	; 251
     9cc:	8b 2d       	mov	r24, r11
     9ce:	61 2f       	mov	r22, r17
     9d0:	19 5f       	subi	r17, 0xF9	; 249
     9d2:	21 2f       	mov	r18, r17
     9d4:	0e 94 ac 04 	call	0x958	; 0x958 <window>

	if(c>127) c-=0x40; // TEST For RUS char
     9d8:	f7 fe       	sbrs	r15, 7
     9da:	02 c0       	rjmp	.+4      	; 0x9e0 <putch+0x44>
     9dc:	80 ec       	ldi	r24, 0xC0	; 192
     9de:	f8 0e       	add	r15, r24
	uint8_t idx = c;
	unsigned char *p = s_apxFont6x8 + idx*6-1; // следующий байт символа
     9e0:	86 e0       	ldi	r24, 0x06	; 6
     9e2:	f8 9e       	mul	r15, r24
     9e4:	60 01       	movw	r12, r0
     9e6:	11 24       	eor	r1, r1
     9e8:	81 ed       	ldi	r24, 0xD1	; 209
     9ea:	91 e0       	ldi	r25, 0x01	; 1
     9ec:	c8 0e       	add	r12, r24
     9ee:	d9 1e       	adc	r13, r25
     9f0:	91 e0       	ldi	r25, 0x01	; 1
     9f2:	e9 2e       	mov	r14, r25
     9f4:	f1 2c       	mov	r15, r1
	int a=0;

	for(int i=0; i<6; i++) {
	p++;
	a = pgm_read_byte(p);
     9f6:	f6 01       	movw	r30, r12
     9f8:	ee 0d       	add	r30, r14
     9fa:	ff 1d       	adc	r31, r15
     9fc:	e4 91       	lpm	r30, Z+
     9fe:	0e 2f       	mov	r16, r30
     a00:	10 e0       	ldi	r17, 0x00	; 0
     a02:	c0 e0       	ldi	r28, 0x00	; 0
     a04:	d0 e0       	ldi	r29, 0x00	; 0

	uint8_t d; // - отправить на экран 1н байт из шести символа
	for(int j=0; j<8; j++) 
			{
	if((a&128)!=0) d=fg; else d=bg;
     a06:	07 fd       	sbrc	r16, 7
     a08:	02 c0       	rjmp	.+4      	; 0xa0e <putch+0x72>
     a0a:	8a 2d       	mov	r24, r10
     a0c:	01 c0       	rjmp	.+2      	; 0xa10 <putch+0x74>
     a0e:	89 2d       	mov	r24, r9
	send_data(d);
     a10:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
	for(int i=0; i<6; i++) {
	p++;
	a = pgm_read_byte(p);

	uint8_t d; // - отправить на экран 1н байт из шести символа
	for(int j=0; j<8; j++) 
     a14:	21 96       	adiw	r28, 0x01	; 1
     a16:	c8 30       	cpi	r28, 0x08	; 8
     a18:	d1 05       	cpc	r29, r1
     a1a:	19 f0       	breq	.+6      	; 0xa22 <putch+0x86>
			{
	if((a&128)!=0) d=fg; else d=bg;
	send_data(d);
	a=a<<1;
     a1c:	00 0f       	add	r16, r16
     a1e:	11 1f       	adc	r17, r17
     a20:	f2 cf       	rjmp	.-28     	; 0xa06 <putch+0x6a>
     a22:	08 94       	sec
     a24:	e1 1c       	adc	r14, r1
     a26:	f1 1c       	adc	r15, r1
	if(c>127) c-=0x40; // TEST For RUS char
	uint8_t idx = c;
	unsigned char *p = s_apxFont6x8 + idx*6-1; // следующий байт символа
	int a=0;

	for(int i=0; i<6; i++) {
     a28:	97 e0       	ldi	r25, 0x07	; 7
     a2a:	e9 16       	cp	r14, r25
     a2c:	f1 04       	cpc	r15, r1
     a2e:	19 f7       	brne	.-58     	; 0x9f6 <putch+0x5a>
	
							}

	return x+6;//update X position to next char

}
     a30:	8b 2d       	mov	r24, r11
     a32:	8a 5f       	subi	r24, 0xFA	; 250
     a34:	df 91       	pop	r29
     a36:	cf 91       	pop	r28
     a38:	1f 91       	pop	r17
     a3a:	0f 91       	pop	r16
     a3c:	ff 90       	pop	r15
     a3e:	ef 90       	pop	r14
     a40:	df 90       	pop	r13
     a42:	cf 90       	pop	r12
     a44:	bf 90       	pop	r11
     a46:	af 90       	pop	r10
     a48:	9f 90       	pop	r9
     a4a:	08 95       	ret

00000a4c <clrscr>:
/////////////////////////////////////////////////////////
///////////////    CLEAR SCREEN        //////////////////
/////////////////////////////////////////////////////////

void clrscr(uint8_t x, uint8_t y, uint8_t dx, uint8_t dy,uint8_t bg)
{
     a4c:	df 92       	push	r13
     a4e:	ef 92       	push	r14
     a50:	ff 92       	push	r15
     a52:	0f 93       	push	r16
     a54:	1f 93       	push	r17
     a56:	cf 93       	push	r28
     a58:	df 93       	push	r29
     a5a:	d8 2e       	mov	r13, r24
     a5c:	f6 2e       	mov	r15, r22
     a5e:	e4 2e       	mov	r14, r20
     a60:	12 2f       	mov	r17, r18
	window(x,y,dx,dy); // clear screen
     a62:	0e 94 ac 04 	call	0x958	; 0x958 <window>

	uint8_t ddx = dx-x+1;
	uint8_t ddy = dy-y+1;
	uint16_t a = ddx*ddy;	
     a66:	81 e0       	ldi	r24, 0x01	; 1
     a68:	98 2f       	mov	r25, r24
     a6a:	9f 19       	sub	r25, r15
     a6c:	91 0f       	add	r25, r17
     a6e:	8d 19       	sub	r24, r13
     a70:	8e 0d       	add	r24, r14
     a72:	98 9f       	mul	r25, r24
     a74:	70 01       	movw	r14, r0
     a76:	11 24       	eor	r1, r1
     a78:	c0 e0       	ldi	r28, 0x00	; 0
     a7a:	d0 e0       	ldi	r29, 0x00	; 0
     a7c:	04 c0       	rjmp	.+8      	; 0xa86 <clrscr+0x3a>
	for(uint16_t i=0; i<a; i++){
	send_data(bg);
     a7e:	80 2f       	mov	r24, r16
     a80:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
	window(x,y,dx,dy); // clear screen

	uint8_t ddx = dx-x+1;
	uint8_t ddy = dy-y+1;
	uint16_t a = ddx*ddy;	
	for(uint16_t i=0; i<a; i++){
     a84:	21 96       	adiw	r28, 0x01	; 1
     a86:	ce 15       	cp	r28, r14
     a88:	df 05       	cpc	r29, r15
     a8a:	c8 f3       	brcs	.-14     	; 0xa7e <clrscr+0x32>
	send_data(bg);
	}


}
     a8c:	df 91       	pop	r29
     a8e:	cf 91       	pop	r28
     a90:	1f 91       	pop	r17
     a92:	0f 91       	pop	r16
     a94:	ff 90       	pop	r15
     a96:	ef 90       	pop	r14
     a98:	df 90       	pop	r13
     a9a:	08 95       	ret

00000a9c <lcd_set_brightness_parms>:
//}

/////////////////////////////////////////////////////////


void lcd_set_brightness_parms(uint8_t a, uint8_t b) {
     a9c:	0f 93       	push	r16
     a9e:	1f 93       	push	r17
     aa0:	18 2f       	mov	r17, r24
     aa2:	06 2f       	mov	r16, r22
	send_cmd (VOLCTR);
     aa4:	85 e2       	ldi	r24, 0x25	; 37
     aa6:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
	send_data(a);
     aaa:	81 2f       	mov	r24, r17
     aac:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
	send_data(b);
     ab0:	80 2f       	mov	r24, r16
     ab2:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
}
     ab6:	1f 91       	pop	r17
     ab8:	0f 91       	pop	r16
     aba:	08 95       	ret

00000abc <pix_blit>:
//void setup_pix_blit(uint8_t sx, uint8_t sy, uint8_t dx, uint8_t dy) {
//  cpxSetAndValidateLCDRect(sx,sy,dx,dy);	
//}
///////////////////////////////////////////////////
void pix_blit(uint8_t color){
	send_data(color);
     abc:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
}
     ac0:	08 95       	ret

00000ac2 <putstr_ram>:

////////////////////////////////////////////////////////
uint8_t putstr_ram(uint8_t x, uint8_t y, char * p, uint8_t fg, uint8_t bg) {
     ac2:	ef 92       	push	r14
     ac4:	ff 92       	push	r15
     ac6:	0f 93       	push	r16
     ac8:	1f 93       	push	r17
     aca:	cf 93       	push	r28
     acc:	df 93       	push	r29
     ace:	e6 2e       	mov	r14, r22
     ad0:	ea 01       	movw	r28, r20
     ad2:	f2 2e       	mov	r15, r18
     ad4:	10 2f       	mov	r17, r16
     ad6:	05 c0       	rjmp	.+10     	; 0xae2 <putstr_ram+0x20>
  //void putstr_ram(uint8_t x, uint8_t y, char * p, uint8_t fg, uint8_t bg) {
  uint8_t c;
  while ((c = *p++))
    x = putch(x, y, c, fg, bg);	
     ad8:	6e 2d       	mov	r22, r14
     ada:	2f 2d       	mov	r18, r15
     adc:	01 2f       	mov	r16, r17
     ade:	0e 94 ce 04 	call	0x99c	; 0x99c <putch>

////////////////////////////////////////////////////////
uint8_t putstr_ram(uint8_t x, uint8_t y, char * p, uint8_t fg, uint8_t bg) {
  //void putstr_ram(uint8_t x, uint8_t y, char * p, uint8_t fg, uint8_t bg) {
  uint8_t c;
  while ((c = *p++))
     ae2:	49 91       	ld	r20, Y+
     ae4:	44 23       	and	r20, r20
     ae6:	c1 f7       	brne	.-16     	; 0xad8 <putstr_ram+0x16>
    x = putch(x, y, c, fg, bg);	
  return x;
}
     ae8:	df 91       	pop	r29
     aea:	cf 91       	pop	r28
     aec:	1f 91       	pop	r17
     aee:	0f 91       	pop	r16
     af0:	ff 90       	pop	r15
     af2:	ef 90       	pop	r14
     af4:	08 95       	ret

00000af6 <putstr_pgm>:




/////////////////////////////////////////////////////////////
uint8_t putstr_pgm(uint8_t x, uint8_t y, PGM_P p, uint8_t fg, uint8_t bg) {
     af6:	ef 92       	push	r14
     af8:	ff 92       	push	r15
     afa:	0f 93       	push	r16
     afc:	1f 93       	push	r17
     afe:	cf 93       	push	r28
     b00:	df 93       	push	r29
     b02:	e6 2e       	mov	r14, r22
     b04:	ea 01       	movw	r28, r20
     b06:	f2 2e       	mov	r15, r18
     b08:	10 2f       	mov	r17, r16
     b0a:	05 c0       	rjmp	.+10     	; 0xb16 <putstr_pgm+0x20>
	
  uint8_t c;
  while ((c = pgm_read_byte(p++)))
    x = putch(x, y, c, fg, bg);
     b0c:	6e 2d       	mov	r22, r14
     b0e:	2f 2d       	mov	r18, r15
     b10:	01 2f       	mov	r16, r17
     b12:	0e 94 ce 04 	call	0x99c	; 0x99c <putch>
     b16:	fe 01       	movw	r30, r28

/////////////////////////////////////////////////////////////
uint8_t putstr_pgm(uint8_t x, uint8_t y, PGM_P p, uint8_t fg, uint8_t bg) {
	
  uint8_t c;
  while ((c = pgm_read_byte(p++)))
     b18:	21 96       	adiw	r28, 0x01	; 1
     b1a:	44 91       	lpm	r20, Z+
     b1c:	44 23       	and	r20, r20
     b1e:	b1 f7       	brne	.-20     	; 0xb0c <putstr_pgm+0x16>
    x = putch(x, y, c, fg, bg);
	
  return x;
}
     b20:	df 91       	pop	r29
     b22:	cf 91       	pop	r28
     b24:	1f 91       	pop	r17
     b26:	0f 91       	pop	r16
     b28:	ff 90       	pop	r15
     b2a:	ef 90       	pop	r14
     b2c:	08 95       	ret

00000b2e <printDecimal>:
/////////////////////////////////////////////////////////////////

uint8_t printDecimal(uint8_t x, uint8_t y, uint32_t val, uint8_t fg, uint8_t bg) {
     b2e:	8f 92       	push	r8
     b30:	9f 92       	push	r9
     b32:	af 92       	push	r10
     b34:	bf 92       	push	r11
     b36:	cf 92       	push	r12
     b38:	df 92       	push	r13
     b3a:	ef 92       	push	r14
     b3c:	ff 92       	push	r15
     b3e:	0f 93       	push	r16
     b40:	1f 93       	push	r17
     b42:	df 93       	push	r29
     b44:	cf 93       	push	r28
     b46:	cd b7       	in	r28, 0x3d	; 61
     b48:	de b7       	in	r29, 0x3e	; 62
     b4a:	29 97       	sbiw	r28, 0x09	; 9
     b4c:	0f b6       	in	r0, 0x3f	; 63
     b4e:	f8 94       	cli
     b50:	de bf       	out	0x3e, r29	; 62
     b52:	0f be       	out	0x3f, r0	; 63
     b54:	cd bf       	out	0x3d, r28	; 61
     b56:	f8 2e       	mov	r15, r24
     b58:	96 2e       	mov	r9, r22
     b5a:	59 01       	movw	r10, r18
     b5c:	6a 01       	movw	r12, r20
     b5e:	80 2e       	mov	r8, r16
  char buf[9];
  buf[8] = 0;
     b60:	19 86       	std	Y+9, r1	; 0x09
     b62:	8e 01       	movw	r16, r28
     b64:	07 5f       	subi	r16, 0xF7	; 247
     b66:	1f 4f       	sbci	r17, 0xFF	; 255
     b68:	18 c0       	rjmp	.+48     	; 0xb9a <printDecimal+0x6c>
  char * ptr = &buf[8];
	
  while(val > 0) {
    ptr--;
    *ptr = val%10 + '0';
     b6a:	c6 01       	movw	r24, r12
     b6c:	b5 01       	movw	r22, r10
     b6e:	2a e0       	ldi	r18, 0x0A	; 10
     b70:	30 e0       	ldi	r19, 0x00	; 0
     b72:	40 e0       	ldi	r20, 0x00	; 0
     b74:	50 e0       	ldi	r21, 0x00	; 0
     b76:	0e 94 9f 08 	call	0x113e	; 0x113e <__udivmodsi4>
     b7a:	60 5d       	subi	r22, 0xD0	; 208
     b7c:	f8 01       	movw	r30, r16
     b7e:	62 93       	st	-Z, r22
     b80:	8f 01       	movw	r16, r30
    val /= 10;
     b82:	c6 01       	movw	r24, r12
     b84:	b5 01       	movw	r22, r10
     b86:	2a e0       	ldi	r18, 0x0A	; 10
     b88:	30 e0       	ldi	r19, 0x00	; 0
     b8a:	40 e0       	ldi	r20, 0x00	; 0
     b8c:	50 e0       	ldi	r21, 0x00	; 0
     b8e:	0e 94 9f 08 	call	0x113e	; 0x113e <__udivmodsi4>
     b92:	c9 01       	movw	r24, r18
     b94:	da 01       	movw	r26, r20
     b96:	5c 01       	movw	r10, r24
     b98:	6d 01       	movw	r12, r26
uint8_t printDecimal(uint8_t x, uint8_t y, uint32_t val, uint8_t fg, uint8_t bg) {
  char buf[9];
  buf[8] = 0;
  char * ptr = &buf[8];
	
  while(val > 0) {
     b9a:	a1 14       	cp	r10, r1
     b9c:	b1 04       	cpc	r11, r1
     b9e:	c1 04       	cpc	r12, r1
     ba0:	d1 04       	cpc	r13, r1
     ba2:	19 f7       	brne	.-58     	; 0xb6a <printDecimal+0x3c>
    val /= 10;
  }
//  if (ptr == &buf[8])
//    *(ptr = &buf[7]);// = '0';

  return putstr_ram(x,y,ptr,fg,bg);
     ba4:	8f 2d       	mov	r24, r15
     ba6:	69 2d       	mov	r22, r9
     ba8:	a8 01       	movw	r20, r16
     baa:	28 2d       	mov	r18, r8
     bac:	0e 2d       	mov	r16, r14
     bae:	0e 94 61 05 	call	0xac2	; 0xac2 <putstr_ram>

}
     bb2:	29 96       	adiw	r28, 0x09	; 9
     bb4:	0f b6       	in	r0, 0x3f	; 63
     bb6:	f8 94       	cli
     bb8:	de bf       	out	0x3e, r29	; 62
     bba:	0f be       	out	0x3f, r0	; 63
     bbc:	cd bf       	out	0x3d, r28	; 61
     bbe:	cf 91       	pop	r28
     bc0:	df 91       	pop	r29
     bc2:	1f 91       	pop	r17
     bc4:	0f 91       	pop	r16
     bc6:	ff 90       	pop	r15
     bc8:	ef 90       	pop	r14
     bca:	df 90       	pop	r13
     bcc:	cf 90       	pop	r12
     bce:	bf 90       	pop	r11
     bd0:	af 90       	pop	r10
     bd2:	9f 90       	pop	r9
     bd4:	8f 90       	pop	r8
     bd6:	08 95       	ret

00000bd8 <test_all_char>:
}

////////////////////////////////////////////////////
//////////  ѕќ ј«ј“ь ¬≈—№ «Ќј ќ√≈Ќ≈–ј“ќ–   /////////
////////////////////////////////////////////////////
void test_all_char(void){
     bd8:	8f 92       	push	r8
     bda:	9f 92       	push	r9
     bdc:	af 92       	push	r10
     bde:	bf 92       	push	r11
     be0:	cf 92       	push	r12
     be2:	df 92       	push	r13
     be4:	ef 92       	push	r14
     be6:	ff 92       	push	r15
     be8:	0f 93       	push	r16
     bea:	1f 93       	push	r17
     bec:	99 24       	eor	r9, r9
     bee:	ff 24       	eor	r15, r15
     bf0:	21 e0       	ldi	r18, 0x01	; 1
     bf2:	a2 2e       	mov	r10, r18
     bf4:	b1 2c       	mov	r11, r1
     bf6:	c1 2c       	mov	r12, r1
     bf8:	d1 2c       	mov	r13, r1
     bfa:	22 c0       	rjmp	.+68     	; 0xc40 <test_all_char+0x68>
     bfc:	48 2d       	mov	r20, r8
     bfe:	0e 2d       	mov	r16, r14
	char j = 1;
	char k =0;
	char l=0;
	for(int i=0; i<128; i+=8){
	for(int h=2; h<114; h+=7){
	putch(h, i, k++, 255, l++);// l++);
     c00:	84 2e       	mov	r8, r20
     c02:	83 94       	inc	r8
     c04:	e0 2e       	mov	r14, r16
     c06:	e3 94       	inc	r14
     c08:	81 2f       	mov	r24, r17
     c0a:	6f 2d       	mov	r22, r15
     c0c:	2f ef       	ldi	r18, 0xFF	; 255
     c0e:	0e 94 ce 04 	call	0x99c	; 0x99c <putch>
     c12:	19 5f       	subi	r17, 0xF9	; 249
void test_all_char(void){
	char j = 1;
	char k =0;
	char l=0;
	for(int i=0; i<128; i+=8){
	for(int h=2; h<114; h+=7){
     c14:	12 37       	cpi	r17, 0x72	; 114
     c16:	91 f7       	brne	.-28     	; 0xbfc <test_all_char+0x24>
     c18:	80 e1       	ldi	r24, 0x10	; 16
     c1a:	98 0e       	add	r9, r24
	putch(h, i, k++, 255, l++);// l++);
	}
	printDecimal(118,i,j++, 0xFE, 0x00);
     c1c:	86 e7       	ldi	r24, 0x76	; 118
     c1e:	6f 2d       	mov	r22, r15
     c20:	a6 01       	movw	r20, r12
     c22:	95 01       	movw	r18, r10
     c24:	0e ef       	ldi	r16, 0xFE	; 254
     c26:	ee 24       	eor	r14, r14
     c28:	0e 94 97 05 	call	0xb2e	; 0xb2e <printDecimal>
     c2c:	88 e0       	ldi	r24, 0x08	; 8
     c2e:	f8 0e       	add	r15, r24
     c30:	08 94       	sec
     c32:	a1 1c       	adc	r10, r1
     c34:	b1 1c       	adc	r11, r1
     c36:	c1 1c       	adc	r12, r1
     c38:	d1 1c       	adc	r13, r1
////////////////////////////////////////////////////
void test_all_char(void){
	char j = 1;
	char k =0;
	char l=0;
	for(int i=0; i<128; i+=8){
     c3a:	80 e8       	ldi	r24, 0x80	; 128
     c3c:	f8 16       	cp	r15, r24
     c3e:	21 f0       	breq	.+8      	; 0xc48 <test_all_char+0x70>
     c40:	49 2d       	mov	r20, r9
     c42:	09 2d       	mov	r16, r9
     c44:	12 e0       	ldi	r17, 0x02	; 2
     c46:	dc cf       	rjmp	.-72     	; 0xc00 <test_all_char+0x28>
	putch(h, i, k++, 255, l++);// l++);
	}
	printDecimal(118,i,j++, 0xFE, 0x00);

	}
}
     c48:	1f 91       	pop	r17
     c4a:	0f 91       	pop	r16
     c4c:	ff 90       	pop	r15
     c4e:	ef 90       	pop	r14
     c50:	df 90       	pop	r13
     c52:	cf 90       	pop	r12
     c54:	bf 90       	pop	r11
     c56:	af 90       	pop	r10
     c58:	9f 90       	pop	r9
     c5a:	8f 90       	pop	r8
     c5c:	08 95       	ret

00000c5e <set_Pixel>:
}



void set_Pixel(int x1,int y1,uint8_t fg, uint8_t l)
{
     c5e:	ef 92       	push	r14
     c60:	ff 92       	push	r15
     c62:	0f 93       	push	r16
     c64:	1f 93       	push	r17
     c66:	18 2f       	mov	r17, r24
     c68:	f6 2e       	mov	r15, r22
     c6a:	e4 2e       	mov	r14, r20
     c6c:	02 2f       	mov	r16, r18

	send_cmd (CASET);
     c6e:	8a e2       	ldi	r24, 0x2A	; 42
     c70:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
	send_data(x1);	
     c74:	81 2f       	mov	r24, r17
     c76:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
	send_data(x1+l);
     c7a:	80 2f       	mov	r24, r16
     c7c:	81 0f       	add	r24, r17
     c7e:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
		
	send_cmd (PASET);	
     c82:	8b e2       	ldi	r24, 0x2B	; 43
     c84:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
	send_data(y1);
     c88:	8f 2d       	mov	r24, r15
     c8a:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
	send_data(y1+l);
     c8e:	80 2f       	mov	r24, r16
     c90:	8f 0d       	add	r24, r15
     c92:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
	send_cmd (RAMWR);
     c96:	8c e2       	ldi	r24, 0x2C	; 44
     c98:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>

	l *=l;
     c9c:	00 9f       	mul	r16, r16
     c9e:	00 2d       	mov	r16, r0
     ca0:	11 24       	eor	r1, r1
     ca2:	10 e0       	ldi	r17, 0x00	; 0
     ca4:	04 c0       	rjmp	.+8      	; 0xcae <set_Pixel+0x50>
	for(uint8_t i=0; i<l; i++){
	send_data(fg);
     ca6:	8e 2d       	mov	r24, r14
     ca8:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
	send_data(y1);
	send_data(y1+l);
	send_cmd (RAMWR);

	l *=l;
	for(uint8_t i=0; i<l; i++){
     cac:	1f 5f       	subi	r17, 0xFF	; 255
     cae:	10 17       	cp	r17, r16
     cb0:	d0 f3       	brcs	.-12     	; 0xca6 <set_Pixel+0x48>
	send_data(fg);
	}
  send_cmd(0x2C);  //Memory Write
     cb2:	8c e2       	ldi	r24, 0x2C	; 44
     cb4:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>

}
     cb8:	1f 91       	pop	r17
     cba:	0f 91       	pop	r16
     cbc:	ff 90       	pop	r15
     cbe:	ef 90       	pop	r14
     cc0:	08 95       	ret

00000cc2 <drawLine>:
}
///////////////////////////////
///////////////////////////////

void drawLine(int x1, int y1, int x2, int y2, uint8_t fg, uint8_t l)
{
     cc2:	2f 92       	push	r2
     cc4:	3f 92       	push	r3
     cc6:	4f 92       	push	r4
     cc8:	5f 92       	push	r5
     cca:	6f 92       	push	r6
     ccc:	7f 92       	push	r7
     cce:	8f 92       	push	r8
     cd0:	9f 92       	push	r9
     cd2:	af 92       	push	r10
     cd4:	bf 92       	push	r11
     cd6:	cf 92       	push	r12
     cd8:	df 92       	push	r13
     cda:	ef 92       	push	r14
     cdc:	ff 92       	push	r15
     cde:	0f 93       	push	r16
     ce0:	1f 93       	push	r17
     ce2:	df 93       	push	r29
     ce4:	cf 93       	push	r28
     ce6:	00 d0       	rcall	.+0      	; 0xce8 <drawLine+0x26>
     ce8:	00 d0       	rcall	.+0      	; 0xcea <drawLine+0x28>
     cea:	00 d0       	rcall	.+0      	; 0xcec <drawLine+0x2a>
     cec:	cd b7       	in	r28, 0x3d	; 61
     cee:	de b7       	in	r29, 0x3e	; 62
     cf0:	5c 01       	movw	r10, r24
     cf2:	6b 01       	movw	r12, r22
     cf4:	3a 01       	movw	r6, r20
     cf6:	49 01       	movw	r8, r18
     cf8:	09 83       	std	Y+1, r16	; 0x01
     cfa:	ea 82       	std	Y+2, r14	; 0x02
    int deltaX = abs(x2 - x1);
     cfc:	7a 01       	movw	r14, r20
     cfe:	e8 1a       	sub	r14, r24
     d00:	f9 0a       	sbc	r15, r25
     d02:	f7 fe       	sbrs	r15, 7
     d04:	04 c0       	rjmp	.+8      	; 0xd0e <drawLine+0x4c>
     d06:	f0 94       	com	r15
     d08:	e1 94       	neg	r14
     d0a:	f1 08       	sbc	r15, r1
     d0c:	f3 94       	inc	r15
    int deltaY = abs(y2 - y1);
     d0e:	84 01       	movw	r16, r8
     d10:	0c 19       	sub	r16, r12
     d12:	1d 09       	sbc	r17, r13
     d14:	17 ff       	sbrs	r17, 7
     d16:	03 c0       	rjmp	.+6      	; 0xd1e <drawLine+0x5c>
     d18:	10 95       	com	r17
     d1a:	01 95       	neg	r16
     d1c:	1f 4f       	sbci	r17, 0xFF	; 255
    int signX = x1 < x2 ? 1 : -1;
     d1e:	a6 14       	cp	r10, r6
     d20:	b7 04       	cpc	r11, r7
     d22:	24 f0       	brlt	.+8      	; 0xd2c <drawLine+0x6a>
     d24:	22 24       	eor	r2, r2
     d26:	2a 94       	dec	r2
     d28:	32 2c       	mov	r3, r2
     d2a:	03 c0       	rjmp	.+6      	; 0xd32 <drawLine+0x70>
     d2c:	51 e0       	ldi	r21, 0x01	; 1
     d2e:	25 2e       	mov	r2, r21
     d30:	31 2c       	mov	r3, r1
    int signY = y1 < y2 ? 1 : -1;
     d32:	c8 14       	cp	r12, r8
     d34:	d9 04       	cpc	r13, r9
     d36:	24 f0       	brlt	.+8      	; 0xd40 <drawLine+0x7e>
     d38:	44 24       	eor	r4, r4
     d3a:	4a 94       	dec	r4
     d3c:	54 2c       	mov	r5, r4
     d3e:	03 c0       	rjmp	.+6      	; 0xd46 <drawLine+0x84>
     d40:	41 e0       	ldi	r20, 0x01	; 1
     d42:	44 2e       	mov	r4, r20
     d44:	51 2c       	mov	r5, r1
    int error = deltaX - deltaY;
     d46:	97 01       	movw	r18, r14
     d48:	20 1b       	sub	r18, r16
     d4a:	31 0b       	sbc	r19, r17
     d4c:	3e 83       	std	Y+6, r19	; 0x06
     d4e:	2d 83       	std	Y+5, r18	; 0x05
        if(x1 == x2 && y1 == y2)
            break;
 
        int error2 = error * 2;
 
        if(error2 > -deltaY)
     d50:	88 27       	eor	r24, r24
     d52:	99 27       	eor	r25, r25
     d54:	80 1b       	sub	r24, r16
     d56:	91 0b       	sbc	r25, r17
     d58:	9c 83       	std	Y+4, r25	; 0x04
     d5a:	8b 83       	std	Y+3, r24	; 0x03
    int signY = y1 < y2 ? 1 : -1;
    int error = deltaX - deltaY;
 
    for (;;)
    {
        set_Pixel(x1, y1, fg, l);//uint8_t fg, uint8_t bg
     d5c:	c5 01       	movw	r24, r10
     d5e:	b6 01       	movw	r22, r12
     d60:	49 81       	ldd	r20, Y+1	; 0x01
     d62:	2a 81       	ldd	r18, Y+2	; 0x02
     d64:	0e 94 2f 06 	call	0xc5e	; 0xc5e <set_Pixel>
 
        if(x1 == x2 && y1 == y2)
     d68:	a6 14       	cp	r10, r6
     d6a:	b7 04       	cpc	r11, r7
     d6c:	19 f4       	brne	.+6      	; 0xd74 <drawLine+0xb2>
     d6e:	c8 14       	cp	r12, r8
     d70:	d9 04       	cpc	r13, r9
     d72:	e9 f0       	breq	.+58     	; 0xdae <drawLine+0xec>
            break;
 
        int error2 = error * 2;
     d74:	8d 81       	ldd	r24, Y+5	; 0x05
     d76:	9e 81       	ldd	r25, Y+6	; 0x06
     d78:	88 0f       	add	r24, r24
     d7a:	99 1f       	adc	r25, r25
 
        if(error2 > -deltaY)
     d7c:	eb 81       	ldd	r30, Y+3	; 0x03
     d7e:	fc 81       	ldd	r31, Y+4	; 0x04
     d80:	e8 17       	cp	r30, r24
     d82:	f9 07       	cpc	r31, r25
     d84:	44 f4       	brge	.+16     	; 0xd96 <drawLine+0xd4>
        {
            error -= deltaY;
     d86:	2d 81       	ldd	r18, Y+5	; 0x05
     d88:	3e 81       	ldd	r19, Y+6	; 0x06
     d8a:	20 1b       	sub	r18, r16
     d8c:	31 0b       	sbc	r19, r17
     d8e:	3e 83       	std	Y+6, r19	; 0x06
     d90:	2d 83       	std	Y+5, r18	; 0x05
            x1 += signX;
     d92:	a2 0c       	add	r10, r2
     d94:	b3 1c       	adc	r11, r3
        }
 
        if(error2 < deltaX)
     d96:	8e 15       	cp	r24, r14
     d98:	9f 05       	cpc	r25, r15
     d9a:	04 f7       	brge	.-64     	; 0xd5c <drawLine+0x9a>
        {
            error += deltaX;
     d9c:	8d 81       	ldd	r24, Y+5	; 0x05
     d9e:	9e 81       	ldd	r25, Y+6	; 0x06
     da0:	8e 0d       	add	r24, r14
     da2:	9f 1d       	adc	r25, r15
     da4:	9e 83       	std	Y+6, r25	; 0x06
     da6:	8d 83       	std	Y+5, r24	; 0x05
            y1 += signY;
     da8:	c4 0c       	add	r12, r4
     daa:	d5 1c       	adc	r13, r5
     dac:	d7 cf       	rjmp	.-82     	; 0xd5c <drawLine+0x9a>
        }
    }
}
     dae:	26 96       	adiw	r28, 0x06	; 6
     db0:	0f b6       	in	r0, 0x3f	; 63
     db2:	f8 94       	cli
     db4:	de bf       	out	0x3e, r29	; 62
     db6:	0f be       	out	0x3f, r0	; 63
     db8:	cd bf       	out	0x3d, r28	; 61
     dba:	cf 91       	pop	r28
     dbc:	df 91       	pop	r29
     dbe:	1f 91       	pop	r17
     dc0:	0f 91       	pop	r16
     dc2:	ff 90       	pop	r15
     dc4:	ef 90       	pop	r14
     dc6:	df 90       	pop	r13
     dc8:	cf 90       	pop	r12
     dca:	bf 90       	pop	r11
     dcc:	af 90       	pop	r10
     dce:	9f 90       	pop	r9
     dd0:	8f 90       	pop	r8
     dd2:	7f 90       	pop	r7
     dd4:	6f 90       	pop	r6
     dd6:	5f 90       	pop	r5
     dd8:	4f 90       	pop	r4
     dda:	3f 90       	pop	r3
     ddc:	2f 90       	pop	r2
     dde:	08 95       	ret

00000de0 <waitms>:
}//main



///////////////////////////////////
void waitms(int ms) {
     de0:	20 e0       	ldi	r18, 0x00	; 0
     de2:	30 e0       	ldi	r19, 0x00	; 0
     de4:	46 e6       	ldi	r20, 0x66	; 102
     de6:	5e e0       	ldi	r21, 0x0E	; 14
     de8:	05 c0       	rjmp	.+10     	; 0xdf4 <waitms+0x14>
     dea:	fa 01       	movw	r30, r20
     dec:	31 97       	sbiw	r30, 0x01	; 1
     dee:	f1 f7       	brne	.-4      	; 0xdec <waitms+0xc>
  int i;
  for (i=0;i<ms;i++) _delay_ms(1);
     df0:	2f 5f       	subi	r18, 0xFF	; 255
     df2:	3f 4f       	sbci	r19, 0xFF	; 255
     df4:	28 17       	cp	r18, r24
     df6:	39 07       	cpc	r19, r25
     df8:	c4 f3       	brlt	.-16     	; 0xdea <waitms+0xa>
}
     dfa:	08 95       	ret

00000dfc <print_hex>:
///////////////////////////////////


uint8_t  print_hex(uint8_t x,uint8_t y,uint16_t char_,uint8_t  fg,uint8_t bg)
{//вывести на LCD 16ти битное число
     dfc:	cf 92       	push	r12
     dfe:	df 92       	push	r13
     e00:	ef 92       	push	r14
     e02:	ff 92       	push	r15
     e04:	0f 93       	push	r16
     e06:	1f 93       	push	r17
     e08:	cf 93       	push	r28
     e0a:	df 93       	push	r29
     e0c:	16 2f       	mov	r17, r22
     e0e:	7a 01       	movw	r14, r20
     e10:	d2 2e       	mov	r13, r18
	temp = char_;
	temp &= 0xF000;
	temp = temp>>12;

	unsigned char *f = s_hex + temp;
	uint8_t a = pgm_read_byte(f);
     e12:	fa 01       	movw	r30, r20
     e14:	ef 2f       	mov	r30, r31
     e16:	ff 27       	eor	r31, r31
     e18:	e2 95       	swap	r30
     e1a:	ef 70       	andi	r30, 0x0F	; 15
     e1c:	c2 ec       	ldi	r28, 0xC2	; 194
     e1e:	d0 e0       	ldi	r29, 0x00	; 0
     e20:	ec 0f       	add	r30, r28
     e22:	fd 1f       	adc	r31, r29
     e24:	e4 91       	lpm	r30, Z+
	
	x = putch(x,y,a,fg,bg);
     e26:	4e 2f       	mov	r20, r30
     e28:	0e 94 ce 04 	call	0x99c	; 0x99c <putch>
	
//////////////////////////////////	
	temp = char_;
	temp &= 0xF00;
     e2c:	f7 01       	movw	r30, r14
     e2e:	e0 70       	andi	r30, 0x00	; 0
     e30:	ff 70       	andi	r31, 0x0F	; 15
	temp = temp>>8;

	unsigned char *g = s_hex + temp;
	a = pgm_read_byte(g);
     e32:	ef 2f       	mov	r30, r31
     e34:	ff 27       	eor	r31, r31
     e36:	ec 0f       	add	r30, r28
     e38:	fd 1f       	adc	r31, r29
     e3a:	e4 91       	lpm	r30, Z+
	
	x = putch(x,y,a,fg,bg);
     e3c:	61 2f       	mov	r22, r17
     e3e:	4e 2f       	mov	r20, r30
     e40:	2d 2d       	mov	r18, r13
     e42:	0e 94 ce 04 	call	0x99c	; 0x99c <putch>

	temp = char_;
	temp &= 0xF0;
     e46:	f7 01       	movw	r30, r14
     e48:	e0 7f       	andi	r30, 0xF0	; 240
     e4a:	f0 70       	andi	r31, 0x00	; 0
	temp = temp>>4;

	unsigned char *p = s_hex + temp;
	a = pgm_read_byte(p);	
     e4c:	64 e0       	ldi	r22, 0x04	; 4
     e4e:	f6 95       	lsr	r31
     e50:	e7 95       	ror	r30
     e52:	6a 95       	dec	r22
     e54:	e1 f7       	brne	.-8      	; 0xe4e <print_hex+0x52>
     e56:	ec 0f       	add	r30, r28
     e58:	fd 1f       	adc	r31, r29
     e5a:	e4 91       	lpm	r30, Z+

	x = putch(x,y,a,fg,bg);
     e5c:	61 2f       	mov	r22, r17
     e5e:	4e 2f       	mov	r20, r30
     e60:	2d 2d       	mov	r18, r13
     e62:	0e 94 ce 04 	call	0x99c	; 0x99c <putch>
/////////////////////////////////////
	temp = char_;
	temp &= 0x0F;
	
	unsigned char *s = s_hex + temp;
	a = pgm_read_byte(s);
     e66:	9f e0       	ldi	r25, 0x0F	; 15
     e68:	e9 22       	and	r14, r25
     e6a:	ff 24       	eor	r15, r15
     e6c:	ce 0d       	add	r28, r14
     e6e:	df 1d       	adc	r29, r15
     e70:	fe 01       	movw	r30, r28
     e72:	44 91       	lpm	r20, Z+
	
	x = putch(x,y,a,fg,bg);	
     e74:	61 2f       	mov	r22, r17
     e76:	2d 2d       	mov	r18, r13
     e78:	0e 94 ce 04 	call	0x99c	; 0x99c <putch>

////////////////////////////////////
return x;					
}
     e7c:	df 91       	pop	r29
     e7e:	cf 91       	pop	r28
     e80:	1f 91       	pop	r17
     e82:	0f 91       	pop	r16
     e84:	ff 90       	pop	r15
     e86:	ef 90       	pop	r14
     e88:	df 90       	pop	r13
     e8a:	cf 90       	pop	r12
     e8c:	08 95       	ret

00000e8e <main>:

static uint8_t s_hex[16] PROGMEM =
{'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};

int main(void)
{
     e8e:	3f 92       	push	r3
     e90:	4f 92       	push	r4
     e92:	5f 92       	push	r5
     e94:	6f 92       	push	r6
     e96:	7f 92       	push	r7
     e98:	8f 92       	push	r8
     e9a:	9f 92       	push	r9
     e9c:	af 92       	push	r10
     e9e:	bf 92       	push	r11
     ea0:	cf 92       	push	r12
     ea2:	df 92       	push	r13
     ea4:	ef 92       	push	r14
     ea6:	ff 92       	push	r15
     ea8:	0f 93       	push	r16
     eaa:	1f 93       	push	r17
     eac:	cf 93       	push	r28
     eae:	df 93       	push	r29

	uint16_t x,y,u;
	uint8_t h,l;

	init_lcd();
     eb0:	0e 94 22 04 	call	0x844	; 0x844 <init_lcd>
	clrscr(0,0,131,131,255);
     eb4:	80 e0       	ldi	r24, 0x00	; 0
     eb6:	60 e0       	ldi	r22, 0x00	; 0
     eb8:	43 e8       	ldi	r20, 0x83	; 131
     eba:	23 e8       	ldi	r18, 0x83	; 131
     ebc:	0f ef       	ldi	r16, 0xFF	; 255
     ebe:	0e 94 26 05 	call	0xa4c	; 0xa4c <clrscr>
//	putstr_pgm(10,5, hello,fg,bg);
//	print_hex(50,50,0x1234,fg,bg);
//		while(1){}

	ADCSRA=(1<<ADEN)|(1<<ADSC)|(1<<ADPS0)|(1<<ADPS1)|(1<<ADPS2);	//ј÷ѕ включен, прескаллер=/128 
     ec2:	87 ec       	ldi	r24, 0xC7	; 199
     ec4:	86 b9       	out	0x06, r24	; 6
     ec6:	80 e0       	ldi	r24, 0x00	; 0
     ec8:	90 e0       	ldi	r25, 0x00	; 0
     eca:	26 e6       	ldi	r18, 0x66	; 102
     ecc:	3e e0       	ldi	r19, 0x0E	; 14
     ece:	f9 01       	movw	r30, r18
     ed0:	31 97       	sbiw	r30, 0x01	; 1
     ed2:	f1 f7       	brne	.-4      	; 0xed0 <main+0x42>


///////////////////////////////////
void waitms(int ms) {
  int i;
  for (i=0;i<ms;i++) _delay_ms(1);
     ed4:	01 96       	adiw	r24, 0x01	; 1
     ed6:	8a 30       	cpi	r24, 0x0A	; 10
     ed8:	91 05       	cpc	r25, r1
     eda:	c9 f7       	brne	.-14     	; 0xece <main+0x40>
				 
			if (u<2) //≈сли было нажатие 
			 
			{  	
*/		
			DDRF= 0x0C;		//—читываем X координату   
     edc:	2c e0       	ldi	r18, 0x0C	; 12
     ede:	32 2e       	mov	r3, r18
			PORTF=0x08; 
     ee0:	98 e0       	ldi	r25, 0x08	; 8
     ee2:	49 2e       	mov	r4, r25
     ee4:	86 e6       	ldi	r24, 0x66	; 102
     ee6:	88 2e       	mov	r8, r24
     ee8:	8e e0       	ldi	r24, 0x0E	; 14
     eea:	98 2e       	mov	r9, r24
			 
	        waitms(1);
  
			ADMUX=(1<<REFS0)|(1<<MUX0);   // ADC0         
     eec:	01 e4       	ldi	r16, 0x41	; 65
     eee:	50 2e       	mov	r5, r16

			x = l + ((unsigned int)h << 8);

/////////////////////////////////////////////////////////////////////////////////////////

			DDRF= 0x03;		// —читываем Y координату
     ef0:	13 e0       	ldi	r17, 0x03	; 3
     ef2:	61 2e       	mov	r6, r17
			PORTF=0x01;  
     ef4:	77 24       	eor	r7, r7
     ef6:	73 94       	inc	r7
	        
			waitms(1);
    
			ADMUX=(1<<REFS0)|(1<<MUX0)|(1<<MUX1);    // ADC3      
     ef8:	b3 e4       	ldi	r27, 0x43	; 67
     efa:	cb 2e       	mov	r12, r27
				 
			if (u<2) //≈сли было нажатие 
			 
			{  	
*/		
			DDRF= 0x0C;		//—читываем X координату   
     efc:	30 92 61 00 	sts	0x0061, r3
			PORTF=0x08; 
     f00:	40 92 62 00 	sts	0x0062, r4
     f04:	c4 01       	movw	r24, r8
     f06:	01 97       	sbiw	r24, 0x01	; 1
     f08:	f1 f7       	brne	.-4      	; 0xf06 <main+0x78>
			 
	        waitms(1);
  
			ADMUX=(1<<REFS0)|(1<<MUX0);   // ADC0         
     f0a:	57 b8       	out	0x07, r5	; 7
			ADCSRA|=(1<<ADSC);
     f0c:	36 9a       	sbi	0x06, 6	; 6
	         
			while ((ADCSRA&_BV(ADIF))==0x00); 	// ∆дем окончани€ преобразовани€;         		   
     f0e:	34 9b       	sbis	0x06, 4	; 6
     f10:	fe cf       	rjmp	.-4      	; 0xf0e <main+0x80>

			 l=ADCL;
     f12:	34 b1       	in	r19, 0x04	; 4
			 h=ADCH;
     f14:	45 b1       	in	r20, 0x05	; 5

			x = l + ((unsigned int)h << 8);

/////////////////////////////////////////////////////////////////////////////////////////

			DDRF= 0x03;		// —читываем Y координату
     f16:	60 92 61 00 	sts	0x0061, r6
			PORTF=0x01;  
     f1a:	70 92 62 00 	sts	0x0062, r7
     f1e:	c4 01       	movw	r24, r8
     f20:	01 97       	sbiw	r24, 0x01	; 1
     f22:	f1 f7       	brne	.-4      	; 0xf20 <main+0x92>
	        
			waitms(1);
    
			ADMUX=(1<<REFS0)|(1<<MUX0)|(1<<MUX1);    // ADC3      
     f24:	c7 b8       	out	0x07, r12	; 7
			ADCSRA|=(1<<ADSC);
     f26:	36 9a       	sbi	0x06, 6	; 6
	         
			while ((ADCSRA&_BV(ADIF))==0x00); 	// ∆дем окончани€ преобразовани€ 
     f28:	34 9b       	sbis	0x06, 4	; 6
     f2a:	fe cf       	rjmp	.-4      	; 0xf28 <main+0x9a>
			 l=ADCL;
     f2c:	84 b1       	in	r24, 0x04	; 4
			 h=ADCH;
     f2e:	25 b1       	in	r18, 0x05	; 5
		
		// y = 0x2E //  болтанка по x & y
		// x = 0x44 //


			y=(y-0x6D)/(0x376/128);		//¬ычисл€ем координаты нажати€		   
     f30:	90 e0       	ldi	r25, 0x00	; 0
     f32:	8d 56       	subi	r24, 0x6D	; 109
     f34:	90 40       	sbci	r25, 0x00	; 0
     f36:	b2 2e       	mov	r11, r18
     f38:	aa 24       	eor	r10, r10
     f3a:	8a 0d       	add	r24, r10
     f3c:	9b 1d       	adc	r25, r11
     f3e:	66 e0       	ldi	r22, 0x06	; 6
     f40:	70 e0       	ldi	r23, 0x00	; 0
     f42:	0e 94 8b 08 	call	0x1116	; 0x1116 <__udivmodhi4>
     f46:	e6 2e       	mov	r14, r22
     f48:	d7 2e       	mov	r13, r23
			x=(x-0x4D)/(0x3B6/128); 
     f4a:	83 2f       	mov	r24, r19
     f4c:	90 e0       	ldi	r25, 0x00	; 0
     f4e:	8d 54       	subi	r24, 0x4D	; 77
     f50:	90 40       	sbci	r25, 0x00	; 0
     f52:	d4 2f       	mov	r29, r20
     f54:	c0 e0       	ldi	r28, 0x00	; 0
     f56:	8c 0f       	add	r24, r28
     f58:	9d 1f       	adc	r25, r29
     f5a:	67 e0       	ldi	r22, 0x07	; 7
     f5c:	70 e0       	ldi	r23, 0x00	; 0
     f5e:	0e 94 8b 08 	call	0x1116	; 0x1116 <__udivmodhi4>
     f62:	16 2f       	mov	r17, r22
     f64:	f7 2e       	mov	r15, r23

		
		

			set_Pixel(x,y,fg,4);
     f66:	86 2f       	mov	r24, r22
     f68:	97 2f       	mov	r25, r23
     f6a:	6e 2d       	mov	r22, r14
     f6c:	7d 2d       	mov	r23, r13
     f6e:	40 91 08 01 	lds	r20, 0x0108
     f72:	24 e0       	ldi	r18, 0x04	; 4
     f74:	0e 94 2f 06 	call	0xc5e	; 0xc5e <set_Pixel>


		putstr_ram(5, 5, "X=", fg, bg);
     f78:	85 e0       	ldi	r24, 0x05	; 5
     f7a:	65 e0       	ldi	r22, 0x05	; 5
     f7c:	40 e0       	ldi	r20, 0x00	; 0
     f7e:	51 e0       	ldi	r21, 0x01	; 1
     f80:	20 91 08 01 	lds	r18, 0x0108
     f84:	00 91 06 01 	lds	r16, 0x0106
     f88:	0e 94 61 05 	call	0xac2	; 0xac2 <putstr_ram>
		print_hex(20,5,x,fg,bg);
     f8c:	84 e1       	ldi	r24, 0x14	; 20
     f8e:	65 e0       	ldi	r22, 0x05	; 5
     f90:	41 2f       	mov	r20, r17
     f92:	5f 2d       	mov	r21, r15
     f94:	20 91 08 01 	lds	r18, 0x0108
     f98:	00 91 06 01 	lds	r16, 0x0106
     f9c:	0e 94 fe 06 	call	0xdfc	; 0xdfc <print_hex>

		putstr_ram(5, 15, "Y=", fg, bg);				
     fa0:	85 e0       	ldi	r24, 0x05	; 5
     fa2:	6f e0       	ldi	r22, 0x0F	; 15
     fa4:	43 e0       	ldi	r20, 0x03	; 3
     fa6:	51 e0       	ldi	r21, 0x01	; 1
     fa8:	20 91 08 01 	lds	r18, 0x0108
     fac:	00 91 06 01 	lds	r16, 0x0106
     fb0:	0e 94 61 05 	call	0xac2	; 0xac2 <putstr_ram>
		print_hex(20,15,y,fg,bg);					   
     fb4:	84 e1       	ldi	r24, 0x14	; 20
     fb6:	6f e0       	ldi	r22, 0x0F	; 15
     fb8:	4e 2d       	mov	r20, r14
     fba:	5d 2d       	mov	r21, r13
     fbc:	20 91 08 01 	lds	r18, 0x0108
     fc0:	00 91 06 01 	lds	r16, 0x0106
     fc4:	0e 94 fe 06 	call	0xdfc	; 0xdfc <print_hex>
     fc8:	99 cf       	rjmp	.-206    	; 0xefc <main+0x6e>

00000fca <bmp_rcv_uart>:
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//////////////////  ѕ–»Ќя“№ по UART - BMP //////////////////////////
////////////////////////////////////////////////////////////////////

void bmp_rcv_uart(void){
     fca:	df 92       	push	r13
     fcc:	ef 92       	push	r14
     fce:	ff 92       	push	r15
     fd0:	0f 93       	push	r16
     fd2:	1f 93       	push	r17
     fd4:	cf 93       	push	r28
     fd6:	df 93       	push	r29
     fd8:	10 e0       	ldi	r17, 0x00	; 0
     fda:	ff 24       	eor	r15, r15
     fdc:	dd 24       	eor	r13, r13
     fde:	ee 24       	eor	r14, r14
     fe0:	c0 e0       	ldi	r28, 0x00	; 0
     fe2:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t x =0;
 	uint8_t y =0;


  for(int i = 0; i<23; i++){ // 1078 // 0x436
	uint8_t	t = receiveByte();//receiveByte//get_data
     fe4:	0e 94 5f 08 	call	0x10be	; 0x10be <receiveByte>

  switch (i){ // получить данные из заголовка BMP
     fe8:	cb 30       	cpi	r28, 0x0B	; 11
     fea:	d1 05       	cpc	r29, r1
     fec:	71 f0       	breq	.+28     	; 0x100a <bmp_rcv_uart+0x40>
     fee:	cc 30       	cpi	r28, 0x0C	; 12
     ff0:	d1 05       	cpc	r29, r1
     ff2:	24 f4       	brge	.+8      	; 0xffc <bmp_rcv_uart+0x32>
     ff4:	ca 30       	cpi	r28, 0x0A	; 10
     ff6:	d1 05       	cpc	r29, r1
     ff8:	a9 f4       	brne	.+42     	; 0x1024 <bmp_rcv_uart+0x5a>
     ffa:	10 c0       	rjmp	.+32     	; 0x101c <bmp_rcv_uart+0x52>
     ffc:	c2 31       	cpi	r28, 0x12	; 18
     ffe:	d1 05       	cpc	r29, r1
    1000:	41 f0       	breq	.+16     	; 0x1012 <bmp_rcv_uart+0x48>
    1002:	c6 31       	cpi	r28, 0x16	; 22
    1004:	d1 05       	cpc	r29, r1
    1006:	71 f4       	brne	.+28     	; 0x1024 <bmp_rcv_uart+0x5a>
    1008:	07 c0       	rjmp	.+14     	; 0x1018 <bmp_rcv_uart+0x4e>
    100a:	f8 2e       	mov	r15, r24
    100c:	d8 2e       	mov	r13, r24
    100e:	e8 2e       	mov	r14, r24
    1010:	09 c0       	rjmp	.+18     	; 0x1024 <bmp_rcv_uart+0x5a>
    1012:	d8 2e       	mov	r13, r24
    1014:	e8 2e       	mov	r14, r24
    1016:	06 c0       	rjmp	.+12     	; 0x1024 <bmp_rcv_uart+0x5a>
    1018:	e8 2e       	mov	r14, r24
    101a:	04 c0       	rjmp	.+8      	; 0x1024 <bmp_rcv_uart+0x5a>
    101c:	18 2f       	mov	r17, r24
    101e:	f8 2e       	mov	r15, r24
    1020:	d8 2e       	mov	r13, r24
    1022:	e8 2e       	mov	r14, r24
	uint8_t h =0;
	uint8_t x =0;
 	uint8_t y =0;


  for(int i = 0; i<23; i++){ // 1078 // 0x436
    1024:	21 96       	adiw	r28, 0x01	; 1
    1026:	c7 31       	cpi	r28, 0x17	; 23
    1028:	d1 05       	cpc	r29, r1
    102a:	e1 f6       	brne	.-72     	; 0xfe4 <bmp_rcv_uart+0x1a>
  case 22: { y = t; }
			}

	}

	uint16_t b = l + ((unsigned int)h << 8); //адрес  начала BMP
    102c:	01 2f       	mov	r16, r17
    102e:	10 e0       	ldi	r17, 0x00	; 0
    1030:	07 51       	subi	r16, 0x17	; 23
    1032:	10 40       	sbci	r17, 0x00	; 0
	b = b - 23; // начало BMP - данные которые уже получили 
    1034:	9f 2d       	mov	r25, r15
    1036:	80 e0       	ldi	r24, 0x00	; 0
    1038:	08 0f       	add	r16, r24
    103a:	19 1f       	adc	r17, r25
    103c:	c0 e0       	ldi	r28, 0x00	; 0
    103e:	d0 e0       	ldi	r29, 0x00	; 0
    1040:	03 c0       	rjmp	.+6      	; 0x1048 <bmp_rcv_uart+0x7e>
//	printDecimal(40,60,y, 0, 255);




	for(uint16_t i = 0; i<b; i++){receiveByte();}
    1042:	0e 94 5f 08 	call	0x10be	; 0x10be <receiveByte>
    1046:	21 96       	adiw	r28, 0x01	; 1
    1048:	c0 17       	cp	r28, r16
    104a:	d1 07       	cpc	r29, r17
    104c:	d0 f3       	brcs	.-12     	; 0x1042 <bmp_rcv_uart+0x78>



	send_cmd (0x36);//  0x36  //;Memory data acces control
    104e:	86 e3       	ldi	r24, 0x36	; 54
    1050:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>
	send_data(0x08);// 0x20-MADCTL_VERT
    1054:	88 e0       	ldi	r24, 0x08	; 8
    1056:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
	send_cmd (0x2c);
    105a:	8c e2       	ldi	r24, 0x2C	; 44
    105c:	0e 94 1c 04 	call	0x838	; 0x838 <send_cmd>


	 window(2,2,x+1,y+1);
    1060:	4d 2d       	mov	r20, r13
    1062:	4f 5f       	subi	r20, 0xFF	; 255
    1064:	2e 2d       	mov	r18, r14
    1066:	2f 5f       	subi	r18, 0xFF	; 255
    1068:	82 e0       	ldi	r24, 0x02	; 2
    106a:	62 e0       	ldi	r22, 0x02	; 2
    106c:	0e 94 ac 04 	call	0x958	; 0x958 <window>
    1070:	00 e0       	ldi	r16, 0x00	; 0
    1072:	0e c0       	rjmp	.+28     	; 0x1090 <bmp_rcv_uart+0xc6>

//	uint8_t dy = 1;
	
	for(uint8_t i = 0; i<y; i++){
	for(uint8_t h = 0; h<x; h++){
	uint8_t k=receiveByte();
    1074:	0e 94 5f 08 	call	0x10be	; 0x10be <receiveByte>
	unsigned char *p = s_palitra8bit+k;
	int a = pgm_read_byte(p);
    1078:	e8 2f       	mov	r30, r24
    107a:	f0 e0       	ldi	r31, 0x00	; 0
    107c:	ee 52       	subi	r30, 0x2E	; 46
    107e:	ff 4f       	sbci	r31, 0xFF	; 255
    1080:	e4 91       	lpm	r30, Z+
	send_data(a);
    1082:	8e 2f       	mov	r24, r30
    1084:	0e 94 16 04 	call	0x82c	; 0x82c <send_data>
	 window(2,2,x+1,y+1);

//	uint8_t dy = 1;
	
	for(uint8_t i = 0; i<y; i++){
	for(uint8_t h = 0; h<x; h++){
    1088:	1f 5f       	subi	r17, 0xFF	; 255
    108a:	1d 15       	cp	r17, r13
    108c:	98 f3       	brcs	.-26     	; 0x1074 <bmp_rcv_uart+0xaa>

	 window(2,2,x+1,y+1);

//	uint8_t dy = 1;
	
	for(uint8_t i = 0; i<y; i++){
    108e:	0f 5f       	subi	r16, 0xFF	; 255
    1090:	0e 15       	cp	r16, r14
    1092:	10 f4       	brcc	.+4      	; 0x1098 <bmp_rcv_uart+0xce>
    1094:	10 e0       	ldi	r17, 0x00	; 0
    1096:	f9 cf       	rjmp	.-14     	; 0x108a <bmp_rcv_uart+0xc0>
	int a = pgm_read_byte(p);
	send_data(a);
	}
*/

}
    1098:	df 91       	pop	r29
    109a:	cf 91       	pop	r28
    109c:	1f 91       	pop	r17
    109e:	0f 91       	pop	r16
    10a0:	ff 90       	pop	r15
    10a2:	ef 90       	pop	r14
    10a4:	df 90       	pop	r13
    10a6:	08 95       	ret

000010a8 <uart1_init>:
#include <avr/pgmspace.h>
#include "UART_routines.h"

void uart1_init(void)
{
	UCSR1A=0x00;
    10a8:	10 92 9b 00 	sts	0x009B, r1
	UCSR1B = (1<<RXEN)|(1<<TXEN);
    10ac:	88 e1       	ldi	r24, 0x18	; 24
    10ae:	80 93 9a 00 	sts	0x009A, r24
//	UCSR1C = (1<<URSEL1)|(1<<UCSZ0)|(1<<UCSZ1);
	UBRR1H = HI(baud);
    10b2:	10 92 98 00 	sts	0x0098, r1
	UBRR1L = LO(baud);
    10b6:	87 e0       	ldi	r24, 0x07	; 7
    10b8:	80 93 99 00 	sts	0x0099, r24
}
    10bc:	08 95       	ret

000010be <receiveByte>:
//*************************************************
unsigned char receiveByte( void )
{
	unsigned char data, status;
	
	while(!(UCSR1A & (1<<RXC1))); 	// Wait for incomming data
    10be:	80 91 9b 00 	lds	r24, 0x009B
    10c2:	87 ff       	sbrs	r24, 7
    10c4:	fc cf       	rjmp	.-8      	; 0x10be <receiveByte>
	
	status = UCSR1A;
    10c6:	80 91 9b 00 	lds	r24, 0x009B
	data = UDR1;
    10ca:	80 91 9c 00 	lds	r24, 0x009C
	
	return(data);
}
    10ce:	08 95       	ret

000010d0 <transmitByte>:

//***************************************************
//Function to transmit a single byte
//***************************************************
void transmitByte( unsigned char data )
{
    10d0:	98 2f       	mov	r25, r24
	while ( !(UCSR1A & (1<<UDRE1)) )
    10d2:	80 91 9b 00 	lds	r24, 0x009B
    10d6:	85 ff       	sbrs	r24, 5
    10d8:	fc cf       	rjmp	.-8      	; 0x10d2 <transmitByte+0x2>
		; 			                /* Wait for empty transmit buffer */
	UDR1 = data; 			        /* Start transmition */
    10da:	90 93 9c 00 	sts	0x009C, r25
}
    10de:	08 95       	ret

000010e0 <transmitHex>:

  data = data/16;
}

//transmitString (dataString);  // ??????????????????????????????????
}
    10e0:	08 95       	ret

000010e2 <transmitString_F>:

//***************************************************
//Function to transmit a string in Flash
//***************************************************
void transmitString_F(char* string)
{
    10e2:	fc 01       	movw	r30, r24
    10e4:	07 c0       	rjmp	.+14     	; 0x10f4 <transmitString_F+0x12>
//***************************************************
//Function to transmit a single byte
//***************************************************
void transmitByte( unsigned char data )
{
	while ( !(UCSR1A & (1<<UDRE1)) )
    10e6:	80 91 9b 00 	lds	r24, 0x009B
    10ea:	85 ff       	sbrs	r24, 5
    10ec:	fc cf       	rjmp	.-8      	; 0x10e6 <transmitString_F+0x4>
//Function to transmit a string in Flash
//***************************************************
void transmitString_F(char* string)
{
  while (pgm_read_byte(&(*string)))
   transmitByte(pgm_read_byte(&(*string++)));
    10ee:	31 96       	adiw	r30, 0x01	; 1
//***************************************************
void transmitByte( unsigned char data )
{
	while ( !(UCSR1A & (1<<UDRE1)) )
		; 			                /* Wait for empty transmit buffer */
	UDR1 = data; 			        /* Start transmition */
    10f0:	90 93 9c 00 	sts	0x009C, r25
//***************************************************
//Function to transmit a string in Flash
//***************************************************
void transmitString_F(char* string)
{
  while (pgm_read_byte(&(*string)))
    10f4:	94 91       	lpm	r25, Z+
    10f6:	99 23       	and	r25, r25
    10f8:	b1 f7       	brne	.-20     	; 0x10e6 <transmitString_F+0x4>
   transmitByte(pgm_read_byte(&(*string++)));
}
    10fa:	08 95       	ret

000010fc <transmitString>:

//***************************************************
//Function to transmit a string in RAM
//***************************************************
void transmitString(char* string)
{
    10fc:	fc 01       	movw	r30, r24
    10fe:	07 c0       	rjmp	.+14     	; 0x110e <__stack+0xf>
//***************************************************
//Function to transmit a single byte
//***************************************************
void transmitByte( unsigned char data )
{
	while ( !(UCSR1A & (1<<UDRE1)) )
    1100:	80 91 9b 00 	lds	r24, 0x009B
    1104:	85 ff       	sbrs	r24, 5
    1106:	fc cf       	rjmp	.-8      	; 0x1100 <__stack+0x1>
//Function to transmit a string in RAM
//***************************************************
void transmitString(char* string)
{
  while (*string)
   transmitByte(*string++);
    1108:	31 96       	adiw	r30, 0x01	; 1
//***************************************************
void transmitByte( unsigned char data )
{
	while ( !(UCSR1A & (1<<UDRE1)) )
		; 			                /* Wait for empty transmit buffer */
	UDR1 = data; 			        /* Start transmition */
    110a:	90 93 9c 00 	sts	0x009C, r25
//***************************************************
//Function to transmit a string in RAM
//***************************************************
void transmitString(char* string)
{
  while (*string)
    110e:	90 81       	ld	r25, Z
    1110:	99 23       	and	r25, r25
    1112:	b1 f7       	brne	.-20     	; 0x1100 <__stack+0x1>
   transmitByte(*string++);
}
    1114:	08 95       	ret

00001116 <__udivmodhi4>:
    1116:	aa 1b       	sub	r26, r26
    1118:	bb 1b       	sub	r27, r27
    111a:	51 e1       	ldi	r21, 0x11	; 17
    111c:	07 c0       	rjmp	.+14     	; 0x112c <__udivmodhi4_ep>

0000111e <__udivmodhi4_loop>:
    111e:	aa 1f       	adc	r26, r26
    1120:	bb 1f       	adc	r27, r27
    1122:	a6 17       	cp	r26, r22
    1124:	b7 07       	cpc	r27, r23
    1126:	10 f0       	brcs	.+4      	; 0x112c <__udivmodhi4_ep>
    1128:	a6 1b       	sub	r26, r22
    112a:	b7 0b       	sbc	r27, r23

0000112c <__udivmodhi4_ep>:
    112c:	88 1f       	adc	r24, r24
    112e:	99 1f       	adc	r25, r25
    1130:	5a 95       	dec	r21
    1132:	a9 f7       	brne	.-22     	; 0x111e <__udivmodhi4_loop>
    1134:	80 95       	com	r24
    1136:	90 95       	com	r25
    1138:	bc 01       	movw	r22, r24
    113a:	cd 01       	movw	r24, r26
    113c:	08 95       	ret

0000113e <__udivmodsi4>:
    113e:	a1 e2       	ldi	r26, 0x21	; 33
    1140:	1a 2e       	mov	r1, r26
    1142:	aa 1b       	sub	r26, r26
    1144:	bb 1b       	sub	r27, r27
    1146:	fd 01       	movw	r30, r26
    1148:	0d c0       	rjmp	.+26     	; 0x1164 <__udivmodsi4_ep>

0000114a <__udivmodsi4_loop>:
    114a:	aa 1f       	adc	r26, r26
    114c:	bb 1f       	adc	r27, r27
    114e:	ee 1f       	adc	r30, r30
    1150:	ff 1f       	adc	r31, r31
    1152:	a2 17       	cp	r26, r18
    1154:	b3 07       	cpc	r27, r19
    1156:	e4 07       	cpc	r30, r20
    1158:	f5 07       	cpc	r31, r21
    115a:	20 f0       	brcs	.+8      	; 0x1164 <__udivmodsi4_ep>
    115c:	a2 1b       	sub	r26, r18
    115e:	b3 0b       	sbc	r27, r19
    1160:	e4 0b       	sbc	r30, r20
    1162:	f5 0b       	sbc	r31, r21

00001164 <__udivmodsi4_ep>:
    1164:	66 1f       	adc	r22, r22
    1166:	77 1f       	adc	r23, r23
    1168:	88 1f       	adc	r24, r24
    116a:	99 1f       	adc	r25, r25
    116c:	1a 94       	dec	r1
    116e:	69 f7       	brne	.-38     	; 0x114a <__udivmodsi4_loop>
    1170:	60 95       	com	r22
    1172:	70 95       	com	r23
    1174:	80 95       	com	r24
    1176:	90 95       	com	r25
    1178:	9b 01       	movw	r18, r22
    117a:	ac 01       	movw	r20, r24
    117c:	bd 01       	movw	r22, r26
    117e:	cf 01       	movw	r24, r30
    1180:	08 95       	ret

00001182 <_exit>:
    1182:	f8 94       	cli

00001184 <__stop_program>:
    1184:	ff cf       	rjmp	.-2      	; 0x1184 <__stop_program>
