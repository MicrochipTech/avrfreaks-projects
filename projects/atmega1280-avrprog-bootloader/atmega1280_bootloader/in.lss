
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000588  0001f800  0001f800  00000074  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .trampolines  00000000  0001fd88  0001fd88  000005fc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000100  00800200  0001fd88  000005fc  2**0
                  ALLOC
  3 .stab         00000e64  00000000  00000000  000005fc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009c4  00000000  00000000  00001460  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0001f800 <__ctors_end>:
   1f800:	11 24       	eor	r1, r1
   1f802:	1f be       	out	0x3f, r1	; 63
   1f804:	cf ef       	ldi	r28, 0xFF	; 255
   1f806:	d1 e2       	ldi	r29, 0x21	; 33
   1f808:	de bf       	out	0x3e, r29	; 62
   1f80a:	cd bf       	out	0x3d, r28	; 61

0001f80c <__do_copy_data>:
   1f80c:	12 e0       	ldi	r17, 0x02	; 2
   1f80e:	a0 e0       	ldi	r26, 0x00	; 0
   1f810:	b2 e0       	ldi	r27, 0x02	; 2
   1f812:	e8 e8       	ldi	r30, 0x88	; 136
   1f814:	fd ef       	ldi	r31, 0xFD	; 253
   1f816:	01 e0       	ldi	r16, 0x01	; 1
   1f818:	0b bf       	out	0x3b, r16	; 59
   1f81a:	02 c0       	rjmp	.+4      	; 0x1f820 <__do_copy_data+0x14>
   1f81c:	07 90       	elpm	r0, Z+
   1f81e:	0d 92       	st	X+, r0
   1f820:	a0 30       	cpi	r26, 0x00	; 0
   1f822:	b1 07       	cpc	r27, r17
   1f824:	d9 f7       	brne	.-10     	; 0x1f81c <__do_copy_data+0x10>

0001f826 <__do_clear_bss>:
   1f826:	13 e0       	ldi	r17, 0x03	; 3
   1f828:	a0 e0       	ldi	r26, 0x00	; 0
   1f82a:	b2 e0       	ldi	r27, 0x02	; 2
   1f82c:	01 c0       	rjmp	.+2      	; 0x1f830 <.do_clear_bss_start>

0001f82e <.do_clear_bss_loop>:
   1f82e:	1d 92       	st	X+, r1

0001f830 <.do_clear_bss_start>:
   1f830:	a0 30       	cpi	r26, 0x00	; 0
   1f832:	b1 07       	cpc	r27, r17
   1f834:	e1 f7       	brne	.-8      	; 0x1f82e <.do_clear_bss_loop>
   1f836:	0e 94 54 fc 	call	0x1f8a8	; 0x1f8a8 <main>
   1f83a:	0c 94 c2 fe 	jmp	0x1fd84	; 0x1fd84 <_exit>

0001f83e <__bad_interrupt>:
   1f83e:	0c 94 21 fc 	jmp	0x1f842	; 0x1f842 <__vector_default>

0001f842 <__vector_default>:

#if defined(BOOTLOADERHASNOVECTORS)
#warning "This Bootloader does not link interrupt vectors - see makefile"
/* make the linker happy - it wants to see __vector_default */
// void __vector_default(void) { ; }
void __vector_default(void) { ; }
   1f842:	08 95       	ret

0001f844 <send_boot>:
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1f844:	80 91 c0 00 	lds	r24, 0x00C0
   1f848:	85 ff       	sbrs	r24, 5
   1f84a:	fc cf       	rjmp	.-8      	; 0x1f844 <send_boot>
	UART_DATA = data;
   1f84c:	81 e4       	ldi	r24, 0x41	; 65
   1f84e:	80 93 c6 00 	sts	0x00C6, r24
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1f852:	80 91 c0 00 	lds	r24, 0x00C0
   1f856:	85 ff       	sbrs	r24, 5
   1f858:	fc cf       	rjmp	.-8      	; 0x1f852 <send_boot+0xe>
	UART_DATA = data;
   1f85a:	86 e5       	ldi	r24, 0x56	; 86
   1f85c:	80 93 c6 00 	sts	0x00C6, r24
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1f860:	80 91 c0 00 	lds	r24, 0x00C0
   1f864:	85 ff       	sbrs	r24, 5
   1f866:	fc cf       	rjmp	.-8      	; 0x1f860 <send_boot+0x1c>
	UART_DATA = data;
   1f868:	82 e5       	ldi	r24, 0x52	; 82
   1f86a:	80 93 c6 00 	sts	0x00C6, r24
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1f86e:	80 91 c0 00 	lds	r24, 0x00C0
   1f872:	85 ff       	sbrs	r24, 5
   1f874:	fc cf       	rjmp	.-8      	; 0x1f86e <send_boot+0x2a>
	UART_DATA = data;
   1f876:	82 e4       	ldi	r24, 0x42	; 66
   1f878:	80 93 c6 00 	sts	0x00C6, r24
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1f87c:	80 91 c0 00 	lds	r24, 0x00C0
   1f880:	85 ff       	sbrs	r24, 5
   1f882:	fc cf       	rjmp	.-8      	; 0x1f87c <send_boot+0x38>
	UART_DATA = data;
   1f884:	8f e4       	ldi	r24, 0x4F	; 79
   1f886:	80 93 c6 00 	sts	0x00C6, r24
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1f88a:	80 91 c0 00 	lds	r24, 0x00C0
   1f88e:	85 ff       	sbrs	r24, 5
   1f890:	fc cf       	rjmp	.-8      	; 0x1f88a <send_boot+0x46>
	UART_DATA = data;
   1f892:	8f e4       	ldi	r24, 0x4F	; 79
   1f894:	80 93 c6 00 	sts	0x00C6, r24
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1f898:	80 91 c0 00 	lds	r24, 0x00C0
   1f89c:	85 ff       	sbrs	r24, 5
   1f89e:	fc cf       	rjmp	.-8      	; 0x1f898 <send_boot+0x54>
	UART_DATA = data;
   1f8a0:	84 e5       	ldi	r24, 0x54	; 84
   1f8a2:	80 93 c6 00 	sts	0x00C6, r24
	sendchar('R');
	sendchar('B');
	sendchar('O');
	sendchar('O');
	sendchar('T');
}
   1f8a6:	08 95       	ret

0001f8a8 <main>:

static void (*jump_to_app)(void) = 0x0000;

int main(void)
{
   1f8a8:	2f 92       	push	r2
   1f8aa:	3f 92       	push	r3
   1f8ac:	4f 92       	push	r4
   1f8ae:	5f 92       	push	r5
   1f8b0:	6f 92       	push	r6
   1f8b2:	7f 92       	push	r7
   1f8b4:	8f 92       	push	r8
   1f8b6:	9f 92       	push	r9
   1f8b8:	af 92       	push	r10
   1f8ba:	bf 92       	push	r11
   1f8bc:	cf 92       	push	r12
   1f8be:	df 92       	push	r13
   1f8c0:	ef 92       	push	r14
   1f8c2:	ff 92       	push	r15
   1f8c4:	0f 93       	push	r16
   1f8c6:	1f 93       	push	r17
   1f8c8:	df 93       	push	r29
   1f8ca:	cf 93       	push	r28
   1f8cc:	00 d0       	rcall	.+0      	; 0x1f8ce <main+0x26>
   1f8ce:	0f 92       	push	r0
   1f8d0:	cd b7       	in	r28, 0x3d	; 61
   1f8d2:	de b7       	in	r29, 0x3e	; 62
#ifdef DISABLE_WDT_AT_STARTUP
#ifdef WDT_OFF_SPECIAL
#warning "using target specific watchdog_off"
	bootloader_wdt_off();
#else
	cli();
   1f8d4:	f8 94       	cli
	wdt_reset();
   1f8d6:	a8 95       	wdr
	wdt_disable();
   1f8d8:	88 e1       	ldi	r24, 0x18	; 24
   1f8da:	0f b6       	in	r0, 0x3f	; 63
   1f8dc:	f8 94       	cli
   1f8de:	80 93 60 00 	sts	0x0060, r24
   1f8e2:	10 92 60 00 	sts	0x0060, r1
   1f8e6:	0f be       	out	0x3f, r0	; 63
	
#ifdef START_POWERSAVE
	uint8_t OK = 1;
#endif

	BLDDR  &= ~(1<<BLPNUM);		// set as Input
   1f8e8:	3f 98       	cbi	0x07, 7	; 7
	BLPORT |= (1<<BLPNUM);		// Enable pullup
   1f8ea:	47 9a       	sbi	0x08, 7	; 8

	// Set baud rate
	UART_BAUD_HIGH = (UART_CALC_BAUDRATE(BAUDRATE)>>8) & 0xFF;
   1f8ec:	10 92 c5 00 	sts	0x00C5, r1
	UART_BAUD_LOW = (UART_CALC_BAUDRATE(BAUDRATE) & 0xFF);
   1f8f0:	98 e0       	ldi	r25, 0x08	; 8
   1f8f2:	90 93 c4 00 	sts	0x00C4, r25

#ifdef UART_DOUBLESPEED
	UART_STATUS = ( 1<<UART_DOUBLE );
#endif

	UART_CTRL = UART_CTRL_DATA;
   1f8f6:	80 93 c1 00 	sts	0x00C1, r24
	UART_CTRL2 = UART_CTRL2_DATA;
   1f8fa:	86 e0       	ldi	r24, 0x06	; 6
   1f8fc:	80 93 c2 00 	sts	0x00C2, r24
   1f900:	cc 24       	eor	r12, r12
   1f902:	dd 24       	eor	r13, r13
			if (UART_DATA == START_WAIT_UARTCHAR)
				break;

		if (cnt++ >= WAIT_VALUE) {
			BLPORT &= ~(1<<BLPNUM);		// set to default
			jump_to_app();			// Jump to application sector
   1f904:	ee 24       	eor	r14, r14
   1f906:	ff 24       	eor	r15, r15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
   1f908:	00 e4       	ldi	r16, 0x40	; 64
   1f90a:	1c e9       	ldi	r17, 0x9C	; 156
#elif defined(START_WAIT)

	uint16_t cnt = 0;

	while (1) {
		if (UART_STATUS & (1<<UART_RXREADY))
   1f90c:	80 91 c0 00 	lds	r24, 0x00C0
   1f910:	87 ff       	sbrs	r24, 7
   1f912:	04 c0       	rjmp	.+8      	; 0x1f91c <main+0x74>
			if (UART_DATA == START_WAIT_UARTCHAR)
   1f914:	80 91 c6 00 	lds	r24, 0x00C6
   1f918:	83 35       	cpi	r24, 0x53	; 83
   1f91a:	79 f0       	breq	.+30     	; 0x1f93a <main+0x92>
				break;

		if (cnt++ >= WAIT_VALUE) {
   1f91c:	28 ee       	ldi	r18, 0xE8	; 232
   1f91e:	c2 16       	cp	r12, r18
   1f920:	23 e0       	ldi	r18, 0x03	; 3
   1f922:	d2 06       	cpc	r13, r18
   1f924:	18 f0       	brcs	.+6      	; 0x1f92c <main+0x84>
			BLPORT &= ~(1<<BLPNUM);		// set to default
   1f926:	47 98       	cbi	0x08, 7	; 8
			jump_to_app();			// Jump to application sector
   1f928:	f7 01       	movw	r30, r14
   1f92a:	09 95       	icall
	while (1) {
		if (UART_STATUS & (1<<UART_RXREADY))
			if (UART_DATA == START_WAIT_UARTCHAR)
				break;

		if (cnt++ >= WAIT_VALUE) {
   1f92c:	08 94       	sec
   1f92e:	c1 1c       	adc	r12, r1
   1f930:	d1 1c       	adc	r13, r1
   1f932:	c8 01       	movw	r24, r16
   1f934:	01 97       	sbiw	r24, 0x01	; 1
   1f936:	f1 f7       	brne	.-4      	; 0x1f934 <main+0x8c>
   1f938:	e9 cf       	rjmp	.-46     	; 0x1f90c <main+0x64>
			jump_to_app();			// Jump to application sector
		}

		_delay_ms(10);
	}
	send_boot();
   1f93a:	0e 94 22 fc 	call	0x1f844	; 0x1f844 <send_boot>
   1f93e:	aa 24       	eor	r10, r10
   1f940:	bb 24       	eor	r11, r11
   1f942:	19 82       	std	Y+1, r1	; 0x01
	UART_DATA = data;
}

static uint8_t recvchar(void)
{
	while (!(UART_STATUS & (1<<UART_RXREADY)));
   1f944:	80 91 c0 00 	lds	r24, 0x00C0
   1f948:	87 ff       	sbrs	r24, 7
   1f94a:	fc cf       	rjmp	.-8      	; 0x1f944 <main+0x9c>
	return UART_DATA;
   1f94c:	90 91 c6 00 	lds	r25, 0x00C6
#endif

	for(;;) {
		val = recvchar();
		// Autoincrement?
		if (val == 'a') {
   1f950:	91 36       	cpi	r25, 0x61	; 97
   1f952:	31 f4       	brne	.+12     	; 0x1f960 <main+0xb8>
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1f954:	80 91 c0 00 	lds	r24, 0x00C0
   1f958:	85 ff       	sbrs	r24, 5
   1f95a:	fc cf       	rjmp	.-8      	; 0x1f954 <main+0xac>
	UART_DATA = data;
   1f95c:	39 e5       	ldi	r19, 0x59	; 89
   1f95e:	c9 c0       	rjmp	.+402    	; 0x1faf2 <main+0x24a>
		// Autoincrement?
		if (val == 'a') {
			sendchar('Y');			// Autoincrement is quicker

		//write address
		} else if (val == 'A') {
   1f960:	91 34       	cpi	r25, 0x41	; 65
   1f962:	c1 f4       	brne	.+48     	; 0x1f994 <main+0xec>
	UART_DATA = data;
}

static uint8_t recvchar(void)
{
	while (!(UART_STATUS & (1<<UART_RXREADY)));
   1f964:	80 91 c0 00 	lds	r24, 0x00C0
   1f968:	87 ff       	sbrs	r24, 7
   1f96a:	fc cf       	rjmp	.-8      	; 0x1f964 <main+0xbc>
	return UART_DATA;
   1f96c:	20 91 c6 00 	lds	r18, 0x00C6
	UART_DATA = data;
}

static uint8_t recvchar(void)
{
	while (!(UART_STATUS & (1<<UART_RXREADY)));
   1f970:	80 91 c0 00 	lds	r24, 0x00C0
   1f974:	87 ff       	sbrs	r24, 7
   1f976:	fc cf       	rjmp	.-8      	; 0x1f970 <main+0xc8>
	return UART_DATA;
   1f978:	90 91 c6 00 	lds	r25, 0x00C6
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1f97c:	80 91 c0 00 	lds	r24, 0x00C0
   1f980:	85 ff       	sbrs	r24, 5
   1f982:	fc cf       	rjmp	.-8      	; 0x1f97c <main+0xd4>
			sendchar('Y');			// Autoincrement is quicker

		//write address
		} else if (val == 'A') {
			address = recvchar();		//read address 8 MSB
			address = (address<<8) | recvchar();
   1f984:	32 2e       	mov	r3, r18
   1f986:	22 24       	eor	r2, r2
   1f988:	a9 2e       	mov	r10, r25
   1f98a:	bb 24       	eor	r11, r11
   1f98c:	a2 28       	or	r10, r2
   1f98e:	b3 28       	or	r11, r3
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
	UART_DATA = data;
   1f990:	4d e0       	ldi	r20, 0x0D	; 13
   1f992:	d4 c1       	rjmp	.+936    	; 0x1fd3c <main+0x494>
			address = recvchar();		//read address 8 MSB
			address = (address<<8) | recvchar();
			sendchar('\r');

		// Buffer load support
		} else if (val == 'b') {
   1f994:	92 36       	cpi	r25, 0x62	; 98
   1f996:	99 f4       	brne	.+38     	; 0x1f9be <main+0x116>
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1f998:	80 91 c0 00 	lds	r24, 0x00C0
   1f99c:	85 ff       	sbrs	r24, 5
   1f99e:	fc cf       	rjmp	.-8      	; 0x1f998 <main+0xf0>
	UART_DATA = data;
   1f9a0:	59 e5       	ldi	r21, 0x59	; 89
   1f9a2:	50 93 c6 00 	sts	0x00C6, r21
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1f9a6:	80 91 c0 00 	lds	r24, 0x00C0
   1f9aa:	85 ff       	sbrs	r24, 5
   1f9ac:	fc cf       	rjmp	.-8      	; 0x1f9a6 <main+0xfe>
	UART_DATA = data;
   1f9ae:	61 e0       	ldi	r22, 0x01	; 1
   1f9b0:	60 93 c6 00 	sts	0x00C6, r22
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1f9b4:	80 91 c0 00 	lds	r24, 0x00C0
   1f9b8:	85 ff       	sbrs	r24, 5
   1f9ba:	fc cf       	rjmp	.-8      	; 0x1f9b4 <main+0x10c>
   1f9bc:	6e c1       	rjmp	.+732    	; 0x1fc9a <main+0x3f2>
			sendchar('Y');					// Report buffer load supported
			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
			sendchar(sizeof(gBuffer) & 0xFF);

		// Start buffer load
		} else if (val == 'B') {
   1f9be:	92 34       	cpi	r25, 0x42	; 66
   1f9c0:	09 f0       	breq	.+2      	; 0x1f9c4 <main+0x11c>
   1f9c2:	9f c0       	rjmp	.+318    	; 0x1fb02 <main+0x25a>
	UART_DATA = data;
}

static uint8_t recvchar(void)
{
	while (!(UART_STATUS & (1<<UART_RXREADY)));
   1f9c4:	80 91 c0 00 	lds	r24, 0x00C0
   1f9c8:	87 ff       	sbrs	r24, 7
   1f9ca:	fc cf       	rjmp	.-8      	; 0x1f9c4 <main+0x11c>
	return UART_DATA;
   1f9cc:	90 91 c6 00 	lds	r25, 0x00C6
	UART_DATA = data;
}

static uint8_t recvchar(void)
{
	while (!(UART_STATUS & (1<<UART_RXREADY)));
   1f9d0:	80 91 c0 00 	lds	r24, 0x00C0
   1f9d4:	87 ff       	sbrs	r24, 7
   1f9d6:	fc cf       	rjmp	.-8      	; 0x1f9d0 <main+0x128>
	return UART_DATA;
   1f9d8:	80 91 c6 00 	lds	r24, 0x00C6
			sendchar(sizeof(gBuffer) & 0xFF);

		// Start buffer load
		} else if (val == 'B') {
			pagebuf_t size;
			size = recvchar() << 8;				// Load high byte of buffersize
   1f9dc:	59 2e       	mov	r5, r25
   1f9de:	44 24       	eor	r4, r4
			size |= recvchar();				// Load low byte of buffersize
   1f9e0:	e8 2f       	mov	r30, r24
   1f9e2:	f0 e0       	ldi	r31, 0x00	; 0
   1f9e4:	e4 29       	or	r30, r4
   1f9e6:	f5 29       	or	r31, r5
   1f9e8:	fb 83       	std	Y+3, r31	; 0x03
   1f9ea:	ea 83       	std	Y+2, r30	; 0x02
	UART_DATA = data;
}

static uint8_t recvchar(void)
{
	while (!(UART_STATUS & (1<<UART_RXREADY)));
   1f9ec:	80 91 c0 00 	lds	r24, 0x00C0
   1f9f0:	87 ff       	sbrs	r24, 7
   1f9f2:	fc cf       	rjmp	.-8      	; 0x1f9ec <main+0x144>
	return UART_DATA;
   1f9f4:	90 91 c6 00 	lds	r25, 0x00C6
   1f9f8:	20 e0       	ldi	r18, 0x00	; 0
   1f9fa:	30 e0       	ldi	r19, 0x00	; 0
   1f9fc:	e0 e0       	ldi	r30, 0x00	; 0
   1f9fe:	f2 e0       	ldi	r31, 0x02	; 2
{
	pagebuf_t cnt;
	uint8_t *tmp = gBuffer;

	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) {
		*tmp++ = (cnt < size) ? recvchar() : 0xFF;
   1fa00:	4a 81       	ldd	r20, Y+2	; 0x02
   1fa02:	5b 81       	ldd	r21, Y+3	; 0x03
   1fa04:	24 17       	cp	r18, r20
   1fa06:	35 07       	cpc	r19, r21
   1fa08:	10 f0       	brcs	.+4      	; 0x1fa0e <main+0x166>
   1fa0a:	8f ef       	ldi	r24, 0xFF	; 255
   1fa0c:	06 c0       	rjmp	.+12     	; 0x1fa1a <main+0x172>
	UART_DATA = data;
}

static uint8_t recvchar(void)
{
	while (!(UART_STATUS & (1<<UART_RXREADY)));
   1fa0e:	80 91 c0 00 	lds	r24, 0x00C0
   1fa12:	87 ff       	sbrs	r24, 7
   1fa14:	fc cf       	rjmp	.-8      	; 0x1fa0e <main+0x166>
	return UART_DATA;
   1fa16:	80 91 c6 00 	lds	r24, 0x00C6
{
	pagebuf_t cnt;
	uint8_t *tmp = gBuffer;

	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) {
		*tmp++ = (cnt < size) ? recvchar() : 0xFF;
   1fa1a:	80 83       	st	Z, r24
static inline void recvBuffer(pagebuf_t size)
{
	pagebuf_t cnt;
	uint8_t *tmp = gBuffer;

	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) {
   1fa1c:	2f 5f       	subi	r18, 0xFF	; 255
   1fa1e:	3f 4f       	sbci	r19, 0xFF	; 255
   1fa20:	51 e0       	ldi	r21, 0x01	; 1
   1fa22:	20 30       	cpi	r18, 0x00	; 0
   1fa24:	35 07       	cpc	r19, r21
   1fa26:	11 f0       	breq	.+4      	; 0x1fa2c <main+0x184>
		*tmp++ = (cnt < size) ? recvchar() : 0xFF;
   1fa28:	31 96       	adiw	r30, 0x01	; 1
   1fa2a:	ea cf       	rjmp	.-44     	; 0x1fa00 <main+0x158>
			size = recvchar() << 8;				// Load high byte of buffersize
			size |= recvchar();				// Load low byte of buffersize
			val = recvchar();				// Load memory type ('E' or 'F')
			recvBuffer(size);

			if (device == DEVTYPE) {
   1fa2c:	69 81       	ldd	r22, Y+1	; 0x01
   1fa2e:	64 34       	cpi	r22, 0x44	; 68
   1fa30:	09 f0       	breq	.+2      	; 0x1fa34 <main+0x18c>
   1fa32:	62 c0       	rjmp	.+196    	; 0x1faf8 <main+0x250>
				if (val == 'F') {
   1fa34:	96 34       	cpi	r25, 0x46	; 70
   1fa36:	09 f0       	breq	.+2      	; 0x1fa3a <main+0x192>
   1fa38:	3c c0       	rjmp	.+120    	; 0x1fab2 <main+0x20a>
	}
}

static inline uint16_t writeFlashPage(uint16_t waddr, pagebuf_t size)
{
	uint32_t pagestart = (uint32_t)waddr<<1;
   1fa3a:	75 01       	movw	r14, r10
   1fa3c:	00 e0       	ldi	r16, 0x00	; 0
   1fa3e:	10 e0       	ldi	r17, 0x00	; 0
   1fa40:	ee 0c       	add	r14, r14
   1fa42:	ff 1c       	adc	r15, r15
   1fa44:	00 1f       	adc	r16, r16
   1fa46:	11 1f       	adc	r17, r17
   1fa48:	a8 01       	movw	r20, r16
   1fa4a:	97 01       	movw	r18, r14
   1fa4c:	a0 e0       	ldi	r26, 0x00	; 0
   1fa4e:	b2 e0       	ldi	r27, 0x02	; 2
	uint32_t baddr = pagestart;
	uint16_t data;
	uint8_t *tmp = gBuffer;

	do {
		data = *tmp++;
   1fa50:	8c 91       	ld	r24, X
   1fa52:	90 e0       	ldi	r25, 0x00	; 0
		data |= *tmp++ << 8;
   1fa54:	11 96       	adiw	r26, 0x01	; 1
   1fa56:	9c 90       	ld	r9, X
   1fa58:	11 97       	sbiw	r26, 0x01	; 1
   1fa5a:	88 24       	eor	r8, r8
   1fa5c:	88 29       	or	r24, r8
   1fa5e:	99 29       	or	r25, r9
}

static void (*jump_to_app)(void) = 0x0000;

int main(void)
{
   1fa60:	12 96       	adiw	r26, 0x02	; 2
	uint8_t *tmp = gBuffer;

	do {
		data = *tmp++;
		data |= *tmp++ << 8;
		boot_page_fill(baddr, data);	// call asm routine.
   1fa62:	61 e0       	ldi	r22, 0x01	; 1
   1fa64:	0c 01       	movw	r0, r24
   1fa66:	f9 01       	movw	r30, r18
   1fa68:	40 93 5b 00 	sts	0x005B, r20
   1fa6c:	60 93 57 00 	sts	0x0057, r22
   1fa70:	e8 95       	spm
   1fa72:	11 24       	eor	r1, r1

		baddr += 2;			// Select next word in memory
   1fa74:	2e 5f       	subi	r18, 0xFE	; 254
   1fa76:	3f 4f       	sbci	r19, 0xFF	; 255
   1fa78:	4f 4f       	sbci	r20, 0xFF	; 255
   1fa7a:	5f 4f       	sbci	r21, 0xFF	; 255
		size -= 2;			// Reduce number of bytes to write by two
   1fa7c:	8a 81       	ldd	r24, Y+2	; 0x02
   1fa7e:	9b 81       	ldd	r25, Y+3	; 0x03
   1fa80:	02 97       	sbiw	r24, 0x02	; 2
   1fa82:	9b 83       	std	Y+3, r25	; 0x03
   1fa84:	8a 83       	std	Y+2, r24	; 0x02
	} while (size);				// Loop until all bytes written
   1fa86:	89 2b       	or	r24, r25
   1fa88:	19 f7       	brne	.-58     	; 0x1fa50 <main+0x1a8>

	boot_page_write(pagestart);
   1fa8a:	95 e0       	ldi	r25, 0x05	; 5
   1fa8c:	f7 01       	movw	r30, r14
   1fa8e:	00 93 5b 00 	sts	0x005B, r16
   1fa92:	90 93 57 00 	sts	0x0057, r25
   1fa96:	e8 95       	spm
	boot_spm_busy_wait();
   1fa98:	07 b6       	in	r0, 0x37	; 55
   1fa9a:	00 fc       	sbrc	r0, 0
   1fa9c:	fd cf       	rjmp	.-6      	; 0x1fa98 <main+0x1f0>
	boot_rww_enable();		// Re-enable the RWW section
   1fa9e:	e1 e1       	ldi	r30, 0x11	; 17
   1faa0:	e0 93 57 00 	sts	0x0057, r30
   1faa4:	e8 95       	spm

	return baddr>>1;
   1faa6:	56 95       	lsr	r21
   1faa8:	47 95       	ror	r20
   1faaa:	37 95       	ror	r19
   1faac:	27 95       	ror	r18
   1faae:	59 01       	movw	r10, r18
   1fab0:	1b c0       	rjmp	.+54     	; 0x1fae8 <main+0x240>
			recvBuffer(size);

			if (device == DEVTYPE) {
				if (val == 'F') {
					address = writeFlashPage(address, size);
				} else if (val == 'E') {
   1fab2:	95 34       	cpi	r25, 0x45	; 69
   1fab4:	c9 f4       	brne	.+50     	; 0x1fae8 <main+0x240>
   1fab6:	ea 80       	ldd	r14, Y+2	; 0x02
   1fab8:	fb 80       	ldd	r15, Y+3	; 0x03
   1faba:	85 01       	movw	r16, r10
   1fabc:	20 e0       	ldi	r18, 0x00	; 0
   1fabe:	c2 2e       	mov	r12, r18
   1fac0:	22 e0       	ldi	r18, 0x02	; 2
   1fac2:	d2 2e       	mov	r13, r18
static inline uint16_t writeEEpromPage(uint16_t address, pagebuf_t size)
{
	uint8_t *tmp = gBuffer;

	do {
		eeprom_write_byte( (uint8_t*)address, *tmp++ );
   1fac4:	f6 01       	movw	r30, r12
   1fac6:	61 91       	ld	r22, Z+
   1fac8:	6f 01       	movw	r12, r30
   1faca:	c8 01       	movw	r24, r16
   1facc:	0e 94 b4 fe 	call	0x1fd68	; 0x1fd68 <__eewr_byte_m1280>
		address++;			// Select next byte
   1fad0:	0f 5f       	subi	r16, 0xFF	; 255
   1fad2:	1f 4f       	sbci	r17, 0xFF	; 255
		size--;				// Decreas number of bytes to write
   1fad4:	08 94       	sec
   1fad6:	e1 08       	sbc	r14, r1
   1fad8:	f1 08       	sbc	r15, r1
	} while (size);				// Loop until all bytes written
   1fada:	e1 14       	cp	r14, r1
   1fadc:	f1 04       	cpc	r15, r1
   1fade:	91 f7       	brne	.-28     	; 0x1fac4 <main+0x21c>
   1fae0:	2a 81       	ldd	r18, Y+2	; 0x02
   1fae2:	3b 81       	ldd	r19, Y+3	; 0x03
   1fae4:	a2 0e       	add	r10, r18
   1fae6:	b3 1e       	adc	r11, r19
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fae8:	80 91 c0 00 	lds	r24, 0x00C0
   1faec:	85 ff       	sbrs	r24, 5
   1faee:	fc cf       	rjmp	.-8      	; 0x1fae8 <main+0x240>
	UART_DATA = data;
   1faf0:	3d e0       	ldi	r19, 0x0D	; 13
   1faf2:	30 93 c6 00 	sts	0x00C6, r19
   1faf6:	26 cf       	rjmp	.-436    	; 0x1f944 <main+0x9c>
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1faf8:	80 91 c0 00 	lds	r24, 0x00C0
   1fafc:	85 ff       	sbrs	r24, 5
   1fafe:	fc cf       	rjmp	.-8      	; 0x1faf8 <main+0x250>
   1fb00:	cc c0       	rjmp	.+408    	; 0x1fc9a <main+0x3f2>
			} else {
				sendchar(0);
			}

		// Block read
		} else if (val == 'g') {
   1fb02:	97 36       	cpi	r25, 0x67	; 103
   1fb04:	09 f0       	breq	.+2      	; 0x1fb08 <main+0x260>
   1fb06:	67 c0       	rjmp	.+206    	; 0x1fbd6 <main+0x32e>
	UART_DATA = data;
}

static uint8_t recvchar(void)
{
	while (!(UART_STATUS & (1<<UART_RXREADY)));
   1fb08:	80 91 c0 00 	lds	r24, 0x00C0
   1fb0c:	87 ff       	sbrs	r24, 7
   1fb0e:	fc cf       	rjmp	.-8      	; 0x1fb08 <main+0x260>
	return UART_DATA;
   1fb10:	90 91 c6 00 	lds	r25, 0x00C6
	UART_DATA = data;
}

static uint8_t recvchar(void)
{
	while (!(UART_STATUS & (1<<UART_RXREADY)));
   1fb14:	80 91 c0 00 	lds	r24, 0x00C0
   1fb18:	87 ff       	sbrs	r24, 7
   1fb1a:	fc cf       	rjmp	.-8      	; 0x1fb14 <main+0x26c>
	return UART_DATA;
   1fb1c:	80 91 c6 00 	lds	r24, 0x00C6
			}

		// Block read
		} else if (val == 'g') {
			pagebuf_t size;
			size = recvchar() << 8;				// Load high byte of buffersize
   1fb20:	79 2e       	mov	r7, r25
   1fb22:	66 24       	eor	r6, r6
			size |= recvchar();				// Load low byte of buffersize
   1fb24:	c8 2e       	mov	r12, r24
   1fb26:	dd 24       	eor	r13, r13
   1fb28:	c6 28       	or	r12, r6
   1fb2a:	d7 28       	or	r13, r7
	UART_DATA = data;
}

static uint8_t recvchar(void)
{
	while (!(UART_STATUS & (1<<UART_RXREADY)));
   1fb2c:	80 91 c0 00 	lds	r24, 0x00C0
   1fb30:	87 ff       	sbrs	r24, 7
   1fb32:	fc cf       	rjmp	.-8      	; 0x1fb2c <main+0x284>
	return UART_DATA;
   1fb34:	80 91 c6 00 	lds	r24, 0x00C6
			pagebuf_t size;
			size = recvchar() << 8;				// Load high byte of buffersize
			size |= recvchar();				// Load low byte of buffersize
			val = recvchar();				// Get memtype

			if (val == 'F') {
   1fb38:	86 34       	cpi	r24, 0x46	; 70
   1fb3a:	99 f5       	brne	.+102    	; 0x1fba2 <main+0x2fa>
	return address;
}

static inline uint16_t readFlashPage(uint16_t waddr, pagebuf_t size)
{
	uint32_t baddr = (uint32_t)waddr<<1;
   1fb3c:	95 01       	movw	r18, r10
   1fb3e:	40 e0       	ldi	r20, 0x00	; 0
   1fb40:	50 e0       	ldi	r21, 0x00	; 0
   1fb42:	22 0f       	add	r18, r18
   1fb44:	33 1f       	adc	r19, r19
   1fb46:	44 1f       	adc	r20, r20
   1fb48:	55 1f       	adc	r21, r21
#else
		data = pgm_read_word_near(baddr);
#endif
#else
		// don't read bootloader
		if ( baddr < APP_END ) {
   1fb4a:	2f 3f       	cpi	r18, 0xFF	; 255
   1fb4c:	67 ef       	ldi	r22, 0xF7	; 247
   1fb4e:	36 07       	cpc	r19, r22
   1fb50:	61 e0       	ldi	r22, 0x01	; 1
   1fb52:	46 07       	cpc	r20, r22
   1fb54:	60 e0       	ldi	r22, 0x00	; 0
   1fb56:	56 07       	cpc	r21, r22
   1fb58:	18 f0       	brcs	.+6      	; 0x1fb60 <main+0x2b8>
   1fb5a:	6f ef       	ldi	r22, 0xFF	; 255
   1fb5c:	7f ef       	ldi	r23, 0xFF	; 255
   1fb5e:	04 c0       	rjmp	.+8      	; 0x1fb68 <main+0x2c0>
#if defined(RAMPZ)
			data = pgm_read_word_far(baddr);
   1fb60:	4b bf       	out	0x3b, r20	; 59
   1fb62:	f9 01       	movw	r30, r18
   1fb64:	67 91       	elpm	r22, Z+
   1fb66:	76 91       	elpm	r23, Z+
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fb68:	80 91 c0 00 	lds	r24, 0x00C0
   1fb6c:	85 ff       	sbrs	r24, 5
   1fb6e:	fc cf       	rjmp	.-8      	; 0x1fb68 <main+0x2c0>
	UART_DATA = data;
   1fb70:	60 93 c6 00 	sts	0x00C6, r22
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fb74:	80 91 c0 00 	lds	r24, 0x00C0
   1fb78:	85 ff       	sbrs	r24, 5
   1fb7a:	fc cf       	rjmp	.-8      	; 0x1fb74 <main+0x2cc>
	UART_DATA = data;
   1fb7c:	70 93 c6 00 	sts	0x00C6, r23
			data = 0xFFFF; // fake empty
		}
#endif
		sendchar(data);			// send LSB
		sendchar((data >> 8));		// send MSB
		baddr += 2;			// Select next word in memory
   1fb80:	2e 5f       	subi	r18, 0xFE	; 254
   1fb82:	3f 4f       	sbci	r19, 0xFF	; 255
   1fb84:	4f 4f       	sbci	r20, 0xFF	; 255
   1fb86:	5f 4f       	sbci	r21, 0xFF	; 255
		size -= 2;			// Subtract two bytes from number of bytes to read
   1fb88:	8e ef       	ldi	r24, 0xFE	; 254
   1fb8a:	9f ef       	ldi	r25, 0xFF	; 255
   1fb8c:	c8 0e       	add	r12, r24
   1fb8e:	d9 1e       	adc	r13, r25
	} while (size);				// Repeat until block has been read
   1fb90:	c1 14       	cp	r12, r1
   1fb92:	d1 04       	cpc	r13, r1
   1fb94:	d1 f6       	brne	.-76     	; 0x1fb4a <main+0x2a2>

	return baddr>>1;
   1fb96:	56 95       	lsr	r21
   1fb98:	47 95       	ror	r20
   1fb9a:	37 95       	ror	r19
   1fb9c:	27 95       	ror	r18
   1fb9e:	59 01       	movw	r10, r18
   1fba0:	d1 ce       	rjmp	.-606    	; 0x1f944 <main+0x9c>
			size |= recvchar();				// Load low byte of buffersize
			val = recvchar();				// Get memtype

			if (val == 'F') {
				address = readFlashPage(address, size);
			} else if (val == 'E') {
   1fba2:	85 34       	cpi	r24, 0x45	; 69
   1fba4:	09 f0       	breq	.+2      	; 0x1fba8 <main+0x300>
   1fba6:	ce ce       	rjmp	.-612    	; 0x1f944 <main+0x9c>
   1fba8:	76 01       	movw	r14, r12
   1fbaa:	85 01       	movw	r16, r10
}

static inline uint16_t readEEpromPage(uint16_t address, pagebuf_t size)
{
	do {
		sendchar( eeprom_read_byte( (uint8_t*)address ) );
   1fbac:	c8 01       	movw	r24, r16
   1fbae:	0e 94 ac fe 	call	0x1fd58	; 0x1fd58 <__eerd_byte_m1280>
   1fbb2:	98 2f       	mov	r25, r24
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fbb4:	80 91 c0 00 	lds	r24, 0x00C0
   1fbb8:	85 ff       	sbrs	r24, 5
   1fbba:	fc cf       	rjmp	.-8      	; 0x1fbb4 <main+0x30c>
	UART_DATA = data;
   1fbbc:	90 93 c6 00 	sts	0x00C6, r25

static inline uint16_t readEEpromPage(uint16_t address, pagebuf_t size)
{
	do {
		sendchar( eeprom_read_byte( (uint8_t*)address ) );
		address++;
   1fbc0:	0f 5f       	subi	r16, 0xFF	; 255
   1fbc2:	1f 4f       	sbci	r17, 0xFF	; 255
		size--;				// Decrease number of bytes to read
   1fbc4:	08 94       	sec
   1fbc6:	e1 08       	sbc	r14, r1
   1fbc8:	f1 08       	sbc	r15, r1
	} while (size);				// Repeat until block has been read
   1fbca:	e1 14       	cp	r14, r1
   1fbcc:	f1 04       	cpc	r15, r1
   1fbce:	71 f7       	brne	.-36     	; 0x1fbac <main+0x304>
   1fbd0:	ac 0c       	add	r10, r12
   1fbd2:	bd 1c       	adc	r11, r13
   1fbd4:	b7 ce       	rjmp	.-658    	; 0x1f944 <main+0x9c>
			} else if (val == 'E') {
				address = readEEpromPage(address, size);
			}

		// Chip erase
 		} else if (val == 'e') {
   1fbd6:	95 36       	cpi	r25, 0x65	; 101
   1fbd8:	39 f5       	brne	.+78     	; 0x1fc28 <main+0x380>
			if (device == DEVTYPE) {
   1fbda:	99 81       	ldd	r25, Y+1	; 0x01
   1fbdc:	94 34       	cpi	r25, 0x44	; 68
   1fbde:	f1 f4       	brne	.+60     	; 0x1fc1c <main+0x374>
   1fbe0:	80 e0       	ldi	r24, 0x00	; 0
   1fbe2:	90 e0       	ldi	r25, 0x00	; 0
   1fbe4:	a0 e0       	ldi	r26, 0x00	; 0
   1fbe6:	b0 e0       	ldi	r27, 0x00	; 0
static inline void eraseFlash(void)
{
	// erase only main section (bootloader protection)
	uint32_t addr = 0;
	while (APP_END > addr) {
		boot_page_erase(addr);		// Perform page erase
   1fbe8:	23 e0       	ldi	r18, 0x03	; 3
   1fbea:	fc 01       	movw	r30, r24
   1fbec:	a0 93 5b 00 	sts	0x005B, r26
   1fbf0:	20 93 57 00 	sts	0x0057, r18
   1fbf4:	e8 95       	spm
		boot_spm_busy_wait();		// Wait until the memory is erased.
   1fbf6:	07 b6       	in	r0, 0x37	; 55
   1fbf8:	00 fc       	sbrc	r0, 0
   1fbfa:	fd cf       	rjmp	.-6      	; 0x1fbf6 <main+0x34e>
		addr += SPM_PAGESIZE;
   1fbfc:	80 50       	subi	r24, 0x00	; 0
   1fbfe:	9f 4f       	sbci	r25, 0xFF	; 255
   1fc00:	af 4f       	sbci	r26, 0xFF	; 255
   1fc02:	bf 4f       	sbci	r27, 0xFF	; 255

static inline void eraseFlash(void)
{
	// erase only main section (bootloader protection)
	uint32_t addr = 0;
	while (APP_END > addr) {
   1fc04:	80 30       	cpi	r24, 0x00	; 0
   1fc06:	38 ef       	ldi	r19, 0xF8	; 248
   1fc08:	93 07       	cpc	r25, r19
   1fc0a:	31 e0       	ldi	r19, 0x01	; 1
   1fc0c:	a3 07       	cpc	r26, r19
   1fc0e:	30 e0       	ldi	r19, 0x00	; 0
   1fc10:	b3 07       	cpc	r27, r19
   1fc12:	51 f7       	brne	.-44     	; 0x1fbe8 <main+0x340>
		boot_page_erase(addr);		// Perform page erase
		boot_spm_busy_wait();		// Wait until the memory is erased.
		addr += SPM_PAGESIZE;
	}
	boot_rww_enable();
   1fc14:	41 e1       	ldi	r20, 0x11	; 17
   1fc16:	40 93 57 00 	sts	0x0057, r20
   1fc1a:	e8 95       	spm
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fc1c:	80 91 c0 00 	lds	r24, 0x00C0
   1fc20:	85 ff       	sbrs	r24, 5
   1fc22:	fc cf       	rjmp	.-8      	; 0x1fc1c <main+0x374>
	UART_DATA = data;
   1fc24:	5d e0       	ldi	r21, 0x0D	; 13
   1fc26:	95 c0       	rjmp	.+298    	; 0x1fd52 <main+0x4aa>
				eraseFlash();
			}
			sendchar('\r');

		// Exit upgrade
		} else if (val == 'E') {
   1fc28:	95 34       	cpi	r25, 0x45	; 69
   1fc2a:	89 f4       	brne	.+34     	; 0x1fc4e <main+0x3a6>
			wdt_enable(EXIT_WDT_TIME); // Enable Watchdog Timer to give reset
   1fc2c:	88 e1       	ldi	r24, 0x18	; 24
   1fc2e:	90 e0       	ldi	r25, 0x00	; 0
   1fc30:	ec e0       	ldi	r30, 0x0C	; 12
   1fc32:	0f b6       	in	r0, 0x3f	; 63
   1fc34:	f8 94       	cli
   1fc36:	a8 95       	wdr
   1fc38:	80 93 60 00 	sts	0x0060, r24
   1fc3c:	0f be       	out	0x3f, r0	; 63
   1fc3e:	e0 93 60 00 	sts	0x0060, r30
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fc42:	80 91 c0 00 	lds	r24, 0x00C0
   1fc46:	85 ff       	sbrs	r24, 5
   1fc48:	fc cf       	rjmp	.-8      	; 0x1fc42 <main+0x39a>
	UART_DATA = data;
   1fc4a:	fd e0       	ldi	r31, 0x0D	; 13
   1fc4c:	5f c0       	rjmp	.+190    	; 0x1fd0c <main+0x464>
				boot_spm_busy_wait();
			}
			sendchar('\r');
#endif
		// Enter programming mode
		} else if (val == 'P') {
   1fc4e:	90 35       	cpi	r25, 0x50	; 80
   1fc50:	41 f4       	brne	.+16     	; 0x1fc62 <main+0x3ba>
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fc52:	80 91 c0 00 	lds	r24, 0x00C0
   1fc56:	85 ff       	sbrs	r24, 5
   1fc58:	fc cf       	rjmp	.-8      	; 0x1fc52 <main+0x3aa>
	UART_DATA = data;
   1fc5a:	2d e0       	ldi	r18, 0x0D	; 13
   1fc5c:	20 93 c6 00 	sts	0x00C6, r18
   1fc60:	71 ce       	rjmp	.-798    	; 0x1f944 <main+0x9c>
		// Enter programming mode
		} else if (val == 'P') {
			sendchar('\r');

		// Leave programming mode
		} else if (val == 'L') {
   1fc62:	9c 34       	cpi	r25, 0x4C	; 76
   1fc64:	29 f4       	brne	.+10     	; 0x1fc70 <main+0x3c8>
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fc66:	80 91 c0 00 	lds	r24, 0x00C0
   1fc6a:	85 ff       	sbrs	r24, 5
   1fc6c:	fc cf       	rjmp	.-8      	; 0x1fc66 <main+0x3be>
   1fc6e:	40 cf       	rjmp	.-384    	; 0x1faf0 <main+0x248>
		// Leave programming mode
		} else if (val == 'L') {
			sendchar('\r');

		// return programmer type
		} else if (val == 'p') {
   1fc70:	90 37       	cpi	r25, 0x70	; 112
   1fc72:	31 f4       	brne	.+12     	; 0x1fc80 <main+0x3d8>
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fc74:	80 91 c0 00 	lds	r24, 0x00C0
   1fc78:	85 ff       	sbrs	r24, 5
   1fc7a:	fc cf       	rjmp	.-8      	; 0x1fc74 <main+0x3cc>
	UART_DATA = data;
   1fc7c:	43 e5       	ldi	r20, 0x53	; 83
   1fc7e:	5e c0       	rjmp	.+188    	; 0x1fd3c <main+0x494>
		} else if (val == 'Q') {
			sendchar(read_fuse_lock(GET_EXTENDED_FUSE_BITS));
#endif

		// Return device type
		} else if (val == 't') {
   1fc80:	94 37       	cpi	r25, 0x74	; 116
   1fc82:	71 f4       	brne	.+28     	; 0x1fca0 <main+0x3f8>
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fc84:	80 91 c0 00 	lds	r24, 0x00C0
   1fc88:	85 ff       	sbrs	r24, 5
   1fc8a:	fc cf       	rjmp	.-8      	; 0x1fc84 <main+0x3dc>
	UART_DATA = data;
   1fc8c:	54 e4       	ldi	r21, 0x44	; 68
   1fc8e:	50 93 c6 00 	sts	0x00C6, r21
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fc92:	80 91 c0 00 	lds	r24, 0x00C0
   1fc96:	85 ff       	sbrs	r24, 5
   1fc98:	fc cf       	rjmp	.-8      	; 0x1fc92 <main+0x3ea>
	UART_DATA = data;
   1fc9a:	10 92 c6 00 	sts	0x00C6, r1
   1fc9e:	52 ce       	rjmp	.-860    	; 0x1f944 <main+0x9c>
		} else if (val == 't') {
			sendchar(DEVTYPE);
			sendchar(0);

		// clear and set LED ignored
		} else if ((val == 'x') || (val == 'y')) {
   1fca0:	89 2f       	mov	r24, r25
   1fca2:	88 57       	subi	r24, 0x78	; 120
   1fca4:	82 30       	cpi	r24, 0x02	; 2
   1fca6:	70 f4       	brcc	.+28     	; 0x1fcc4 <main+0x41c>
	UART_DATA = data;
}

static uint8_t recvchar(void)
{
	while (!(UART_STATUS & (1<<UART_RXREADY)));
   1fca8:	80 91 c0 00 	lds	r24, 0x00C0
   1fcac:	87 ff       	sbrs	r24, 7
   1fcae:	fc cf       	rjmp	.-8      	; 0x1fca8 <main+0x400>
	return UART_DATA;
   1fcb0:	80 91 c6 00 	lds	r24, 0x00C6
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fcb4:	80 91 c0 00 	lds	r24, 0x00C0
   1fcb8:	85 ff       	sbrs	r24, 5
   1fcba:	fc cf       	rjmp	.-8      	; 0x1fcb4 <main+0x40c>
	UART_DATA = data;
   1fcbc:	6d e0       	ldi	r22, 0x0D	; 13
   1fcbe:	60 93 c6 00 	sts	0x00C6, r22
   1fcc2:	40 ce       	rjmp	.-896    	; 0x1f944 <main+0x9c>
		} else if ((val == 'x') || (val == 'y')) {
			recvchar();
			sendchar('\r');

		// set device
		} else if (val == 'T') {
   1fcc4:	94 35       	cpi	r25, 0x54	; 84
   1fcc6:	79 f4       	brne	.+30     	; 0x1fce6 <main+0x43e>
	UART_DATA = data;
}

static uint8_t recvchar(void)
{
	while (!(UART_STATUS & (1<<UART_RXREADY)));
   1fcc8:	80 91 c0 00 	lds	r24, 0x00C0
   1fccc:	87 ff       	sbrs	r24, 7
   1fcce:	fc cf       	rjmp	.-8      	; 0x1fcc8 <main+0x420>
	return UART_DATA;
   1fcd0:	80 91 c6 00 	lds	r24, 0x00C6
   1fcd4:	89 83       	std	Y+1, r24	; 0x01
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fcd6:	80 91 c0 00 	lds	r24, 0x00C0
   1fcda:	85 ff       	sbrs	r24, 5
   1fcdc:	fc cf       	rjmp	.-8      	; 0x1fcd6 <main+0x42e>
	UART_DATA = data;
   1fcde:	9d e0       	ldi	r25, 0x0D	; 13
   1fce0:	90 93 c6 00 	sts	0x00C6, r25
   1fce4:	2f ce       	rjmp	.-930    	; 0x1f944 <main+0x9c>
		} else if (val == 'T') {
			device = recvchar();
			sendchar('\r');

		// Return software identifier
		} else if (val == 'S') {
   1fce6:	93 35       	cpi	r25, 0x53	; 83
   1fce8:	19 f4       	brne	.+6      	; 0x1fcf0 <main+0x448>
			send_boot();
   1fcea:	0e 94 22 fc 	call	0x1f844	; 0x1f844 <send_boot>
   1fcee:	2a ce       	rjmp	.-940    	; 0x1f944 <main+0x9c>

		// Return Software Version
		} else if (val == 'V') {
   1fcf0:	96 35       	cpi	r25, 0x56	; 86
   1fcf2:	79 f4       	brne	.+30     	; 0x1fd12 <main+0x46a>
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fcf4:	80 91 c0 00 	lds	r24, 0x00C0
   1fcf8:	85 ff       	sbrs	r24, 5
   1fcfa:	fc cf       	rjmp	.-8      	; 0x1fcf4 <main+0x44c>
	UART_DATA = data;
   1fcfc:	e0 e3       	ldi	r30, 0x30	; 48
   1fcfe:	e0 93 c6 00 	sts	0x00C6, r30
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fd02:	80 91 c0 00 	lds	r24, 0x00C0
   1fd06:	85 ff       	sbrs	r24, 5
   1fd08:	fc cf       	rjmp	.-8      	; 0x1fd02 <main+0x45a>
	UART_DATA = data;
   1fd0a:	f8 e3       	ldi	r31, 0x38	; 56
   1fd0c:	f0 93 c6 00 	sts	0x00C6, r31
   1fd10:	19 ce       	rjmp	.-974    	; 0x1f944 <main+0x9c>
			sendchar(VERSION_LOW);

		// Return Signature Bytes (it seems that 
		// AVRProg expects the "Atmel-byte" 0x1E last
		// but shows it first in the dialog-window)
		} else if (val == 's') {
   1fd12:	93 37       	cpi	r25, 0x73	; 115
   1fd14:	b1 f4       	brne	.+44     	; 0x1fd42 <main+0x49a>
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fd16:	80 91 c0 00 	lds	r24, 0x00C0
   1fd1a:	85 ff       	sbrs	r24, 5
   1fd1c:	fc cf       	rjmp	.-8      	; 0x1fd16 <main+0x46e>
	UART_DATA = data;
   1fd1e:	23 e0       	ldi	r18, 0x03	; 3
   1fd20:	20 93 c6 00 	sts	0x00C6, r18
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fd24:	80 91 c0 00 	lds	r24, 0x00C0
   1fd28:	85 ff       	sbrs	r24, 5
   1fd2a:	fc cf       	rjmp	.-8      	; 0x1fd24 <main+0x47c>
	UART_DATA = data;
   1fd2c:	37 e9       	ldi	r19, 0x97	; 151
   1fd2e:	30 93 c6 00 	sts	0x00C6, r19
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fd32:	80 91 c0 00 	lds	r24, 0x00C0
   1fd36:	85 ff       	sbrs	r24, 5
   1fd38:	fc cf       	rjmp	.-8      	; 0x1fd32 <main+0x48a>
	UART_DATA = data;
   1fd3a:	4e e1       	ldi	r20, 0x1E	; 30
   1fd3c:	40 93 c6 00 	sts	0x00C6, r20
   1fd40:	01 ce       	rjmp	.-1022   	; 0x1f944 <main+0x9c>
			sendchar(SIG_BYTE3);
			sendchar(SIG_BYTE2);
			sendchar(SIG_BYTE1);

		/* ESC */
		} else if(val != 0x1b) {
   1fd42:	9b 31       	cpi	r25, 0x1B	; 27
   1fd44:	09 f4       	brne	.+2      	; 0x1fd48 <main+0x4a0>
   1fd46:	fe cd       	rjmp	.-1028   	; 0x1f944 <main+0x9c>
void __vector_default(void) { ; }
#endif

static void sendchar(uint8_t data)
{
	while (!(UART_STATUS & (1<<UART_TXREADY)));
   1fd48:	80 91 c0 00 	lds	r24, 0x00C0
   1fd4c:	85 ff       	sbrs	r24, 5
   1fd4e:	fc cf       	rjmp	.-8      	; 0x1fd48 <main+0x4a0>
	UART_DATA = data;
   1fd50:	5f e3       	ldi	r21, 0x3F	; 63
   1fd52:	50 93 c6 00 	sts	0x00C6, r21
   1fd56:	f6 cd       	rjmp	.-1044   	; 0x1f944 <main+0x9c>

0001fd58 <__eerd_byte_m1280>:
   1fd58:	f9 99       	sbic	0x1f, 1	; 31
   1fd5a:	fe cf       	rjmp	.-4      	; 0x1fd58 <__eerd_byte_m1280>
   1fd5c:	92 bd       	out	0x22, r25	; 34
   1fd5e:	81 bd       	out	0x21, r24	; 33
   1fd60:	f8 9a       	sbi	0x1f, 0	; 31
   1fd62:	99 27       	eor	r25, r25
   1fd64:	80 b5       	in	r24, 0x20	; 32
   1fd66:	08 95       	ret

0001fd68 <__eewr_byte_m1280>:
   1fd68:	26 2f       	mov	r18, r22

0001fd6a <__eewr_r18_m1280>:
   1fd6a:	f9 99       	sbic	0x1f, 1	; 31
   1fd6c:	fe cf       	rjmp	.-4      	; 0x1fd6a <__eewr_r18_m1280>
   1fd6e:	1f ba       	out	0x1f, r1	; 31
   1fd70:	92 bd       	out	0x22, r25	; 34
   1fd72:	81 bd       	out	0x21, r24	; 33
   1fd74:	20 bd       	out	0x20, r18	; 32
   1fd76:	0f b6       	in	r0, 0x3f	; 63
   1fd78:	f8 94       	cli
   1fd7a:	fa 9a       	sbi	0x1f, 2	; 31
   1fd7c:	f9 9a       	sbi	0x1f, 1	; 31
   1fd7e:	0f be       	out	0x3f, r0	; 63
   1fd80:	01 96       	adiw	r24, 0x01	; 1
   1fd82:	08 95       	ret

0001fd84 <_exit>:
   1fd84:	f8 94       	cli

0001fd86 <__stop_program>:
   1fd86:	ff cf       	rjmp	.-2      	; 0x1fd86 <__stop_program>
