
lcd.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000f98  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000008a  00800060  00000f98  0000102c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000001d  008000ea  008000ea  000010b6  2**0
                  ALLOC
  3 .debug_aranges 000000a0  00000000  00000000  000010b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000004e8  00000000  00000000  00001156  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001249  00000000  00000000  0000163e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000006e2  00000000  00000000  00002887  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001253  00000000  00000000  00002f69  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000400  00000000  00000000  000041bc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000005c3  00000000  00000000  000045bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000891  00000000  00000000  00004b7f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000048  00000000  00000000  00005410  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__ctors_end>
   4:	0c 94 99 00 	jmp	0x132	; 0x132 <__bad_interrupt>
   8:	0c 94 99 00 	jmp	0x132	; 0x132 <__bad_interrupt>
   c:	0c 94 99 00 	jmp	0x132	; 0x132 <__bad_interrupt>
  10:	0c 94 19 06 	jmp	0xc32	; 0xc32 <__vector_4>
  14:	0c 94 25 05 	jmp	0xa4a	; 0xa4a <__vector_5>
  18:	0c 94 ec 05 	jmp	0xbd8	; 0xbd8 <__vector_6>
  1c:	0c 94 92 05 	jmp	0xb24	; 0xb24 <__vector_7>
  20:	0c 94 bf 05 	jmp	0xb7e	; 0xb7e <__vector_8>
  24:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__vector_9>
  28:	0c 94 65 05 	jmp	0xaca	; 0xaca <__vector_10>
  2c:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__vector_11>
  30:	0c 94 99 00 	jmp	0x132	; 0x132 <__bad_interrupt>
  34:	0c 94 99 00 	jmp	0x132	; 0x132 <__bad_interrupt>
  38:	0c 94 99 00 	jmp	0x132	; 0x132 <__bad_interrupt>
  3c:	0c 94 99 00 	jmp	0x132	; 0x132 <__bad_interrupt>
  40:	0c 94 99 00 	jmp	0x132	; 0x132 <__bad_interrupt>
  44:	0c 94 99 00 	jmp	0x132	; 0x132 <__bad_interrupt>
  48:	0c 94 99 00 	jmp	0x132	; 0x132 <__bad_interrupt>
  4c:	0c 94 99 00 	jmp	0x132	; 0x132 <__bad_interrupt>
  50:	0c 94 99 00 	jmp	0x132	; 0x132 <__bad_interrupt>

00000054 <LcdCustomChar>:
  54:	00 1f 00 00 00 00 1f 00 00 1f 10 10 10 10 1f 00     ................
  64:	00 1f 18 18 18 18 1f 00 00 1f 1c 1c 1c 1c 1f 00     ................
  74:	00 1f 1e 1e 1e 1e 1f 00 00 1f 1f 1f 1f 1f 1f 00     ................
  84:	03 07 0f 1f 0f 07 03 00 00 1f 1f 1f 1f 1f 1f 00     ................
  94:	1b 1b 1b 1b 1b 1b 1b 00 18 1c 1e 1f 1e 1c 18 00     ................
  a4:	00 04 04 0e 0e 1f 1f 00 00 1f 1f 0e 0e 04 04 00     ................
	...
  bc:	00 0e 19 15 13 0e 00 00 00 0e 15 15 15 0e 00 00     ................
  cc:	00 0e 13 15 19 0e 00 00 00 0e 11 1f 11 0e 00 00     ................

000000dc <TimerPrescaleFactor>:
  dc:	00 00 01 00 08 00 40 00 00 01 00 04                 ......@.....

000000e8 <TimerRTCPrescaleFactor>:
  e8:	00 00 01 00 08 00 20 00 40 00 80 00 00 01 00 04     ...... .@.......

000000f8 <__ctors_end>:
  f8:	11 24       	eor	r1, r1
  fa:	1f be       	out	0x3f, r1	; 63
  fc:	cf e5       	ldi	r28, 0x5F	; 95
  fe:	d8 e0       	ldi	r29, 0x08	; 8
 100:	de bf       	out	0x3e, r29	; 62
 102:	cd bf       	out	0x3d, r28	; 61

00000104 <__do_copy_data>:
 104:	10 e0       	ldi	r17, 0x00	; 0
 106:	a0 e6       	ldi	r26, 0x60	; 96
 108:	b0 e0       	ldi	r27, 0x00	; 0
 10a:	e8 e9       	ldi	r30, 0x98	; 152
 10c:	ff e0       	ldi	r31, 0x0F	; 15
 10e:	02 c0       	rjmp	.+4      	; 0x114 <.do_copy_data_start>

00000110 <.do_copy_data_loop>:
 110:	05 90       	lpm	r0, Z+
 112:	0d 92       	st	X+, r0

00000114 <.do_copy_data_start>:
 114:	aa 3e       	cpi	r26, 0xEA	; 234
 116:	b1 07       	cpc	r27, r17
 118:	d9 f7       	brne	.-10     	; 0x110 <.do_copy_data_loop>

0000011a <__do_clear_bss>:
 11a:	11 e0       	ldi	r17, 0x01	; 1
 11c:	aa ee       	ldi	r26, 0xEA	; 234
 11e:	b0 e0       	ldi	r27, 0x00	; 0
 120:	01 c0       	rjmp	.+2      	; 0x124 <.do_clear_bss_start>

00000122 <.do_clear_bss_loop>:
 122:	1d 92       	st	X+, r1

00000124 <.do_clear_bss_start>:
 124:	a7 30       	cpi	r26, 0x07	; 7
 126:	b1 07       	cpc	r27, r17
 128:	e1 f7       	brne	.-8      	; 0x122 <.do_clear_bss_loop>
 12a:	0e 94 9b 00 	call	0x136	; 0x136 <main>
 12e:	0c 94 ca 07 	jmp	0xf94	; 0xf94 <_exit>

00000132 <__bad_interrupt>:
 132:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000136 <main>:
#include "mmc/mmc.h"
#include "mmc/mmcconf.h"
#include "global/global.h"

int main(void)
{
 136:	cf 92       	push	r12
 138:	df 92       	push	r13
 13a:	ef 92       	push	r14
 13c:	ff 92       	push	r15
 13e:	0f 93       	push	r16
 140:	1f 93       	push	r17
 142:	df 93       	push	r29
 144:	cf 93       	push	r28
 146:	cd b7       	in	r28, 0x3d	; 61
 148:	de b7       	in	r29, 0x3e	; 62
 14a:	c0 54       	subi	r28, 0x40	; 64
 14c:	d0 40       	sbci	r29, 0x00	; 0
 14e:	0f b6       	in	r0, 0x3f	; 63
 150:	f8 94       	cli
 152:	de bf       	out	0x3e, r29	; 62
 154:	0f be       	out	0x3f, r0	; 63
 156:	cd bf       	out	0x3d, r28	; 61
	
	u08 i=0;
	u08 buffer[64]="hassan ghorbany";
 158:	de 01       	movw	r26, r28
 15a:	11 96       	adiw	r26, 0x01	; 1
 15c:	e9 ea       	ldi	r30, 0xA9	; 169
 15e:	f0 e0       	ldi	r31, 0x00	; 0
 160:	80 e1       	ldi	r24, 0x10	; 16
 162:	01 90       	ld	r0, Z+
 164:	0d 92       	st	X+, r0
 166:	81 50       	subi	r24, 0x01	; 1
 168:	e1 f7       	brne	.-8      	; 0x162 <main+0x2c>
 16a:	fe 01       	movw	r30, r28
 16c:	71 96       	adiw	r30, 0x11	; 17
 16e:	80 e3       	ldi	r24, 0x30	; 48
 170:	df 01       	movw	r26, r30
 172:	1d 92       	st	X+, r1
 174:	8a 95       	dec	r24
 176:	e9 f7       	brne	.-6      	; 0x172 <main+0x3c>
	
	lcdInit();
 178:	0e 94 be 02 	call	0x57c	; 0x57c <lcdInit>
	lcdClear();
 17c:	0e 94 0e 02 	call	0x41c	; 0x41c <lcdClear>

	lcdPrintData("MMC test",8);
 180:	80 e6       	ldi	r24, 0x60	; 96
 182:	90 e0       	ldi	r25, 0x00	; 0
 184:	68 e0       	ldi	r22, 0x08	; 8
 186:	0e 94 4c 02 	call	0x498	; 0x498 <lcdPrintData>
 18a:	80 e3       	ldi	r24, 0x30	; 48
 18c:	95 e7       	ldi	r25, 0x75	; 117
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 18e:	24 e6       	ldi	r18, 0x64	; 100
 190:	30 e0       	ldi	r19, 0x00	; 0
 192:	f9 01       	movw	r30, r18
 194:	31 97       	sbiw	r30, 0x01	; 1
 196:	f1 f7       	brne	.-4      	; 0x194 <main+0x5e>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 198:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 19a:	d9 f7       	brne	.-10     	; 0x192 <main+0x5c>
	_delay_ms(3000);
    lcdClear();
 19c:	0e 94 0e 02 	call	0x41c	; 0x41c <lcdClear>


	mmcInit();
 1a0:	0e 94 70 07 	call	0xee0	; 0xee0 <mmcInit>
	lcdPrintData("mmc init",8);
 1a4:	89 e6       	ldi	r24, 0x69	; 105
 1a6:	90 e0       	ldi	r25, 0x00	; 0
 1a8:	68 e0       	ldi	r22, 0x08	; 8
 1aa:	0e 94 4c 02 	call	0x498	; 0x498 <lcdPrintData>
 1ae:	80 e1       	ldi	r24, 0x10	; 16
 1b0:	97 e2       	ldi	r25, 0x27	; 39
 1b2:	24 e6       	ldi	r18, 0x64	; 100
 1b4:	30 e0       	ldi	r19, 0x00	; 0
 1b6:	f9 01       	movw	r30, r18
 1b8:	31 97       	sbiw	r30, 0x01	; 1
 1ba:	f1 f7       	brne	.-4      	; 0x1b8 <main+0x82>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 1bc:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 1be:	d9 f7       	brne	.-10     	; 0x1b6 <main+0x80>
	_delay_ms(1000);  
	if (mmcReset()==0)
 1c0:	0e 94 36 07 	call	0xe6c	; 0xe6c <mmcReset>
 1c4:	88 23       	and	r24, r24
 1c6:	41 f4       	brne	.+16     	; 0x1d8 <main+0xa2>
	{
		lcdGotoXY(10,1);
 1c8:	8a e0       	ldi	r24, 0x0A	; 10
 1ca:	61 e0       	ldi	r22, 0x01	; 1
 1cc:	0e 94 12 02 	call	0x424	; 0x424 <lcdGotoXY>
		lcdPrintData("success",7);
 1d0:	82 e7       	ldi	r24, 0x72	; 114
 1d2:	90 e0       	ldi	r25, 0x00	; 0
 1d4:	67 e0       	ldi	r22, 0x07	; 7
 1d6:	07 c0       	rjmp	.+14     	; 0x1e6 <main+0xb0>
	}
	else 
	{
		lcdGotoXY(10,1);
 1d8:	8a e0       	ldi	r24, 0x0A	; 10
 1da:	61 e0       	ldi	r22, 0x01	; 1
 1dc:	0e 94 12 02 	call	0x424	; 0x424 <lcdGotoXY>
		lcdPrintData("faild",5);
 1e0:	8a e7       	ldi	r24, 0x7A	; 122
 1e2:	90 e0       	ldi	r25, 0x00	; 0
 1e4:	65 e0       	ldi	r22, 0x05	; 5
 1e6:	0e 94 4c 02 	call	0x498	; 0x498 <lcdPrintData>
 1ea:	80 e3       	ldi	r24, 0x30	; 48
 1ec:	95 e7       	ldi	r25, 0x75	; 117
 1ee:	24 e6       	ldi	r18, 0x64	; 100
 1f0:	30 e0       	ldi	r19, 0x00	; 0
 1f2:	f9 01       	movw	r30, r18
 1f4:	31 97       	sbiw	r30, 0x01	; 1
 1f6:	f1 f7       	brne	.-4      	; 0x1f4 <main+0xbe>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 1f8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 1fa:	d9 f7       	brne	.-10     	; 0x1f2 <main+0xbc>
	}

	_delay_ms(3000);
	lcdClear();
 1fc:	0e 94 0e 02 	call	0x41c	; 0x41c <lcdClear>

	lcdPrintData("writing ",8);
 200:	80 e8       	ldi	r24, 0x80	; 128
 202:	90 e0       	ldi	r25, 0x00	; 0
 204:	68 e0       	ldi	r22, 0x08	; 8
 206:	0e 94 4c 02 	call	0x498	; 0x498 <lcdPrintData>
 20a:	80 e1       	ldi	r24, 0x10	; 16
 20c:	97 e2       	ldi	r25, 0x27	; 39
 20e:	24 e6       	ldi	r18, 0x64	; 100
 210:	30 e0       	ldi	r19, 0x00	; 0
 212:	f9 01       	movw	r30, r18
 214:	31 97       	sbiw	r30, 0x01	; 1
 216:	f1 f7       	brne	.-4      	; 0x214 <main+0xde>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 218:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 21a:	d9 f7       	brne	.-10     	; 0x212 <main+0xdc>
	_delay_ms(1000);
	if(mmcWrite(100,buffer)==0)
 21c:	64 e6       	ldi	r22, 0x64	; 100
 21e:	70 e0       	ldi	r23, 0x00	; 0
 220:	80 e0       	ldi	r24, 0x00	; 0
 222:	90 e0       	ldi	r25, 0x00	; 0
 224:	ae 01       	movw	r20, r28
 226:	4f 5f       	subi	r20, 0xFF	; 255
 228:	5f 4f       	sbci	r21, 0xFF	; 255
 22a:	0e 94 b4 06 	call	0xd68	; 0xd68 <mmcWrite>
 22e:	88 23       	and	r24, r24
 230:	41 f4       	brne	.+16     	; 0x242 <main+0x10c>
	{
		lcdGotoXY(10,1);
 232:	8a e0       	ldi	r24, 0x0A	; 10
 234:	61 e0       	ldi	r22, 0x01	; 1
 236:	0e 94 12 02 	call	0x424	; 0x424 <lcdGotoXY>
		lcdPrintData("success",7);
 23a:	82 e7       	ldi	r24, 0x72	; 114
 23c:	90 e0       	ldi	r25, 0x00	; 0
 23e:	67 e0       	ldi	r22, 0x07	; 7
 240:	07 c0       	rjmp	.+14     	; 0x250 <main+0x11a>
	}
	else
	{
		lcdGotoXY(10,1);
 242:	8a e0       	ldi	r24, 0x0A	; 10
 244:	61 e0       	ldi	r22, 0x01	; 1
 246:	0e 94 12 02 	call	0x424	; 0x424 <lcdGotoXY>
		lcdPrintData("faild",5);
 24a:	8a e7       	ldi	r24, 0x7A	; 122
 24c:	90 e0       	ldi	r25, 0x00	; 0
 24e:	65 e0       	ldi	r22, 0x05	; 5
 250:	0e 94 4c 02 	call	0x498	; 0x498 <lcdPrintData>
 254:	80 e3       	ldi	r24, 0x30	; 48
 256:	95 e7       	ldi	r25, 0x75	; 117
 258:	24 e6       	ldi	r18, 0x64	; 100
 25a:	30 e0       	ldi	r19, 0x00	; 0
 25c:	f9 01       	movw	r30, r18
 25e:	31 97       	sbiw	r30, 0x01	; 1
 260:	f1 f7       	brne	.-4      	; 0x25e <main+0x128>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 262:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 264:	d9 f7       	brne	.-10     	; 0x25c <main+0x126>
	}
	_delay_ms(3000);
	lcdClear();
 266:	0e 94 0e 02 	call	0x41c	; 0x41c <lcdClear>
	
	i=100;
	lcdPrintData("reading 512-byte",16);
 26a:	89 e8       	ldi	r24, 0x89	; 137
 26c:	90 e0       	ldi	r25, 0x00	; 0
 26e:	60 e1       	ldi	r22, 0x10	; 16
 270:	0e 94 4c 02 	call	0x498	; 0x498 <lcdPrintData>
 274:	80 e1       	ldi	r24, 0x10	; 16
 276:	97 e2       	ldi	r25, 0x27	; 39
 278:	24 e6       	ldi	r18, 0x64	; 100
 27a:	30 e0       	ldi	r19, 0x00	; 0
 27c:	f9 01       	movw	r30, r18
 27e:	31 97       	sbiw	r30, 0x01	; 1
 280:	f1 f7       	brne	.-4      	; 0x27e <main+0x148>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 282:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 284:	d9 f7       	brne	.-10     	; 0x27c <main+0x146>
	_delay_ms(1000);
	if(mmcRead(i,buffer)==0)
 286:	64 e6       	ldi	r22, 0x64	; 100
 288:	70 e0       	ldi	r23, 0x00	; 0
 28a:	80 e0       	ldi	r24, 0x00	; 0
 28c:	90 e0       	ldi	r25, 0x00	; 0
 28e:	ae 01       	movw	r20, r28
 290:	4f 5f       	subi	r20, 0xFF	; 255
 292:	5f 4f       	sbci	r21, 0xFF	; 255
 294:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <mmcRead>
 298:	88 23       	and	r24, r24
 29a:	81 f5       	brne	.+96     	; 0x2fc <main+0x1c6>
	{
		lcdGotoXY(10,1);
 29c:	8a e0       	ldi	r24, 0x0A	; 10
 29e:	61 e0       	ldi	r22, 0x01	; 1
 2a0:	0e 94 12 02 	call	0x424	; 0x424 <lcdGotoXY>
		lcdPrintData("success",7);
 2a4:	82 e7       	ldi	r24, 0x72	; 114
 2a6:	90 e0       	ldi	r25, 0x00	; 0
 2a8:	67 e0       	ldi	r22, 0x07	; 7
 2aa:	0e 94 4c 02 	call	0x498	; 0x498 <lcdPrintData>
 2ae:	80 e3       	ldi	r24, 0x30	; 48
 2b0:	95 e7       	ldi	r25, 0x75	; 117
 2b2:	24 e6       	ldi	r18, 0x64	; 100
 2b4:	30 e0       	ldi	r19, 0x00	; 0
 2b6:	f9 01       	movw	r30, r18
 2b8:	31 97       	sbiw	r30, 0x01	; 1
 2ba:	f1 f7       	brne	.-4      	; 0x2b8 <main+0x182>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 2bc:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 2be:	d9 f7       	brne	.-10     	; 0x2b6 <main+0x180>
		_delay_ms(3000);
		lcdClear();
 2c0:	0e 94 0e 02 	call	0x41c	; 0x41c <lcdClear>
 2c4:	8e 01       	movw	r16, r28
 2c6:	0f 5f       	subi	r16, 0xFF	; 255
 2c8:	1f 4f       	sbci	r17, 0xFF	; 255
 2ca:	94 e6       	ldi	r25, 0x64	; 100
 2cc:	c9 2e       	mov	r12, r25
 2ce:	d1 2c       	mov	r13, r1
		for(i=0;i<15;i++)
 2d0:	80 e1       	ldi	r24, 0x10	; 16
 2d2:	e8 2e       	mov	r14, r24
 2d4:	f1 2c       	mov	r15, r1
 2d6:	ec 0e       	add	r14, r28
 2d8:	fd 1e       	adc	r15, r29
		{
			lcdDataWrite(buffer[i]);
 2da:	f8 01       	movw	r30, r16
 2dc:	80 81       	ld	r24, Z
 2de:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <lcdDataWrite>
 2e2:	88 e8       	ldi	r24, 0x88	; 136
 2e4:	93 e1       	ldi	r25, 0x13	; 19
 2e6:	f6 01       	movw	r30, r12
 2e8:	31 97       	sbiw	r30, 0x01	; 1
 2ea:	f1 f7       	brne	.-4      	; 0x2e8 <main+0x1b2>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 2ec:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 2ee:	d9 f7       	brne	.-10     	; 0x2e6 <main+0x1b0>
 2f0:	0f 5f       	subi	r16, 0xFF	; 255
 2f2:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		lcdGotoXY(10,1);
		lcdPrintData("success",7);
		_delay_ms(3000);
		lcdClear();
		for(i=0;i<15;i++)
 2f4:	0e 15       	cp	r16, r14
 2f6:	1f 05       	cpc	r17, r15
 2f8:	81 f7       	brne	.-32     	; 0x2da <main+0x1a4>
 2fa:	09 c0       	rjmp	.+18     	; 0x30e <main+0x1d8>
		}
	
	}
	else 
	{
		lcdGotoXY(10,1);
 2fc:	8a e0       	ldi	r24, 0x0A	; 10
 2fe:	61 e0       	ldi	r22, 0x01	; 1
 300:	0e 94 12 02 	call	0x424	; 0x424 <lcdGotoXY>
		lcdPrintData("faild",5);
 304:	8a e7       	ldi	r24, 0x7A	; 122
 306:	90 e0       	ldi	r25, 0x00	; 0
 308:	65 e0       	ldi	r22, 0x05	; 5
 30a:	0e 94 4c 02 	call	0x498	; 0x498 <lcdPrintData>
 30e:	80 e5       	ldi	r24, 0x50	; 80
 310:	93 ec       	ldi	r25, 0xC3	; 195
 312:	24 e6       	ldi	r18, 0x64	; 100
 314:	30 e0       	ldi	r19, 0x00	; 0
 316:	f9 01       	movw	r30, r18
 318:	31 97       	sbiw	r30, 0x01	; 1
 31a:	f1 f7       	brne	.-4      	; 0x318 <main+0x1e2>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 31c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 31e:	d9 f7       	brne	.-10     	; 0x316 <main+0x1e0>
	}
	_delay_ms(5000);
	lcdClear();
 320:	0e 94 0e 02 	call	0x41c	; 0x41c <lcdClear>
	lcdPrintData("mmc test fnish",14);
 324:	8a e9       	ldi	r24, 0x9A	; 154
 326:	90 e0       	ldi	r25, 0x00	; 0
 328:	6e e0       	ldi	r22, 0x0E	; 14
 32a:	0e 94 4c 02 	call	0x498	; 0x498 <lcdPrintData>
 32e:	ff cf       	rjmp	.-2      	; 0x32e <main+0x1f8>

00000330 <lcdInitHW>:
{
	// initialize I/O ports
	// if I/O interface is in use
#ifdef LCD_PORT_INTERFACE
	// initialize LCD control lines
	cbi(LCD_CTRL_PORT, LCD_CTRL_RS);
 330:	d8 98       	cbi	0x1b, 0	; 27
	cbi(LCD_CTRL_PORT, LCD_CTRL_RW);
 332:	d9 98       	cbi	0x1b, 1	; 27
	cbi(LCD_CTRL_PORT, LCD_CTRL_E);
 334:	da 98       	cbi	0x1b, 2	; 27
	// initialize LCD control lines to output
	sbi(LCD_CTRL_DDR, LCD_CTRL_RS);
 336:	d0 9a       	sbi	0x1a, 0	; 26
	sbi(LCD_CTRL_DDR, LCD_CTRL_RW);
 338:	d1 9a       	sbi	0x1a, 1	; 26
	sbi(LCD_CTRL_DDR, LCD_CTRL_E);
 33a:	d2 9a       	sbi	0x1a, 2	; 26
	// initialize LCD data lines to pull-up
	#ifdef LCD_DATA_4BIT
		outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&0x0F);		// set data I/O lines to input (4bit)
		outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);	// set pull-ups to on (4bit)
	#else
		outb(LCD_DATA_DDR, 0x00);						// set data I/O lines to input (8bit)
 33c:	14 ba       	out	0x14, r1	; 20
		outb(LCD_DATA_POUT, 0xFF);						// set pull-ups to on (8bit)
 33e:	8f ef       	ldi	r24, 0xFF	; 255
 340:	85 bb       	out	0x15, r24	; 21
	#endif
#else
	// enable external memory bus if not already enabled
	sbi(MCUCR, SRE);			// enable bus interface
#endif
}
 342:	08 95       	ret

00000344 <lcdBusyWait>:
void lcdBusyWait(void)
{
	// wait until LCD busy bit goes to zero
	// do a read from control register
#ifdef LCD_PORT_INTERFACE
	cbi(LCD_CTRL_PORT, LCD_CTRL_RS);				// set RS to "control"
 344:	d8 98       	cbi	0x1b, 0	; 27
	#ifdef LCD_DATA_4BIT
		outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&0x0F);	// set data I/O lines to input (4bit)
		outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);	// set pull-ups to on (4bit)
	#else
		outb(LCD_DATA_DDR, 0x00);					// set data I/O lines to input (8bit)
 346:	14 ba       	out	0x14, r1	; 20
		outb(LCD_DATA_POUT, 0xFF);					// set pull-ups to on (8bit)
 348:	8f ef       	ldi	r24, 0xFF	; 255
 34a:	85 bb       	out	0x15, r24	; 21
	#endif
	sbi(LCD_CTRL_PORT, LCD_CTRL_RW);				// set R/W to "read"
 34c:	d9 9a       	sbi	0x1b, 1	; 27
	sbi(LCD_CTRL_PORT, LCD_CTRL_E);					// set "E" line
 34e:	da 9a       	sbi	0x1b, 2	; 27
	LCD_DELAY;								// wait
 350:	00 00       	nop
 352:	00 00       	nop
 354:	00 00       	nop
 356:	0e c0       	rjmp	.+28     	; 0x374 <lcdBusyWait+0x30>
	while(inb(LCD_DATA_PIN) & 1<<LCD_BUSY)
	{
		cbi(LCD_CTRL_PORT, LCD_CTRL_E);		// clear "E" line
 358:	da 98       	cbi	0x1b, 2	; 27
	...
		LCD_DELAY;									// wait
		LCD_DELAY;									// wait
		sbi(LCD_CTRL_PORT, LCD_CTRL_E);		// set "E" line
 366:	da 9a       	sbi	0x1b, 2	; 27
	...
		outb(LCD_DATA_POUT, 0xFF);					// set pull-ups to on (8bit)
	#endif
	sbi(LCD_CTRL_PORT, LCD_CTRL_RW);				// set R/W to "read"
	sbi(LCD_CTRL_PORT, LCD_CTRL_E);					// set "E" line
	LCD_DELAY;								// wait
	while(inb(LCD_DATA_PIN) & 1<<LCD_BUSY)
 374:	9f 99       	sbic	0x13, 7	; 19
 376:	f0 cf       	rjmp	.-32     	; 0x358 <lcdBusyWait+0x14>
			sbi(LCD_CTRL_PORT, LCD_CTRL_E);	// set "E" line
			LCD_DELAY;								// wait
			LCD_DELAY;								// wait
		#endif
	}
	cbi(LCD_CTRL_PORT, LCD_CTRL_E);			// clear "E" line
 378:	da 98       	cbi	0x1b, 2	; 27
	// sbi(MCUCR, SRW);			// enable RAM waitstate
	// wait until LCD busy bit goes to zero
	while( (*((volatile unsigned char *) (LCD_CTRL_ADDR))) & (1<<LCD_BUSY) );
	// cbi(MCUCR, SRW);			// disable RAM waitstate
#endif
}
 37a:	08 95       	ret

0000037c <lcdControlWrite>:

void lcdControlWrite(u08 data) 
{
 37c:	1f 93       	push	r17
 37e:	18 2f       	mov	r17, r24
// write the control byte to the display controller
#ifdef LCD_PORT_INTERFACE
	lcdBusyWait();							// wait until LCD not busy
 380:	0e 94 a2 01 	call	0x344	; 0x344 <lcdBusyWait>
	cbi(LCD_CTRL_PORT, LCD_CTRL_RS);			// set RS to "control"
 384:	d8 98       	cbi	0x1b, 0	; 27
	cbi(LCD_CTRL_PORT, LCD_CTRL_RW);			// set R/W to "write"
 386:	d9 98       	cbi	0x1b, 1	; 27
		LCD_DELAY;								// wait
		LCD_DELAY;								// wait
		cbi(LCD_CTRL_PORT, LCD_CTRL_E);	// clear "E" line
	#else
		// 8 bit write
		sbi(LCD_CTRL_PORT, LCD_CTRL_E);	// set "E" line
 388:	da 9a       	sbi	0x1b, 2	; 27
		outb(LCD_DATA_DDR, 0xFF);				// set data I/O lines to output (8bit)
 38a:	8f ef       	ldi	r24, 0xFF	; 255
 38c:	84 bb       	out	0x14, r24	; 20
		outb(LCD_DATA_POUT, data);				// output data, 8bits
 38e:	15 bb       	out	0x15, r17	; 21
	...
		LCD_DELAY;								// wait
		LCD_DELAY;								// wait
		cbi(LCD_CTRL_PORT, LCD_CTRL_E);	// clear "E" line
 39c:	da 98       	cbi	0x1b, 2	; 27
	//	leave data lines in input mode so they can be most easily used for other purposes
	#ifdef LCD_DATA_4BIT
		outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&0x0F);		// set data I/O lines to input (4bit)
		outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);	// set pull-ups to on (4bit)
	#else
		outb(LCD_DATA_DDR, 0x00);			// set data I/O lines to input (8bit)
 39e:	14 ba       	out	0x14, r1	; 20
		outb(LCD_DATA_POUT, 0xFF);			// set pull-ups to on (8bit)
 3a0:	85 bb       	out	0x15, r24	; 21
	//sbi(MCUCR, SRW);			// enable RAM waitstate
	lcdBusyWait();				// wait until LCD not busy
	*((volatile unsigned char *) (LCD_CTRL_ADDR)) = data;
	//cbi(MCUCR, SRW);			// disable RAM waitstate
#endif
}
 3a2:	1f 91       	pop	r17
 3a4:	08 95       	ret

000003a6 <lcdControlRead>:
u08 lcdControlRead(void)
{
// read the control byte from the display controller
	register u08 data;
#ifdef LCD_PORT_INTERFACE
	lcdBusyWait();				// wait until LCD not busy
 3a6:	0e 94 a2 01 	call	0x344	; 0x344 <lcdBusyWait>
	#ifdef LCD_DATA_4BIT
		outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&0x0F);		// set data I/O lines to input (4bit)
		outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);	// set pull-ups to on (4bit)
	#else
		outb(LCD_DATA_DDR, 0x00);			// set data I/O lines to input (8bit)
 3aa:	14 ba       	out	0x14, r1	; 20
		outb(LCD_DATA_POUT, 0xFF);			// set pull-ups to on (8bit)
 3ac:	8f ef       	ldi	r24, 0xFF	; 255
 3ae:	85 bb       	out	0x15, r24	; 21
	#endif
	cbi(LCD_CTRL_PORT, LCD_CTRL_RS);		// set RS to "control"
 3b0:	d8 98       	cbi	0x1b, 0	; 27
	sbi(LCD_CTRL_PORT, LCD_CTRL_RW);		// set R/W to "read"
 3b2:	d9 9a       	sbi	0x1b, 1	; 27
		LCD_DELAY;						// wait
		data |= inb(LCD_DATA_PIN)>>4;	// input data, low 4 bits
		cbi(LCD_CTRL_PORT, LCD_CTRL_E);	// clear "E" line
	#else
		// 8 bit read
		sbi(LCD_CTRL_PORT, LCD_CTRL_E);	// set "E" line
 3b4:	da 9a       	sbi	0x1b, 2	; 27
	...
		LCD_DELAY;						// wait
		LCD_DELAY;						// wait
		data = inb(LCD_DATA_PIN);		// input data, 8bits
 3c2:	83 b3       	in	r24, 0x13	; 19
		cbi(LCD_CTRL_PORT, LCD_CTRL_E);	// clear "E" line
 3c4:	da 98       	cbi	0x1b, 2	; 27
	lcdBusyWait();				// wait until LCD not busy
	data = *((volatile unsigned char *) (LCD_CTRL_ADDR));
	//cbi(MCUCR, SRW);			// disable RAM waitstate
#endif
	return data;
}
 3c6:	08 95       	ret

000003c8 <lcdDataWrite>:

void lcdDataWrite(u08 data) 
{
 3c8:	1f 93       	push	r17
 3ca:	18 2f       	mov	r17, r24
// write a data byte to the display
#ifdef LCD_PORT_INTERFACE
	lcdBusyWait();							// wait until LCD not busy
 3cc:	0e 94 a2 01 	call	0x344	; 0x344 <lcdBusyWait>
	sbi(LCD_CTRL_PORT, LCD_CTRL_RS);		// set RS to "data"
 3d0:	d8 9a       	sbi	0x1b, 0	; 27
	cbi(LCD_CTRL_PORT, LCD_CTRL_RW);		// set R/W to "write"
 3d2:	d9 98       	cbi	0x1b, 1	; 27
		LCD_DELAY;								// wait
		LCD_DELAY;								// wait
		cbi(LCD_CTRL_PORT, LCD_CTRL_E);	// clear "E" line
	#else
		// 8 bit write
		sbi(LCD_CTRL_PORT, LCD_CTRL_E);	// set "E" line
 3d4:	da 9a       	sbi	0x1b, 2	; 27
		outb(LCD_DATA_DDR, 0xFF);			// set data I/O lines to output (8bit)
 3d6:	8f ef       	ldi	r24, 0xFF	; 255
 3d8:	84 bb       	out	0x14, r24	; 20
		outb(LCD_DATA_POUT, data);			// output data, 8bits
 3da:	15 bb       	out	0x15, r17	; 21
	...
		LCD_DELAY;								// wait
		LCD_DELAY;								// wait
		cbi(LCD_CTRL_PORT, LCD_CTRL_E);	// clear "E" line
 3e8:	da 98       	cbi	0x1b, 2	; 27
	//	leave data lines in input mode so they can be most easily used for other purposes
	#ifdef LCD_DATA_4BIT
		outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&0x0F);		// set data I/O lines to input (4bit)
		outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);	// set pull-ups to on (4bit)
	#else
		outb(LCD_DATA_DDR, 0x00);			// set data I/O lines to input (8bit)
 3ea:	14 ba       	out	0x14, r1	; 20
		outb(LCD_DATA_POUT, 0xFF);			// set pull-ups to on (8bit)
 3ec:	85 bb       	out	0x15, r24	; 21
	//sbi(MCUCR, SRW);			// enable RAM waitstate
	lcdBusyWait();				// wait until LCD not busy
	*((volatile unsigned char *) (LCD_DATA_ADDR)) = data;
	//cbi(MCUCR, SRW);			// disable RAM waitstate
#endif
}
 3ee:	1f 91       	pop	r17
 3f0:	08 95       	ret

000003f2 <lcdDataRead>:
u08 lcdDataRead(void)
{
// read a data byte from the display
	register u08 data;
#ifdef LCD_PORT_INTERFACE
	lcdBusyWait();				// wait until LCD not busy
 3f2:	0e 94 a2 01 	call	0x344	; 0x344 <lcdBusyWait>
	#ifdef LCD_DATA_4BIT
		outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&0x0F);		// set data I/O lines to input (4bit)
		outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);	// set pull-ups to on (4bit)
	#else
		outb(LCD_DATA_DDR, 0x00);			// set data I/O lines to input (8bit)
 3f6:	14 ba       	out	0x14, r1	; 20
		outb(LCD_DATA_POUT, 0xFF);			// set pull-ups to on (8bit)
 3f8:	8f ef       	ldi	r24, 0xFF	; 255
 3fa:	85 bb       	out	0x15, r24	; 21
	#endif
	sbi(LCD_CTRL_PORT, LCD_CTRL_RS);		// set RS to "data"
 3fc:	d8 9a       	sbi	0x1b, 0	; 27
	sbi(LCD_CTRL_PORT, LCD_CTRL_RW);		// set R/W to "read"
 3fe:	d9 9a       	sbi	0x1b, 1	; 27
		LCD_DELAY;								// wait
		data |= inb(LCD_DATA_PIN)>>4;			// input data, low 4 bits
		cbi(LCD_CTRL_PORT, LCD_CTRL_E);	// clear "E" line
	#else
		// 8 bit read
		sbi(LCD_CTRL_PORT, LCD_CTRL_E);	// set "E" line
 400:	da 9a       	sbi	0x1b, 2	; 27
	...
		LCD_DELAY;								// wait
		LCD_DELAY;								// wait
		data = inb(LCD_DATA_PIN);			// input data, 8bits
 40e:	83 b3       	in	r24, 0x13	; 19
		cbi(LCD_CTRL_PORT, LCD_CTRL_E);	// clear "E" line
 410:	da 98       	cbi	0x1b, 2	; 27
	lcdBusyWait();				// wait until LCD not busy
	data = *((volatile unsigned char *) (LCD_DATA_ADDR));
	//cbi(MCUCR, SRW);			// disable RAM waitstate
#endif
	return data;
}
 412:	08 95       	ret

00000414 <lcdHome>:
}

void lcdHome(void)
{
	// move cursor to home
	lcdControlWrite(1<<LCD_HOME);
 414:	82 e0       	ldi	r24, 0x02	; 2
 416:	0e 94 be 01 	call	0x37c	; 0x37c <lcdControlWrite>
}
 41a:	08 95       	ret

0000041c <lcdClear>:

void lcdClear(void)
{
	// clear LCD
	lcdControlWrite(1<<LCD_CLR);
 41c:	81 e0       	ldi	r24, 0x01	; 1
 41e:	0e 94 be 01 	call	0x37c	; 0x37c <lcdControlWrite>
}
 422:	08 95       	ret

00000424 <lcdGotoXY>:
void lcdGotoXY(u08 x, u08 y)
{
	register u08 DDRAMAddr;

	// remap lines into proper order
	switch(y)
 424:	62 30       	cpi	r22, 0x02	; 2
 426:	31 f0       	breq	.+12     	; 0x434 <lcdGotoXY+0x10>
 428:	63 30       	cpi	r22, 0x03	; 3
 42a:	31 f0       	breq	.+12     	; 0x438 <lcdGotoXY+0x14>
 42c:	61 30       	cpi	r22, 0x01	; 1
 42e:	29 f4       	brne	.+10     	; 0x43a <lcdGotoXY+0x16>
	{
	case 0: DDRAMAddr = LCD_LINE0_DDRAMADDR+x; break;
	case 1: DDRAMAddr = LCD_LINE1_DDRAMADDR+x; break;
 430:	80 5c       	subi	r24, 0xC0	; 192
 432:	03 c0       	rjmp	.+6      	; 0x43a <lcdGotoXY+0x16>
	case 2: DDRAMAddr = LCD_LINE2_DDRAMADDR+x; break;
 434:	8c 5e       	subi	r24, 0xEC	; 236
 436:	01 c0       	rjmp	.+2      	; 0x43a <lcdGotoXY+0x16>
	case 3: DDRAMAddr = LCD_LINE3_DDRAMADDR+x; break;
 438:	8c 5a       	subi	r24, 0xAC	; 172
	default: DDRAMAddr = LCD_LINE0_DDRAMADDR+x;
	}

	// set data address
	lcdControlWrite(1<<LCD_DDRAM | DDRAMAddr);
 43a:	80 68       	ori	r24, 0x80	; 128
 43c:	0e 94 be 01 	call	0x37c	; 0x37c <lcdControlWrite>
}
 440:	08 95       	ret

00000442 <lcdLoadCustomChar>:

void lcdLoadCustomChar(u08* lcdCustomCharArray, u08 romCharNum, u08 lcdCharNum)
{
 442:	ff 92       	push	r15
 444:	0f 93       	push	r16
 446:	1f 93       	push	r17
 448:	cf 93       	push	r28
 44a:	df 93       	push	r29
 44c:	ec 01       	movw	r28, r24
 44e:	16 2f       	mov	r17, r22
 450:	04 2f       	mov	r16, r20
	register u08 i;
	u08 saveDDRAMAddr;

	// backup the current cursor position
	saveDDRAMAddr = lcdControlRead() & 0x7F;
 452:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <lcdControlRead>
 456:	f8 2e       	mov	r15, r24

	// multiply the character index by 8
	lcdCharNum = (lcdCharNum<<3);	// each character occupies 8 bytes
 458:	00 0f       	add	r16, r16
 45a:	00 0f       	add	r16, r16
 45c:	00 0f       	add	r16, r16
 45e:	11 0f       	add	r17, r17
 460:	11 0f       	add	r17, r17
 462:	11 0f       	add	r17, r17
 464:	c1 0f       	add	r28, r17
 466:	d1 1d       	adc	r29, r1
 468:	10 e0       	ldi	r17, 0x00	; 0

	// copy the 8 bytes into CG (character generator) RAM
	for(i=0; i<8; i++)
	{
		// set CG RAM address
		lcdControlWrite((1<<LCD_CGRAM) | (lcdCharNum+i));
 46a:	81 2f       	mov	r24, r17
 46c:	80 0f       	add	r24, r16
 46e:	80 64       	ori	r24, 0x40	; 64
 470:	0e 94 be 01 	call	0x37c	; 0x37c <lcdControlWrite>
		// write character data
		lcdDataWrite( pgm_read_byte(lcdCustomCharArray+romCharNum+i) );
 474:	fe 01       	movw	r30, r28
 476:	84 91       	lpm	r24, Z+
 478:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <lcdDataWrite>
	// multiply the character index by 8
	lcdCharNum = (lcdCharNum<<3);	// each character occupies 8 bytes
	romCharNum = (romCharNum<<3);	// each character occupies 8 bytes

	// copy the 8 bytes into CG (character generator) RAM
	for(i=0; i<8; i++)
 47c:	1f 5f       	subi	r17, 0xFF	; 255
 47e:	21 96       	adiw	r28, 0x01	; 1
 480:	18 30       	cpi	r17, 0x08	; 8
 482:	99 f7       	brne	.-26     	; 0x46a <lcdLoadCustomChar+0x28>
		// write character data
		lcdDataWrite( pgm_read_byte(lcdCustomCharArray+romCharNum+i) );
	}

	// restore the previous cursor position
	lcdControlWrite(1<<LCD_DDRAM | saveDDRAMAddr);
 484:	8f 2d       	mov	r24, r15
 486:	80 68       	ori	r24, 0x80	; 128
 488:	0e 94 be 01 	call	0x37c	; 0x37c <lcdControlWrite>

}
 48c:	df 91       	pop	r29
 48e:	cf 91       	pop	r28
 490:	1f 91       	pop	r17
 492:	0f 91       	pop	r16
 494:	ff 90       	pop	r15
 496:	08 95       	ret

00000498 <lcdPrintData>:

void lcdPrintData(char* data, u08 nBytes)
{
 498:	0f 93       	push	r16
 49a:	1f 93       	push	r17
 49c:	cf 93       	push	r28
 49e:	df 93       	push	r29
 4a0:	06 2f       	mov	r16, r22
	register u08 i;

	// check to make sure we have a good pointer
	if (!data) return;
 4a2:	00 97       	sbiw	r24, 0x00	; 0
 4a4:	49 f0       	breq	.+18     	; 0x4b8 <lcdPrintData+0x20>
 4a6:	ec 01       	movw	r28, r24
 4a8:	10 e0       	ldi	r17, 0x00	; 0
 4aa:	04 c0       	rjmp	.+8      	; 0x4b4 <lcdPrintData+0x1c>

	// print data
	for(i=0; i<nBytes; i++)
	{
		lcdDataWrite(data[i]);
 4ac:	89 91       	ld	r24, Y+
 4ae:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <lcdDataWrite>

	// check to make sure we have a good pointer
	if (!data) return;

	// print data
	for(i=0; i<nBytes; i++)
 4b2:	1f 5f       	subi	r17, 0xFF	; 255
 4b4:	10 17       	cp	r17, r16
 4b6:	d0 f3       	brcs	.-12     	; 0x4ac <lcdPrintData+0x14>
	{
		lcdDataWrite(data[i]);
	}
}
 4b8:	df 91       	pop	r29
 4ba:	cf 91       	pop	r28
 4bc:	1f 91       	pop	r17
 4be:	0f 91       	pop	r16
 4c0:	08 95       	ret

000004c2 <lcdProgressBar>:

void lcdProgressBar(u16 progress, u16 maxprogress, u08 length)
{
 4c2:	7f 92       	push	r7
 4c4:	8f 92       	push	r8
 4c6:	9f 92       	push	r9
 4c8:	af 92       	push	r10
 4ca:	bf 92       	push	r11
 4cc:	cf 92       	push	r12
 4ce:	df 92       	push	r13
 4d0:	ef 92       	push	r14
 4d2:	ff 92       	push	r15
 4d4:	0f 93       	push	r16
 4d6:	1f 93       	push	r17
 4d8:	74 2e       	mov	r7, r20
	// ***note, LCD chars 0-5 must be programmed as the bar characters
	// char 0 = empty ... char 5 = full

	// total pixel length of bargraph equals length*PROGRESSPIXELS_PER_CHAR;
	// pixel length of bar itself is
	pixelprogress = ((progress*(length*PROGRESSPIXELS_PER_CHAR))/maxprogress);
 4da:	9c 01       	movw	r18, r24
 4dc:	22 0f       	add	r18, r18
 4de:	33 1f       	adc	r19, r19
 4e0:	28 0f       	add	r18, r24
 4e2:	39 1f       	adc	r19, r25
 4e4:	22 0f       	add	r18, r18
 4e6:	33 1f       	adc	r19, r19
 4e8:	87 2d       	mov	r24, r7
 4ea:	90 e0       	ldi	r25, 0x00	; 0
 4ec:	ac 01       	movw	r20, r24
 4ee:	24 9f       	mul	r18, r20
 4f0:	c0 01       	movw	r24, r0
 4f2:	25 9f       	mul	r18, r21
 4f4:	90 0d       	add	r25, r0
 4f6:	34 9f       	mul	r19, r20
 4f8:	90 0d       	add	r25, r0
 4fa:	11 24       	eor	r1, r1
 4fc:	0e 94 94 07 	call	0xf28	; 0xf28 <__udivmodhi4>
 500:	5b 01       	movw	r10, r22
 502:	cc 24       	eor	r12, r12
 504:	dd 24       	eor	r13, r13
				c = 0;
			}
			else
			{
				// this is a partial block
				c = pixelprogress % PROGRESSPIXELS_PER_CHAR;
 506:	c6 01       	movw	r24, r12
 508:	b5 01       	movw	r22, r10
 50a:	26 e0       	ldi	r18, 0x06	; 6
 50c:	30 e0       	ldi	r19, 0x00	; 0
 50e:	40 e0       	ldi	r20, 0x00	; 0
 510:	50 e0       	ldi	r21, 0x00	; 0
 512:	0e 94 a8 07 	call	0xf50	; 0xf50 <__udivmodsi4>
 516:	86 2e       	mov	r8, r22
 518:	99 24       	eor	r9, r9
 51a:	ee 24       	eor	r14, r14
 51c:	ff 24       	eor	r15, r15
 51e:	87 01       	movw	r16, r14
 520:	1f c0       	rjmp	.+62     	; 0x560 <lcdProgressBar+0x9e>
	// print exactly "length" characters
	for(i=0; i<length; i++)
	{
		// check if this is a full block, or partial or empty
		// (u16) cast is needed to avoid sign comparison warning
		if( ((i*(u16)PROGRESSPIXELS_PER_CHAR)+5) > pixelprogress )
 522:	d8 01       	movw	r26, r16
 524:	c7 01       	movw	r24, r14
 526:	05 96       	adiw	r24, 0x05	; 5
 528:	a1 1d       	adc	r26, r1
 52a:	b1 1d       	adc	r27, r1
 52c:	a8 16       	cp	r10, r24
 52e:	b9 06       	cpc	r11, r25
 530:	ca 06       	cpc	r12, r26
 532:	db 06       	cpc	r13, r27
 534:	10 f0       	brcs	.+4      	; 0x53a <lcdProgressBar+0x78>
 536:	85 e0       	ldi	r24, 0x05	; 5
 538:	08 c0       	rjmp	.+16     	; 0x54a <lcdProgressBar+0x88>
		{
			// this is a partial or empty block
			if( ((i*(u16)PROGRESSPIXELS_PER_CHAR)) > pixelprogress )
 53a:	ae 14       	cp	r10, r14
 53c:	bf 04       	cpc	r11, r15
 53e:	c0 06       	cpc	r12, r16
 540:	d1 06       	cpc	r13, r17
 542:	10 f0       	brcs	.+4      	; 0x548 <lcdProgressBar+0x86>
 544:	88 2d       	mov	r24, r8
 546:	01 c0       	rjmp	.+2      	; 0x54a <lcdProgressBar+0x88>
 548:	80 e0       	ldi	r24, 0x00	; 0
			// this is a full block
			c = 5;
		}
		
		// write character to display
		lcdDataWrite(c);
 54a:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <lcdDataWrite>
	// total pixel length of bargraph equals length*PROGRESSPIXELS_PER_CHAR;
	// pixel length of bar itself is
	pixelprogress = ((progress*(length*PROGRESSPIXELS_PER_CHAR))/maxprogress);
	
	// print exactly "length" characters
	for(i=0; i<length; i++)
 54e:	93 94       	inc	r9
 550:	86 e0       	ldi	r24, 0x06	; 6
 552:	90 e0       	ldi	r25, 0x00	; 0
 554:	a0 e0       	ldi	r26, 0x00	; 0
 556:	b0 e0       	ldi	r27, 0x00	; 0
 558:	e8 0e       	add	r14, r24
 55a:	f9 1e       	adc	r15, r25
 55c:	0a 1f       	adc	r16, r26
 55e:	1b 1f       	adc	r17, r27
 560:	97 14       	cp	r9, r7
 562:	f8 f2       	brcs	.-66     	; 0x522 <lcdProgressBar+0x60>
		
		// write character to display
		lcdDataWrite(c);
	}

}
 564:	1f 91       	pop	r17
 566:	0f 91       	pop	r16
 568:	ff 90       	pop	r15
 56a:	ef 90       	pop	r14
 56c:	df 90       	pop	r13
 56e:	cf 90       	pop	r12
 570:	bf 90       	pop	r11
 572:	af 90       	pop	r10
 574:	9f 90       	pop	r9
 576:	8f 90       	pop	r8
 578:	7f 90       	pop	r7
 57a:	08 95       	ret

0000057c <lcdInit>:
/*************************************************************/
/********************* PUBLIC FUNCTIONS **********************/
/*************************************************************/

void lcdInit()
{
 57c:	0f 93       	push	r16
 57e:	1f 93       	push	r17
	// initialize hardware
	lcdInitHW();
 580:	0e 94 98 01 	call	0x330	; 0x330 <lcdInitHW>
	// LCD function set
	lcdControlWrite(LCD_FUNCTION_DEFAULT);
 584:	88 e3       	ldi	r24, 0x38	; 56
 586:	0e 94 be 01 	call	0x37c	; 0x37c <lcdControlWrite>
	// clear LCD
	lcdControlWrite(1<<LCD_CLR);
 58a:	81 e0       	ldi	r24, 0x01	; 1
 58c:	0e 94 be 01 	call	0x37c	; 0x37c <lcdControlWrite>
	delay(60000);	// wait 60ms
 590:	80 e6       	ldi	r24, 0x60	; 96
 592:	9a ee       	ldi	r25, 0xEA	; 234
 594:	0e 94 05 03 	call	0x60a	; 0x60a <delay_us>
	// set entry mode
	lcdControlWrite(1<<LCD_ENTRY_MODE | 1<<LCD_ENTRY_INC);
 598:	86 e0       	ldi	r24, 0x06	; 6
 59a:	0e 94 be 01 	call	0x37c	; 0x37c <lcdControlWrite>
	// set display to on
	//lcdControlWrite(1<<LCD_ON_CTRL | 1<<LCD_ON_DISPLAY | 1<<LCD_ON_BLINK);
	lcdControlWrite(1<<LCD_ON_CTRL | 1<<LCD_ON_DISPLAY );
 59e:	8c e0       	ldi	r24, 0x0C	; 12
 5a0:	0e 94 be 01 	call	0x37c	; 0x37c <lcdControlWrite>
	// move cursor to home
	lcdControlWrite(1<<LCD_HOME);
 5a4:	82 e0       	ldi	r24, 0x02	; 2
 5a6:	0e 94 be 01 	call	0x37c	; 0x37c <lcdControlWrite>
	// set data address to 0
	lcdControlWrite(1<<LCD_DDRAM | 0x00);
 5aa:	80 e8       	ldi	r24, 0x80	; 128
 5ac:	0e 94 be 01 	call	0x37c	; 0x37c <lcdControlWrite>

	// load the first 8 custom characters
	lcdLoadCustomChar((u08*)LcdCustomChar,0,0);
 5b0:	04 e5       	ldi	r16, 0x54	; 84
 5b2:	10 e0       	ldi	r17, 0x00	; 0
 5b4:	c8 01       	movw	r24, r16
 5b6:	60 e0       	ldi	r22, 0x00	; 0
 5b8:	40 e0       	ldi	r20, 0x00	; 0
 5ba:	0e 94 21 02 	call	0x442	; 0x442 <lcdLoadCustomChar>
	lcdLoadCustomChar((u08*)LcdCustomChar,1,1);
 5be:	c8 01       	movw	r24, r16
 5c0:	61 e0       	ldi	r22, 0x01	; 1
 5c2:	41 e0       	ldi	r20, 0x01	; 1
 5c4:	0e 94 21 02 	call	0x442	; 0x442 <lcdLoadCustomChar>
	lcdLoadCustomChar((u08*)LcdCustomChar,2,2);
 5c8:	c8 01       	movw	r24, r16
 5ca:	62 e0       	ldi	r22, 0x02	; 2
 5cc:	42 e0       	ldi	r20, 0x02	; 2
 5ce:	0e 94 21 02 	call	0x442	; 0x442 <lcdLoadCustomChar>
	lcdLoadCustomChar((u08*)LcdCustomChar,3,3);
 5d2:	c8 01       	movw	r24, r16
 5d4:	63 e0       	ldi	r22, 0x03	; 3
 5d6:	43 e0       	ldi	r20, 0x03	; 3
 5d8:	0e 94 21 02 	call	0x442	; 0x442 <lcdLoadCustomChar>
	lcdLoadCustomChar((u08*)LcdCustomChar,4,4);
 5dc:	c8 01       	movw	r24, r16
 5de:	64 e0       	ldi	r22, 0x04	; 4
 5e0:	44 e0       	ldi	r20, 0x04	; 4
 5e2:	0e 94 21 02 	call	0x442	; 0x442 <lcdLoadCustomChar>
	lcdLoadCustomChar((u08*)LcdCustomChar,5,5);
 5e6:	c8 01       	movw	r24, r16
 5e8:	65 e0       	ldi	r22, 0x05	; 5
 5ea:	45 e0       	ldi	r20, 0x05	; 5
 5ec:	0e 94 21 02 	call	0x442	; 0x442 <lcdLoadCustomChar>
	lcdLoadCustomChar((u08*)LcdCustomChar,6,6);
 5f0:	c8 01       	movw	r24, r16
 5f2:	66 e0       	ldi	r22, 0x06	; 6
 5f4:	46 e0       	ldi	r20, 0x06	; 6
 5f6:	0e 94 21 02 	call	0x442	; 0x442 <lcdLoadCustomChar>
	lcdLoadCustomChar((u08*)LcdCustomChar,7,7);
 5fa:	c8 01       	movw	r24, r16
 5fc:	67 e0       	ldi	r22, 0x07	; 7
 5fe:	47 e0       	ldi	r20, 0x07	; 7
 600:	0e 94 21 02 	call	0x442	; 0x442 <lcdLoadCustomChar>
}
 604:	1f 91       	pop	r17
 606:	0f 91       	pop	r16
 608:	08 95       	ret

0000060a <delay_us>:

	delay_loops = (time_us+3)/5*CYCLES_PER_US; // +3 for rounding up (dirty) 

	// one loop takes 5 cpu cycles 
	for (i=0; i < delay_loops; i++) {};
}
 60a:	08 95       	ret

0000060c <timer0Init>:
#endif

void timer0SetPrescaler(u08 prescale)
{
	// set prescaler on timer 0
	outb(TCCR0, (inb(TCCR0) & ~TIMER_PRESCALE_MASK) | prescale);
 60c:	83 b7       	in	r24, 0x33	; 51
 60e:	88 7f       	andi	r24, 0xF8	; 248
 610:	82 60       	ori	r24, 0x02	; 2
 612:	83 bf       	out	0x33, r24	; 51

void timer0Init()
{
	// initialize timer 0
	timer0SetPrescaler( TIMER0PRESCALE );	// set prescaler
	outb(TCNT0, 0);							// reset TCNT0
 614:	12 be       	out	0x32, r1	; 50
	sbi(TIMSK, TOIE0);						// enable TCNT0 overflow interrupt
 616:	89 b7       	in	r24, 0x39	; 57
 618:	81 60       	ori	r24, 0x01	; 1
 61a:	89 bf       	out	0x39, r24	; 57
}

void timer0ClearOverflowCount(void)
{
	// clear the timer overflow counter registers
	Timer0Reg0 = 0;	// initialize time registers
 61c:	10 92 fa 00 	sts	0x00FA, r1
 620:	10 92 fb 00 	sts	0x00FB, r1
 624:	10 92 fc 00 	sts	0x00FC, r1
 628:	10 92 fd 00 	sts	0x00FD, r1
	timer0SetPrescaler( TIMER0PRESCALE );	// set prescaler
	outb(TCNT0, 0);							// reset TCNT0
	sbi(TIMSK, TOIE0);						// enable TCNT0 overflow interrupt

	timer0ClearOverflowCount();				// initialize time registers
}
 62c:	08 95       	ret

0000062e <timer1Init>:
}

void timer1SetPrescaler(u08 prescale)
{
	// set prescaler on timer 1
	outb(TCCR1B, (inb(TCCR1B) & ~TIMER_PRESCALE_MASK) | prescale);
 62e:	8e b5       	in	r24, 0x2e	; 46
 630:	88 7f       	andi	r24, 0xF8	; 248
 632:	83 60       	ori	r24, 0x03	; 3
 634:	8e bd       	out	0x2e, r24	; 46

void timer1Init(void)
{
	// initialize timer 1
	timer1SetPrescaler( TIMER1PRESCALE );	// set prescaler
	outb(TCNT1H, 0);						// reset TCNT1
 636:	1d bc       	out	0x2d, r1	; 45
	outb(TCNT1L, 0);
 638:	1c bc       	out	0x2c, r1	; 44
	sbi(TIMSK, TOIE1);						// enable TCNT1 overflow
 63a:	89 b7       	in	r24, 0x39	; 57
 63c:	84 60       	ori	r24, 0x04	; 4
 63e:	89 bf       	out	0x39, r24	; 57
}
 640:	08 95       	ret

00000642 <timer2Init>:

#ifdef TCNT2	// support timer2 only if it exists
void timer2SetPrescaler(u08 prescale)
{
	// set prescaler on timer 2
	outb(TCCR2, (inb(TCCR2) & ~TIMER_PRESCALE_MASK) | prescale);
 642:	85 b5       	in	r24, 0x25	; 37
 644:	88 7f       	andi	r24, 0xF8	; 248
 646:	84 60       	ori	r24, 0x04	; 4
 648:	85 bd       	out	0x25, r24	; 37
#ifdef TCNT2	// support timer2 only if it exists
void timer2Init(void)
{
	// initialize timer 2
	timer2SetPrescaler( TIMER2PRESCALE );	// set prescaler
	outb(TCNT2, 0);							// reset TCNT2
 64a:	14 bc       	out	0x24, r1	; 36
	sbi(TIMSK, TOIE2);						// enable TCNT2 overflow
 64c:	89 b7       	in	r24, 0x39	; 57
 64e:	80 64       	ori	r24, 0x40	; 64
 650:	89 bf       	out	0x39, r24	; 57

#ifdef TCNT2	// support timer2 only if it exists
void timer2ClearOverflowCount(void)
{
	// clear the timer overflow counter registers
	Timer2Reg0 = 0;	// initialize time registers
 652:	10 92 02 01 	sts	0x0102, r1
 656:	10 92 03 01 	sts	0x0103, r1
 65a:	10 92 04 01 	sts	0x0104, r1
 65e:	10 92 05 01 	sts	0x0105, r1
	timer2SetPrescaler( TIMER2PRESCALE );	// set prescaler
	outb(TCNT2, 0);							// reset TCNT2
	sbi(TIMSK, TOIE2);						// enable TCNT2 overflow

	timer2ClearOverflowCount();				// initialize time registers
}
 662:	08 95       	ret

00000664 <timerInit>:
                  :"r"(time_ms), "r"((unsigned short) (delay_count))
	);
}
*/
void timerInit(void)
{
 664:	80 e0       	ldi	r24, 0x00	; 0
 666:	90 e0       	ldi	r25, 0x00	; 0
{
	// make sure the interrupt number is within bounds
	if(interruptNum < TIMER_NUM_INTERRUPTS)
	{
		// set the interrupt function to run nothing
		TimerIntFunc[interruptNum] = 0;
 668:	fc 01       	movw	r30, r24
 66a:	ee 0f       	add	r30, r30
 66c:	ff 1f       	adc	r31, r31
 66e:	e6 51       	subi	r30, 0x16	; 22
 670:	ff 4f       	sbci	r31, 0xFF	; 255
 672:	11 82       	std	Z+1, r1	; 0x01
 674:	10 82       	st	Z, r1
 676:	01 96       	adiw	r24, 0x01	; 1
*/
void timerInit(void)
{
	u08 intNum;
	// detach all user functions from interrupts
	for(intNum=0; intNum<TIMER_NUM_INTERRUPTS; intNum++)
 678:	88 30       	cpi	r24, 0x08	; 8
 67a:	91 05       	cpc	r25, r1
 67c:	a9 f7       	brne	.-22     	; 0x668 <timerInit+0x4>
		timerDetach(intNum);

	// initialize all timers
	timer0Init();
 67e:	0e 94 06 03 	call	0x60c	; 0x60c <timer0Init>
	timer1Init();
 682:	0e 94 17 03 	call	0x62e	; 0x62e <timer1Init>
	#ifdef TCNT2	// support timer2 only if it exists
	timer2Init();
 686:	0e 94 21 03 	call	0x642	; 0x642 <timer2Init>
	#endif
	// enable interrupts
	sei();
 68a:	78 94       	sei
}
 68c:	08 95       	ret

0000068e <timer0SetPrescaler>:
#endif

void timer0SetPrescaler(u08 prescale)
{
	// set prescaler on timer 0
	outb(TCCR0, (inb(TCCR0) & ~TIMER_PRESCALE_MASK) | prescale);
 68e:	93 b7       	in	r25, 0x33	; 51
 690:	98 7f       	andi	r25, 0xF8	; 248
 692:	98 2b       	or	r25, r24
 694:	93 bf       	out	0x33, r25	; 51
}
 696:	08 95       	ret

00000698 <timer1SetPrescaler>:

void timer1SetPrescaler(u08 prescale)
{
	// set prescaler on timer 1
	outb(TCCR1B, (inb(TCCR1B) & ~TIMER_PRESCALE_MASK) | prescale);
 698:	9e b5       	in	r25, 0x2e	; 46
 69a:	98 7f       	andi	r25, 0xF8	; 248
 69c:	98 2b       	or	r25, r24
 69e:	9e bd       	out	0x2e, r25	; 46
}
 6a0:	08 95       	ret

000006a2 <timer2SetPrescaler>:

#ifdef TCNT2	// support timer2 only if it exists
void timer2SetPrescaler(u08 prescale)
{
	// set prescaler on timer 2
	outb(TCCR2, (inb(TCCR2) & ~TIMER_PRESCALE_MASK) | prescale);
 6a2:	95 b5       	in	r25, 0x25	; 37
 6a4:	98 7f       	andi	r25, 0xF8	; 248
 6a6:	98 2b       	or	r25, r24
 6a8:	95 bd       	out	0x25, r25	; 37
}
 6aa:	08 95       	ret

000006ac <timer0GetPrescaler>:
#endif

u16 timer0GetPrescaler(void)
{
	// get the current prescaler setting
	return (pgm_read_word(TimerPrescaleFactor+(inb(TCCR0) & TIMER_PRESCALE_MASK)));
 6ac:	83 b7       	in	r24, 0x33	; 51
 6ae:	e8 2f       	mov	r30, r24
 6b0:	f0 e0       	ldi	r31, 0x00	; 0
 6b2:	e7 70       	andi	r30, 0x07	; 7
 6b4:	f0 70       	andi	r31, 0x00	; 0
 6b6:	ee 0f       	add	r30, r30
 6b8:	ff 1f       	adc	r31, r31
 6ba:	e4 52       	subi	r30, 0x24	; 36
 6bc:	ff 4f       	sbci	r31, 0xFF	; 255
 6be:	25 91       	lpm	r18, Z+
 6c0:	34 91       	lpm	r19, Z+
}
 6c2:	c9 01       	movw	r24, r18
 6c4:	08 95       	ret

000006c6 <timer1GetPrescaler>:

u16 timer1GetPrescaler(void)
{
	// get the current prescaler setting
	return (pgm_read_word(TimerPrescaleFactor+(inb(TCCR1B) & TIMER_PRESCALE_MASK)));
 6c6:	8e b5       	in	r24, 0x2e	; 46
 6c8:	e8 2f       	mov	r30, r24
 6ca:	f0 e0       	ldi	r31, 0x00	; 0
 6cc:	e7 70       	andi	r30, 0x07	; 7
 6ce:	f0 70       	andi	r31, 0x00	; 0
 6d0:	ee 0f       	add	r30, r30
 6d2:	ff 1f       	adc	r31, r31
 6d4:	e4 52       	subi	r30, 0x24	; 36
 6d6:	ff 4f       	sbci	r31, 0xFF	; 255
 6d8:	25 91       	lpm	r18, Z+
 6da:	34 91       	lpm	r19, Z+
}
 6dc:	c9 01       	movw	r24, r18
 6de:	08 95       	ret

000006e0 <timer2GetPrescaler>:
{
	//TODO: can we assume for all 3-timer AVR processors,
	// that timer2 is the RTC timer?

	// get the current prescaler setting
	return (pgm_read_word(TimerRTCPrescaleFactor+(inb(TCCR2) & TIMER_PRESCALE_MASK)));
 6e0:	85 b5       	in	r24, 0x25	; 37
 6e2:	e8 2f       	mov	r30, r24
 6e4:	f0 e0       	ldi	r31, 0x00	; 0
 6e6:	e7 70       	andi	r30, 0x07	; 7
 6e8:	f0 70       	andi	r31, 0x00	; 0
 6ea:	ee 0f       	add	r30, r30
 6ec:	ff 1f       	adc	r31, r31
 6ee:	e8 51       	subi	r30, 0x18	; 24
 6f0:	ff 4f       	sbci	r31, 0xFF	; 255
 6f2:	25 91       	lpm	r18, Z+
 6f4:	34 91       	lpm	r19, Z+
}
 6f6:	c9 01       	movw	r24, r18
 6f8:	08 95       	ret

000006fa <timerAttach>:
#endif

void timerAttach(u08 interruptNum, void (*userFunc)(void) )
{
	// make sure the interrupt number is within bounds
	if(interruptNum < TIMER_NUM_INTERRUPTS)
 6fa:	88 30       	cpi	r24, 0x08	; 8
 6fc:	40 f4       	brcc	.+16     	; 0x70e <timerAttach+0x14>
	{
		// set the interrupt function to run
		// the supplied user's function
		TimerIntFunc[interruptNum] = userFunc;
 6fe:	e8 2f       	mov	r30, r24
 700:	f0 e0       	ldi	r31, 0x00	; 0
 702:	ee 0f       	add	r30, r30
 704:	ff 1f       	adc	r31, r31
 706:	e6 51       	subi	r30, 0x16	; 22
 708:	ff 4f       	sbci	r31, 0xFF	; 255
 70a:	71 83       	std	Z+1, r23	; 0x01
 70c:	60 83       	st	Z, r22
 70e:	08 95       	ret

00000710 <timerDetach>:
}

void timerDetach(u08 interruptNum)
{
	// make sure the interrupt number is within bounds
	if(interruptNum < TIMER_NUM_INTERRUPTS)
 710:	88 30       	cpi	r24, 0x08	; 8
 712:	40 f4       	brcc	.+16     	; 0x724 <timerDetach+0x14>
	{
		// set the interrupt function to run nothing
		TimerIntFunc[interruptNum] = 0;
 714:	e8 2f       	mov	r30, r24
 716:	f0 e0       	ldi	r31, 0x00	; 0
 718:	ee 0f       	add	r30, r30
 71a:	ff 1f       	adc	r31, r31
 71c:	e6 51       	subi	r30, 0x16	; 22
 71e:	ff 4f       	sbci	r31, 0xFF	; 255
 720:	11 82       	std	Z+1, r1	; 0x01
 722:	10 82       	st	Z, r1
 724:	08 95       	ret

00000726 <timerPause>:
	// calculate the number of milliseconds in x timer tics
	return (tics*1000*(prescaleDiv*256))/F_CPU;
}
*/
void timerPause(unsigned short pause_ms)
{
 726:	ef 92       	push	r14
 728:	ff 92       	push	r15
 72a:	0f 93       	push	r16
 72c:	1f 93       	push	r17
 72e:	cf 93       	push	r28
 730:	df 93       	push	r29
 732:	ec 01       	movw	r28, r24
	u08 timerThres;
	u32 ticRateHz;
	u32 pause;

	// capture current pause timer value
	timerThres = inb(TCNT0);
 734:	12 b7       	in	r17, 0x32	; 50
	// reset pause timer overflow count
	TimerPauseReg = 0;
 736:	10 92 fe 00 	sts	0x00FE, r1
 73a:	10 92 ff 00 	sts	0x00FF, r1
 73e:	10 92 00 01 	sts	0x0100, r1
 742:	10 92 01 01 	sts	0x0101, r1
#endif

u16 timer0GetPrescaler(void)
{
	// get the current prescaler setting
	return (pgm_read_word(TimerPrescaleFactor+(inb(TCCR0) & TIMER_PRESCALE_MASK)));
 746:	83 b7       	in	r24, 0x33	; 51
 748:	e8 2f       	mov	r30, r24
 74a:	f0 e0       	ldi	r31, 0x00	; 0
 74c:	e7 70       	andi	r30, 0x07	; 7
 74e:	f0 70       	andi	r31, 0x00	; 0
 750:	ee 0f       	add	r30, r30
 752:	ff 1f       	adc	r31, r31
 754:	e4 52       	subi	r30, 0x24	; 36
 756:	ff 4f       	sbci	r31, 0xFF	; 255
 758:	25 91       	lpm	r18, Z+
 75a:	34 91       	lpm	r19, Z+
	timerThres = inb(TCNT0);
	// reset pause timer overflow count
	TimerPauseReg = 0;
	// calculate delay for [pause_ms] milliseconds
	// prescaler division = 1<<(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)))
	ticRateHz = F_CPU/timer0GetPrescaler();
 75c:	40 e0       	ldi	r20, 0x00	; 0
 75e:	50 e0       	ldi	r21, 0x00	; 0
 760:	60 e0       	ldi	r22, 0x00	; 0
 762:	79 e0       	ldi	r23, 0x09	; 9
 764:	8d e3       	ldi	r24, 0x3D	; 61
 766:	90 e0       	ldi	r25, 0x00	; 0
 768:	0e 94 a8 07 	call	0xf50	; 0xf50 <__udivmodsi4>
 76c:	b9 01       	movw	r22, r18
 76e:	ca 01       	movw	r24, r20
	// precision management
	// prevent overflow and precision underflow
	//	-could add more conditions to improve accuracy
	if( ((ticRateHz < 429497) && (pause_ms <= 10000)) )
 770:	69 3b       	cpi	r22, 0xB9	; 185
 772:	2d e8       	ldi	r18, 0x8D	; 141
 774:	72 07       	cpc	r23, r18
 776:	26 e0       	ldi	r18, 0x06	; 6
 778:	82 07       	cpc	r24, r18
 77a:	20 e0       	ldi	r18, 0x00	; 0
 77c:	92 07       	cpc	r25, r18
 77e:	a0 f4       	brcc	.+40     	; 0x7a8 <timerPause+0x82>
 780:	37 e2       	ldi	r19, 0x27	; 39
 782:	c1 31       	cpi	r28, 0x11	; 17
 784:	d3 07       	cpc	r29, r19
 786:	80 f4       	brcc	.+32     	; 0x7a8 <timerPause+0x82>
		pause = (pause_ms*ticRateHz)/1000;
 788:	9e 01       	movw	r18, r28
 78a:	40 e0       	ldi	r20, 0x00	; 0
 78c:	50 e0       	ldi	r21, 0x00	; 0
 78e:	0e 94 75 07 	call	0xeea	; 0xeea <__mulsi3>
 792:	28 ee       	ldi	r18, 0xE8	; 232
 794:	33 e0       	ldi	r19, 0x03	; 3
 796:	40 e0       	ldi	r20, 0x00	; 0
 798:	50 e0       	ldi	r21, 0x00	; 0
 79a:	0e 94 a8 07 	call	0xf50	; 0xf50 <__udivmodsi4>
 79e:	c9 01       	movw	r24, r18
 7a0:	da 01       	movw	r26, r20
 7a2:	bc 01       	movw	r22, r24
 7a4:	cd 01       	movw	r24, r26
 7a6:	21 c0       	rjmp	.+66     	; 0x7ea <timerPause+0xc4>
	else
		pause = pause_ms*(ticRateHz/1000);
 7a8:	28 ee       	ldi	r18, 0xE8	; 232
 7aa:	33 e0       	ldi	r19, 0x03	; 3
 7ac:	40 e0       	ldi	r20, 0x00	; 0
 7ae:	50 e0       	ldi	r21, 0x00	; 0
 7b0:	0e 94 a8 07 	call	0xf50	; 0xf50 <__udivmodsi4>
 7b4:	ca 01       	movw	r24, r20
 7b6:	b9 01       	movw	r22, r18
 7b8:	9e 01       	movw	r18, r28
 7ba:	40 e0       	ldi	r20, 0x00	; 0
 7bc:	50 e0       	ldi	r21, 0x00	; 0
 7be:	0e 94 75 07 	call	0xeea	; 0xeea <__mulsi3>
 7c2:	13 c0       	rjmp	.+38     	; 0x7ea <timerPause+0xc4>

	// loop until time expires
	while( ((TimerPauseReg<<8) | inb(TCNT0)) < (pause+timerThres) )
	{
		if( TimerPauseReg < (pause>>8));
 7c4:	80 91 fe 00 	lds	r24, 0x00FE
 7c8:	90 91 ff 00 	lds	r25, 0x00FF
 7cc:	a0 91 00 01 	lds	r26, 0x0100
 7d0:	b0 91 01 01 	lds	r27, 0x0101
		{
			// save power by idling the processor
			set_sleep_mode(SLEEP_MODE_IDLE);
 7d4:	85 b7       	in	r24, 0x35	; 53
 7d6:	8f 78       	andi	r24, 0x8F	; 143
 7d8:	85 bf       	out	0x35, r24	; 53
			sleep_mode();
 7da:	85 b7       	in	r24, 0x35	; 53
 7dc:	80 68       	ori	r24, 0x80	; 128
 7de:	85 bf       	out	0x35, r24	; 53
 7e0:	88 95       	sleep
 7e2:	85 b7       	in	r24, 0x35	; 53
 7e4:	8f 77       	andi	r24, 0x7F	; 127
 7e6:	85 bf       	out	0x35, r24	; 53
 7e8:	08 c0       	rjmp	.+16     	; 0x7fa <timerPause+0xd4>
		pause = (pause_ms*ticRateHz)/1000;
	else
		pause = pause_ms*(ticRateHz/1000);

	// loop until time expires
	while( ((TimerPauseReg<<8) | inb(TCNT0)) < (pause+timerThres) )
 7ea:	9b 01       	movw	r18, r22
 7ec:	ac 01       	movw	r20, r24
 7ee:	21 0f       	add	r18, r17
 7f0:	31 1d       	adc	r19, r1
 7f2:	41 1d       	adc	r20, r1
 7f4:	51 1d       	adc	r21, r1
 7f6:	79 01       	movw	r14, r18
 7f8:	8a 01       	movw	r16, r20
 7fa:	20 91 fe 00 	lds	r18, 0x00FE
 7fe:	30 91 ff 00 	lds	r19, 0x00FF
 802:	40 91 00 01 	lds	r20, 0x0100
 806:	50 91 01 01 	lds	r21, 0x0101
 80a:	82 b7       	in	r24, 0x32	; 50
 80c:	90 e0       	ldi	r25, 0x00	; 0
 80e:	a0 e0       	ldi	r26, 0x00	; 0
 810:	b0 e0       	ldi	r27, 0x00	; 0
 812:	54 2f       	mov	r21, r20
 814:	43 2f       	mov	r20, r19
 816:	32 2f       	mov	r19, r18
 818:	22 27       	eor	r18, r18
 81a:	82 2b       	or	r24, r18
 81c:	93 2b       	or	r25, r19
 81e:	a4 2b       	or	r26, r20
 820:	b5 2b       	or	r27, r21
 822:	8e 15       	cp	r24, r14
 824:	9f 05       	cpc	r25, r15
 826:	a0 07       	cpc	r26, r16
 828:	b1 07       	cpc	r27, r17
 82a:	60 f2       	brcs	.-104    	; 0x7c4 <timerPause+0x9e>
	
	TimerPauseReg = 0;
	while(TimerPauseReg < pause);

	*/
}
 82c:	df 91       	pop	r29
 82e:	cf 91       	pop	r28
 830:	1f 91       	pop	r17
 832:	0f 91       	pop	r16
 834:	ff 90       	pop	r15
 836:	ef 90       	pop	r14
 838:	08 95       	ret

0000083a <timer0ClearOverflowCount>:

void timer0ClearOverflowCount(void)
{
	// clear the timer overflow counter registers
	Timer0Reg0 = 0;	// initialize time registers
 83a:	10 92 fa 00 	sts	0x00FA, r1
 83e:	10 92 fb 00 	sts	0x00FB, r1
 842:	10 92 fc 00 	sts	0x00FC, r1
 846:	10 92 fd 00 	sts	0x00FD, r1
}
 84a:	08 95       	ret

0000084c <timer0GetOverflowCount>:

long timer0GetOverflowCount(void)
{
	// return the current timer overflow count
	// (this is since the last timer0ClearOverflowCount() command was called)
	return Timer0Reg0;
 84c:	20 91 fa 00 	lds	r18, 0x00FA
 850:	30 91 fb 00 	lds	r19, 0x00FB
 854:	40 91 fc 00 	lds	r20, 0x00FC
 858:	50 91 fd 00 	lds	r21, 0x00FD
}
 85c:	b9 01       	movw	r22, r18
 85e:	ca 01       	movw	r24, r20
 860:	08 95       	ret

00000862 <timer2ClearOverflowCount>:

#ifdef TCNT2	// support timer2 only if it exists
void timer2ClearOverflowCount(void)
{
	// clear the timer overflow counter registers
	Timer2Reg0 = 0;	// initialize time registers
 862:	10 92 02 01 	sts	0x0102, r1
 866:	10 92 03 01 	sts	0x0103, r1
 86a:	10 92 04 01 	sts	0x0104, r1
 86e:	10 92 05 01 	sts	0x0105, r1
}
 872:	08 95       	ret

00000874 <timer2GetOverflowCount>:

long timer2GetOverflowCount(void)
{
	// return the current timer overflow count
	// (this is since the last timer2ClearOverflowCount() command was called)
	return Timer2Reg0;
 874:	20 91 02 01 	lds	r18, 0x0102
 878:	30 91 03 01 	lds	r19, 0x0103
 87c:	40 91 04 01 	lds	r20, 0x0104
 880:	50 91 05 01 	lds	r21, 0x0105
}
 884:	b9 01       	movw	r22, r18
 886:	ca 01       	movw	r24, r20
 888:	08 95       	ret

0000088a <timer1PWMInit>:
{
	// configures timer1 for use with PWM output
	// on OC1A and OC1B pins

	// enable timer1 as 8,9,10bit PWM
	if(bitRes == 9)
 88a:	89 30       	cpi	r24, 0x09	; 9
 88c:	31 f4       	brne	.+12     	; 0x89a <timer1PWMInit+0x10>
	{	// 9bit mode
		sbi(TCCR1A,PWM11);
 88e:	8f b5       	in	r24, 0x2f	; 47
 890:	82 60       	ori	r24, 0x02	; 2
 892:	8f bd       	out	0x2f, r24	; 47
		cbi(TCCR1A,PWM10);
 894:	8f b5       	in	r24, 0x2f	; 47
 896:	8e 7f       	andi	r24, 0xFE	; 254
 898:	0a c0       	rjmp	.+20     	; 0x8ae <timer1PWMInit+0x24>
	}
	else if( bitRes == 10 )
 89a:	8a 30       	cpi	r24, 0x0A	; 10
 89c:	19 f4       	brne	.+6      	; 0x8a4 <timer1PWMInit+0x1a>
	{	// 10bit mode
		sbi(TCCR1A,PWM11);
 89e:	8f b5       	in	r24, 0x2f	; 47
 8a0:	82 60       	ori	r24, 0x02	; 2
 8a2:	02 c0       	rjmp	.+4      	; 0x8a8 <timer1PWMInit+0x1e>
		sbi(TCCR1A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR1A,PWM11);
 8a4:	8f b5       	in	r24, 0x2f	; 47
 8a6:	8d 7f       	andi	r24, 0xFD	; 253
 8a8:	8f bd       	out	0x2f, r24	; 47
		sbi(TCCR1A,PWM10);
 8aa:	8f b5       	in	r24, 0x2f	; 47
 8ac:	81 60       	ori	r24, 0x01	; 1
 8ae:	8f bd       	out	0x2f, r24	; 47
	}

	// clear output compare value A
	outb(OCR1AH, 0);
 8b0:	1b bc       	out	0x2b, r1	; 43
	outb(OCR1AL, 0);
 8b2:	1a bc       	out	0x2a, r1	; 42
	// clear output compare value B
	outb(OCR1BH, 0);
 8b4:	19 bc       	out	0x29, r1	; 41
	outb(OCR1BL, 0);
 8b6:	18 bc       	out	0x28, r1	; 40
}
 8b8:	08 95       	ret

000008ba <timer1PWMInitICR>:
// include support for arbitrary top-count PWM
// on new AVR processors that support it
void timer1PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR1A,WGM10);
 8ba:	2f b5       	in	r18, 0x2f	; 47
 8bc:	2e 7f       	andi	r18, 0xFE	; 254
 8be:	2f bd       	out	0x2f, r18	; 47
	sbi(TCCR1A,WGM11);
 8c0:	2f b5       	in	r18, 0x2f	; 47
 8c2:	22 60       	ori	r18, 0x02	; 2
 8c4:	2f bd       	out	0x2f, r18	; 47
	sbi(TCCR1B,WGM12);
 8c6:	2e b5       	in	r18, 0x2e	; 46
 8c8:	28 60       	ori	r18, 0x08	; 8
 8ca:	2e bd       	out	0x2e, r18	; 46
	sbi(TCCR1B,WGM13);
 8cc:	2e b5       	in	r18, 0x2e	; 46
 8ce:	20 61       	ori	r18, 0x10	; 16
 8d0:	2e bd       	out	0x2e, r18	; 46
	
	// set top count value
	ICR1 = topcount;
 8d2:	97 bd       	out	0x27, r25	; 39
 8d4:	86 bd       	out	0x26, r24	; 38
	
	// clear output compare value A
	OCR1A = 0;
 8d6:	1b bc       	out	0x2b, r1	; 43
 8d8:	1a bc       	out	0x2a, r1	; 42
	// clear output compare value B
	OCR1B = 0;
 8da:	19 bc       	out	0x29, r1	; 41
 8dc:	18 bc       	out	0x28, r1	; 40

}
 8de:	08 95       	ret

000008e0 <timer1PWMOff>:
#endif

void timer1PWMOff(void)
{
	// turn off timer1 PWM mode
	cbi(TCCR1A,PWM11);
 8e0:	8f b5       	in	r24, 0x2f	; 47
 8e2:	8d 7f       	andi	r24, 0xFD	; 253
 8e4:	8f bd       	out	0x2f, r24	; 47
	cbi(TCCR1A,PWM10);
 8e6:	8f b5       	in	r24, 0x2f	; 47
 8e8:	8e 7f       	andi	r24, 0xFE	; 254
 8ea:	8f bd       	out	0x2f, r24	; 47

void timer1PWMAOff(void)
{
	// turn off channel A (OC1A) PWM output
	// set OC1A (OutputCompare action) to none
	cbi(TCCR1A,COM1A1);
 8ec:	8f b5       	in	r24, 0x2f	; 47
 8ee:	8f 77       	andi	r24, 0x7F	; 127
 8f0:	8f bd       	out	0x2f, r24	; 47
	cbi(TCCR1A,COM1A0);
 8f2:	8f b5       	in	r24, 0x2f	; 47
 8f4:	8f 7b       	andi	r24, 0xBF	; 191
 8f6:	8f bd       	out	0x2f, r24	; 47

void timer1PWMBOff(void)
{
	// turn off channel B (OC1B) PWM output
	// set OC1B (OutputCompare action) to none
	cbi(TCCR1A,COM1B1);
 8f8:	8f b5       	in	r24, 0x2f	; 47
 8fa:	8f 7d       	andi	r24, 0xDF	; 223
 8fc:	8f bd       	out	0x2f, r24	; 47
	cbi(TCCR1A,COM1B0);
 8fe:	8f b5       	in	r24, 0x2f	; 47
 900:	8f 7e       	andi	r24, 0xEF	; 239
 902:	8f bd       	out	0x2f, r24	; 47
	cbi(TCCR1A,PWM11);
	cbi(TCCR1A,PWM10);
	// set PWM1A/B (OutputCompare action) to none
	timer1PWMAOff();
	timer1PWMBOff();
}
 904:	08 95       	ret

00000906 <timer1PWMAOn>:

void timer1PWMAOn(void)
{
	// turn on channel A (OC1A) PWM output
	// set OC1A as non-inverted PWM
	sbi(TCCR1A,COM1A1);
 906:	8f b5       	in	r24, 0x2f	; 47
 908:	80 68       	ori	r24, 0x80	; 128
 90a:	8f bd       	out	0x2f, r24	; 47
	cbi(TCCR1A,COM1A0);
 90c:	8f b5       	in	r24, 0x2f	; 47
 90e:	8f 7b       	andi	r24, 0xBF	; 191
 910:	8f bd       	out	0x2f, r24	; 47
}
 912:	08 95       	ret

00000914 <timer1PWMBOn>:

void timer1PWMBOn(void)
{
	// turn on channel B (OC1B) PWM output
	// set OC1B as non-inverted PWM
	sbi(TCCR1A,COM1B1);
 914:	8f b5       	in	r24, 0x2f	; 47
 916:	80 62       	ori	r24, 0x20	; 32
 918:	8f bd       	out	0x2f, r24	; 47
	cbi(TCCR1A,COM1B0);
 91a:	8f b5       	in	r24, 0x2f	; 47
 91c:	8f 7e       	andi	r24, 0xEF	; 239
 91e:	8f bd       	out	0x2f, r24	; 47
}
 920:	08 95       	ret

00000922 <timer1PWMAOff>:

void timer1PWMAOff(void)
{
	// turn off channel A (OC1A) PWM output
	// set OC1A (OutputCompare action) to none
	cbi(TCCR1A,COM1A1);
 922:	8f b5       	in	r24, 0x2f	; 47
 924:	8f 77       	andi	r24, 0x7F	; 127
 926:	8f bd       	out	0x2f, r24	; 47
	cbi(TCCR1A,COM1A0);
 928:	8f b5       	in	r24, 0x2f	; 47
 92a:	8f 7b       	andi	r24, 0xBF	; 191
 92c:	8f bd       	out	0x2f, r24	; 47
}
 92e:	08 95       	ret

00000930 <timer1PWMBOff>:

void timer1PWMBOff(void)
{
	// turn off channel B (OC1B) PWM output
	// set OC1B (OutputCompare action) to none
	cbi(TCCR1A,COM1B1);
 930:	8f b5       	in	r24, 0x2f	; 47
 932:	8f 7d       	andi	r24, 0xDF	; 223
 934:	8f bd       	out	0x2f, r24	; 47
	cbi(TCCR1A,COM1B0);
 936:	8f b5       	in	r24, 0x2f	; 47
 938:	8f 7e       	andi	r24, 0xEF	; 239
 93a:	8f bd       	out	0x2f, r24	; 47
}
 93c:	08 95       	ret

0000093e <timer1PWMASet>:
	// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
	//			pwmDuty should be in the range 0-511 for 9bit PWM
	//			pwmDuty should be in the range 0-1023 for 10bit PWM
	//outp( (pwmDuty>>8), OCR1AH);		// set the high 8bits of OCR1A
	//outp( (pwmDuty&0x00FF), OCR1AL);	// set the low 8bits of OCR1A
	OCR1A = pwmDuty;
 93e:	9b bd       	out	0x2b, r25	; 43
 940:	8a bd       	out	0x2a, r24	; 42
}
 942:	08 95       	ret

00000944 <timer1PWMBSet>:
	// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
	//			pwmDuty should be in the range 0-511 for 9bit PWM
	//			pwmDuty should be in the range 0-1023 for 10bit PWM
	//outp( (pwmDuty>>8), OCR1BH);		// set the high 8bits of OCR1B
	//outp( (pwmDuty&0x00FF), OCR1BL);	// set the low 8bits of OCR1B
	OCR1B = pwmDuty;
 944:	99 bd       	out	0x29, r25	; 41
 946:	88 bd       	out	0x28, r24	; 40
}
 948:	08 95       	ret

0000094a <__vector_11>:

//! Interrupt handler for tcnt0 overflow interrupt
TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW0)
{
 94a:	1f 92       	push	r1
 94c:	0f 92       	push	r0
 94e:	0f b6       	in	r0, 0x3f	; 63
 950:	0f 92       	push	r0
 952:	11 24       	eor	r1, r1
 954:	2f 93       	push	r18
 956:	3f 93       	push	r19
 958:	4f 93       	push	r20
 95a:	5f 93       	push	r21
 95c:	6f 93       	push	r22
 95e:	7f 93       	push	r23
 960:	8f 93       	push	r24
 962:	9f 93       	push	r25
 964:	af 93       	push	r26
 966:	bf 93       	push	r27
 968:	ef 93       	push	r30
 96a:	ff 93       	push	r31
	Timer0Reg0++;			// increment low-order counter
 96c:	80 91 fa 00 	lds	r24, 0x00FA
 970:	90 91 fb 00 	lds	r25, 0x00FB
 974:	a0 91 fc 00 	lds	r26, 0x00FC
 978:	b0 91 fd 00 	lds	r27, 0x00FD
 97c:	01 96       	adiw	r24, 0x01	; 1
 97e:	a1 1d       	adc	r26, r1
 980:	b1 1d       	adc	r27, r1
 982:	80 93 fa 00 	sts	0x00FA, r24
 986:	90 93 fb 00 	sts	0x00FB, r25
 98a:	a0 93 fc 00 	sts	0x00FC, r26
 98e:	b0 93 fd 00 	sts	0x00FD, r27

	// increment pause counter
	TimerPauseReg++;
 992:	80 91 fe 00 	lds	r24, 0x00FE
 996:	90 91 ff 00 	lds	r25, 0x00FF
 99a:	a0 91 00 01 	lds	r26, 0x0100
 99e:	b0 91 01 01 	lds	r27, 0x0101
 9a2:	01 96       	adiw	r24, 0x01	; 1
 9a4:	a1 1d       	adc	r26, r1
 9a6:	b1 1d       	adc	r27, r1
 9a8:	80 93 fe 00 	sts	0x00FE, r24
 9ac:	90 93 ff 00 	sts	0x00FF, r25
 9b0:	a0 93 00 01 	sts	0x0100, r26
 9b4:	b0 93 01 01 	sts	0x0101, r27

	// if a user function is defined, execute it too
	if(TimerIntFunc[TIMER0OVERFLOW_INT])
 9b8:	80 91 ea 00 	lds	r24, 0x00EA
 9bc:	90 91 eb 00 	lds	r25, 0x00EB
 9c0:	89 2b       	or	r24, r25
 9c2:	29 f0       	breq	.+10     	; 0x9ce <__vector_11+0x84>
		TimerIntFunc[TIMER0OVERFLOW_INT]();
 9c4:	e0 91 ea 00 	lds	r30, 0x00EA
 9c8:	f0 91 eb 00 	lds	r31, 0x00EB
 9cc:	09 95       	icall
}
 9ce:	ff 91       	pop	r31
 9d0:	ef 91       	pop	r30
 9d2:	bf 91       	pop	r27
 9d4:	af 91       	pop	r26
 9d6:	9f 91       	pop	r25
 9d8:	8f 91       	pop	r24
 9da:	7f 91       	pop	r23
 9dc:	6f 91       	pop	r22
 9de:	5f 91       	pop	r21
 9e0:	4f 91       	pop	r20
 9e2:	3f 91       	pop	r19
 9e4:	2f 91       	pop	r18
 9e6:	0f 90       	pop	r0
 9e8:	0f be       	out	0x3f, r0	; 63
 9ea:	0f 90       	pop	r0
 9ec:	1f 90       	pop	r1
 9ee:	18 95       	reti

000009f0 <__vector_9>:

//! Interrupt handler for tcnt1 overflow interrupt
TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW1)
{
 9f0:	1f 92       	push	r1
 9f2:	0f 92       	push	r0
 9f4:	0f b6       	in	r0, 0x3f	; 63
 9f6:	0f 92       	push	r0
 9f8:	11 24       	eor	r1, r1
 9fa:	2f 93       	push	r18
 9fc:	3f 93       	push	r19
 9fe:	4f 93       	push	r20
 a00:	5f 93       	push	r21
 a02:	6f 93       	push	r22
 a04:	7f 93       	push	r23
 a06:	8f 93       	push	r24
 a08:	9f 93       	push	r25
 a0a:	af 93       	push	r26
 a0c:	bf 93       	push	r27
 a0e:	ef 93       	push	r30
 a10:	ff 93       	push	r31
	// if a user function is defined, execute it
	if(TimerIntFunc[TIMER1OVERFLOW_INT])
 a12:	80 91 ec 00 	lds	r24, 0x00EC
 a16:	90 91 ed 00 	lds	r25, 0x00ED
 a1a:	89 2b       	or	r24, r25
 a1c:	29 f0       	breq	.+10     	; 0xa28 <__vector_9+0x38>
		TimerIntFunc[TIMER1OVERFLOW_INT]();
 a1e:	e0 91 ec 00 	lds	r30, 0x00EC
 a22:	f0 91 ed 00 	lds	r31, 0x00ED
 a26:	09 95       	icall
}
 a28:	ff 91       	pop	r31
 a2a:	ef 91       	pop	r30
 a2c:	bf 91       	pop	r27
 a2e:	af 91       	pop	r26
 a30:	9f 91       	pop	r25
 a32:	8f 91       	pop	r24
 a34:	7f 91       	pop	r23
 a36:	6f 91       	pop	r22
 a38:	5f 91       	pop	r21
 a3a:	4f 91       	pop	r20
 a3c:	3f 91       	pop	r19
 a3e:	2f 91       	pop	r18
 a40:	0f 90       	pop	r0
 a42:	0f be       	out	0x3f, r0	; 63
 a44:	0f 90       	pop	r0
 a46:	1f 90       	pop	r1
 a48:	18 95       	reti

00000a4a <__vector_5>:

#ifdef TCNT2	// support timer2 only if it exists
//! Interrupt handler for tcnt2 overflow interrupt
TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW2)
{
 a4a:	1f 92       	push	r1
 a4c:	0f 92       	push	r0
 a4e:	0f b6       	in	r0, 0x3f	; 63
 a50:	0f 92       	push	r0
 a52:	11 24       	eor	r1, r1
 a54:	2f 93       	push	r18
 a56:	3f 93       	push	r19
 a58:	4f 93       	push	r20
 a5a:	5f 93       	push	r21
 a5c:	6f 93       	push	r22
 a5e:	7f 93       	push	r23
 a60:	8f 93       	push	r24
 a62:	9f 93       	push	r25
 a64:	af 93       	push	r26
 a66:	bf 93       	push	r27
 a68:	ef 93       	push	r30
 a6a:	ff 93       	push	r31
	Timer2Reg0++;			// increment low-order counter
 a6c:	80 91 02 01 	lds	r24, 0x0102
 a70:	90 91 03 01 	lds	r25, 0x0103
 a74:	a0 91 04 01 	lds	r26, 0x0104
 a78:	b0 91 05 01 	lds	r27, 0x0105
 a7c:	01 96       	adiw	r24, 0x01	; 1
 a7e:	a1 1d       	adc	r26, r1
 a80:	b1 1d       	adc	r27, r1
 a82:	80 93 02 01 	sts	0x0102, r24
 a86:	90 93 03 01 	sts	0x0103, r25
 a8a:	a0 93 04 01 	sts	0x0104, r26
 a8e:	b0 93 05 01 	sts	0x0105, r27

	// if a user function is defined, execute it
	if(TimerIntFunc[TIMER2OVERFLOW_INT])
 a92:	80 91 f4 00 	lds	r24, 0x00F4
 a96:	90 91 f5 00 	lds	r25, 0x00F5
 a9a:	89 2b       	or	r24, r25
 a9c:	29 f0       	breq	.+10     	; 0xaa8 <__vector_5+0x5e>
		TimerIntFunc[TIMER2OVERFLOW_INT]();
 a9e:	e0 91 f4 00 	lds	r30, 0x00F4
 aa2:	f0 91 f5 00 	lds	r31, 0x00F5
 aa6:	09 95       	icall
}
 aa8:	ff 91       	pop	r31
 aaa:	ef 91       	pop	r30
 aac:	bf 91       	pop	r27
 aae:	af 91       	pop	r26
 ab0:	9f 91       	pop	r25
 ab2:	8f 91       	pop	r24
 ab4:	7f 91       	pop	r23
 ab6:	6f 91       	pop	r22
 ab8:	5f 91       	pop	r21
 aba:	4f 91       	pop	r20
 abc:	3f 91       	pop	r19
 abe:	2f 91       	pop	r18
 ac0:	0f 90       	pop	r0
 ac2:	0f be       	out	0x3f, r0	; 63
 ac4:	0f 90       	pop	r0
 ac6:	1f 90       	pop	r1
 ac8:	18 95       	reti

00000aca <__vector_10>:

#ifdef OCR0
// include support for Output Compare 0 for new AVR processors that support it
//! Interrupt handler for OutputCompare0 match (OC0) interrupt
TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE0)
{
 aca:	1f 92       	push	r1
 acc:	0f 92       	push	r0
 ace:	0f b6       	in	r0, 0x3f	; 63
 ad0:	0f 92       	push	r0
 ad2:	11 24       	eor	r1, r1
 ad4:	2f 93       	push	r18
 ad6:	3f 93       	push	r19
 ad8:	4f 93       	push	r20
 ada:	5f 93       	push	r21
 adc:	6f 93       	push	r22
 ade:	7f 93       	push	r23
 ae0:	8f 93       	push	r24
 ae2:	9f 93       	push	r25
 ae4:	af 93       	push	r26
 ae6:	bf 93       	push	r27
 ae8:	ef 93       	push	r30
 aea:	ff 93       	push	r31
	// if a user function is defined, execute it
	if(TimerIntFunc[TIMER0OUTCOMPARE_INT])
 aec:	80 91 f8 00 	lds	r24, 0x00F8
 af0:	90 91 f9 00 	lds	r25, 0x00F9
 af4:	89 2b       	or	r24, r25
 af6:	29 f0       	breq	.+10     	; 0xb02 <__vector_10+0x38>
		TimerIntFunc[TIMER0OUTCOMPARE_INT]();
 af8:	e0 91 f8 00 	lds	r30, 0x00F8
 afc:	f0 91 f9 00 	lds	r31, 0x00F9
 b00:	09 95       	icall
}
 b02:	ff 91       	pop	r31
 b04:	ef 91       	pop	r30
 b06:	bf 91       	pop	r27
 b08:	af 91       	pop	r26
 b0a:	9f 91       	pop	r25
 b0c:	8f 91       	pop	r24
 b0e:	7f 91       	pop	r23
 b10:	6f 91       	pop	r22
 b12:	5f 91       	pop	r21
 b14:	4f 91       	pop	r20
 b16:	3f 91       	pop	r19
 b18:	2f 91       	pop	r18
 b1a:	0f 90       	pop	r0
 b1c:	0f be       	out	0x3f, r0	; 63
 b1e:	0f 90       	pop	r0
 b20:	1f 90       	pop	r1
 b22:	18 95       	reti

00000b24 <__vector_7>:
#endif

//! Interrupt handler for CutputCompare1A match (OC1A) interrupt
TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1A)
{
 b24:	1f 92       	push	r1
 b26:	0f 92       	push	r0
 b28:	0f b6       	in	r0, 0x3f	; 63
 b2a:	0f 92       	push	r0
 b2c:	11 24       	eor	r1, r1
 b2e:	2f 93       	push	r18
 b30:	3f 93       	push	r19
 b32:	4f 93       	push	r20
 b34:	5f 93       	push	r21
 b36:	6f 93       	push	r22
 b38:	7f 93       	push	r23
 b3a:	8f 93       	push	r24
 b3c:	9f 93       	push	r25
 b3e:	af 93       	push	r26
 b40:	bf 93       	push	r27
 b42:	ef 93       	push	r30
 b44:	ff 93       	push	r31
	// if a user function is defined, execute it
	if(TimerIntFunc[TIMER1OUTCOMPAREA_INT])
 b46:	80 91 ee 00 	lds	r24, 0x00EE
 b4a:	90 91 ef 00 	lds	r25, 0x00EF
 b4e:	89 2b       	or	r24, r25
 b50:	29 f0       	breq	.+10     	; 0xb5c <__vector_7+0x38>
		TimerIntFunc[TIMER1OUTCOMPAREA_INT]();
 b52:	e0 91 ee 00 	lds	r30, 0x00EE
 b56:	f0 91 ef 00 	lds	r31, 0x00EF
 b5a:	09 95       	icall
}
 b5c:	ff 91       	pop	r31
 b5e:	ef 91       	pop	r30
 b60:	bf 91       	pop	r27
 b62:	af 91       	pop	r26
 b64:	9f 91       	pop	r25
 b66:	8f 91       	pop	r24
 b68:	7f 91       	pop	r23
 b6a:	6f 91       	pop	r22
 b6c:	5f 91       	pop	r21
 b6e:	4f 91       	pop	r20
 b70:	3f 91       	pop	r19
 b72:	2f 91       	pop	r18
 b74:	0f 90       	pop	r0
 b76:	0f be       	out	0x3f, r0	; 63
 b78:	0f 90       	pop	r0
 b7a:	1f 90       	pop	r1
 b7c:	18 95       	reti

00000b7e <__vector_8>:

//! Interrupt handler for OutputCompare1B match (OC1B) interrupt
TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1B)
{
 b7e:	1f 92       	push	r1
 b80:	0f 92       	push	r0
 b82:	0f b6       	in	r0, 0x3f	; 63
 b84:	0f 92       	push	r0
 b86:	11 24       	eor	r1, r1
 b88:	2f 93       	push	r18
 b8a:	3f 93       	push	r19
 b8c:	4f 93       	push	r20
 b8e:	5f 93       	push	r21
 b90:	6f 93       	push	r22
 b92:	7f 93       	push	r23
 b94:	8f 93       	push	r24
 b96:	9f 93       	push	r25
 b98:	af 93       	push	r26
 b9a:	bf 93       	push	r27
 b9c:	ef 93       	push	r30
 b9e:	ff 93       	push	r31
	// if a user function is defined, execute it
	if(TimerIntFunc[TIMER1OUTCOMPAREB_INT])
 ba0:	80 91 f0 00 	lds	r24, 0x00F0
 ba4:	90 91 f1 00 	lds	r25, 0x00F1
 ba8:	89 2b       	or	r24, r25
 baa:	29 f0       	breq	.+10     	; 0xbb6 <__vector_8+0x38>
		TimerIntFunc[TIMER1OUTCOMPAREB_INT]();
 bac:	e0 91 f0 00 	lds	r30, 0x00F0
 bb0:	f0 91 f1 00 	lds	r31, 0x00F1
 bb4:	09 95       	icall
}
 bb6:	ff 91       	pop	r31
 bb8:	ef 91       	pop	r30
 bba:	bf 91       	pop	r27
 bbc:	af 91       	pop	r26
 bbe:	9f 91       	pop	r25
 bc0:	8f 91       	pop	r24
 bc2:	7f 91       	pop	r23
 bc4:	6f 91       	pop	r22
 bc6:	5f 91       	pop	r21
 bc8:	4f 91       	pop	r20
 bca:	3f 91       	pop	r19
 bcc:	2f 91       	pop	r18
 bce:	0f 90       	pop	r0
 bd0:	0f be       	out	0x3f, r0	; 63
 bd2:	0f 90       	pop	r0
 bd4:	1f 90       	pop	r1
 bd6:	18 95       	reti

00000bd8 <__vector_6>:

//! Interrupt handler for InputCapture1 (IC1) interrupt
TIMER_INTERRUPT_HANDLER(SIG_INPUT_CAPTURE1)
{
 bd8:	1f 92       	push	r1
 bda:	0f 92       	push	r0
 bdc:	0f b6       	in	r0, 0x3f	; 63
 bde:	0f 92       	push	r0
 be0:	11 24       	eor	r1, r1
 be2:	2f 93       	push	r18
 be4:	3f 93       	push	r19
 be6:	4f 93       	push	r20
 be8:	5f 93       	push	r21
 bea:	6f 93       	push	r22
 bec:	7f 93       	push	r23
 bee:	8f 93       	push	r24
 bf0:	9f 93       	push	r25
 bf2:	af 93       	push	r26
 bf4:	bf 93       	push	r27
 bf6:	ef 93       	push	r30
 bf8:	ff 93       	push	r31
	// if a user function is defined, execute it
	if(TimerIntFunc[TIMER1INPUTCAPTURE_INT])
 bfa:	80 91 f2 00 	lds	r24, 0x00F2
 bfe:	90 91 f3 00 	lds	r25, 0x00F3
 c02:	89 2b       	or	r24, r25
 c04:	29 f0       	breq	.+10     	; 0xc10 <__vector_6+0x38>
		TimerIntFunc[TIMER1INPUTCAPTURE_INT]();
 c06:	e0 91 f2 00 	lds	r30, 0x00F2
 c0a:	f0 91 f3 00 	lds	r31, 0x00F3
 c0e:	09 95       	icall
}
 c10:	ff 91       	pop	r31
 c12:	ef 91       	pop	r30
 c14:	bf 91       	pop	r27
 c16:	af 91       	pop	r26
 c18:	9f 91       	pop	r25
 c1a:	8f 91       	pop	r24
 c1c:	7f 91       	pop	r23
 c1e:	6f 91       	pop	r22
 c20:	5f 91       	pop	r21
 c22:	4f 91       	pop	r20
 c24:	3f 91       	pop	r19
 c26:	2f 91       	pop	r18
 c28:	0f 90       	pop	r0
 c2a:	0f be       	out	0x3f, r0	; 63
 c2c:	0f 90       	pop	r0
 c2e:	1f 90       	pop	r1
 c30:	18 95       	reti

00000c32 <__vector_4>:

//! Interrupt handler for OutputCompare2 match (OC2) interrupt
TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE2)
{
 c32:	1f 92       	push	r1
 c34:	0f 92       	push	r0
 c36:	0f b6       	in	r0, 0x3f	; 63
 c38:	0f 92       	push	r0
 c3a:	11 24       	eor	r1, r1
 c3c:	2f 93       	push	r18
 c3e:	3f 93       	push	r19
 c40:	4f 93       	push	r20
 c42:	5f 93       	push	r21
 c44:	6f 93       	push	r22
 c46:	7f 93       	push	r23
 c48:	8f 93       	push	r24
 c4a:	9f 93       	push	r25
 c4c:	af 93       	push	r26
 c4e:	bf 93       	push	r27
 c50:	ef 93       	push	r30
 c52:	ff 93       	push	r31
	// if a user function is defined, execute it
	if(TimerIntFunc[TIMER2OUTCOMPARE_INT])
 c54:	80 91 f6 00 	lds	r24, 0x00F6
 c58:	90 91 f7 00 	lds	r25, 0x00F7
 c5c:	89 2b       	or	r24, r25
 c5e:	29 f0       	breq	.+10     	; 0xc6a <__vector_4+0x38>
		TimerIntFunc[TIMER2OUTCOMPARE_INT]();
 c60:	e0 91 f6 00 	lds	r30, 0x00F6
 c64:	f0 91 f7 00 	lds	r31, 0x00F7
 c68:	09 95       	icall
}
 c6a:	ff 91       	pop	r31
 c6c:	ef 91       	pop	r30
 c6e:	bf 91       	pop	r27
 c70:	af 91       	pop	r26
 c72:	9f 91       	pop	r25
 c74:	8f 91       	pop	r24
 c76:	7f 91       	pop	r23
 c78:	6f 91       	pop	r22
 c7a:	5f 91       	pop	r21
 c7c:	4f 91       	pop	r20
 c7e:	3f 91       	pop	r19
 c80:	2f 91       	pop	r18
 c82:	0f 90       	pop	r0
 c84:	0f be       	out	0x3f, r0	; 63
 c86:	0f 90       	pop	r0
 c88:	1f 90       	pop	r1
 c8a:	18 95       	reti

00000c8c <spiInit>:
    cbi(DDRB, 4);   // set MISO as input
    sbi(DDRB, 3);   // set MOSI as output
    sbi(DDRB, 2);   // SS must be output for Master mode to work
#else
	// setup SPI I/O pins
	sbi(PORTB, 7);	// set SCK hi
 c8c:	c7 9a       	sbi	0x18, 7	; 24
	sbi(DDRB, 7);	// set SCK as output
 c8e:	bf 9a       	sbi	0x17, 7	; 23
	cbi(DDRB, 6);	// set MISO as input
 c90:	be 98       	cbi	0x17, 6	; 23
	sbi(DDRB, 5);	// set MOSI as output
 c92:	bd 9a       	sbi	0x17, 5	; 23
	sbi(DDRB, 4);	// SS must be output for Master mode to work
 c94:	bc 9a       	sbi	0x17, 4	; 23
#endif
	
	// setup SPI interface :
	// master mode
	sbi(SPCR, MSTR);
 c96:	6c 9a       	sbi	0x0d, 4	; 13
	// clock = f/4
//	cbi(SPCR, SPR0);
//	cbi(SPCR, SPR1);
	// clock = f/16
	cbi(SPCR, SPR0);
 c98:	68 98       	cbi	0x0d, 0	; 13
	sbi(SPCR, SPR1);
 c9a:	69 9a       	sbi	0x0d, 1	; 13
	// select clock phase positive-going in middle of data
	cbi(SPCR, CPOL);
 c9c:	6b 98       	cbi	0x0d, 3	; 13
	// Data order MSB first
	cbi(SPCR,DORD);
 c9e:	6d 98       	cbi	0x0d, 5	; 13
	// enable SPI
	sbi(SPCR, SPE);
 ca0:	6e 9a       	sbi	0x0d, 6	; 13
	//outp((1<<MSTR)|(1<<SPE)|(1<<SPR0), SPCR );
	//outp((1<<CPHA)|(1<<CPOL)|(1<<MSTR)|(1<<SPE)|(1<<SPR0)|(1<<SPR1), SPCR );
	//outp((1<<CPHA)|(1<<MSTR)|(1<<SPE)|(1<<SPR0), SPCR );
	
	// clear status
	inb(SPSR);
 ca2:	8e b1       	in	r24, 0x0e	; 14
	spiTransferComplete = TRUE;
 ca4:	8f ef       	ldi	r24, 0xFF	; 255
 ca6:	80 93 06 01 	sts	0x0106, r24

	// enable SPI interrupt
	#ifdef SPI_USEINT
	sbi(SPCR, SPIE);
	#endif
}
 caa:	08 95       	ret

00000cac <spiSendByte>:
{
	// send a byte over SPI and ignore reply
	#ifdef SPI_USEINT
		while(!spiTransferComplete);
	#else
		while(!(inb(SPSR) & (1<<SPIF)));
 cac:	77 9b       	sbis	0x0e, 7	; 14
 cae:	fe cf       	rjmp	.-4      	; 0xcac <spiSendByte>
	#endif

	spiTransferComplete = FALSE;
 cb0:	10 92 06 01 	sts	0x0106, r1
	outb(SPDR, data);
 cb4:	8f b9       	out	0x0f, r24	; 15
}
 cb6:	08 95       	ret

00000cb8 <spiTransferByte>:
	#else
		while(!(inb(SPSR) & (1<<SPIF)));
	#endif
*/
	// send the given data
	spiTransferComplete = FALSE;
 cb8:	10 92 06 01 	sts	0x0106, r1
	outb(SPDR, data);
 cbc:	8f b9       	out	0x0f, r24	; 15

	// wait for transfer to complete
	#ifdef SPI_USEINT
		while(!spiTransferComplete);
	#else
		while(!(inb(SPSR) & (1<<SPIF)));
 cbe:	77 9b       	sbis	0x0e, 7	; 14
 cc0:	fe cf       	rjmp	.-4      	; 0xcbe <spiTransferByte+0x6>
		// *** reading of the SPSR and SPDR are crucial
		// *** to the clearing of the SPIF flag
		// *** in non-interrupt mode
		//inb(SPDR);
		// set flag
		spiTransferComplete = TRUE;
 cc2:	8f ef       	ldi	r24, 0xFF	; 255
 cc4:	80 93 06 01 	sts	0x0106, r24
	#endif
	// return the received data
	return inb(SPDR);
 cc8:	8f b1       	in	r24, 0x0f	; 15
}
 cca:	08 95       	ret

00000ccc <spiTransferWord>:

u16 spiTransferWord(u16 data)
{
 ccc:	28 2f       	mov	r18, r24
	#else
		while(!(inb(SPSR) & (1<<SPIF)));
	#endif
*/
	// send the given data
	spiTransferComplete = FALSE;
 cce:	10 92 06 01 	sts	0x0106, r1
	outb(SPDR, data);
 cd2:	9f b9       	out	0x0f, r25	; 15

	// wait for transfer to complete
	#ifdef SPI_USEINT
		while(!spiTransferComplete);
	#else
		while(!(inb(SPSR) & (1<<SPIF)));
 cd4:	77 9b       	sbis	0x0e, 7	; 14
 cd6:	fe cf       	rjmp	.-4      	; 0xcd4 <spiTransferWord+0x8>
		// *** reading of the SPSR and SPDR are crucial
		// *** to the clearing of the SPIF flag
		// *** in non-interrupt mode
		//inb(SPDR);
		// set flag
		spiTransferComplete = TRUE;
 cd8:	8f ef       	ldi	r24, 0xFF	; 255
 cda:	80 93 06 01 	sts	0x0106, r24
	#endif
	// return the received data
	return inb(SPDR);
 cde:	3f b1       	in	r19, 0x0f	; 15
	#else
		while(!(inb(SPSR) & (1<<SPIF)));
	#endif
*/
	// send the given data
	spiTransferComplete = FALSE;
 ce0:	10 92 06 01 	sts	0x0106, r1
	outb(SPDR, data);
 ce4:	2f b9       	out	0x0f, r18	; 15

	// wait for transfer to complete
	#ifdef SPI_USEINT
		while(!spiTransferComplete);
	#else
		while(!(inb(SPSR) & (1<<SPIF)));
 ce6:	77 9b       	sbis	0x0e, 7	; 14
 ce8:	fe cf       	rjmp	.-4      	; 0xce6 <spiTransferWord+0x1a>
		// *** reading of the SPSR and SPDR are crucial
		// *** to the clearing of the SPIF flag
		// *** in non-interrupt mode
		//inb(SPDR);
		// set flag
		spiTransferComplete = TRUE;
 cea:	8f ef       	ldi	r24, 0xFF	; 255
 cec:	80 93 06 01 	sts	0x0106, r24
	#endif
	// return the received data
	return inb(SPDR);
 cf0:	2f b1       	in	r18, 0x0f	; 15
u16 spiTransferWord(u16 data)
{
	u16 rxData = 0;

	// send MS byte of given data
	rxData = (spiTransferByte((data>>8) & 0x00FF))<<8;
 cf2:	93 2f       	mov	r25, r19
 cf4:	80 e0       	ldi	r24, 0x00	; 0
 cf6:	30 e0       	ldi	r19, 0x00	; 0
 cf8:	28 2b       	or	r18, r24
 cfa:	39 2b       	or	r19, r25
	// send LS byte of given data
	rxData |= (spiTransferByte(data & 0x00FF));

	// return the received data
	return rxData;
}
 cfc:	c9 01       	movw	r24, r18
 cfe:	08 95       	ret

00000d00 <mmcCommand>:
	// return success
	return 0;
}

u08 mmcCommand(u08 cmd, u32 arg)
{
 d00:	ef 92       	push	r14
 d02:	ff 92       	push	r15
 d04:	0f 93       	push	r16
 d06:	1f 93       	push	r17
 d08:	7a 01       	movw	r14, r20
 d0a:	8b 01       	movw	r16, r22
	u08 r1;
	u08 retry=0;
	// send command
	spiTransferByte(cmd | 0x40);
 d0c:	80 64       	ori	r24, 0x40	; 64
 d0e:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
	spiTransferByte(arg>>24);
 d12:	81 2f       	mov	r24, r17
 d14:	99 27       	eor	r25, r25
 d16:	aa 27       	eor	r26, r26
 d18:	bb 27       	eor	r27, r27
 d1a:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
	spiTransferByte(arg>>16);
 d1e:	c8 01       	movw	r24, r16
 d20:	aa 27       	eor	r26, r26
 d22:	bb 27       	eor	r27, r27
 d24:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
	spiTransferByte(arg>>8);
 d28:	bb 27       	eor	r27, r27
 d2a:	a1 2f       	mov	r26, r17
 d2c:	90 2f       	mov	r25, r16
 d2e:	8f 2d       	mov	r24, r15
 d30:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
	spiTransferByte(arg);
 d34:	8e 2d       	mov	r24, r14
 d36:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
	spiTransferByte(0x95);	// crc valid only for MMC_GO_IDLE_STATE
 d3a:	85 e9       	ldi	r24, 0x95	; 149
 d3c:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
 d40:	10 e0       	ldi	r17, 0x00	; 0
 d42:	03 c0       	rjmp	.+6      	; 0xd4a <mmcCommand+0x4a>
	// end command
	// wait for response
	// if more than 8 retries, card has timed-out
	// return the received 0xFF
	while((r1 = spiTransferByte(0xFF)) == 0xFF)
		if(retry++ > 8) break;
 d44:	19 30       	cpi	r17, 0x09	; 9
 d46:	31 f0       	breq	.+12     	; 0xd54 <mmcCommand+0x54>
 d48:	1f 5f       	subi	r17, 0xFF	; 255
	spiTransferByte(0x95);	// crc valid only for MMC_GO_IDLE_STATE
	// end command
	// wait for response
	// if more than 8 retries, card has timed-out
	// return the received 0xFF
	while((r1 = spiTransferByte(0xFF)) == 0xFF)
 d4a:	8f ef       	ldi	r24, 0xFF	; 255
 d4c:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
 d50:	8f 3f       	cpi	r24, 0xFF	; 255
 d52:	c1 f3       	breq	.-16     	; 0xd44 <mmcCommand+0x44>
		if(retry++ > 8) break;
	// return response
	return r1;
}
 d54:	1f 91       	pop	r17
 d56:	0f 91       	pop	r16
 d58:	ff 90       	pop	r15
 d5a:	ef 90       	pop	r14
 d5c:	08 95       	ret

00000d5e <mmcSendCommand>:
u08 mmcSendCommand(u08 cmd, u32 arg)
{
	u08 r1;

	// assert chip select
	cbi(MMC_CS_PORT,MMC_CS_PIN);
 d5e:	c4 98       	cbi	0x18, 4	; 24
	// issue the command
	r1 = mmcCommand(cmd, arg);
 d60:	0e 94 80 06 	call	0xd00	; 0xd00 <mmcCommand>
	// release chip select
	sbi(MMC_CS_PORT,MMC_CS_PIN);
 d64:	c4 9a       	sbi	0x18, 4	; 24

	return r1;
}
 d66:	08 95       	ret

00000d68 <mmcWrite>:
	// return success
	return 0;
}

u08 mmcWrite(u32 sector, u08* buffer)
{
 d68:	ef 92       	push	r14
 d6a:	ff 92       	push	r15
 d6c:	0f 93       	push	r16
 d6e:	1f 93       	push	r17
 d70:	cf 93       	push	r28
 d72:	df 93       	push	r29
 d74:	8b 01       	movw	r16, r22
 d76:	9c 01       	movw	r18, r24
 d78:	7a 01       	movw	r14, r20
	u08 r1;
	u16 i;

	// assert chip select
	cbi(MMC_CS_PORT,MMC_CS_PIN);
 d7a:	c4 98       	cbi	0x18, 4	; 24
	// issue command
	r1 = mmcCommand(MMC_WRITE_BLOCK, sector<<9);
 d7c:	49 e0       	ldi	r20, 0x09	; 9
 d7e:	00 0f       	add	r16, r16
 d80:	11 1f       	adc	r17, r17
 d82:	22 1f       	adc	r18, r18
 d84:	33 1f       	adc	r19, r19
 d86:	4a 95       	dec	r20
 d88:	d1 f7       	brne	.-12     	; 0xd7e <mmcWrite+0x16>
 d8a:	88 e1       	ldi	r24, 0x18	; 24
 d8c:	b9 01       	movw	r22, r18
 d8e:	a8 01       	movw	r20, r16
 d90:	0e 94 80 06 	call	0xd00	; 0xd00 <mmcCommand>
	#ifdef MMC_DEBUG
	rprintf("MMC Write Block R1=0x%x\r\n", r1);
	#endif
	// check for valid response
	if(r1 != 0x00)
 d94:	88 23       	and	r24, r24
 d96:	11 f0       	breq	.+4      	; 0xd9c <mmcWrite+0x34>
 d98:	98 2f       	mov	r25, r24
 d9a:	26 c0       	rjmp	.+76     	; 0xde8 <mmcWrite+0x80>
		return r1;
	// send dummy
	spiTransferByte(0xFF);
 d9c:	8f ef       	ldi	r24, 0xFF	; 255
 d9e:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
	// send data start token
	spiTransferByte(MMC_STARTBLOCK_WRITE);
 da2:	8e ef       	ldi	r24, 0xFE	; 254
 da4:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
 da8:	c0 e0       	ldi	r28, 0x00	; 0
 daa:	d0 e0       	ldi	r29, 0x00	; 0
	// write data
	for(i=0; i<0x200; i++)
	{
		spiTransferByte(*buffer++);
 dac:	f7 01       	movw	r30, r14
 dae:	81 91       	ld	r24, Z+
 db0:	7f 01       	movw	r14, r30
 db2:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
	// send dummy
	spiTransferByte(0xFF);
	// send data start token
	spiTransferByte(MMC_STARTBLOCK_WRITE);
	// write data
	for(i=0; i<0x200; i++)
 db6:	21 96       	adiw	r28, 0x01	; 1
 db8:	f2 e0       	ldi	r31, 0x02	; 2
 dba:	c0 30       	cpi	r28, 0x00	; 0
 dbc:	df 07       	cpc	r29, r31
 dbe:	b1 f7       	brne	.-20     	; 0xdac <mmcWrite+0x44>
	{
		spiTransferByte(*buffer++);
	}
	// write 16-bit CRC (dummy values)
	spiTransferByte(0xFF);
 dc0:	8f ef       	ldi	r24, 0xFF	; 255
 dc2:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
	spiTransferByte(0xFF);
 dc6:	8f ef       	ldi	r24, 0xFF	; 255
 dc8:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
	// read data response token
	r1 = spiTransferByte(0xFF);
 dcc:	8f ef       	ldi	r24, 0xFF	; 255
 dce:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
 dd2:	98 2f       	mov	r25, r24
	if( (r1&MMC_DR_MASK) != MMC_DR_ACCEPT)
 dd4:	8f 71       	andi	r24, 0x1F	; 31
 dd6:	85 30       	cpi	r24, 0x05	; 5
 dd8:	39 f4       	brne	.+14     	; 0xde8 <mmcWrite+0x80>
		return r1;
	#ifdef MMC_DEBUG
	rprintf("Data Response Token=0x%x\r\n", r1);
	#endif
	// wait until card not busy
	while(!spiTransferByte(0xFF));
 dda:	8f ef       	ldi	r24, 0xFF	; 255
 ddc:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
 de0:	88 23       	and	r24, r24
 de2:	d9 f3       	breq	.-10     	; 0xdda <mmcWrite+0x72>
	// release chip select
	sbi(MMC_CS_PORT,MMC_CS_PIN);
 de4:	c4 9a       	sbi	0x18, 4	; 24
 de6:	90 e0       	ldi	r25, 0x00	; 0
	// return success
	return 0;
}
 de8:	89 2f       	mov	r24, r25
 dea:	df 91       	pop	r29
 dec:	cf 91       	pop	r28
 dee:	1f 91       	pop	r17
 df0:	0f 91       	pop	r16
 df2:	ff 90       	pop	r15
 df4:	ef 90       	pop	r14
 df6:	08 95       	ret

00000df8 <mmcRead>:

	return r1;
}

u08 mmcRead(u32 sector, u08* buffer)
{
 df8:	ef 92       	push	r14
 dfa:	ff 92       	push	r15
 dfc:	0f 93       	push	r16
 dfe:	1f 93       	push	r17
 e00:	cf 93       	push	r28
 e02:	df 93       	push	r29
 e04:	8b 01       	movw	r16, r22
 e06:	9c 01       	movw	r18, r24
 e08:	7a 01       	movw	r14, r20
	u08 r1;
	u16 i;

	// assert chip select
	cbi(MMC_CS_PORT,MMC_CS_PIN);
 e0a:	c4 98       	cbi	0x18, 4	; 24
	// issue command
	r1 = mmcCommand(MMC_READ_SINGLE_BLOCK, sector<<9);
 e0c:	59 e0       	ldi	r21, 0x09	; 9
 e0e:	00 0f       	add	r16, r16
 e10:	11 1f       	adc	r17, r17
 e12:	22 1f       	adc	r18, r18
 e14:	33 1f       	adc	r19, r19
 e16:	5a 95       	dec	r21
 e18:	d1 f7       	brne	.-12     	; 0xe0e <mmcRead+0x16>
 e1a:	81 e1       	ldi	r24, 0x11	; 17
 e1c:	b9 01       	movw	r22, r18
 e1e:	a8 01       	movw	r20, r16
 e20:	0e 94 80 06 	call	0xd00	; 0xd00 <mmcCommand>
 e24:	08 2f       	mov	r16, r24
	#ifdef MMC_DEBUG
	rprintf("MMC Read Block R1=0x%x\r\n", r1);
	#endif
	// check for valid response
	if(r1 != 0x00)
 e26:	88 23       	and	r24, r24
 e28:	c9 f4       	brne	.+50     	; 0xe5c <mmcRead+0x64>
		return r1;
	// wait for block start
	while(spiTransferByte(0xFF) != MMC_STARTBLOCK_READ);
 e2a:	8f ef       	ldi	r24, 0xFF	; 255
 e2c:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
 e30:	8e 3f       	cpi	r24, 0xFE	; 254
 e32:	d9 f7       	brne	.-10     	; 0xe2a <mmcRead+0x32>
 e34:	c0 e0       	ldi	r28, 0x00	; 0
 e36:	d0 e0       	ldi	r29, 0x00	; 0
	// read in data
	for(i=0; i<0x200; i++)
	{
		*buffer++ = spiTransferByte(0xFF);
 e38:	8f ef       	ldi	r24, 0xFF	; 255
 e3a:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
 e3e:	f7 01       	movw	r30, r14
 e40:	81 93       	st	Z+, r24
 e42:	7f 01       	movw	r14, r30
	if(r1 != 0x00)
		return r1;
	// wait for block start
	while(spiTransferByte(0xFF) != MMC_STARTBLOCK_READ);
	// read in data
	for(i=0; i<0x200; i++)
 e44:	21 96       	adiw	r28, 0x01	; 1
 e46:	f2 e0       	ldi	r31, 0x02	; 2
 e48:	c0 30       	cpi	r28, 0x00	; 0
 e4a:	df 07       	cpc	r29, r31
 e4c:	a9 f7       	brne	.-22     	; 0xe38 <mmcRead+0x40>
	{
		*buffer++ = spiTransferByte(0xFF);
	}
	// read 16-bit CRC
	spiTransferByte(0xFF);
 e4e:	8f ef       	ldi	r24, 0xFF	; 255
 e50:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
	spiTransferByte(0xFF);
 e54:	8f ef       	ldi	r24, 0xFF	; 255
 e56:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
	// release chip select
	sbi(MMC_CS_PORT,MMC_CS_PIN);
 e5a:	c4 9a       	sbi	0x18, 4	; 24
	// return success
	return 0;
}
 e5c:	80 2f       	mov	r24, r16
 e5e:	df 91       	pop	r29
 e60:	cf 91       	pop	r28
 e62:	1f 91       	pop	r17
 e64:	0f 91       	pop	r16
 e66:	ff 90       	pop	r15
 e68:	ef 90       	pop	r14
 e6a:	08 95       	ret

00000e6c <mmcReset>:
	sbi(MMC_CS_DDR, MMC_CS_PIN);
	sbi(MMC_CS_PORT,MMC_CS_PIN);
}

u08 mmcReset(void)
{
 e6c:	1f 93       	push	r17
 e6e:	10 e0       	ldi	r17, 0x00	; 0

	retry = 0;
	do
	{
		// send dummy bytes with CS high before accessing
		spiTransferByte(0xFF);
 e70:	8f ef       	ldi	r24, 0xFF	; 255
 e72:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
		spiTransferByte(0xFF);
 e76:	8f ef       	ldi	r24, 0xFF	; 255
 e78:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
		spiTransferByte(0xFF);
 e7c:	8f ef       	ldi	r24, 0xFF	; 255
 e7e:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
		spiTransferByte(0xFF);
 e82:	8f ef       	ldi	r24, 0xFF	; 255
 e84:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <spiTransferByte>
		// resetting card, go to SPI mode
		r1 = mmcSendCommand(MMC_GO_IDLE_STATE, 0);
 e88:	80 e0       	ldi	r24, 0x00	; 0
 e8a:	40 e0       	ldi	r20, 0x00	; 0
 e8c:	50 e0       	ldi	r21, 0x00	; 0
 e8e:	60 e0       	ldi	r22, 0x00	; 0
 e90:	70 e0       	ldi	r23, 0x00	; 0
 e92:	0e 94 af 06 	call	0xd5e	; 0xd5e <mmcSendCommand>
		#ifdef MMC_DEBUG
		rprintf("MMC_GO_IDLE_STATE: R1=0x%x\r\n", r1);
		#endif
		// do retry counter
		retry++;
 e96:	1f 5f       	subi	r17, 0xFF	; 255
		if(retry>10) return -1;
 e98:	1b 30       	cpi	r17, 0x0B	; 11
 e9a:	f9 f0       	breq	.+62     	; 0xeda <mmcReset+0x6e>
	} while(r1 != 0x01);
 e9c:	81 30       	cpi	r24, 0x01	; 1
 e9e:	41 f7       	brne	.-48     	; 0xe70 <mmcReset+0x4>
 ea0:	10 e0       	ldi	r17, 0x00	; 0

	retry = 0;
	do
	{
		// initializing card for operation
		r1 = mmcSendCommand(MMC_SEND_OP_COND, 0);
 ea2:	81 e0       	ldi	r24, 0x01	; 1
 ea4:	40 e0       	ldi	r20, 0x00	; 0
 ea6:	50 e0       	ldi	r21, 0x00	; 0
 ea8:	60 e0       	ldi	r22, 0x00	; 0
 eaa:	70 e0       	ldi	r23, 0x00	; 0
 eac:	0e 94 af 06 	call	0xd5e	; 0xd5e <mmcSendCommand>
		#ifdef MMC_DEBUG
		rprintf("MMC_SEND_OP_COND: R1=0x%x\r\n", r1);
		#endif
		// do retry counter
		retry++;
 eb0:	1f 5f       	subi	r17, 0xFF	; 255
		if(retry>100) return -1;
 eb2:	15 36       	cpi	r17, 0x65	; 101
 eb4:	91 f0       	breq	.+36     	; 0xeda <mmcReset+0x6e>
	} while(r1);
 eb6:	88 23       	and	r24, r24
 eb8:	a1 f7       	brne	.-24     	; 0xea2 <mmcReset+0x36>
		
	// turn off CRC checking to simplify communication
	r1 = mmcSendCommand(MMC_CRC_ON_OFF, 0);
 eba:	8b e3       	ldi	r24, 0x3B	; 59
 ebc:	40 e0       	ldi	r20, 0x00	; 0
 ebe:	50 e0       	ldi	r21, 0x00	; 0
 ec0:	60 e0       	ldi	r22, 0x00	; 0
 ec2:	70 e0       	ldi	r23, 0x00	; 0
 ec4:	0e 94 af 06 	call	0xd5e	; 0xd5e <mmcSendCommand>
	#ifdef MMC_DEBUG
	rprintf("MMC_CRC_ON_OFF: R1=0x%x\r\n", r1);
	#endif

	// set block length to 512 bytes
	r1 = mmcSendCommand(MMC_SET_BLOCKLEN, 512);
 ec8:	80 e1       	ldi	r24, 0x10	; 16
 eca:	40 e0       	ldi	r20, 0x00	; 0
 ecc:	52 e0       	ldi	r21, 0x02	; 2
 ece:	60 e0       	ldi	r22, 0x00	; 0
 ed0:	70 e0       	ldi	r23, 0x00	; 0
 ed2:	0e 94 af 06 	call	0xd5e	; 0xd5e <mmcSendCommand>
 ed6:	80 e0       	ldi	r24, 0x00	; 0
 ed8:	01 c0       	rjmp	.+2      	; 0xedc <mmcReset+0x70>
	#ifdef MMC_DEBUG
	rprintf("MMC_SET_BLOCKLEN: R1=0x%x\r\n", r1);
	#endif

	// return success
	return 0;
 eda:	8f ef       	ldi	r24, 0xFF	; 255
}
 edc:	1f 91       	pop	r17
 ede:	08 95       	ret

00000ee0 <mmcInit>:
// Functions

void mmcInit(void)
{
	// initialize SPI interface
	spiInit();
 ee0:	0e 94 46 06 	call	0xc8c	; 0xc8c <spiInit>
	// release chip select
	sbi(MMC_CS_DDR, MMC_CS_PIN);
 ee4:	bc 9a       	sbi	0x17, 4	; 23
	sbi(MMC_CS_PORT,MMC_CS_PIN);
 ee6:	c4 9a       	sbi	0x18, 4	; 24
}
 ee8:	08 95       	ret

00000eea <__mulsi3>:
 eea:	62 9f       	mul	r22, r18
 eec:	d0 01       	movw	r26, r0
 eee:	73 9f       	mul	r23, r19
 ef0:	f0 01       	movw	r30, r0
 ef2:	82 9f       	mul	r24, r18
 ef4:	e0 0d       	add	r30, r0
 ef6:	f1 1d       	adc	r31, r1
 ef8:	64 9f       	mul	r22, r20
 efa:	e0 0d       	add	r30, r0
 efc:	f1 1d       	adc	r31, r1
 efe:	92 9f       	mul	r25, r18
 f00:	f0 0d       	add	r31, r0
 f02:	83 9f       	mul	r24, r19
 f04:	f0 0d       	add	r31, r0
 f06:	74 9f       	mul	r23, r20
 f08:	f0 0d       	add	r31, r0
 f0a:	65 9f       	mul	r22, r21
 f0c:	f0 0d       	add	r31, r0
 f0e:	99 27       	eor	r25, r25
 f10:	72 9f       	mul	r23, r18
 f12:	b0 0d       	add	r27, r0
 f14:	e1 1d       	adc	r30, r1
 f16:	f9 1f       	adc	r31, r25
 f18:	63 9f       	mul	r22, r19
 f1a:	b0 0d       	add	r27, r0
 f1c:	e1 1d       	adc	r30, r1
 f1e:	f9 1f       	adc	r31, r25
 f20:	bd 01       	movw	r22, r26
 f22:	cf 01       	movw	r24, r30
 f24:	11 24       	eor	r1, r1
 f26:	08 95       	ret

00000f28 <__udivmodhi4>:
 f28:	aa 1b       	sub	r26, r26
 f2a:	bb 1b       	sub	r27, r27
 f2c:	51 e1       	ldi	r21, 0x11	; 17
 f2e:	07 c0       	rjmp	.+14     	; 0xf3e <__udivmodhi4_ep>

00000f30 <__udivmodhi4_loop>:
 f30:	aa 1f       	adc	r26, r26
 f32:	bb 1f       	adc	r27, r27
 f34:	a6 17       	cp	r26, r22
 f36:	b7 07       	cpc	r27, r23
 f38:	10 f0       	brcs	.+4      	; 0xf3e <__udivmodhi4_ep>
 f3a:	a6 1b       	sub	r26, r22
 f3c:	b7 0b       	sbc	r27, r23

00000f3e <__udivmodhi4_ep>:
 f3e:	88 1f       	adc	r24, r24
 f40:	99 1f       	adc	r25, r25
 f42:	5a 95       	dec	r21
 f44:	a9 f7       	brne	.-22     	; 0xf30 <__udivmodhi4_loop>
 f46:	80 95       	com	r24
 f48:	90 95       	com	r25
 f4a:	bc 01       	movw	r22, r24
 f4c:	cd 01       	movw	r24, r26
 f4e:	08 95       	ret

00000f50 <__udivmodsi4>:
 f50:	a1 e2       	ldi	r26, 0x21	; 33
 f52:	1a 2e       	mov	r1, r26
 f54:	aa 1b       	sub	r26, r26
 f56:	bb 1b       	sub	r27, r27
 f58:	fd 01       	movw	r30, r26
 f5a:	0d c0       	rjmp	.+26     	; 0xf76 <__udivmodsi4_ep>

00000f5c <__udivmodsi4_loop>:
 f5c:	aa 1f       	adc	r26, r26
 f5e:	bb 1f       	adc	r27, r27
 f60:	ee 1f       	adc	r30, r30
 f62:	ff 1f       	adc	r31, r31
 f64:	a2 17       	cp	r26, r18
 f66:	b3 07       	cpc	r27, r19
 f68:	e4 07       	cpc	r30, r20
 f6a:	f5 07       	cpc	r31, r21
 f6c:	20 f0       	brcs	.+8      	; 0xf76 <__udivmodsi4_ep>
 f6e:	a2 1b       	sub	r26, r18
 f70:	b3 0b       	sbc	r27, r19
 f72:	e4 0b       	sbc	r30, r20
 f74:	f5 0b       	sbc	r31, r21

00000f76 <__udivmodsi4_ep>:
 f76:	66 1f       	adc	r22, r22
 f78:	77 1f       	adc	r23, r23
 f7a:	88 1f       	adc	r24, r24
 f7c:	99 1f       	adc	r25, r25
 f7e:	1a 94       	dec	r1
 f80:	69 f7       	brne	.-38     	; 0xf5c <__udivmodsi4_loop>
 f82:	60 95       	com	r22
 f84:	70 95       	com	r23
 f86:	80 95       	com	r24
 f88:	90 95       	com	r25
 f8a:	9b 01       	movw	r18, r22
 f8c:	ac 01       	movw	r20, r24
 f8e:	bd 01       	movw	r22, r26
 f90:	cf 01       	movw	r24, r30
 f92:	08 95       	ret

00000f94 <_exit>:
 f94:	f8 94       	cli

00000f96 <__stop_program>:
 f96:	ff cf       	rjmp	.-2      	; 0xf96 <__stop_program>
