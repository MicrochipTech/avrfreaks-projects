# Hey Emacs, this is a -*- makefile -*-
#----------------------------------------------------------------------------
# On command line:
#
# make all = Make software.
#
# make clean = Clean out built project files.
#
# make coff = Convert ELF to AVR COFF.
#
# make extcoff = Convert ELF to AVR Extended COFF.
#
# make program = Download the hex file to the device, using avrdude.
#                Please customize the avrdude settings below first!
#
# make debug = Start either simulavr or avarice as specified for debugging, 
#              with avr-gdb or avr-insight as the front end for debugging.
#
# make filename.s = Just compile filename.c into the assembler code only.
#
# make filename.i = Create a preprocessed source file for use in submitting
#                   bug reports to the GCC project.
#
# To rebuild project do "make clean" then "make all".
#----------------------------------------------------------------------------


AVRSTUDIO_PATH = "f:\Atmel\AVR Tools\AvrAssembler2"

# MCU name
_MCU = tiny15
MCU = at$(_MCU)


# Processor frequency.
#     This will define a symbol, F_CPU, in all source code files equal to the 
#     processor frequency. You can then use this symbol in your source code to 
#     calculate timings. Do NOT tack on a 'UL' at the end, this will be done
#     automatically to create a 32-bit value in your source code.
F_CPU = 1000000


# Output format. (can be srec, ihex, binary)
FORMAT = ihex


# Target file name (without extension).
TARGET = RTTTLplay


# List C source files here. (C dependencies are automatically generated.)
SRC = main.asm

#---------------- Programming Options (avreal) ----------------

PRG_WRITE_FLASH = -c $(TARGET).hex
PRG_WRITE_EEPROM = -d $(TARGET).eep

PRG_FLAGS = -ab -p1 +$(MCU) -w -v
PRG_FLAGS += $(AVRDUDE_NO_VERIFY)
PRG_FLAGS += $(AVRDUDE_VERBOSE)
PRG_FLAGS += $(AVRDUDE_ERASE_COUNTER)

#============================================================================


# Define programs and commands.
ASM = $(AVRSTUDIO_PATH)/avrasm2
PROGRAMMER = avreal32
SIZE = avr-size
OBJ-DUMP = avr-objdump

# Define Messages
# English
MSG_ERRORS_NONE = Errors: none
MSG_BEGIN = -------- begin --------
MSG_END = --------  end  --------
MSG_SIZE_BEFORE = Size before: 
MSG_SIZE_AFTER = Size after:
MSG_COFF = Converting to AVR COFF:
MSG_EXTENDED_COFF = Converting to AVR Extended COFF:
MSG_FLASH = Creating load file for Flash:
MSG_EEPROM = Creating load file for EEPROM:
MSG_EXTENDED_LISTING = Creating Extended Listing:
MSG_SYMBOL_TABLE = Creating Symbol Table:
MSG_LINKING = Linking:
MSG_COMPILING = Compiling:
MSG_ASSEMBLING = Assembling:
MSG_CLEANING = Cleaning project:


# asm flags

ASM_FLAGS = -S labels.tmp -fI 
ASM_FLAGS += -o "$(TARGET).hex" 
ASM_FLAGS += -d "$(TARGET).obj" 
ASM_FLAGS += -e "$(TARGET).eep"
ASM_FLAGS += -m "$(TARGET).map"
ASM_FLAGS += -W+ie

# Default target.
all: begin assemble end

build: assemble


# Eye candy.
# AVR Studio 3.x does not check make's exit code but relies on
# the following magic strings to be generated by the compile job.
begin:
	@echo
	@echo $(MSG_BEGIN)

end:
	@echo $(MSG_END)
	@echo



# Display compiler version information.
asmversion : 
	@$(ASM) -v

# assemble target
assemble :
	@$(ASM) $(ASM_FLAGS) "$(SRC)"
	@rm labels.tmp


# Program the device.  
program: $(TARGET).hex $(TARGET).eep
	$(PROGRAMMER) $(PRG_FLAGS) $(PRG_WRITE_FLASH) $(PRG_WRITE_EEPROM)


# Target: clean project.
clean: begin clean_list end

clean_list :
	@echo
	@echo $(MSG_CLEANING)
	$(REMOVE) $(TARGET).hex
	$(REMOVE) $(TARGET).eep
	$(REMOVE) $(TARGET).cof
	$(REMOVE) $(TARGET).elf
	$(REMOVE) $(TARGET).map
	$(REMOVE) $(TARGET).sym
	$(REMOVE) $(TARGET).lss
	$(REMOVE) $(OBJ)
	$(REMOVE) $(LST)
	$(REMOVE) $(SRC:.c=.s)
	$(REMOVE) $(SRC:.c=.d)
	$(REMOVE) .dep/*



# Include the dependency files.
-include $(shell mkdir .dep 2>/dev/null) $(wildcard .dep/*)


# Listing of phony targets.
.PHONY : all begin finish end sizebefore sizeafter gccversion \
build elf hex eep lss sym coff extcoff \
clean clean_list program debug gdb-config

