/*
   Copyright 2011 Elijah M. Merkin aka Ellioh

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#ifndef AVRPP_KTEST_PORTS_IMPL_HPP___
#define AVRPP_KTEST_PORTS_IMPL_HPP___


#include <avrpp/locking.hpp>

namespace avrpp {

/**
 * @brief A namespace containing classes encapsulating physical i/o ports & pins
 *
 */
namespace ports {

/**
 * @brief Input port option disabling pull-up
 */
template <typename bulk> struct hi_z {
	/** @brief Configures pullup */
	static void bulk_config (typename bulk::type mask) {
		bulk::bulk_config_hi_z (mask);
	}
};

/**
 * @brief Input port option enabling pull-up
 */
template <typename bulk> struct pullup {
	/** @brief Configures pullup */
	static void bulk_config (typename bulk::type mask) {
		bulk::bulk_config_pullup (mask);
	}
};

/**
 * @brief Placeholder for empty set of options
 */
template <typename bulk> struct no_options {
	/** @brief Configures nothing */
	static void bulk_config (typename bulk::type /*mask*/) {}
};


/** @brief No update for ports */
struct noupdate_port {
	/** @brief Do nothing, no update required for real ports */
	static void update_outputs () {}
	/** @brief Do nothing, no update required for real ports */
	static void update_inputs () {}
};

/**
 * @brief A class supporting bulk operations, i.e. on more than one pin at a time.
 *
 */
template <typename port_class>
struct bulk_port_operations {
	/** @brief Data type for port */
	typedef typename port_class::bulk_data_type type;
	/** @brief Port type */
	typedef port_class port;
	/** @brief Configure masked pins as inputs */
	static void bulk_config_input (type mask) { port::ddr () &= ~mask; }
	/** @brief Enable pullups for masked pins */
	static void bulk_config_pullup (type mask) { port::port () |= mask; }
	/** @brief Disable pullups for masked pins */
	static void bulk_config_hi_z (type mask) {	port::port () &= ~mask; }
	/** @brief Set or clear pullup flags */
	static void bulk_config_pullup_hi_z (type mask,type pullup_flags) {
		port::port () =  (port::port () & ~mask) | pullup_flags;
	}
	/** @brief Configure masked pins as outputs */
	static void bulk_config_output (type mask) { port::ddr () |= mask;	}
	/** @brief Set masked pins to 1 */
	static void bulk_set (type mask) {	port::port () |= mask; }
	/** @brief Set masked pins to 0 */
	static void bulk_clear (type mask) { port::port () &= ~mask; }
	/** @brief Set masked pins to relevant bits from values */
	static void bulk_set_data (type mask, type values) {
		port::port () = (port::port () & ~mask) | values;
	}
	/** @brief Read masked input pins */
	static type bulk_input (type mask) {
		return port::pin () & mask;
	}
	/** @brief Read masked output pins */
	static type bulk_get_outputs (type mask) {
		return port::port () & mask;
	}
};

/** @brief Port A */
#ifdef PORTA
struct port_a : noupdate_port {
	/** @brief Datatype accepted and generated by bulk operations class for port */
	typedef unsigned char bulk_data_type;
	/** @brief Class performing bulk operations */
	typedef bulk_port_operations <port_a> bulk;
	/** @brief Get reference to PORTx */
	static volatile unsigned char & port () {return PORTA;}
	/** @brief Get reference to PINx */
	static volatile unsigned char & pin () {return PINA;}
	/** @brief Get reference to DDRx */
	static volatile unsigned char & ddr () {return DDRA;}
};
#endif

#ifdef PORTB
/** @brief Port B */
struct port_b : noupdate_port {
	/** @brief Datatype accepted and generated by bulk operations class for port */
	typedef unsigned char bulk_data_type;
	/** @brief Class performing bulk operations */
	typedef bulk_port_operations <port_b> bulk;
	/** @brief Get reference to PORTx */
	static volatile unsigned char & port () {return PORTB;}
	/** @brief Get reference to PINx */
	static volatile unsigned char & pin () {return PINB;}
	/** @brief Get reference to DDRx */
	static volatile unsigned char & ddr () {return DDRB;}
};
#endif

#ifdef PORTC
/** @brief Port C */
struct port_c : noupdate_port {
	/** @brief Datatype accepted and generated by bulk operations class for port */
	typedef unsigned char bulk_data_type;
	/** @brief Class performing bulk operations */
	typedef bulk_port_operations <port_c> bulk;
	/** @brief Get reference to PORTx */
	static volatile unsigned char & port () {return PORTC;}
	/** @brief Get reference to PINx */
	static volatile unsigned char & pin () {return PINC;}
	/** @brief Get reference to DDRx */
	static volatile unsigned char & ddr () {return DDRC;}
};
#endif

#ifdef PORTD
/** @brief Port D */
struct port_d : noupdate_port {
	/** @brief Datatype accepted and generated by bulk operations class for port */
	typedef unsigned char bulk_data_type;
	/** @brief Class performing bulk operations */
	typedef bulk_port_operations <port_d> bulk;
	/** @brief Get reference to PORTx */
	static volatile unsigned char & port () {return PORTD;}
	/** @brief Get reference to PINx */
	static volatile unsigned char & pin () {return PIND;}
	/** @brief Get reference to DDRx */
	static volatile unsigned char & ddr () {return DDRD;}
};
#endif

#ifdef PORTE
/** @brief Port E */
struct port_e : noupdate_port {
	/** @brief Datatype accepted and generated by bulk operations class for port */
	typedef unsigned char bulk_data_type;
	/** @brief Class performing bulk operations */
	typedef bulk_port_operations <port_e> bulk;
	/** @brief Get reference to PORTx */
	static volatile unsigned char & port () {return PORTE;}
	/** @brief Get reference to PINx */
	static volatile unsigned char & pin () {return PINE;}
	/** @brief Get reference to DDRx */
	static volatile unsigned char & ddr () {return DDRE;}
};
#endif

#ifdef PORTF
/** @brief Port F */
struct port_f : noupdate_port {
	/** @brief Datatype accepted and generated by bulk operations class for port */
	typedef unsigned char bulk_data_type;
	/** @brief Class performing bulk operations */
	typedef bulk_port_operations <port_f> bulk;
	/** @brief Get reference to PORTx */
	static volatile unsigned char & port () {return PORTF;}
	/** @brief Get reference to PINx */
	static volatile unsigned char & pin () {return PINF;}
	/** @brief Get reference to DDRx */
	static volatile unsigned char & ddr () {return DDRF;}
};
#endif




/** @brief A class used to work with input pins */
template <typename port_class, int pin, template <typename cls> class opts=pullup,
		typename locking_policy=avrpp::locking::no_locking>
struct input {
	/** @brief Pin number */
	enum {/** @brief pin number */
		port_pin=pin
	};
	/** @brief Relevant port class */
	typedef port_class port;
	/** @brief Bulk operations class */
	typedef typename port::bulk bulk;
	/** @brief Options (pullup/hi_z) */
	typedef opts<bulk> options;
	enum {/** @brief Bit mask for bulk operations */
		bulk_mask=(1<<port_pin)
	};
	/** @brief Configure pull-up resistor state */
	static void config_options () {
		locking_policy::lock ();
		options::bulk_config (bulk_mask);
		locking_policy::unlock ();
	}
	/** @brief Configure everything (data direction & pull-up state) */
	static void config () {
		locking_policy::lock ();
		port::bulk::bulk_config_input (static_cast<unsigned char> (bulk_mask));
		options::bulk_config (bulk_mask);
		locking_policy::unlock ();
	}
	/** @brief Get input level (true means high level) */
	static bool get() {
		return static_cast<bool>(bulk::bulk_input(static_cast<unsigned char> (bulk_mask)));
	}
	/** @brief Update does nothing */
	static void update() {}
};

/** @brief A class used to work with output pins */
template <typename port_class, int pin, typename locking_policy=::avrpp::locking::no_locking>
struct output {
	/** @brief Relevant port class */
	typedef port_class port;
	/** @brief Pin number */
	enum {/** @brief Pin number */port_pin=pin};
	/** @brief Bulk operations class */
	typedef typename port::bulk bulk;
	/** @brief Relevant port class */
	typedef no_options<bulk> options;
	enum {/** @brief Bit mask for bulk operations */
		bulk_mask=(static_cast<typename bulk::type>(1)<<port_pin)
	};
	/** @brief Configure pull-up resistor state */
	static void config_options () {
		locking_policy::lock ();
		options::bulk_config (bulk_mask);
		locking_policy::unlock ();
	}
	/** @brief Configure data direction */
	static void config () {
		locking_policy::lock ();
		port::bulk::bulk_config_output (static_cast<unsigned char> (bulk_mask));
		options::bulk_config(bulk_mask);
		locking_policy::unlock ();
	}
	/** @brief Get pin value */
	static bool get() {
		return static_cast<bool>(bulk::bulk_get_outputs(static_cast<unsigned char> (bulk_mask)));
	}

	/** @brief Set pin value */
	static void set(bool high) {
		locking_policy::lock ();
		if (high)
			bulk::bulk_set (static_cast<unsigned char> (bulk_mask));
		else
			bulk::bulk_clear (static_cast<unsigned char> (bulk_mask));
		locking_policy::unlock ();
	}
	/** @brief Update, does nothing :-) */
	static void update () {}
};


}

}



#endif //AVRPP_KTEST_PORTS_IMPL_HPP___
