
UART_code.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000058a  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          0000008a  00800100  00800100  000005fe  2**0
                  ALLOC
  2 .debug_aranges 00000040  00000000  00000000  000005fe  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 00000102  00000000  00000000  0000063e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000068c  00000000  00000000  00000740  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 000001ec  00000000  00000000  00000dcc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   000004ec  00000000  00000000  00000fb8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000110  00000000  00000000  000014a4  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000261  00000000  00000000  000015b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000300  00000000  00000000  00001815  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 83 00 	jmp	0x106	; 0x106 <__ctors_end>
   4:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
   8:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
   c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  10:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  14:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  18:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  1c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  20:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  24:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  28:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  2c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  30:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  34:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  38:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  3c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  40:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  44:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  48:	0c 94 00 01 	jmp	0x200	; 0x200 <__vector_18>
  4c:	0c 94 2e 01 	jmp	0x25c	; 0x25c <__vector_19>
  50:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  54:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  58:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  5c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  60:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  64:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  68:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  6c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  70:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  74:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  78:	0c 94 b8 01 	jmp	0x370	; 0x370 <__vector_30>
  7c:	0c 94 e8 01 	jmp	0x3d0	; 0x3d0 <__vector_31>
  80:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  84:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  88:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>

0000008c <__c.1473>:
  8c:	42 75 66 66 65 72 20 6f 76 65 72 66 6c 6f 77 20     Buffer overflow 
  9c:	65 72 72 6f 72 3a 20 00                             error: .

000000a4 <__c.1471>:
  a4:	55 41 52 54 20 4f 76 65 72 72 75 6e 20 45 72 72     UART Overrun Err
  b4:	6f 72 3a 20 00                                      or: .

000000b9 <__c.1469>:
  b9:	55 41 52 54 20 46 72 61 6d 65 20 45 72 72 6f 72     UART Frame Error
  c9:	3a 20 00                                            : .

000000cc <__c.1467>:
  cc:	0a 0a 52 65 63 65 69 76 69 6e 67 20 00              ..Receiving .

000000d9 <__c.1465>:
  d9:	0a 0a 54 72 61 6e 73 6d 69 74 74 69 6e 67 3a 20     ..Transmitting: 
	...

000000ea <__c.1463>:
  ea:	0d 0a 0a 57 72 69 74 69 6e 67 20 6e 75 6d 62 65     ...Writing numbe
  fa:	72 20 74 6f 20 55 41 52 54 3a 20 00                 r to UART: .

00000106 <__ctors_end>:
 106:	11 24       	eor	r1, r1
 108:	1f be       	out	0x3f, r1	; 63
 10a:	cf ef       	ldi	r28, 0xFF	; 255
 10c:	d0 e1       	ldi	r29, 0x10	; 16
 10e:	de bf       	out	0x3e, r29	; 62
 110:	cd bf       	out	0x3d, r28	; 61

00000112 <__do_copy_data>:
 112:	11 e0       	ldi	r17, 0x01	; 1
 114:	a0 e0       	ldi	r26, 0x00	; 0
 116:	b1 e0       	ldi	r27, 0x01	; 1
 118:	ea e8       	ldi	r30, 0x8A	; 138
 11a:	f5 e0       	ldi	r31, 0x05	; 5
 11c:	00 e0       	ldi	r16, 0x00	; 0
 11e:	0b bf       	out	0x3b, r16	; 59
 120:	02 c0       	rjmp	.+4      	; 0x126 <__do_copy_data+0x14>
 122:	07 90       	elpm	r0, Z+
 124:	0d 92       	st	X+, r0
 126:	a0 30       	cpi	r26, 0x00	; 0
 128:	b1 07       	cpc	r27, r17
 12a:	d9 f7       	brne	.-10     	; 0x122 <__do_copy_data+0x10>

0000012c <__do_clear_bss>:
 12c:	11 e0       	ldi	r17, 0x01	; 1
 12e:	a0 e0       	ldi	r26, 0x00	; 0
 130:	b1 e0       	ldi	r27, 0x01	; 1
 132:	01 c0       	rjmp	.+2      	; 0x136 <.do_clear_bss_start>

00000134 <.do_clear_bss_loop>:
 134:	1d 92       	st	X+, r1

00000136 <.do_clear_bss_start>:
 136:	aa 38       	cpi	r26, 0x8A	; 138
 138:	b1 07       	cpc	r27, r17
 13a:	e1 f7       	brne	.-8      	; 0x134 <.do_clear_bss_loop>
 13c:	0e 94 a4 00 	call	0x148	; 0x148 <main>
 140:	0c 94 c3 02 	jmp	0x586	; 0x586 <_exit>

00000144 <__bad_interrupt>:
 144:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000148 <main>:
/* 4800 baud */
#define UART_BAUD_RATE      4800    //Change baud rate here


int main(void)
{
 148:	0f 93       	push	r16
 14a:	1f 93       	push	r17
 14c:	df 93       	push	r29
 14e:	cf 93       	push	r28
 150:	cd b7       	in	r28, 0x3d	; 61
 152:	de b7       	in	r29, 0x3e	; 62
 154:	27 97       	sbiw	r28, 0x07	; 7
 156:	0f b6       	in	r0, 0x3f	; 63
 158:	f8 94       	cli
 15a:	de bf       	out	0x3e, r29	; 62
 15c:	0f be       	out	0x3f, r0	; 63
 15e:	cd bf       	out	0x3d, r28	; 61
    unsigned int c;
    char buffer[7];
    int  num=134;
    
	DDRB=0X01;						
 160:	81 e0       	ldi	r24, 0x01	; 1
 162:	87 bb       	out	0x17, r24	; 23
	DDRE=0X00;
 164:	12 b8       	out	0x02, r1	; 2
	DDRD=0XF0;						
 166:	80 ef       	ldi	r24, 0xF0	; 240
 168:	81 bb       	out	0x11, r24	; 17
	
	sbi(PORTB,0);					//LED1 ON
 16a:	c0 9a       	sbi	0x18, 0	; 24
     *  with the macro 
     *  UART_BAUD_SELECT() (normal speed mode )
     *  or 
     *  UART_BAUD_SELECT_DOUBLE_SPEED() ( double speed mode)
     */
    uart_init( UART_BAUD_SELECT(UART_BAUD_RATE,F_CPU) );
 16c:	8c e0       	ldi	r24, 0x0C	; 12
 16e:	90 e0       	ldi	r25, 0x00	; 0
 170:	0e 94 57 01 	call	0x2ae	; 0x2ae <uart_init>
	uart1_init( UART_BAUD_SELECT(UART_BAUD_RATE,F_CPU) ); 
 174:	8c e0       	ldi	r24, 0x0C	; 12
 176:	90 e0       	ldi	r25, 0x00	; 0
 178:	0e 94 16 02 	call	0x42c	; 0x42c <uart1_init>
    
    /*
     * now enable interrupt, since UART library is interrupt controlled
     */
    sei();
 17c:	78 94       	sei
     */
 
    /*
     * Transmit string from program memory to UART
     */
    uart_puts_P("\r\n\nWriting number to UART: ");
 17e:	8a ee       	ldi	r24, 0xEA	; 234
 180:	90 e0       	ldi	r25, 0x00	; 0
 182:	0e 94 aa 01 	call	0x354	; 0x354 <uart_puts_p>
      
    /* 
     * Use standard avr-libc functions to convert numbers into string
     * before transmitting via UART
     */     
    itoa( num, buffer, 10);   // convert interger into string (decimal format)    
 186:	86 e8       	ldi	r24, 0x86	; 134
 188:	90 e0       	ldi	r25, 0x00	; 0
 18a:	8e 01       	movw	r16, r28
 18c:	0f 5f       	subi	r16, 0xFF	; 255
 18e:	1f 4f       	sbci	r17, 0xFF	; 255
 190:	b8 01       	movw	r22, r16
 192:	4a e0       	ldi	r20, 0x0A	; 10
 194:	50 e0       	ldi	r21, 0x00	; 0
 196:	0e 94 7e 02 	call	0x4fc	; 0x4fc <itoa>
	uart_puts(buffer);        // and transmit string to UART     
 19a:	c8 01       	movw	r24, r16
 19c:	0e 94 9d 01 	call	0x33a	; 0x33a <uart_puts>
	uart1_puts(buffer);        // and transmit string to UART   
 1a0:	c8 01       	movw	r24, r16
 1a2:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uart1_puts>
    /*
     * Transmit single character to UART
     */
    uart_putc('\r');
 1a6:	8d e0       	ldi	r24, 0x0D	; 13
 1a8:	0e 94 8b 01 	call	0x316	; 0x316 <uart_putc>
	
	uart_puts_P("\n\nTransmitting: ");
 1ac:	89 ed       	ldi	r24, 0xD9	; 217
 1ae:	90 e0       	ldi	r25, 0x00	; 0
 1b0:	0e 94 aa 01 	call	0x354	; 0x354 <uart_puts_p>
	uart_putc('\r');
 1b4:	8d e0       	ldi	r24, 0x0D	; 13
 1b6:	0e 94 8b 01 	call	0x316	; 0x316 <uart_putc>
	uart1_puts_P("\n\nReceiving ");
 1ba:	8c ec       	ldi	r24, 0xCC	; 204
 1bc:	90 e0       	ldi	r25, 0x00	; 0
 1be:	0e 94 70 02 	call	0x4e0	; 0x4e0 <uart1_puts_p>
	uart1_putc('\r');
 1c2:	8d e0       	ldi	r24, 0x0D	; 13
 1c4:	0e 94 4d 02 	call	0x49a	; 0x49a <uart1_putc>
         * uart_getc() returns in the lower byte the received character and 
         * in the higher byte (bitmask) the last receive error
         * UART_NO_DATA is returned when no data is available.
         *
         */
        c = uart_getc();
 1c8:	0e 94 6e 01 	call	0x2dc	; 0x2dc <uart_getc>
 1cc:	8c 01       	movw	r16, r24
        if ( c & UART_NO_DATA )
 1ce:	90 fd       	sbrc	r25, 0
 1d0:	fb cf       	rjmp	.-10     	; 0x1c8 <main+0x80>
        {
            /*
             * new data available from UART
             * check for Frame or Overrun error
             */
            if ( c & UART_FRAME_ERROR )
 1d2:	93 ff       	sbrs	r25, 3
 1d4:	04 c0       	rjmp	.+8      	; 0x1de <main+0x96>
            {
                /* Framing Error detected, i.e no stop bit detected */
                uart_puts_P("UART Frame Error: ");
 1d6:	89 eb       	ldi	r24, 0xB9	; 185
 1d8:	90 e0       	ldi	r25, 0x00	; 0
 1da:	0e 94 aa 01 	call	0x354	; 0x354 <uart_puts_p>
            }
            if ( c & UART_OVERRUN_ERROR )
 1de:	12 ff       	sbrs	r17, 2
 1e0:	04 c0       	rjmp	.+8      	; 0x1ea <main+0xa2>
                /* 
                 * Overrun, a character already present in the UART UDR register was 
                 * not read by the interrupt handler before the next character arrived,
                 * one or more received characters have been dropped
                 */
                uart_puts_P("UART Overrun Error: ");
 1e2:	84 ea       	ldi	r24, 0xA4	; 164
 1e4:	90 e0       	ldi	r25, 0x00	; 0
 1e6:	0e 94 aa 01 	call	0x354	; 0x354 <uart_puts_p>
            }
            if ( c & UART_BUFFER_OVERFLOW )
 1ea:	11 ff       	sbrs	r17, 1
 1ec:	04 c0       	rjmp	.+8      	; 0x1f6 <main+0xae>
            {
                /* 
                 * We are not reading the receive buffer fast enough,
                 * one or more received character have been dropped 
                 */
                uart_puts_P("Buffer overflow error: ");
 1ee:	8c e8       	ldi	r24, 0x8C	; 140
 1f0:	90 e0       	ldi	r25, 0x00	; 0
 1f2:	0e 94 aa 01 	call	0x354	; 0x354 <uart_puts_p>
            }
            /* 
             * send received character back
             */
            uart_putc( (unsigned char)c );
 1f6:	80 2f       	mov	r24, r16
 1f8:	0e 94 8b 01 	call	0x316	; 0x316 <uart_putc>
			
			uart1_putc( (unsigned char)c );
 1fc:	80 2f       	mov	r24, r16
 1fe:	e2 cf       	rjmp	.-60     	; 0x1c4 <main+0x7c>

00000200 <__vector_18>:
SIGNAL(UART0_RECEIVE_INTERRUPT)
/*************************************************************************
Function: UART Receive Complete interrupt
Purpose:  called when the UART has received a character
**************************************************************************/
{
 200:	1f 92       	push	r1
 202:	0f 92       	push	r0
 204:	0f b6       	in	r0, 0x3f	; 63
 206:	0f 92       	push	r0
 208:	0b b6       	in	r0, 0x3b	; 59
 20a:	0f 92       	push	r0
 20c:	11 24       	eor	r1, r1
 20e:	2f 93       	push	r18
 210:	8f 93       	push	r24
 212:	9f 93       	push	r25
 214:	ef 93       	push	r30
 216:	ff 93       	push	r31
    unsigned char usr;
    unsigned char lastRxError;
 
 
    /* read UART status register and UART data register */ 
    usr  = UART0_STATUS;
 218:	9b b1       	in	r25, 0x0b	; 11
    data = UART0_DATA;
 21a:	2c b1       	in	r18, 0x0c	; 12
#elif defined ( ATMEGA_UART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#endif
        
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
 21c:	e0 91 42 01 	lds	r30, 0x0142
 220:	ef 5f       	subi	r30, 0xFF	; 255
 222:	ef 71       	andi	r30, 0x1F	; 31
    
    if ( tmphead == UART_RxTail ) {
 224:	80 91 43 01 	lds	r24, 0x0143
 228:	e8 17       	cp	r30, r24
 22a:	11 f4       	brne	.+4      	; 0x230 <__vector_18+0x30>
 22c:	82 e0       	ldi	r24, 0x02	; 2
 22e:	08 c0       	rjmp	.+16     	; 0x240 <__vector_18+0x40>
#if defined( AT90_UART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#elif defined( ATMEGA_USART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#elif defined( ATMEGA_USART0 )
    lastRxError = (usr & (_BV(FE0)|_BV(DOR0)) );
 230:	89 2f       	mov	r24, r25
 232:	88 71       	andi	r24, 0x18	; 24
    if ( tmphead == UART_RxTail ) {
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    }else{
        /* store new index */
        UART_RxHead = tmphead;
 234:	e0 93 42 01 	sts	0x0142, r30
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
 238:	f0 e0       	ldi	r31, 0x00	; 0
 23a:	e0 5e       	subi	r30, 0xE0	; 224
 23c:	fe 4f       	sbci	r31, 0xFE	; 254
 23e:	20 83       	st	Z, r18
    }
    UART_LastRxError = lastRxError;   
 240:	80 93 44 01 	sts	0x0144, r24
}
 244:	ff 91       	pop	r31
 246:	ef 91       	pop	r30
 248:	9f 91       	pop	r25
 24a:	8f 91       	pop	r24
 24c:	2f 91       	pop	r18
 24e:	0f 90       	pop	r0
 250:	0b be       	out	0x3b, r0	; 59
 252:	0f 90       	pop	r0
 254:	0f be       	out	0x3f, r0	; 63
 256:	0f 90       	pop	r0
 258:	1f 90       	pop	r1
 25a:	18 95       	reti

0000025c <__vector_19>:
SIGNAL(UART0_TRANSMIT_INTERRUPT)
/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/
{
 25c:	1f 92       	push	r1
 25e:	0f 92       	push	r0
 260:	0f b6       	in	r0, 0x3f	; 63
 262:	0f 92       	push	r0
 264:	0b b6       	in	r0, 0x3b	; 59
 266:	0f 92       	push	r0
 268:	11 24       	eor	r1, r1
 26a:	8f 93       	push	r24
 26c:	9f 93       	push	r25
 26e:	ef 93       	push	r30
 270:	ff 93       	push	r31
    unsigned char tmptail;

    
    if ( UART_TxHead != UART_TxTail) {
 272:	90 91 40 01 	lds	r25, 0x0140
 276:	80 91 41 01 	lds	r24, 0x0141
 27a:	98 17       	cp	r25, r24
 27c:	61 f0       	breq	.+24     	; 0x296 <__vector_19+0x3a>
        /* calculate and store new buffer index */
        tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
 27e:	e0 91 41 01 	lds	r30, 0x0141
 282:	ef 5f       	subi	r30, 0xFF	; 255
 284:	ef 71       	andi	r30, 0x1F	; 31
        UART_TxTail = tmptail;
 286:	e0 93 41 01 	sts	0x0141, r30
        /* get one byte from buffer and write it to UART */
        UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
 28a:	f0 e0       	ldi	r31, 0x00	; 0
 28c:	e0 50       	subi	r30, 0x00	; 0
 28e:	ff 4f       	sbci	r31, 0xFF	; 255
 290:	80 81       	ld	r24, Z
 292:	8c b9       	out	0x0c, r24	; 12
 294:	01 c0       	rjmp	.+2      	; 0x298 <__vector_19+0x3c>
    }else{
        /* tx buffer empty, disable UDRE interrupt */
        UART0_CONTROL &= ~_BV(UART0_UDRIE);
 296:	55 98       	cbi	0x0a, 5	; 10
    }
}
 298:	ff 91       	pop	r31
 29a:	ef 91       	pop	r30
 29c:	9f 91       	pop	r25
 29e:	8f 91       	pop	r24
 2a0:	0f 90       	pop	r0
 2a2:	0b be       	out	0x3b, r0	; 59
 2a4:	0f 90       	pop	r0
 2a6:	0f be       	out	0x3f, r0	; 63
 2a8:	0f 90       	pop	r0
 2aa:	1f 90       	pop	r1
 2ac:	18 95       	reti

000002ae <uart_init>:
Purpose:  initialize UART and set baudrate
Input:    baudrate using macro UART_BAUD_SELECT()
Returns:  none
**************************************************************************/
void uart_init(unsigned int baudrate)
{
 2ae:	9c 01       	movw	r18, r24
    UART_TxHead = 0;
 2b0:	10 92 40 01 	sts	0x0140, r1
    UART_TxTail = 0;
 2b4:	10 92 41 01 	sts	0x0141, r1
    UART_RxHead = 0;
 2b8:	10 92 42 01 	sts	0x0142, r1
    UART_RxTail = 0;
 2bc:	10 92 43 01 	sts	0x0143, r1
    UCSRC = (3<<UCSZ0);
    #endif 
    
#elif defined (ATMEGA_USART0 )
    /* Set baud rate */
    if ( baudrate & 0x8000 ) 
 2c0:	97 ff       	sbrs	r25, 7
 2c2:	03 c0       	rjmp	.+6      	; 0x2ca <uart_init+0x1c>
    {
   		UART0_STATUS = (1<<U2X0);  //Enable 2x speed 
 2c4:	82 e0       	ldi	r24, 0x02	; 2
 2c6:	8b b9       	out	0x0b, r24	; 11
   		baudrate &= ~0x8000;
 2c8:	3f 77       	andi	r19, 0x7F	; 127
   	}
    UBRR0H = (unsigned char)(baudrate>>8);
 2ca:	30 93 90 00 	sts	0x0090, r19
    UBRR0L = (unsigned char) baudrate;
 2ce:	29 b9       	out	0x09, r18	; 9

    /* Enable USART receiver and transmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE0)|(1<<RXEN0)|(1<<TXEN0);
 2d0:	88 e9       	ldi	r24, 0x98	; 152
 2d2:	8a b9       	out	0x0a, r24	; 10
    
    /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
    #ifdef URSEL0
    UCSR0C = (1<<URSEL0)|(3<<UCSZ00);
    #else
    UCSR0C = (3<<UCSZ00);
 2d4:	86 e0       	ldi	r24, 0x06	; 6
 2d6:	80 93 95 00 	sts	0x0095, r24
    /* Enable UART receiver and transmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);

#endif

}/* uart_init */
 2da:	08 95       	ret

000002dc <uart_getc>:
{    
    unsigned char tmptail;
    unsigned char data;


    if ( UART_RxHead == UART_RxTail ) {
 2dc:	90 91 42 01 	lds	r25, 0x0142
 2e0:	80 91 43 01 	lds	r24, 0x0143
 2e4:	98 17       	cp	r25, r24
 2e6:	19 f4       	brne	.+6      	; 0x2ee <uart_getc+0x12>
 2e8:	20 e0       	ldi	r18, 0x00	; 0
 2ea:	31 e0       	ldi	r19, 0x01	; 1
 2ec:	12 c0       	rjmp	.+36     	; 0x312 <uart_getc+0x36>
        return UART_NO_DATA;   /* no data available */
    }
    
    /* calculate /store buffer index */
    tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
 2ee:	e0 91 43 01 	lds	r30, 0x0143
 2f2:	ef 5f       	subi	r30, 0xFF	; 255
 2f4:	ef 71       	andi	r30, 0x1F	; 31
    UART_RxTail = tmptail; 
 2f6:	e0 93 43 01 	sts	0x0143, r30
    
    /* get data from receive buffer */
    data = UART_RxBuf[tmptail];
 2fa:	f0 e0       	ldi	r31, 0x00	; 0
 2fc:	e0 5e       	subi	r30, 0xE0	; 224
 2fe:	fe 4f       	sbci	r31, 0xFE	; 254
 300:	30 81       	ld	r19, Z
    
    return (UART_LastRxError << 8) + data;
 302:	20 91 44 01 	lds	r18, 0x0144
 306:	92 2f       	mov	r25, r18
 308:	80 e0       	ldi	r24, 0x00	; 0
 30a:	ac 01       	movw	r20, r24
 30c:	43 0f       	add	r20, r19
 30e:	51 1d       	adc	r21, r1
 310:	9a 01       	movw	r18, r20

}/* uart_getc */
 312:	c9 01       	movw	r24, r18
 314:	08 95       	ret

00000316 <uart_putc>:
Purpose:  write byte to ringbuffer for transmitting via UART
Input:    byte to be transmitted
Returns:  none          
**************************************************************************/
void uart_putc(unsigned char data)
{
 316:	28 2f       	mov	r18, r24
    unsigned char tmphead;

    
    tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 318:	90 91 40 01 	lds	r25, 0x0140
 31c:	9f 5f       	subi	r25, 0xFF	; 255
 31e:	9f 71       	andi	r25, 0x1F	; 31
    
    while ( tmphead == UART_TxTail ){
 320:	80 91 41 01 	lds	r24, 0x0141
 324:	98 17       	cp	r25, r24
 326:	e1 f3       	breq	.-8      	; 0x320 <uart_putc+0xa>
        ;/* wait for free space in buffer */
    }
    
    UART_TxBuf[tmphead] = data;
 328:	e9 2f       	mov	r30, r25
 32a:	f0 e0       	ldi	r31, 0x00	; 0
 32c:	e0 50       	subi	r30, 0x00	; 0
 32e:	ff 4f       	sbci	r31, 0xFF	; 255
 330:	20 83       	st	Z, r18
    UART_TxHead = tmphead;
 332:	90 93 40 01 	sts	0x0140, r25

    /* enable UDRE interrupt */
    UART0_CONTROL    |= _BV(UART0_UDRIE);
 336:	55 9a       	sbi	0x0a, 5	; 10

}/* uart_putc */
 338:	08 95       	ret

0000033a <uart_puts>:
Purpose:  transmit string to UART
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart_puts(const char *s )
{
 33a:	cf 93       	push	r28
 33c:	df 93       	push	r29
 33e:	ec 01       	movw	r28, r24
 340:	03 c0       	rjmp	.+6      	; 0x348 <uart_puts+0xe>
    while (*s) 
      uart_putc(*s++);
 342:	21 96       	adiw	r28, 0x01	; 1
 344:	0e 94 8b 01 	call	0x316	; 0x316 <uart_putc>
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart_puts(const char *s )
{
    while (*s) 
 348:	88 81       	ld	r24, Y
 34a:	88 23       	and	r24, r24
 34c:	d1 f7       	brne	.-12     	; 0x342 <uart_puts+0x8>
      uart_putc(*s++);

}/* uart_puts */
 34e:	df 91       	pop	r29
 350:	cf 91       	pop	r28
 352:	08 95       	ret

00000354 <uart_puts_p>:
Purpose:  transmit string from program memory to UART
Input:    program memory string to be transmitted
Returns:  none
**************************************************************************/
void uart_puts_p(const char *progmem_s )
{
 354:	cf 93       	push	r28
 356:	df 93       	push	r29
 358:	ec 01       	movw	r28, r24
 35a:	02 c0       	rjmp	.+4      	; 0x360 <uart_puts_p+0xc>
    register char c;
    
    while ( (c = pgm_read_byte(progmem_s++)) ) 
      uart_putc(c);
 35c:	0e 94 8b 01 	call	0x316	; 0x316 <uart_putc>
 360:	fe 01       	movw	r30, r28
**************************************************************************/
void uart_puts_p(const char *progmem_s )
{
    register char c;
    
    while ( (c = pgm_read_byte(progmem_s++)) ) 
 362:	21 96       	adiw	r28, 0x01	; 1
 364:	84 91       	lpm	r24, Z+
 366:	88 23       	and	r24, r24
 368:	c9 f7       	brne	.-14     	; 0x35c <uart_puts_p+0x8>
      uart_putc(c);

}/* uart_puts_p */
 36a:	df 91       	pop	r29
 36c:	cf 91       	pop	r28
 36e:	08 95       	ret

00000370 <__vector_30>:
SIGNAL(UART1_RECEIVE_INTERRUPT)
/*************************************************************************
Function: UART1 Receive Complete interrupt
Purpose:  called when the UART1 has received a character
**************************************************************************/
{
 370:	1f 92       	push	r1
 372:	0f 92       	push	r0
 374:	0f b6       	in	r0, 0x3f	; 63
 376:	0f 92       	push	r0
 378:	0b b6       	in	r0, 0x3b	; 59
 37a:	0f 92       	push	r0
 37c:	11 24       	eor	r1, r1
 37e:	2f 93       	push	r18
 380:	8f 93       	push	r24
 382:	9f 93       	push	r25
 384:	ef 93       	push	r30
 386:	ff 93       	push	r31
    unsigned char usr;
    unsigned char lastRxError;
 
 
    /* read UART status register and UART data register */ 
    usr  = UART1_STATUS;
 388:	90 91 9b 00 	lds	r25, 0x009B
    data = UART1_DATA;
 38c:	20 91 9c 00 	lds	r18, 0x009C
    
    /* */
    lastRxError = (usr & (_BV(FE1)|_BV(DOR1)) );
        
    /* calculate buffer index */ 
    tmphead = ( UART1_RxHead + 1) & UART_RX_BUFFER_MASK;
 390:	e0 91 87 01 	lds	r30, 0x0187
 394:	ef 5f       	subi	r30, 0xFF	; 255
 396:	ef 71       	andi	r30, 0x1F	; 31
    
    if ( tmphead == UART1_RxTail ) {
 398:	80 91 88 01 	lds	r24, 0x0188
 39c:	e8 17       	cp	r30, r24
 39e:	11 f4       	brne	.+4      	; 0x3a4 <__vector_30+0x34>
 3a0:	82 e0       	ldi	r24, 0x02	; 2
 3a2:	08 c0       	rjmp	.+16     	; 0x3b4 <__vector_30+0x44>
    /* read UART status register and UART data register */ 
    usr  = UART1_STATUS;
    data = UART1_DATA;
    
    /* */
    lastRxError = (usr & (_BV(FE1)|_BV(DOR1)) );
 3a4:	89 2f       	mov	r24, r25
 3a6:	88 71       	andi	r24, 0x18	; 24
    if ( tmphead == UART1_RxTail ) {
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    }else{
        /* store new index */
        UART1_RxHead = tmphead;
 3a8:	e0 93 87 01 	sts	0x0187, r30
        /* store received data in buffer */
        UART1_RxBuf[tmphead] = data;
 3ac:	f0 e0       	ldi	r31, 0x00	; 0
 3ae:	eb 59       	subi	r30, 0x9B	; 155
 3b0:	fe 4f       	sbci	r31, 0xFE	; 254
 3b2:	20 83       	st	Z, r18
    }
    UART1_LastRxError = lastRxError;   
 3b4:	80 93 89 01 	sts	0x0189, r24
}
 3b8:	ff 91       	pop	r31
 3ba:	ef 91       	pop	r30
 3bc:	9f 91       	pop	r25
 3be:	8f 91       	pop	r24
 3c0:	2f 91       	pop	r18
 3c2:	0f 90       	pop	r0
 3c4:	0b be       	out	0x3b, r0	; 59
 3c6:	0f 90       	pop	r0
 3c8:	0f be       	out	0x3f, r0	; 63
 3ca:	0f 90       	pop	r0
 3cc:	1f 90       	pop	r1
 3ce:	18 95       	reti

000003d0 <__vector_31>:
SIGNAL(UART1_TRANSMIT_INTERRUPT)
/*************************************************************************
Function: UART1 Data Register Empty interrupt
Purpose:  called when the UART1 is ready to transmit the next byte
**************************************************************************/
{
 3d0:	1f 92       	push	r1
 3d2:	0f 92       	push	r0
 3d4:	0f b6       	in	r0, 0x3f	; 63
 3d6:	0f 92       	push	r0
 3d8:	0b b6       	in	r0, 0x3b	; 59
 3da:	0f 92       	push	r0
 3dc:	11 24       	eor	r1, r1
 3de:	8f 93       	push	r24
 3e0:	9f 93       	push	r25
 3e2:	ef 93       	push	r30
 3e4:	ff 93       	push	r31
    unsigned char tmptail;

    
    if ( UART1_TxHead != UART1_TxTail) {
 3e6:	90 91 85 01 	lds	r25, 0x0185
 3ea:	80 91 86 01 	lds	r24, 0x0186
 3ee:	98 17       	cp	r25, r24
 3f0:	69 f0       	breq	.+26     	; 0x40c <__vector_31+0x3c>
        /* calculate and store new buffer index */
        tmptail = (UART1_TxTail + 1) & UART_TX_BUFFER_MASK;
 3f2:	e0 91 86 01 	lds	r30, 0x0186
 3f6:	ef 5f       	subi	r30, 0xFF	; 255
 3f8:	ef 71       	andi	r30, 0x1F	; 31
        UART1_TxTail = tmptail;
 3fa:	e0 93 86 01 	sts	0x0186, r30
        /* get one byte from buffer and write it to UART */
        UART1_DATA = UART1_TxBuf[tmptail];  /* start transmission */
 3fe:	f0 e0       	ldi	r31, 0x00	; 0
 400:	eb 5b       	subi	r30, 0xBB	; 187
 402:	fe 4f       	sbci	r31, 0xFE	; 254
 404:	80 81       	ld	r24, Z
 406:	80 93 9c 00 	sts	0x009C, r24
 40a:	05 c0       	rjmp	.+10     	; 0x416 <__vector_31+0x46>
    }else{
        /* tx buffer empty, disable UDRE interrupt */
        UART1_CONTROL &= ~_BV(UART1_UDRIE);
 40c:	80 91 9a 00 	lds	r24, 0x009A
 410:	8f 7d       	andi	r24, 0xDF	; 223
 412:	80 93 9a 00 	sts	0x009A, r24
    }
}
 416:	ff 91       	pop	r31
 418:	ef 91       	pop	r30
 41a:	9f 91       	pop	r25
 41c:	8f 91       	pop	r24
 41e:	0f 90       	pop	r0
 420:	0b be       	out	0x3b, r0	; 59
 422:	0f 90       	pop	r0
 424:	0f be       	out	0x3f, r0	; 63
 426:	0f 90       	pop	r0
 428:	1f 90       	pop	r1
 42a:	18 95       	reti

0000042c <uart1_init>:
Purpose:  initialize UART1 and set baudrate
Input:    baudrate using macro UART_BAUD_SELECT()
Returns:  none
**************************************************************************/
void uart1_init(unsigned int baudrate)
{
 42c:	9c 01       	movw	r18, r24
    UART1_TxHead = 0;
 42e:	10 92 85 01 	sts	0x0185, r1
    UART1_TxTail = 0;
 432:	10 92 86 01 	sts	0x0186, r1
    UART1_RxHead = 0;
 436:	10 92 87 01 	sts	0x0187, r1
    UART1_RxTail = 0;
 43a:	10 92 88 01 	sts	0x0188, r1
    

    /* Set baud rate */
    if ( baudrate & 0x8000 ) 
 43e:	97 ff       	sbrs	r25, 7
 440:	04 c0       	rjmp	.+8      	; 0x44a <uart1_init+0x1e>
    {
    	UART1_STATUS = (1<<U2X1);  //Enable 2x speed 
 442:	82 e0       	ldi	r24, 0x02	; 2
 444:	80 93 9b 00 	sts	0x009B, r24
      baudrate &= ~0x8000;
 448:	3f 77       	andi	r19, 0x7F	; 127
    }
    UBRR1H = (unsigned char)(baudrate>>8);
 44a:	30 93 98 00 	sts	0x0098, r19
    UBRR1L = (unsigned char) baudrate;
 44e:	20 93 99 00 	sts	0x0099, r18

    /* Enable USART receiver and transmitter and receive complete interrupt */
    UART1_CONTROL = _BV(RXCIE1)|(1<<RXEN1)|(1<<TXEN1);
 452:	88 e9       	ldi	r24, 0x98	; 152
 454:	80 93 9a 00 	sts	0x009A, r24
    
    /* Set frame format: asynchronous, 8data, no parity, 1stop bit */   
    #ifdef URSEL1
    UCSR1C = (1<<URSEL1)|(3<<UCSZ10);
    #else
    UCSR1C = (3<<UCSZ10);
 458:	86 e0       	ldi	r24, 0x06	; 6
 45a:	80 93 9d 00 	sts	0x009D, r24
    #endif 
}/* uart_init */
 45e:	08 95       	ret

00000460 <uart1_getc>:
{    
    unsigned char tmptail;
    unsigned char data;


    if ( UART1_RxHead == UART1_RxTail ) {
 460:	90 91 87 01 	lds	r25, 0x0187
 464:	80 91 88 01 	lds	r24, 0x0188
 468:	98 17       	cp	r25, r24
 46a:	19 f4       	brne	.+6      	; 0x472 <uart1_getc+0x12>
 46c:	20 e0       	ldi	r18, 0x00	; 0
 46e:	31 e0       	ldi	r19, 0x01	; 1
 470:	12 c0       	rjmp	.+36     	; 0x496 <uart1_getc+0x36>
        return UART_NO_DATA;   /* no data available */
    }
    
    /* calculate /store buffer index */
    tmptail = (UART1_RxTail + 1) & UART_RX_BUFFER_MASK;
 472:	e0 91 88 01 	lds	r30, 0x0188
 476:	ef 5f       	subi	r30, 0xFF	; 255
 478:	ef 71       	andi	r30, 0x1F	; 31
    UART1_RxTail = tmptail; 
 47a:	e0 93 88 01 	sts	0x0188, r30
    
    /* get data from receive buffer */
    data = UART1_RxBuf[tmptail];
 47e:	f0 e0       	ldi	r31, 0x00	; 0
 480:	eb 59       	subi	r30, 0x9B	; 155
 482:	fe 4f       	sbci	r31, 0xFE	; 254
 484:	30 81       	ld	r19, Z
    
    return (UART1_LastRxError << 8) + data;
 486:	20 91 89 01 	lds	r18, 0x0189
 48a:	92 2f       	mov	r25, r18
 48c:	80 e0       	ldi	r24, 0x00	; 0
 48e:	ac 01       	movw	r20, r24
 490:	43 0f       	add	r20, r19
 492:	51 1d       	adc	r21, r1
 494:	9a 01       	movw	r18, r20

}/* uart1_getc */
 496:	c9 01       	movw	r24, r18
 498:	08 95       	ret

0000049a <uart1_putc>:
Purpose:  write byte to ringbuffer for transmitting via UART
Input:    byte to be transmitted
Returns:  none          
**************************************************************************/
void uart1_putc(unsigned char data)
{
 49a:	28 2f       	mov	r18, r24
    unsigned char tmphead;

    
    tmphead  = (UART1_TxHead + 1) & UART_TX_BUFFER_MASK;
 49c:	90 91 85 01 	lds	r25, 0x0185
 4a0:	9f 5f       	subi	r25, 0xFF	; 255
 4a2:	9f 71       	andi	r25, 0x1F	; 31
    
    while ( tmphead == UART1_TxTail ){
 4a4:	80 91 86 01 	lds	r24, 0x0186
 4a8:	98 17       	cp	r25, r24
 4aa:	e1 f3       	breq	.-8      	; 0x4a4 <uart1_putc+0xa>
        ;/* wait for free space in buffer */
    }
    
    UART1_TxBuf[tmphead] = data;
 4ac:	e9 2f       	mov	r30, r25
 4ae:	f0 e0       	ldi	r31, 0x00	; 0
 4b0:	eb 5b       	subi	r30, 0xBB	; 187
 4b2:	fe 4f       	sbci	r31, 0xFE	; 254
 4b4:	20 83       	st	Z, r18
    UART1_TxHead = tmphead;
 4b6:	90 93 85 01 	sts	0x0185, r25

    /* enable UDRE interrupt */
    UART1_CONTROL    |= _BV(UART1_UDRIE);
 4ba:	80 91 9a 00 	lds	r24, 0x009A
 4be:	80 62       	ori	r24, 0x20	; 32
 4c0:	80 93 9a 00 	sts	0x009A, r24

}/* uart1_putc */
 4c4:	08 95       	ret

000004c6 <uart1_puts>:
Purpose:  transmit string to UART1
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart1_puts(const char *s )
{
 4c6:	cf 93       	push	r28
 4c8:	df 93       	push	r29
 4ca:	ec 01       	movw	r28, r24
 4cc:	03 c0       	rjmp	.+6      	; 0x4d4 <uart1_puts+0xe>
    while (*s) 
      uart1_putc(*s++);
 4ce:	21 96       	adiw	r28, 0x01	; 1
 4d0:	0e 94 4d 02 	call	0x49a	; 0x49a <uart1_putc>
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart1_puts(const char *s )
{
    while (*s) 
 4d4:	88 81       	ld	r24, Y
 4d6:	88 23       	and	r24, r24
 4d8:	d1 f7       	brne	.-12     	; 0x4ce <uart1_puts+0x8>
      uart1_putc(*s++);

}/* uart1_puts */
 4da:	df 91       	pop	r29
 4dc:	cf 91       	pop	r28
 4de:	08 95       	ret

000004e0 <uart1_puts_p>:
Purpose:  transmit string from program memory to UART1
Input:    program memory string to be transmitted
Returns:  none
**************************************************************************/
void uart1_puts_p(const char *progmem_s )
{
 4e0:	cf 93       	push	r28
 4e2:	df 93       	push	r29
 4e4:	ec 01       	movw	r28, r24
 4e6:	02 c0       	rjmp	.+4      	; 0x4ec <uart1_puts_p+0xc>
    register char c;
    
    while ( (c = pgm_read_byte(progmem_s++)) ) 
      uart1_putc(c);
 4e8:	0e 94 4d 02 	call	0x49a	; 0x49a <uart1_putc>
 4ec:	fe 01       	movw	r30, r28
**************************************************************************/
void uart1_puts_p(const char *progmem_s )
{
    register char c;
    
    while ( (c = pgm_read_byte(progmem_s++)) ) 
 4ee:	21 96       	adiw	r28, 0x01	; 1
 4f0:	84 91       	lpm	r24, Z+
 4f2:	88 23       	and	r24, r24
 4f4:	c9 f7       	brne	.-14     	; 0x4e8 <uart1_puts_p+0x8>
      uart1_putc(c);

}/* uart1_puts_p */
 4f6:	df 91       	pop	r29
 4f8:	cf 91       	pop	r28
 4fa:	08 95       	ret

000004fc <itoa>:
 4fc:	fb 01       	movw	r30, r22
 4fe:	9f 01       	movw	r18, r30
 500:	e8 94       	clt
 502:	42 30       	cpi	r20, 0x02	; 2
 504:	c4 f0       	brlt	.+48     	; 0x536 <itoa+0x3a>
 506:	45 32       	cpi	r20, 0x25	; 37
 508:	b4 f4       	brge	.+44     	; 0x536 <itoa+0x3a>
 50a:	4a 30       	cpi	r20, 0x0A	; 10
 50c:	29 f4       	brne	.+10     	; 0x518 <itoa+0x1c>
 50e:	97 fb       	bst	r25, 7
 510:	1e f4       	brtc	.+6      	; 0x518 <itoa+0x1c>
 512:	90 95       	com	r25
 514:	81 95       	neg	r24
 516:	9f 4f       	sbci	r25, 0xFF	; 255
 518:	64 2f       	mov	r22, r20
 51a:	77 27       	eor	r23, r23
 51c:	0e 94 af 02 	call	0x55e	; 0x55e <__udivmodhi4>
 520:	80 5d       	subi	r24, 0xD0	; 208
 522:	8a 33       	cpi	r24, 0x3A	; 58
 524:	0c f0       	brlt	.+2      	; 0x528 <itoa+0x2c>
 526:	89 5d       	subi	r24, 0xD9	; 217
 528:	81 93       	st	Z+, r24
 52a:	cb 01       	movw	r24, r22
 52c:	00 97       	sbiw	r24, 0x00	; 0
 52e:	a1 f7       	brne	.-24     	; 0x518 <itoa+0x1c>
 530:	16 f4       	brtc	.+4      	; 0x536 <itoa+0x3a>
 532:	5d e2       	ldi	r21, 0x2D	; 45
 534:	51 93       	st	Z+, r21
 536:	10 82       	st	Z, r1
 538:	c9 01       	movw	r24, r18
 53a:	0c 94 9f 02 	jmp	0x53e	; 0x53e <strrev>

0000053e <strrev>:
 53e:	dc 01       	movw	r26, r24
 540:	fc 01       	movw	r30, r24
 542:	67 2f       	mov	r22, r23
 544:	71 91       	ld	r23, Z+
 546:	77 23       	and	r23, r23
 548:	e1 f7       	brne	.-8      	; 0x542 <strrev+0x4>
 54a:	32 97       	sbiw	r30, 0x02	; 2
 54c:	04 c0       	rjmp	.+8      	; 0x556 <strrev+0x18>
 54e:	7c 91       	ld	r23, X
 550:	6d 93       	st	X+, r22
 552:	70 83       	st	Z, r23
 554:	62 91       	ld	r22, -Z
 556:	ae 17       	cp	r26, r30
 558:	bf 07       	cpc	r27, r31
 55a:	c8 f3       	brcs	.-14     	; 0x54e <strrev+0x10>
 55c:	08 95       	ret

0000055e <__udivmodhi4>:
 55e:	aa 1b       	sub	r26, r26
 560:	bb 1b       	sub	r27, r27
 562:	51 e1       	ldi	r21, 0x11	; 17
 564:	07 c0       	rjmp	.+14     	; 0x574 <__udivmodhi4_ep>

00000566 <__udivmodhi4_loop>:
 566:	aa 1f       	adc	r26, r26
 568:	bb 1f       	adc	r27, r27
 56a:	a6 17       	cp	r26, r22
 56c:	b7 07       	cpc	r27, r23
 56e:	10 f0       	brcs	.+4      	; 0x574 <__udivmodhi4_ep>
 570:	a6 1b       	sub	r26, r22
 572:	b7 0b       	sbc	r27, r23

00000574 <__udivmodhi4_ep>:
 574:	88 1f       	adc	r24, r24
 576:	99 1f       	adc	r25, r25
 578:	5a 95       	dec	r21
 57a:	a9 f7       	brne	.-22     	; 0x566 <__udivmodhi4_loop>
 57c:	80 95       	com	r24
 57e:	90 95       	com	r25
 580:	bc 01       	movw	r22, r24
 582:	cd 01       	movw	r24, r26
 584:	08 95       	ret

00000586 <_exit>:
 586:	f8 94       	cli

00000588 <__stop_program>:
 588:	ff cf       	rjmp	.-2      	; 0x588 <__stop_program>
