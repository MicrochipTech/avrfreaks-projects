<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SST: SST</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>SST</h1>
<p>
<h3 align="center">1.1 </h3><h2><a class="anchor" name="intro">
Introduction</a></h2>
This is a implementation of a lightweight scheduler so called "Super Simple Tasker" - SST. The idea is taken from the Robert Ward's article - "Practical Real-Time Techniques" [<a href="http://www.quantum-leaps.com/resources/Ward03.pdf">http://www.quantum-leaps.com/resources/Ward03.pdf</a>].<br>
 Conventional real-time kernels maintain relatively complex execution contexts (including separate stack spaces) for each running thread or task. This gives developer a nice design flexibility and scalability but it is not for free. For smaller devices the requirements for CPU resources can be prohibitive.<br>
 The SST allows to significantly reduce needs for precious RAM and ROM and still allows to keep a real time characteristic of the scheduler (e.g. tasks prioritization and preemption).<br>
 For detailed description of the SST concept look at the mentioned above article or at Embedded.com site <a href="http://www.embedded.com/showArticle.jhtml?articleID=190302110">http://www.embedded.com/showArticle.jhtml?articleID=190302110</a><br>
 In short - this is so called Run To Completion (RTC) scheduler and the preemption points are restricted only to interrupts (ISR) and SST API calls. The preemption is possible only when there is a task (in the ready to run state) with higher priority than priority of the current task.<br>
 Because of this, tasks have no "waiting" state which implies that it is up to developer to properly design given task to not block the whole system (it is usually achieved by implementing task as a finite state machine (FSM)).<br>
 Because of resource utilization as a primary goal there is no dynamic tasks creation and deletion. Also the functions which initialize objects have very limited (or not at all) error detection or recovery. Because such initialization is performed only once (at program startup) and it not depends on dynamic conditions then it is left up to developer to properly use some resources (e.g. not to create more periodic tasks than given <a class="el" href="sst__timer_8h.html#c17a602aa76d07648a0035a426a8c45e">SST_Ticker_T</a> object can handle). <br>
<br>
 There are possibilities to tailor some functionalities (thus usage of resources like RAM and ROM) at compile time by defining some macros or assigning to them special values.<br>
 For simplicity the maximum number of tasks is defined statically at compile time - see <a class="el" href="sst__base__def_8h.html#21e4312065735a4693073bd3fd408e43">SST_MAX_NO_OF_TASKS</a><br>
 E.g. User can declare three different functionalities associated with event queue associated with task - see <a class="el" href="sst__base__def_8h.html#91b4bef2cc2f07f610a99c275134b3e6">SST_MAX_EV_QUEUE_LEN</a>.<br>
 There is possible to automatically enable given timer only when needed and disable when not needed- see <a class="el" href="sst__base__def_8h.html#ea8c167e52967cbab830f699100c0f5f">SST_USE_LAZY_TIMER</a><br>
 When the macro <a class="el" href="sst__base__def_8h.html#354c38bd9f81c3ad3cac30b537fd903f">SST_USE_SIGNAL_MASK</a> defined to nonzero value there is available additional functionality which allows to post event to more than one task (broadcast like) by single function (<a class="el" href="sst_8h.html#4f8fd4af0f0cb0e90e17c8fa1b3f8470">SST_PostEvent</a>) call.<br>
 This functionality can be used to decouple tasks - event can be sent without previous knowledge of ID for given task(s). E.g. you can with ease send event to two tasks interested about change of ADC value and if you later chnage your mind and want to inform three tasks then you do not need change the existing code of event sender nor receiver. Just add proper event mask for the new receiver task. <br>
 Some numbers:<ul>
<li>5 tasks with queue for 4 events each (SST RAM usage):<ul>
<li>78 (AVR)</li><li>292 (ARM)</li></ul>
</li><li>API for scheduler (FLASH):<ul>
<li>672 (AVR)</li><li>828 (ARM)</li></ul>
</li><li>5 tasks with queue for 4 events each with event broadcast functionality (SST RAM usage):<ul>
<li>83 (AVR)</li><li>312 (ARM)</li></ul>
</li><li>API for scheduler with event broadcast functionality (FLASH):<ul>
<li>784 (AVR)</li><li>1048 (ARM)</li></ul>
</li><li>Optional API for periodic and time scheduled tasks (FLASH):<ul>
<li>192 (AVR)</li><li>216 (ARM)</li></ul>
</li><li>Optional API for mutex (FLASH):<ul>
<li>72 (AVR)</li><li>148 (ARM)</li></ul>
</li></ul>
<h2><a class="anchor" name="support">
Supported Devices</a></h2>
Atmel AVR, NXP LPC (ARM), Atmel AT91 (ARM)<h2><a class="anchor" name="install">
Installation</a></h2>
All you need is to include supplied source files from the <code>sst</code> folder into your project.<br>
 There are parts of the code (in the <a class="el" href="sst__base__def_8h.html">sst_base_def.h</a>) to enable/disable interrupts which use GNU specific extensions but they are very short (a few lines) and easy to replace by constructions used by other toolsets e.g. IAR.<br>
 Mainly for size efficiency, all tunable parameters are fixed at compile time. They are placed in the <a class="el" href="sst__base__def_8h.html">sst_base_def.h</a> file which is specific for given CPU and project.<h2><a class="anchor" name="examples">
Examples</a></h2>
There are provided in the <code>examples</code> folder two examples of the SST usage. Both are prepared for running on the AVR and LPC (ARM) platforms (the <code>AVR</code> and <code>LPC</code> folders respectively).<br>
<p>
The example below shows how to create and schedule two tasks, one periodic and one event schedulable.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="sst__timer_8h.html">sst_timer.h</a>&gt;</span>

<span class="preprocessor">#define TIMER_TASK_PRIO        (SST_MIN_TASK_PRIO + 1)</span>
<span class="preprocessor"></span><span class="preprocessor">#define EVENT_TASK_PRIO        (SST_MIN_TASK_PRIO + 2)</span>
<span class="preprocessor"></span>
<a class="code" href="sst__intern_8h.html#1ea52fd8fe6e7118999e3c04f3753b2b">SST_TaskID_T</a> timer_task_id;
<a class="code" href="sst__intern_8h.html#1ea52fd8fe6e7118999e3c04f3753b2b">SST_TaskID_T</a> event_task_id;

<a class="code" href="sst__timer_8h.html#5d685a1dfdebb07b31c6e59ef0c083e9">SST_TICKER_DEFINE</a>(ticker, 1);

<span class="comment">// this is an ISR function for periodic timer interrupt</span>
<span class="keywordtype">void</span> Timer_ISR(<span class="keywordtype">void</span>)
{
    <a class="code" href="sst__intern_8h.html#3ad2d9067dd414c1d9d11ab54b0fdc26">SST_DECLARE_ISR</a>;
    
    <span class="comment">// do some timer HW housekeeping (if needed)</span>

    <a class="code" href="sst__intern_8h.html#14f5d75172e06770be7b9c5a4a04e03e">SST_ISR_ENTRY</a>(<a class="code" href="sst__intern_8h.html#534e46f75f8824d7f609f41e69d51d4a">SST_MIN_INT_PRIO</a>+1);

    <a class="code" href="sst__timer_8h.html#6bd77ded2989304492acc6615c733da5">SST_TimerTick</a>(&amp;ticker);

    <a class="code" href="sst__intern_8h.html#2ae07f6058627d0ea67dc64c91e97129">SST_ISR_EXIT</a>();
}


<span class="keywordtype">void</span> timer_task_func(<a class="code" href="sst__event_8h.html#fe74032b6d1729f1f9135a495c1d5cc3">SST_Event_T</a> e)
{
    <span class="keyword">static</span> <a class="code" href="sst__base__def_8h.html#24d4221cdd204d79e5229dfa493e0159">CPU_Base_T</a> ticks;

    ticks++;

    <span class="comment">// do some other processing</span>
    
    <span class="comment">// sometime start event triggered task</span>
    <span class="keywordflow">if</span> (0 == (ticks % 3))
    {
        <a class="code" href="sst_8h.html#4f8fd4af0f0cb0e90e17c8fa1b3f8470">SST_PostEvent</a>(event_task_id, 3, ticks);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0 == (ticks % 8))
    {
        <a class="code" href="sst_8h.html#4f8fd4af0f0cb0e90e17c8fa1b3f8470">SST_PostEvent</a>(event_task_id, 8, ticks);
    }
    <span class="keywordflow">else</span>
    {
    }
}


<span class="keywordtype">void</span> event_task_func(<a class="code" href="sst__event_8h.html#fe74032b6d1729f1f9135a495c1d5cc3">SST_Event_T</a> e)
{
    printf(<span class="stringliteral">"divident = %lu,\tticks = %lu\n"</span>, (uint32_t)e.sig, (uint32_t)e.par);
}


<span class="keywordtype">void</span> <a class="code" href="sst_8h.html#72726c8678b00d7f75771594c6a59b13">SST_Start</a>(<span class="keywordtype">void</span>)
{
    <span class="comment">// perform some IO anf HW initialization</span>
    ioinit();

    timer_task_id = <a class="code" href="sst_8h.html#573abf104045f1163f028bc02f445ba1">SST_CreateTask</a>(TIMER_TASK_PRIO, timer_task_func);
    event_task_id = <a class="code" href="sst_8h.html#573abf104045f1163f028bc02f445ba1">SST_CreateTask</a>(EVENT_TASK_PRIO, event_task_func);

    <span class="comment">// create a periodic task -  period is 10 calls of ticker</span>
    (void) <a class="code" href="sst__timer_8h.html#37c89a616de693f19e801e6fa3576f5d">SST_MakeTimedTask</a>(timer_task_id, 10, <span class="keyword">true</span>, &amp;ticker);

    <span class="comment">// enable interrupts</span>
    <a class="code" href="sst__intern_8h.html#c8d541f772823c2ef0be55d7f1930470">SST_INT_UNLOCK</a>();
}


<span class="keywordtype">void</span> <a class="code" href="sst_8h.html#3972841e709c07f625043a17d3cc5d25">SST_OnIdle</a>(<span class="keywordtype">void</span>)
{
    <span class="comment">// put microcontroller into "idle" mode</span>
}


<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
    <a class="code" href="sst_8h.html#b45b5d20c0797e108b04c8da08dcbd54">SST_Run</a>();
}
</pre></div><p>
<br>
 <br>
<h2><a class="anchor" name="copyright">
Copyright</a></h2>
(C) Copyright 2006, Artur Lipowski<br>
 No guarantees, warrantees, or promises, implied or otherwise.<br>
 May be used for hobby or commercial purposes provided copyright notice remains intact.<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Artur Lipowski &lt;<a href="mailto:LAL@pro.onet.pl">LAL@pro.onet.pl</a>&gt; </dd></dl>
<dl class="version" compact><dt><b>Version:</b></dt><dd>1.1 </dd></dl>
<dl class="date" compact><dt><b>Date:</b></dt><dd>30 December 2006 </dd></dl>
<hr size="1"><address style="align: right;"><small>Generated on Sat Dec 30 18:21:36 2006 for SST by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
