file name: example_1.txt – built in delays


As mentioned in the article, some compilers have macros or functions which provide built it delays.  It is important to read the documentation, however, on their proper use and limitations.  A common requirement is that the delay time be hard coded as a number, since it is during the compilation process that the correct timing loops are constructed.

To do this the compiler must also know the processor speed.  One common method is to include a preprocessor directive such as:

    #define   F_CPU 8000000UL

which would correspond to an 8 MHz clock.  Leaving this out may default to an assumed speed, which would likely cause incorrect delays.  Or it may result in a compiler error.

Then the delays are coded with something similar to the following:

    _delay_ms(300);          // wait 300 milliseconds

When the code generated by this macro is reached, the processor enters some nested loops which execute enough instructions to consume the requested 300 milliseconds.  It is a busy loop, meaning the processor isn’t available for other work.  The exception is interrupts, which will be processed, but which will also alter the overall accuracy of the delay since their execution times are not included in the timing calculations.

If you want to have a variable length delay, an easy way to do this is to embed the hard coded macro in a function, and pass an argument that repeats it the desired number of times:

    void wait_sec(unsigned int seconds) {
      while (seconds--) _delay_ms(1000);    // wait 1 second each pass
    }

You can extend this idea even further:

    void wait_min(unsigned int minutes) {
      while (minutes--) wait_sec(60);      // wait 1 minute each pass
    }

and so on.

Using these “wrapper functions” introduces a little error in the timing because both the function and the loops themselves require a certain amount of overhead.  In many cases it will be negligible and can be ignored, but if it is important you can adjust one or more of the delays to compensate.

The downside of this type of delay is that you can’t be doing any other useful work (other than in interrupts) while the delay is taking place.
