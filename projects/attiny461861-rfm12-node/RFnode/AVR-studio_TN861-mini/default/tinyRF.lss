
AVRASM ver. 2.1.51  \\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\main.asm Mon Jun 24 13:56:02 2013

[builtin](2): Including file 'C:\Program Files\Atmel\Atmel Studio 6.0\extensions\Atmel\AVRAssembler\2.1.51.46\AvrAssembler/Include\tn861def.inc'
\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\main.asm(4): Including file '\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\macros.inc'
\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\main.asm(109): Including file '\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\vectors_861.asm'
\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\main.asm(219): Including file '\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\subs.asm'
\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\main.asm(220): Including file '\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\ext0.asm'
\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\main.asm(221): Including file '\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\1wire_28-06-10.asm'
\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\main.asm(222): Including file '\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\RFM12B.asm'
\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\main.asm(223): Including file '\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\SPI.asm'
\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\main.asm(224): Including file '\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\crc.asm'
\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\main.asm(225): Including file '\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\eeprom.asm'
                 
                 
                 
                 ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny861.xml ***********
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "tn861def.inc"
                 ;* Title             : Register/Bit Definitions for the ATtiny861
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATtiny861
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _TN861DEF_INC_
                 #define _TN861DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATtiny861
                 #pragma AVRPART ADMIN PART_NAME ATtiny861
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x93
                 .equ	SIGNATURE_002	= 0x0d
                 
                 #pragma AVRPART CORE CORE_VERSION V2
                 #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	GIMSK	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK	= 0x39
                 .equ	TIFR	= 0x38
                 .equ	SPMCSR	= 0x37
                 .equ	PRR	= 0x36
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	TCCR0B	= 0x33
                 .equ	TCNT0L	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	TCCR1A	= 0x30
                 .equ	TCCR1B	= 0x2f
                 .equ	TCNT1	= 0x2e
                 .equ	OCR1A	= 0x2d
                 .equ	OCR1B	= 0x2c
                 .equ	OCR1C	= 0x2b
                 .equ	OCR1D	= 0x2a
                 .equ	PLLCSR	= 0x29
                 .equ	CLKPR	= 0x28
                 .equ	TCCR1C	= 0x27
                 .equ	TCCR1D	= 0x26
                 .equ	TC1H	= 0x25
                 .equ	DT1	= 0x24
                 .equ	PCMSK0	= 0x23
                 .equ	PCMSK1	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	DWDR	= 0x20
                 .equ	EEARH	= 0x1f
                 .equ	EEARL	= 0x1e
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTA	= 0x1b
                 .equ	DDRA	= 0x1a
                 .equ	PINA	= 0x19
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	TCCR0A	= 0x15
                 .equ	TCNT0H	= 0x14
                 .equ	OCR0A	= 0x13
                 .equ	OCR0B	= 0x12
                 .equ	USIPP	= 0x11
                 .equ	USIBR	= 0x10
                 .equ	USIDR	= 0x0f
                 .equ	USISR	= 0x0e
                 .equ	USICR	= 0x0d
                 .equ	GPIOR2	= 0x0c
                 .equ	GPIOR1	= 0x0b
                 .equ	GPIOR0	= 0x0a
                 .equ	ACSRB	= 0x09
                 .equ	ACSRA	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCH	= 0x05
                 .equ	ADCL	= 0x04
                 .equ	ADCSRB	= 0x03
                 .equ	DIDR1	= 0x02
                 .equ	DIDR0	= 0x01
                 .equ	TCCR1E	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** PORTA ************************
                 ; PORTA - Port A Data Register
                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                 .equ	PA0	= 0	; For compatibility
                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                 .equ	PA1	= 1	; For compatibility
                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                 .equ	PA2	= 2	; For compatibility
                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                 .equ	PA3	= 3	; For compatibility
                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                 .equ	PA4	= 4	; For compatibility
                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                 .equ	PA5	= 5	; For compatibility
                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                 .equ	PA6	= 6	; For compatibility
                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                 .equ	PA7	= 7	; For compatibility
                 
                 ; DDRA - Port A Data Direction Register
                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                 
                 ; PINA - Port A Input Pins
                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADPS0	= 0	; ADC Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; ADCSRB - ADC Control and Status Register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
                 .equ	MUX5	= 3	; 
                 .equ	REFS2	= 4	; 
                 .equ	IPR	= 5	; Input Polarity Mode
                 .equ	GSEL	= 6	; Gain Select
                 .equ	BIN	= 7	; Bipolar Input Mode
                 
                 ; DIDR0 - Digital Input Disable Register 0
                 .equ	ADC0D	= 0	; ADC0 Digital input Disable
                 .equ	ADC1D	= 1	; ADC1 Digital input Disable
                 .equ	ADC2D	= 2	; ADC2 Digital input Disable
                 .equ	AREFD	= 3	; AREF Digital Input Disable
                 .equ	ADC3D	= 4	; ADC3 Digital input Disable
                 .equ	ADC4D	= 5	; ADC4 Digital input Disable
                 .equ	ADC5D	= 6	; ADC5 Digital input Disable
                 .equ	ADC6D	= 7	; ADC6 Digital input Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ	ADC7D	= 4	; ADC7 Digital input Disable
                 .equ	ADC8D	= 5	; ADC8 Digital input Disable
                 .equ	ADC9D	= 6	; ADC9 Digital input Disable
                 .equ	ADC10D	= 7	; ADC10 Digital input Disable
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ACSRA - Analog Comparator Control And Status Register A
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACME	= 2	; Analog Comparator Multiplexer Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; ACSRB - Analog Comparator Control And Status Register B
                 .equ	ACM0	= 0	; Analog Comparator Multiplexer
                 .equ	ACM1	= 1	; Analog Comparator Multiplexer
                 .equ	ACM2	= 2	; Analog Comparator Multiplexer
                 .equ	HLEV	= 6	; Hysteresis Level
                 .equ	HSEL	= 7	; Hysteresis Select
                 
                 
                 ; ***** USI **************************
                 ; USIPP - USI Pin Position
                 .equ	USIPOS	= 0	; USI Pin Position
                 
                 ; USIBR - USI Buffer Register
                 .equ	USIBR0	= 0	; USI Buffer Register bit 0
                 .equ	USIBR1	= 1	; USI Buffer Register bit 1
                 .equ	USIBR2	= 2	; USI Buffer Register bit 2
                 .equ	USIBR3	= 3	; USI Buffer Register bit 3
                 .equ	USIBR4	= 4	; USI Buffer Register bit 4
                 .equ	USIBR5	= 5	; USI Buffer Register bit 5
                 .equ	USIBR6	= 6	; USI Buffer Register bit 6
                 .equ	USIBR7	= 7	; USI Buffer Register bit 7
                 
                 ; USIDR - USI Data Register
                 .equ	USIDR0	= 0	; USI Data Register bit 0
                 .equ	USIDR1	= 1	; USI Data Register bit 1
                 .equ	USIDR2	= 2	; USI Data Register bit 2
                 .equ	USIDR3	= 3	; USI Data Register bit 3
                 .equ	USIDR4	= 4	; USI Data Register bit 4
                 .equ	USIDR5	= 5	; USI Data Register bit 5
                 .equ	USIDR6	= 6	; USI Data Register bit 6
                 .equ	USIDR7	= 7	; USI Data Register bit 7
                 
                 ; USISR - USI Status Register
                 .equ	USICNT0	= 0	; USI Counter Value Bit 0
                 .equ	USICNT1	= 1	; USI Counter Value Bit 1
                 .equ	USICNT2	= 2	; USI Counter Value Bit 2
                 .equ	USICNT3	= 3	; USI Counter Value Bit 3
                 .equ	USIDC	= 4	; Data Output Collision
                 .equ	USIPF	= 5	; Stop Condition Flag
                 .equ	USIOIF	= 6	; Counter Overflow Interrupt Flag
                 .equ	USISIF	= 7	; Start Condition Interrupt Flag
                 
                 ; USICR - USI Control Register
                 .equ	USITC	= 0	; Toggle Clock Port Pin
                 .equ	USICLK	= 1	; Clock Strobe
                 .equ	USICS0	= 2	; USI Clock Source Select Bit 0
                 .equ	USICS1	= 3	; USI Clock Source Select Bit 1
                 .equ	USIWM0	= 4	; USI Wire Mode Bit 0
                 .equ	USIWM1	= 5	; USI Wire Mode Bit 1
                 .equ	USIOIE	= 6	; Counter Overflow Interrupt Enable
                 .equ	USISIE	= 7	; Start Condition Interrupt Enable
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEARH - EEPROM Address Register High Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 0
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDTCSR	= WDTCR	; For compatibility
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDTOE	= WDCE	; For compatibility
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TICIE0	= 0	; Timer/Counter0 Input Capture Interrupt Enable
                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0B	= 3	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 .equ	OCIE0A	= 4	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 
                 ; TIFR - Timer/Counter0 Interrupt Flag register
                 .equ	ICF0	= 0	; Timer/Counter0 Input Capture Flag
                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                 .equ	OCF0B	= 3	; Timer/Counter0 Output Compare Flag 0B
                 .equ	OCF0A	= 4	; Timer/Counter0 Output Compare Flag 0A
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	ACIC0	= 3	; Analog Comparator Input Capture Enable
                 .equ	ICES0	= 4	; Input Capture Edge Select
                 .equ	ICNC0	= 5	; Input Capture Noice Canceler
                 .equ	ICEN0	= 6	; Input Capture Mode Enable
                 .equ	TCW0	= 7	; Timer/Counter 0 Width
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	PSR0	= 3	; Timer/Counter 0 Prescaler Reset
                 .equ	TSM	= 4	; Timer/Counter Synchronization Mode
                 
                 ; TCNT0H - Timer/Counter0 High
                 .equ	TCNT0H_0	= 0	; 
                 .equ	TCNT0H_1	= 1	; 
                 .equ	TCNT0H_2	= 2	; 
                 .equ	TCNT0H_3	= 3	; 
                 .equ	TCNT0H_4	= 4	; 
                 .equ	TCNT0H_5	= 5	; 
                 .equ	TCNT0H_6	= 6	; 
                 .equ	TCNT0H_7	= 7	; 
                 
                 ; TCNT0L - Timer/Counter0 Low
                 .equ	TCNT0L_0	= 0	; 
                 .equ	TCNT0L_1	= 1	; 
                 .equ	TCNT0L_2	= 2	; 
                 .equ	TCNT0L_3	= 3	; 
                 .equ	TCNT0L_4	= 4	; 
                 .equ	TCNT0L_5	= 5	; 
                 .equ	TCNT0L_6	= 6	; 
                 .equ	TCNT0L_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCR0A_0	= 0	; 
                 .equ	OCR0A_1	= 1	; 
                 .equ	OCR0A_2	= 2	; 
                 .equ	OCR0A_3	= 3	; 
                 .equ	OCR0A_4	= 4	; 
                 .equ	OCR0A_5	= 5	; 
                 .equ	OCR0A_6	= 6	; 
                 .equ	OCR0A_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TCCR1A - Timer/Counter Control Register A
                 .equ	PWM1B	= 0	; Pulse Width Modulator Enable
                 .equ	PWM1A	= 1	; Pulse Width Modulator Enable
                 .equ	FOC1B	= 2	; Force Output Compare Match 1B
                 .equ	FOC1A	= 3	; Force Output Compare Match 1A
                 .equ	COM1B0	= 4	; Compare Output Mode, Bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode, Bit 1
                 .equ	COM1A0	= 6	; Compare Output Mode, Bit 1
                 .equ	COM1A1	= 7	; Compare Output Mode, Bit 0
                 
                 ; TCCR1B - Timer/Counter Control Register B
                 .equ	CS10	= 0	; Clock Select Bits
                 .equ	CS11	= 1	; Clock Select Bits
                 .equ	CS12	= 2	; Clock Select Bits
                 .equ	CS13	= 3	; Clock Select Bits
                 .equ	DTPS10	= 4	; Dead Time Prescaler
                 .equ	DTPS11	= 5	; Dead Time Prescaler
                 .equ	PSR1	= 6	; Timer/Counter 1 Prescaler reset
                 
                 ; TCCR1C - Timer/Counter Control Register C
                 .equ	PWM1D	= 0	; Pulse Width Modulator D Enable
                 .equ	FOC1D	= 1	; Force Output Compare Match 1D
                 .equ	COM1D0	= 2	; Comparator D output mode
                 .equ	COM1D1	= 3	; Comparator D output mode
                 .equ	COM1B0S	= 4	; COM1B0 Shadow Bit
                 .equ	COM1B1S	= 5	; COM1B1 Shadow Bit
                 .equ	COM1A0S	= 6	; COM1A0 Shadow Bit
                 .equ	COM1A1S	= 7	; COM1A1 Shadow Bit
                 
                 ; TCCR1D - Timer/Counter Control Register D
                 .equ	WGM10	= 0	; Waveform Generation Mode Bit
                 .equ	WGM11	= 1	; Waveform Generation Mode Bit
                 .equ	FPF1	= 2	; Fault Protection Interrupt Flag
                 .equ	FPAC1	= 3	; Fault Protection Analog Comparator Enable
                 .equ	FPES1	= 4	; Fault Protection Edge Select
                 .equ	FPNC1	= 5	; Fault Protection Noise Canceler
                 .equ	FPEN1	= 6	; Fault Protection Mode Enable
                 .equ	FPIE1	= 7	; Fault Protection Interrupt Enable
                 
                 ; TCCR1E - Timer/Counter1 Control Register E
                 .equ	OC1OE0	= 0	; Ouput Compare Override Enable Bit 0
                 .equ	OC1OE1	= 1	; Ouput Compare Override Enable Bit 1
                 .equ	OC1OE2	= 2	; Ouput Compare Override Enable Bit 2
                 .equ	OC1OE3	= 3	; Ouput Compare Override Enable Bit 3
                 .equ	OC1OE4	= 4	; Ouput Compare Override Enable Bit 4
                 .equ	OC1OE5	= 5	; Ouput Compare Override Enable Bit 5
                 
                 ; TCNT1 - Timer/Counter Register
                 .equ	TC1H_0	= 0	; Timer/Counter Register Bit 0
                 .equ	TC1H_1	= 1	; Timer/Counter Register Bit 1
                 .equ	TC1H_2	= 2	; Timer/Counter Register Bit 2
                 .equ	TC1H_3	= 3	; Timer/Counter Register Bit 3
                 .equ	TC1H_4	= 4	; Timer/Counter Register Bit 4
                 .equ	TC1H_5	= 5	; Timer/Counter Register Bit 5
                 .equ	TC1H_6	= 6	; Timer/Counter Register Bit 6
                 .equ	TC1H_7	= 7	; Timer/Counter Register Bit 7
                 
                 ; TC1H - Timer/Counter 1 Register High
                 .equ	TC18	= 0	; Timer/Counter Register Bit 0
                 .equ	TC19	= 1	; Timer/Counter Register Bit 1
                 
                 ; OCR1A - Output Compare Register
                 .equ	OCR1A0	= 0	; Output Compare Register A Bit 0
                 .equ	OCR1A1	= 1	; Output Compare Register A Bit 1
                 .equ	OCR1A2	= 2	; Output Compare Register A Bit 2
                 .equ	OCR1A3	= 3	; Output Compare Register A Bit 3
                 .equ	OCR1A4	= 4	; Output Compare Register A Bit 4
                 .equ	OCR1A5	= 5	; Output Compare Register A Bit 5
                 .equ	OCR1A6	= 6	; Output Compare Register A Bit 6
                 .equ	OCR1A7	= 7	; Output Compare Register A Bit 7
                 
                 ; OCR1B - Output Compare Register
                 .equ	OCR1B0	= 0	; Output Compare Register B Bit 0
                 .equ	OCR1B1	= 1	; Output Compare Register B Bit 1
                 .equ	OCR1B2	= 2	; Output Compare Register B Bit 2
                 .equ	OCR1B3	= 3	; Output Compare Register B Bit 3
                 .equ	OCR1B4	= 4	; Output Compare Register B Bit 4
                 .equ	OCR1B5	= 5	; Output Compare Register B Bit 5
                 .equ	OCR1B6	= 6	; Output Compare Register B Bit 6
                 .equ	OCR1B7	= 7	; Output Compare Register B Bit 7
                 
                 ; OCR1C - Output compare register
                 .equ	OCR1C0	= 0	; 
                 .equ	OCR1C1	= 1	; 
                 .equ	OCR1C2	= 2	; 
                 .equ	OCR1C3	= 3	; 
                 .equ	OCR1C4	= 4	; 
                 .equ	OCR1C5	= 5	; 
                 .equ	OCR1C6	= 6	; 
                 .equ	OCR1C7	= 7	; 
                 
                 ; OCR1D - Output compare register
                 .equ	OCR1D0	= 0	; 
                 .equ	OCR1D1	= 1	; 
                 .equ	OCR1D2	= 2	; 
                 .equ	OCR1D3	= 3	; 
                 .equ	OCR1D4	= 4	; 
                 .equ	OCR1D5	= 5	; 
                 .equ	OCR1D6	= 6	; 
                 .equ	OCR1D7	= 7	; 
                 
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 5	; OCIE1A: Timer/Counter1 Output Compare B Interrupt Enable
                 .equ	OCIE1A	= 6	; OCIE1A: Timer/Counter1 Output Compare Interrupt Enable
                 .equ	OCIE1D	= 7	; OCIE1D: Timer/Counter1 Output Compare Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 5	; Timer/Counter1 Output Compare Flag 1B
                 .equ	OCF1A	= 6	; Timer/Counter1 Output Compare Flag 1A
                 .equ	OCF1D	= 7	; Timer/Counter1 Output Compare Flag 1D
                 
                 ; DT1 - Timer/Counter 1 Dead Time Value
                 .equ	DT1L0	= 0	; 
                 .equ	DT1L1	= 1	; 
                 .equ	DT1L2	= 2	; 
                 .equ	DT1L3	= 3	; 
                 .equ	DT1H0	= 4	; 
                 .equ	DT1H1	= 5	; 
                 .equ	DT1H2	= 6	; 
                 .equ	DT1H3	= 7	; 
                 
                 
                 ; ***** BOOT_LOAD ********************
                 ; SPMCSR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	RFLB	= 3	; Read fuse and lock bits
                 .equ	CTPB	= 4	; Clear temporary page buffer
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; MCUCR - MCU Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 
                 ; GIMSK - General Interrupt Mask Register
                 .equ	GICR	= GIMSK	; For compatibility
                 .equ	PCIE0	= 4	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 5	; Pin Change Interrupt Enable 1
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                 
                 ; GIFR - General Interrupt Flag register
                 .equ	PCIF	= 5	; Pin Change Interrupt Flag
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 .equ	INTF1	= 7	; External Interrupt Flag 1
                 
                 ; PCMSK0 - Pin Change Enable Mask 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask Bit 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask Bit 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask Bit 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask Bit 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask Bit 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask Bit 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask Bit 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask Bit 7
                 
                 ; PCMSK1 - Pin Change Enable Mask 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask Bit 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask Bit 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask Bit 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask Bit 11
                 .equ	PCINT12	= 4	; Pin Change Enable Mask Bit 12
                 .equ	PCINT13	= 5	; Pin Change Enable Mask Bit 13
                 .equ	PCINT14	= 6	; Pin Change Enable Mask Bit 14
                 .equ	PCINT15	= 7	; Pin Change Enable Mask Bit 15
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                 .equ	SM0	= 3	; Sleep Mode Select Bit 0
                 .equ	SM1	= 4	; Sleep Mode Select Bit 1
                 .equ	SE	= 5	; Sleep Enable
                 .equ	PUD	= 6	; Pull-up Disable
                 
                 ; MCUSR - MCU Status register
                 .equ	PORF	= 0	; Power-On Reset Flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; PRR - Power Reduction Register
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSI	= 1	; Power Reduction USI
                 .equ	PRTIM0	= 2	; Power Reduction Timer/Counter0
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 
                 ; OSCCAL - Oscillator Calibration Register
                 .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
                 .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
                 .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
                 .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
                 .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
                 .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
                 .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
                 .equ	CAL7	= 7	; Oscillatro Calibration Value Bit 7
                 
                 ; PLLCSR - PLL Control and status register
                 .equ	PLOCK	= 0	; PLL Lock detector
                 .equ	PLLE	= 1	; PLL Enable
                 .equ	PCKE	= 2	; PCK Enable
                 .equ	LSM	= 7	; Low speed mode
                 
                 ; CLKPR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                 
                 ; DWDR - debugWire data register
                 .equ	DWDR0	= 0	; 
                 .equ	DWDR1	= 1	; 
                 .equ	DWDR2	= 2	; 
                 .equ	DWDR3	= 3	; 
                 .equ	DWDR4	= 4	; 
                 .equ	DWDR5	= 5	; 
                 .equ	DWDR6	= 6	; 
                 .equ	DWDR7	= 7	; 
                 
                 ; GPIOR2 - General Purpose IO register 2
                 .equ	GPIOR20	= 0	; 
                 .equ	GPIOR21	= 1	; 
                 .equ	GPIOR22	= 2	; 
                 .equ	GPIOR23	= 3	; 
                 .equ	GPIOR24	= 4	; 
                 .equ	GPIOR25	= 5	; 
                 .equ	GPIOR26	= 6	; 
                 .equ	GPIOR27	= 7	; 
                 
                 ; GPIOR1 - General Purpose register 1
                 .equ	GPIOR10	= 0	; 
                 .equ	GPIOR11	= 1	; 
                 .equ	GPIOR12	= 2	; 
                 .equ	GPIOR13	= 3	; 
                 .equ	GPIOR14	= 4	; 
                 .equ	GPIOR15	= 5	; 
                 .equ	GPIOR16	= 6	; 
                 .equ	GPIOR17	= 7	; 
                 
                 ; GPIOR0 - General purpose register 0
                 .equ	GPIOR00	= 0	; 
                 .equ	GPIOR01	= 1	; 
                 .equ	GPIOR02	= 2	; 
                 .equ	GPIOR03	= 3	; 
                 .equ	GPIOR04	= 4	; 
                 .equ	GPIOR05	= 5	; 
                 .equ	GPIOR06	= 6	; 
                 .equ	GPIOR07	= 7	; 
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lockbit
                 .equ	LB2	= 1	; Lockbit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock source
                 .equ	CKSEL1	= 1	; Select Clock source
                 .equ	CKSEL2	= 2	; Select Clock source
                 .equ	CKSEL3	= 3	; Select Clock source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock Output Enable
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through the Chip Erase
                 .equ	WDTON	= 4	; Watchdog Timer always on
                 .equ	SPIEN	= 5	; Enable Serial Program and Data Downloading
                 .equ	DWEN	= 6	; DebugWIRE Enable
                 .equ	RSTDISBL	= 7	; External Reset disable
                 
                 ; EXTENDED fuse bits
                 .equ	SELFPRGEN	= 0	; Self-Programming Enable
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x0fff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 512
                 .equ	RAMEND	= 0x025f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x01ff
                 .equ	EEPROMEND	= 0x01ff
                 .equ	EEADRBITS	= 9
                 #pragma AVRPART MEMORY PROG_FLASH 8192
                 #pragma AVRPART MEMORY EEPROM 512
                 #pragma AVRPART MEMORY INT_SRAM SIZE 512
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x0
                 .equ	NRWW_STOP_ADDR	= 0xfff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x0
                 .equ	PAGESIZE	= 32
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt 0
                 .equ	PCIaddr	= 0x0002	; Pin Change Interrupt
                 .equ	OC1Aaddr	= 0x0003	; Timer/Counter1 Compare Match 1A
                 .equ	OC1Baddr	= 0x0004	; Timer/Counter1 Compare Match 1B
                 .equ	OVF1addr	= 0x0005	; Timer/Counter1 Overflow
                 .equ	OVF0addr	= 0x0006	; Timer/Counter0 Overflow
                 .equ	USI_STARTaddr	= 0x0007	; USI Start
                 .equ	USI_OVFaddr	= 0x0008	; USI Overflow
                 .equ	ERDYaddr	= 0x0009	; EEPROM Ready
                 .equ	ACIaddr	= 0x000a	; Analog Comparator
                 .equ	ADCCaddr	= 0x000b	; ADC Conversion Complete
                 .equ	WDTaddr	= 0x000c	; Watchdog Time-Out
                 .equ	INT1addr	= 0x000d	; External Interrupt 1
                 .equ	OC0Aaddr	= 0x000e	; Timer/Counter0 Compare Match A
                 .equ	OC0Baddr	= 0x000f	; Timer/Counter0 Compare Match B
                 .equ	ICP0addr	= 0x0010	; ADC Conversion Complete
                 .equ	OC1Daddr	= 0x0011	; Timer/Counter1 Compare Match D
                 .equ	FAULT_PROTaddr	= 0x0012	; Timer/Counter1 Fault Protection
                 
                 .equ	INT_VECTORS_SIZE	= 19	; size in words
                 
                 #endif  /* _TN861DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                 
                 ;.include	"tn861def.inc"		; un-comment for AVR studio-4
                 .include	"macros.inc"
                 
                 .macro	sb
                 	sbr	@0,(1<<@1)
                 .endmacro
                 
                 .macro	cb
                 	cbr	@0,(1<<@1)
                 .endmacro
                 	
                 
                 .macro	stream
                 	push	temp1
                 	ldi	temp1,@0
                 	sts	stream_destination,temp1
                 	pop	temp1
                 .endmacro
                 
                 
                 .macro	stopRF
                 	ext0_OFF		; turn off int
                 	RFcommand RF_IDLE_MODE	; xtal on, (RX, TX, low-bat detect, clk out) all off
                 	clr	state		; set to zero
                 .endmacro
                 
                 
                 .macro	jeq
                 	cpi	@0,@1
                 	brne	m1
                 	rjmp	@2
                 m1:
                 .endmacro
                 
                 
                 .macro	jne
                 	cpi	@0,@1
                 	brne	@2
                 .endmacro
                 
                 
                 
                 .macro	stringout
                 	rcall	sendstring
                 	.db	@0,0
                 .endmacro
                 
                 
                 
                 
                 .macro	ldx
                 	.if @0==1
                 	ldi	xl,low(@1)
                 	ldi	xh,high(@1)
                 	.elif @0==2
                 	ldi	xl,low(2*@1)
                 	ldi	xh,high(2*@1)
                 	.else
                 	.error "must be ram or rom"
                 	.endif
                 .endmacro
                 
                 .macro	ldy
                 	.if @0==1
                 	ldi	yl,low(@1)
                 	ldi	yh,high(@1)
                 	.elif @0==2
                 	ldi	yl,low(2*@1)
                 	ldi	yh,high(2*@1)
                 	.else
                 	.error "must be ram or rom"
                 	.endif
                 .endmacro
                 
                 .macro	ldz
                 	.if @0==1
                 	ldi	ZL,low(@1)
                 	ldi	ZH,high(@1)
                 	.elif @0==2
                 	ldi	ZL,low(2*@1)
                 	ldi	ZH,high(2*@1)
                 	.else
                 	.error "must be ram or rom"
                 	.endif
                 .endmacro
                 
                 .macro	ldACC
                 	.if @0==1
                 	ldi	accL,low(@1)
                 	ldi	accH,high(@1)
                 	.elif @0==2
                 	ldi	accL,low(2*@1)
                 	ldi	accH,high(2*@1)
                 	.else
                 	.error "must be ram or rom"
                 	.endif
                 .endmacro
                 
                 .macro	loadX
                 	lds	xl,@0
                 	lds	xh,@0+1
                 .endmacro
                 
                 .macro	storeX
                 	sts	@0,xl
                 	sts	@0+1,xh
                 .endmacro
                 
                 .macro	loadY
                 	lds	yl,@0
                 	lds	yh,@0+1
                 .endmacro
                 
                 .macro	storeY
                 	sts	@0+1,yl
                 	sts	@0+1,yh
                 .endmacro
                 
                 .macro	loadZ
                 	lds	zl,@0
                 	lds	zh,@0+1
                 .endmacro
                 
                 .macro	storeZ
                 	sts	@0,zl
                 	sts	@0+1,zh
                 .endmacro
                 
                 
                 .macro	send
                 	ldi	temp1,@0
                 	rcall	stream_out
                 .endmacro
                 
                 
                 
                 .macro	RFcommand
                 	ldi	accH,high(@0)
                 	ldi	accL,low(@0)
                 	rcall	sendword
                 .endmacro
                 
                 
                 .macro	ext0_ON
                 	ldi	temp1,  (1<<INTF0)
                 	out	gifr, temp1		; clear any pending INT0 interrupt flag
                 	in	temp1,gimsk
                 	sb	temp1,6			; enable int
                 	out	gimsk,temp1
                 .endmacro
                 
                 .macro	ext0_OFF
                 	in	temp1,gimsk
                 	cb	temp1,6			; disable ext0 int
                 	out	gimsk,temp1
                 .endmacro
                 
                 
                 .macro	error
                 	ldi	temp1,@0
                 	sts	errorcode,temp1
                 .endmacro
                 
                 
                 
                 ;************************************************************************/
                 ;*                                                                      */
                 ;*                      Delay Macro 8 ... 65543 Cycle                   */
                 ;*                                                                      */
                 ;*              Author: Peter Dannegger                                 */
                 ;*                                                                      */
                 ;************************************************************************/
                 ;cydelay 8 ... 65543 cycle
                 .macro  cydelay
                         ldi     accl, low( @0 - 8 )
                         ldi     acch, high( @0 - 8 )
                         sbiw    accl, 4
                         brcc    pc - 1
                         cpi     accl, 0xFD
                         brcs    pc + 4
                         breq    pc + 3
                         cpi     accl, 0xFF
                         breq    pc + 1
                 .endmacro
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 ;*****************************************************************
                 ;*	file: macros.inc
                 ;*
                 ;*	Description:
                 ;*	Source file for application note AVR001 - Conditional Assembly
                 ;*	and Portability Macros.
                 ;*
                 ;*	Defines a number of macros that makes it easier to access
                 ;*	IO registers and extended IO registers (or SRAM locations up
                 ;*  to adress $FF if applicable).
                 ;*	The macros can be used to produce code that assembles to
                 ;*	any target AVR, without considering if the accessed IO
                 ;*	registers are located in low, standard or extended IO space
                 ;*
                 ;* $Revision: 2.2 $
                 ;* $Author: jllassen $
                 ;* $Date: Wednesday, January 26, 2005 10:55:18 UTC $
                 ;*****************************************************************
                 
                 ;*********************************************************
                 ;*	BIT access anywhere in IO or lower $FF of data space
                 ;*	SETB - SET Bit in IO of data space
                 ;*	CLRB - CLeaR Bit in IO of data space
                 ;*********************************************************
                 
                 .macro SETB 		;Arguments: Address, Bit, Register
                 	.if @1>7
                 		.message "Only values 0-7 allowed for Bit parameter"
                 	.endif
                 	.if @0>0x3F
                 		lds  @2, @0
                 		sbr  @2, (1<<@1)
                 		sts  @0, @2
                 	.elif @0>0x1F
                 		in   @2, @0
                 		sbr  @2, (1<<@1)
                 		out  @0, @2
                 	.else
                 		sbi  @0, @1
                 	.endif
                 .endmacro
                 
                 .macro CLRB 		;Arguments: Address, Bit, Register
                 	.if @1>7
                 		.message "Only values 0-7 allowed for Bit parameter"
                 	.endif
                 	.if @0>0x3F
                 		lds  @2, @0
                 		cbr  @2, (1<<@1)
                 		sts  @0, @2
                 	.elif @0>0x1F
                 		in   @2, @0
                 		cbr  @2, (1<<@1)
                 		out  @0, @2
                 	.else
                 		cbi  @0, @1
                 	.endif
                 .endmacro
                 
                 ;*********************************************************
                 ;*	Bit test anywhere in IO or in lower $FF of data space
                 ;*  SKBS : SKip if Bit Set
                 ;*  SKBC : SKip if Bit Cleared
                 ;*********************************************************
                 .macro SKBS  		;Arguments: Address, Bit, Register
                 	.if @1>7
                 		.message "Only values 0-7 allowed for Bit parameter"
                 	.endif
                 	.if @0>0x3F
                 		lds  @2, @0
                 		sbrs @2, @1
                 	.elif @0>0x1F
                 		in   @2, @0
                 		sbrs @2, @1
                 	.else
                 		sbis @0, @1
                 	.endif
                 .endmacro
                 
                 .macro SKBC  		;Arguments: Address, Bit, Register
                 	.if @1>7
                 		.message "Only values 0-7 allowed for Bit parameter"
                 	.endif
                 	.if @0>0x3F
                 		lds	 @2, @0
                 		sbrc @2, @1
                 	.elif @0>0x1F
                 		in	 @2, @0
                 		sbrc @2, @1
                 	.else
                 		sbic @0, @1
                 	.endif
                 .endmacro
                 
                 ;*********************************************************
                 ;*	Byte access anywhere in IO or lower $FF of data space
                 ;* 	STORE - Store register in IO or data space
                 ;* 	LOAD  - Load register from IO or data space
                 ;*********************************************************
                 
                 .macro store 		;Arguments: Address, Register
                 	.if	@0>0x3F
                 		sts	@0, @1
                 	.else
                 		out	@0, @1
                 	.endif
                 .endmacro
                 
                 .macro load 		;Arguments: Register, Address
                 	.if	@1>0x3F
                 		lds	@0, @1
                 	.else
                 		in	@0, @1
                 	.endif
                 .endmacro
                 
                 .equ	TX_node_address	= 4	; node address for TX & RX (RX not used in this app)
                 
                 
                 #define	led_on		sbi portb,5	; 
                 #define	led_off		cbi portb,5	; 
                 
                 #define SSpin		portb,3		; slave select pin for RFM12B
                 
                 ;#define	RX_enable	; builds with or without receive functionanlity
                 
                 ;==============================================================================
                 ;
                 ; ***************  Y-reg reserved for use in ext0 int routine******************
                 ;
                 ;==============================================================================
                 
                 .equ	true		= 0xff
                 .equ	false		= 0
                 
                 ; output stream destinations
                 .equ	null_stream	= 0	; nowhere
                 .equ	serial_stream	= 1	; serial out
                 .equ	memory_stream	= 2	; memory buffer
                 
                 
                 .equ	preamble 	= 0xAA	; for the receiver to lock-up to
                 .equ	syncbyte	= 0x2D	; 1st sync-byte (fixed in receiver silicon)
                 .equ	group		= 0xD4	; default group (definable in software)
                 
                 .equ	ram = 1			; used for the ldX/ldY/ldZ/ldACC macros
                 .equ	rom = 2
                 
                 ; 'state' used in ext0_int for RX
                 .equ	state0		= 0	; idle
                 .equ	state1		= 1	; error condition. RF system set to idle
                 .equ	state2		= 2	; initiated RX. On 1st RX byte, start timeout timer.
                 .equ	state3		= 3	; waiting for count
                 .equ	state4		= 4	; receiving data
                 .equ	state5		= 5	; waiting CRC
                 .equ	state6		= 6	; message complete & CRC good!
                 
                 ; state for the TX functios
                 .equ	state10		= 10	; doing TX.
                 .equ	state11		= 11	; TX complete
                 
                 
                 
                 ;==============================================================
                 ;.def	 =		r0	; 
                 ;.def	 =		r1	; 
                 .def	zero	 =	r2	; always contains zero
                 
                 ;.def	 =		r3	; -
                 ;.def	 =		r4	; -
                 ;.def	 =		r5	; -
                 ;.def	 =		r6	; - 
                 ;.def	 =		r7	; -
                 ;.def	 =		r8	; -
                 ;.def	 =		r9	; -
                 ;.def	 =		r10	; -
                 ;.def	 =		r11	; -
                 ;.def	 =		r12	; -
                 ;.def	 =		r13	; -
                 ;.def	 =		r14	; -
                 ;.def	 =		r15	; -
                 
                 .def	temp1	=	r16	; temp register
                 .def	temp2	=	r17	; temp register
                 .def	temp3	=	r18	; temp register
                 .def	state =		r19	; current 'state' for int routine
                 .def	datacount =	r20	; count of incoming/outgoing data
                 .def	headerbyte =	r21	; header info for data block (block-type)
                 .def	loopcounter =	r22	; counter for loops
                 
                 .def	bitflags =	r23	; 
                 ; .equ			= 0	; 
                 ; .equ			= 1	; 
                 ; .equ			= 2	; 
                 ; .equ			= 3	; 
                 ; .equ			= 4	; 
                 ; .equ			= 5	; 
                 ; .equ			= 6	; 
                  .equ	sleepbit	= 7	; sleep indicator
                 
                 ; r24 & 25 can be used for 16-bit operations
                 .def	accL =		r24	; 
                 .def	accH =		r25
                 
                 ;==============================================================================
                 
                 .dseg
                 ; RF system uses to show what an error was (during RX)
000060           errorcode:		.byte	1	; number representing an error type
                 
000061           stream_destination:	.byte	1	; where an output stream is sent
                 					; (null, serial, memory)
                 					; Only null or memory used here
                 
                 
                 ;=============================================================================
                 ; actual code starts here with the int-vector table
                 .cseg
                 
                 .include	"vectors_861.asm"	; int vectors. Only ext0 int used.
                 
                 
                 ; int vectors for ATTINY261/461/861
                 
                 
                 	.org	0x0000
000000 c011      	rjmp RESET ; Reset Handler
                 	.org	0x0001 
000001 c0f5      	rjmp EXT_INT0 ; IRQ0 Handler (INT from RFM12)
                 	.org	0x0002 
                 ;	rjmp PCINT ; PCINT Handler
                 	.org	0x0003 
                 ;	rjmp TIM1_COMPA ; Timer1 CompareA Handler
                 	.org	0x0004 
                 ;	rjmp TIM1_COMPB ; Timer1 CompareB Handler
                 	.org	0x0005 
                 ;	rjmp TIM1_OVF ; Timer1 Overflow Handler
                 	.org	0x0006 
                 ;	rjmp TIM0_OVF ; Timer0 Overflow Handler
                 	.org	0x0007 
                 ;	rjmp USI_START ; USI Start Handler
                 	.org	0x0008 
                 ;	rjmp USI_OVF ; USI Overflow Handler
                 	.org	0x0009 
                 ;	rjmp EE_RDY ; EEPROM Ready Handler
                 	.org	0x000A 
                 ;	rjmp ANA_COMP ; Analog Comparator Handler
                 	.org	0x000B 
                 ;	rjmp ADC ; ADC Conversion Handler
                 	.org	0x000C 
                 ;	rjmp WDT ; WDT Interrupt Handler
                 	.org	0x000D 
                 ;	rjmp EXT_INT1 ; IRQ1 Handler
                 	.org	0x000E 
                 ;	rjmp TIM0_COMPA ; Timer0 CompareA Handler
                 	.org	0x000F 
                 ;	rjmp TIM0_COMPB ; Timer0 CompareB Handler
                 	.org	0x0010 
                 ;	rjmp TIM0_CAPT ; Timer0 Capture Event Handler
                 	.org	0x0011 
                 ;	rjmp TIM1_COMPD ; Timer1 CompareD Handler
                 	.org	0x0012 
                 
                 
                 ;******************************************************************************
                 ;			reset vector
                 ;******************************************************************************
                 ; 1st thing to do is clear internal ram to zero
000012 2422      RESET:	clr	zero			; location always set to zero
                 
000013 e6e0
000014 e0f0      	ldZ	ram,SRAM_START		; point to start of ram
000015 e002      	ldi	temp1,SRAM_SIZE/256	; get pages of 256 bytes
000016 2766      	clr	loopcounter		; downcount of 256 
                 
000017 9221      wploop:	st	z+,zero			; write 0's to ram
000018 956a      	dec	loopcounter		; inner loop
000019 f7e9      	brne	wploop
00001a 950a      	dec	temp1
00001b f7d9      	brne	wploop			; outer loop
                 
                 
                 ; set up stack
00001c e002      	ldi	temp1,high(RAMEND)	; Init SP
00001d bf0e      	out	SPH,temp1
00001e e50f      	ldi	temp1,low(RAMEND)
00001f bf0d      	out	SPL,temp1
                 
                 ; select startup output stream
000020 930f
000021 e000
000022 9300 0061
000024 910f      	stream	null_stream		; set o/p stream to null (nowhere)
                 
                 ;******************************************************************************
                 ; port-A
                 ; bits are assigned as....
                 ; 0-DIN			(in)  0		; USI
                 ; 1-DOUT		(out) 1		; USI
                 ; 2-DSCK		(out) 1		; USI
                 ; 3-AREF		(in)  0		; wired to VCC with capacitor.
                 ; 4-AN3			(in)  0		; 
                 ; 5-AN4			(in)  0		; 
                 ; 6-AN5			(0ut  1		; 
                 ; 7-AN6			(out) 1		;
000025 ec06      	ldi	temp1,0b11000110
000026 bb0a      	out	DDRA,temp1
000027 e004      	ldi	temp1,0b00000100
000028 bb0b      	out	PORTA,temp1
                 
                 ;******************************************************************************
                 ;******************************************************************************
                 ; port-B
                 ; bits are assigned as....
                 ; 0-mosi		(out) 1		; mosi
                 ; 1-miso		(in)  0		; miso
                 ; 2-SCK			(out) 1		; sck
                 ; 3-SS			(out) 1		; SS
                 ; 4-1-wire		(out) 1		; 1-wire bus
                 ; 5-LED			(out) 1		; user LED
                 ; 6-int0		(in)  0		; ext int0
                 ; 7-rst pin		(in)  0		; not used as IO pin
                 
000029 e30d      	ldi	temp1,0b00111101	;
00002a bb07      	out	DDRB,temp1
00002b e008      	ldi	temp1,0b00001000
00002c bb08      	out	PORTB,temp1
00002d 98c5      	led_off
                 
                 ;******************************************************************************
                 ;	end of port setup
                 ;******************************************************************************
                 
00002e 2777      	clr	bitflags		; make sure all zero
00002f 2733      	clr	state			; idle for RFM12B state machine
                 
000030 e100      	ldi	temp1,0b00010000	; assign sleep mode = power-down
000031 bf05      	out	mcucr,temp1
                 
                 ; test if eeprom config for RFM12 exists, if not create one.
000032 d5a2      	rcall	test_config		; see if a eeprom config available
000033 f008      	brcs	yes_config
000034 d5d3      	rcall	default_config		; create if not exists
                 yes_config:
000035 d55c      	rcall	set_config		; use the config data
                 
                 ; basic inits for modules
000036 d3f0      	rcall	init_spi		; sets up SPI
000037 d0b8      	rcall	init_ext0		; sets up ext0 int type (-ve edge)
000038 9478      	sei				; global ints on
                 
000039 d2cd      	rcall	init_RFM12B		; configs RFM12, leaves in idle mode.
                 	
                 ; =============================================================================
                 ; =============================================================================
00003a d13f      main:	rcall	start_temp		; start 1-wire temp conv. Takes 2.2ms
00003b 98c5      	led_off				; activity about to stop
00003c d3c2      	rcall	enter_sleep1		; 1 sec sleep. See end of RFM12.asm
                 ; falls thru after 1 sec so now read the sensor. Timing critical so
                 ; interrupts are turned OFF during the read then back on again.
00003d 9ac5      	led_on				; indicates awake 
00003e d148      	rcall	read_result		; ints are off for about 7.4ms
                 ; Temperature data now in TX buffer
                 
00003f 9140 0064 	lds	datacount,Pcount	; save the count
000041 e7a0
000042 e0b0      	ldx	ram,TX_base		; start of TX ram block
000043 d340      	rcall	prepare_tx		; finalise packet in memory then send it
000044 d379      	rcall	wait_TXend		; wait till the ToX is completed
                 					; finished sending and RFM12 back in idle.
000045 cff4      	rjmp	main			; and back to sleep again till next time
                 
                 ; =============================================================================
                 ; =============================================================================
                 
                 
                 .include	"subs.asm"
                 
                 .cseg
                 
                 
                 ;****************************************************************
                 ; DiSPLayRom - Send a null terminated message to the output stream
                 ; This version works with
                 ; micros that don't support enhanced LPM
                 ; instructions.
                 ; Uses R0 and R16
                 ;****************************************************************
                 sendstring:
000046 91ff      	pop	ZH
000047 91ef      	pop	ZL		;move Stack Pointer to Z-register
000048 930f      	push	temp1
000049 920f      	push	r0
                 
00004a 0fee      	lsl	ZL		;shift Z-register over for
00004b 1fff      	rol	ZH		;LPM operations
00004c 95c8      DR10:	lpm	 		;byte character from rom
00004d 9631      	adiw	ZL,1		;inc Z-register
00004e 2d00      	mov	temp1,r0
00004f 3000      	cpi	temp1,0		;test for end of string
000050 f011      	breq	Rone0		;rjmp when end of string
000051 d054      	rcall	stream_out	;diSPLay data
000052 cff9      	rjmp	DR10
                 
000053 95f6      Rone0:	lsr	ZH		;restore the Stack by pointing
000054 95e7      	ror	ZL		;Z just past the rom-based string
000055 900f      	pop	r0
000056 910f      	pop	temp1
000057 93ef      	push	ZL		;then push it on the Stack so
000058 93ff      	push	ZH		;the return operation places it
000059 9508      	ret			;in the Program Counter
                 
                 
                 
                 
                 ; *****************************************************************************
                 ; DESCR: sends the low-nibble to the o/p stream (in Ascii)
                 ; ENTRY: data in temp1
                 ; EXIT: data sent
                 ; CHANGES: temp1
                 ; USES: -
                 ; *****************************************************************************
00005a 93ef      h_a:	push	ZL
00005b 93ff      	push	ZH
00005c ecec
00005d e0f0      	ldz	rom,table1
00005e 700f      	andi	temp1,0b00001111
00005f 0fe0      	add	ZL,temp1
000060 f408      	brcc	J2
000061 95f3      	inc	ZH
000062 9104      J2:	lpm	temp1,z
000063 91ff      	pop	ZH
000064 91ef      	pop	ZL
000065 9508      	ret
                 
000066 3130
000067 3332
000068 3534
000069 3736
00006a 3938
00006b 4241
00006c 4443
00006d 4645      table1:	.db	'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
                 
                 
                 
                 
                 
                 ; *****************************************************************************
                 ; DESCR: o/p's temp1 as ascii decimal to the o/p stream
                 ; ENTRY: data in temp1
                 ; EXIT: data sent
                 ; CHANGES: none
                 ; USES: h_a, stream_out
                 ; *****************************************************************************
                 decout:
00006e 936f      	push	loopcounter	; temp storage
00006f 932f      	push	temp3		; temp storage
000070 930f      	push	temp1
000071 931f      	push	temp2
                 
000072 2f10      	mov	temp2,temp1
000073 2766      	clr	loopcounter
000074 2722      	clr	temp3		;clear result (hundreds)
                 
                 bBCD8_10:
000075 5614      	subi	temp2,100	;input = input - 10
000076 f010      	brcs	bBCD8_20	;abort if carry set
000077 9523      	inc	temp3		;inc MSD
000078 cffc      	rjmp	bBCD8_10	;loop again
                 
                 bBCD8_20:			; hundreds now in temp3
000079 591c      	subi	temp2,-100	;compensate extra subtraction
                 
                 bBCD8_30:
00007a 501a      	subi	temp2,10
00007b f010      	brcs	bBCD8_40
00007c 9563      	inc	loopcounter	; tens in loopcounter
00007d cffc      	rjmp	bBCD8_30
                 
                 bBCD8_40:
00007e 5f16      	subi	temp2,-10
00007f 2f02      	mov	temp1,temp3	; output hundreds
000080 dfd9      	rcall	h_a
000081 d024      	rcall	stream_out
                 
000082 2f06      Tns:	mov	temp1,loopcounter	; output tens
000083 dfd6      	rcall	h_a
000084 d021      	rcall	stream_out
000085 2f01      unts:	mov	temp1,temp2	; output units
000086 dfd3      	rcall	h_a
000087 d01e      	rcall	stream_out
                 
000088 911f      	pop	temp2
000089 910f      	pop	temp1
00008a 912f      	pop	temp3
00008b 916f      	pop	loopcounter
00008c 9508      	ret
                 
                 
                 
                 
                 .dseg
000062           Ppointer:	.byte	2	; mem print pointer
000064           Pcount:		.byte	1	; chars printed to mem
                 .cseg
                 ; *****************************************************************************
                 ; DESCR: 'Print' a char to ram
                 ; ENTRY: char in temp1, memory pointer at Ppointer
                 ; EXIT: -
                 ; CHANGES: ram, Ppointer, Pcount
                 ; USES: -
                 ; *****************************************************************************
00008d 93af      Pmem:	push	xl
00008e 93bf      	push	xh
00008f 930f      	push	temp1
                 
000090 9100 0064 	lds	temp1,Pcount
000092 3602      	cpi	temp1,maxdata-2		; check if TX buffer full
000093 f071      	breq	nost			; if full, just exit
000094 9503      	inc	temp1
000095 9300 0064 	sts	Pcount,temp1
                 
000097 91a0 0062
000099 91b0 0063 	loadX	Ppointer
00009b 910f      	pop	temp1
00009c 930d      	st	x+,temp1
00009d 93a0 0062
00009f 93b0 0063 	storeX	Ppointer
0000a1 c001      	rjmp	nopop
0000a2 910f      nost:	pop	temp1
0000a3 91bf      nopop:	pop	xh
0000a4 91af      	pop	xl
0000a5 9508      	ret
                 
                 
                 
                 ; *****************************************************************************
                 ; DESCR: sends a char to the choosen o/p stream. (serial or memory buffer)
                 ; ENTRY: [stream_destination] loaded with stream value. 0=null, 1=serial, 2=memory
                 ; EXIT: -
                 ; CHANGES: 
                 ; USES: 
                 ; *****************************************************************************
                 stream_out:
0000a6 931f      	push	temp2
0000a7 9110 0061 	lds	temp2,stream_destination
0000a9 2311      	tst	temp2
0000aa f409      	brne	somewhere
0000ab c005      	rjmp	str_ex		; null so just exit
                 somewhere:
                 ;	jeq	temp2,serial_stream,serout	; no serial out used
0000ac 3012
0000ad f409
0000ae c001      	jeq	temp2,memory_stream,memout
0000af c001      	rjmp	str_ex
                 
                 ;serout:	rcall	sersend0
                 ;	rjmp	str_ex
                 
0000b0 dfdc      memout:	rcall	Pmem
0000b1 911f      str_ex:	pop	temp2
0000b2 9508      	ret	
                 
                 
                 
                 
                 
                 ; *****************************************************************************
                 ; DESCR: 1ms software delay
                 ; ENTRY: 
                 ; EXIT: 1ms later
                 ; CHANGES: acch:accl (r25:r24)
                 ; USES: 
                 ; *****************************************************************************
0000b3 e388
0000b4 e19f
0000b5 9704
0000b6 f7f0
0000b7 3f8d
0000b8 f018
0000b9 f011
0000ba 3f8f
0000bb f001      msone:	cydelay	8000		; 1ms at 8mhz
0000bc 9508      	ret
                 
                 
                 ; *****************************************************************************
                 ; DESCR: variable ms delay
                 ; ENTRY: ms count in temp1
                 ; EXIT: temp1-ms later
                 ; CHANGES: temp1
                 ; USES: msone
                 ; *****************************************************************************
                 delsoft:
0000bd 938f      	push	accL
0000be 939f      	push	accH
0000bf dff3      wait:	rcall	msone
0000c0 950a      	dec	temp1
0000c1 f7e9      	brne	wait
0000c2 919f      	pop	accH
0000c3 918f      	pop	accL
0000c4 9508      	ret
                 
                 
                 
                 
                 ;***** software multiply 8-bit * 8-bit from atmel app note AVR200b.asm
                 
0000c5 930f      mpy8u:	push	temp1
0000c6 931f      	push	temp2
0000c7 932f      	push	temp3
                 
0000c8 2722      	clr	temp3		;clear result High byte
0000c9 9516      	lsr	temp2		;shift multiplier
                 	
0000ca f408      	brcc	noad80		;if carry set
0000cb 0f20      	add	temp3,temp1	;add multiplicand to result High byte
0000cc 9527      noad80:	ror	temp3		;shift right result High byte 
0000cd 9517      	ror	temp2		;rotate right result L byte and multiplier
                 
0000ce f408      	brcc	noad81		;if carry set
0000cf 0f20      	add	temp3,temp1	;add multiplicand to result High byte
0000d0 9527      noad81:	ror	temp3		;shift right result High byte 
0000d1 9517      	ror	temp2		;rotate right result L byte and multiplier
                 
0000d2 f408      	brcc	noad82		;if carry set
0000d3 0f20      	add	temp3,temp1	;add multiplicand to result High byte
0000d4 9527      noad82:	ror	temp3		;shift right result High byte 
0000d5 9517      	ror	temp2		;rotate right result L byte and multiplier
                 
0000d6 f408      	brcc	noad83		;if carry set
0000d7 0f20      	add	temp3,temp1	; add multiplicand to result High byte
0000d8 9527      noad83:	ror	temp3		;shift right result High byte 
0000d9 9517      	ror	temp2		;rotate right result L byte and multiplier
                 
0000da f408      	brcc	noad84		;if carry set
0000db 0f20      	add	temp3,temp1	;add multiplicand to result High byte
0000dc 9527      noad84:	ror	temp3		;shift right result High byte 
0000dd 9517      	ror	temp2		;rotate right result L byte and multiplier
                 
0000de f408      	brcc	noad85		;if carry set
0000df 0f20      	add	temp3,temp1	;add multiplicand to result High byte
0000e0 9527      noad85:	ror	temp3		;shift right result High byte 
0000e1 9517      	ror	temp2		;rotate right result L byte and multiplier
                 
0000e2 f408      	brcc	noad86		;if carry set
0000e3 0f20      	add	temp3,temp1	;add multiplicand to result High byte
0000e4 9527      noad86:	ror	temp3		;shift right result High byte 
0000e5 9517      	ror	temp2		;rotate right result L byte and multiplier
                 
0000e6 f408      	brcc	noad87		;if carry set
0000e7 0f20      	add	temp3,temp1	;add multiplicand to result High byte
0000e8 9527      noad87:	ror	temp3		;shift right result High byte 
0000e9 9517      	ror	temp2		;rotate right result L byte and multiplier
                 
0000ea 2e01      	mov	r0,temp2	; answer copied to r0/r1 as per hardware mult
0000eb 2e12      	mov	r1,temp3
                 
0000ec 912f      	pop	temp3
0000ed 911f      	pop	temp2
0000ee 910f      	pop	temp1
0000ef 9508      	ret
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 .include	"ext0.asm"
                 
                 ;==============================================================================
                 ;
                 ; ***************  Y-reg reserved for use in ext0 int routine  ****************
                 ;
                 ;==============================================================================
                 
                 ; the initialise routine only sets up for  -ve edge trigger.
                 init_ext0:
0000f0 e400      	ldi	temp1,0b01000000	; bit to clear any pending ext0 int
0000f1 bf0a      	out	gifr, temp1		; 
                 
0000f2 b705      	in	temp1,mcucr
0000f3 7f0c      	andi	temp1,0b11111100
0000f4 6002      	ori	temp1,0b00000010	; falling edge on int0 & 1
0000f5 bf05      	out	mcucr,temp1
0000f6 9508      	ret
                 
                 
                 
                 
                 ; The interrupt oroutine works by jumping to the section dictated to by the value
                 ; of a variable called 'state'.
                 ; The receive software is broken into more states than the transmit. Receive data
                 ; is checked byte by byte (almost) as it arrives and the local checksum assembled so
                 ; by the time the received checksum arrives, it can be checked immidiately
                 ; Transmit is simpler in the interrupt sense. The complete message is built and
                 ; the checksum calculated as a foreground task, the interrupt routine (once triggered
                 ; for transmit) simply feeds the data into the transmitter register.
                 
                 ; external int-0 routine
                 EXT_INT0:
0000f7 fd77      	sbrc	bitflags,7	; test if just woken from power-down mode
0000f8 c070      	rjmp	wakeup
                 
0000f9 930f      	push	temp1		; save reg and status
0000fa b70f      	load	temp1,SREG
0000fb 930f      	push	temp1
0000fc 931f      	push	temp2
0000fd 932f      	push	temp3
0000fe 938f      	push	accL
0000ff 939f      	push	accH
                 
                 ; first, check if TX'ing and go straight there if appropriate
000100 303a
000101 f409
000102 c054      	jeq	state,state10,TX10
                 
                 
                 ; so must be in RX mode. Read the RFM12B
                 RXstuff:
000103 d271      	rcall	RFMread		; combined status & fifo read (if data is available)
000104 f008      	brcs	got		; C=got data in temp1
000105 c017      	rjmp	I0exit		; NC=no data
                 
                 ; data byte in temp1
000106 9309      got:	st	y+,temp1	; save in ram
000107 3035      	cpi	state,state5	; see if receiving CRC bytes so dont add into CRC
000108 f409      	brne	gotC
000109 c037      	rjmp	rxD		; skip fwd so dont add RX'ed CRC bytes into local CRC
                 
00010a d353      gotC:	rcall	addtoCRC
                 
00010b 3034
00010c f409
00010d c02d      	jeq	state,4,rxC	; receiving data
00010e 3033
00010f f409
000110 c01d      	jeq	state,3,rxB	; receiving data
000111 3032
000112 f409
000113 c018      	jeq	state,2,rxA	; initiated RX. On 1st RX byte, start timeout timer.
000114 3031
000115 f409
000116 c00e      	jeq	state,1,er	; error state. stop int and exit
000117 3030
000118 f409
000119 c00b      	jeq	state,0,idle	; nothing in progress. Stop int and exit
00011a e001
00011b 9300 0060 	error	1
                 
                 ; falls thru to exit
                 I0exit:
00011d 919f      	pop	accH
00011e 918f      	pop	accL
00011f 912f      	pop	temp3
000120 911f      	pop	temp2
000121 910f      	pop	temp1
000122 bf0f      	store	SREG,temp1
000123 910f      	pop	temp1
000124 9518      	reti
                 
                 er:
                 idle:
                 finished:
000125 b70b
000126 7b0f
000127 bf0b      	ext0_OFF		; turn off int
000128 e892
000129 e589
00012a d22d      	RFcommand RF_IDLE_MODE	; xtal on, (RX, TX, low-bat detect, clk out) all off
00012b cff1      	rjmp	I0exit
                 
                 ;==============================================================================
                 ;The 1st byte to activate the RX interrupt routine is the HEADER byte. (RFM12B.asm
                 ;for packet structure) .The system is using TWO sync-bytes to trigger the
                 ;fifo fill. The 1st sync byte is fixed in the silicon of the RFM12B.
                 ;The 2nd sync-byte is being uses as the GROUP byte. It can be changed in software.
                 ;Reception of the GROUP byte is implied since the only way the FIFO fill would
                 ;be triggered is by receiving both sync-bytes in sequence.
                 ;The GROUP byte is include in the CRC. The begin_RX routine adds it to the CRC
                 ;So, 1st byte is the HEADER, 2nd is payload (data) length, 3rd is payload
                 ;
                 ;==============================================================================
                 ; State2
                 ; 1st received byte of a block gets us here. HEADER byte.
                 rxA:
00012c e033      	ldi	state,state3	; change state to show rx in progress
00012d cfef      	rjmp	I0exit		; exit
                 
                 ;******************************************************************************
                 ; state3
                 ; now looking for data (payload) count
                 rxB:
                 ; this should be the actual payload count. It is from 0 to maxdata
00012e 2f40      	mov	datacount,temp1	; save here also
00012f 3000
000130 f409
000131 c00b      	jeq	temp1,0,Zdata	; if zero length, skip to state5 (CRC)
000132 3605      	cpi	temp1,maxdata+1
000133 f410      	brsh	YY		; bad length
                 ; count good so continue
000134 e034      	ldi	state,state4	; for data receive
000135 cfe7      	rjmp	I0exit
                 
000136 e001
000137 9300 0060 YY:	error	1		; bad length byte
000139 e031      XY:	ldi	state,state1	; set error state
00013a cfea      	rjmp	finished	; stop int and exit
                 
                 
                 
                 ;******************************************************************************
                 ; state4
                 ; the actual payload gets received here (if any). state4 Skipped if no payload
00013b 954a      rxC:	dec	datacount
00013c f701      	brne	I0exit
                 ; payload finished, change state so next time get CRC bytes
00013d e035      Zdata:	ldi	state,state5	; data completed
00013e e002      	ldi	temp1,2		; for 2 CRC bytes reception
00013f 2f40      	mov	datacount,temp1
000140 cfdc      	rjmp	I0exit
                 
                 ;******************************************************************************
                 ; state5
                 ; this should be the CRC bytes
000141 954a      rxD:	dec	datacount
000142 f6d1      	brne	I0exit		; on 1st CRC byte, just exit
                 
                 ; after 2nd byte, falls through to the CRC testing
                 ; now both CRC bytes received. High byte is still in temp1
000143 9120 00f1 	lds	temp3,crc_high
000145 1702      	cp	temp1,temp3
000146 f459      	brne	bad
000147 910a      	ld	temp1,-y	; Y is now pointing AFTER the CRC so -1 (now at MSB)
000148 910a      	ld	temp1,-y	; back again to point at LSB
000149 9120 00f0 	lds	temp3,crc_low
00014b 1702      	cp	temp1,temp3
00014c f429      	brne	bad
00014d e036      	ldi	state,state6	; complete packet tested and good
00014e e000
00014f 9300 0060 	error	0		; no errors
000151 cfd3      	rjmp	finished	; turn OFF int and exit
                 
000152 e002
000153 9300 0060 bad:	error	2		; bad checksum
000155 e031      	ldi	state,state1	; error
000156 cfce      	rjmp	finished	; exits with error
                 
                 
                 
                 
                 ;******************************************************************************
                 ;******************************************************************************
                 ; state 10
                 ; TX interrupt section
                 ; just straight TX from ram. The complete message (with checksums) has been constructed
                 ; in ram before the transmission process is started
000157 9109      TX10:	ld	temp1,y+		; get data to TX
000158 d2d4      	rcall	spi_send		; SS is stil low (see intTXdata routine)
                 
000159 9100 0070 	lds	temp1,TX_txcount	; adjust TX downcount
00015b 950a      	dec	temp1
00015c 9300 0070 	sts	TX_txcount,temp1
                 
00015e f009      	breq	TXdun			; if all sent, jump
00015f cfbd      	rjmp	I0exit			; else exit till next byte to TX
                 
                 
                 ; the last byte is a dummy one, just to give enough time for the bytes in
                 ; the TX buffers to be sent before turning-off the transmitter
                 TXdun:
000160 b70b
000161 7b0f
000162 bf0b      	ext0_OFF		; switch off int
                 ; RFM12B into idle mode
000163 e892
000164 e589
000165 d1f2      	RFcommand RF_IDLE_MODE	; RX,TX OFF
                 
000166 e03b      	ldi	state,state11	; show done
000167 9ac3      	sbi	SSpin		; finish the write to the TX buffers
000168 cfb4      	rjmp	I0exit		; and exit
                 
                 
                 ; here on wake-up from power-down.
                 wakeup:
000169 930f      	push	temp1
00016a b70f      	in	temp1,sreg
00016b 930f      	push	temp1
                 
00016c b70b      	in	temp1,gimsk
00016d 7b0f      	andi	temp1,0b10111111	; turn off ext0 int
00016e bf0b      	out	gimsk,temp1
                 
00016f 777f      	cb	bitflags,7		; clear indicator bit
                 
000170 b705      	in	temp1,mcucr
000171 7d0c      	andi	temp1,0b11011100	; clear sleep bit and int types
000172 6002      	ori	temp1,0b00000010	; set falling edge on int0 & 1
000173 bf05      	out	mcucr,temp1		; sleep off, falling edge for ext0
                 
000174 e400      	ldi	temp1,0b01000000	; bit to clear any pending ext0 int
000175 bf0a      	out	gifr, temp1		; clear any pending INT0 interrupt flag
                 
000176 910f      	pop	temp1
000177 bf0f      	out	sreg,temp1
000178 910f      	pop	temp1
                 
000179 9518      	reti
                 
                 
                 	
                 
                 .include	"1wire_28-06-10.asm"
                 
                 
                 #define		oneW_port	portb		; port for 1-wire
                 #define		oneW_pin	PINB		; pin reg
                 #define		oneW_dir	DDRB		; direction
                 .equ	databit		= 4			; bit 4
                 
                 ; pick one of the types below
                 	#define		DS18B20		; high res, 12-bit temp
                 ;	#define		DS18S20		; low res, 9-bit temp
                 
                 
                 .dseg
                 
000065           tempdata:	.byte	10	; where to store
                 
00006f           ticker:		.byte	1
                 
                 .CSEG
                 
                 ; *****************************************************************************
                 ; DESCR: resets the sensor and initiates a temp reading
                 ; ENTRY: 
                 ; EXIT: 
                 ; CHANGES: 
                 ; USES: 
                 ; *****************************************************************************
                 start_temp:
00017a 9ac3      	sbi	SSpin				; make sure RFM12 deselected
                 
00017b 94f8      	cli					; stop ALL interrupts
                 
00017c 9ac4      	sbi	oneW_port,databit		; make sure port pins in
00017d 9abc      	sbi	oneW_dir,databit		; correct state to start
                 
                 ; set up to read data into ram
00017e d0ac      	rcall	onewire_reset			; about 1ms , idealy 960uSec.
                 
                 ;====================================================================
00017f ec0c      	ldi	temp1,0xcc	; skip rom	; this section takes
000180 d052      	rcall	send_byte_1820			; about 1.2ms
                 						; 
000181 e404      	ldi	temp1,0x44 ; do temp conv	; 
000182 d050      	rcall	send_byte_1820			; 
                 ;====================================================================
000183 9abc      	sbi	oneW_dir,databit		; make back to an output
000184 98c4      	cbi	oneW_port,databit		; make sure port pin low
                 
000185 9478      	sei					; restart ints
000186 9508      	ret
                 
                 
                 
                 
                 ;====================================================================
                 read_result:				;			/\
000187 94f8      	cli				;			|
                 					;			|
000188 9abc      	sbi	oneW_dir,databit	; make an o/p again	|
000189 98c4      	cbi	oneW_port,databit	; make sure port pins in|
                 					;			|
00018a d0a0      	rcall	onewire_reset		; all this section	|
                 					; takes about 7.4ms	|
00018b ec0c      	ldi	temp1,0xcc		; skip rom cmd		|
00018c d046      	rcall	send_byte_1820		;			|
                 					;			|
00018d eb0e      	ldi	temp1,0xbe		; read scratchpad	|
00018e d044      	rcall	send_byte_1820		;			|
                 					;			|
00018f e6e5
000190 e0f0      	ldZ	ram,tempdata		;			|
000191 e069      	ldi	loopcounter,9		; 8 data bytes + CRC	|
                 					;			|
                 readloop:				;			|
000192 d03a      	rcall	inbyte_1820		; get device code	|
000193 9301      	st	z+,temp1		;			|
000194 956a      	dec	loopcounter		;			|
000195 f7e1      	brne	readloop		;			|
                 					;			\/	
                 ;===================================================================
000196 9abc      	sbi	oneW_dir,databit	; make an o/p again
000197 98c4      	cbi	oneW_port,databit	; make sure pin low
000198 9478      	sei				; re-enable ints
                 
                 ; the 'ticker' is to o/p a char that alternates between two chars on successive reads
                 ; This is to let you see something is happening if the temperature display appears
                 ; to be static. It might just be at the same value but the ticker lets you know its
                 ; a live reading.
000199 9100 006f 	lds	temp1,ticker
00019b 9503      	inc	temp1
00019c 7001      	andi	temp1,1
00019d 9300 006f 	sts	ticker,temp1
                 
                 ; now prep the items for the RFM12 TX buffer prior to initiating a TX of the data
00019f 9100 00e3 	lds	temp1,config_node_address	; THIS nodes address
0001a1 9300 0079 	sts	TX_sourcenode,temp1	; as source of data
                 
0001a3 9100 00e7 	lds	temp1,config_node_dest	; destination addr
0001a5 9300 007a 	sts	TX_destnode,temp1	; where to send to
                 
0001a7 e05e      	ldi	headerbyte,temppack	; packet type
                 
0001a8 e7ab
0001a9 e0b0      	ldx	ram,TX_data_buffer+2	; where to 'print' to ram (see RFM12.asm)
0001aa 93a0 0062
0001ac 93b0 0063 	storeX	Ppointer		; save pointer
0001ae e002      	ldi	temp1,2			; for 1st 2 bytes (source/dest)
0001af 9300 0064 	sts	Pcount,temp1		; preload the count
                 
0001b1 930f
0001b2 e002
0001b3 9300 0061
0001b5 910f      	stream	memory_stream		; set o/p stream        |
                 
0001b6 e6a5
0001b7 e0b0      	ldX	ram,tempdata		; point to data read from 1-wire sensor
0001b8 e068      	ldi	loopcounter,8		; byte count
0001b9 d099      	rcall	crc8			; calculate CRC of data, returns value in temp2
                 
0001ba 910c      	ld	temp1,x			; gets received CRC value
0001bb 1701      	cp	temp1,temp2		; compare to localy generated one
0001bc f409      	brne	badCRC			; if not equal, error
0001bd c007      	rjmp	showtem
                 
                 badCRC:
0001be de87
0001bf 6142
0001c0 2064
0001c1 5243
0001c2 2043
\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\macros.inc(43): warning: .cseg .db misalignment - padding zero byte
\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\1wire_28-06-10.asm(119): macro 'stringout' called here
\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\main.asm(221): '\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\1wire_28-06-10.asm' included form here
0001c3 0000      	stringout "Bad CRC "		; print error message
0001c4 c001      	rjmp	tg1			; then jump to ticker
                 
                 showtem:
0001c5 d09f      	rcall	showtemp		; all good so print temp
                 
0001c6 d131      tg1:	rcall	do_ticker		; print ticker
                 
0001c7 930f
0001c8 e000
0001c9 9300 0061
0001cb 910f      tmpex:	stream	null_stream		; o/p stream set to nowhere
                 
0001cc 9508      	ret
                 
                 
                 
                 ;**********************************************
                 ;****************** DS18S20 Assembly routines *
                 ;****************** atmega 8Mhz portd bit0 *
                 ;***********************************************
                 
                 inbyte_1820:
0001cd e017      	ldi	temp2,0x07
                 inbyte_loop:
0001ce d00f      	rcall	master_read_slot
0001cf 951a      	dec	temp2
0001d0 3f1f      	cpi	temp2,0xff
0001d1 f7e1      	brne	inbyte_loop
0001d2 9508      	ret
                 
                 
                 send_byte_1820:
0001d3 e017      	ldi	temp2,0x07
                 send_byte_loop:
0001d4 9507      	ror	temp1
0001d5 f008      	brcs	send_one
0001d6 f410      	brcc	send_zero
                 
                 
                 send_one:
0001d7 d029      	rcall	Master_write_1_slot
0001d8 c001      	rjmp	exit_send_byte
                 
                 
                 send_zero:
0001d9 d03c      	rcall	Master_write_0_slot
                 exit_send_byte:
0001da 951a      	dec	temp2
0001db 3f1f      	cpi	temp2,0xff
0001dc f7b9      	brne	send_byte_loop
0001dd 9508      	ret
                 
                 
                 
                 Master_read_slot:
0001de 98c4      	cbi	oneW_port,databit
                 
0001df e286
0001e0 e090
0001e1 9704
0001e2 f7f0
0001e3 3f8d
0001e4 f018
0001e5 f011
0001e6 3f8f
0001e7 f001      	cydelay 46
                 
0001e8 9ac4      	sbi	oneW_port,databit
                 
0001e9 e38e
0001ea e090
0001eb 9704
0001ec f7f0
0001ed 3f8d
0001ee f018
0001ef f011
0001f0 3f8f
0001f1 f001      	cydelay 70
                 
0001f2 9488      	clc				; clear carry
0001f3 9bb4      	sbis	oneW_pin,databit	; check pin value
0001f4 c001      	rjmp	Master_read_slot_exit
0001f5 9408      	sec				; set carry
                 
                 Master_read_slot_exit:
0001f6 9507      	ror	temp1			; push carry into byte
                 
0001f7 ea8c
0001f8 e091
0001f9 9704
0001fa f7f0
0001fb 3f8d
0001fc f018
0001fd f011
0001fe 3f8f
0001ff f001      	cydelay 436
                 
000200 9508      	ret
                 
                 Master_write_1_slot:
000201 98c4      	cbi	oneW_port,databit
                 
000202 e286
000203 e090
000204 9704
000205 f7f0
000206 3f8d
000207 f018
000208 f011
000209 3f8f
00020a f001      	cydelay 46
                 
00020b 9ac4      	sbi	oneW_port,databit
                 
00020c ef82
00020d e091
00020e 9704
00020f f7f0
000210 3f8d
000211 f018
000212 f011
000213 3f8f
000214 f001      	cydelay	506
                 
000215 9508      	ret
                 
                 
                 Master_write_0_slot:
000216 98c4      	cbi	oneW_port,databit
                 
000217 ed84
000218 e091
000219 9704
00021a f7f0
00021b 3f8d
00021c f018
00021d f011
00021e 3f8f
00021f f001      	cydelay 476
                 
000220 9ac4      	sbi	oneW_port,databit
                 
000221 e486
000222 e090
000223 9704
000224 f7f0
000225 3f8d
000226 f018
000227 f011
000228 3f8f
000229 f001      	cydelay 78
                 
00022a 9508      	ret
                 
                 
                 ; returns C=no device, NC=device
                 onewire_reset:
00022b 9abc      	sbi	oneW_dir,databit		; 2 change pin to o/p
00022c 98c4      	cbi	oneW_port,databit		; 2 pull bus low
                 
00022d ef88
00022e e09e
00022f 9704
000230 f7f0
000231 3f8d
000232 f018
000233 f011
000234 3f8f
000235 f001      	cydelay 3840
                 
000236 9ac4      	sbi	oneW_port,databit		; 2 drive high
000237 98bc      	cbi	oneW_dir,databit		; 2 change pin to i/p (pullup is on)
                 
                 
000238 e288
000239 e092
00023a 9704
00023b f7f0
00023c 3f8d
00023d f018
00023e f011
00023f 3f8f
000240 f001      	cydelay	560
                 
000241 9488      	clc			; 1
000242 99b4      	sbic	oneW_pin,databit; 2
000243 9408      	sec			; 1
                 
000244 b70f      	in	temp1,sreg	; 1
000245 930f      	push	temp1
                 
000246 ec88
000247 e09c
000248 9704
000249 f7f0
00024a 3f8d
00024b f018
00024c f011
00024d 3f8f
00024e f001      	cydelay	3280
                 
00024f 910f      	pop	temp1		; 2
000250 bf0f      	out	sreg,temp1	; 1
000251 9abc      	sbi	oneW_dir,databit; 2 change pin to o/p
000252 9508      	ret
                 
                 
                 ;Library subroutine CRC8
                 ;Calculates CRC-8 of a string
                 ;runs on any Atmel AVR microcontroller that has SRAM stack
                 ;(result matches Dallas Semiconductor's One-Wire [DOW] CRC8 algorithm)
                 ;(use this subroutine to check the CRC8 on serial numbers from Dallas iButtons)
                 ;
                 ;written by  E. Nicholas Cupery  Farba Research  29 April 2000
                 ;
                 ;on input:
                 ;     X register must point to the string in SRAM
                 ;     loopcounter register must hold the byte-count of the string  [0 means 256]
                 ;on exit:
                 ;     temp2 holds the CRC-8 result
                 ;     all other registers are preserved
                 ;     c-bit is indeterminate
                 ;
                 CRC8:
000253 938f      	push	accL		;save accL
000254 2711      	clr	temp2		;start with a zero CRC-8
                 
                 
                 	;begin loop to do each byte in the string
                 CRC8BYT:
000255 912d      	ld	temp3,X+	;fetch next string byte and bump pointer
000256 e088      	ldi	accL,8		;load the bit-counter for this byte
                 
                 	;begin loop to do each bit in the byte
                 CRC8BIT:
000257 2f02      	mov	temp1,temp3	;get a temporary copy of current data
000258 2701      	eor	temp1,temp2	;XOR the data byte with the current CRC
000259 9516      	lsr	temp2		;position to the new CRC
00025a 9526      	lsr	temp3		;position to next bit of this byte	
00025b 9506      	lsr	temp1		;get low bit of old result into c-bit
00025c f410      	brcc	CRC8NA		;br if low bit was clear (no adjustment)
00025d e80c      	ldi	temp1,$8C	;magical value needed for CRC-8s
00025e 2710      	eor	temp2,temp1	;fold in the magic CRC8 value
00025f 958a      CRC8NA:	dec	accL		;count the previous bit done
000260 f7b1      	brne	CRC8BIT		;br if not done all bits in this byte
                 	;end loop to do each bit in the byte
                 
000261 956a      	dec	loopcounter	;count this byte done
000262 f791      	brne	CRC8BYT		;br if not done all bytes in the string
                 	;end loop to do each byte in the string
                 
                 
000263 918f              pop	accL		;restore accL
000264 9508      	ret			;return to caller
                 
                 
                 
                 
                 
                 
                 	#ifdef	DS18B20
                 ; =====================================================
                 
                 showtemp:
000265 e6e5
000266 e0f0      	ldZ	ram,tempdata
                 
000267 9111      	ld	temp2,z+	; low byte
000268 9101      	ld	temp1,z+	; high byte
                 ; check if + or -
000269 ff07      	sbrs	temp1,7		; skip jump if NEG
00026a c00b      	rjmp	pos
                 
00026b e20d
00026c de39      	send	'-'		; display for negetive temp
                 
00026d 9500      	com	temp1		; invert value
00026e 9510      	com	temp2
00026f 936f      	push	loopcounter
000270 e061      	ldi	loopcounter,1
000271 0f16      	add	temp2,loopcounter
000272 2766      	clr	loopcounter
000273 1f06      	adc	temp1,loopcounter
000274 916f      	pop	loopcounter
000275 c004      	rjmp	st1
                 
                 
000276 930f      pos:	push	temp1
000277 e20b
000278 de2d      	send	'+'
000279 910f      	pop	temp1
                 
00027a 0f11      st1:	lsl	temp2
00027b 1f00      	rol	temp1
                 
00027c 0f11      	lsl	temp2
00027d 1f00      	rol	temp1
                 
00027e 0f11      	lsl	temp2
00027f 1f00      	rol	temp1
                 
000280 0f11      	lsl	temp2
000281 1f00      	rol	temp1
                 
000282 9512      	swap	temp2
000283 ddea      	rcall	decout
000284 e20e      	ldi	temp1,'.'
000285 de20      	rcall	stream_out
000286 2f01      	mov	temp1,temp2
000287 d003      	rcall	showLDP
000288 e200
000289 de1c      	send	' '
00028a 9508      	ret
                 
                 
                 showLDP:
00028b 9488      	clc
00028c 1f00      	rol	temp1		; mul by 2 for table of words
                 
00028d 2711      	clr	temp2
00028e e3e0
00028f e0f5      	ldZ	rom,Ttable
000290 0fe0      	add	zl,temp1
000291 1ff1      	adc	zh,temp2
000292 9005      	lpm	r0,z+
000293 920f      	push	r0
000294 9004      	lpm	r0,z
000295 2df0      	mov	zh,r0
000296 91ef      	pop	zl
000297 9409      	ijmp			; jumps to address from table
                 
                 
                 
000298 02a8
000299 02ad
00029a 02b2
00029b 02b7
00029c 02bc
00029d 02c1
00029e 02c6
00029f 02cb
0002a0 02d0
0002a1 02d5
0002a2 02da
0002a3 02df
0002a4 02e4
0002a5 02e9
0002a6 02ee
0002a7 02f3      Ttable:	.dw	tp0,tp1,tp2,tp3,tp4,tp5,tp6,tp7,tp8,tp9,tp10,tp11,tp12,tp13,tp14,tp15
                 
0002a8 e300
0002a9 ddfc      tp0:	send	'0'	;	"00"		;25"	 The last two decimal places are removed
0002aa e300
0002ab ddfa      	send	'0'	;
0002ac 9508      	ret					; as not required in my application
0002ad e300
0002ae ddf7      tp1:	send	'0'
0002af e306
0002b0 ddf5      	send	'6'
0002b1 9508      	ret
0002b2 e301
0002b3 ddf2      tp2:	send	'1'
0002b4 e302
0002b5 ddf0      	send	'2'
0002b6 9508      	ret
0002b7 e301
0002b8 dded      tp3:	send	'1'
0002b9 e308
0002ba ddeb      	send	'8'
0002bb 9508      	ret
0002bc e302
0002bd dde8      tp4:	send	'2'
0002be e305
0002bf dde6      	send	'5'
0002c0 9508      	ret
0002c1 e303
0002c2 dde3      tp5:	send	'3'
0002c3 e301
0002c4 dde1      	send	'1'
0002c5 9508      	ret
0002c6 e303
0002c7 ddde      tp6:	send	'3'
0002c8 e307
0002c9 dddc      	send	'7'
0002ca 9508      	ret
0002cb e304
0002cc ddd9      tp7:	send	'4'
0002cd e303
0002ce ddd7      	send	'3'
0002cf 9508      	ret
0002d0 e305
0002d1 ddd4      tp8:	send	'5'
0002d2 e300
0002d3 ddd2      	send	'0'
0002d4 9508      	ret
0002d5 e305
0002d6 ddcf      tp9:	send	'5'
0002d7 e306
0002d8 ddcd      	send	'6'
0002d9 9508      	ret
0002da e306
0002db ddca      tp10:	send	'6'
0002dc e302
0002dd ddc8      	send	'2'
0002de 9508      	ret
0002df e306
0002e0 ddc5      tp11:	send	'6'
0002e1 e308
0002e2 ddc3      	send	'8'
0002e3 9508      	ret
0002e4 e307
0002e5 ddc0      tp12:	send	'7'
0002e6 e305
0002e7 ddbe      	send	'5'
0002e8 9508      	ret
0002e9 e308
0002ea ddbb      tp13:	send	'8'
0002eb e301
0002ec ddb9      	send	'1'
0002ed 9508      	ret
0002ee e308
0002ef ddb6      tp14:	send	'8'
0002f0 e307
0002f1 ddb4      	send	'7'
0002f2 9508      	ret
0002f3 e309
0002f4 ddb1      tp15:	send	'9'
0002f5 e303
0002f6 ddaf      	send	'3'
0002f7 9508      	ret
                 
                 
                 ; ===================================================
                 	#elif	DS18S20
                 	#endif
                 
                 
                 do_ticker:
0002f8 9100 006f 	lds	temp1,ticker
0002fa 3000
0002fb f409
0002fc c004      	jeq	temp1,0,pat1
0002fd 3001
0002fe f409
0002ff c004      	jeq	temp1,1,pat2
000300 9508      	ret
                 
000301 e203      pat1:	ldi	temp1,'#'
000302 dda3      	rcall	stream_out
000303 c002      	rjmp	tikend
                 
000304 e20a      pat2:	ldi	temp1,'*'
000305 dda0      	rcall	stream_out
                 	
                 
                 tikend:
000306 9508      	ret
                 
                 .include	"RFM12B.asm"
                 
                 ;433 1/4 wave = 164.7mm
                 ;433 1/2 wave = 329.4mm
                 ;433 full wave = 692.7mm
                 ;868 1/4 wave = 82.2mm
                 ;868 1/2 wave = 164.3mm
                 ;868 full wave = 345.5mm
                 ;915 1/4 wave = 77.9mm
                 ;915 1/2 wave = 155.9mm
                 ;915 full wave = 327.8mm
                 
                 ;=====================================================================
                 ;STATUS BITS. HIGH BYTE 1ST
                 ;
                 ;bit15-	RGIT (TX register is ready to receive the next byte) or..
                 ;	FFIT (RX mode. Bits in the RX FIFO reached the programmed limit)
                 ;bit14-	POR (Power-on reset)
                 ;bit13-	RGUR (TX reg under run, reg over write) or..
                 ;	FFOV (RX FIFO overflow)
                 ;bit12-	WKUP (Wake-up timer overflow)
                 ;bit11-	EXT (Logic level on interrupt pin)
                 ;bit10-	LBD (Low battery detect, voltage is below the programmed limit)
                 ;bit9-	FFEM (FIFO is empty)
                 ;BIT8-	ATS (detected strong enough RF signal) when enable receiver (er) is OFF OR...
                 ;	RSSI (strength of the incoming signal is above programmed limit) with (er) ON
                 
                 ;bit7-	DQD (Data quality detector output)
                 ;bit6-	CRL (Clock recovery locked)
                 ;bit5-	ATGL (Toggling in each AFC cycle)
                 ;bit4-	OFFS-6 (MSB of the measured frequency offset (sign of the offset value))
                 ;bits 3..0 OFFS(3..0)  Offset value to be added to the value of the frequency-
                 ;	  control parameter (Four LSB bits)
                 ;Note: In order to get accurate values the AFC has to be disabled during the
                 ;read by clearing the "en" bit in the AFC Control Command (bit 0).
                 
                 
                 .equ	RF_RX_ON	= 0x8281	; RX on, low-bat detect off, no clk out
                 .equ	RF_TX_ON	= 0x8229	; TX on, low-bat detect off, no clk out
                 .equ	RF_IDLE_MODE    = 0x8259	; xtal on, RX & TX all off low-bat detect off, no clk out
                 .equ	RF_WAKEUP_MODE  = 0x8203	; xtal, RX, TX, low-bat, clk out all off, wakeup ON
                 
                 .equ	RF_TIMER_4ms    = 0xE102	; WAKE-UP timer set for 4-ms
                 .equ	RF_TIMER_1      = 0xE38c	; WAKE-UP timer set for 1-sec
                 .equ	RF_TIMER_4      = 0xE58C	; WAKE-UP timer set for 4-sec
                 .equ	RF_TIMER_59     = 0xE97f	; WAKE-UP timer set for 59-sec
                 .equ	RF_TIMER_1m     = 0xE982	; WAKE-UP timer set for 1-min
                 .equ	RF_TIMER_2m     = 0xEa82	; WAKE-UP timer set for 2-min
                 
                 .equ	RF_SLEEP_MODE   = 0x8203	; xtal, RX, TX all off low-bat off, no clk out
                 
                 
                 .equ	maxdata		= 100		; maximum data packet size.
                 
                 ; now header-byte values
                 
                 .equ	cmdpack		= 0	; command mode packet. terminal mode to a remote node
                 ; a command response from the 'remote' node has bit-7 set ie cmdpack+0x80
                 
                 .equ	beaconpack	= 1	; beacon packet. Just to indicate existance
                 .equ	fwdpack		= 2	; for forwarding. to reach indirect destination
                 .equ	timepack	= 3	; time packet. from hub or node to node
                 .equ	datapack	= 4	; 'normal' data packet. Whatever
                 .equ	ackpack		= 6	; acknowlege packet.
                 .equ	configpack	= 7	; to remotely configure a node
                 .equ	digipack	= 8	; read/set digital I/O
                 .equ	ananpack	= 9	; read/set analog I/O
                 .equ	pinpack		= 10	; combination of 8 & 9
                 .equ	pwmpack		= 11	; read/sets PWM output
                 .equ	pingpack	= 12	; 'are you there' packet
                 .equ	connectpack	= 13	; request 'command connection'
                 .equ	temppack	= 14	; temperature reading
                 .equ	lightpack	= 15	; turn light on/off
                 .equ	meterpack	= 16	; water meter / electric meter
                 
                 .equ	nakpack		= 21	; NAK response
                 
                 
                 ;************************ -------------------------- **************************
                 ;*********************** configuration data in eeprom *************************
                 ;************************ -------------------------- **************************
                 .eseg
                 config_start:
                 
000000           node_address:		.byte	1	; this nodes address
000001           node_group:		.byte	1	; this nodes group
000002           node_channel:		.byte	1	; this nodes channel (frequency)
000003           node_rate:		.byte	1	; over the link data rate
000004           node_retries:		.byte	1	; how many send attempts
000005           node_beacon:		.byte	1	; 0=off, otherwise frequency in minuits
000006           node_dest:		.byte	1	; default send (destination) address
000007           node_e:			.byte	1	; not used yet...
000008           node_f:			.byte	1	; not used yet...
000009           node_g:			.byte	1	; not used yet...
00000a           node_h:			.byte	1	; not used yet...
00000b           node_i:			.byte	1	; not used yet...
00000c           node_j:			.byte	1	; not used yet...
                 
                 config_end:
                 
00000d           config_data_crc_low:	.byte	1	; crcL of config data
00000e           config_data_crc_high:	.byte	1	; high byte
                 ;******************************************************************************
                 
                 
                 
                 ; *****************************************************************************
                 ; ************************* TX block format ***********************************
                 ; *****************************************************************************
                 ; 0xAA	3-bytes is the preamble for the receiver RF stage to lock onto (0xAA,0xAA,0xAA)
                 ; 0x2D	1-byte sync-byte (built into the silicon of the receiver for "fill fifo on sync-byte/s"
                 ; 0xD4	1-byte sync-byte.(groupbyte) This is changeable and can be used as a 'group select'
                 ; XX	1-byte header. (headerbyte) Defines packet type.
                 ; XX	1-byte Length of payload (DATA) block length.
                 ; XX...	data payload. The 1st 2 bytes of payload are normaly source/dest addresses.
                 ; XX	2-bytes CRC16, little-endian (LS-byte is 1st in stream, then MS-byte) X-modem CRC16
                 ; XX	2-bytes post-amble (0xAA, 0xAA). These bytes are fed into the TX stream but because
                 ; there is a 2-byte TX buffer they only serve to enable the CRC bytes to actualy
                 ; get transmitted. After the last CRC byte, the 1st of the post-amble bytes is about
                 ; to be shifted out into the TX stage. One of the post-amble bytes is sent then
                 ; the transmitter is switched off. Switching off before this byte causes (on my
                 ; desktop testing) about a 2.5% error with the last bit transmitted.
                 ; Once I started to send (actualy transmit) ONE postamble byte these errors stopped.
                 
                 ;------------------------------------------------------------------------------
                 	.dseg
                 ;************************ -------------------------- **************************
                 ;************************ transmitter message buffer **************************
                 ;************************ -------------------------- **************************
                 
                 TX_base:
000070           TX_txcount:		.byte	1	; byte-downcount as being sent by int routine
000071           TX_total_length:	.byte	1	; calculated before 1st transmission. TX_datasize+12
                 ;TX_datasize+(3xpreamble)+(2xpostamble)+(2xcrc)+(2xsync)+(1xheader)=(1xdatasize)+1
                 ; the +1 at the end does not get sent to RFM12B chip. The interrupt is used to switch OFF transmit mode
                 
000072           TX_pream:		.byte	3	; fixed at 0xAA
000075           TX_sync_code:		.byte	1	; fixed at 0x2D
000076           TX_group_code:		.byte	1	; actualy used as 2nd sync-byte. (redefinable in software)
000077           TX_header_code:		.byte	1	; defines 'type' of packet
                 
000078           TX_datasize:		.byte	1	; how many actual DATA bytes in the buffer
                 ; 1st 2 bytes in data buffer can be used as source/dest adresses so
                 ; TX_data_buffer address is the same as TX_sourcenode
                 TX_data_buffer:
000079           TX_sourcenode:		.byte	1
00007a           TX_destnode:		.byte	1+maxdata+2	; space for CRC16 & 2xpostamble bytes
                 
0000e1           pointer1:		.byte	2	; TX pointer store
                 
                 
                 #ifdef RX_enable
                 #endif
                 
                 
                 
                 
                 ;************************ ------------------------ ****************************
                 ;***********************  Config bytes from EEPROM  ***************************
                 ;************************ ------------------------ ****************************
                 
0000e3           config_data_ram:	.byte	config_end-config_start ; space to copy config data into
                 
                 ; these are the addresses of the individual config items. Not all are used yet.
                 .equ	config_node_address	= config_data_ram	; node address
                 .equ	config_node_group	= config_data_ram+1	; node	group
                 .equ	config_node_channel	= config_data_ram+2	; node channel (frequency)
                 .equ	config_node_rate	= config_data_ram+3	; node over-air data rate
                 .equ	config_node_dest	= config_data_ram+4	; where to send to
                 .equ	config_node_retries	= config_data_ram+5
                 .equ	config_node_beacon	= config_data_ram+6
                 .equ	config_node_e		= config_data_ram+7
                 .equ	config_node_f		= config_data_ram+8
                 .equ	config_node_g		= config_data_ram+9
                 .equ	config_node_h		= config_data_ram+10
                 .equ	config_node_i		= config_data_ram+11
                 .equ	config_node_j		= config_data_ram+12
                 
                 
                 ;************************ ------------------------ ****************************
                 ;***********************          code              ***************************
                 ;************************ ------------------------ ****************************
                 
                 .cseg
                 
                 ; *****************************************************************************
                 ; DESCR: initial setup of RFM12B.
                 ; ENTRY: Some items are fixed, others are from config set in eeprom
                 ; EXIT: RFM12 initialised in idle (tx-rx-OFF, xtal ON)
                 ; CHANGES: 
                 ; USES: 
                 ; *****************************************************************************
                 init_RFM12B:
000307 d066      	rcall	wait_powerup			; if RFM12B just powered on, pause
                 
000308 e890
000309 ed87
00030a d04d      	RFcommand	0x80D7			;//EL,EF,433band,11.5pF
00030b e892
00030c e589
00030d d04a      	RFcommand	RF_IDLE_MODE		;idle, TC & RX off, xtal ON
                 
00030e 9100 00e5 	lds	temp1,config_node_channel	; read channel (frequency) from eeprom
000310 d0b9      	rcall	set_channel			; write it
                 
000311 9100 00e6 	lds	temp1,config_node_rate		; read data rate from eeprom
000313 d0cb      	rcall	set_datarate			; write it
                 
000314 e994
000315 ea82
000316 d041      	RFcommand	0x94A2			; VDI,FAST,134kHz,0dBm,
000317 ec92
000318 ea8c
000319 d03e      	RFcommand	0xC2AC			; AL,!ml,DIG,DQD4
                 
00031a 9100 00e4 	lds	temp1,config_node_group		; read group from eeprom
00031c d0a8      	rcall	set_group			; write it
                 
00031d ec9a
00031e e883
00031f d038      	RFcommand	0xCA83	; FIFO8,SYNC,ff,DR.  FIFO depth is in BITS, not BYTES
000320 ec94
000321 e88a
000322 d035      	RFcommand	0xC48A	; @PWR,NO RSTRIC,!st,!fi,O
000323 e998
000324 e580
000325 d032      	RFcommand	0x9850	; pos shift, 90Khz dev, max out
000326 ec9c
000327 e787
000328 d02f      	RFcommand	0xCC77	; PLL settings
000329 ee90
00032a e080
00032b d02c      	RFcommand	0xE000	; NOT USE
00032c ec98
00032d e080
00032e d029      	RFcommand	0xC800	; NOT USE
00032f ec94
000330 e080
000331 d026      	RFcommand	0xC400	; 1.66MHz,2.2V
000332 9508      	ret
                 
                 ; *****************************************************************************
                 ; DESCR: calculates CRC16 (XMODEM style) of the memory block for transmission
                 ; ENTRY: datacount has PAYLOAD count, payload in block at [pointer1]-see TXbase/RXbase
                 ; EXIT: CRC16 at end of data, postamble added, (RX)(TX)_total_length filled in
                 ; CHANGES: memory block, X, CRC bytes, (RX)(TX)_total_length
                 ; USES: init_crc, addtocrc
                 ; *****************************************************************************
                 build_crc:
000333 930f      	push	temp1
000334 931f      	push	temp2
                 
000335 91a0 00e1
000337 91b0 00e2 	loadX	pointer1		; get base ddress of data block
000339 9616      	adiw	xh:xl,6			; point at 1st byte to add to CRC (group)
00033a d11b      	rcall	init_crc		; zero it
00033b 2f64      	mov	loopcounter,datacount	; payload count
00033c 9563      	inc	loopcounter		; extras pre-data
00033d 9563      	inc	loopcounter
00033e 9563      	inc	loopcounter
                 addloop:
00033f 910d      	ld	temp1,x+
000340 d11d      	rcall	addtoCRC
000341 956a      	dec	loopcounter
000342 f7e1      	brne	addloop
                 ; crc done. now store it at the end of the payload
000343 9100 00f0 	lds	temp1,crc_low
000345 930d      	st	x+,temp1
000346 9100 00f1 	lds	temp1,crc_high
000348 930d      	st	x+,temp1
                 ; and finaly, fill in the ending postamble
000349 ea0a      	ldi	temp1,preamble	; 2x postamble bytes
00034a 930d      	st	x+,temp1
00034b 930c      	st	x,temp1
                 
00034c 91a0 00e1
00034e 91b0 00e2 	loadX	pointer1	; get base of ram block
000350 9611      	adiw	xh:xl,1		; point at (RX)(TX)_total_length
000351 2f04      	mov	temp1,datacount	; get payload length
000352 e01c      	ldi	temp2,11+1	; get overhead
000353 0f01      	add	temp1,temp2	; add payload & overhead
000354 930c      	st	x,temp1		; store at (RX)(TX)_total_length
                 
000355 911f      	pop	temp2
000356 910f      	pop	temp1
000357 9508      	ret			; message in ram complete & ready to send
                 
                 
                 
                 ; *****************************************************************************
                 ; DESCR: sends 16-bit data from SPI port to device
                 ; ENTRY: high byte in accH, low byte in accL
                 ; EXIT: -
                 ; CHANGES: temp1
                 ; USES: spi_send
                 ; *****************************************************************************
                 sendword:
000358 98c3      	cbi	SSpin		; select chip
000359 2f09      	mov	temp1,accH
00035a d0d2      	rcall	spi_send	; data preserved over rcall
00035b 2f08      	mov	temp1,accL	; actual data byte
00035c d0d0      	rcall	spi_send	; data preserved over rcall
00035d 9ac3      	sbi	SSpin
00035e 9508      	ret
                 
                 
                 ; *****************************************************************************
                 ; DESCR: returns all 16-bits of status reg
                 ; ENTRY: -
                 ; EXIT: accH=high byte of status, accL=low byte
                 ; CHANGES: temp1, accL, accH
                 ; USES: spi_send
                 ; *****************************************************************************
                 RFMstatus:
00035f 98c3      	cbi	SSpin		; select chip
000360 2700      	clr	temp1
000361 d0cb      	rcall	spi_send
000362 2f90      	mov	accH,temp1	; copy read-in high byte
000363 2700      	clr	temp1
000364 d0c8      	rcall	spi_send
000365 2f80      	mov	accL,temp1	; copy read-in low byte
000366 9ac3      	sbi	SSpin
000367 9508      	ret
                 
                 
                 
                 ; ****************************************************************************
                 ; DESCR: gets the 1st 8 bits (b15..b8) of status (The interrupt bits)
                 ; ENTRY: -
                 ; EXIT: 8-bits of status in accH
                 ; CHANGES: accH, temp1
                 ; USES: spi_send
                 ; *****************************************************************************
                 RFMintbits:
000368 98c3      	cbi	SSpin		; select chip
000369 2700      	clr	temp1
00036a d0c2      	rcall	spi_send
00036b 2f90      	mov	accH,temp1
00036c 9ac3      	sbi	SSpin
00036d 9508      	ret
                 
                 
                 
                 ; *****************************************************************************
                 ; DESCR: checks RFM12B status flags for newly powered-on.
                 ; ENTRY: -
                 ; EXIT: If new power-on, pause for 200ms. If not, just exit
                 ; CHANGES: accH, accL
                 ; USES: msdelay function
                 ; *****************************************************************************
                 wait_powerup:
00036e dff0      	rcall	RFMstatus
00036f fd96      	sbrc	accH,6		; see if a power-on reset
000370 c001      	rjmp	POD		; power-on-delay
000371 9508      	ret
000372 ec08      POD:	ldi	temp1,200	; power-on delay. Commands not accepted before 100ms
000373 dd49      	rcall	delsoft		; software delay, (200 * 1ms)
000374 9508      	ret
                 
                 
                 
                 #ifdef	RX_enable
                 #endif
                 
                 
                 
                 
                 ; *****************************************************************************
                 ; DESCR: reads RFM12B status bytes ( 2-bytes), if RX data is available,
                 ; keeps reading another 8 bits to read the RX fifo
                 ; ENTRY: -
                 ; EXIT: C=data in temp1, NC=no data
                 ; CHANGES: accL, accH, temp1
                 ; USES: spi_send
                 ; *****************************************************************************
                 RFMread:
000375 98c3      	cbi	SSpin		; select chip
000376 2700      	clr	temp1
000377 d0b5      	rcall	spi_send
000378 2f90      	mov	accH,temp1	; copy read-in high byte
000379 2700      	clr	temp1
00037a d0b2      	rcall	spi_send
00037b 2f80      	mov	accL,temp1	; copy read-in low byte
                 
00037c 9488      	clc			; clear carry
00037d ff97      	sbrs	accH,7		; testing for 'ready' bit
00037e c003      	rjmp	nodata		; if no data ready, exit
00037f 2700      	clr	temp1
000380 d0ac      	rcall	spi_send	; now reads in fifo
000381 9408      	sec			; to show got data
000382 9ac3      nodata:	sbi	SSpin		; transaction finished
000383 9508      	ret
                 
                 
                 
                 
                 ; *****************************************************************************
                 ; DESCR: formats the ram-block before intiating transmission
                 ; ENTRY: data block base at X, datacount is payload size, payload at
                 ; (RX)(TX)_data_buffer inside ram block
                 ; EXIT: transmission started
                 ; CHANGES: ram-block at X, X,INT0 state, pointer1
                 ; USES: build_CRC, start_TX
                 ; *****************************************************************************
                 prepare_TX:
000384 b70b
000385 7b0f
000386 bf0b      	ext0_OFF			; make sure int0 is OFF
000387 93a0 00e1
000389 93b0 00e2 	storeX	pointer1		; save pointer. (TX)(RX)_base
                 
00038b 9612      	adiw	xh:xl,2			; point at 1st preamble byte location
00038c ea0a      	ldi	temp1,preamble		; set-up 3Xpreamble bytes
00038d 930d      	st	x+,temp1
00038e 930d      	st	x+,temp1
00038f 930d      	st	x+,temp1
                 
000390 e20d      	ldi	temp1,syncbyte		; get 1st syncbyte. This is a fixed value
000391 930d      	st	x+,temp1		; save into buffer
                 
000392 9100 00e4 	lds	temp1,config_node_group
000394 930d      	st	x+,temp1		; changeable in software (2nd sync byte)
000395 935d      	st	x+,headerbyte		; frame type
000396 934c      	st	x,datacount		; data payload count
                 
000397 df9b      	rcall	build_CRC		; fills in the CRC bytes and TX_total_length
                 ; message now complete in ram
                 ; (TX)(RX)_total_length/preamble/sync/group/header/count/data/checksum/postamble
                 
                 ;	rcall	test_listen
                 ;	brcs	do_tx
                 ;	ret
                 
000398 d001      do_tx:	rcall	start_TX		; loads the TX count and sets TX mode
                 
000399 9508      	ret
                 
                 ; *****************************************************************************
                 ; DESCR: re/transmit a packet from ram after prepare_TX has constructed it
                 ; ENTRY: prepare_TX must have been called for the data. pointer1 must be valid
                 ; EXIT: packet transmission started
                 ; CHANGES: temp1, X, state, Y, enables INT0
                 ; USES: intTXdata, sendword
                 ; *****************************************************************************
                 start_TX:
00039a e03a      	ldi	state,state10
00039b 91a0 00e1
00039d 91b0 00e2 	loadX	pointer1		; base of data block
00039f 9611      	adiw	xh:xl,1			; point at total length
0003a0 910c      	ld	temp1,x			; total length location
0003a1 950a      	dec	temp1			; because we are just goint to send the 1st byte
0003a2 930e      	st	-x,temp1		; int routine downcount location
0003a3 9612      	adiw	xh:xl,2			; mow points to 1st preamble byte
0003a4 2fca      	mov	yl,xl			; copy this location to Y pair
0003a5 2fdb      	mov	yh,xh
0003a6 e892
0003a7 e289
0003a8 dfaf      	RFcommand RF_TX_ON		; switch TX chain ON
0003a9 9109      	ld	temp1,y+		; get 1st preamble byte
0003aa d006      	rcall	intTXdata		; send it, but keep SS low
0003ab e400
0003ac bf0a
0003ad b70b
0003ae 6400
0003af bf0b      	ext0_ON				; turn on ext0 int for (TX buffer ready)
0003b0 9508      	ret
                 
                 
                 
                 
                 
                 ; *****************************************************************************
                 ; DESCR: transmits the FIRST byte of a prepared message. The rest are all sent
                 ; from within the interrupt routine (INT0)
                 ; ENTRY: complete message assembled in ram ready to send
                 ; EXIT: 1st databyte transmitted is left in temp1
                 ; CHANGES: accH, accL, temp1
                 ; USES: RFMintbits, spi_send
                 ; *****************************************************************************
                 intTXdata:
0003b1 930f      	push	temp1		; 1st, save the data byte
0003b2 dfb5      wtTX:	rcall	RFMintbits	; get module int status bits
0003b3 ff97      	sbrs	accH,7		; testing for 'TX ready' bit
0003b4 cffd      	rjmp	wtTX		; loop till unit ready
                 
                 ; here when ready to accept data.
0003b5 910f      	pop	temp1		; restore data to send
0003b6 eb98      	ldi	accH,0xb8	; write to TX register command
0003b7 2f80      	mov	accL,temp1	; data to write
                 
0003b8 98c3      	cbi	SSpin		; select chip (RFM12B module)
0003b9 2f09      	mov	temp1,accH	; send command
0003ba d072      	rcall	spi_send	;
0003bb 2f08      	mov	temp1,accL	; send data byte to TX
0003bc d070      	rcall	spi_send	; data preserved over rcall
0003bd 9508      	ret
                 ; The SS signal is kept lowered on exit from this routine so the next write
                 ; (the next byte to TX) will go direct to the TX register as an 8-bit transfer
                 ; because the COMMAND (0xB8XX) is still active (write to TX register).
                 ; Once the SS line is brought high, the command is finished.
                 ; Every time the TX register is available, the int0 line is activated so the
                 ; 8-bit transfer can happen in the interrupt routine as a background task
                 
                 
                 
                 ; *****************************************************************************
                 ; DESCR: waits till a TX is finished
                 ; ENTRY: transmission in progress
                 ; EXIT: transmission completed. RF=idle, state=11, ext0=OFF
                 ; CHANGES: -
                 ; USES: -
                 ; *****************************************************************************
                 wait_TXend:
0003be 303b
0003bf f7f1      	jne	state,state11,wait_TXend	; wait till TX finished
0003c0 e892
0003c1 e589
0003c2 df95      	rfcommand RF_IDLE_MODE			; RFM12 in idle state
0003c3 df9b      	rcall	RFMstatus		; clears any RFM12 int flag
                 
0003c4 9508      	ret
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 ; *****************************************************************************
                 ; DESCR: sets tx/rx group code
                 ; ENTRY: group in temp1 (0..0xFF)
                 ; EXIT: RFM12B register updated
                 ; CHANGES: 
                 ; USES: 
                 ; *****************************************************************************
                 set_group:
0003c5 2f80      	mov	accL,temp1
0003c6 ec9e      	ldi	accH,0xCE
0003c7 df90      	rcall	sendword
0003c8 9408      	sec
0003c9 9508      	ret
                 
                 
                 ; =============================================================================
                 
                 ; channel spacing at 0.5Mhz steps starting at
                 ; 1, F=200 430.5M
                 ; 2, F=400 431
                 ; 3, F=600 431.5M
                 ; 4, F=800 432
                 ; 5, F=1000 432.5M
                 ; 6, F=1200 433
                 ; 7, F=1400 433.5M
                 ; 8, F=1600 434
                 ; 9, F=1800 434.5M
                 ; 10, F=2000 435
                 ; 11, F=2200 435.5M
                 ; 12, F=2400 436
                 ; 13, F=2600 436.5M
                 ; 14, F=2800 437
                 ; 15, F=3000 437.5M
                 ; 16, F=3200 438
                 ; 17, F=3400 438.5M
                 ; 18, F=3600 439
                 ; 19, F=3800 439.5M
                 ; *****************************************************************************
                 ; DESCR: setx the channel (frequency) for TX/RX
                 ; ENTRY: channel number in temp1 (1...19) at 0.5Mhz steps.
                 ; EXIT: C=good, NC=error
                 ; CHANGES: accH, accL, temp1, temp2, r0, r1
                 ; USES: 
                 ; *****************************************************************************
                 set_channel:
0003ca 3104      	cpi	temp1,20
0003cb f008      	brlo	Setc1		; check if too high
0003cc c010      	rjmp	badval		; bad exit
                 
0003cd 2300      setc1:	tst	temp1		; check if zero
0003ce f409      	brne	Setc2
0003cf c00d      	rjmp	badval		; bad exit
                 
                 ; good value so continue
0003d0 930f      setc2:	push	temp1		; save value
0003d1 ec18      	ldi	temp2,200	; fixed to define channel spacing (0.5Mhz)
0003d2 dcf2      	rcall	mpy8u		; temp1 can be 1....19
0003d3 ea10      	ldi	temp2,0b10100000	; high nibble is command
0003d4 2a11      	or	r1,temp2	; merge bits
                 
0003d5 94f8      	cli
0003d6 2d80      	mov	accL,r0
0003d7 2d91      	mov	accH,r1
0003d8 df7f      	rcall	sendword
0003d9 9478      	sei
0003da 910f      	pop	temp1		; restore entry value
0003db 9408      	sec			; all good!
0003dc 9508      	ret
                 
0003dd 9488      badval:	clc
0003de 9508      	ret
                 
                 
                 
                 ; *****************************************************************************
                 ; DESCR: sets the over-the-air data rate
                 ; ENTRY: value in temp1 (0..15). 'state' must be ok to allow change
                 ; EXIT: CS=success, CC=failed (bad state)
                 ; CHANGES: 
                 ; USES: 
                 ; *****************************************************************************
                 set_datarate:
0003df 3100      	cpi	temp1,16
0003e0 f7e0      	brsh	badval		; if >15 then bad
                 
0003e1 93ef      rt2:	push	ZL
0003e2 93ff      	push	ZH
0003e3 930f      	push	temp1
0003e4 eee6
0003e5 e0f7      	ldz	rom,rate_table
0003e6 700f      	andi	temp1,0b00001111
0003e7 0fe0      	add	ZL,temp1
0003e8 f408      	brcc	rt1
0003e9 95f3      	inc	ZH
0003ea 9104      rt1:	lpm	temp1,z		; value for data rate
0003eb 2f80      	mov	accL,temp1
0003ec ec96      	ldi	accH,0xc6	; data rate command
0003ed df6a      	rcall	sendword	; writes the rate data to RFM12B
0003ee 910f      	pop	temp1
0003ef 91ff      	pop	ZH
0003f0 91ef      	pop	ZL
0003f1 9408      	sec
0003f2 9508      	ret
                 
                 rate_table:
0003f3 a2c6
0003f4 8891
0003f5 2330
0003f6 1117      	.db	0xc6,0xa2,0x91,0x88,0x30,0x23,0x17,0x11
0003f7 080b
0003f8 0607
0003f9 0405
0003fa 0203      	.db	0x0B,0x08,0x07,0x06,0x05,0x04,0x03,0x02
                 
                 
                 
                 ;0x02	; 114.943	15
                 ;0x03	; 86.207	14
                 ;0x04	; 68.966	13
                 ;0x05	; 57.471	12
                 ;0x06	; 49.261	11
                 ;0x07	; 43.103	10
                 ;0x08	; 38.314	9
                 ;0x0B	; 28.736	8
                 ;0x11	; 19.157	7
                 ;0x17	; 14.368	6
                 ;0x23	; 9.579		5
                 ;0x30	; 7.037		4
                 ;0x88	; 4.789		3
                 ;0x91	; 2.395		2
                 ;0xa2	; 1.232		1
                 ;0xc6	; 0.607		0
                 
                 
                 
                 
                 
                 
                 ; *****************************************************************************
                 ; DESCR: sets up for a 4 second sleep period
                 ; ENTRY: 
                 ; EXIT: 
                 ; CHANGES: 
                 ; USES: 
                 ; *****************************************************************************
                 
                 enter_sleep4ms:
0003fb ee91
0003fc e082
0003fd df5a      	RFCOMMAND RF_TIMER_4ms	; WAKE-UP in 4 ms
0003fe c014      	rjmp	comm
                 
                 enter_sleep1:
0003ff ee93
000400 e88c
000401 df56      	RFCOMMAND RF_TIMER_1	; WAKE-UP in 1-sec
000402 c010      	rjmp	comm
                 
                 enter_sleep4:
000403 ee95
000404 e88c
000405 df52      	RFCOMMAND RF_TIMER_4	; WAKE-UP in 4 sec
000406 c00c      	rjmp	comm
                 
                 enter_sleep59:
000407 ee99
000408 e78f
000409 df4e      	RFCOMMAND RF_TIMER_59	; WAKE-UP in 59 sec
00040a c008      	rjmp	comm
                 
                 enter_sleep1m:
00040b ee99
00040c e882
00040d df4a      	RFCOMMAND RF_TIMER_1m	; WAKE-UP in 1-min
00040e c004      	rjmp	comm
                 
                 enter_sleep2m:
00040f ee9a
000410 e882
000411 df46      	RFCOMMAND RF_TIMER_2m	; WAKE-UP in 1-min
000412 c000      	rjmp	comm
                 
                 
                 comm:
000413 e892
000414 e083
000415 df42      	RFCOMMAND RF_SLEEP_MODE	; shuts chip RF system down
000416 6870      	sb	bitflags,7		; set bit 7 to indicate sleep
                 
000417 b705      	in	temp1,mcucr
000418 7f0c      	andi	temp1,0b11111100	; set ext0/1 to low level
000419 6200      	ori	temp1,0b00100000	; and set sleep enable bit
00041a bf05      	out	mcucr,temp1		; write to reg
                 
00041b e400      	ldi	temp1,0b01000000	; bit to clear any pending ext0 int
00041c bf0a      	out	gifr, temp1		;
                 
00041d b70b      	in	temp1,gimsk
00041e 6400      	ori	temp1,0b01000000	; ext0 enable bit
00041f bf0b      	out	gimsk,temp1
                 
                 
000420 9588      	sleep	; enter power-down mode. Exit by ext0 int
                 ;===============================================================================
                 ;===============================================================================
                 
                 ; has just exited the ext0 int routine.
                 
                 
000421 df3d      	rcall	RFMstatus		; clears any RFM12 int bits
                 
000422 e892
000423 e589
000424 df33      	RFcommand RF_IDLE_MODE		; xtal on, (RX, TX, low-bat detect, clk out) all off
000425 2733      	clr	state			; set to zero
                 
000426 9508      	ret
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 .include	"SPI.asm"
                 
                 
                 
                 
                 init_spi:
000427 9ac3      	sbi	SSpin			; make sure SS high
000428 98da      	cbi	porta,2			; always leave/start sck line in LOW
000429 98d9      	cbi	porta,1			; and data line LOW
00042a e001      	ldi	temp1,1
00042b bb01      	out	USIPP,temp1		; moves USI to port-A pins (0,1,2)
00042c 9508      	ret
                 
                 
                 spi_send:
00042d 931f      	push	temp2
00042e b90f      	out	USIDR,temp1
00042f e101      	ldi	temp1,(1<<USIWM0)|(0<<USICS0)|(1<<USITC)
000430 e113      	ldi	temp2,(1<<USIWM0)|(0<<USICS0)|(1<<USITC)|(1<<USICLK)
                 
000431 b90d      	out	USICR,temp1	; MSB
000432 0000      	nop
000433 b91d      	out	USICR,temp2
000434 0000      	nop
                 
000435 b90d      	out	USICR,temp1
000436 0000      	nop
000437 b91d      	out	USICR,temp2
000438 0000      	nop
                 
000439 b90d      	out	USICR,temp1
00043a 0000      	nop
00043b b91d      	out	USICR,temp2
00043c 0000      	nop
                 
00043d b90d      	out	USICR,temp1
00043e 0000      	nop
00043f b91d      	out	USICR,temp2
000440 0000      	nop
                 
000441 b90d      	out	USICR,temp1
000442 0000      	nop
000443 b91d      	out	USICR,temp2
000444 0000      	nop
                 
000445 b90d      	out	USICR,temp1
000446 0000      	nop
000447 b91d      	out	USICR,temp2
000448 0000      	nop
                 
000449 b90d      	out	USICR,temp1
00044a 0000      	nop
00044b b91d      	out	USICR,temp2	; LSB
00044c 0000      	nop
                 
00044d b90d      	out	USICR,temp1
00044e 0000      	nop
00044f b91d      	out	USICR,temp2
000450 0000      	nop
                 
000451 b10f      	in	temp1,USIDR
000452 98da      	cbi	porta,2		; always leave sck line in LOW
000453 98d9      	cbi	porta,1		; and data line LOW
000454 911f      	pop	temp2
000455 9508      	ret
                 .include	"crc.asm"
                 
                 ;*                                *
                 ;*    Fast lookup table driven    *
                 ;*     16 bit CRC Routine for     *
                 ;*   ATMEL AVR microcontrollers   *
                 ;*                                *
                 ;*          17-Oct-2002           *
                 ;*                                *
                 ;*       By Anthony Barrett       *
                 ;*                                *
                 ;**********************************
                 ; ORIGINAL did....
                 ; byte to add in [temp1]
                 ; CRC result is returned in crc_low (low byte) & crc_high (high byte).
                 ; Uses regisisters:  crc_A, crc_low, crc_high, crc_B, crc_C, crc_D
                 
                 ;21/06/10
                 ; MODIFIED from the authors original, so now does byte-at-a-time. Byte to add in temp1
                 ; Call init_crc before adding bytes.
                 ; tested at http://www.lammertbies.nl/comm/info/crc-calculation.html
                 ; Uses CRC16, x-modem style. Stewart
                 
                 .dseg
                 
0000f0           crc_low:	.byte	1
0000f1           crc_high:	.byte	1
                 
                 .cseg
                 
                 init_crc:
000456 930f      	push	temp1
000457 2700      	clr	temp1
000458 9300 00f0 	sts	crc_low,temp1
00045a 9300 00f1 	sts	crc_high,temp1
00045c 910f      	pop	temp1
00045d 9508      	ret
                 
                 
                 
                 ; data to add in temp1 (preserved)
                 addtoCRC:
00045e 93ef      	push	zl
00045f 93ff      	push	zh
000460 930f      	push	temp1
000461 931f      	push	temp2
000462 932f      	push	temp3
000463 2722      	clr	temp3
                 
000464 2f10      	mov	temp2,temp1
000465 9100 00f1 	lds	temp1,crc_high
000467 2701      	eor	temp1,temp2
                 
000468 efee      	ldi	ZL,low(2 * CRC16Tab)
000469 e0f8      	ldi	ZH,high(2 * CRC16Tab)
                 
00046a 0fe0      	add	ZL,temp1
00046b 1ff2      	adc	ZH,temp3
00046c 0fe0      	add	ZL,temp1
00046d 1ff2      	adc	ZH,temp3
                 
00046e 9124      	lpm	temp3,z
                 
00046f 9110 00f0 	lds	temp2,crc_low
000471 2f02      	mov	temp1,temp3
                 
000472 9631      	adiw	ZL,1
                 
000473 9124      	lpm	temp3,z
                 
000474 2712      	eor	temp2,temp3
000475 9300 00f0 	sts	crc_low,temp1
000477 9310 00f1 	sts	crc_high,temp2
                 
000479 912f      	pop	temp3
00047a 911f      	pop	temp2
00047b 910f      	pop	temp1
00047c 91ff      	pop	zh
00047d 91ef      	pop	zl
00047e 9508      	ret
                 
                 
                 
                 ;High speed 16 bit CRC lookup table:
                 ;Polynomial: x^12 + x^5 + 1
                 
00047f 0000
000480 1021
000481 2042
000482 3063
000483 4084
000484 50a5
000485 60c6
000486 70e7      CRC16Tab:	.dw	$0000,$1021,$2042,$3063,$4084,$50a5,$60c6,$70e7
000487 8108
000488 9129
000489 a14a
00048a b16b
00048b c18c
00048c d1ad
00048d e1ce
00048e f1ef      	.dw	$8108,$9129,$a14a,$b16b,$c18c,$d1ad,$e1ce,$f1ef
00048f 1231
000490 0210
000491 3273
000492 2252
000493 52b5
000494 4294
000495 72f7
000496 62d6      	.dw	$1231,$0210,$3273,$2252,$52b5,$4294,$72f7,$62d6
000497 9339
000498 8318
000499 b37b
00049a a35a
00049b d3bd
00049c c39c
00049d f3ff
00049e e3de      	.dw	$9339,$8318,$b37b,$a35a,$d3bd,$c39c,$f3ff,$e3de
00049f 2462
0004a0 3443
0004a1 0420
0004a2 1401
0004a3 64e6
0004a4 74c7
0004a5 44a4
0004a6 5485      	.dw	$2462,$3443,$0420,$1401,$64e6,$74c7,$44a4,$5485
0004a7 a56a
0004a8 b54b
0004a9 8528
0004aa 9509
0004ab e5ee
0004ac f5cf
0004ad c5ac
0004ae d58d      	.dw	$a56a,$b54b,$8528,$9509,$e5ee,$f5cf,$c5ac,$d58d
0004af 3653
0004b0 2672
0004b1 1611
0004b2 0630
0004b3 76d7
0004b4 66f6
0004b5 5695
0004b6 46b4      	.dw	$3653,$2672,$1611,$0630,$76d7,$66f6,$5695,$46b4
0004b7 b75b
0004b8 a77a
0004b9 9719
0004ba 8738
0004bb f7df
0004bc e7fe
0004bd d79d
0004be c7bc      	.dw	$b75b,$a77a,$9719,$8738,$f7df,$e7fe,$d79d,$c7bc
0004bf 48c4
0004c0 58e5
0004c1 6886
0004c2 78a7
0004c3 0840
0004c4 1861
0004c5 2802
0004c6 3823      	.dw	$48c4,$58e5,$6886,$78a7,$0840,$1861,$2802,$3823
0004c7 c9cc
0004c8 d9ed
0004c9 e98e
0004ca f9af
0004cb 8948
0004cc 9969
0004cd a90a
0004ce b92b      	.dw	$c9cc,$d9ed,$e98e,$f9af,$8948,$9969,$a90a,$b92b
0004cf 5af5
0004d0 4ad4
0004d1 7ab7
0004d2 6a96
0004d3 1a71
0004d4 0a50
0004d5 3a33
0004d6 2a12      	.dw	$5af5,$4ad4,$7ab7,$6a96,$1a71,$0a50,$3a33,$2a12
0004d7 dbfd
0004d8 cbdc
0004d9 fbbf
0004da eb9e
0004db 9b79
0004dc 8b58
0004dd bb3b
0004de ab1a      	.dw	$dbfd,$cbdc,$fbbf,$eb9e,$9b79,$8b58,$bb3b,$ab1a
0004df 6ca6
0004e0 7c87
0004e1 4ce4
0004e2 5cc5
0004e3 2c22
0004e4 3c03
0004e5 0c60
0004e6 1c41      	.dw	$6ca6,$7c87,$4ce4,$5cc5,$2c22,$3c03,$0c60,$1c41
0004e7 edae
0004e8 fd8f
0004e9 cdec
0004ea ddcd
0004eb ad2a
0004ec bd0b
0004ed 8d68
0004ee 9d49      	.dw	$edae,$fd8f,$cdec,$ddcd,$ad2a,$bd0b,$8d68,$9d49
0004ef 7e97
0004f0 6eb6
0004f1 5ed5
0004f2 4ef4
0004f3 3e13
0004f4 2e32
0004f5 1e51
0004f6 0e70      	.dw	$7e97,$6eb6,$5ed5,$4ef4,$3e13,$2e32,$1e51,$0e70
0004f7 ff9f
0004f8 efbe
0004f9 dfdd
0004fa cffc
0004fb bf1b
0004fc af3a
0004fd 9f59
0004fe 8f78      	.dw	$ff9f,$efbe,$dfdd,$cffc,$bf1b,$af3a,$9f59,$8f78
0004ff 9188
000500 81a9
000501 b1ca
000502 a1eb
000503 d10c
000504 c12d
000505 f14e
000506 e16f      	.dw	$9188,$81a9,$b1ca,$a1eb,$d10c,$c12d,$f14e,$e16f
000507 1080
000508 00a1
000509 30c2
00050a 20e3
00050b 5004
00050c 4025
00050d 7046
00050e 6067      	.dw	$1080,$00a1,$30c2,$20e3,$5004,$4025,$7046,$6067
00050f 83b9
000510 9398
000511 a3fb
000512 b3da
000513 c33d
000514 d31c
000515 e37f
000516 f35e      	.dw	$83b9,$9398,$a3fb,$b3da,$c33d,$d31c,$e37f,$f35e
000517 02b1
000518 1290
000519 22f3
00051a 32d2
00051b 4235
00051c 5214
00051d 6277
00051e 7256      	.dw	$02b1,$1290,$22f3,$32d2,$4235,$5214,$6277,$7256
00051f b5ea
000520 a5cb
000521 95a8
000522 8589
000523 f56e
000524 e54f
000525 d52c
000526 c50d      	.dw	$b5ea,$a5cb,$95a8,$8589,$f56e,$e54f,$d52c,$c50d
000527 34e2
000528 24c3
000529 14a0
00052a 0481
00052b 7466
00052c 6447
00052d 5424
00052e 4405      	.dw	$34e2,$24c3,$14a0,$0481,$7466,$6447,$5424,$4405
00052f a7db
000530 b7fa
000531 8799
000532 97b8
000533 e75f
000534 f77e
000535 c71d
000536 d73c      	.dw	$a7db,$b7fa,$8799,$97b8,$e75f,$f77e,$c71d,$d73c
000537 26d3
000538 36f2
000539 0691
00053a 16b0
00053b 6657
00053c 7676
00053d 4615
00053e 5634      	.dw	$26d3,$36f2,$0691,$16b0,$6657,$7676,$4615,$5634
00053f d94c
000540 c96d
000541 f90e
000542 e92f
000543 99c8
000544 89e9
000545 b98a
000546 a9ab      	.dw	$d94c,$c96d,$f90e,$e92f,$99c8,$89e9,$b98a,$a9ab
000547 5844
000548 4865
000549 7806
00054a 6827
00054b 18c0
00054c 08e1
00054d 3882
00054e 28a3      	.dw	$5844,$4865,$7806,$6827,$18c0,$08e1,$3882,$28a3
00054f cb7d
000550 db5c
000551 eb3f
000552 fb1e
000553 8bf9
000554 9bd8
000555 abbb
000556 bb9a      	.dw	$cb7d,$db5c,$eb3f,$fb1e,$8bf9,$9bd8,$abbb,$bb9a
000557 4a75
000558 5a54
000559 6a37
00055a 7a16
00055b 0af1
00055c 1ad0
00055d 2ab3
00055e 3a92      	.dw	$4a75,$5a54,$6a37,$7a16,$0af1,$1ad0,$2ab3,$3a92
00055f fd2e
000560 ed0f
000561 dd6c
000562 cd4d
000563 bdaa
000564 ad8b
000565 9de8
000566 8dc9      	.dw	$fd2e,$ed0f,$dd6c,$cd4d,$bdaa,$ad8b,$9de8,$8dc9
000567 7c26
000568 6c07
000569 5c64
00056a 4c45
00056b 3ca2
00056c 2c83
00056d 1ce0
00056e 0cc1      	.dw	$7c26,$6c07,$5c64,$4c45,$3ca2,$2c83,$1ce0,$0cc1
00056f ef1f
000570 ff3e
000571 cf5d
000572 df7c
000573 af9b
000574 bfba
000575 8fd9
000576 9ff8      	.dw	$ef1f,$ff3e,$cf5d,$df7c,$af9b,$bfba,$8fd9,$9ff8
000577 6e17
000578 7e36
000579 4e55
00057a 5e74
00057b 2e93
00057c 3eb2
00057d 0ed1
00057e 1ef0      	.dw	$6e17,$7e36,$4e55,$5e74,$2e93,$3eb2,$0ed1,$1ef0
                 
                 
                 
                 
                 
                 
                 .include	"eeprom.asm"
                 
                 
                 .equ	default_address 	= TX_node_address	; node address
                 .equ	default_group		= 0xD4			; dec-212 default group
                 .equ	default_channel		= 0x06			; default channel =433Mhz. CH6
                 .equ	default_rate		= 11			; default rate=49.2K. rate 9
                 .equ	default_retries		= 0			; not used
                 .equ	default_beacon		= 0			; not used
                 .equ	default_dest		= 255			; default destination
                 
                 
                 
                 .dseg
                 
0000f2 02        EEadr:		.db	2	; EEprom addr start, Low byte then high
                 
                 
                 .cseg
                 
                 ; *****************************************************************************
                 ; DESCR: copies the eeprom config data into ram
                 ; ENTRY: config data must exist
                 ; EXIT: data copied
                 ; CHANGES: ram
                 ; USES: eeprom_read
                 ; *****************************************************************************
                 configset_to_ram:
00057f e0a0
000580 e0b0      	ldX	ram,config_start			; get eeprom data start
000581 93a0 00f2
000583 93b0 00f3 	storeX	EEadr
000585 e06d      	ldi	loopcounter,config_end-config_start	; byte count
000586 eee3
000587 e0f0      	ldZ	ram,config_data_ram
000588 d0f3      copi:	rcall	eeprom_read
000589 9611      	adiw	xh:xl,1
00058a 93a0 00f2
00058c 93b0 00f3 	storeX	EEadr
00058e 8300      	st	z,temp1
00058f 956a      	dec	loopcounter
000590 f7b9      	brne	copi
000591 9508      	ret
                 
                 
                 
                 set_config:
000592 e0a0
000593 e0b0      	ldX	ram,node_address
000594 93a0 00f2
000596 93b0 00f3 	storeX	EEadr
000598 d0e3      	rcall	EEPROM_read
000599 9300 00e3 	sts	config_node_address,temp1
                 
00059b e0a1
00059c e0b0      	ldX	ram,node_group
00059d 93a0 00f2
00059f 93b0 00f3 	storeX	EEadr
0005a1 d0da      	rcall	EEPROM_read
0005a2 9300 00e4 	sts	config_node_group,temp1
0005a4 de20      	rcall	set_group
                 
0005a5 e0a2
0005a6 e0b0      	ldX	ram,node_channel
0005a7 93a0 00f2
0005a9 93b0 00f3 	storeX	EEadr
0005ab d0d0      	rcall	EEPROM_read
0005ac 9300 00e5 	sts	config_node_channel,temp1
0005ae de1b      	rcall	set_channel
                 
0005af e0a3
0005b0 e0b0      	ldX	ram,node_rate
0005b1 93a0 00f2
0005b3 93b0 00f3 	storeX	EEadr
0005b5 d0c6      	rcall	EEPROM_read
0005b6 9300 00e6 	sts	config_node_rate,temp1
0005b8 de26      	rcall	set_datarate
                 
0005b9 e0a4
0005ba e0b0      	ldX	ram,node_retries
0005bb 93a0 00f2
0005bd 93b0 00f3 	storeX	EEadr
0005bf d0bc      	rcall	EEPROM_read
0005c0 9300 00e8 	sts	config_node_retries,temp1
                 
0005c2 e0a5
0005c3 e0b0      	ldX	ram,node_beacon
0005c4 93a0 00f2
0005c6 93b0 00f3 	storeX	EEadr
0005c8 d0b3      	rcall	EEPROM_read
0005c9 9300 00e9 	sts	config_node_beacon,temp1
                 
0005cb e0a6
0005cc e0b0      	ldX	ram,node_dest
0005cd 93a0 00f2
0005cf 93b0 00f3 	storeX	EEadr
0005d1 d0aa      	rcall	EEPROM_read
0005d2 9300 00e7 	sts	config_node_dest,temp1
0005d4 9508      	ret
                 
                 
                 
                 
                 
                 test_config:
0005d5 de80      	rcall	init_crc		; zero CRC
0005d6 e0a0
0005d7 e0b0      	ldX	ram,config_start	; start of config data
0005d8 93a0 00f2
0005da 93b0 00f3 	storeX	EEadr			; set pointer
                 
                 ; get length of data
0005dc e06d      	ldi	loopcounter,config_end-config_start
0005dd d09e      check1:	rcall	EEPROM_read		; get byte
0005de de7f      	rcall	addtoCRC		; add to CRC
0005df 91a0 00f2
0005e1 91b0 00f3 	loadX	EEadr
0005e3 9611      	adiw	xh:xl,1			; inc pointer
0005e4 93a0 00f2
0005e6 93b0 00f3 	storeX	EEadr			; save it
0005e8 956a      	dec	loopcounter
0005e9 f799      	brne	check1			; loop till read all config data
                 ; crc now complete so compare to stored one in eeprom
0005ea d091      	rcall	EEPROM_read		; get byte (crcL)
0005eb 9110 00f0 	lds	temp2,crc_low
0005ed 1701      	cp	temp1,temp2
0005ee f461      	brne	config_fail
0005ef 9611      	adiw	xh:xl,1			; inc pointer
0005f0 93a0 00f2
0005f2 93b0 00f3 	storeX	EEadr			; save it
0005f4 d087      	rcall	EEPROM_read		; get byte (crcH)
0005f5 9110 00f1 	lds	temp2,crc_high
0005f7 1701      	cp	temp1,temp2		; compare next
0005f8 f411      	brne	config_fail
0005f9 9408      	sec				; shows data valid
0005fa 9508      	ret
                 
                 
                 config_fail:
0005fb da4a
0005fc 6f63
0005fd 666e
0005fe 6769
0005ff 4320
000600 4352
000601 6620
000602 6961
000603 756c
000604 6572
\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\macros.inc(43): warning: .cseg .db misalignment - padding zero byte
\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\eeprom.asm(116): macro 'stringout' called here
\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\main.asm(225): '\\vmware-host\Shared Folders\My Documents\Windocs\AVRproj\RFM12B\TN861-mini\eeprom.asm' included form here
000605 0000      	stringout	"config CRC failure"
000606 9488      	clc
000607 9508      	ret
                 
                 
                 
                 default_config:
000608 de4d      	rcall	init_crc		; zero CRC
000609 e0a0
00060a e0b0      	ldX	ram,config_start	; start of config data
00060b 93a0 00f2
00060d 93b0 00f3 	storeX	EEadr			; set pointer
                 ; get length of data
00060f e06d      	ldi	loopcounter,config_end-config_start
                 
000610 e004      set1:	ldi	temp1,default_address		; default chan=1
000611 d028      	rcall	do_EE
                 
000612 ed04      	ldi	temp1,default_group		; default group=0xd4
000613 d026      	rcall	do_EE
                 
000614 e006      	ldi	temp1,default_channel		; default channel=6 (433Mhz)
000615 d024      	rcall	do_EE
                 
000616 e00b      	ldi	temp1,default_rate		; rate = 49.2k
000617 d022      	rcall	do_EE
                 
000618 e000      	ldi	temp1,default_retries		; not used
000619 d020      	rcall	do_EE
                 	
00061a e000      	ldi	temp1,default_beacon		; not used
00061b d01e      	rcall	do_EE
                 
00061c ef0f      	ldi	temp1,default_dest		; =255
00061d d01c      	rcall	do_EE
                 
00061e 2700      set2:	clr	temp1			; fill the rest with zeros
00061f d01a      	rcall	do_EE
000620 f7e9      	brne	set2
                 
                 
                 ; now write CRC low
000621 9100 00f0 	lds	temp1,crc_low
000623 d048      	rcall	EEPROM_write
000624 91a0 00f2
000626 91b0 00f3 	loadX	EEadr
000628 9611      	adiw	xh:xl,1
000629 93a0 00f2
00062b 93b0 00f3 	storeX	EEadr
                 	
                 ; now write CRC high
00062d 9100 00f1 	lds	temp1,crc_high
00062f d03c      	rcall	EEPROM_write
000630 91a0 00f2
000632 91b0 00f3 	loadX	EEadr
000634 9611      	adiw	xh:xl,1
000635 93a0 00f2
000637 93b0 00f3 	storeX	EEadr
000639 9508      	ret
                 	
                 
00063a de23      do_EE:	rcall	addtoCRC
00063b d030      	rcall	EEPROM_write
00063c 91a0 00f2
00063e 91b0 00f3 	loadX	EEadr
000640 9611      	adiw	xh:xl,1
000641 93a0 00f2
000643 93b0 00f3 	storeX	EEadr
000645 956a      	dec	loopcounter
000646 9508      	ret
                 
                 
                 
                 ; *****************************************************************************
                 ; DESCR: reads the EEprom data and updates the CRC to match
                 ; ENTRY: -
                 ; EXIT: CRC in eeprom updated
                 ; CHANGES: CRC in eeprom
                 ; USES: rcall	EEPROM_read, EEPROM_write
                 ; *****************************************************************************
                 update_CRC:
000647 de0e      	rcall	init_crc		; zero CRC
000648 e0a0
000649 e0b0      	ldX	ram,config_start	; start of config data
00064a 93a0 00f2
00064c 93b0 00f3 	storeX	EEadr			; set pointer
                 
                 ; get length of data
00064e e06d      	ldi	loopcounter,config_end-config_start
00064f d02c      check4:	rcall	EEPROM_read		; get byte
000650 de0d      	rcall	addtoCRC		; add to CRC
000651 91a0 00f2
000653 91b0 00f3 	loadX	EEadr
000655 9611      	adiw	xh:xl,1			; inc pointer
000656 93a0 00f2
000658 93b0 00f3 	storeX	EEadr			; save it
00065a 956a      	dec	loopcounter
00065b f799      	brne	check4			; loop till read all config data
                 
                 ; crc now complete so write to EEprom
00065c 9100 00f0 	lds	temp1,crc_low
00065e d00d      	rcall	EEPROM_write
00065f 91a0 00f2
000661 91b0 00f3 	loadX	EEadr
000663 9611      	adiw	xh:xl,1
000664 93a0 00f2
000666 93b0 00f3 	storeX	EEadr
                 ; now write CRC high
000668 9100 00f1 	lds	temp1,crc_high
00066a d001      	rcall	EEPROM_write
00066b 9508      	ret
                 
                 
                 
                 
                 
                 ; *****************************************************************************
                 ; DESCR: writes a byte to eeprom (erase then write cycle)
                 ; ENTRY: byte to write in temp1, addr to write in EEadr (ram)
                 ; EXIT: byte written
                 ; CHANGES: eeprom
                 ; USES: -
                 ; *****************************************************************************
                 EEPROM_write:
00066c 99e1      	sbic	EECR,EEPE	; Wait for completion of previous write
00066d cffe      	rjmp	EEPROM_write	; loop till ready
00066e 930f      	push	temp1
00066f 9100 00f2 	lds	temp1,EEadr	; get low byte
000671 bb0e      	out	EEARL,temp1
000672 9100 00f3 	lds	temp1,EEadr+1	; get high byte
000674 bb0f      	out	EEARH, temp1	; Set up address (r18:r17) in address register
000675 910f      	pop	temp1
000676 bb0d      	out	EEDR,temp1	; Write data (r16) to Data Register
000677 94f8      	cli			; disable ints for timed access
000678 9ae2      	sbi	EECR,EEMPE	; Write logical one to EEMPE
000679 9ae1      	sbi	EECR,EEPE	; Start eeprom write by setting EEPE
00067a 9478      	sei			; re-enable ints
00067b 9508      	ret
                 
                 
                 
                 
                 ; *****************************************************************************
                 ; DESCR: reads a byte from EEprom
                 ; ENTRY: address to read in EEadr (ram)
                 ; EXIT: data in temp1
                 ; CHANGES: temp1
                 ; USES: -
                 ; *****************************************************************************
                 EEPROM_read:
00067c 99e1      	sbic	EECR,EEPE	; Wait for completion of previous write
00067d cffe      	rjmp	EEPROM_read		
                 
00067e 9100 00f2 	lds	temp1,EEadr	; get low byte
000680 bb0e      	out	EEARL,temp1
000681 9100 00f3 	lds	temp1,EEadr+1	; get high byte
000683 bb0f      	out	EEARH, temp1	; Set up address (r18:r17) in address register
000684 94f8      	cli
000685 9ae0      	sbi	EECR,EERE	; Start eeprom read by writing EERE
000686 9478      	sei
000687 b30d      	in	temp1,EEDR	; Read data from Data Register
000688 9508      	ret
                 
                 
                 
                 
                 
                 
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny861" register use summary:
r0 :   9 r1 :   3 r2 :   2 r3 :   0 r4 :   0 r5 :   0 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 r13:   0 r14:   0 r15:   0 
r16: 334 r17:  78 r18:  43 r19:  18 r20:   8 r21:   2 r22:  30 r23:   4 
r24:  83 r25:  50 r26:  62 r27:  62 r28:   1 r29:   1 r30:  26 r31:  24 
x  :  18 y  :   5 z  :  11 
Registers used: 22 out of 35 (62.9%)

"ATtiny861" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   4 add   :  15 adiw  :  15 and   :   0 
andi  :   7 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :  23 brcs  :  16 break :   0 breq  :  25 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   0 brmi  :   0 
brne  :  34 brpl  :   0 brsh  :   2 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 cbi   :  19 cbr   :   4 clc   :   6 
clh   :   0 cli   :   5 cln   :   0 clr   :  20 cls   :   0 clt   :   0 
clv   :   0 clz   :   0 com   :   2 cp    :   5 cpc   :   0 cpi   :  41 
cpse  :   0 dec   :  17 eor   :   4 icall :   0 ijmp  :   1 in    :  14 
inc   :   9 ld    :  10 ldd   :   0 ldi   : 215 lds   :  48 lpm   :  14 
lsl   :   5 lsr   :   5 mov   :  32 movw  :   0 neg   :   0 nop   :  16 
or    :   1 ori   :   4 out   :  46 pop   :  51 push  :  50 rcall : 163 
ret   :  67 reti  :   2 rjmp  :  51 rol   :   6 ror   :  19 sbc   :   0 
sbci  :   0 sbi   :  22 sbic  :   3 sbis  :   1 sbiw  :  11 sbr   :   2 
sbrc  :   2 sbrs  :   3 sec   :   7 seh   :   0 sei   :   6 sen   :   0 
ser   :   0 ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   1 
spm   :   0 st    :  18 std   :   0 sts   :  68 sub   :   0 subi  :   4 
swap  :   1 tst   :   2 wdr   :   0 
Instructions used: 57 out of 105 (54.3%)

"ATtiny861" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000d12   2708    606   3314    8192  40.5%
[.dseg] 0x000060 0x0000f3      0    147    147     512  28.7%
[.eseg] 0x000000 0x00000f      0     15     15     512   2.9%

Assembly complete, 0 errors, 2 warnings
