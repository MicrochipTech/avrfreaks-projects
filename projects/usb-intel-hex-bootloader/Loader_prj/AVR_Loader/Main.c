/*****************************************************************************
	For WinAVR gcc-compiler.
* Программа предназначена для контроллера AT90CAN128 и USB конвертора FT245BM.
* Для переноса программы на ATMEGA128 требуются незначительные изменения в программе обслуживания таймера 
* программе инициализации и make файле.
* Код программы начинается с адреса 0xF000 Flash памяти контроллера.
* После занесения кода программы, устанавливаются необходимые для запуска загрузчика fuse
* и биты блокировки доступа
	BOOTSZ=0
	BOOTRST=0
	l2
* Частота кварца - 6 МГц. Питание - 3.3В  
* Программа устанавливает и обслуживает внутренний и внешний сторожевой таймер.
* Используется таймер 0.

  Непременным условием для работы загрузчика является наличие джампера в позиции 3 контактной группы SW
  и подключение кабеля к шине USB во время рестарта контроллера.
  Если это условие не выполняется, то стартует приложение пользователя.
  Если отключить USB кабель во время работы загрузчика, то произойдет переход на приложение пользователя.
    
  Предполагается запуск утилиты load.exe на стороне компьютера с указанием файла для передачи
  в качестве параметра.
  Утилита load.exe, предварительно устанавливает связь с загрузчиком, а затем передает указанный файл.
  Одновременно контролируются сообщения от загрузчика о процессе программирования и обнаруженных ошибках.
  Утилита load.exe делает до 8и попыток получить ответ "OK" со стороны контроллера на запрос "ASK"
  Если ответ получен, то диалог продолжается посылкой запроса "GET" и ожиданием ответа "LET",
  после чего высылается hex файл для программирования.
  
  Фазы работы программы:
  0 - ожидание соединения с кабелем USB
  1 - текстовый диалог с компьютером
  2 - инициализация криптографической гаммы (кодирование не используется)
  3 - считывание, обработка hex записей входного файла и запись страниц Flash
  4 - установка бит защиты, возврат к диалогу с компьютером
  Переход в фазу 0 по сбросу, по обнаружению разрыва с USB из любой фазы в функции connectTest();
  Переход в фазу 1 по обнаружению соединения с USB в функции connectTest()
  или из функций recordRec, recordView по обнаружению ошибки записи или конца файла,
  а также из функции usbWork по time-out ожидания очередного символа и из функции setLock после установки бит защиты
  Переход в фазу 2 происходит из функции dialog при обнаружении попытки загрузки файла
  Переход в фазу 4 происходит из функции recordView или pageWriting  после записи последней страницы
    
* Адрес 0xfff4 использован для чтения и записи в микросхему контроллера шины USB.
* Адрес 0xfff5 использован для чтения состояния интерфейса USB.
* структура регистра 0xfff5 -> d0=-pwren d1=-rxf d2=-txf
* Выходные порты контроллера:
  PD7 - переключение - сброс внешнего сторожевого таймера
* Программа устанавливает и обслуживает внутренний и внешний сторожевой таймер. 

  Для указания линкеру места расположения загрузчика, нужно внести изменение в makefile:
  #LDFLAGS = -Wl,-Map=$(TARGET).map,--cref
  LDFLAGS = -Wl,--section-start=.text=0x1E000,-Map=$(TARGET).map,--cref
****************************************************************************/
//#define TEST            //для удобства отладки фрагментов кода.
/****************************************************************/

#include <avr/wdt.h>
#include "Define/MACRO.H"
#include "Define/defConstant.h"
#include "Define/defGlobal.h"
#include "Define/defFunction.h"

/****************************************************************/

/****************************************************************/
#define SW3     0x04      //позиция перемычки - 3

/****************************************************************/

int main(void)
{
  initCPU();            // Hardware CPU initialization
  /*********************************/ 
  #ifdef TEST           // для проведения отладки небольших фрагментов программы
  {
  
  }
  #endif
  /*********************************/ 
  if(getEXTdata() & SW3)
  {
    wdt_disable();
    release();          // выход в пользовательскую программу по неустановленной перемычке SW3
  }
/****************************************************************/
  while(1)
  {
    timer();			// модификация таймерных переменных и работа с индикатором
    usbWork();			// работа с USB интерфейсом
    connectTest();     	// проверка соединения с шиной USB
    dialog();         	// поддержка диалога с комтьютером
    cryptInit();		// инициализация криптографической гаммы
    recordRec();		// формирование строки записи
    recordView();		// обработка полученной строки
    setLock();			// завершение цикла записи установка бит защиты, сообщение
    wdt_reset();		// сброс внутреннего сторожевого таймера
    EWDT_reset();		// сброс внешнего сторожевого таймера
  }
  return 0;
}
/****************************************************************/
/**************Часто вызываемые функции**************************/
/****************************************************************/
void resetState(unsigned char s)  //сброс установок фазы работы загрузчика
{
  unsigned char i;
  unsigned char len;
  unsigned char* p;
  
  len = sizeof(dw);
  p=(unsigned char*)&dw;
  
  for(i=0; i<len; i++) *(p++)=0;
  dw.phase=s;           //предустановка фазы работы
}
/****************************************************************/
/**************Формирование ответных сообщений*******************/
/****************************************************************/
void ansFault(unsigned char s)  //выдача сообщения об ошибке
{
  if(tx.req) return;      //передатчик чем-то занят
  tx.req=1;
  
  txBuff[0]='\n';
  txBuff[1]='F';
  txBuff[2]='A';
  txBuff[3]='U';
  txBuff[4]='L';
  txBuff[5]='T';
  txBuff[6]=' ';
  switch(s)
  {
    case 0:     //выдача сообщения об ошибке входного формата hex файла при загрузке
    txBuff[7]='F';
    txBuff[8]='O';
    txBuff[9]='R';
    txBuff[10]='M';
    txBuff[11]='A';
    txBuff[12]='T';
    tx.len=13;
    break;
    case 1:     //выдача сообщения об ошибке программирования
    txBuff[7]='P';
    txBuff[8]='R';
    txBuff[9]='O';
    txBuff[10]='G';
    tx.len=11;
    break;
    case 2:     //выдача сообщения об ошибке времени ожидания
    txBuff[7]='W';
    txBuff[8]='A';
    txBuff[9]='I';
    txBuff[10]='T';
    txBuff[11]='I';
    txBuff[12]='N';
    txBuff[13]='G';
    tx.len=14;
    break;
    case 3:
    txBuff[0]='.';
    tx.len=1;
    break;
    case 4:
    txBuff[0]='*';
    tx.len=1;
    break;
    case 5:
    txBuff[0]='?';
    tx.len=1;
    break;
    default:
    tx.len=7;
    break;
  }
}
/****************************************************************/
void ansSuccess(void)       //выдача сообщения об успешном завершении программирования
{
  if(tx.req) return;      //передатчик чем-то занят
  tx.req=1;
  tx.len=8;
  
  txBuff[0]='\n';
  txBuff[1]='S';
  txBuff[2]='U';
  txBuff[3]='C';
  txBuff[4]='C';
  txBuff[5]='E';
  txBuff[6]='S';
  txBuff[7]='S';
}
/****************************************************************/
