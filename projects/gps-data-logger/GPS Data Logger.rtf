{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
{\f16\froman\fcharset238\fprq2 Times New Roman CE;}{\f17\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f19\froman\fcharset161\fprq2 Times New Roman Greek;}{\f20\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f21\froman\fcharset186\fprq2 Times New Roman Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;
\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\widctlpar\adjustright \fs20\lang2057\cgrid \snext0 
Normal;}{\s1\keepn\widctlpar\adjustright \b\fs16\lang2057\cgrid \sbasedon0 \snext0 heading 1;}{\s2\keepn\widctlpar\adjustright \b\fs20\lang2057\cgrid \sbasedon0 \snext0 heading 2;}{\s3\keepn\widctlpar\adjustright \b\lang2057\cgrid \sbasedon0 \snext0 
heading 3;}{\*\cs10 \additive Default Paragraph Font;}{\s15\widctlpar\adjustright \fs16\lang2057\cgrid \sbasedon0 \snext15 Body Text;}{\*\cs16 \additive \ul\cf2 \sbasedon10 Hyperlink;}}{\*\listtable{\list\listtemplateid134807553\listsimple{\listlevel
\levelnfc23\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\fbias0 \fi-360\li360\jclisttab\tx360 }{\listname ;}\listid782848775}}{\*\listoverridetable{\listoverride\listid782848775
\listoverridecount0\ls1}}{\info{\title GPS Data Logger}{\author MSTRANGE}{\operator MSTRANGE}{\creatim\yr2005\mo10\dy14\hr12\min35}{\revtim\yr2005\mo10\dy14\hr12\min37}{\version4}{\edmins0}{\nofpages3}{\nofwords1716}{\nofchars8059}{\*\company none}
{\nofcharsws9723}{\vern113}}\paperw11906\paperh16838 \widowctrl\ftnbj\aenddoc\hyphcaps0\formshade\viewkind1\viewscale100\pgbrdrhead\pgbrdrfoot \fet0\sectd \linex0\headery709\footery709\colsx709\endnhere\sectdefaultcl {\*\pnseclvl1
\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5
\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s3\keepn\widctlpar\outlinelevel2\adjustright \b\lang2057\cgrid {\fs28 GPS Data Logger
\par }\pard\plain \widctlpar\adjustright \fs20\lang2057\cgrid {
\par 
\par The GPS Data Logger records GPS position (longitude, latitude and height) information every second. 
\par This position data is written to flash memory and can be later uploaded to a PC via RS232
\par With a 2MB-memory card, 68 hours of GPS information can be recorded!
\par The system requires next to no additional components apart from the main three described below.
\par 
\par The GPS Data Logger comprises of the following main components.
\par 
\par {\pntext\pard\plain\f3\fs20\cgrid \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {Crumb128 (ATMega128 based board)
\par {\pntext\pard\plain\f3\fs20\cgrid \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {
A GPS Receiver capable of producing NMEA messages
\par {\pntext\pard\plain\f3\fs20\cgrid \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls1\adjustright {Atmel Serial Flash
\par }\pard \widctlpar\adjustright {
\par }\pard\plain \s1\keepn\widctlpar\outlinelevel0\adjustright \b\fs16\lang2057\cgrid {\fs20 Crumb128
\par }\pard\plain \widctlpar\adjustright \fs20\lang2057\cgrid {The ATMega128 resides on the excellent Crumb128 prototyping board (}{\field\flddirty{\*\fldinst { HYPERLINK http://www.chip45.com }{{\*\datafield 
00d0c9ea79f9bace118c8200aa004ba90b02000000170000000f0000007700770077002e006300680069007000340035002e0063006f006d000000e0c9ea79f9bace118c8200aa004ba90b2e00000068007400740070003a002f002f007700770077002e006300680069007000340035002e0063006f006d002f0000000000}
}}{\fldrslt {\cs16\ul\cf2 www.chip45.com}}}{)\tab . This t
iny board (40mm x 30mm) provides the RS232 interface to the PC/PDA and the TTL serial interface to the GPS unit. The Crumb128 is a 5v unit. (Any similar prototype board will do, I like this one because of the size, capabilities and that all AVR pins are a
vailable)
\par 
\par }\pard\plain \s1\keepn\widctlpar\outlinelevel0\adjustright \b\fs16\lang2057\cgrid {\fs20 GPS Receiver}{\b0\fs20 
\par }\pard\plain \widctlpar\adjustright \fs20\lang2057\cgrid {The GPS receiver is the very compact Locsense LS-40CM (}{\field{\*\fldinst { HYPERLINK http://www.locsense.com.tw }{{\*\datafield 
00d0c9ea79f9bace118c8200aa004ba90b0200000017000000140000007700770077002e006c006f006300730065006e00730065002e0063006f006d002e00740077000000e0c9ea79f9bace118c8200aa004ba90b3800000068007400740070003a002f002f007700770077002e006c006f006300730065006e0073006500
2e0063006f006d002e00740077002f0000000000}}}{\fldrslt {\cs16\ul\cf2 www.locsense.com.tw}}}{ ). The \lquote CM\rquote  model has a built in antenna, is 5v, outputs standard NMEA messages and has TTL and RS232 serial outputs
\par It only measures 43mm x 42mm x 13mm
\par Any GPS unit capable of outputting NMEA messages will be suitable.
\par The AVR only receives from the GPS unit, no data is sent to the GPS Receiver, so there is a one wire interface to the AVR.
\par 
\par }\pard\plain \s1\keepn\widctlpar\outlinelevel0\adjustright \b\fs16\lang2057\cgrid {\fs20 Atmel Serial Flash
\par }\pard\plain \widctlpar\adjustright \fs20\lang2057\cgrid {The data flash is the Atmel AT45DCB002, it uses an SPI interface making it really easy to talk to. 
\par It does however require 3v, and as such needs to be powered through its own voltage regulator. The SPI interface is 5v tolerant and thus connects directly to the AVR.
\par It would be an easy take to replace the Atmel Flash with an MMC unit, since they use the SPI interface and also use block buffered I/O. AVR Freaks contains many threads on this.
\par 
\par 
\par }\pard\plain \s2\keepn\widctlpar\outlinelevel1\adjustright \b\fs20\lang2057\cgrid {\fs24 Software Overview
\par }\pard\plain \widctlpar\adjustright \fs20\lang2057\cgrid {
\par WinAVR based project. Project file is for Programmers notepad. Apart from the makefile, it should be buildable with any AVR compiler/environment (?). Its builds with avr-gcc (GCC) 3.4.1
\par 
\par As this device is a dedicated data logger, the user interface is limi
ted. There are just two LEDs that provide feedback about the state of the unit. The LEDs flash according to the error/status code, the meaning of which can be found in ProjectCommon.h. Basically, the green LED flashes each time a valid NMEA sentence is re
ceived and the red flashes error codes.
\par (It would be a simple exercise to add an alphanumeric display showing GPS location information etc. The code is present to do this and has been used, though it\rquote s currently commented out and has been untested for a while).
\par 
\par The software uses Larry Borello\rquote s excellent AvrX kernel (}{\field{\*\fldinst { HYPERLINK http://www.barello.net }{{\*\datafield 
00d0c9ea79f9bace118c8200aa004ba90b0200000017000000100000007700770077002e0062006100720065006c006c006f002e006e00650074000000e0c9ea79f9bace118c8200aa004ba90b3000000068007400740070003a002f002f007700770077002e0062006100720065006c006c006f002e006e00650074002f00
00000000}}}{\fldrslt {\cs16\ul\cf2 www.barello.net}}}{ and through AVRFreaks). This facilitates the multitasking used within the software; one thread controls the user interface and system monito
ring, the other manages the receipt and storage of the GPS data.
\par 
\par AvrX is included in the project. This is pretty much verbatim from Larry\rquote s release. (Although the library will have to be specifically built for anything but the ATMega128 \endash  see the AvrX makefile in the library directory)
\par 
\par The Serial Flash is interfaced through the SPI. The SPI and Flash interface are based upon code posted to AVR Freaks. There is a multithreaded wrapper allowing more that one thread to access the SPI. While this project has 
only one thread using the SPI, I developed it for another project, so provides a reliable SPI interface and follows the goal of reusability!
\par 
\par The GPS unit outputs standard NMEA sentences, so any GPS unit capable of this will do. The Locsense unit has the advantage of TTL serial comms, therefore it can be interfaced to the AVR without any interface glue whatsoever. I\rquote 
ve not used the USB connection on the Crumb128 because I wanted the logger to be able to connect to any PC/PDA without the need for USB drivers etc.
\par 
\par Each NMEA sentence is of the format $<msg type><msg data><CR><LF>
\par 
\par The <msg type> identifies the type of sentence being received from the GPS unit. The logger recognises four types of NMEA sentences; GSA, GSV, RMC and GGA.
\par All are written to their own buffer. This allows sentence data to be received while the current one is being processed.
\par Only GGA and RMC are needed by the Logger to record the location information. The other two are not used but available for future use, if any.
\par 
\par When an NMEA sente
nce is received it is dissected. If the checksum is correct the contents of the sentence are extracted to a temporary data structure. Once both sentences are received the data needed to record the current location is complete, it is then passed to the Fla
sh writing routines.
\par 
\par }\pard\plain \s15\widctlpar\adjustright \fs16\lang2057\cgrid {\fs20 
The code to drive the LCD is present in the project but has been commented out and removed from the makefile. In order to keep the device as small as possible the LCD has been sacrificed. This is fine for my needs where I use the devic
e as a route recorder on my mountain bike trips! Should you want details of the current location, you could always attach a PDA to the Loggers PC serial output.
\par }\pard\plain \widctlpar\adjustright \fs20\lang2057\cgrid {
\par 
\par }\pard\plain \s2\keepn\widctlpar\outlinelevel1\adjustright \b\fs20\lang2057\cgrid {\fs24 Flash Structure
\par }\pard\plain \widctlpar\adjustright \fs20\lang2057\cgrid {
\par The Flash can only be written in blocks, the size of which is Flash type dependent. Because the data arriving from the GPS is a lot smaller that the size of the Flash block size, the data must be buffered by the AVR before it\rquote s written to Flash.

\par 
\par The buffer comprises of a header record and several data records.
\par The header record holds absolute GPS positional (location and height) and time data. The data record holds deltas. In this way, the software makes best use of the available data storage. This dramatically increases the amount of GPS data that can be held.

\par 
\par When the buffer is full, it is written to Flash. With the current data flash type and the GPS outputting positional information every second, the flash is written to every 60 sec\rquote s.
\par A CRC is recorded with the written data to enable error checking when being uploaded to the PC.
\par The data blocks are written sequentially and will wrap when reaching the last block in the memory. The eldest data in flash will be overwritten with the latest.
\par 
\par In addition to the GPS data, the header record identifies the trip to w
hich the block belongs. If the gap between the last block written to Flash and the first one after power up is greater than a predetermined time then a new trip is started. This time is arbitrary and easily altered.
\par 
\par Routines exist to search for specific trips. This information is used at power up and during the upload of trip data to the PC.
\par 
\par 
\par }\pard\plain \s2\keepn\widctlpar\outlinelevel1\adjustright \b\fs20\lang2057\cgrid {\fs24 Data Upload
\par }\pard\plain \widctlpar\adjustright \fs20\lang2057\cgrid {
\par In order to upload the data to the PC, the unit is connected to a PC through RS232. If when powering up, the Logger sees \ldblquote #c\rdblquote  on the serial interface, it will enter command mode. 
\par The user interface maintains a current trip index, this index is initialised with the last trip written to Flash. The current trip can be uploaded.
\par The current trip index can be increased and decreased by user commands and the selected trip uploaded. (See the code in TaskUSerInteface.c for the user commands)
\par 
\par 
\par }\pard\plain \s2\keepn\widctlpar\outlinelevel1\adjustright \b\fs20\lang2057\cgrid {\fs24 Battery Monitoring
\par }\pard\plain \widctlpar\adjustright \fs20\lang2057\cgrid {
\par The s/w contains code to monitor the battery state. Should the voltage fall below a predefined value the LED will flash an error code.
\par This code is commented out. I\rquote ve decided for my needs that it isn\rquote t of much help because the NiMH batteries I\rquote m using give a flat response then die quickly and I probably wont be watching the device when it dies!
\par However, should the system die because of the brownout and there be sufficient power to keep the AVR alive, the reset cause will be displayed on power up (probably just before it dies again!)
\par 
\par The circuit diagram shows the battery monitor circuit. 
\par Simply connect the output from the Flash voltage regulator to the ADC\rquote 
s reference input. This provides a convenient reference voltage against which the battery can be monitored. Also connect the battery to the ADC (channel 3, see the code) through a potential divider.
\par 
\par The battery warning level will have to be calibrated against the battery being used. Modify the code to send/display the current ADC value through to the PC and run the unit down. The actual value may also depend upon the GPS unit and if draws a constant 
current. This will take some experimenting. (I used to have it all working on my prototype and it seemed to work with a 10 second sample rate)
\par 
\par 
\par }\pard\plain \s2\keepn\widctlpar\outlinelevel1\adjustright \b\fs20\lang2057\cgrid {\fs24 Design/Build Notes
\par }\pard\plain \widctlpar\adjustright \fs20\lang2057\cgrid {
\par Depending upon the AVR unit and the GPS unit employed, one or more RS232 interface drivers (
MAX232 etc) may be required. This will require no changes to the software. The Locsense unit has both TTL and RS232 output. In my system, the TTL output goes to the AVR and the RS232 goes to the PC/PDA so can use to provide GPS (NMEA) input to navigation 
programs. If the GPS device has only as one output, the software can be modified to send out the GPS data it receives (this code is present but commented out). Currently the output to the PC is only diagnostic data.
\par 
\par }\pard\plain \s15\widctlpar\adjustright \fs16\lang2057\cgrid {\fs20 If NiMH batteries are used, the charging
 voltage of the batteries is above that tolerated by the electronics. A switch can be used that either connects the battery to the electronics or to the charger lead.
\par 
\par }\pard\plain \widctlpar\adjustright \fs20\lang2057\cgrid {My goal throughout this project has been to keep the unit as small as possible. With the components used, the whole thing fits into a plastic box measuring 80x50x30. 
\par 
\par The external connections to the unit are through a 2.54mm pin header connector glued to the inside edge of the casing \endash  simple and cheap. 
\par 
\par To reduce space,  use surface mount LEDs  glued flush into similar sized holes in the case.
\par 
\par }\pard\plain \s15\widctlpar\adjustright \fs16\lang2057\cgrid {\fs20 The unit can be built without additional PCBs etc. The voltage regulator and capacitors can be soldered in line and placed in heat shrink, as can the LED resistors. 
\par 
\par Because of the simple interfaces between the devices and the fact that they are all off the shelf, means pretty much all the components can be replaced without a great deal of software change (if any).
\par 
\par 
\par }}