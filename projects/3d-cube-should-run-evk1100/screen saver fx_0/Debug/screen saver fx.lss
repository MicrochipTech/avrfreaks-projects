
screen saver fx.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00000d8e  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80002e00  80002e00  00003200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000962c  80003000  80003000  00003400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  8000c62c  8000c62c  0000ca2c  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000170  00000008  8000c630  0000cc08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          00006558  00000178  00000178  00000000  2**2
                  ALLOC
  9 .heap         00008930  000066d0  000066d0  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0000cd78  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00000720  00000000  00000000  0000cda8  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 000015f2  00000000  00000000  0000d4c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00008f79  00000000  00000000  0000eaba  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00001474  00000000  00000000  00017a33  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   000052de  00000000  00000000  00018ea7  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00001170  00000000  00000000  0001e188  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    000024a9  00000000  00000000  0001f2f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    00002882  00000000  00000000  000217a1  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 00762ab9  00000000  00000000  00024023  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00000700  00000000  00000000  00786ae0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf d2 b8 	sub	pc,pc,-11592

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf f2 bc 	sub	pc,pc,-3396

Disassembly of section .text:

80002008 <cprodf_FFIX>:
80002008:	d4 31       	pushm	r0-r7,lr
8000200a:	20 7d       	sub	sp,28
const int COSTABLE_STEP_0_050000_QUADPOS[] = {0x0000FFFF, 0x0000FFE9, 0x0000FFA6, 0x0000FF35, 0x0000FE98, 0x0000FDCF, 0x0000FCD9, 0x0000FBB6, 0x0000FA67, 0x0000F8ED, 0x0000F746, 0x0000F575, 0x0000F378, 0x0000F150, 0x0000EEFF, 0x0000EC83, 0x0000E9DE, 0x0000E70F, 0x0000E419, 0x0000E0FA, 0x0000DDB3, 0x0000DA46, 0x0000D6B3, 0x0000D2F9, 0x0000CF1B, 0x0000CB19, 0x0000C6F3, 0x0000C2A9, 0x0000BE3E, 0x0000B9B2, 0x0000B504, 0x0000B038, 0x0000AB4C, 0x0000A642, 0x0000A11B, 0x00009BD7, 0x00009679, 0x00009100, 0x00008B6D, 0x000085C2, 0x00007FFF, 0x00007A27, 0x00007438, 0x00006E35, 0x0000681F, 0x000061F7, 0x00005BBE, 0x00005574, 0x00004F1B, 0x000048B5, 0x00004241, 0x00003BC3, 0x00003539, 0x00002EA6, 0x0000280C, 0x0000216A, 0x00001AC2, 0x00001415, 0x00000D65, 0x000006B3 };
const int SINTABLE_STEP_0_050000_QUADPOS[] = {0x00000000, 0x000006B3, 0x00000D65, 0x00001415, 0x00001AC2, 0x0000216A, 0x0000280C, 0x00002EA6, 0x00003539, 0x00003BC3, 0x00004241, 0x000048B5, 0x00004F1B, 0x00005574, 0x00005BBE, 0x000061F7, 0x0000681F, 0x00006E35, 0x00007438, 0x00007A27, 0x00008000, 0x000085C2, 0x00008B6D, 0x00009100, 0x00009679, 0x00009BD7, 0x0000A11B, 0x0000A642, 0x0000AB4C, 0x0000B038, 0x0000B504, 0x0000B9B2, 0x0000BE3E, 0x0000C2A9, 0x0000C6F3, 0x0000CB19, 0x0000CF1B, 0x0000D2F9, 0x0000D6B3, 0x0000DA46, 0x0000DDB3, 0x0000E0FA, 0x0000E419, 0x0000E70F, 0x0000E9DE, 0x0000EC83, 0x0000EEFF, 0x0000F150, 0x0000F378, 0x0000F575, 0x0000F746, 0x0000F8ED, 0x0000FA67, 0x0000FBB6, 0x0000FCD9, 0x0000FDCF, 0x0000FE98, 0x0000FF35, 0x0000FFA6, 0x0000FFE9 };

int cprodf_FFIX(int *m1,int l1,int c1,int *m2,int l2,int c2,int *m3);
int cprodf_FFIX(int *m1,int l1,int c1,int *m2,int l2,int c2,int *m3)
{
8000200c:	fa c4 ff c0 	sub	r4,sp,-64
80002010:	50 4b       	stdsp	sp[0x10],r11
80002012:	68 02       	ld.w	r2,r4[0x0]
80002014:	68 18       	ld.w	r8,r4[0x4]
 int i,j,k;
 int r;

 for(i=0;i<l1;i++) {
80002016:	58 0b       	cp.w	r11,0
80002018:	e0 8a 00 3d 	brle	80002092 <cprodf_FFIX+0x8a>
const int ROTZ_001STEPF_FFIX[9]={0x00000100, 0x00000000, 0x00000000, 0x00000000, 0x00000100, 0x00000000, 0x00000000, 0x00000000, 0x00000100};
const int COSTABLE_STEP_0_050000_QUADPOS[] = {0x0000FFFF, 0x0000FFE9, 0x0000FFA6, 0x0000FF35, 0x0000FE98, 0x0000FDCF, 0x0000FCD9, 0x0000FBB6, 0x0000FA67, 0x0000F8ED, 0x0000F746, 0x0000F575, 0x0000F378, 0x0000F150, 0x0000EEFF, 0x0000EC83, 0x0000E9DE, 0x0000E70F, 0x0000E419, 0x0000E0FA, 0x0000DDB3, 0x0000DA46, 0x0000D6B3, 0x0000D2F9, 0x0000CF1B, 0x0000CB19, 0x0000C6F3, 0x0000C2A9, 0x0000BE3E, 0x0000B9B2, 0x0000B504, 0x0000B038, 0x0000AB4C, 0x0000A642, 0x0000A11B, 0x00009BD7, 0x00009679, 0x00009100, 0x00008B6D, 0x000085C2, 0x00007FFF, 0x00007A27, 0x00007438, 0x00006E35, 0x0000681F, 0x000061F7, 0x00005BBE, 0x00005574, 0x00004F1B, 0x000048B5, 0x00004241, 0x00003BC3, 0x00003539, 0x00002EA6, 0x0000280C, 0x0000216A, 0x00001AC2, 0x00001415, 0x00000D65, 0x000006B3 };
const int SINTABLE_STEP_0_050000_QUADPOS[] = {0x00000000, 0x000006B3, 0x00000D65, 0x00001415, 0x00001AC2, 0x0000216A, 0x0000280C, 0x00002EA6, 0x00003539, 0x00003BC3, 0x00004241, 0x000048B5, 0x00004F1B, 0x00005574, 0x00005BBE, 0x000061F7, 0x0000681F, 0x00006E35, 0x00007438, 0x00007A27, 0x00008000, 0x000085C2, 0x00008B6D, 0x00009100, 0x00009679, 0x00009BD7, 0x0000A11B, 0x0000A642, 0x0000AB4C, 0x0000B038, 0x0000B504, 0x0000B9B2, 0x0000BE3E, 0x0000C2A9, 0x0000C6F3, 0x0000CB19, 0x0000CF1B, 0x0000D2F9, 0x0000D6B3, 0x0000DA46, 0x0000DDB3, 0x0000E0FA, 0x0000E419, 0x0000E70F, 0x0000E9DE, 0x0000EC83, 0x0000EEFF, 0x0000F150, 0x0000F378, 0x0000F575, 0x0000F746, 0x0000F8ED, 0x0000FA67, 0x0000FBB6, 0x0000FCD9, 0x0000FDCF, 0x0000FE98, 0x0000FF35, 0x0000FFA6, 0x0000FFE9 };

int cprodf_FFIX(int *m1,int l1,int c1,int *m2,int l2,int c2,int *m3);
int cprodf_FFIX(int *m1,int l1,int c1,int *m2,int l2,int c2,int *m3)
8000201c:	e4 06 15 02 	lsl	r6,r2,0x2
80002020:	50 18       	stdsp	sp[0x4],r8
80002022:	f4 0b 15 02 	lsl	r11,r10,0x2
80002026:	50 5b       	stdsp	sp[0x14],r11
80002028:	50 2c       	stdsp	sp[0x8],r12
8000202a:	30 08       	mov	r8,0
8000202c:	50 38       	stdsp	sp[0xc],r8
{
 int i,j,k;
 int r;

 for(i=0;i<l1;i++) {
  for(j=0;j<c2;j++){
8000202e:	50 69       	stdsp	sp[0x18],r9
const int ROTZ_001STEPF_FFIX[9]={0x00000100, 0x00000000, 0x00000000, 0x00000000, 0x00000100, 0x00000000, 0x00000000, 0x00000000, 0x00000100};
const int COSTABLE_STEP_0_050000_QUADPOS[] = {0x0000FFFF, 0x0000FFE9, 0x0000FFA6, 0x0000FF35, 0x0000FE98, 0x0000FDCF, 0x0000FCD9, 0x0000FBB6, 0x0000FA67, 0x0000F8ED, 0x0000F746, 0x0000F575, 0x0000F378, 0x0000F150, 0x0000EEFF, 0x0000EC83, 0x0000E9DE, 0x0000E70F, 0x0000E419, 0x0000E0FA, 0x0000DDB3, 0x0000DA46, 0x0000D6B3, 0x0000D2F9, 0x0000CF1B, 0x0000CB19, 0x0000C6F3, 0x0000C2A9, 0x0000BE3E, 0x0000B9B2, 0x0000B504, 0x0000B038, 0x0000AB4C, 0x0000A642, 0x0000A11B, 0x00009BD7, 0x00009679, 0x00009100, 0x00008B6D, 0x000085C2, 0x00007FFF, 0x00007A27, 0x00007438, 0x00006E35, 0x0000681F, 0x000061F7, 0x00005BBE, 0x00005574, 0x00004F1B, 0x000048B5, 0x00004241, 0x00003BC3, 0x00003539, 0x00002EA6, 0x0000280C, 0x0000216A, 0x00001AC2, 0x00001415, 0x00000D65, 0x000006B3 };
const int SINTABLE_STEP_0_050000_QUADPOS[] = {0x00000000, 0x000006B3, 0x00000D65, 0x00001415, 0x00001AC2, 0x0000216A, 0x0000280C, 0x00002EA6, 0x00003539, 0x00003BC3, 0x00004241, 0x000048B5, 0x00004F1B, 0x00005574, 0x00005BBE, 0x000061F7, 0x0000681F, 0x00006E35, 0x00007438, 0x00007A27, 0x00008000, 0x000085C2, 0x00008B6D, 0x00009100, 0x00009679, 0x00009BD7, 0x0000A11B, 0x0000A642, 0x0000AB4C, 0x0000B038, 0x0000B504, 0x0000B9B2, 0x0000BE3E, 0x0000C2A9, 0x0000C6F3, 0x0000CB19, 0x0000CF1B, 0x0000D2F9, 0x0000D6B3, 0x0000DA46, 0x0000DDB3, 0x0000E0FA, 0x0000E419, 0x0000E70F, 0x0000E9DE, 0x0000EC83, 0x0000EEFF, 0x0000F150, 0x0000F378, 0x0000F575, 0x0000F746, 0x0000F8ED, 0x0000FA67, 0x0000FBB6, 0x0000FCD9, 0x0000FDCF, 0x0000FE98, 0x0000FF35, 0x0000FFA6, 0x0000FFE9 };

int cprodf_FFIX(int *m1,int l1,int c1,int *m2,int l2,int c2,int *m3);
int cprodf_FFIX(int *m1,int l1,int c1,int *m2,int l2,int c2,int *m3)
80002030:	10 91       	mov	r1,r8
80002032:	50 08       	stdsp	sp[0x0],r8
80002034:	c2 78       	rjmp	80002082 <cprodf_FFIX+0x7a>
80002036:	08 99       	mov	r9,r4
80002038:	00 9c       	mov	r12,r0
8000203a:	02 9b       	mov	r11,r1
8000203c:	40 08       	lddsp	r8,sp[0x0]

 for(i=0;i<l1;i++) {
  for(j=0;j<c2;j++){
   r=0;
   for(k=0;k<c1;k++){   
    r=r+((m1[i*c1+k]*m2[k*c2+j]) >> 8);
8000203e:	72 07       	ld.w	r7,r9[0x0]
80002040:	19 0e       	ld.w	lr,r12++
80002042:	ee 0e 02 4e 	mul	lr,r7,lr
80002046:	a9 4e       	asr	lr,0x8
80002048:	1c 0b       	add	r11,lr
 int r;

 for(i=0;i<l1;i++) {
  for(j=0;j<c2;j++){
   r=0;
   for(k=0;k<c1;k++){   
8000204a:	2f f8       	sub	r8,-1
8000204c:	0c 09       	add	r9,r6
8000204e:	14 38       	cp.w	r8,r10
80002050:	cf 71       	brne	8000203e <cprodf_FFIX+0x36>
    r=r+((m1[i*c1+k]*m2[k*c2+j]) >> 8);
   }
   m3[i*c2+j]=r;
80002052:	06 ab       	st.w	r3++,r11
{
 int i,j,k;
 int r;

 for(i=0;i<l1;i++) {
  for(j=0;j<c2;j++){
80002054:	2f f5       	sub	r5,-1
80002056:	2f c4       	sub	r4,-4
80002058:	04 35       	cp.w	r5,r2
8000205a:	c0 60       	breq	80002066 <cprodf_FFIX+0x5e>
   r=0;
   for(k=0;k<c1;k++){   
8000205c:	58 0a       	cp.w	r10,0
8000205e:	fe 99 ff ec 	brgt	80002036 <cprodf_FFIX+0x2e>
80002062:	02 9b       	mov	r11,r1
80002064:	cf 7b       	rjmp	80002052 <cprodf_FFIX+0x4a>
int cprodf_FFIX(int *m1,int l1,int c1,int *m2,int l2,int c2,int *m3)
{
 int i,j,k;
 int r;

 for(i=0;i<l1;i++) {
80002066:	40 3b       	lddsp	r11,sp[0xc]
80002068:	2f fb       	sub	r11,-1
8000206a:	50 3b       	stdsp	sp[0xc],r11
8000206c:	40 19       	lddsp	r9,sp[0x4]
8000206e:	0c 09       	add	r9,r6
80002070:	50 19       	stdsp	sp[0x4],r9
80002072:	40 28       	lddsp	r8,sp[0x8]
80002074:	40 5b       	lddsp	r11,sp[0x14]
80002076:	16 08       	add	r8,r11
80002078:	50 28       	stdsp	sp[0x8],r8
8000207a:	40 39       	lddsp	r9,sp[0xc]
8000207c:	40 48       	lddsp	r8,sp[0x10]
8000207e:	10 39       	cp.w	r9,r8
80002080:	c0 90       	breq	80002092 <cprodf_FFIX+0x8a>
  for(j=0;j<c2;j++){
80002082:	58 02       	cp.w	r2,0
80002084:	fe 9a ff f1 	brle	80002066 <cprodf_FFIX+0x5e>
80002088:	40 64       	lddsp	r4,sp[0x18]
8000208a:	40 13       	lddsp	r3,sp[0x4]
8000208c:	30 05       	mov	r5,0
const int ROTZ_001STEPF_FFIX[9]={0x00000100, 0x00000000, 0x00000000, 0x00000000, 0x00000100, 0x00000000, 0x00000000, 0x00000000, 0x00000100};
const int COSTABLE_STEP_0_050000_QUADPOS[] = {0x0000FFFF, 0x0000FFE9, 0x0000FFA6, 0x0000FF35, 0x0000FE98, 0x0000FDCF, 0x0000FCD9, 0x0000FBB6, 0x0000FA67, 0x0000F8ED, 0x0000F746, 0x0000F575, 0x0000F378, 0x0000F150, 0x0000EEFF, 0x0000EC83, 0x0000E9DE, 0x0000E70F, 0x0000E419, 0x0000E0FA, 0x0000DDB3, 0x0000DA46, 0x0000D6B3, 0x0000D2F9, 0x0000CF1B, 0x0000CB19, 0x0000C6F3, 0x0000C2A9, 0x0000BE3E, 0x0000B9B2, 0x0000B504, 0x0000B038, 0x0000AB4C, 0x0000A642, 0x0000A11B, 0x00009BD7, 0x00009679, 0x00009100, 0x00008B6D, 0x000085C2, 0x00007FFF, 0x00007A27, 0x00007438, 0x00006E35, 0x0000681F, 0x000061F7, 0x00005BBE, 0x00005574, 0x00004F1B, 0x000048B5, 0x00004241, 0x00003BC3, 0x00003539, 0x00002EA6, 0x0000280C, 0x0000216A, 0x00001AC2, 0x00001415, 0x00000D65, 0x000006B3 };
const int SINTABLE_STEP_0_050000_QUADPOS[] = {0x00000000, 0x000006B3, 0x00000D65, 0x00001415, 0x00001AC2, 0x0000216A, 0x0000280C, 0x00002EA6, 0x00003539, 0x00003BC3, 0x00004241, 0x000048B5, 0x00004F1B, 0x00005574, 0x00005BBE, 0x000061F7, 0x0000681F, 0x00006E35, 0x00007438, 0x00007A27, 0x00008000, 0x000085C2, 0x00008B6D, 0x00009100, 0x00009679, 0x00009BD7, 0x0000A11B, 0x0000A642, 0x0000AB4C, 0x0000B038, 0x0000B504, 0x0000B9B2, 0x0000BE3E, 0x0000C2A9, 0x0000C6F3, 0x0000CB19, 0x0000CF1B, 0x0000D2F9, 0x0000D6B3, 0x0000DA46, 0x0000DDB3, 0x0000E0FA, 0x0000E419, 0x0000E70F, 0x0000E9DE, 0x0000EC83, 0x0000EEFF, 0x0000F150, 0x0000F378, 0x0000F575, 0x0000F746, 0x0000F8ED, 0x0000FA67, 0x0000FBB6, 0x0000FCD9, 0x0000FDCF, 0x0000FE98, 0x0000FF35, 0x0000FFA6, 0x0000FFE9 };

int cprodf_FFIX(int *m1,int l1,int c1,int *m2,int l2,int c2,int *m3);
int cprodf_FFIX(int *m1,int l1,int c1,int *m2,int l2,int c2,int *m3)
8000208e:	40 20       	lddsp	r0,sp[0x8]
80002090:	ce 6b       	rjmp	8000205c <cprodf_FFIX+0x54>
   }
   m3[i*c2+j]=r;
  }
 }
 return(1);
}
80002092:	2f 9d       	sub	sp,-28
80002094:	da 3a       	popm	r0-r7,pc,r12=1
80002096:	d7 03       	nop

80002098 <transforme_C8_FFIX>:

void transforme_C8_FFIX(OBJ3D_C8_FFIX *ob,OBJ3D_C8_FFIX *ob2,int *tsf) {
80002098:	d4 31       	pushm	r0-r7,lr
8000209a:	20 6d       	sub	sp,24
8000209c:	18 97       	mov	r7,r12
8000209e:	16 95       	mov	r5,r11
800020a0:	14 90       	mov	r0,r10
 int i,k;
 int res[3],tmp[3];
 ob2->zoom=ob->zoom;
800020a2:	78 08       	ld.w	r8,r12[0x0]
800020a4:	97 08       	st.w	r11[0x0],r8
   for(i=0;i<ob->nbpoints;i++) {
800020a6:	78 48       	ld.w	r8,r12[0x10]
800020a8:	58 08       	cp.w	r8,0
800020aa:	c3 70       	breq	80002118 <transforme_C8_FFIX+0x80>
800020ac:	30 06       	mov	r6,0
800020ae:	0c 94       	mov	r4,r6
800020b0:	1a 93       	mov	r3,sp
800020b2:	0c 92       	mov	r2,r6
  
    for(k=0;k<3;k++){
     tmp[k]=((int)(ob->ob[k*ob->nbpoints+i])<<8);
    }
    cprodf_FFIX(tsf,3,3,tmp,3,1,res);
800020b4:	fa c1 ff f4 	sub	r1,sp,-12
800020b8:	c2 d8       	rjmp	80002112 <transforme_C8_FFIX+0x7a>
 int res[3],tmp[3];
 ob2->zoom=ob->zoom;
   for(i=0;i<ob->nbpoints;i++) {
  
    for(k=0;k<3;k++){
     tmp[k]=((int)(ob->ob[k*ob->nbpoints+i])<<8);
800020ba:	6e 4a       	ld.w	r10,r7[0x10]
800020bc:	f0 0a 02 4a 	mul	r10,r8,r10
800020c0:	6e 1b       	ld.w	r11,r7[0x4]
800020c2:	0c 0b       	add	r11,r6
800020c4:	f6 0a 06 0a 	ld.sb	r10,r11[r10]
800020c8:	a9 6a       	lsl	r10,0x8
800020ca:	12 aa       	st.w	r9++,r10
 int i,k;
 int res[3],tmp[3];
 ob2->zoom=ob->zoom;
   for(i=0;i<ob->nbpoints;i++) {
  
    for(k=0;k<3;k++){
800020cc:	2f f8       	sub	r8,-1
800020ce:	58 38       	cp.w	r8,3
800020d0:	cf 51       	brne	800020ba <transforme_C8_FFIX+0x22>
     tmp[k]=((int)(ob->ob[k*ob->nbpoints+i])<<8);
    }
    cprodf_FFIX(tsf,3,3,tmp,3,1,res);
800020d2:	1a d1       	st.w	--sp,r1
800020d4:	30 18       	mov	r8,1
800020d6:	1a d8       	st.w	--sp,r8
800020d8:	30 38       	mov	r8,3
800020da:	06 99       	mov	r9,r3
800020dc:	10 9a       	mov	r10,r8
800020de:	10 9b       	mov	r11,r8
800020e0:	00 9c       	mov	r12,r0
800020e2:	f0 1f 00 0f 	mcall	8000211c <transforme_C8_FFIX+0x84>
800020e6:	fa c9 ff ec 	sub	r9,sp,-20
800020ea:	04 98       	mov	r8,r2
800020ec:	2f ed       	sub	sp,-8
  
    for(k=0;k<3;k++) {
     ob2->ob[k*ob->nbpoints+i]=(signed char)(res[k]>>8);
800020ee:	6e 4a       	ld.w	r10,r7[0x10]
800020f0:	f0 0a 02 4a 	mul	r10,r8,r10
800020f4:	6a 1b       	ld.w	r11,r5[0x4]
800020f6:	0c 0b       	add	r11,r6
800020f8:	13 0c       	ld.w	r12,r9++
800020fa:	a9 4c       	asr	r12,0x8
800020fc:	f6 0a 0b 0c 	st.b	r11[r10],r12
    for(k=0;k<3;k++){
     tmp[k]=((int)(ob->ob[k*ob->nbpoints+i])<<8);
    }
    cprodf_FFIX(tsf,3,3,tmp,3,1,res);
  
    for(k=0;k<3;k++) {
80002100:	2f f8       	sub	r8,-1
80002102:	58 38       	cp.w	r8,3
80002104:	cf 51       	brne	800020ee <transforme_C8_FFIX+0x56>

void transforme_C8_FFIX(OBJ3D_C8_FFIX *ob,OBJ3D_C8_FFIX *ob2,int *tsf) {
 int i,k;
 int res[3],tmp[3];
 ob2->zoom=ob->zoom;
   for(i=0;i<ob->nbpoints;i++) {
80002106:	2f f4       	sub	r4,-1
80002108:	08 96       	mov	r6,r4
8000210a:	6e 48       	ld.w	r8,r7[0x10]
8000210c:	08 38       	cp.w	r8,r4
8000210e:	e0 88 00 05 	brls	80002118 <transforme_C8_FFIX+0x80>
80002112:	06 99       	mov	r9,r3
80002114:	04 98       	mov	r8,r2
80002116:	cd 2b       	rjmp	800020ba <transforme_C8_FFIX+0x22>
    for(k=0;k<3;k++) {
     ob2->ob[k*ob->nbpoints+i]=(signed char)(res[k]>>8);
    }
  
  }
}
80002118:	2f ad       	sub	sp,-24
8000211a:	d8 32       	popm	r0-r7,pc
8000211c:	80 00       	ld.sh	r0,r0[0x0]
8000211e:	20 08       	sub	r8,0

80002120 <mrot_C8_FULL_FFIX>:

void mrot_C8_FULL_FFIX(int *m,int teta,int a,int b,int c)
{
80002120:	eb cd 40 fc 	pushm	r2-r7,lr
    int costeta, sinteta;
        
     if((teta<COSTABLENBELTS)) {
80002124:	16 9e       	mov	lr,r11
80002126:	e0 4b 00 3b 	cp.w	r11,59
8000212a:	e0 8b 00 09 	brhi	8000213c <mrot_C8_FULL_FFIX+0x1c>
      costeta= COSTABLE_STEP_0_050000_QUADPOS[teta];
8000212e:	4c 8e       	lddpc	lr,8000224c <mrot_C8_FULL_FFIX+0x12c>
80002130:	fc 0b 03 2e 	ld.w	lr,lr[r11<<0x2]
      sinteta= SINTABLE_STEP_0_050000_QUADPOS[teta];
80002134:	4c 77       	lddpc	r7,80002250 <mrot_C8_FULL_FFIX+0x130>
80002136:	ee 0b 03 27 	ld.w	r7,r7[r11<<0x2]
8000213a:	c3 c8       	rjmp	800021b2 <mrot_C8_FULL_FFIX+0x92>
     } else if(teta==COSTABLENBELTS) {
8000213c:	e0 4b 00 3c 	cp.w	r11,60
80002140:	c0 51       	brne	8000214a <mrot_C8_FULL_FFIX+0x2a>
80002142:	e0 67 ff ff 	mov	r7,65535
80002146:	30 0e       	mov	lr,0
80002148:	c3 58       	rjmp	800021b2 <mrot_C8_FULL_FFIX+0x92>
       costeta=0;
       sinteta=FIXEDBITPRECSCALE-1;
     } else if((teta<2*COSTABLENBELTS)) {
8000214a:	e0 4b 00 77 	cp.w	r11,119
8000214e:	e0 8b 00 0c 	brhi	80002166 <mrot_C8_FULL_FFIX+0x46>
      costeta=-COSTABLE_STEP_0_050000_QUADPOS[COSTABLENBELTS-(teta-COSTABLENBELTS)];
80002152:	f6 0b 11 78 	rsub	r11,r11,120
80002156:	4b ee       	lddpc	lr,8000224c <mrot_C8_FULL_FFIX+0x12c>
80002158:	fc 0b 03 2e 	ld.w	lr,lr[r11<<0x2]
8000215c:	5c 3e       	neg	lr
      sinteta= SINTABLE_STEP_0_050000_QUADPOS[COSTABLENBELTS-(teta-COSTABLENBELTS)];
8000215e:	4b d7       	lddpc	r7,80002250 <mrot_C8_FULL_FFIX+0x130>
80002160:	ee 0b 03 27 	ld.w	r7,r7[r11<<0x2]
80002164:	c2 78       	rjmp	800021b2 <mrot_C8_FULL_FFIX+0x92>
     } else if(teta==2*COSTABLENBELTS) {
80002166:	e0 4b 00 78 	cp.w	r11,120
8000216a:	c0 51       	brne	80002174 <mrot_C8_FULL_FFIX+0x54>
8000216c:	30 07       	mov	r7,0
8000216e:	fe 7e 00 01 	mov	lr,-65535
80002172:	c2 08       	rjmp	800021b2 <mrot_C8_FULL_FFIX+0x92>
       costeta=-(FIXEDBITPRECSCALE-1);
       sinteta=0;
     } else if((teta<3*COSTABLENBELTS)) {
80002174:	e0 4b 00 b3 	cp.w	r11,179
80002178:	e0 8b 00 0c 	brhi	80002190 <mrot_C8_FULL_FFIX+0x70>
       costeta=-COSTABLE_STEP_0_050000_QUADPOS[teta-2*COSTABLENBELTS];
8000217c:	27 8b       	sub	r11,120
8000217e:	4b 4e       	lddpc	lr,8000224c <mrot_C8_FULL_FFIX+0x12c>
80002180:	fc 0b 03 2e 	ld.w	lr,lr[r11<<0x2]
80002184:	5c 3e       	neg	lr
       sinteta=-SINTABLE_STEP_0_050000_QUADPOS[teta-2*COSTABLENBELTS];
80002186:	4b 37       	lddpc	r7,80002250 <mrot_C8_FULL_FFIX+0x130>
80002188:	ee 0b 03 27 	ld.w	r7,r7[r11<<0x2]
8000218c:	5c 37       	neg	r7
8000218e:	c1 28       	rjmp	800021b2 <mrot_C8_FULL_FFIX+0x92>
     } else if((teta == 3*COSTABLENBELTS)) {
80002190:	e0 4b 00 b4 	cp.w	r11,180
80002194:	c0 51       	brne	8000219e <mrot_C8_FULL_FFIX+0x7e>
80002196:	fe 77 00 01 	mov	r7,-65535
8000219a:	30 0e       	mov	lr,0
8000219c:	c0 b8       	rjmp	800021b2 <mrot_C8_FULL_FFIX+0x92>
       costeta=0;
       sinteta=-(FIXEDBITPRECSCALE-1);
     } else {
      costeta= COSTABLE_STEP_0_050000_QUADPOS[COSTABLENBELTS-(teta-3*COSTABLENBELTS)];
8000219e:	e0 6b 00 f0 	mov	r11,240
800021a2:	1c 1b       	sub	r11,lr
800021a4:	4a ae       	lddpc	lr,8000224c <mrot_C8_FULL_FFIX+0x12c>
800021a6:	fc 0b 03 2e 	ld.w	lr,lr[r11<<0x2]
      sinteta=-SINTABLE_STEP_0_050000_QUADPOS[COSTABLENBELTS-(teta-3*COSTABLENBELTS)];
800021aa:	4a a7       	lddpc	r7,80002250 <mrot_C8_FULL_FFIX+0x130>
800021ac:	ee 0b 03 27 	ld.w	r7,r7[r11<<0x2]
800021b0:	5c 37       	neg	r7
     }
     
     int term1;
    
     term1=(((((MAXPOSVAL-costeta)*((a*a)>>VECPREC)))))>>VECPREC;
800021b2:	e0 6b ff ff 	mov	r11,65535
800021b6:	1c 1b       	sub	r11,lr
     m[0]=(int)(((           term1 + costeta)                         ))>>8;
800021b8:	f4 0a 02 46 	mul	r6,r10,r10
800021bc:	af 56       	asr	r6,0xf
800021be:	f6 06 02 46 	mul	r6,r11,r6
800021c2:	af 56       	asr	r6,0xf
800021c4:	1c 06       	add	r6,lr
800021c6:	a9 46       	asr	r6,0x8
800021c8:	99 06       	st.w	r12[0x0],r6
    
     term1=(((((MAXPOSVAL-costeta)*((a*b)>>VECPREC)))));
800021ca:	f2 0a 02 43 	mul	r3,r9,r10
800021ce:	af 53       	asr	r3,0xf
800021d0:	f6 03 02 43 	mul	r3,r11,r3
     m[1]=(int)((            term1 -(c*sinteta)   ))>>VECPREC>>8;
800021d4:	ee 08 02 44 	mul	r4,r7,r8
800021d8:	e6 04 01 06 	sub	r6,r3,r4
800021dc:	b7 56       	asr	r6,0x17
800021de:	99 16       	st.w	r12[0x4],r6
    
     term1=(((((MAXPOSVAL-costeta)*((a*c)>>VECPREC)))));
800021e0:	f0 0a 02 45 	mul	r5,r8,r10
800021e4:	af 55       	asr	r5,0xf
800021e6:	f6 05 02 45 	mul	r5,r11,r5
     m[2]=(int)(((           term1 +(b*sinteta))  ))>>VECPREC>>8;
800021ea:	ee 09 02 46 	mul	r6,r7,r9
800021ee:	ea 06 00 02 	add	r2,r5,r6
800021f2:	b7 52       	asr	r2,0x17
800021f4:	99 22       	st.w	r12[0x8],r2
    
     term1=(((((MAXPOSVAL-costeta)*((a*b)>>VECPREC)))));
     m[3]=(int)(((           term1 +(c*sinteta))  ))>>VECPREC>>8;
800021f6:	e6 04 00 04 	add	r4,r3,r4
800021fa:	b7 54       	asr	r4,0x17
800021fc:	99 34       	st.w	r12[0xc],r4
    
     term1=(((((MAXPOSVAL-costeta)*((b*b)>>VECPREC)))))>>VECPREC;
     m[4]=(int)(((           term1 +costeta)	          ))>>8;
800021fe:	f2 09 02 44 	mul	r4,r9,r9
80002202:	af 54       	asr	r4,0xf
80002204:	f6 04 02 44 	mul	r4,r11,r4
80002208:	af 54       	asr	r4,0xf
8000220a:	1c 04       	add	r4,lr
8000220c:	a9 44       	asr	r4,0x8
8000220e:	99 44       	st.w	r12[0x10],r4
    
     term1=(((((MAXPOSVAL-costeta)*((b*c)>>VECPREC)))));
80002210:	f0 09 02 49 	mul	r9,r8,r9
80002214:	af 59       	asr	r9,0xf
80002216:	f6 09 02 49 	mul	r9,r11,r9
     m[5]=(int)(((           term1 -(a*sinteta))  ))>>VECPREC>>8;
8000221a:	ee 0a 02 4a 	mul	r10,r7,r10
8000221e:	f2 0a 01 07 	sub	r7,r9,r10
80002222:	b7 57       	asr	r7,0x17
80002224:	99 57       	st.w	r12[0x14],r7
    
     term1=(((((MAXPOSVAL-costeta)*((a*c)>>VECPREC)))));
     m[6]=(int)(((           term1 -(b*sinteta))  ))>>VECPREC>>8;
80002226:	ea 06 01 06 	sub	r6,r5,r6
8000222a:	b7 56       	asr	r6,0x17
8000222c:	99 66       	st.w	r12[0x18],r6
    
     term1=(((((MAXPOSVAL-costeta)*((b*c)>>VECPREC)))));
     m[7]=(int)(((           term1 +(a*sinteta))  ))>>VECPREC>>8;
8000222e:	f2 0a 00 0a 	add	r10,r9,r10
80002232:	b7 5a       	asr	r10,0x17
80002234:	99 7a       	st.w	r12[0x1c],r10
    
     term1=(((((MAXPOSVAL-costeta)*((c*c)>>VECPREC)))))>>VECPREC;
     m[8]=(int)((            term1 +costeta	          ))>>8;
80002236:	b1 38       	mul	r8,r8
80002238:	af 58       	asr	r8,0xf
8000223a:	b1 3b       	mul	r11,r8
8000223c:	af 5b       	asr	r11,0xf
8000223e:	f6 0e 00 0e 	add	lr,r11,lr
80002242:	a9 4e       	asr	lr,0x8
80002244:	99 8e       	st.w	r12[0x20],lr
}
80002246:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000224a:	00 00       	add	r0,r0
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	30 f0       	mov	r0,15
80002250:	80 00       	ld.sh	r0,r0[0x0]
80002252:	30 00       	mov	r0,0

80002254 <lcd_nokia_send>:
  gpio_set_gpio_pin(LCD_NOKIA_RESET_PIN);
}

void lcd_nokia_send(unsigned char type, unsigned short data);
void lcd_nokia_send(unsigned char type, unsigned short data)
{
80002254:	d4 01       	pushm	lr
    if(type)
80002256:	58 0c       	cp.w	r12,0
80002258:	c0 20       	breq	8000225c <lcd_nokia_send+0x8>
    {
        data |=0x0100;                                      
8000225a:	a9 ab       	sbr	r11,0x8
    }
    spi_write( LCD_NOKIA_SPI, (unsigned short) data );
8000225c:	5c 7b       	castu.h	r11
8000225e:	fe 7c 24 00 	mov	r12,-56320
80002262:	f0 1f 00 02 	mcall	80002268 <lcd_nokia_send+0x14>
}
80002266:	d8 02       	popm	pc
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	2d 2a       	sub	r10,-46

8000226c <lcd_nokia_putbuffer>:
  lcd_nokia_send(LCDCommand,RAMWRP);
  lcd_nokia_send(LCDData,color);
}

void lcd_nokia_putbuffer(unsigned char *buffer)
{
8000226c:	eb cd 40 e0 	pushm	r5-r7,lr
80002270:	18 97       	mov	r7,r12
  
  lcd_nokia_send(LCDCommand,PASETP);
80002272:	32 bb       	mov	r11,43
80002274:	30 0c       	mov	r12,0
80002276:	f0 1f 00 1f 	mcall	800022f0 <lcd_nokia_putbuffer+0x84>
  lcd_nokia_send(LCDData,2);
8000227a:	30 2b       	mov	r11,2
8000227c:	30 1c       	mov	r12,1
8000227e:	f0 1f 00 1d 	mcall	800022f0 <lcd_nokia_putbuffer+0x84>
  lcd_nokia_send(LCDData,SCR_WIDE);
80002282:	e0 6b 00 84 	mov	r11,132
80002286:	30 1c       	mov	r12,1
80002288:	f0 1f 00 1a 	mcall	800022f0 <lcd_nokia_putbuffer+0x84>

  lcd_nokia_send(LCDCommand,CASETP);
8000228c:	32 ab       	mov	r11,42
8000228e:	30 0c       	mov	r12,0
80002290:	f0 1f 00 18 	mcall	800022f0 <lcd_nokia_putbuffer+0x84>
  lcd_nokia_send(LCDData,0);
80002294:	30 0b       	mov	r11,0
80002296:	30 1c       	mov	r12,1
80002298:	f0 1f 00 16 	mcall	800022f0 <lcd_nokia_putbuffer+0x84>
  lcd_nokia_send(LCDData,SCR_HEIGHT-1);
8000229c:	e0 6b 00 83 	mov	r11,131
800022a0:	30 1c       	mov	r12,1
800022a2:	f0 1f 00 14 	mcall	800022f0 <lcd_nokia_putbuffer+0x84>

  lcd_nokia_send(LCDCommand,RAMWRP);
800022a6:	32 cb       	mov	r11,44
800022a8:	30 0c       	mov	r12,0
800022aa:	f0 1f 00 12 	mcall	800022f0 <lcd_nokia_putbuffer+0x84>
800022ae:	30 06       	mov	r6,0
  for(int i = 0; i < (SCR_WIDE * SCR_HEIGHT); i++) {
	  lcd_nokia_send(LCDData, ((buffer[i] & 0b11100000) >> 5) * 2);
800022b0:	30 15       	mov	r5,1
800022b2:	0f 8b       	ld.ub	r11,r7[0x0]
800022b4:	a5 8b       	lsr	r11,0x4
800022b6:	e2 1b 00 0e 	andl	r11,0xe,COH
800022ba:	0a 9c       	mov	r12,r5
800022bc:	f0 1f 00 0d 	mcall	800022f0 <lcd_nokia_putbuffer+0x84>
	  lcd_nokia_send(LCDData, ((buffer[i] & 0b00011100) >> 2) * 2);
800022c0:	0f 8b       	ld.ub	r11,r7[0x0]
800022c2:	f7 db c0 43 	bfextu	r11,r11,0x2,0x3
800022c6:	a1 7b       	lsl	r11,0x1
800022c8:	0a 9c       	mov	r12,r5
800022ca:	f0 1f 00 0a 	mcall	800022f0 <lcd_nokia_putbuffer+0x84>
	  lcd_nokia_send(LCDData, (buffer[i] & 0b00000011) * 5);
800022ce:	0f 38       	ld.ub	r8,r7++
800022d0:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800022d4:	f0 09 15 02 	lsl	r9,r8,0x2
800022d8:	12 08       	add	r8,r9
800022da:	f7 d8 c0 10 	bfextu	r11,r8,0x0,0x10
800022de:	0a 9c       	mov	r12,r5
800022e0:	f0 1f 00 04 	mcall	800022f0 <lcd_nokia_putbuffer+0x84>
  lcd_nokia_send(LCDCommand,CASETP);
  lcd_nokia_send(LCDData,0);
  lcd_nokia_send(LCDData,SCR_HEIGHT-1);

  lcd_nokia_send(LCDCommand,RAMWRP);
  for(int i = 0; i < (SCR_WIDE * SCR_HEIGHT); i++) {
800022e4:	2f f6       	sub	r6,-1
800022e6:	e0 46 44 10 	cp.w	r6,17424
800022ea:	ce 41       	brne	800022b2 <lcd_nokia_putbuffer+0x46>
	  lcd_nokia_send(LCDData, ((buffer[i] & 0b11100000) >> 5) * 2);
	  lcd_nokia_send(LCDData, ((buffer[i] & 0b00011100) >> 2) * 2);
	  lcd_nokia_send(LCDData, (buffer[i] & 0b00000011) * 5);
  }
}
800022ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	22 54       	sub	r4,37

800022f4 <lcd_nokia_reset_high>:
  gpio_clr_gpio_pin(LCD_NOKIA_RESET_PIN);
}

void lcd_nokia_reset_high(void);
void lcd_nokia_reset_high(void)
{
800022f4:	d4 01       	pushm	lr
  gpio_enable_gpio_pin(LCD_NOKIA_RESET_PIN);
800022f6:	30 9c       	mov	r12,9
800022f8:	f0 1f 00 03 	mcall	80002304 <lcd_nokia_reset_high+0x10>
  gpio_set_gpio_pin(LCD_NOKIA_RESET_PIN);
800022fc:	30 9c       	mov	r12,9
800022fe:	f0 1f 00 03 	mcall	80002308 <lcd_nokia_reset_high+0x14>
}
80002302:	d8 02       	popm	pc
80002304:	80 00       	ld.sh	r0,r0[0x0]
80002306:	29 a8       	sub	r8,-102
80002308:	80 00       	ld.sh	r0,r0[0x0]
8000230a:	29 c0       	sub	r0,-100

8000230c <lcd_nokia_reset_low>:
  spi_unselectChip(LCD_NOKIA_SPI, LCD_NOKIA_SPI_NPCS);
}

void lcd_nokia_reset_low(void);
void lcd_nokia_reset_low(void)
{
8000230c:	d4 01       	pushm	lr
  gpio_enable_gpio_pin(LCD_NOKIA_RESET_PIN);
8000230e:	30 9c       	mov	r12,9
80002310:	f0 1f 00 03 	mcall	8000231c <lcd_nokia_reset_low+0x10>
  gpio_clr_gpio_pin(LCD_NOKIA_RESET_PIN);
80002314:	30 9c       	mov	r12,9
80002316:	f0 1f 00 03 	mcall	80002320 <lcd_nokia_reset_low+0x14>
}
8000231a:	d8 02       	popm	pc
8000231c:	80 00       	ld.sh	r0,r0[0x0]
8000231e:	29 a8       	sub	r8,-102
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	29 dc       	sub	r12,-99

80002324 <lcd_nokia_select>:

extern avr32_spi_t *spi ;                 //!< SPI Instance dedicated for LCD Display

void lcd_nokia_select(void);
void lcd_nokia_select(void)
{
80002324:	d4 01       	pushm	lr
  spi_selectChip(LCD_NOKIA_SPI, LCD_NOKIA_SPI_NPCS);
80002326:	30 0b       	mov	r11,0
80002328:	fe 7c 24 00 	mov	r12,-56320
8000232c:	f0 1f 00 02 	mcall	80002334 <lcd_nokia_select+0x10>
}
80002330:	d8 02       	popm	pc
80002332:	00 00       	add	r0,r0
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	2c 20       	sub	r0,-62

80002338 <lcd_nokia_init>:
	  lcd_nokia_send(LCDData, (buffer[i] & 0b00000011) * 5);
  }
}

void lcd_nokia_init(void)
{
80002338:	d4 01       	pushm	lr
    lcd_nokia_select();
8000233a:	f0 1f 00 29 	mcall	800023dc <lcd_nokia_init+0xa4>

    lcd_nokia_reset_low();
8000233e:	f0 1f 00 29 	mcall	800023e0 <lcd_nokia_init+0xa8>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002342:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002346:	f0 ca e9 80 	sub	r10,r8,-5760
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000234a:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000234e:	14 38       	cp.w	r8,r10
80002350:	e0 88 00 08 	brls	80002360 <lcd_nokia_init+0x28>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002354:	12 38       	cp.w	r8,r9
80002356:	fe 98 ff fa 	brls	8000234a <lcd_nokia_init+0x12>
8000235a:	12 3a       	cp.w	r10,r9
8000235c:	c2 a3       	brcs	800023b0 <lcd_nokia_init+0x78>
8000235e:	cf 6b       	rjmp	8000234a <lcd_nokia_init+0x12>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002360:	12 38       	cp.w	r8,r9
80002362:	e0 8b 00 27 	brhi	800023b0 <lcd_nokia_init+0x78>
80002366:	12 3a       	cp.w	r10,r9
80002368:	c2 43       	brcs	800023b0 <lcd_nokia_init+0x78>
8000236a:	cf 0b       	rjmp	8000234a <lcd_nokia_init+0x12>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000236c:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002370:	14 38       	cp.w	r8,r10
80002372:	e0 88 00 08 	brls	80002382 <lcd_nokia_init+0x4a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002376:	12 38       	cp.w	r8,r9
80002378:	fe 98 ff fa 	brls	8000236c <lcd_nokia_init+0x34>
8000237c:	12 3a       	cp.w	r10,r9
8000237e:	c2 03       	brcs	800023be <lcd_nokia_init+0x86>
80002380:	cf 6b       	rjmp	8000236c <lcd_nokia_init+0x34>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002382:	12 38       	cp.w	r8,r9
80002384:	e0 8b 00 1d 	brhi	800023be <lcd_nokia_init+0x86>
80002388:	12 3a       	cp.w	r10,r9
8000238a:	c1 a3       	brcs	800023be <lcd_nokia_init+0x86>
8000238c:	cf 0b       	rjmp	8000236c <lcd_nokia_init+0x34>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000238e:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002392:	14 38       	cp.w	r8,r10
80002394:	e0 88 00 08 	brls	800023a4 <lcd_nokia_init+0x6c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002398:	12 38       	cp.w	r8,r9
8000239a:	fe 98 ff fa 	brls	8000238e <lcd_nokia_init+0x56>
8000239e:	12 3a       	cp.w	r10,r9
800023a0:	c1 83       	brcs	800023d0 <lcd_nokia_init+0x98>
800023a2:	cf 6b       	rjmp	8000238e <lcd_nokia_init+0x56>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800023a4:	12 38       	cp.w	r8,r9
800023a6:	e0 8b 00 15 	brhi	800023d0 <lcd_nokia_init+0x98>
800023aa:	12 3a       	cp.w	r10,r9
800023ac:	c1 23       	brcs	800023d0 <lcd_nokia_init+0x98>
800023ae:	cf 0b       	rjmp	8000238e <lcd_nokia_init+0x56>
    delay_ms(50);   //fake! 50ms needed
    lcd_nokia_reset_high();
800023b0:	f0 1f 00 0d 	mcall	800023e4 <lcd_nokia_init+0xac>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800023b4:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800023b8:	f0 ca e9 80 	sub	r10,r8,-5760
800023bc:	cd 8b       	rjmp	8000236c <lcd_nokia_init+0x34>
    delay_ms(50);   //fake! 50ms needed
    
    lcd_nokia_send(LCDCommand,SLEEPOUT); // Sleep out
800023be:	31 1b       	mov	r11,17
800023c0:	30 0c       	mov	r12,0
800023c2:	f0 1f 00 0a 	mcall	800023e8 <lcd_nokia_init+0xb0>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800023c6:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800023ca:	f0 ca fb 80 	sub	r10,r8,-1152
800023ce:	ce 0b       	rjmp	8000238e <lcd_nokia_init+0x56>
    delay_ms(10);
	 
    lcd_nokia_send(LCDCommand,DISPON);		// Display ON
800023d0:	32 9b       	mov	r11,41
800023d2:	30 0c       	mov	r12,0
800023d4:	f0 1f 00 05 	mcall	800023e8 <lcd_nokia_init+0xb0>
}
800023d8:	d8 02       	popm	pc
800023da:	00 00       	add	r0,r0
800023dc:	80 00       	ld.sh	r0,r0[0x0]
800023de:	23 24       	sub	r4,50
800023e0:	80 00       	ld.sh	r0,r0[0x0]
800023e2:	23 0c       	sub	r12,48
800023e4:	80 00       	ld.sh	r0,r0[0x0]
800023e6:	22 f4       	sub	r4,47
800023e8:	80 00       	ld.sh	r0,r0[0x0]
800023ea:	22 54       	sub	r4,37

800023ec <update_faces>:



void update_faces(void);
void update_faces()
{
800023ec:	eb cd 40 f8 	pushm	r3-r7,lr
800023f0:	20 6d       	sub	sp,24
  // Here we considere on z coordinate of tempcenters object.
  #define zbuffer ((signed char *)&tmpcenters.ob[FACE_NUMBER*2 + 0])

  int Faces[6] = {0, 1, 2, 3, 4, 5};
800023f2:	4b b9       	lddpc	r9,800024dc <update_faces+0xf0>
800023f4:	f2 ea 00 00 	ld.d	r10,r9[0]
800023f8:	fa eb 00 00 	st.d	sp[0],r10
800023fc:	f2 ea 00 08 	ld.d	r10,r9[8]
80002400:	fa eb 00 08 	st.d	sp[8],r10
80002404:	f2 ea 00 10 	ld.d	r10,r9[16]
80002408:	fa eb 00 10 	st.d	sp[16],r10
  do
  {
    swap = 0;
    for (i = 0; i < 5; i++)
      // If Next Buffer to display has an z value higher than current one, swap current z with new z face value and stop
      if (zbuffer[Faces[i]] > zbuffer[Faces[i+1]])
8000240c:	4b 58       	lddpc	r8,800024e0 <update_faces+0xf4>
8000240e:	70 1e       	ld.w	lr,r8[0x4]
80002410:	30 08       	mov	r8,0
80002412:	10 9a       	mov	r10,r8
        Faces[i] = Faces[i+1];
        Faces[i+1] = temp;
        swap = 1;
      }
  }
  while (swap);
80002414:	10 95       	mov	r5,r8
80002416:	10 94       	mov	r4,r8
      // If Next Buffer to display has an z value higher than current one, swap current z with new z face value and stop
      if (zbuffer[Faces[i]] > zbuffer[Faces[i+1]])
      {
        temp = Faces[i];
        Faces[i] = Faces[i+1];
        Faces[i+1] = temp;
80002418:	30 13       	mov	r3,1
8000241a:	c2 78       	rjmp	80002468 <update_faces+0x7c>
  do
  {
    swap = 0;
    for (i = 0; i < 5; i++)
      // If Next Buffer to display has an z value higher than current one, swap current z with new z face value and stop
      if (zbuffer[Faces[i]] > zbuffer[Faces[i+1]])
8000241c:	fa cb ff e8 	sub	r11,sp,-24
80002420:	f6 08 00 29 	add	r9,r11,r8<<0x2
80002424:	f2 fb ff e8 	ld.w	r11,r9[-24]
80002428:	f0 c9 ff ff 	sub	r9,r8,-1
8000242c:	fa c6 ff e8 	sub	r6,sp,-24
80002430:	ec 09 00 2c 	add	r12,r6,r9<<0x2
80002434:	f8 fc ff e8 	ld.w	r12,r12[-24]
80002438:	fc 0b 00 06 	add	r6,lr,r11
8000243c:	fc 0c 00 07 	add	r7,lr,r12
80002440:	ed 36 00 0c 	ld.ub	r6,r6[12]
80002444:	ef 37 00 0c 	ld.ub	r7,r7[12]
80002448:	ee 06 18 00 	cp.b	r6,r7
8000244c:	e0 8a 00 0d 	brle	80002466 <update_faces+0x7a>
      {
        temp = Faces[i];
        Faces[i] = Faces[i+1];
80002450:	fa ca ff e8 	sub	r10,sp,-24
80002454:	f4 08 00 28 	add	r8,r10,r8<<0x2
80002458:	f1 4c ff e8 	st.w	r8[-24],r12
        Faces[i+1] = temp;
8000245c:	f4 09 00 28 	add	r8,r10,r9<<0x2
80002460:	f1 4b ff e8 	st.w	r8[-24],r11
80002464:	06 9a       	mov	r10,r3
80002466:	12 98       	mov	r8,r9

  int swap, temp, i;
  do
  {
    swap = 0;
    for (i = 0; i < 5; i++)
80002468:	58 48       	cp.w	r8,4
8000246a:	fe 9a ff d9 	brle	8000241c <update_faces+0x30>
        Faces[i] = Faces[i+1];
        Faces[i+1] = temp;
        swap = 1;
      }
  }
  while (swap);
8000246e:	58 0a       	cp.w	r10,0
80002470:	c0 40       	breq	80002478 <update_faces+0x8c>
80002472:	0a 99       	mov	r9,r5
80002474:	08 9a       	mov	r10,r4
80002476:	cf 8b       	rjmp	80002466 <update_faces+0x7a>

  Number_Face_to_print = 0;
80002478:	30 08       	mov	r8,0
8000247a:	49 b9       	lddpc	r9,800024e4 <update_faces+0xf8>
8000247c:	93 08       	st.w	r9[0x0],r8
  // Display the 3 first one faces
  for (i = 0; i < 3; i++)
  {
    Face_to_prints[i] = Faces[5-i];
8000247e:	40 59       	lddsp	r9,sp[0x14]
80002480:	49 aa       	lddpc	r10,800024e8 <update_faces+0xfc>
80002482:	95 09       	st.w	r10[0x0],r9
    if (zbuffer[Face_to_prints[i]]) Number_Face_to_print++;
80002484:	fc 09 00 09 	add	r9,lr,r9
80002488:	f3 39 00 0c 	ld.ub	r9,r9[12]
8000248c:	f0 09 18 00 	cp.b	r9,r8
80002490:	c0 61       	brne	8000249c <update_faces+0xb0>
80002492:	c2 18       	rjmp	800024d4 <update_faces+0xe8>
80002494:	30 39       	mov	r9,3
80002496:	49 48       	lddpc	r8,800024e4 <update_faces+0xf8>
80002498:	91 09       	st.w	r8[0x0],r9
8000249a:	c1 d8       	rjmp	800024d4 <update_faces+0xe8>
8000249c:	30 19       	mov	r9,1
8000249e:	49 28       	lddpc	r8,800024e4 <update_faces+0xf8>
800024a0:	91 09       	st.w	r8[0x0],r9

  Number_Face_to_print = 0;
  // Display the 3 first one faces
  for (i = 0; i < 3; i++)
  {
    Face_to_prints[i] = Faces[5-i];
800024a2:	40 48       	lddsp	r8,sp[0x10]
800024a4:	49 19       	lddpc	r9,800024e8 <update_faces+0xfc>
800024a6:	93 18       	st.w	r9[0x4],r8
    if (zbuffer[Face_to_prints[i]]) Number_Face_to_print++;
800024a8:	fc 08 00 08 	add	r8,lr,r8
800024ac:	f1 39 00 0c 	ld.ub	r9,r8[12]
800024b0:	30 08       	mov	r8,0
800024b2:	f0 09 18 00 	cp.b	r9,r8
800024b6:	c0 f0       	breq	800024d4 <update_faces+0xe8>
800024b8:	30 29       	mov	r9,2
800024ba:	48 b8       	lddpc	r8,800024e4 <update_faces+0xf8>
800024bc:	91 09       	st.w	r8[0x0],r9

  Number_Face_to_print = 0;
  // Display the 3 first one faces
  for (i = 0; i < 3; i++)
  {
    Face_to_prints[i] = Faces[5-i];
800024be:	40 38       	lddsp	r8,sp[0xc]
800024c0:	48 a9       	lddpc	r9,800024e8 <update_faces+0xfc>
800024c2:	93 28       	st.w	r9[0x8],r8
    if (zbuffer[Face_to_prints[i]]) Number_Face_to_print++;
800024c4:	fc 08 00 08 	add	r8,lr,r8
800024c8:	f1 39 00 0c 	ld.ub	r9,r8[12]
800024cc:	30 08       	mov	r8,0
800024ce:	f0 09 18 00 	cp.b	r9,r8
800024d2:	ce 11       	brne	80002494 <update_faces+0xa8>
    else break;
  }
}
800024d4:	2f ad       	sub	sp,-24
800024d6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800024da:	00 00       	add	r0,r0
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	31 e0       	mov	r0,30
800024e0:	00 00       	add	r0,r0
800024e2:	00 24       	rsub	r4,r0
800024e4:	00 00       	add	r0,r0
800024e6:	01 78       	ld.ub	r8,--r0
800024e8:	00 00       	add	r0,r0
800024ea:	02 68       	and	r8,r1

800024ec <draw_image_raster_bmp>:


void draw_image_raster_bmp (OBJ3D_C8_FFIX *myobj, int color, char* RASTER)
{
800024ec:	eb cd 40 c0 	pushm	r6-r7,lr
  int i;
  if(myobj->lien == NULL) {
800024f0:	78 28       	ld.w	r8,r12[0x8]
800024f2:	58 08       	cp.w	r8,0
800024f4:	c0 60       	breq	80002500 <draw_image_raster_bmp+0x14>
    for(i=0; i<myobj->nbliens;i++) {
      RASTER[(SCR_WIDE/2-myobj->ob[i]) + (SCR_HEIGHT/2-myobj->ob[i+myobj->nbpoints])*SCR_WIDE] = color;
    }
  } else {
    for(i=0; i<myobj->nbliens;i++) {
800024f6:	78 58       	ld.w	r8,r12[0x14]
800024f8:	58 08       	cp.w	r8,0
800024fa:	c2 31       	brne	80002540 <draw_image_raster_bmp+0x54>
800024fc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

void draw_image_raster_bmp (OBJ3D_C8_FFIX *myobj, int color, char* RASTER)
{
  int i;
  if(myobj->lien == NULL) {
    for(i=0; i<myobj->nbliens;i++) {
80002500:	78 58       	ld.w	r8,r12[0x14]
80002502:	58 08       	cp.w	r8,0
80002504:	c3 b0       	breq	8000257a <draw_image_raster_bmp+0x8e>
80002506:	30 09       	mov	r9,0
80002508:	12 98       	mov	r8,r9
      RASTER[(SCR_WIDE/2-myobj->ob[i]) + (SCR_HEIGHT/2-myobj->ob[i+myobj->nbpoints])*SCR_WIDE] = color;
8000250a:	78 1e       	ld.w	lr,r12[0x4]
8000250c:	fc 09 06 07 	ld.sb	r7,lr[r9]
80002510:	ee 07 11 42 	rsub	r7,r7,66
80002514:	78 46       	ld.w	r6,r12[0x10]
80002516:	fc 09 00 09 	add	r9,lr,r9
8000251a:	f2 06 06 09 	ld.sb	r9,r9[r6]
8000251e:	f2 09 11 42 	rsub	r9,r9,66
80002522:	f2 0e 15 05 	lsl	lr,r9,0x5
80002526:	fc 09 00 09 	add	r9,lr,r9
8000252a:	ee 09 00 29 	add	r9,r7,r9<<0x2
8000252e:	f4 09 0b 0b 	st.b	r10[r9],r11

void draw_image_raster_bmp (OBJ3D_C8_FFIX *myobj, int color, char* RASTER)
{
  int i;
  if(myobj->lien == NULL) {
    for(i=0; i<myobj->nbliens;i++) {
80002532:	2f f8       	sub	r8,-1
80002534:	10 99       	mov	r9,r8
80002536:	78 5e       	ld.w	lr,r12[0x14]
80002538:	1c 38       	cp.w	r8,lr
8000253a:	ce 83       	brcs	8000250a <draw_image_raster_bmp+0x1e>
8000253c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002540:	30 08       	mov	r8,0
80002542:	10 99       	mov	r9,r8
      RASTER[(SCR_WIDE/2-myobj->ob[i]) + (SCR_HEIGHT/2-myobj->ob[i+myobj->nbpoints])*SCR_WIDE] = color;
    }
  } else {
    for(i=0; i<myobj->nbliens;i++) {
      RASTER[(SCR_WIDE/2-myobj->ob[i]) + (SCR_HEIGHT/2-myobj->ob[i+myobj->nbpoints])*SCR_WIDE] = myobj->lien[i];
80002544:	78 1e       	ld.w	lr,r12[0x4]
80002546:	fc 08 06 07 	ld.sb	r7,lr[r8]
8000254a:	ee 07 11 42 	rsub	r7,r7,66
8000254e:	78 4b       	ld.w	r11,r12[0x10]
80002550:	10 0e       	add	lr,r8
80002552:	fc 0b 06 0b 	ld.sb	r11,lr[r11]
80002556:	f6 0b 11 42 	rsub	r11,r11,66
8000255a:	f6 0e 15 05 	lsl	lr,r11,0x5
8000255e:	fc 0b 00 0b 	add	r11,lr,r11
80002562:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
80002566:	78 2e       	ld.w	lr,r12[0x8]
80002568:	fc 08 07 08 	ld.ub	r8,lr[r8]
8000256c:	f4 0b 0b 08 	st.b	r10[r11],r8
  if(myobj->lien == NULL) {
    for(i=0; i<myobj->nbliens;i++) {
      RASTER[(SCR_WIDE/2-myobj->ob[i]) + (SCR_HEIGHT/2-myobj->ob[i+myobj->nbpoints])*SCR_WIDE] = color;
    }
  } else {
    for(i=0; i<myobj->nbliens;i++) {
80002570:	2f f9       	sub	r9,-1
80002572:	12 98       	mov	r8,r9
80002574:	78 5b       	ld.w	r11,r12[0x14]
80002576:	16 39       	cp.w	r9,r11
80002578:	ce 63       	brcs	80002544 <draw_image_raster_bmp+0x58>
8000257a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000257e <my_put_line_raster>:
  }
}

void my_put_line_raster(int x0, int y0, int x1, int y1, unsigned char color, char* RASTER);
void my_put_line_raster(int x0, int y0, int x1, int y1, unsigned char color, char* RASTER)
{
8000257e:	eb cd 40 fe 	pushm	r1-r7,lr
80002582:	40 84       	lddsp	r4,sp[0x20]

        int dy = y1 - y0;
80002584:	f2 0b 01 05 	sub	r5,r9,r11
        int dx = x1 - x0;
80002588:	f4 0c 01 06 	sub	r6,r10,r12
        int stepx, stepy;

        if (dy < 0) { dy = -dy;  stepy = -1; } else { stepy = 1; }
8000258c:	58 05       	cp.w	r5,0
8000258e:	c0 35       	brlt	80002594 <my_put_line_raster+0x16>
80002590:	30 12       	mov	r2,1
80002592:	c0 38       	rjmp	80002598 <my_put_line_raster+0x1a>
80002594:	5c 35       	neg	r5
80002596:	3f f2       	mov	r2,-1
        if (dx < 0) { dx = -dx;  stepx = -1; } else { stepx = 1; }
80002598:	58 06       	cp.w	r6,0
8000259a:	f9 b3 04 01 	movge	r3,1
8000259e:	fb b6 05 00 	rsublt	r6,0
800025a2:	f9 b3 05 ff 	movlt	r3,-1
        dy <<= 1;
800025a6:	a1 75       	lsl	r5,0x1
        dx <<= 1;
800025a8:	a1 76       	lsl	r6,0x1
      if( (x0)+(y0)*SCR_HEIGHT < 128*128)
800025aa:	f6 0e 15 05 	lsl	lr,r11,0x5
800025ae:	16 0e       	add	lr,r11
800025b0:	f8 0e 00 2e 	add	lr,r12,lr<<0x2
800025b4:	e0 4e 3f ff 	cp.w	lr,16383
800025b8:	e0 89 00 04 	brgt	800025c0 <my_put_line_raster+0x42>
	RASTER[(x0)+(y0)*SCR_HEIGHT]=color;
800025bc:	e8 0e 0b 08 	st.b	r4[lr],r8
        if (dx > dy) {
800025c0:	0c 35       	cp.w	r5,r6
800025c2:	c2 04       	brge	80002602 <my_put_line_raster+0x84>
            int fraction = dy - (dx >> 1);
            while (x0 != x1) {
800025c4:	18 3a       	cp.w	r10,r12
800025c6:	c4 30       	breq	8000264c <my_put_line_raster+0xce>
        dy <<= 1;
        dx <<= 1;
      if( (x0)+(y0)*SCR_HEIGHT < 128*128)
	RASTER[(x0)+(y0)*SCR_HEIGHT]=color;
        if (dx > dy) {
            int fraction = dy - (dx >> 1);
800025c8:	ec 09 14 01 	asr	r9,r6,0x1
800025cc:	ea 09 01 09 	sub	r9,r5,r9
    }
  }
}

void my_put_line_raster(int x0, int y0, int x1, int y1, unsigned char color, char* RASTER);
void my_put_line_raster(int x0, int y0, int x1, int y1, unsigned char color, char* RASTER)
800025d0:	e6 0c 00 0c 	add	r12,r3,r12
	RASTER[(x0)+(y0)*SCR_HEIGHT]=color;
        if (dx > dy) {
            int fraction = dy - (dx >> 1);
            while (x0 != x1) {
                if (fraction >= 0) {
                    y0 += stepy;
800025d4:	58 09       	cp.w	r9,0
800025d6:	f7 d2 e4 0b 	addge	r11,r11,r2
                    fraction -= dx;
800025da:	f3 d6 e4 19 	subge	r9,r9,r6
                }
                x0 += stepx;
                fraction += dy;
	if( (x0)+(y0)*SCR_HEIGHT < 128*128)
800025de:	f6 0e 15 05 	lsl	lr,r11,0x5
800025e2:	16 0e       	add	lr,r11
800025e4:	f8 0e 00 2e 	add	lr,r12,lr<<0x2
800025e8:	e0 4e 3f ff 	cp.w	lr,16383
800025ec:	e0 89 00 04 	brgt	800025f4 <my_put_line_raster+0x76>
          RASTER[(x0)+(y0)*SCR_HEIGHT]=color;
800025f0:	e8 0e 0b 08 	st.b	r4[lr],r8
800025f4:	06 0c       	add	r12,r3
        dx <<= 1;
      if( (x0)+(y0)*SCR_HEIGHT < 128*128)
	RASTER[(x0)+(y0)*SCR_HEIGHT]=color;
        if (dx > dy) {
            int fraction = dy - (dx >> 1);
            while (x0 != x1) {
800025f6:	f8 03 01 0e 	sub	lr,r12,r3
800025fa:	1c 3a       	cp.w	r10,lr
800025fc:	c2 80       	breq	8000264c <my_put_line_raster+0xce>
                if (fraction >= 0) {
                    y0 += stepy;
                    fraction -= dx;
                }
                x0 += stepx;
                fraction += dy;
800025fe:	0a 09       	add	r9,r5
80002600:	ce ab       	rjmp	800025d4 <my_put_line_raster+0x56>
	if( (x0)+(y0)*SCR_HEIGHT < 128*128)
          RASTER[(x0)+(y0)*SCR_HEIGHT]=color;
            }
        } else {
            int fraction = dx - (dy >> 1);
            while (y0 != y1) {
80002602:	16 39       	cp.w	r9,r11
80002604:	c2 40       	breq	8000264c <my_put_line_raster+0xce>
                fraction += dy;
	if( (x0)+(y0)*SCR_HEIGHT < 128*128)
          RASTER[(x0)+(y0)*SCR_HEIGHT]=color;
            }
        } else {
            int fraction = dx - (dy >> 1);
80002606:	ea 0a 14 01 	asr	r10,r5,0x1
8000260a:	ec 0a 01 0a 	sub	r10,r6,r10
    }
  }
}

void my_put_line_raster(int x0, int y0, int x1, int y1, unsigned char color, char* RASTER);
void my_put_line_raster(int x0, int y0, int x1, int y1, unsigned char color, char* RASTER)
8000260e:	e4 0b 00 0b 	add	r11,r2,r11
80002612:	e4 01 15 05 	lsl	r1,r2,0x5
80002616:	04 01       	add	r1,r2
80002618:	a3 61       	lsl	r1,0x2
8000261a:	f6 0e 15 05 	lsl	lr,r11,0x5
8000261e:	16 0e       	add	lr,r11
80002620:	a3 6e       	lsl	lr,0x2
            }
        } else {
            int fraction = dx - (dy >> 1);
            while (y0 != y1) {
                if (fraction >= 0) {
                    x0 += stepx;
80002622:	58 0a       	cp.w	r10,0
80002624:	f9 d3 e4 0c 	addge	r12,r12,r3
                    fraction -= dy;
80002628:	f5 d5 e4 1a 	subge	r10,r10,r5
                }
                y0 += stepy;
                fraction += dx;
       if( (x0)+(y0)*SCR_HEIGHT < 128*128 )
8000262c:	f8 0e 00 07 	add	r7,r12,lr
80002630:	e0 47 3f ff 	cp.w	r7,16383
80002634:	e0 89 00 04 	brgt	8000263c <my_put_line_raster+0xbe>
	RASTER[(x0)+(y0)*SCR_HEIGHT]=color;
80002638:	e8 07 0b 08 	st.b	r4[r7],r8
8000263c:	04 0b       	add	r11,r2
8000263e:	02 0e       	add	lr,r1
	if( (x0)+(y0)*SCR_HEIGHT < 128*128)
          RASTER[(x0)+(y0)*SCR_HEIGHT]=color;
            }
        } else {
            int fraction = dx - (dy >> 1);
            while (y0 != y1) {
80002640:	f6 02 01 07 	sub	r7,r11,r2
80002644:	0e 39       	cp.w	r9,r7
80002646:	c0 30       	breq	8000264c <my_put_line_raster+0xce>
                if (fraction >= 0) {
                    x0 += stepx;
                    fraction -= dy;
                }
                y0 += stepy;
                fraction += dx;
80002648:	0c 0a       	add	r10,r6
8000264a:	ce cb       	rjmp	80002622 <my_put_line_raster+0xa4>
8000264c:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc

80002650 <draw_image_raster>:
       if( (x0)+(y0)*SCR_HEIGHT < 128*128 )
	RASTER[(x0)+(y0)*SCR_HEIGHT]=color;
            }
        }
 }
void draw_image_raster(OBJ3D_C8_FFIX *myobj, int color, char* RASTER) {
80002650:	eb cd 40 f8 	pushm	r3-r7,lr
80002654:	18 97       	mov	r7,r12
80002656:	14 94       	mov	r4,r10
  int i;
  int x1, y1, x2, y2;
  for(i=0; i<myobj->nbliens;i++) {
80002658:	78 58       	ld.w	r8,r12[0x14]
8000265a:	58 08       	cp.w	r8,0
8000265c:	c2 f0       	breq	800026ba <draw_image_raster+0x6a>
8000265e:	30 15       	mov	r5,1
80002660:	30 06       	mov	r6,0
    x1=(unsigned char)(SCR_WIDE/2-((int)(myobj->ob[myobj->lien[2*i]])));
    y1=(unsigned char)(SCR_HEIGHT/2-((int)(myobj->ob[myobj->lien[2*i]+ myobj->nbpoints])));
    x2=(unsigned char)(SCR_WIDE/2-((int)(myobj->ob[myobj->lien[2*i+1]])));
    y2=(unsigned char)(SCR_HEIGHT/2-((int)(myobj->ob[myobj->lien[2*i+1]+myobj->nbpoints])));
    my_put_line_raster(x1, y1, x2, y2, color, RASTER);
80002662:	e7 db c0 08 	bfextu	r3,r11,0x0,0x8
 }
void draw_image_raster(OBJ3D_C8_FFIX *myobj, int color, char* RASTER) {
  int i;
  int x1, y1, x2, y2;
  for(i=0; i<myobj->nbliens;i++) {
    x1=(unsigned char)(SCR_WIDE/2-((int)(myobj->ob[myobj->lien[2*i]])));
80002666:	6e 18       	ld.w	r8,r7[0x4]
80002668:	6e 29       	ld.w	r9,r7[0x8]
8000266a:	f2 06 07 1c 	ld.ub	r12,r9[r6<<0x1]
    y1=(unsigned char)(SCR_HEIGHT/2-((int)(myobj->ob[myobj->lien[2*i]+ myobj->nbpoints])));
8000266e:	6e 4b       	ld.w	r11,r7[0x10]
    x2=(unsigned char)(SCR_WIDE/2-((int)(myobj->ob[myobj->lien[2*i+1]])));
80002670:	f2 05 07 0a 	ld.ub	r10,r9[r5]
    y2=(unsigned char)(SCR_HEIGHT/2-((int)(myobj->ob[myobj->lien[2*i+1]+myobj->nbpoints])));
    my_put_line_raster(x1, y1, x2, y2, color, RASTER);
80002674:	f0 0a 00 09 	add	r9,r8,r10
80002678:	f2 0b 07 09 	ld.ub	r9,r9[r11]
8000267c:	f2 09 11 42 	rsub	r9,r9,66
80002680:	f0 0a 07 0a 	ld.ub	r10,r8[r10]
80002684:	f4 0a 11 42 	rsub	r10,r10,66
80002688:	f0 0b 00 0b 	add	r11,r8,r11
8000268c:	f6 0c 07 0b 	ld.ub	r11,r11[r12]
80002690:	f6 0b 11 42 	rsub	r11,r11,66
80002694:	f0 0c 07 0c 	ld.ub	r12,r8[r12]
80002698:	f8 0c 11 42 	rsub	r12,r12,66
8000269c:	1a d4       	st.w	--sp,r4
8000269e:	06 98       	mov	r8,r3
800026a0:	5c 59       	castu.b	r9
800026a2:	5c 5a       	castu.b	r10
800026a4:	5c 5b       	castu.b	r11
800026a6:	5c 5c       	castu.b	r12
800026a8:	f0 1f 00 06 	mcall	800026c0 <draw_image_raster+0x70>
        }
 }
void draw_image_raster(OBJ3D_C8_FFIX *myobj, int color, char* RASTER) {
  int i;
  int x1, y1, x2, y2;
  for(i=0; i<myobj->nbliens;i++) {
800026ac:	2f f6       	sub	r6,-1
800026ae:	2f e5       	sub	r5,-2
800026b0:	2f fd       	sub	sp,-4
800026b2:	6e 58       	ld.w	r8,r7[0x14]
800026b4:	0c 38       	cp.w	r8,r6
800026b6:	fe 9b ff d8 	brhi	80002666 <draw_image_raster+0x16>
800026ba:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800026be:	00 00       	add	r0,r0
800026c0:	80 00       	ld.sh	r0,r0[0x0]
800026c2:	25 7e       	sub	lr,87

800026c4 <reset_Raster>:
void SEND_RASTER_BUF(char * RASTER) {
      lcd_nokia_putbuffer((unsigned char *)RASTER);
}

void reset_Raster(char* RASTER)
{
800026c4:	d4 01       	pushm	lr
  memset((void *)RASTER,(int )mycolor, (size_t )SCR_WIDE*SCR_HEIGHT);
800026c6:	e0 6a 44 10 	mov	r10,17424
800026ca:	48 38       	lddpc	r8,800026d4 <reset_Raster+0x10>
800026cc:	11 8b       	ld.ub	r11,r8[0x0]
800026ce:	f0 1f 00 03 	mcall	800026d8 <reset_Raster+0x14>
}
800026d2:	d8 02       	popm	pc
800026d4:	00 00       	add	r0,r0
800026d6:	00 e4       	st.h	--r0,r4
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	2d 88       	sub	r8,-40

800026dc <SEND_RASTER_BUF>:
    my_put_line_raster(x1, y1, x2, y2, color, RASTER);
  }
}


void SEND_RASTER_BUF(char * RASTER) {
800026dc:	d4 01       	pushm	lr
      lcd_nokia_putbuffer((unsigned char *)RASTER);
800026de:	f0 1f 00 02 	mcall	800026e4 <SEND_RASTER_BUF+0x8>
}
800026e2:	d8 02       	popm	pc
800026e4:	80 00       	ld.sh	r0,r0[0x0]
800026e6:	22 6c       	sub	r12,38

800026e8 <lcd_nokia_resources_init>:

/*! \brief Initializes LCD_NOKIA resources: GPIO, SPI
 */
void lcd_nokia_resources_init(void);
void lcd_nokia_resources_init(void)
{
800026e8:	eb cd 40 80 	pushm	r7,lr
800026ec:	20 4d       	sub	sp,16
    .spck_delay   = 0,
    .trans_delay  = 0,
    .stay_act     = 1,
    .spi_mode     = 0,
    .modfdis      = 1
  };
800026ee:	49 68       	lddpc	r8,80002744 <lcd_nokia_resources_init+0x5c>
800026f0:	1a 97       	mov	r7,sp
800026f2:	f0 ea 00 00 	ld.d	r10,r8[0]
800026f6:	fa eb 00 00 	st.d	sp[0],r10
800026fa:	f0 e8 00 08 	ld.d	r8,r8[8]
800026fe:	fa e9 00 08 	st.d	sp[8],r8

  // Assign I/Os to SPI.
  gpio_enable_module(LCD_NOKIA_SPI_GPIO_MAP,
80002702:	30 4b       	mov	r11,4
80002704:	49 1c       	lddpc	r12,80002748 <lcd_nokia_resources_init+0x60>
80002706:	f0 1f 00 12 	mcall	8000274c <lcd_nokia_resources_init+0x64>
                     sizeof(LCD_NOKIA_SPI_GPIO_MAP) / sizeof(LCD_NOKIA_SPI_GPIO_MAP[0]));

  // Initialize as master.
  spi_initMaster(LCD_NOKIA_SPI, &spiOptions);
8000270a:	1a 9b       	mov	r11,sp
8000270c:	fe 7c 24 00 	mov	r12,-56320
80002710:	f0 1f 00 10 	mcall	80002750 <lcd_nokia_resources_init+0x68>

  // Set selection mode: variable_ps, pcs_decode, delay.
  spi_selectionMode(LCD_NOKIA_SPI, 0, 0, 0);
80002714:	30 09       	mov	r9,0
80002716:	12 9a       	mov	r10,r9
80002718:	12 9b       	mov	r11,r9
8000271a:	fe 7c 24 00 	mov	r12,-56320
8000271e:	f0 1f 00 0e 	mcall	80002754 <lcd_nokia_resources_init+0x6c>

  // Enable SPI.
  spi_enable(LCD_NOKIA_SPI);
80002722:	fe 7c 24 00 	mov	r12,-56320
80002726:	f0 1f 00 0d 	mcall	80002758 <lcd_nokia_resources_init+0x70>

  // Initialize LCD with SPI clock Osc0.
  spi_setupChipReg(LCD_NOKIA_SPI, &spiOptions, FPBA_HZ);
8000272a:	e0 6a 8a 40 	mov	r10,35392
8000272e:	ea 1a 01 f7 	orh	r10,0x1f7
80002732:	1a 9b       	mov	r11,sp
80002734:	fe 7c 24 00 	mov	r12,-56320
80002738:	f0 1f 00 09 	mcall	8000275c <lcd_nokia_resources_init+0x74>
}
8000273c:	2f cd       	sub	sp,-16
8000273e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002742:	00 00       	add	r0,r0
80002744:	80 00       	ld.sh	r0,r0[0x0]
80002746:	af 3c       	mul	r12,r7
80002748:	80 00       	ld.sh	r0,r0[0x0]
8000274a:	af 1c       	ld.d	r12,--r7
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	29 78       	sub	r8,-105
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	2b bc       	sub	r12,-69
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	2b f4       	sub	r4,-65
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	2d 24       	sub	r4,-46
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	2c 6c       	sub	r12,-58

80002760 <main>:


int main(void)
{
80002760:	d4 31       	pushm	r0-r7,lr
80002762:	20 9d       	sub	sp,36
static void init_sys_clocks(void)
{

volatile avr32_pm_t* pm = &AVR32_PM;

  pm_switch_to_osc0(pm, FOSC0, OSC0_STARTUP);  // Switch main clock to Osc0.
80002764:	30 3a       	mov	r10,3
80002766:	e0 6b 1b 00 	mov	r11,6912
8000276a:	ea 1b 00 b7 	orh	r11,0xb7
8000276e:	fe 7c 0c 00 	mov	r12,-62464
80002772:	f0 1f 00 4e 	mcall	800028a8 <main+0x148>
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount) {
   */
  pm_pll_setup(pm,
80002776:	31 08       	mov	r8,16
80002778:	1a d8       	st.w	--sp,r8
8000277a:	30 08       	mov	r8,0
8000277c:	30 19       	mov	r9,1
8000277e:	30 ba       	mov	r10,11
80002780:	10 9b       	mov	r11,r8
80002782:	fe 7c 0c 00 	mov	r12,-62464
80002786:	f0 1f 00 4a 	mcall	800028ac <main+0x14c>
   pll_freq Set to 1 for VCO frequency range 80-180MHz, set to 0 for VCO frequency range 160-240Mhz.
   pll_div2 Divide the PLL output frequency by 2 (this settings does not change the FVCO value)
   pll_wbwdisable 1 Disable the Wide-Bandith Mode (Wide-Bandwith mode allow a faster startup time and out-of-lock time). 0 to enable the Wide-Bandith Mode.
  */
  /* PLL output VCO frequency is 96MHz. We divide it by 2 with the pll_div2=1. This enable to get later main clock to 48MHz */
  pm_pll_set_option(pm, 0, 1, 1, 0);
8000278a:	30 08       	mov	r8,0
8000278c:	30 19       	mov	r9,1
8000278e:	12 9a       	mov	r10,r9
80002790:	10 9b       	mov	r11,r8
80002792:	fe 7c 0c 00 	mov	r12,-62464
80002796:	f0 1f 00 47 	mcall	800028b0 <main+0x150>
  /* Enable PLL0 */
  /*
    void pm_pll_enable(volatile avr32_pm_t* pm,
                  unsigned int pll) {
  */
  pm_pll_enable(pm,0);
8000279a:	30 0b       	mov	r11,0
8000279c:	fe 7c 0c 00 	mov	r12,-62464
800027a0:	f0 1f 00 45 	mcall	800028b4 <main+0x154>

  /* Wait for PLL0 locked */
  pm_wait_for_pll0_locked(pm) ;
800027a4:	fe 7c 0c 00 	mov	r12,-62464
800027a8:	f0 1f 00 44 	mcall	800028b8 <main+0x158>
     Pheripheral Bus B clock divisor enable = 0
     Pheripheral Bus B select = 0
     High Speed Bus clock divisor enable = 0
     High Speed Bus select = 0
  */
  pm_cksel(pm, 1, 0, 0, 0, 0, 0);
800027ac:	30 07       	mov	r7,0
800027ae:	1a d7       	st.w	--sp,r7
800027b0:	1a d7       	st.w	--sp,r7
800027b2:	0e 98       	mov	r8,r7
800027b4:	0e 99       	mov	r9,r7
800027b6:	0e 9a       	mov	r10,r7
800027b8:	30 1b       	mov	r11,1
800027ba:	fe 7c 0c 00 	mov	r12,-62464
800027be:	f0 1f 00 40 	mcall	800028bc <main+0x15c>

  // Set one wait-state (WS) for flash controller. 0 WS access is up to 30MHz for HSB/CPU clock.
  // As we want to have 48MHz on HSB/CPU clock, we need to set 1 WS on flash controller.
  flashc_set_wait_state(1);
800027c2:	30 1c       	mov	r12,1
800027c4:	f0 1f 00 3f 	mcall	800028c0 <main+0x160>

  pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0); /* Switch main clock to 48MHz */
800027c8:	30 2b       	mov	r11,2
800027ca:	fe 7c 0c 00 	mov	r12,-62464
800027ce:	f0 1f 00 3e 	mcall	800028c4 <main+0x164>
  int i = 0;
  int teta = 0;
  int MYTSFMATR[9];

  // First init of the rotation matrix
  mrot_C8_FULL_FFIX(MYTSFMATR, teta, 0x5A82, 0x5A82, 0);
800027d2:	0e 98       	mov	r8,r7
800027d4:	e0 69 5a 82 	mov	r9,23170
800027d8:	12 9a       	mov	r10,r9
800027da:	0e 9b       	mov	r11,r7
800027dc:	fa cc ff f4 	sub	r12,sp,-12
800027e0:	f0 1f 00 3a 	mcall	800028c8 <main+0x168>

  // Initialize LCD_NOKIA resources: GPIO, SPI
  lcd_nokia_resources_init();
800027e4:	f0 1f 00 3a 	mcall	800028cc <main+0x16c>


	// Controller initialization routine for LCD controller
	lcd_nokia_init();
800027e8:	f0 1f 00 3a 	mcall	800028d0 <main+0x170>
 
  reset_Raster(RASTER);
800027ec:	4b ac       	lddpc	r12,800028d4 <main+0x174>
800027ee:	f0 1f 00 3b 	mcall	800028d8 <main+0x178>
800027f2:	2f dd       	sub	sp,-12

  for (;;) {
        gpio_tgl_gpio_pin(AVR32_PIN_PX12);
800027f4:	36 c4       	mov	r4,108
        transforme_C8_FFIX((OBJ3D_C8_FFIX *)&centers, (OBJ3D_C8_FFIX *)&tmpcenters, (int *)MYTSFMATR);

        // Compute zBuffer Transformation in order to optimize display
        update_faces();

        for( i = 0; i < Number_Face_to_print; i++)
800027f6:	4b a5       	lddpc	r5,800028dc <main+0x17c>
	lcd_nokia_init();
 
  reset_Raster(RASTER);

  for (;;) {
        gpio_tgl_gpio_pin(AVR32_PIN_PX12);
800027f8:	08 9c       	mov	r12,r4
800027fa:	f0 1f 00 3a 	mcall	800028e0 <main+0x180>
          case 2 :
              mrot_C8_FULL_FFIX(MYTSFMATR, teta, 0,0x5A82 , 0x5A82);
          break;
          // Rotation Axes on -x,y,z
          case 3 :
              mrot_C8_FULL_FFIX(MYTSFMATR, teta, -0x49E6, 0x49E6, 0x49E6);
800027fe:	e0 68 49 e6 	mov	r8,18918
80002802:	10 99       	mov	r9,r8
80002804:	fe 7a b6 1a 	mov	r10,-18918
80002808:	0e 9b       	mov	r11,r7
8000280a:	1a 9c       	mov	r12,sp
8000280c:	f0 1f 00 2f 	mcall	800028c8 <main+0x168>
            MYTSFMATR[6] = 0;MYTSFMATR[7] = 0;MYTSFMATR[8] = 1;
      		break;
        }
        // Teta Update: Update step between every rotation axes
        // Bigger is the step and Faster is the rotation
         teta += Ball_speed;
80002810:	4b 58       	lddpc	r8,800028e4 <main+0x184>
80002812:	70 08       	ld.w	r8,r8[0x0]
80002814:	10 07       	add	r7,r8
        if(teta>=240)
80002816:	e0 47 00 f0 	cp.w	r7,240
8000281a:	f9 b7 04 00 	movge	r7,0
        {
              teta=0;
        }

        // Display Screen
        SEND_RASTER_BUF(RASTER);
8000281e:	4a e6       	lddpc	r6,800028d4 <main+0x174>
80002820:	0c 9c       	mov	r12,r6
80002822:	f0 1f 00 32 	mcall	800028e8 <main+0x188>

        // Clear Display Buffer for next compute step
        reset_Raster(RASTER);
80002826:	0c 9c       	mov	r12,r6
80002828:	f0 1f 00 2c 	mcall	800028d8 <main+0x178>

        // Compute 3D Transformation with last MATRIX value
        // Input buffer : centers / Output buffer : tmpcenters
        transforme_C8_FFIX((OBJ3D_C8_FFIX *)&centers, (OBJ3D_C8_FFIX *)&tmpcenters, (int *)MYTSFMATR);
8000282c:	1a 9a       	mov	r10,sp
8000282e:	4b 0b       	lddpc	r11,800028ec <main+0x18c>
80002830:	4b 0c       	lddpc	r12,800028f0 <main+0x190>
80002832:	f0 1f 00 31 	mcall	800028f4 <main+0x194>

        // Compute zBuffer Transformation in order to optimize display
        update_faces();
80002836:	f0 1f 00 31 	mcall	800028f8 <main+0x198>

        for( i = 0; i < Number_Face_to_print; i++)
8000283a:	6a 08       	ld.w	r8,r5[0x0]
8000283c:	58 08       	cp.w	r8,0
8000283e:	fe 9a ff dd 	brle	800027f8 <main+0x98>
80002842:	4a f6       	lddpc	r6,800028fc <main+0x19c>
80002844:	30 03       	mov	r3,0
        {
          // Test if it is a face to display so a Picture
          if (cube_logoavr32[Face_to_prints[i]])
          {
              transforme_C8_FFIX(cube_logoavr32[Face_to_prints[i]], tmpcube_logoavr32[Face_to_prints[i]], MYTSFMATR);
80002846:	4a f0       	lddpc	r0,80002900 <main+0x1a0>
              draw_image_raster_bmp(tmpcube_logoavr32[Face_to_prints[i]], AVR32_COLOR, RASTER);
80002848:	4a 31       	lddpc	r1,800028d4 <main+0x174>
        update_faces();

        for( i = 0; i < Number_Face_to_print; i++)
        {
          // Test if it is a face to display so a Picture
          if (cube_logoavr32[Face_to_prints[i]])
8000284a:	6c 08       	ld.w	r8,r6[0x0]
8000284c:	4a e9       	lddpc	r9,80002904 <main+0x1a4>
8000284e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
80002852:	58 0c       	cp.w	r12,0
80002854:	c0 d0       	breq	8000286e <main+0x10e>
          {
              transforme_C8_FFIX(cube_logoavr32[Face_to_prints[i]], tmpcube_logoavr32[Face_to_prints[i]], MYTSFMATR);
80002856:	1a 9a       	mov	r10,sp
80002858:	e0 08 03 2b 	ld.w	r11,r0[r8<<0x2]
8000285c:	f0 1f 00 26 	mcall	800028f4 <main+0x194>
              draw_image_raster_bmp(tmpcube_logoavr32[Face_to_prints[i]], AVR32_COLOR, RASTER);
80002860:	6c 08       	ld.w	r8,r6[0x0]
80002862:	02 9a       	mov	r10,r1
80002864:	31 3b       	mov	r11,19
80002866:	e0 08 03 2c 	ld.w	r12,r0[r8<<0x2]
8000286a:	f0 1f 00 28 	mcall	80002908 <main+0x1a8>
          }
          // Else Display Cube Transformation
          transforme_C8_FFIX((OBJ3D_C8_FFIX *)&of[Face_to_prints[i]], (OBJ3D_C8_FFIX *)&tmpof[Face_to_prints[i]], (int *)MYTSFMATR);
8000286e:	6c 0c       	ld.w	r12,r6[0x0]
80002870:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80002874:	a3 7c       	lsl	r12,0x3
80002876:	1a 9a       	mov	r10,sp
80002878:	4a 5b       	lddpc	r11,8000290c <main+0x1ac>
8000287a:	18 0b       	add	r11,r12
8000287c:	4a 58       	lddpc	r8,80002910 <main+0x1b0>
8000287e:	f0 0c 00 0c 	add	r12,r8,r12
80002882:	f0 1f 00 1d 	mcall	800028f4 <main+0x194>
          draw_image_raster(&tmpof[Face_to_prints[i]], MESH_COLOR, RASTER);
80002886:	0d 0c       	ld.w	r12,r6++
80002888:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
8000288c:	02 9a       	mov	r10,r1
8000288e:	30 0b       	mov	r11,0
80002890:	49 f9       	lddpc	r9,8000290c <main+0x1ac>
80002892:	f2 0c 00 3c 	add	r12,r9,r12<<0x3
80002896:	f0 1f 00 20 	mcall	80002914 <main+0x1b4>
        transforme_C8_FFIX((OBJ3D_C8_FFIX *)&centers, (OBJ3D_C8_FFIX *)&tmpcenters, (int *)MYTSFMATR);

        // Compute zBuffer Transformation in order to optimize display
        update_faces();

        for( i = 0; i < Number_Face_to_print; i++)
8000289a:	2f f3       	sub	r3,-1
8000289c:	6a 08       	ld.w	r8,r5[0x0]
8000289e:	06 38       	cp.w	r8,r3
800028a0:	fe 9a ff ac 	brle	800027f8 <main+0x98>
800028a4:	cd 3b       	rjmp	8000284a <main+0xea>
800028a6:	00 00       	add	r0,r0
800028a8:	80 00       	ld.sh	r0,r0[0x0]
800028aa:	2b 70       	sub	r0,-73
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	2b 12       	sub	r2,-79
800028b0:	80 00       	ld.sh	r0,r0[0x0]
800028b2:	2b 34       	sub	r4,-77
800028b4:	80 00       	ld.sh	r0,r0[0x0]
800028b6:	2b 4e       	sub	lr,-76
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	2b 5c       	sub	r12,-75
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	2a cc       	sub	r12,-84
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	29 18       	sub	r8,-111
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	2b 66       	sub	r6,-74
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	21 20       	sub	r0,18
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	26 e8       	sub	r8,110
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	23 38       	sub	r8,51
800028d4:	00 00       	add	r0,r0
800028d6:	02 74       	tst	r4,r1
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	26 c4       	sub	r4,108
800028dc:	00 00       	add	r0,r0
800028de:	01 78       	ld.ub	r8,--r0
800028e0:	80 00       	ld.sh	r0,r0[0x0]
800028e2:	29 f8       	sub	r8,-97
800028e4:	00 00       	add	r0,r0
800028e6:	00 08       	add	r8,r0
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	26 dc       	sub	r12,109
800028ec:	00 00       	add	r0,r0
800028ee:	00 24       	rsub	r4,r0
800028f0:	80 00       	ld.sh	r0,r0[0x0]
800028f2:	c5 74       	brge	800029a0 <gpio_enable_module+0x28>
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	20 98       	sub	r8,9
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	23 ec       	sub	r12,62
800028fc:	00 00       	add	r0,r0
800028fe:	02 68       	and	r8,r1
80002900:	00 00       	add	r0,r0
80002902:	01 30       	ld.ub	r0,r0++
80002904:	00 00       	add	r0,r0
80002906:	01 00       	ld.w	r0,r0++
80002908:	80 00       	ld.sh	r0,r0[0x0]
8000290a:	24 ec       	sub	r12,78
8000290c:	00 00       	add	r0,r0
8000290e:	00 3c       	cp.w	r12,r0
80002910:	80 00       	ld.sh	r0,r0[0x0]
80002912:	ae 8c       	st.b	r7[0x0],r12
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	26 50       	sub	r0,101

80002918 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80002918:	fe 68 14 00 	mov	r8,-125952
8000291c:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
8000291e:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80002922:	91 09       	st.w	r8[0x0],r9
}
80002924:	5e fc       	retal	r12

80002926 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002926:	f8 08 16 05 	lsr	r8,r12,0x5
8000292a:	a9 68       	lsl	r8,0x8
8000292c:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80002930:	58 1b       	cp.w	r11,1
80002932:	c0 d0       	breq	8000294c <gpio_enable_module_pin+0x26>
80002934:	c0 63       	brcs	80002940 <gpio_enable_module_pin+0x1a>
80002936:	58 2b       	cp.w	r11,2
80002938:	c1 00       	breq	80002958 <gpio_enable_module_pin+0x32>
8000293a:	58 3b       	cp.w	r11,3
8000293c:	c1 40       	breq	80002964 <gpio_enable_module_pin+0x3e>
8000293e:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80002940:	30 19       	mov	r9,1
80002942:	f2 0c 09 49 	lsl	r9,r9,r12
80002946:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002948:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000294a:	c1 28       	rjmp	8000296e <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000294c:	30 19       	mov	r9,1
8000294e:	f2 0c 09 49 	lsl	r9,r9,r12
80002952:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002954:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002956:	c0 c8       	rjmp	8000296e <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80002958:	30 19       	mov	r9,1
8000295a:	f2 0c 09 49 	lsl	r9,r9,r12
8000295e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002960:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002962:	c0 68       	rjmp	8000296e <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002964:	30 19       	mov	r9,1
80002966:	f2 0c 09 49 	lsl	r9,r9,r12
8000296a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000296c:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000296e:	30 19       	mov	r9,1
80002970:	f2 0c 09 4c 	lsl	r12,r9,r12
80002974:	91 2c       	st.w	r8[0x8],r12
80002976:	5e fd       	retal	0

80002978 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80002978:	d4 21       	pushm	r4-r7,lr
8000297a:	18 97       	mov	r7,r12
8000297c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000297e:	58 0b       	cp.w	r11,0
80002980:	c0 31       	brne	80002986 <gpio_enable_module+0xe>
80002982:	30 05       	mov	r5,0
80002984:	c0 d8       	rjmp	8000299e <gpio_enable_module+0x26>
80002986:	30 06       	mov	r6,0
80002988:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000298a:	6e 1b       	ld.w	r11,r7[0x4]
8000298c:	6e 0c       	ld.w	r12,r7[0x0]
8000298e:	f0 1f 00 06 	mcall	800029a4 <gpio_enable_module+0x2c>
80002992:	18 45       	or	r5,r12
		gpiomap++;
80002994:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80002996:	2f f6       	sub	r6,-1
80002998:	0c 34       	cp.w	r4,r6
8000299a:	fe 9b ff f8 	brhi	8000298a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000299e:	0a 9c       	mov	r12,r5
800029a0:	d8 22       	popm	r4-r7,pc
800029a2:	00 00       	add	r0,r0
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	29 26       	sub	r6,-110

800029a8 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800029a8:	f8 08 16 05 	lsr	r8,r12,0x5
800029ac:	a9 68       	lsl	r8,0x8
800029ae:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
800029b2:	30 19       	mov	r9,1
800029b4:	f2 0c 09 4c 	lsl	r12,r9,r12
800029b8:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
800029bc:	91 1c       	st.w	r8[0x4],r12
}
800029be:	5e fc       	retal	r12

800029c0 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800029c0:	f8 08 16 05 	lsr	r8,r12,0x5
800029c4:	a9 68       	lsl	r8,0x8
800029c6:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800029ca:	30 19       	mov	r9,1
800029cc:	f2 0c 09 4c 	lsl	r12,r9,r12
800029d0:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800029d4:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800029d8:	91 1c       	st.w	r8[0x4],r12
}
800029da:	5e fc       	retal	r12

800029dc <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800029dc:	f8 08 16 05 	lsr	r8,r12,0x5
800029e0:	a9 68       	lsl	r8,0x8
800029e2:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800029e6:	30 19       	mov	r9,1
800029e8:	f2 0c 09 4c 	lsl	r12,r9,r12
800029ec:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800029f0:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800029f4:	91 1c       	st.w	r8[0x4],r12
}
800029f6:	5e fc       	retal	r12

800029f8 <gpio_tgl_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_tgl_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800029f8:	f8 08 16 05 	lsr	r8,r12,0x5
800029fc:	a9 68       	lsl	r8,0x8
800029fe:	e0 28 f0 00 	sub	r8,61440
	
	/* Toggle the I/O line. */
	gpio_port->ovrt  = 1 << (pin & 0x1F);
80002a02:	30 19       	mov	r9,1
80002a04:	f2 0c 09 4c 	lsl	r12,r9,r12
80002a08:	f1 4c 00 5c 	st.w	r8[92],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80002a0c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80002a10:	91 1c       	st.w	r8[0x4],r12
}
80002a12:	5e fc       	retal	r12

80002a14 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80002a14:	fe 78 08 00 	mov	r8,-63488
80002a18:	e0 69 00 83 	mov	r9,131
80002a1c:	f2 0c 01 0c 	sub	r12,r9,r12
80002a20:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80002a24:	f2 ca ff c0 	sub	r10,r9,-64
80002a28:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002a2c:	58 08       	cp.w	r8,0
80002a2e:	c0 21       	brne	80002a32 <_get_interrupt_handler+0x1e>
80002a30:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80002a32:	f0 08 12 00 	clz	r8,r8
80002a36:	48 5a       	lddpc	r10,80002a48 <_get_interrupt_handler+0x34>
80002a38:	f4 09 00 39 	add	r9,r10,r9<<0x3
80002a3c:	f0 08 11 1f 	rsub	r8,r8,31
80002a40:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002a42:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80002a46:	5e fc       	retal	r12
80002a48:	80 00       	ld.sh	r0,r0[0x0]
80002a4a:	c5 8c       	rcall	80002afa <pm_cksel+0x2e>

80002a4c <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002a4c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80002a4e:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002a52:	99 a8       	st.w	r12[0x28],r8
}
80002a54:	5e fc       	retal	r12
80002a56:	d7 03       	nop

80002a58 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80002a58:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80002a5a:	ec 5b bb 9f 	cp.w	r11,899999
80002a5e:	e0 8b 00 04 	brhi	80002a66 <pm_enable_osc0_crystal+0xe>
80002a62:	30 4b       	mov	r11,4
80002a64:	c1 38       	rjmp	80002a8a <pm_enable_osc0_crystal+0x32>
80002a66:	e0 68 c6 bf 	mov	r8,50879
80002a6a:	ea 18 00 2d 	orh	r8,0x2d
80002a6e:	10 3b       	cp.w	r11,r8
80002a70:	e0 8b 00 04 	brhi	80002a78 <pm_enable_osc0_crystal+0x20>
80002a74:	30 5b       	mov	r11,5
80002a76:	c0 a8       	rjmp	80002a8a <pm_enable_osc0_crystal+0x32>
80002a78:	e0 68 12 00 	mov	r8,4608
80002a7c:	ea 18 00 7a 	orh	r8,0x7a
80002a80:	10 3b       	cp.w	r11,r8
80002a82:	f9 bb 03 06 	movlo	r11,6
80002a86:	f9 bb 02 07 	movhs	r11,7
80002a8a:	f0 1f 00 02 	mcall	80002a90 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80002a8e:	d8 02       	popm	pc
80002a90:	80 00       	ld.sh	r0,r0[0x0]
80002a92:	2a 4c       	sub	r12,-92

80002a94 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002a94:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80002a96:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002a9a:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80002a9c:	78 08       	ld.w	r8,r12[0x0]
80002a9e:	a3 a8       	sbr	r8,0x2
80002aa0:	99 08       	st.w	r12[0x0],r8
}
80002aa2:	5e fc       	retal	r12

80002aa4 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80002aa4:	79 58       	ld.w	r8,r12[0x54]
80002aa6:	e2 18 00 80 	andl	r8,0x80,COH
80002aaa:	cf d0       	breq	80002aa4 <pm_wait_for_clk0_ready>
}
80002aac:	5e fc       	retal	r12
80002aae:	d7 03       	nop

80002ab0 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80002ab0:	eb cd 40 80 	pushm	r7,lr
80002ab4:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80002ab6:	f0 1f 00 04 	mcall	80002ac4 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80002aba:	0e 9c       	mov	r12,r7
80002abc:	f0 1f 00 03 	mcall	80002ac8 <pm_enable_clk0+0x18>
}
80002ac0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ac4:	80 00       	ld.sh	r0,r0[0x0]
80002ac6:	2a 94       	sub	r4,-87
80002ac8:	80 00       	ld.sh	r0,r0[0x0]
80002aca:	2a a4       	sub	r4,-86

80002acc <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80002acc:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80002ad0:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80002ad4:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80002ad6:	09 f7       	ld.ub	r7,r4[0x7]
80002ad8:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80002adc:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80002ae0:	09 b4       	ld.ub	r4,r4[0x3]
80002ae2:	08 96       	mov	r6,r4
80002ae4:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80002ae8:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80002aec:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80002af0:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80002af4:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80002af8:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80002afc:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80002b00:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80002b04:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80002b06:	79 58       	ld.w	r8,r12[0x54]
80002b08:	e2 18 00 20 	andl	r8,0x20,COH
80002b0c:	cf d0       	breq	80002b06 <pm_cksel+0x3a>
}
80002b0e:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80002b12 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80002b12:	eb cd 40 80 	pushm	r7,lr
80002b16:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80002b18:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80002b1a:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80002b1e:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80002b22:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80002b26:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80002b2a:	2f 8b       	sub	r11,-8
80002b2c:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80002b30:	e3 cd 80 80 	ldm	sp++,r7,pc

80002b34 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80002b34:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80002b36:	2f 8b       	sub	r11,-8
80002b38:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80002b3c:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80002b40:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80002b44:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80002b48:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80002b4c:	d8 02       	popm	pc

80002b4e <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80002b4e:	2f 8b       	sub	r11,-8
80002b50:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80002b54:	a1 a8       	sbr	r8,0x0
80002b56:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80002b5a:	5e fc       	retal	r12

80002b5c <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80002b5c:	79 58       	ld.w	r8,r12[0x54]
80002b5e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002b62:	cf d0       	breq	80002b5c <pm_wait_for_pll0_locked>
}
80002b64:	5e fc       	retal	r12

80002b66 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80002b66:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80002b68:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80002b6c:	99 08       	st.w	r12[0x0],r8
}
80002b6e:	5e fc       	retal	r12

80002b70 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80002b70:	eb cd 40 c0 	pushm	r6-r7,lr
80002b74:	18 97       	mov	r7,r12
80002b76:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80002b78:	f0 1f 00 06 	mcall	80002b90 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80002b7c:	0c 9b       	mov	r11,r6
80002b7e:	0e 9c       	mov	r12,r7
80002b80:	f0 1f 00 05 	mcall	80002b94 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80002b84:	30 1b       	mov	r11,1
80002b86:	0e 9c       	mov	r12,r7
80002b88:	f0 1f 00 04 	mcall	80002b98 <pm_switch_to_osc0+0x28>
}
80002b8c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b90:	80 00       	ld.sh	r0,r0[0x0]
80002b92:	2a 58       	sub	r8,-91
80002b94:	80 00       	ld.sh	r0,r0[0x0]
80002b96:	2a b0       	sub	r0,-85
80002b98:	80 00       	ld.sh	r0,r0[0x0]
80002b9a:	2b 66       	sub	r6,-74

80002b9c <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80002b9c:	f8 c8 00 01 	sub	r8,r12,1
80002ba0:	f0 0b 00 0b 	add	r11,r8,r11
80002ba4:	f6 0c 0d 0a 	divu	r10,r11,r12
80002ba8:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80002baa:	f4 c8 00 01 	sub	r8,r10,1
80002bae:	e0 48 00 fe 	cp.w	r8,254
80002bb2:	e0 88 00 03 	brls	80002bb8 <getBaudDiv+0x1c>
80002bb6:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80002bb8:	5c 8c       	casts.h	r12
}
80002bba:	5e fc       	retal	r12

80002bbc <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80002bbc:	f7 39 00 0d 	ld.ub	r9,r11[13]
80002bc0:	30 18       	mov	r8,1
80002bc2:	f0 09 18 00 	cp.b	r9,r8
80002bc6:	e0 88 00 04 	brls	80002bce <spi_initMaster+0x12>
80002bca:	30 2c       	mov	r12,2
80002bcc:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80002bce:	e0 68 00 80 	mov	r8,128
80002bd2:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80002bd4:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80002bd6:	30 19       	mov	r9,1
80002bd8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80002bdc:	f7 39 00 0d 	ld.ub	r9,r11[13]
80002be0:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80002be4:	30 09       	mov	r9,0
80002be6:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80002bea:	30 fa       	mov	r10,15
80002bec:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80002bf0:	99 18       	st.w	r12[0x4],r8
80002bf2:	5e f9       	retal	r9

80002bf4 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80002bf4:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80002bf6:	30 18       	mov	r8,1
80002bf8:	f0 0b 18 00 	cp.b	r11,r8
80002bfc:	5f be       	srhi	lr
80002bfe:	f0 0a 18 00 	cp.b	r10,r8
80002c02:	5f b8       	srhi	r8
80002c04:	fd e8 10 08 	or	r8,lr,r8
80002c08:	c0 30       	breq	80002c0e <spi_selectionMode+0x1a>
80002c0a:	30 2c       	mov	r12,2
80002c0c:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80002c0e:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80002c10:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80002c14:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80002c18:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80002c1c:	99 18       	st.w	r12[0x4],r8
80002c1e:	d8 0a       	popm	pc,r12=0

80002c20 <spi_selectChip>:
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002c20:	78 18       	ld.w	r8,r12[0x4]
80002c22:	ea 18 00 0f 	orh	r8,0xf
80002c26:	99 18       	st.w	r12[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80002c28:	78 18       	ld.w	r8,r12[0x4]
80002c2a:	e2 18 00 04 	andl	r8,0x4,COH
80002c2e:	c0 f0       	breq	80002c4c <spi_selectChip+0x2c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80002c30:	30 e8       	mov	r8,14
80002c32:	f0 0b 18 00 	cp.b	r11,r8
80002c36:	e0 8b 00 19 	brhi	80002c68 <spi_selectChip+0x48>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80002c3a:	78 18       	ld.w	r8,r12[0x4]
80002c3c:	b1 6b       	lsl	r11,0x10
80002c3e:	ea 1b ff f0 	orh	r11,0xfff0
80002c42:	e8 1b ff ff 	orl	r11,0xffff
80002c46:	10 6b       	and	r11,r8
80002c48:	99 1b       	st.w	r12[0x4],r11
80002c4a:	5e fd       	retal	0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80002c4c:	30 38       	mov	r8,3
80002c4e:	f0 0b 18 00 	cp.b	r11,r8
80002c52:	e0 8b 00 0b 	brhi	80002c68 <spi_selectChip+0x48>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80002c56:	78 18       	ld.w	r8,r12[0x4]
80002c58:	2f 0b       	sub	r11,-16
80002c5a:	30 19       	mov	r9,1
80002c5c:	f2 0b 09 4b 	lsl	r11,r9,r11
80002c60:	5c db       	com	r11
80002c62:	10 6b       	and	r11,r8
80002c64:	99 1b       	st.w	r12[0x4],r11
80002c66:	5e fd       	retal	0
80002c68:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80002c6a:	5e fc       	retal	r12

80002c6c <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80002c6c:	eb cd 40 f8 	pushm	r3-r7,lr
80002c70:	18 95       	mov	r5,r12
80002c72:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002c74:	f7 36 00 0c 	ld.ub	r6,r11[12]
80002c78:	30 38       	mov	r8,3
80002c7a:	f0 06 18 00 	cp.b	r6,r8
80002c7e:	e0 8b 00 4d 	brhi	80002d18 <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
80002c82:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002c86:	30 18       	mov	r8,1
80002c88:	f0 04 18 00 	cp.b	r4,r8
80002c8c:	e0 8b 00 46 	brhi	80002d18 <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80002c90:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002c94:	30 78       	mov	r8,7
80002c96:	f0 03 18 00 	cp.b	r3,r8
80002c9a:	e0 88 00 3f 	brls	80002d18 <spi_setupChipReg+0xac>
80002c9e:	31 08       	mov	r8,16
80002ca0:	f0 03 18 00 	cp.b	r3,r8
80002ca4:	e0 8b 00 3a 	brhi	80002d18 <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80002ca8:	14 9b       	mov	r11,r10
80002caa:	6e 1c       	ld.w	r12,r7[0x4]
80002cac:	f0 1f 00 1d 	mcall	80002d20 <spi_setupChipReg+0xb4>

	if (baudDiv < 0) {
80002cb0:	c3 45       	brlt	80002d18 <spi_setupChipReg+0xac>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80002cb2:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80002cb4:	ec 09 16 01 	lsr	r9,r6,0x1
80002cb8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80002cbc:	ec 16 00 01 	eorl	r6,0x1
80002cc0:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80002cc4:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80002cc8:	20 83       	sub	r3,8
80002cca:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80002cce:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80002cd2:	ef 39 00 09 	ld.ub	r9,r7[9]
80002cd6:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80002cda:	ef 39 00 0a 	ld.ub	r9,r7[10]
80002cde:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80002ce2:	0f 89       	ld.ub	r9,r7[0x0]
80002ce4:	30 1a       	mov	r10,1
80002ce6:	f4 09 18 00 	cp.b	r9,r10
80002cea:	c0 e0       	breq	80002d06 <spi_setupChipReg+0x9a>
80002cec:	c0 a3       	brcs	80002d00 <spi_setupChipReg+0x94>
80002cee:	30 2a       	mov	r10,2
80002cf0:	f4 09 18 00 	cp.b	r9,r10
80002cf4:	c0 c0       	breq	80002d0c <spi_setupChipReg+0xa0>
80002cf6:	30 3a       	mov	r10,3
80002cf8:	f4 09 18 00 	cp.b	r9,r10
80002cfc:	c0 e1       	brne	80002d18 <spi_setupChipReg+0xac>
80002cfe:	c0 a8       	rjmp	80002d12 <spi_setupChipReg+0xa6>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80002d00:	8b c8       	st.w	r5[0x30],r8
80002d02:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80002d06:	8b d8       	st.w	r5[0x34],r8
80002d08:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80002d0c:	8b e8       	st.w	r5[0x38],r8
80002d0e:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80002d12:	8b f8       	st.w	r5[0x3c],r8
80002d14:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;
80002d18:	30 2c       	mov	r12,2
		}
	}
#endif

	return SPI_OK;
}
80002d1a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002d1e:	00 00       	add	r0,r0
80002d20:	80 00       	ld.sh	r0,r0[0x0]
80002d22:	2b 9c       	sub	r12,-71

80002d24 <spi_enable>:

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80002d24:	30 18       	mov	r8,1
80002d26:	99 08       	st.w	r12[0x0],r8
}
80002d28:	5e fc       	retal	r12

80002d2a <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80002d2a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80002d2e:	c0 58       	rjmp	80002d38 <spi_write+0xe>
		if (!timeout--) {
80002d30:	58 08       	cp.w	r8,0
80002d32:	c0 21       	brne	80002d36 <spi_write+0xc>
80002d34:	5e ff       	retal	1
80002d36:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80002d38:	78 49       	ld.w	r9,r12[0x10]
80002d3a:	e2 19 00 02 	andl	r9,0x2,COH
80002d3e:	cf 90       	breq	80002d30 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80002d40:	5c 7b       	castu.h	r11
80002d42:	99 3b       	st.w	r12[0xc],r11
80002d44:	5e fd       	retal	0
80002d46:	d7 03       	nop

80002d48 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80002d48:	e0 7d 00 00 	mov	sp,65536

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80002d4c:	fe c0 ff 4c 	sub	r0,pc,-180

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80002d50:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80002d54:	d5 53       	csrf	0x15
  cp      r0, r1
80002d56:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80002d58:	e0 61 01 78 	mov	r1,376
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80002d5c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80002d5e:	c0 62       	brcc	80002d6a <idata_load_loop_end>
  cp      r0, r1
80002d60:	48 92       	lddpc	r2,80002d84 <udata_clear_loop_end+0x4>

80002d62 <idata_load_loop>:
  brlo    idata_load_loop
80002d62:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80002d64:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80002d66:	02 30       	cp.w	r0,r1
  cp      r0, r1
80002d68:	cf d3       	brcs	80002d62 <idata_load_loop>

80002d6a <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80002d6a:	e0 60 01 78 	mov	r0,376
  mov     r2, 0
  mov     r3, 0
80002d6e:	e0 61 66 d0 	mov	r1,26320
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80002d72:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80002d74:	c0 62       	brcc	80002d80 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80002d76:	30 02       	mov	r2,0
80002d78:	30 03       	mov	r3,0

80002d7a <udata_clear_loop>:
80002d7a:	a1 22       	st.d	r0++,r2
80002d7c:	02 30       	cp.w	r0,r1
80002d7e:	cf e3       	brcs	80002d7a <udata_clear_loop>

80002d80 <udata_clear_loop_end>:
80002d80:	fe cf 06 20 	sub	pc,pc,1568
80002d84:	80 00       	ld.sh	r0,r0[0x0]
80002d86:	c6 30       	breq	80002e4c <_handle_DTLB_Modified+0x8>

80002d88 <memset>:
80002d88:	18 98       	mov	r8,r12
80002d8a:	c0 38       	rjmp	80002d90 <memset+0x8>
80002d8c:	10 cb       	st.b	r8++,r11
80002d8e:	20 1a       	sub	r10,1
80002d90:	58 0a       	cp.w	r10,0
80002d92:	cf d1       	brne	80002d8c <memset+0x4>
80002d94:	5e fc       	retal	r12

Disassembly of section .exception:

80002e00 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80002e00:	c0 08       	rjmp	80002e00 <_evba>
	...

80002e04 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80002e04:	c0 08       	rjmp	80002e04 <_handle_TLB_Multiple_Hit>
	...

80002e08 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80002e08:	c0 08       	rjmp	80002e08 <_handle_Bus_Error_Data_Fetch>
	...

80002e0c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
80002e0c:	c0 08       	rjmp	80002e0c <_handle_Bus_Error_Instruction_Fetch>
	...

80002e10 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80002e10:	c0 08       	rjmp	80002e10 <_handle_NMI>
	...

80002e14 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80002e14:	c0 08       	rjmp	80002e14 <_handle_Instruction_Address>
	...

80002e18 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80002e18:	c0 08       	rjmp	80002e18 <_handle_ITLB_Protection>
	...

80002e1c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
80002e1c:	c0 08       	rjmp	80002e1c <_handle_Breakpoint>
	...

80002e20 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80002e20:	c0 08       	rjmp	80002e20 <_handle_Illegal_Opcode>
	...

80002e24 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80002e24:	c0 08       	rjmp	80002e24 <_handle_Unimplemented_Instruction>
	...

80002e28 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80002e28:	c0 08       	rjmp	80002e28 <_handle_Privilege_Violation>
	...

80002e2c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR32UC and AVR32AP.
_handle_Floating_Point:
	rjmp $
80002e2c:	c0 08       	rjmp	80002e2c <_handle_Floating_Point>
	...

80002e30 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
	rjmp $
80002e30:	c0 08       	rjmp	80002e30 <_handle_Coprocessor_Absent>
	...

80002e34 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80002e34:	c0 08       	rjmp	80002e34 <_handle_Data_Address_Read>
	...

80002e38 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80002e38:	c0 08       	rjmp	80002e38 <_handle_Data_Address_Write>
	...

80002e3c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
80002e3c:	c0 08       	rjmp	80002e3c <_handle_DTLB_Protection_Read>
	...

80002e40 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80002e40:	c0 08       	rjmp	80002e40 <_handle_DTLB_Protection_Write>
	...

80002e44 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80002e44:	c0 08       	rjmp	80002e44 <_handle_DTLB_Modified>
	...

80002e50 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80002e50:	c0 08       	rjmp	80002e50 <_handle_ITLB_Miss>
	...

80002e60 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80002e60:	c0 08       	rjmp	80002e60 <_handle_DTLB_Miss_Read>
	...

80002e70 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80002e70:	c0 08       	rjmp	80002e70 <_handle_DTLB_Miss_Write>
	...

80002f00 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	rjmp $
80002f00:	c0 08       	rjmp	80002f00 <_handle_Supervisor_Call>
80002f02:	d7 03       	nop

80002f04 <_int0>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80002f04:	30 0c       	mov	r12,0
80002f06:	fe b0 fd 87 	rcall	80002a14 <_get_interrupt_handler>
80002f0a:	58 0c       	cp.w	r12,0
80002f0c:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80002f10:	d6 03       	rete

80002f12 <_int1>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80002f12:	30 1c       	mov	r12,1
80002f14:	fe b0 fd 80 	rcall	80002a14 <_get_interrupt_handler>
80002f18:	58 0c       	cp.w	r12,0
80002f1a:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80002f1e:	d6 03       	rete

80002f20 <_int2>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80002f20:	30 2c       	mov	r12,2
80002f22:	fe b0 fd 79 	rcall	80002a14 <_get_interrupt_handler>
80002f26:	58 0c       	cp.w	r12,0
80002f28:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80002f2c:	d6 03       	rete

80002f2e <_int3>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80002f2e:	30 3c       	mov	r12,3
80002f30:	fe b0 fd 72 	rcall	80002a14 <_get_interrupt_handler>
80002f34:	58 0c       	cp.w	r12,0
80002f36:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80002f3a:	d6 03       	rete
80002f3c:	d7 03       	nop
80002f3e:	d7 03       	nop
80002f40:	d7 03       	nop
80002f42:	d7 03       	nop
80002f44:	d7 03       	nop
80002f46:	d7 03       	nop
80002f48:	d7 03       	nop
80002f4a:	d7 03       	nop
80002f4c:	d7 03       	nop
80002f4e:	d7 03       	nop
80002f50:	d7 03       	nop
80002f52:	d7 03       	nop
80002f54:	d7 03       	nop
80002f56:	d7 03       	nop
80002f58:	d7 03       	nop
80002f5a:	d7 03       	nop
80002f5c:	d7 03       	nop
80002f5e:	d7 03       	nop
80002f60:	d7 03       	nop
80002f62:	d7 03       	nop
80002f64:	d7 03       	nop
80002f66:	d7 03       	nop
80002f68:	d7 03       	nop
80002f6a:	d7 03       	nop
80002f6c:	d7 03       	nop
80002f6e:	d7 03       	nop
80002f70:	d7 03       	nop
80002f72:	d7 03       	nop
80002f74:	d7 03       	nop
80002f76:	d7 03       	nop
80002f78:	d7 03       	nop
80002f7a:	d7 03       	nop
80002f7c:	d7 03       	nop
80002f7e:	d7 03       	nop
80002f80:	d7 03       	nop
80002f82:	d7 03       	nop
80002f84:	d7 03       	nop
80002f86:	d7 03       	nop
80002f88:	d7 03       	nop
80002f8a:	d7 03       	nop
80002f8c:	d7 03       	nop
80002f8e:	d7 03       	nop
80002f90:	d7 03       	nop
80002f92:	d7 03       	nop
80002f94:	d7 03       	nop
80002f96:	d7 03       	nop
80002f98:	d7 03       	nop
80002f9a:	d7 03       	nop
80002f9c:	d7 03       	nop
80002f9e:	d7 03       	nop
80002fa0:	d7 03       	nop
80002fa2:	d7 03       	nop
80002fa4:	d7 03       	nop
80002fa6:	d7 03       	nop
80002fa8:	d7 03       	nop
80002faa:	d7 03       	nop
80002fac:	d7 03       	nop
80002fae:	d7 03       	nop
80002fb0:	d7 03       	nop
80002fb2:	d7 03       	nop
80002fb4:	d7 03       	nop
80002fb6:	d7 03       	nop
80002fb8:	d7 03       	nop
80002fba:	d7 03       	nop
80002fbc:	d7 03       	nop
80002fbe:	d7 03       	nop
80002fc0:	d7 03       	nop
80002fc2:	d7 03       	nop
80002fc4:	d7 03       	nop
80002fc6:	d7 03       	nop
80002fc8:	d7 03       	nop
80002fca:	d7 03       	nop
80002fcc:	d7 03       	nop
80002fce:	d7 03       	nop
80002fd0:	d7 03       	nop
80002fd2:	d7 03       	nop
80002fd4:	d7 03       	nop
80002fd6:	d7 03       	nop
80002fd8:	d7 03       	nop
80002fda:	d7 03       	nop
80002fdc:	d7 03       	nop
80002fde:	d7 03       	nop
80002fe0:	d7 03       	nop
80002fe2:	d7 03       	nop
80002fe4:	d7 03       	nop
80002fe6:	d7 03       	nop
80002fe8:	d7 03       	nop
80002fea:	d7 03       	nop
80002fec:	d7 03       	nop
80002fee:	d7 03       	nop
80002ff0:	d7 03       	nop
80002ff2:	d7 03       	nop
80002ff4:	d7 03       	nop
80002ff6:	d7 03       	nop
80002ff8:	d7 03       	nop
80002ffa:	d7 03       	nop
80002ffc:	d7 03       	nop
80002ffe:	d7 03       	nop
