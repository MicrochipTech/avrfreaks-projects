
basementstove.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000026d4  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000030  00800060  000026d4  00002788  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006fc  00800090  00800090  000027b8  2**0
                  ALLOC
  3 .eeprom       00000001  00810000  00810000  000027b8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00000888  00000000  00000000  000027bc  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      000001ac  00000000  00000000  00003044  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 000001e0  00000000  00000000  000031f0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002feb  00000000  00000000  000033d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000dde  00000000  00000000  000063bb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000014e5  00000000  00000000  00007199  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000009c0  00000000  00000000  00008680  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001440  00000000  00000000  00009040  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002479  00000000  00000000  0000a480  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000000f8  00000000  00000000  0000c8f9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 f0 08 	jmp	0x11e0	; 0x11e0 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 14 01 	jmp	0x228	; 0x228 <__vector_12>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 ed       	ldi	r30, 0xD4	; 212
      68:	f6 e2       	ldi	r31, 0x26	; 38
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a0 39       	cpi	r26, 0x90	; 144
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a0 e9       	ldi	r26, 0x90	; 144
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ac 38       	cpi	r26, 0x8C	; 140
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 d6 12 	call	0x25ac	; 0x25ac <main>
      8a:	0c 94 68 13 	jmp	0x26d0	; 0x26d0 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <adc_init>:
uint8_t ADC_VALUE3;


void adc_init(void)
{
	ADMUX = _BV(REFS0) | _BV(REFS1) | _BV(ADLAR);
      92:	80 ee       	ldi	r24, 0xE0	; 224
      94:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= (ADC_CLOCK_SCALER | _BV(ADEN));
      96:	86 b1       	in	r24, 0x06	; 6
      98:	86 68       	ori	r24, 0x86	; 134
      9a:	86 b9       	out	0x06, r24	; 6
	ADCSRA |= _BV(ADSC);
      9c:	36 9a       	sbi	0x06, 6	; 6
      9e:	e6 e0       	ldi	r30, 0x06	; 6
      a0:	f7 e0       	ldi	r31, 0x07	; 7
uint8_t ADC_VALUE1;
uint8_t ADC_VALUE2;
uint8_t ADC_VALUE3;


void adc_init(void)
      a2:	86 e4       	ldi	r24, 0x46	; 70
      a4:	97 e0       	ldi	r25, 0x07	; 7
	ADMUX = _BV(REFS0) | _BV(REFS1) | _BV(ADLAR);
	ADCSRA |= (ADC_CLOCK_SCALER | _BV(ADEN));
	ADCSRA |= _BV(ADSC);
	for (uint8_t x = 0; x < 64 ; x++ )
	{
		ADC_BUFFER[x] = 0xff;
      a6:	2f ef       	ldi	r18, 0xFF	; 255
      a8:	21 93       	st	Z+, r18
void adc_init(void)
{
	ADMUX = _BV(REFS0) | _BV(REFS1) | _BV(ADLAR);
	ADCSRA |= (ADC_CLOCK_SCALER | _BV(ADEN));
	ADCSRA |= _BV(ADSC);
	for (uint8_t x = 0; x < 64 ; x++ )
      aa:	e8 17       	cp	r30, r24
      ac:	f9 07       	cpc	r31, r25
      ae:	e1 f7       	brne	.-8      	; 0xa8 <adc_init+0x16>
	{
		ADC_BUFFER[x] = 0xff;
	}
}
      b0:	08 95       	ret

000000b2 <adc>:
		while (bit_is_clear(ADCSRA,ADIF)) 
		{
				vTaskDelay(1);
		}
		
		ADC_BUFFER_SUM -= ADC_BUFFER[ADC_BUFFER_POS];
      b2:	c6 e0       	ldi	r28, 0x06	; 6
      b4:	d7 e0       	ldi	r29, 0x07	; 7

void adc(void)
{
	for( ;; )
	{
		ADMUX &= ~(_BV(MUX0));
      b6:	38 98       	cbi	0x07, 0	; 7
		
		ADCSRA |= _BV(ADSC);
      b8:	36 9a       	sbi	0x06, 6	; 6
		
		while (bit_is_clear(ADCSRA,ADIF)) 
      ba:	34 99       	sbic	0x06, 4	; 6
      bc:	06 c0       	rjmp	.+12     	; 0xca <adc+0x18>
		{
				vTaskDelay(1);
      be:	81 e0       	ldi	r24, 0x01	; 1
      c0:	90 e0       	ldi	r25, 0x00	; 0
      c2:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskDelay>
	{
		ADMUX &= ~(_BV(MUX0));
		
		ADCSRA |= _BV(ADSC);
		
		while (bit_is_clear(ADCSRA,ADIF)) 
      c6:	34 9b       	sbis	0x06, 4	; 6
      c8:	fa cf       	rjmp	.-12     	; 0xbe <adc+0xc>
		{
				vTaskDelay(1);
		}
		
		ADC_BUFFER_SUM -= ADC_BUFFER[ADC_BUFFER_POS];
      ca:	20 91 90 00 	lds	r18, 0x0090
      ce:	fe 01       	movw	r30, r28
      d0:	e2 0f       	add	r30, r18
      d2:	f1 1d       	adc	r31, r1
      d4:	30 81       	ld	r19, Z
      d6:	80 91 60 00 	lds	r24, 0x0060
      da:	90 91 61 00 	lds	r25, 0x0061
      de:	83 1b       	sub	r24, r19
      e0:	91 09       	sbc	r25, r1
      e2:	90 93 61 00 	sts	0x0061, r25
      e6:	80 93 60 00 	sts	0x0060, r24
		ADC_BUFFER[ADC_BUFFER_POS] = ADCH;
      ea:	35 b1       	in	r19, 0x05	; 5
      ec:	30 83       	st	Z, r19
		ADC_BUFFER_SUM += ADC_BUFFER[ADC_BUFFER_POS];
      ee:	83 0f       	add	r24, r19
      f0:	91 1d       	adc	r25, r1
      f2:	90 93 61 00 	sts	0x0061, r25
      f6:	80 93 60 00 	sts	0x0060, r24
		ADC_VALUE1 = (ADC_BUFFER_SUM >> 6);
      fa:	00 24       	eor	r0, r0
      fc:	88 0f       	add	r24, r24
      fe:	99 1f       	adc	r25, r25
     100:	00 1c       	adc	r0, r0
     102:	88 0f       	add	r24, r24
     104:	99 1f       	adc	r25, r25
     106:	00 1c       	adc	r0, r0
     108:	89 2f       	mov	r24, r25
     10a:	90 2d       	mov	r25, r0
     10c:	80 93 04 07 	sts	0x0704, r24
		ADC_BUFFER_POS++;
     110:	2f 5f       	subi	r18, 0xFF	; 255
		ADC_BUFFER_POS &= 0x3f;
     112:	2f 73       	andi	r18, 0x3F	; 63
     114:	20 93 90 00 	sts	0x0090, r18
		
		vTaskDelay(ADC_DELAY);
     118:	84 ef       	ldi	r24, 0xF4	; 244
     11a:	91 e0       	ldi	r25, 0x01	; 1
     11c:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskDelay>
		
		ADMUX |= _BV(MUX0);
     120:	38 9a       	sbi	0x07, 0	; 7
		
		ADCSRA |= _BV(ADSC);
     122:	36 9a       	sbi	0x06, 6	; 6
		
		while (bit_is_clear(ADCSRA,ADIF))
     124:	34 99       	sbic	0x06, 4	; 6
     126:	06 c0       	rjmp	.+12     	; 0x134 <adc+0x82>
		{
			vTaskDelay(1);
     128:	81 e0       	ldi	r24, 0x01	; 1
     12a:	90 e0       	ldi	r25, 0x00	; 0
     12c:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskDelay>
		
		ADMUX |= _BV(MUX0);
		
		ADCSRA |= _BV(ADSC);
		
		while (bit_is_clear(ADCSRA,ADIF))
     130:	34 9b       	sbis	0x06, 4	; 6
     132:	fa cf       	rjmp	.-12     	; 0x128 <adc+0x76>
		{
			vTaskDelay(1);
		}
		
		ADC_VALUE2 = ADCH;
     134:	85 b1       	in	r24, 0x05	; 5
     136:	80 93 05 07 	sts	0x0705, r24
		
		vTaskDelay(ADC_DELAY);
     13a:	84 ef       	ldi	r24, 0xF4	; 244
     13c:	91 e0       	ldi	r25, 0x01	; 1
     13e:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskDelay>
		ADMUX &= ~(_BV(MUX0));
     142:	38 98       	cbi	0x07, 0	; 7
		#ifndef DOWN_STAIRS_
		
		ADMUX |= _BV(MUX2);
     144:	3a 9a       	sbi	0x07, 2	; 7
		
		ADCSRA |= _BV(ADSC);
     146:	36 9a       	sbi	0x06, 6	; 6
		
		while (bit_is_clear(ADCSRA,ADIF))
     148:	34 99       	sbic	0x06, 4	; 6
     14a:	06 c0       	rjmp	.+12     	; 0x158 <adc+0xa6>
		{
			vTaskDelay(1);
     14c:	81 e0       	ldi	r24, 0x01	; 1
     14e:	90 e0       	ldi	r25, 0x00	; 0
     150:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskDelay>
		
		ADMUX |= _BV(MUX2);
		
		ADCSRA |= _BV(ADSC);
		
		while (bit_is_clear(ADCSRA,ADIF))
     154:	34 9b       	sbis	0x06, 4	; 6
     156:	fa cf       	rjmp	.-12     	; 0x14c <adc+0x9a>
		{
			vTaskDelay(1);
		}
		
		ADC_VALUE3 = ADCH;
     158:	85 b1       	in	r24, 0x05	; 5
     15a:	80 93 03 07 	sts	0x0703, r24
		vTaskDelay(ADC_DELAY);
     15e:	84 ef       	ldi	r24, 0xF4	; 244
     160:	91 e0       	ldi	r25, 0x01	; 1
     162:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskDelay>
		ADMUX &= ~(_BV(MUX2));
     166:	3a 98       	cbi	0x07, 2	; 7
		#endif	
	}
     168:	a6 cf       	rjmp	.-180    	; 0xb6 <adc+0x4>

0000016a <spi_master_init>:
uint8_t SPI_DATA_MOSI[SPI_DATA_BUFFER_SIZE];
uint8_t SPI_DATA_COUNT;

void spi_master_init(void)
{
	SPI_SLAVE_SELECT_PORT |= (_BV(SPI_SLAVE_SELECT_SS));
     16a:	c4 9a       	sbi	0x18, 4	; 24
	SPI_SLAVE_SELECT_DDR |= _BV(SPI_SLAVE_SELECT_SS);
     16c:	bc 9a       	sbi	0x17, 4	; 23
	/* Set MOSI and SCK output, all others input */
	DDR_SPI = (1<<DD_MOSI)|(1<<DD_SCK);
     16e:	80 ea       	ldi	r24, 0xA0	; 160
     170:	87 bb       	out	0x17, r24	; 23
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);
     172:	83 e5       	ldi	r24, 0x53	; 83
     174:	8d b9       	out	0x0d, r24	; 13
//	PORT_SPI |= (_BV(DD_MISO))  | (_BV(DD_SCK)); //| (_BV(DD_MOSI))
	SPI_SLAVE_SELECT_DDR |= _BV(SPI_SLAVE_SELECT_SS);
     176:	bc 9a       	sbi	0x17, 4	; 23

	
	SPI_DATA_MISO[14]=0xac;
     178:	8c ea       	ldi	r24, 0xAC	; 172
     17a:	80 93 55 07 	sts	0x0755, r24
	SPI_DATA_MISO[15]=0xdd;
     17e:	8d ed       	ldi	r24, 0xDD	; 221
     180:	80 93 56 07 	sts	0x0756, r24
//	for (uint8_t i=0;i<16;i++)
//	{
//	SPI_DATA_MOSI[i]=0xbd;
//	}	
	
}
     184:	08 95       	ret

00000186 <spi_slave_init>:

void spi_slave_init(void)
{
	/* Set MISO output, all others input */
	DDR_SPI = (1<<DD_MISO);
     186:	80 e4       	ldi	r24, 0x40	; 64
     188:	87 bb       	out	0x17, r24	; 23
	/* Enable SPI */
	SPCR = (1<<SPE)| (1<<SPIE);
     18a:	80 ec       	ldi	r24, 0xC0	; 192
     18c:	8d b9       	out	0x0d, r24	; 13
//    PORT_SPI |= (_BV(DD_MOSI)) | (_BV(DD_SCK));
}
     18e:	08 95       	ret

00000190 <spi_master>:
{
	for (;;)
	{
		SPI_SLAVE_SELECT_PORT &= ~(_BV(SPI_SLAVE_SELECT_SS));
		SPI_SLAVE_SELECT_DDR |= _BV(SPI_SLAVE_SELECT_SS);
		SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);
     190:	0f 2e       	mov	r0, r31
     192:	f3 e5       	ldi	r31, 0x53	; 83
     194:	7f 2e       	mov	r7, r31
     196:	f0 2d       	mov	r31, r0
		vTaskDelay(SPI_MASTER_DELAY_SHORT);
     198:	0f 2e       	mov	r0, r31
     19a:	f7 e5       	ldi	r31, 0x57	; 87
     19c:	af 2e       	mov	r10, r31
     19e:	f7 e0       	ldi	r31, 0x07	; 7
     1a0:	bf 2e       	mov	r11, r31
     1a2:	f0 2d       	mov	r31, r0
	/* Enable SPI */
	SPCR = (1<<SPE)| (1<<SPIE);
//    PORT_SPI |= (_BV(DD_MOSI)) | (_BV(DD_SCK));
}

void spi_master(void)
     1a4:	ee 24       	eor	r14, r14
     1a6:	ff 24       	eor	r15, r15
     1a8:	68 94       	set
     1aa:	e4 f8       	bld	r14, 4
     1ac:	ea 0c       	add	r14, r10
     1ae:	fb 1c       	adc	r15, r11
     1b0:	88 24       	eor	r8, r8
     1b2:	8a 94       	dec	r8
     1b4:	98 2c       	mov	r9, r8
			/* Wait for transmission complete */
			while ((SPSR & (_BV(SPIF))) == 0)
			{
			vTaskDelay(SPI_MASTER_DELAY_SHORT);
			}				
			SPI_DATA_MISO[((i-1) & SPI_DATA_BUFFER_MASK)]=SPDR;
     1b6:	0f 2e       	mov	r0, r31
     1b8:	f7 e4       	ldi	r31, 0x47	; 71
     1ba:	cf 2e       	mov	r12, r31
     1bc:	f7 e0       	ldi	r31, 0x07	; 7
     1be:	df 2e       	mov	r13, r31
     1c0:	f0 2d       	mov	r31, r0

void spi_master(void)
{
	for (;;)
	{
		SPI_SLAVE_SELECT_PORT &= ~(_BV(SPI_SLAVE_SELECT_SS));
     1c2:	c4 98       	cbi	0x18, 4	; 24
		SPI_SLAVE_SELECT_DDR |= _BV(SPI_SLAVE_SELECT_SS);
     1c4:	bc 9a       	sbi	0x17, 4	; 23
		SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);
     1c6:	7d b8       	out	0x0d, r7	; 13
		vTaskDelay(SPI_MASTER_DELAY_SHORT);
     1c8:	8a e0       	ldi	r24, 0x0A	; 10
     1ca:	90 e0       	ldi	r25, 0x00	; 0
     1cc:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskDelay>
     1d0:	e5 01       	movw	r28, r10
	/* Enable SPI */
	SPCR = (1<<SPE)| (1<<SPIE);
//    PORT_SPI |= (_BV(DD_MOSI)) | (_BV(DD_SCK));
}

void spi_master(void)
     1d2:	84 01       	movw	r16, r8
		vTaskDelay(SPI_MASTER_DELAY_SHORT);

		for (uint8_t i=0; i < SPI_DATA_BUFFER_SIZE; i++ )
		{
			/* Start transmission */
			SPDR = (SPI_DATA_MOSI[i]);
     1d4:	89 91       	ld	r24, Y+
     1d6:	8f b9       	out	0x0f, r24	; 15
			/* Wait for transmission complete */
			while ((SPSR & (_BV(SPIF))) == 0)
     1d8:	77 99       	sbic	0x0e, 7	; 14
     1da:	06 c0       	rjmp	.+12     	; 0x1e8 <spi_master+0x58>
			{
			vTaskDelay(SPI_MASTER_DELAY_SHORT);
     1dc:	8a e0       	ldi	r24, 0x0A	; 10
     1de:	90 e0       	ldi	r25, 0x00	; 0
     1e0:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskDelay>
		for (uint8_t i=0; i < SPI_DATA_BUFFER_SIZE; i++ )
		{
			/* Start transmission */
			SPDR = (SPI_DATA_MOSI[i]);
			/* Wait for transmission complete */
			while ((SPSR & (_BV(SPIF))) == 0)
     1e4:	77 9b       	sbis	0x0e, 7	; 14
     1e6:	fa cf       	rjmp	.-12     	; 0x1dc <spi_master+0x4c>
			{
			vTaskDelay(SPI_MASTER_DELAY_SHORT);
			}				
			SPI_DATA_MISO[((i-1) & SPI_DATA_BUFFER_MASK)]=SPDR;
     1e8:	2f b1       	in	r18, 0x0f	; 15
     1ea:	c8 01       	movw	r24, r16
     1ec:	8f 70       	andi	r24, 0x0F	; 15
     1ee:	90 70       	andi	r25, 0x00	; 0
     1f0:	8c 0d       	add	r24, r12
     1f2:	9d 1d       	adc	r25, r13
     1f4:	fc 01       	movw	r30, r24
     1f6:	20 83       	st	Z, r18
     1f8:	0f 5f       	subi	r16, 0xFF	; 255
     1fa:	1f 4f       	sbci	r17, 0xFF	; 255
		SPI_SLAVE_SELECT_PORT &= ~(_BV(SPI_SLAVE_SELECT_SS));
		SPI_SLAVE_SELECT_DDR |= _BV(SPI_SLAVE_SELECT_SS);
		SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);
		vTaskDelay(SPI_MASTER_DELAY_SHORT);

		for (uint8_t i=0; i < SPI_DATA_BUFFER_SIZE; i++ )
     1fc:	ce 15       	cp	r28, r14
     1fe:	df 05       	cpc	r29, r15
     200:	49 f7       	brne	.-46     	; 0x1d4 <spi_master+0x44>
			vTaskDelay(SPI_MASTER_DELAY_SHORT);
			}				
			SPI_DATA_MISO[((i-1) & SPI_DATA_BUFFER_MASK)]=SPDR;

		}		
		vTaskDelay((SPI_MASTER_DELAY_LONG/2));
     202:	82 e3       	ldi	r24, 0x32	; 50
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskDelay>
		SPI_SLAVE_SELECT_PORT |= _BV(SPI_SLAVE_SELECT_SS);
     20a:	c4 9a       	sbi	0x18, 4	; 24
		vTaskDelay((SPI_MASTER_DELAY_LONG/2));
     20c:	82 e3       	ldi	r24, 0x32	; 50
     20e:	90 e0       	ldi	r25, 0x00	; 0
     210:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskDelay>
	}	
     214:	d6 cf       	rjmp	.-84     	; 0x1c2 <spi_master+0x32>

00000216 <spi_slave>:

void spi_slave(void)
{
	for (;;)
	{
		if ( (SPI_SLAVE_SELECT_PIN & (_BV(SPI_SLAVE_SELECT_SS)))== (_BV(SPI_SLAVE_SELECT_SS))) 
     216:	b4 9b       	sbis	0x16, 4	; 22
     218:	02 c0       	rjmp	.+4      	; 0x21e <spi_slave+0x8>
		{
			SPI_DATA_COUNT=0;	
     21a:	10 92 46 07 	sts	0x0746, r1
		}		
		vTaskDelay(SPI_SLAVE_DELAY);
     21e:	85 e0       	ldi	r24, 0x05	; 5
     220:	90 e0       	ldi	r25, 0x00	; 0
     222:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskDelay>
	}	
     226:	f7 cf       	rjmp	.-18     	; 0x216 <spi_slave>

00000228 <__vector_12>:
}

#ifdef SPI_SLAVE_
ISR (SPI_STC_vect)
{
     228:	1f 92       	push	r1
     22a:	0f 92       	push	r0
     22c:	0f b6       	in	r0, 0x3f	; 63
     22e:	0f 92       	push	r0
     230:	11 24       	eor	r1, r1
     232:	2f 93       	push	r18
     234:	3f 93       	push	r19
     236:	8f 93       	push	r24
     238:	9f 93       	push	r25
     23a:	ef 93       	push	r30
     23c:	ff 93       	push	r31
	SPI_DATA_MOSI[SPI_DATA_COUNT]=SPDR;
     23e:	20 91 46 07 	lds	r18, 0x0746
     242:	82 2f       	mov	r24, r18
     244:	90 e0       	ldi	r25, 0x00	; 0
     246:	3f b1       	in	r19, 0x0f	; 15
     248:	fc 01       	movw	r30, r24
     24a:	e9 5a       	subi	r30, 0xA9	; 169
     24c:	f8 4f       	sbci	r31, 0xF8	; 248
     24e:	30 83       	st	Z, r19
	SPDR=SPI_DATA_MISO[SPI_DATA_COUNT];
     250:	89 5b       	subi	r24, 0xB9	; 185
     252:	98 4f       	sbci	r25, 0xF8	; 248
     254:	fc 01       	movw	r30, r24
     256:	80 81       	ld	r24, Z
     258:	8f b9       	out	0x0f, r24	; 15
	SPI_DATA_COUNT++;
     25a:	2f 5f       	subi	r18, 0xFF	; 255
	SPI_DATA_COUNT &= SPI_DATA_BUFFER_MASK;
     25c:	2f 70       	andi	r18, 0x0F	; 15
     25e:	20 93 46 07 	sts	0x0746, r18

}
     262:	ff 91       	pop	r31
     264:	ef 91       	pop	r30
     266:	9f 91       	pop	r25
     268:	8f 91       	pop	r24
     26a:	3f 91       	pop	r19
     26c:	2f 91       	pop	r18
     26e:	0f 90       	pop	r0
     270:	0f be       	out	0x3f, r0	; 63
     272:	0f 90       	pop	r0
     274:	1f 90       	pop	r1
     276:	18 95       	reti

00000278 <stepper_init>:
uint16_t STEPPER_POS_INTERNAL;
uint8_t STEPPER_DISPLAY;

void stepper_init (void)
{
	STEPPER_PORT &= ~(0x0f << STEPPER_SHIFT);
     278:	85 b3       	in	r24, 0x15	; 21
     27a:	8f 70       	andi	r24, 0x0F	; 15
     27c:	85 bb       	out	0x15, r24	; 21
	STEPPER_STOP_PORT |= _BV(STEPPER_STOP);
     27e:	de 9a       	sbi	0x1b, 6	; 27
	STEPPER_DDR |= (0x0f << STEPPER_SHIFT);
     280:	84 b3       	in	r24, 0x14	; 20
     282:	80 6f       	ori	r24, 0xF0	; 240
     284:	84 bb       	out	0x14, r24	; 20
	STEPPER_STOP_DDR |= _BV(STEPPER_STOP);
     286:	d6 9a       	sbi	0x1a, 6	; 26
	
	STEPPER_CYCLE[0] = STEPPER_CYCLE1;
     288:	8c e0       	ldi	r24, 0x0C	; 12
     28a:	80 93 67 07 	sts	0x0767, r24
	STEPPER_CYCLE[1] = STEPPER_CYCLE2;
     28e:	89 e0       	ldi	r24, 0x09	; 9
     290:	80 93 68 07 	sts	0x0768, r24
	STEPPER_CYCLE[2] = STEPPER_CYCLE3;
     294:	83 e0       	ldi	r24, 0x03	; 3
     296:	80 93 69 07 	sts	0x0769, r24
	STEPPER_CYCLE[3] = STEPPER_CYCLE4;
     29a:	86 e0       	ldi	r24, 0x06	; 6
     29c:	80 93 6a 07 	sts	0x076A, r24
	STEPPER_POS_INTERNAL=STEPPER_POS_START;
     2a0:	80 e0       	ldi	r24, 0x00	; 0
     2a2:	90 e4       	ldi	r25, 0x40	; 64
     2a4:	90 93 72 07 	sts	0x0772, r25
     2a8:	80 93 71 07 	sts	0x0771, r24
	STEPPER_POS=STEPPER_POS_START;
     2ac:	90 93 70 07 	sts	0x0770, r25
     2b0:	80 93 6f 07 	sts	0x076F, r24
	STEPPER_POS_CURRENT=STEPPER_POS_CURRENT_START;
     2b4:	10 92 6c 07 	sts	0x076C, r1
     2b8:	10 92 6b 07 	sts	0x076B, r1
	STEPPER_INIT_DONE=0;
     2bc:	10 92 6d 07 	sts	0x076D, r1

}
     2c0:	08 95       	ret

000002c2 <stepper_pos_calc>:

void stepper_pos_calc(void)
{ 
	if (STEPPER_POS_CURRENT >= damper_open_pos)
     2c2:	80 91 6b 07 	lds	r24, 0x076B
     2c6:	90 91 6c 07 	lds	r25, 0x076C
     2ca:	2c e1       	ldi	r18, 0x1C	; 28
     2cc:	80 30       	cpi	r24, 0x00	; 0
     2ce:	92 07       	cpc	r25, r18
     2d0:	50 f0       	brcs	.+20     	; 0x2e6 <stepper_pos_calc+0x24>
	{
		STEPPER_DISPLAY = ((STEPPER_POS_CURRENT-damper_open_pos)/((damper_close_pos-damper_open_pos)/11));
     2d2:	80 50       	subi	r24, 0x00	; 0
     2d4:	9c 41       	sbci	r25, 0x1C	; 28
     2d6:	68 ee       	ldi	r22, 0xE8	; 232
     2d8:	72 e0       	ldi	r23, 0x02	; 2
     2da:	0e 94 35 13 	call	0x266a	; 0x266a <__udivmodhi4>
		STEPPER_DISPLAY += 6;
     2de:	6a 5f       	subi	r22, 0xFA	; 250
     2e0:	60 93 6e 07 	sts	0x076E, r22
     2e4:	08 c0       	rjmp	.+16     	; 0x2f6 <stepper_pos_calc+0x34>
	}
	else
	{
		STEPPER_DISPLAY = ((STEPPER_POS_CURRENT-bottem_open_pos)/((damper_open_pos-bottem_open_pos)/5));
     2e6:	80 50       	subi	r24, 0x00	; 0
     2e8:	9a 40       	sbci	r25, 0x0A	; 10
     2ea:	69 e9       	ldi	r22, 0x99	; 153
     2ec:	73 e0       	ldi	r23, 0x03	; 3
     2ee:	0e 94 35 13 	call	0x266a	; 0x266a <__udivmodhi4>
     2f2:	60 93 6e 07 	sts	0x076E, r22
	}
	if (STEPPER_POS_CURRENT > damper_close_pos)
     2f6:	80 91 6b 07 	lds	r24, 0x076B
     2fa:	90 91 6c 07 	lds	r25, 0x076C
     2fe:	2c e3       	ldi	r18, 0x3C	; 60
     300:	81 30       	cpi	r24, 0x01	; 1
     302:	92 07       	cpc	r25, r18
     304:	18 f0       	brcs	.+6      	; 0x30c <stepper_pos_calc+0x4a>
	{
		STEPPER_DISPLAY=0x11;	
     306:	21 e1       	ldi	r18, 0x11	; 17
     308:	20 93 6e 07 	sts	0x076E, r18
	}
	if (STEPPER_POS_CURRENT < bottem_open_pos)
     30c:	2a e0       	ldi	r18, 0x0A	; 10
     30e:	80 30       	cpi	r24, 0x00	; 0
     310:	92 07       	cpc	r25, r18
     312:	10 f4       	brcc	.+4      	; 0x318 <stepper_pos_calc+0x56>
	{
		STEPPER_DISPLAY=0;
     314:	10 92 6e 07 	sts	0x076E, r1
     318:	08 95       	ret

0000031a <stepper>:
		STEPPER_STOP_VAR >>= STEPPER_STOP;
		if (STEPPER_STOP_VAR != 0x01 )
		{
			if ((STEPPER_POS_CURRENT & 0xff00) != (STEPPER_POS_STOP & 0xFF00))
			{
				STEPPER_POS_CURRENT = STEPPER_POS_STOP;
     31a:	0f ef       	ldi	r16, 0xFF	; 255
     31c:	1f e3       	ldi	r17, 0x3F	; 63
				STEPPER_POS_INTERNAL= STEPPER_POS_STOP;
				STEPPER_INIT_DONE = 1;
     31e:	c1 e0       	ldi	r28, 0x01	; 1
	uint16_t STEPPER_STEP = 0;
	uint8_t  STEPPER_STOP_VAR;
	
	for ( ;; )
	{
		stepper_pos_calc();	
     320:	0e 94 61 01 	call	0x2c2	; 0x2c2 <stepper_pos_calc>
		STEPPER_STOP_VAR = STEPPER_STOP_PIN & _BV(STEPPER_STOP);
     324:	89 b3       	in	r24, 0x19	; 25
		STEPPER_STOP_VAR >>= STEPPER_STOP;
		if (STEPPER_STOP_VAR != 0x01 )
     326:	86 fd       	sbrc	r24, 6
     328:	10 c0       	rjmp	.+32     	; 0x34a <stepper+0x30>
		{
			if ((STEPPER_POS_CURRENT & 0xff00) != (STEPPER_POS_STOP & 0xFF00))
     32a:	80 91 6b 07 	lds	r24, 0x076B
     32e:	90 91 6c 07 	lds	r25, 0x076C
     332:	80 70       	andi	r24, 0x00	; 0
     334:	2f e3       	ldi	r18, 0x3F	; 63
     336:	80 30       	cpi	r24, 0x00	; 0
     338:	92 07       	cpc	r25, r18
     33a:	39 f0       	breq	.+14     	; 0x34a <stepper+0x30>
			{
				STEPPER_POS_CURRENT = STEPPER_POS_STOP;
     33c:	10 93 6c 07 	sts	0x076C, r17
     340:	00 93 6b 07 	sts	0x076B, r16
				STEPPER_POS_INTERNAL= STEPPER_POS_STOP;
				STEPPER_INIT_DONE = 1;
     344:	c0 93 6d 07 	sts	0x076D, r28
     348:	04 c0       	rjmp	.+8      	; 0x352 <stepper+0x38>
			}							
		}
		if (STEPPER_INIT_DONE == 1)
     34a:	80 91 6d 07 	lds	r24, 0x076D
     34e:	81 30       	cpi	r24, 0x01	; 1
     350:	41 f4       	brne	.+16     	; 0x362 <stepper+0x48>
		{
			STEPPER_POS_INTERNAL=STEPPER_POS;
     352:	80 91 6f 07 	lds	r24, 0x076F
     356:	90 91 70 07 	lds	r25, 0x0770
     35a:	90 93 72 07 	sts	0x0772, r25
     35e:	80 93 71 07 	sts	0x0771, r24

		}
		if (STEPPER_POS_INTERNAL == STEPPER_POS_CURRENT)
     362:	20 91 71 07 	lds	r18, 0x0771
     366:	30 91 72 07 	lds	r19, 0x0772
     36a:	80 91 6b 07 	lds	r24, 0x076B
     36e:	90 91 6c 07 	lds	r25, 0x076C
     372:	28 17       	cp	r18, r24
     374:	39 07       	cpc	r19, r25
     376:	21 f4       	brne	.+8      	; 0x380 <stepper+0x66>
		{
			STEPPER_PORT &= ~(0x0f << STEPPER_SHIFT);	
     378:	85 b3       	in	r24, 0x15	; 21
     37a:	8f 70       	andi	r24, 0x0F	; 15
     37c:	85 bb       	out	0x15, r24	; 21
     37e:	2a c0       	rjmp	.+84     	; 0x3d4 <stepper+0xba>
		}
		else
		{
			if (STEPPER_POS_INTERNAL > STEPPER_POS_CURRENT)
     380:	82 17       	cp	r24, r18
     382:	93 07       	cpc	r25, r19
     384:	a0 f4       	brcc	.+40     	; 0x3ae <stepper+0x94>
			{
				STEPPER_POS_CURRENT++;
     386:	01 96       	adiw	r24, 0x01	; 1
     388:	90 93 6c 07 	sts	0x076C, r25
     38c:	80 93 6b 07 	sts	0x076B, r24
				STEPPER_STEP = STEPPER_POS_CURRENT;
				STEPPER_STEP &= 0b11;
                STEPPER_PORT &= ~(0x0f << STEPPER_SHIFT);
     390:	25 b3       	in	r18, 0x15	; 21
     392:	2f 70       	andi	r18, 0x0F	; 15
     394:	25 bb       	out	0x15, r18	; 21
				STEPPER_PORT |= (STEPPER_CYCLE[STEPPER_STEP] << STEPPER_SHIFT);
     396:	25 b3       	in	r18, 0x15	; 21
		{
			if (STEPPER_POS_INTERNAL > STEPPER_POS_CURRENT)
			{
				STEPPER_POS_CURRENT++;
				STEPPER_STEP = STEPPER_POS_CURRENT;
				STEPPER_STEP &= 0b11;
     398:	83 70       	andi	r24, 0x03	; 3
     39a:	90 70       	andi	r25, 0x00	; 0
                STEPPER_PORT &= ~(0x0f << STEPPER_SHIFT);
				STEPPER_PORT |= (STEPPER_CYCLE[STEPPER_STEP] << STEPPER_SHIFT);
     39c:	fc 01       	movw	r30, r24
     39e:	e9 59       	subi	r30, 0x99	; 153
     3a0:	f8 4f       	sbci	r31, 0xF8	; 248
     3a2:	80 81       	ld	r24, Z
     3a4:	82 95       	swap	r24
     3a6:	80 7f       	andi	r24, 0xF0	; 240
     3a8:	82 2b       	or	r24, r18
     3aa:	85 bb       	out	0x15, r24	; 21
     3ac:	13 c0       	rjmp	.+38     	; 0x3d4 <stepper+0xba>
			}
			else
			{
				STEPPER_POS_CURRENT--;
     3ae:	01 97       	sbiw	r24, 0x01	; 1
     3b0:	90 93 6c 07 	sts	0x076C, r25
     3b4:	80 93 6b 07 	sts	0x076B, r24
				STEPPER_STEP = STEPPER_POS_CURRENT;
				STEPPER_STEP &= 0b11;
				STEPPER_PORT &= ~(0x0f << STEPPER_SHIFT);
     3b8:	25 b3       	in	r18, 0x15	; 21
     3ba:	2f 70       	andi	r18, 0x0F	; 15
     3bc:	25 bb       	out	0x15, r18	; 21
				STEPPER_PORT |= (STEPPER_CYCLE[STEPPER_STEP] << STEPPER_SHIFT);				
     3be:	25 b3       	in	r18, 0x15	; 21
			}
			else
			{
				STEPPER_POS_CURRENT--;
				STEPPER_STEP = STEPPER_POS_CURRENT;
				STEPPER_STEP &= 0b11;
     3c0:	83 70       	andi	r24, 0x03	; 3
     3c2:	90 70       	andi	r25, 0x00	; 0
				STEPPER_PORT &= ~(0x0f << STEPPER_SHIFT);
				STEPPER_PORT |= (STEPPER_CYCLE[STEPPER_STEP] << STEPPER_SHIFT);				
     3c4:	fc 01       	movw	r30, r24
     3c6:	e9 59       	subi	r30, 0x99	; 153
     3c8:	f8 4f       	sbci	r31, 0xF8	; 248
     3ca:	80 81       	ld	r24, Z
     3cc:	82 95       	swap	r24
     3ce:	80 7f       	andi	r24, 0xF0	; 240
     3d0:	82 2b       	or	r24, r18
     3d2:	85 bb       	out	0x15, r24	; 21
			}
		}

	vTaskDelay (STEPPER_SPEED);
     3d4:	86 e0       	ldi	r24, 0x06	; 6
     3d6:	90 e0       	ldi	r25, 0x00	; 0
     3d8:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskDelay>
		
	}
     3dc:	a1 cf       	rjmp	.-190    	; 0x320 <stepper+0x6>

000003de <stove_cooldown_test>:
	}		
}

void stove_cooldown_test(uint8_t stove_target_temp_test, uint16_t stove_cooldown_count_amount )
{
	if (STEPPER_POS != stove_run_lower_limit)
     3de:	40 91 6f 07 	lds	r20, 0x076F
     3e2:	50 91 70 07 	lds	r21, 0x0770
     3e6:	20 91 75 07 	lds	r18, 0x0775
     3ea:	30 91 76 07 	lds	r19, 0x0776
     3ee:	42 17       	cp	r20, r18
     3f0:	53 07       	cpc	r21, r19
     3f2:	21 f0       	breq	.+8      	; 0x3fc <stove_cooldown_test+0x1e>
	{
		stove_cooldown_count=0;
     3f4:	10 92 74 07 	sts	0x0774, r1
     3f8:	10 92 73 07 	sts	0x0773, r1
	}
	if (ADC_VALUE1 >= stove_target_temp)
     3fc:	20 91 04 07 	lds	r18, 0x0704
     400:	90 91 87 07 	lds	r25, 0x0787
     404:	29 17       	cp	r18, r25
     406:	28 f0       	brcs	.+10     	; 0x412 <stove_cooldown_test+0x34>
	{
		stove_cooldown_count=0;
     408:	10 92 74 07 	sts	0x0774, r1
     40c:	10 92 73 07 	sts	0x0773, r1
     410:	08 95       	ret
	}
	else
	{
		if (stove_cooldown_count <= stove_cooldown_count_amount) 
     412:	20 91 73 07 	lds	r18, 0x0773
     416:	30 91 74 07 	lds	r19, 0x0774
     41a:	62 17       	cp	r22, r18
     41c:	73 07       	cpc	r23, r19
     41e:	38 f0       	brcs	.+14     	; 0x42e <stove_cooldown_test+0x50>
		{
			stove_cooldown_count++;
     420:	2f 5f       	subi	r18, 0xFF	; 255
     422:	3f 4f       	sbci	r19, 0xFF	; 255
     424:	30 93 74 07 	sts	0x0774, r19
     428:	20 93 73 07 	sts	0x0773, r18
     42c:	08 95       	ret
		}
		else
		{
			stove_target_temp=stove_target_temp_test;
     42e:	80 93 87 07 	sts	0x0787, r24
			stove_target_temp_lockout=stove_target_temp_test;
     432:	80 93 79 07 	sts	0x0779, r24
			stove_cooldown_count=0;
     436:	10 92 74 07 	sts	0x0774, r1
     43a:	10 92 73 07 	sts	0x0773, r1
     43e:	08 95       	ret

00000440 <stove_target_temp_config>:
		}
	}
}

void stove_target_temp_config(uint8_t stove_target_temp_higher, uint8_t stove_target_temp_lower, uint16_t stove_run_change_count_len)
{   
     440:	78 2f       	mov	r23, r24
     442:	fa 01       	movw	r30, r20
	if (ds1620_temp == (stove_mode_room_temp_target_var*2))
     444:	40 91 8a 07 	lds	r20, 0x078A
     448:	50 e0       	ldi	r21, 0x00	; 0
     44a:	80 91 85 07 	lds	r24, 0x0785
     44e:	90 e0       	ldi	r25, 0x00	; 0
     450:	9c 01       	movw	r18, r24
     452:	22 0f       	add	r18, r18
     454:	33 1f       	adc	r19, r19
     456:	42 17       	cp	r20, r18
     458:	53 07       	cpc	r21, r19
     45a:	21 f4       	brne	.+8      	; 0x464 <stove_target_temp_config+0x24>
	{
		stove_run_change_temp_count=0;
     45c:	10 92 84 07 	sts	0x0784, r1
     460:	10 92 83 07 	sts	0x0783, r1
	}
	if (ds1620_temp >= ((stove_mode_room_temp_target_var+stove_mode_room_temp_over)*2))
     464:	01 96       	adiw	r24, 0x01	; 1
     466:	88 0f       	add	r24, r24
     468:	99 1f       	adc	r25, r25
     46a:	48 17       	cp	r20, r24
     46c:	59 07       	cpc	r21, r25
     46e:	9c f0       	brlt	.+38     	; 0x496 <stove_target_temp_config+0x56>
	{
		if (stove_run_change_temp_count <= stove_run_change_count_len)
     470:	80 91 83 07 	lds	r24, 0x0783
     474:	90 91 84 07 	lds	r25, 0x0784
     478:	e8 17       	cp	r30, r24
     47a:	f9 07       	cpc	r31, r25
     47c:	30 f0       	brcs	.+12     	; 0x48a <stove_target_temp_config+0x4a>
		{
			stove_run_change_temp_count++;
     47e:	01 96       	adiw	r24, 0x01	; 1
     480:	90 93 84 07 	sts	0x0784, r25
     484:	80 93 83 07 	sts	0x0783, r24
     488:	06 c0       	rjmp	.+12     	; 0x496 <stove_target_temp_config+0x56>
		}
		else 
		{
			stove_run_change_temp_count=0;
     48a:	10 92 84 07 	sts	0x0784, r1
     48e:	10 92 83 07 	sts	0x0783, r1
			stove_target_temp=stove_target_temp_lower;			
     492:	60 93 87 07 	sts	0x0787, r22
		}
	}
	if (ds1620_temp <=((stove_mode_room_temp_target_var-stove_mode_room_temp_under)*2))
     496:	80 91 8a 07 	lds	r24, 0x078A
     49a:	90 e0       	ldi	r25, 0x00	; 0
     49c:	20 91 85 07 	lds	r18, 0x0785
     4a0:	30 e0       	ldi	r19, 0x00	; 0
     4a2:	21 50       	subi	r18, 0x01	; 1
     4a4:	30 40       	sbci	r19, 0x00	; 0
     4a6:	22 0f       	add	r18, r18
     4a8:	33 1f       	adc	r19, r19
     4aa:	28 17       	cp	r18, r24
     4ac:	39 07       	cpc	r19, r25
     4ae:	9c f0       	brlt	.+38     	; 0x4d6 <stove_target_temp_config+0x96>
	{
		if (stove_run_change_temp_count <= stove_run_change_count_len)
     4b0:	80 91 83 07 	lds	r24, 0x0783
     4b4:	90 91 84 07 	lds	r25, 0x0784
     4b8:	e8 17       	cp	r30, r24
     4ba:	f9 07       	cpc	r31, r25
     4bc:	30 f0       	brcs	.+12     	; 0x4ca <stove_target_temp_config+0x8a>
		{
			stove_run_change_temp_count++;
     4be:	01 96       	adiw	r24, 0x01	; 1
     4c0:	90 93 84 07 	sts	0x0784, r25
     4c4:	80 93 83 07 	sts	0x0783, r24
     4c8:	08 95       	ret
		}
		else
		{
			stove_run_change_temp_count=0;
     4ca:	10 92 84 07 	sts	0x0784, r1
     4ce:	10 92 83 07 	sts	0x0783, r1
			stove_target_temp=stove_target_temp_higher;
     4d2:	70 93 87 07 	sts	0x0787, r23
     4d6:	08 95       	ret

000004d8 <stove_control_nite_mode>:
}

void stove_control_nite_mode(void)
{
	
}
     4d8:	08 95       	ret

000004da <stove_control_reset>:
	eeprom_update_byte(&stove_mode_room_temp_target_ee,stove_mode_room_temp_target_var);
	sei();
	stove_control_buzzer_count_upstairs=0;
#endif
#ifdef DOWN_STAIRS_
	stove_mode_room_temp_target_var=stove_mode_room_temp_target;
     4da:	94 e1       	ldi	r25, 0x14	; 20
     4dc:	90 93 85 07 	sts	0x0785, r25
#endif
	
	stove_mode_start_first=0;
     4e0:	10 92 7a 07 	sts	0x077A, r1
	stove_run_upper_limit = damper_close_pos;
     4e4:	20 e0       	ldi	r18, 0x00	; 0
     4e6:	3c e3       	ldi	r19, 0x3C	; 60
     4e8:	30 93 7d 07 	sts	0x077D, r19
     4ec:	20 93 7c 07 	sts	0x077C, r18
	stove_run_lower_limit = damper_open_pos;
     4f0:	20 e0       	ldi	r18, 0x00	; 0
     4f2:	3c e1       	ldi	r19, 0x1C	; 28
     4f4:	30 93 76 07 	sts	0x0776, r19
     4f8:	20 93 75 07 	sts	0x0775, r18
	stove_target_temp_lockout=stove_start_temp;
     4fc:	90 ed       	ldi	r25, 0xD0	; 208
     4fe:	90 93 79 07 	sts	0x0779, r25
	stove_target_temp=stove_run_hot_temp;
     502:	98 eb       	ldi	r25, 0xB8	; 184
     504:	90 93 87 07 	sts	0x0787, r25
	stove_cooldown_count=0;
     508:	10 92 74 07 	sts	0x0774, r1
     50c:	10 92 73 07 	sts	0x0773, r1
	stove_mode &= 0xF0;
     510:	90 91 7e 07 	lds	r25, 0x077E
     514:	90 7f       	andi	r25, 0xF0	; 240
     516:	90 93 7e 07 	sts	0x077E, r25
	if (stove_target_temp == 00 )
	{
		stove_target_temp=stove_run_hot_temp; 
	}
		
	if (stove_control_reset_mode == stove_control_reset_nite)
     51a:	82 30       	cpi	r24, 0x02	; 2
     51c:	41 f4       	brne	.+16     	; 0x52e <stove_control_reset+0x54>
	{
		stove_target_temp_lockout=stove_run_cool_temp;
     51e:	84 e6       	ldi	r24, 0x64	; 100
     520:	80 93 79 07 	sts	0x0779, r24
		stove_target_temp=stove_run_cool_temp;
     524:	80 93 87 07 	sts	0x0787, r24
		stove_mode &= 0xF0;
		stove_mode |= MODE_NITE;	
     528:	91 60       	ori	r25, 0x01	; 1
     52a:	90 93 7e 07 	sts	0x077E, r25
     52e:	08 95       	ret

00000530 <stove_control_init>:
#endif



void stove_control_init(void)
{
     530:	cf 93       	push	r28
     532:	df 93       	push	r29
	stove_mode_room_temp_target_var =eeprom_read_byte(&stove_mode_room_temp_target_ee);
	stove_control_buzzer_PORT |= (_BV(stove_control_buzzer_PI));
	stove_control_buzzer_DDR |= _BV(stove_control_buzzer_PI);
#endif

	stove_control_led_PORT &= ~(_BV(stove_control_led_PI));
     534:	da 98       	cbi	0x1b, 2	; 27
	stove_control_led_DDR |=_BV(stove_control_led_PI);
     536:	d2 9a       	sbi	0x1a, 2	; 26
	
	STEPPER_POS=damper_shutdown_pos;  
     538:	c0 e8       	ldi	r28, 0x80	; 128
     53a:	dd e3       	ldi	r29, 0x3D	; 61
     53c:	d0 93 70 07 	sts	0x0770, r29
     540:	c0 93 6f 07 	sts	0x076F, r28
	stove_target_temp = stove_start_temp;
     544:	80 ed       	ldi	r24, 0xD0	; 208
     546:	80 93 87 07 	sts	0x0787, r24
	stove_run_change_count = 0;
     54a:	10 92 78 07 	sts	0x0778, r1
     54e:	10 92 77 07 	sts	0x0777, r1
	stove_run_upper_limit = damper_close_pos;
     552:	80 e0       	ldi	r24, 0x00	; 0
     554:	9c e3       	ldi	r25, 0x3C	; 60
     556:	90 93 7d 07 	sts	0x077D, r25
     55a:	80 93 7c 07 	sts	0x077C, r24
	stove_run_lower_limit = damper_open_pos;
     55e:	80 e0       	ldi	r24, 0x00	; 0
     560:	9c e1       	ldi	r25, 0x1C	; 28
     562:	90 93 76 07 	sts	0x0776, r25
     566:	80 93 75 07 	sts	0x0775, r24
	stove_run_limit_result = 0;
     56a:	10 92 86 07 	sts	0x0786, r1
	stove_target_temp_lockout=0;
     56e:	10 92 79 07 	sts	0x0779, r1
	stove_mode=0;
	stove_mode &= 0xF0;
	stove_mode |= MODE_NORM;
	stove_mode |= (4<<MODE_SRT);
     572:	88 e0       	ldi	r24, 0x08	; 8
     574:	80 93 7e 07 	sts	0x077E, r24

	stove_control_reset(stove_control_reset_normal);
     578:	81 e0       	ldi	r24, 0x01	; 1
     57a:	0e 94 6d 02 	call	0x4da	; 0x4da <stove_control_reset>
	stove_mode_start_first=2;
     57e:	82 e0       	ldi	r24, 0x02	; 2
     580:	80 93 7a 07 	sts	0x077A, r24
	STEPPER_POS=damper_shutdown_pos;
     584:	d0 93 70 07 	sts	0x0770, r29
     588:	c0 93 6f 07 	sts	0x076F, r28
}
     58c:	df 91       	pop	r29
     58e:	cf 91       	pop	r28
     590:	08 95       	ret

00000592 <stove_control_change_damper_pos>:
	}
}

void stove_control_change_damper_pos(uint8_t i)
{
	stove_run_limit_result = 0;
     592:	10 92 86 07 	sts	0x0786, r1
	
	if (i == 1)
     596:	81 30       	cpi	r24, 0x01	; 1
     598:	49 f5       	brne	.+82     	; 0x5ec <stove_control_change_damper_pos+0x5a>
	{
		if (STEPPER_POS >= stove_run_change_steps)
     59a:	20 91 6f 07 	lds	r18, 0x076F
     59e:	30 91 70 07 	lds	r19, 0x0770
     5a2:	80 91 7f 07 	lds	r24, 0x077F
     5a6:	90 91 80 07 	lds	r25, 0x0780
     5aa:	28 17       	cp	r18, r24
     5ac:	39 07       	cpc	r19, r25
     5ae:	38 f0       	brcs	.+14     	; 0x5be <stove_control_change_damper_pos+0x2c>
		{
			STEPPER_POS -= stove_run_change_steps;
     5b0:	28 1b       	sub	r18, r24
     5b2:	39 0b       	sbc	r19, r25
     5b4:	30 93 70 07 	sts	0x0770, r19
     5b8:	20 93 6f 07 	sts	0x076F, r18
     5bc:	04 c0       	rjmp	.+8      	; 0x5c6 <stove_control_change_damper_pos+0x34>
		}
		else
		{
			STEPPER_POS = 0;
     5be:	10 92 70 07 	sts	0x0770, r1
     5c2:	10 92 6f 07 	sts	0x076F, r1
		}
		
		if (STEPPER_POS < stove_run_lower_limit)
     5c6:	80 91 75 07 	lds	r24, 0x0775
     5ca:	90 91 76 07 	lds	r25, 0x0776
     5ce:	20 91 6f 07 	lds	r18, 0x076F
     5d2:	30 91 70 07 	lds	r19, 0x0770
     5d6:	28 17       	cp	r18, r24
     5d8:	39 07       	cpc	r19, r25
     5da:	a8 f5       	brcc	.+106    	; 0x646 <stove_control_change_damper_pos+0xb4>
		{
			STEPPER_POS = stove_run_lower_limit;
     5dc:	90 93 70 07 	sts	0x0770, r25
     5e0:	80 93 6f 07 	sts	0x076F, r24
			stove_run_limit_result = 1 ;
     5e4:	81 e0       	ldi	r24, 0x01	; 1
     5e6:	80 93 86 07 	sts	0x0786, r24
     5ea:	08 95       	ret
		}

	}
	else
	{
		if ((0xFFFF - STEPPER_POS) >= stove_run_change_steps)
     5ec:	80 91 6f 07 	lds	r24, 0x076F
     5f0:	90 91 70 07 	lds	r25, 0x0770
     5f4:	20 91 7f 07 	lds	r18, 0x077F
     5f8:	30 91 80 07 	lds	r19, 0x0780
     5fc:	ac 01       	movw	r20, r24
     5fe:	40 95       	com	r20
     600:	50 95       	com	r21
     602:	42 17       	cp	r20, r18
     604:	53 07       	cpc	r21, r19
     606:	38 f0       	brcs	.+14     	; 0x616 <stove_control_change_damper_pos+0x84>
		{
			STEPPER_POS += stove_run_change_steps;
     608:	82 0f       	add	r24, r18
     60a:	93 1f       	adc	r25, r19
     60c:	90 93 70 07 	sts	0x0770, r25
     610:	80 93 6f 07 	sts	0x076F, r24
     614:	06 c0       	rjmp	.+12     	; 0x622 <stove_control_change_damper_pos+0x90>
		}
		else
		{
			STEPPER_POS = 0xFFFF;
     616:	8f ef       	ldi	r24, 0xFF	; 255
     618:	9f ef       	ldi	r25, 0xFF	; 255
     61a:	90 93 70 07 	sts	0x0770, r25
     61e:	80 93 6f 07 	sts	0x076F, r24
		}
		
		if (STEPPER_POS > stove_run_upper_limit)
     622:	80 91 7c 07 	lds	r24, 0x077C
     626:	90 91 7d 07 	lds	r25, 0x077D
     62a:	20 91 6f 07 	lds	r18, 0x076F
     62e:	30 91 70 07 	lds	r19, 0x0770
     632:	82 17       	cp	r24, r18
     634:	93 07       	cpc	r25, r19
     636:	38 f4       	brcc	.+14     	; 0x646 <stove_control_change_damper_pos+0xb4>
		{
			STEPPER_POS = stove_run_upper_limit;
     638:	90 93 70 07 	sts	0x0770, r25
     63c:	80 93 6f 07 	sts	0x076F, r24
			stove_run_limit_result = 2 ;
     640:	82 e0       	ldi	r24, 0x02	; 2
     642:	80 93 86 07 	sts	0x0786, r24
     646:	08 95       	ret

00000648 <stove_control_fuzzy>:
		/*
		Test stove temp against target temp if equal do nothing
		if not see how far away from target 
		if    mask     then        delay  and amount of change
		*/
		if (ADC_VALUE1 != stove_target_temp)
     648:	20 91 04 07 	lds	r18, 0x0704
     64c:	80 91 87 07 	lds	r24, 0x0787
     650:	28 17       	cp	r18, r24
     652:	09 f4       	brne	.+2      	; 0x656 <stove_control_fuzzy+0xe>
     654:	44 c0       	rjmp	.+136    	; 0x6de <stove_control_fuzzy+0x96>
		{
			if ((ADC_VALUE1 & (~stove_run_change_stage2_mask)) == (stove_target_temp & (~stove_run_change_stage2_mask)))
     656:	90 e0       	ldi	r25, 0x00	; 0
     658:	30 e0       	ldi	r19, 0x00	; 0
     65a:	82 27       	eor	r24, r18
     65c:	93 27       	eor	r25, r19
     65e:	9c 01       	movw	r18, r24
     660:	2c 7f       	andi	r18, 0xFC	; 252
     662:	21 15       	cp	r18, r1
     664:	31 05       	cpc	r19, r1
     666:	69 f4       	brne	.+26     	; 0x682 <stove_control_fuzzy+0x3a>
			{
				stove_run_change_count_len = stove_run_change_count_len_stage1;
     668:	8f e4       	ldi	r24, 0x4F	; 79
     66a:	90 e0       	ldi	r25, 0x00	; 0
     66c:	90 93 82 07 	sts	0x0782, r25
     670:	80 93 81 07 	sts	0x0781, r24
				stove_run_change_steps = stove_run_change_steps_stage1;
     674:	80 e3       	ldi	r24, 0x30	; 48
     676:	90 e0       	ldi	r25, 0x00	; 0
     678:	90 93 80 07 	sts	0x0780, r25
     67c:	80 93 7f 07 	sts	0x077F, r24
     680:	2e c0       	rjmp	.+92     	; 0x6de <stove_control_fuzzy+0x96>
			}
			else
			{
				if ((ADC_VALUE1 & (~stove_run_change_stage3_mask)) == (stove_target_temp & (~stove_run_change_stage3_mask)))
     682:	9c 01       	movw	r18, r24
     684:	20 7f       	andi	r18, 0xF0	; 240
     686:	21 15       	cp	r18, r1
     688:	31 05       	cpc	r19, r1
     68a:	69 f4       	brne	.+26     	; 0x6a6 <stove_control_fuzzy+0x5e>
				{
					stove_run_change_count_len = stove_run_change_count_len_stage2;
     68c:	8f e1       	ldi	r24, 0x1F	; 31
     68e:	90 e0       	ldi	r25, 0x00	; 0
     690:	90 93 82 07 	sts	0x0782, r25
     694:	80 93 81 07 	sts	0x0781, r24
					stove_run_change_steps = stove_run_change_steps_stage2;				
     698:	80 e5       	ldi	r24, 0x50	; 80
     69a:	90 e0       	ldi	r25, 0x00	; 0
     69c:	90 93 80 07 	sts	0x0780, r25
     6a0:	80 93 7f 07 	sts	0x077F, r24
     6a4:	1c c0       	rjmp	.+56     	; 0x6de <stove_control_fuzzy+0x96>
				}
				else
				{
					if ((ADC_VALUE1 & (~stove_run_change_stage4_mask)) == (stove_target_temp & (~stove_run_change_stage4_mask)))
     6a6:	80 7c       	andi	r24, 0xC0	; 192
     6a8:	00 97       	sbiw	r24, 0x00	; 0
     6aa:	69 f4       	brne	.+26     	; 0x6c6 <stove_control_fuzzy+0x7e>
					{
						stove_run_change_count_len = stove_run_change_count_len_stage3;
     6ac:	86 e0       	ldi	r24, 0x06	; 6
     6ae:	90 e0       	ldi	r25, 0x00	; 0
     6b0:	90 93 82 07 	sts	0x0782, r25
     6b4:	80 93 81 07 	sts	0x0781, r24
						stove_run_change_steps = stove_run_change_steps_stage3;
     6b8:	80 e8       	ldi	r24, 0x80	; 128
     6ba:	90 e0       	ldi	r25, 0x00	; 0
     6bc:	90 93 80 07 	sts	0x0780, r25
     6c0:	80 93 7f 07 	sts	0x077F, r24
     6c4:	0c c0       	rjmp	.+24     	; 0x6de <stove_control_fuzzy+0x96>
					}
					else
					{
						stove_run_change_count_len = stove_run_change_count_len_stage4;
     6c6:	83 e0       	ldi	r24, 0x03	; 3
     6c8:	90 e0       	ldi	r25, 0x00	; 0
     6ca:	90 93 82 07 	sts	0x0782, r25
     6ce:	80 93 81 07 	sts	0x0781, r24
						stove_run_change_steps = stove_run_change_steps_stage4;
     6d2:	80 ec       	ldi	r24, 0xC0	; 192
     6d4:	90 e0       	ldi	r25, 0x00	; 0
     6d6:	90 93 80 07 	sts	0x0780, r25
     6da:	80 93 7f 07 	sts	0x077F, r24
			}
		}
		
		// delay for speed
		
		if ( stove_run_change_count <= stove_run_change_count_len )
     6de:	80 91 77 07 	lds	r24, 0x0777
     6e2:	90 91 78 07 	lds	r25, 0x0778
     6e6:	20 91 81 07 	lds	r18, 0x0781
     6ea:	30 91 82 07 	lds	r19, 0x0782
     6ee:	28 17       	cp	r18, r24
     6f0:	39 07       	cpc	r19, r25
     6f2:	30 f0       	brcs	.+12     	; 0x700 <stove_control_fuzzy+0xb8>
		{
			stove_run_change_count++;
     6f4:	01 96       	adiw	r24, 0x01	; 1
     6f6:	90 93 78 07 	sts	0x0778, r25
     6fa:	80 93 77 07 	sts	0x0777, r24
     6fe:	08 95       	ret
		{
			/*
			once delay is done figure out if the stove temp is moving in the right direction if it is do nothing
			else change damper position
			*/
			stove_run_change_count = 0;
     700:	10 92 78 07 	sts	0x0778, r1
     704:	10 92 77 07 	sts	0x0777, r1
			if (ADC_VALUE1 < stove_target_temp)
     708:	80 91 04 07 	lds	r24, 0x0704
     70c:	90 91 87 07 	lds	r25, 0x0787
     710:	89 17       	cp	r24, r25
     712:	68 f4       	brcc	.+26     	; 0x72e <stove_control_fuzzy+0xe6>
			{
				if (ADC_VALUE1 <= stove_target_temp_ref) 
     714:	90 91 7b 07 	lds	r25, 0x077B
     718:	98 17       	cp	r25, r24
     71a:	30 f0       	brcs	.+12     	; 0x728 <stove_control_fuzzy+0xe0>
				{
					stove_target_temp_ref=ADC_VALUE1;
     71c:	80 93 7b 07 	sts	0x077B, r24
					stove_control_change_damper_pos(open_damper);
     720:	81 e0       	ldi	r24, 0x01	; 1
     722:	0e 94 c9 02 	call	0x592	; 0x592 <stove_control_change_damper_pos>
     726:	08 95       	ret
				}
				else
				{
					stove_target_temp_ref=ADC_VALUE1;
     728:	80 93 7b 07 	sts	0x077B, r24
     72c:	08 95       	ret
				}
			}
			else
			{
				if (ADC_VALUE1 >= stove_target_temp_ref) 
     72e:	90 91 7b 07 	lds	r25, 0x077B
     732:	89 17       	cp	r24, r25
     734:	30 f0       	brcs	.+12     	; 0x742 <stove_control_fuzzy+0xfa>
				{
					stove_target_temp_ref=ADC_VALUE1;
     736:	80 93 7b 07 	sts	0x077B, r24
					stove_control_change_damper_pos(close_damper);
     73a:	80 e0       	ldi	r24, 0x00	; 0
     73c:	0e 94 c9 02 	call	0x592	; 0x592 <stove_control_change_damper_pos>
     740:	08 95       	ret
				}
				else
				{
					stove_target_temp_ref=ADC_VALUE1;
     742:	80 93 7b 07 	sts	0x077B, r24
     746:	08 95       	ret

00000748 <stove_control_checks>:
*		set nite mode if required
*/

void stove_control_checks(void)
{
	if (stove_target_temp!=stove_shutdown_temp)
     748:	80 91 87 07 	lds	r24, 0x0787
     74c:	88 23       	and	r24, r24
     74e:	09 f4       	brne	.+2      	; 0x752 <stove_control_checks+0xa>
     750:	a2 c0       	rjmp	.+324    	; 0x896 <__stack+0x37>
	{
		if (stove_mode_start_first==0)
     752:	80 91 7a 07 	lds	r24, 0x077A
     756:	88 23       	and	r24, r24
     758:	b1 f4       	brne	.+44     	; 0x786 <stove_control_checks+0x3e>
		{
			stove_mode_start_first=1;
     75a:	81 e0       	ldi	r24, 0x01	; 1
     75c:	80 93 7a 07 	sts	0x077A, r24
			
			if (ADC_VALUE2 < stove_back_temp) 
     760:	80 91 05 07 	lds	r24, 0x0705
     764:	80 3c       	cpi	r24, 0xC0	; 192
     766:	78 f4       	brcc	.+30     	; 0x786 <stove_control_checks+0x3e>
			{
				stove_run_lower_limit = bottem_open_pos;
     768:	80 e0       	ldi	r24, 0x00	; 0
     76a:	9a e0       	ldi	r25, 0x0A	; 10
     76c:	90 93 76 07 	sts	0x0776, r25
     770:	80 93 75 07 	sts	0x0775, r24
				stove_target_temp = stove_start_temp;
     774:	20 ed       	ldi	r18, 0xD0	; 208
     776:	20 93 87 07 	sts	0x0787, r18
				stove_target_temp_lockout= stove_start_temp;
     77a:	20 93 79 07 	sts	0x0779, r18
				STEPPER_POS=bottem_open_pos;
     77e:	90 93 70 07 	sts	0x0770, r25
     782:	80 93 6f 07 	sts	0x076F, r24
			}		
		}
		if (stove_target_temp > stove_target_temp_lockout)
     786:	80 91 79 07 	lds	r24, 0x0779
     78a:	90 91 87 07 	lds	r25, 0x0787
     78e:	89 17       	cp	r24, r25
     790:	10 f4       	brcc	.+4      	; 0x796 <stove_control_checks+0x4e>
		{
			stove_target_temp=stove_target_temp_lockout;
     792:	80 93 87 07 	sts	0x0787, r24
		}
		if (stove_target_temp == stove_start_temp)
     796:	80 91 87 07 	lds	r24, 0x0787
     79a:	80 3d       	cpi	r24, 0xD0	; 208
     79c:	99 f4       	brne	.+38     	; 0x7c4 <stove_control_checks+0x7c>
		{
			if (ADC_VALUE2 > stove_back_temp)
     79e:	80 91 05 07 	lds	r24, 0x0705
     7a2:	81 3c       	cpi	r24, 0xC1	; 193
     7a4:	48 f0       	brcs	.+18     	; 0x7b8 <stove_control_checks+0x70>
			{
				stove_run_lower_limit = damper_open_pos;
     7a6:	80 e0       	ldi	r24, 0x00	; 0
     7a8:	9c e1       	ldi	r25, 0x1C	; 28
     7aa:	90 93 76 07 	sts	0x0776, r25
     7ae:	80 93 75 07 	sts	0x0775, r24
				stove_target_temp = stove_run_hot_temp;
     7b2:	88 eb       	ldi	r24, 0xB8	; 184
     7b4:	80 93 87 07 	sts	0x0787, r24
			}
			stove_cooldown_test(stove_run_hot_temp,stove_mode_warmup_count);
     7b8:	88 eb       	ldi	r24, 0xB8	; 184
     7ba:	90 e0       	ldi	r25, 0x00	; 0
     7bc:	64 e8       	ldi	r22, 0x84	; 132
     7be:	73 e0       	ldi	r23, 0x03	; 3
     7c0:	0e 94 ef 01 	call	0x3de	; 0x3de <stove_cooldown_test>
		}
		if (stove_target_temp == stove_run_hot_temp)
     7c4:	80 91 87 07 	lds	r24, 0x0787
     7c8:	88 3b       	cpi	r24, 0xB8	; 184
     7ca:	71 f4       	brne	.+28     	; 0x7e8 <stove_control_checks+0xa0>
		{
			stove_cooldown_test(stove_run_med_temp,stove_mode_high_temp_lower_count);
     7cc:	8e e8       	ldi	r24, 0x8E	; 142
     7ce:	90 e0       	ldi	r25, 0x00	; 0
     7d0:	62 ec       	ldi	r22, 0xC2	; 194
     7d2:	71 e0       	ldi	r23, 0x01	; 1
     7d4:	0e 94 ef 01 	call	0x3de	; 0x3de <stove_cooldown_test>
			stove_target_temp_config(stove_run_hot_temp,stove_run_med_temp,stove_mode_high_temp_lower_count);		
     7d8:	88 eb       	ldi	r24, 0xB8	; 184
     7da:	90 e0       	ldi	r25, 0x00	; 0
     7dc:	6e e8       	ldi	r22, 0x8E	; 142
     7de:	70 e0       	ldi	r23, 0x00	; 0
     7e0:	42 ec       	ldi	r20, 0xC2	; 194
     7e2:	51 e0       	ldi	r21, 0x01	; 1
     7e4:	0e 94 20 02 	call	0x440	; 0x440 <stove_target_temp_config>
		}
		if (stove_target_temp == stove_run_med_temp)
     7e8:	80 91 87 07 	lds	r24, 0x0787
     7ec:	8e 38       	cpi	r24, 0x8E	; 142
     7ee:	71 f4       	brne	.+28     	; 0x80c <stove_control_checks+0xc4>
		{
			stove_cooldown_test(stove_run_cool_temp,stove_mode_med_temp_lower_count);		
     7f0:	84 e6       	ldi	r24, 0x64	; 100
     7f2:	90 e0       	ldi	r25, 0x00	; 0
     7f4:	62 ec       	ldi	r22, 0xC2	; 194
     7f6:	71 e0       	ldi	r23, 0x01	; 1
     7f8:	0e 94 ef 01 	call	0x3de	; 0x3de <stove_cooldown_test>
			stove_target_temp_config(stove_run_hot_temp,stove_run_cool_temp,stove_mode_med_temp_lower_count);
     7fc:	88 eb       	ldi	r24, 0xB8	; 184
     7fe:	90 e0       	ldi	r25, 0x00	; 0
     800:	64 e6       	ldi	r22, 0x64	; 100
     802:	70 e0       	ldi	r23, 0x00	; 0
     804:	42 ec       	ldi	r20, 0xC2	; 194
     806:	51 e0       	ldi	r21, 0x01	; 1
     808:	0e 94 20 02 	call	0x440	; 0x440 <stove_target_temp_config>
		}
		if (stove_target_temp == stove_run_cool_temp)
     80c:	80 91 87 07 	lds	r24, 0x0787
     810:	84 36       	cpi	r24, 0x64	; 100
     812:	c9 f4       	brne	.+50     	; 0x846 <stove_control_checks+0xfe>
		{
			stove_cooldown_test(stove_shutdown_temp,stove_mode_low_temp_lower_count);	
     814:	80 e0       	ldi	r24, 0x00	; 0
     816:	90 e0       	ldi	r25, 0x00	; 0
     818:	64 e8       	ldi	r22, 0x84	; 132
     81a:	73 e0       	ldi	r23, 0x03	; 3
     81c:	0e 94 ef 01 	call	0x3de	; 0x3de <stove_cooldown_test>
			stove_target_temp_config(stove_run_med_temp,stove_run_cool_temp,stove_mode_low_temp_lower_count);
     820:	8e e8       	ldi	r24, 0x8E	; 142
     822:	90 e0       	ldi	r25, 0x00	; 0
     824:	64 e6       	ldi	r22, 0x64	; 100
     826:	70 e0       	ldi	r23, 0x00	; 0
     828:	44 e8       	ldi	r20, 0x84	; 132
     82a:	53 e0       	ldi	r21, 0x03	; 3
     82c:	0e 94 20 02 	call	0x440	; 0x440 <stove_target_temp_config>
			if(stove_cooldown_count >= (stove_mode_low_temp_lower_count/2))
     830:	80 91 73 07 	lds	r24, 0x0773
     834:	90 91 74 07 	lds	r25, 0x0774
     838:	21 e0       	ldi	r18, 0x01	; 1
     83a:	82 3c       	cpi	r24, 0xC2	; 194
     83c:	92 07       	cpc	r25, r18
     83e:	18 f0       	brcs	.+6      	; 0x846 <stove_control_checks+0xfe>
			{
				stove_target_temp_lockout=stove_run_cool_temp;
     840:	84 e6       	ldi	r24, 0x64	; 100
     842:	80 93 79 07 	sts	0x0779, r24
			}
		}
		if (stove_target_temp == stove_shutdown_temp)
     846:	80 91 87 07 	lds	r24, 0x0787
     84a:	88 23       	and	r24, r24
     84c:	59 f4       	brne	.+22     	; 0x864 <__stack+0x5>
		{
			stove_run_upper_limit=damper_shutdown_pos;
     84e:	80 e8       	ldi	r24, 0x80	; 128
     850:	9d e3       	ldi	r25, 0x3D	; 61
     852:	90 93 7d 07 	sts	0x077D, r25
     856:	80 93 7c 07 	sts	0x077C, r24
			STEPPER_POS=damper_shutdown_pos;
     85a:	90 93 70 07 	sts	0x0770, r25
     85e:	80 93 6f 07 	sts	0x076F, r24
     862:	06 c0       	rjmp	.+12     	; 0x870 <__stack+0x11>
		}
		if (stove_target_temp > stove_target_temp_lockout)
     864:	90 91 79 07 	lds	r25, 0x0779
     868:	98 17       	cp	r25, r24
     86a:	10 f4       	brcc	.+4      	; 0x870 <__stack+0x11>
		{
			stove_target_temp=stove_target_temp_lockout;
     86c:	90 93 87 07 	sts	0x0787, r25
		}
		if (stove_mode_start_first == 2)
     870:	80 91 7a 07 	lds	r24, 0x077A
     874:	82 30       	cpi	r24, 0x02	; 2
     876:	79 f4       	brne	.+30     	; 0x896 <__stack+0x37>
		{
			vTaskDelay(1000);
     878:	88 ee       	ldi	r24, 0xE8	; 232
     87a:	93 e0       	ldi	r25, 0x03	; 3
     87c:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskDelay>
			if (ADC_VALUE2 > stove_back_temp)
     880:	80 91 05 07 	lds	r24, 0x0705
     884:	81 3c       	cpi	r24, 0xC1	; 193
     886:	18 f0       	brcs	.+6      	; 0x88e <__stack+0x2f>
			{
				stove_mode_start_first=0;
     888:	10 92 7a 07 	sts	0x077A, r1
     88c:	08 95       	ret
			}
			else
			{
				stove_target_temp=stove_shutdown_temp;
     88e:	10 92 87 07 	sts	0x0787, r1
				stove_target_temp_lockout=stove_shutdown_temp;
     892:	10 92 79 07 	sts	0x0779, r1
     896:	08 95       	ret

00000898 <stove_control_mode_check>:
	
}

void stove_control_mode_check(void)
{
	switch (stove_target_temp)
     898:	80 91 87 07 	lds	r24, 0x0787
     89c:	8e 38       	cpi	r24, 0x8E	; 142
     89e:	c9 f0       	breq	.+50     	; 0x8d2 <stove_control_mode_check+0x3a>
     8a0:	8f 38       	cpi	r24, 0x8F	; 143
     8a2:	28 f4       	brcc	.+10     	; 0x8ae <stove_control_mode_check+0x16>
     8a4:	88 23       	and	r24, r24
     8a6:	19 f1       	breq	.+70     	; 0x8ee <stove_control_mode_check+0x56>
     8a8:	84 36       	cpi	r24, 0x64	; 100
     8aa:	39 f5       	brne	.+78     	; 0x8fa <stove_control_mode_check+0x62>
     8ac:	19 c0       	rjmp	.+50     	; 0x8e0 <stove_control_mode_check+0x48>
     8ae:	88 3b       	cpi	r24, 0xB8	; 184
     8b0:	49 f0       	breq	.+18     	; 0x8c4 <stove_control_mode_check+0x2c>
     8b2:	80 3d       	cpi	r24, 0xD0	; 208
     8b4:	11 f5       	brne	.+68     	; 0x8fa <stove_control_mode_check+0x62>
	{
		case stove_start_temp:
			stove_mode &= 0x0f;
     8b6:	80 91 7e 07 	lds	r24, 0x077E
     8ba:	8f 70       	andi	r24, 0x0F	; 15
			stove_mode |= (MODE_SRT<<4);
     8bc:	80 61       	ori	r24, 0x10	; 16
     8be:	80 93 7e 07 	sts	0x077E, r24
		break;
     8c2:	1b c0       	rjmp	.+54     	; 0x8fa <stove_control_mode_check+0x62>
		case stove_run_hot_temp :
			stove_mode &= 0x0f;
     8c4:	80 91 7e 07 	lds	r24, 0x077E
     8c8:	8f 70       	andi	r24, 0x0F	; 15
			stove_mode |= (MODE_HOT<<4);
     8ca:	80 62       	ori	r24, 0x20	; 32
     8cc:	80 93 7e 07 	sts	0x077E, r24
		break;
     8d0:	14 c0       	rjmp	.+40     	; 0x8fa <stove_control_mode_check+0x62>
		case stove_run_med_temp :
			stove_mode &= 0x0f;
     8d2:	80 91 7e 07 	lds	r24, 0x077E
     8d6:	8f 70       	andi	r24, 0x0F	; 15
			stove_mode |= (MODE_MED<<4);	
     8d8:	80 63       	ori	r24, 0x30	; 48
     8da:	80 93 7e 07 	sts	0x077E, r24
		break;
     8de:	0d c0       	rjmp	.+26     	; 0x8fa <stove_control_mode_check+0x62>
		case stove_run_cool_temp :
			stove_mode &= 0x0f;
     8e0:	80 91 7e 07 	lds	r24, 0x077E
     8e4:	8f 70       	andi	r24, 0x0F	; 15
			stove_mode |= (MODE_LOW<<4);
     8e6:	80 64       	ori	r24, 0x40	; 64
     8e8:	80 93 7e 07 	sts	0x077E, r24
		break;
     8ec:	06 c0       	rjmp	.+12     	; 0x8fa <stove_control_mode_check+0x62>
		case stove_shutdown_temp :
			stove_mode &= 0x0f;
     8ee:	80 91 7e 07 	lds	r24, 0x077E
			stove_mode |= (MODE_OFF<<4);
     8f2:	83 70       	andi	r24, 0x03	; 3
			stove_mode &= ~((1<<MODE_LED_bit) | (1<<MODE_BEEP_bit));
     8f4:	80 65       	ori	r24, 0x50	; 80
     8f6:	80 93 7e 07 	sts	0x077E, r24
		break;
	}
	if ((stove_mode & 0x03) != MODE_NITE)
     8fa:	80 91 7e 07 	lds	r24, 0x077E
     8fe:	98 2f       	mov	r25, r24
     900:	93 70       	andi	r25, 0x03	; 3
     902:	91 30       	cpi	r25, 0x01	; 1
     904:	b1 f0       	breq	.+44     	; 0x932 <stove_control_mode_check+0x9a>
	{
		if (stove_target_temp_lockout == stove_start_temp)
     906:	90 91 79 07 	lds	r25, 0x0779
     90a:	90 3d       	cpi	r25, 0xD0	; 208
     90c:	21 f4       	brne	.+8      	; 0x916 <stove_control_mode_check+0x7e>
		{
			stove_mode &= 0xFC;
			stove_mode |= MODE_NORM;
			stove_mode &= ~(1<<MODE_LED_bit);
			stove_mode &= ~(1<<MODE_BEEP_bit);
     90e:	80 7f       	andi	r24, 0xF0	; 240
     910:	80 93 7e 07 	sts	0x077E, r24
     914:	04 c0       	rjmp	.+8      	; 0x91e <stove_control_mode_check+0x86>
		}
		else
		{
			stove_mode &= 0xFC;
     916:	8c 7f       	andi	r24, 0xFC	; 252
			stove_mode |= MODE_FEED;
			stove_mode |= (1<<MODE_LED_bit);
			stove_mode |= (1<<MODE_BEEP_bit);
     918:	8e 60       	ori	r24, 0x0E	; 14
     91a:	80 93 7e 07 	sts	0x077E, r24
						
		}
		if (stove_target_temp_lockout == stove_shutdown_temp)
     91e:	80 91 79 07 	lds	r24, 0x0779
     922:	88 23       	and	r24, r24
     924:	49 f4       	brne	.+18     	; 0x938 <stove_control_mode_check+0xa0>
		{
			stove_mode &= ~(1<<MODE_LED_bit);
			stove_mode &= ~(1<<MODE_BEEP_bit);
     926:	80 91 7e 07 	lds	r24, 0x077E
     92a:	83 7f       	andi	r24, 0xF3	; 243
     92c:	80 93 7e 07 	sts	0x077E, r24
     930:	08 95       	ret
		}
	}
	else
	{
		stove_mode &= ~(1<<MODE_LED_bit);
		stove_mode &= ~(1<<MODE_BEEP_bit);
     932:	83 7f       	andi	r24, 0xF3	; 243
     934:	80 93 7e 07 	sts	0x077E, r24
     938:	08 95       	ret

0000093a <stove_control_led>:
	}
}

void stove_control_led(void)
{
	if ((stove_mode & (1<<MODE_LED_bit)) == (1<<MODE_LED_bit))
     93a:	80 91 7e 07 	lds	r24, 0x077E
     93e:	82 ff       	sbrs	r24, 2
     940:	02 c0       	rjmp	.+4      	; 0x946 <stove_control_led+0xc>
	{
		stove_control_led_PORT |= _BV(stove_control_led_PI);
     942:	da 9a       	sbi	0x1b, 2	; 27
     944:	08 95       	ret
	}
	else
	{
		stove_control_led_PORT &= ~(_BV(stove_control_led_PI));
     946:	da 98       	cbi	0x1b, 2	; 27
     948:	08 95       	ret

0000094a <stove_control>:

void stove_control(void)
{
	for ( ;; )
	{
		vTaskDelay(1000);
     94a:	88 ee       	ldi	r24, 0xE8	; 232
     94c:	93 e0       	ldi	r25, 0x03	; 3
     94e:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskDelay>
		stove_control_fuzzy(); // call fuzzy control for temp adjust
     952:	0e 94 24 03 	call	0x648	; 0x648 <stove_control_fuzzy>
		stove_control_checks();
     956:	0e 94 a4 03 	call	0x748	; 0x748 <stove_control_checks>
		stove_control_mode_check();
     95a:	0e 94 4c 04 	call	0x898	; 0x898 <stove_control_mode_check>
		stove_control_led();
     95e:	0e 94 9d 04 	call	0x93a	; 0x93a <stove_control_led>
     962:	f3 cf       	rjmp	.-26     	; 0x94a <stove_control>

00000964 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     964:	af 92       	push	r10
     966:	bf 92       	push	r11
     968:	cf 92       	push	r12
     96a:	df 92       	push	r13
     96c:	ef 92       	push	r14
     96e:	ff 92       	push	r15
     970:	0f 93       	push	r16
     972:	1f 93       	push	r17
     974:	cf 93       	push	r28
     976:	df 93       	push	r29
     978:	6c 01       	movw	r12, r24
     97a:	e6 2e       	mov	r14, r22
     97c:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     97e:	8a e1       	ldi	r24, 0x1A	; 26
     980:	90 e0       	ldi	r25, 0x00	; 0
     982:	0e 94 14 09 	call	0x1228	; 0x1228 <pvPortMalloc>
     986:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
     988:	00 97       	sbiw	r24, 0x00	; 0
     98a:	09 f4       	brne	.+2      	; 0x98e <xCoRoutineCreate+0x2a>
     98c:	62 c0       	rjmp	.+196    	; 0xa52 <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     98e:	80 91 91 00 	lds	r24, 0x0091
     992:	90 91 92 00 	lds	r25, 0x0092
     996:	00 97       	sbiw	r24, 0x00	; 0
     998:	39 f5       	brne	.+78     	; 0x9e8 <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     99a:	10 93 92 00 	sts	0x0092, r17
     99e:	00 93 91 00 	sts	0x0091, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     9a2:	c4 e9       	ldi	r28, 0x94	; 148
     9a4:	d0 e0       	ldi	r29, 0x00	; 0
     9a6:	ce 01       	movw	r24, r28
     9a8:	0e 94 d7 06 	call	0xdae	; 0xdae <vListInitialise>
     9ac:	ce 01       	movw	r24, r28
     9ae:	09 96       	adiw	r24, 0x09	; 9
     9b0:	0e 94 d7 06 	call	0xdae	; 0xdae <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     9b4:	c6 ea       	ldi	r28, 0xA6	; 166
     9b6:	d0 e0       	ldi	r29, 0x00	; 0
     9b8:	ce 01       	movw	r24, r28
     9ba:	0e 94 d7 06 	call	0xdae	; 0xdae <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     9be:	0f 2e       	mov	r0, r31
     9c0:	ff ea       	ldi	r31, 0xAF	; 175
     9c2:	af 2e       	mov	r10, r31
     9c4:	f0 e0       	ldi	r31, 0x00	; 0
     9c6:	bf 2e       	mov	r11, r31
     9c8:	f0 2d       	mov	r31, r0
     9ca:	c5 01       	movw	r24, r10
     9cc:	0e 94 d7 06 	call	0xdae	; 0xdae <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     9d0:	88 eb       	ldi	r24, 0xB8	; 184
     9d2:	90 e0       	ldi	r25, 0x00	; 0
     9d4:	0e 94 d7 06 	call	0xdae	; 0xdae <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     9d8:	d0 93 c2 00 	sts	0x00C2, r29
     9dc:	c0 93 c1 00 	sts	0x00C1, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     9e0:	b0 92 c4 00 	sts	0x00C4, r11
     9e4:	a0 92 c3 00 	sts	0x00C3, r10
     9e8:	ce 2d       	mov	r28, r14
     9ea:	e1 10       	cpse	r14, r1
     9ec:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     9ee:	f8 01       	movw	r30, r16
     9f0:	11 8e       	std	Z+25, r1	; 0x19
     9f2:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     9f4:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     9f6:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     9f8:	c1 92       	st	Z+, r12
     9fa:	d1 92       	st	Z+, r13
     9fc:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     9fe:	cf 01       	movw	r24, r30
     a00:	0e 94 e5 06 	call	0xdca	; 0xdca <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     a04:	c8 01       	movw	r24, r16
     a06:	0c 96       	adiw	r24, 0x0c	; 12
     a08:	0e 94 e5 06 	call	0xdca	; 0xdca <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     a0c:	f8 01       	movw	r30, r16
     a0e:	11 87       	std	Z+9, r17	; 0x09
     a10:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     a12:	13 8b       	std	Z+19, r17	; 0x13
     a14:	02 8b       	std	Z+18, r16	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     a16:	84 e0       	ldi	r24, 0x04	; 4
     a18:	90 e0       	ldi	r25, 0x00	; 0
     a1a:	8c 1b       	sub	r24, r28
     a1c:	91 09       	sbc	r25, r1
     a1e:	95 87       	std	Z+13, r25	; 0x0d
     a20:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     a22:	86 89       	ldd	r24, Z+22	; 0x16
     a24:	90 91 93 00 	lds	r25, 0x0093
     a28:	98 17       	cp	r25, r24
     a2a:	10 f4       	brcc	.+4      	; 0xa30 <xCoRoutineCreate+0xcc>
     a2c:	80 93 93 00 	sts	0x0093, r24
     a30:	90 e0       	ldi	r25, 0x00	; 0
     a32:	9c 01       	movw	r18, r24
     a34:	22 0f       	add	r18, r18
     a36:	33 1f       	adc	r19, r19
     a38:	22 0f       	add	r18, r18
     a3a:	33 1f       	adc	r19, r19
     a3c:	22 0f       	add	r18, r18
     a3e:	33 1f       	adc	r19, r19
     a40:	82 0f       	add	r24, r18
     a42:	93 1f       	adc	r25, r19
     a44:	8c 56       	subi	r24, 0x6C	; 108
     a46:	9f 4f       	sbci	r25, 0xFF	; 255
     a48:	b7 01       	movw	r22, r14
     a4a:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <vListInsertEnd>

		xReturn = pdPASS;
     a4e:	81 e0       	ldi	r24, 0x01	; 1
     a50:	01 c0       	rjmp	.+2      	; 0xa54 <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     a52:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
     a54:	df 91       	pop	r29
     a56:	cf 91       	pop	r28
     a58:	1f 91       	pop	r17
     a5a:	0f 91       	pop	r16
     a5c:	ff 90       	pop	r15
     a5e:	ef 90       	pop	r14
     a60:	df 90       	pop	r13
     a62:	cf 90       	pop	r12
     a64:	bf 90       	pop	r11
     a66:	af 90       	pop	r10
     a68:	08 95       	ret

00000a6a <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     a6a:	0f 93       	push	r16
     a6c:	1f 93       	push	r17
     a6e:	cf 93       	push	r28
     a70:	df 93       	push	r29
     a72:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     a74:	c0 91 c5 00 	lds	r28, 0x00C5
     a78:	d0 91 c6 00 	lds	r29, 0x00C6
     a7c:	c8 0f       	add	r28, r24
     a7e:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     a80:	80 91 91 00 	lds	r24, 0x0091
     a84:	90 91 92 00 	lds	r25, 0x0092
     a88:	02 96       	adiw	r24, 0x02	; 2
     a8a:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     a8e:	e0 91 91 00 	lds	r30, 0x0091
     a92:	f0 91 92 00 	lds	r31, 0x0092
     a96:	d3 83       	std	Z+3, r29	; 0x03
     a98:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     a9a:	80 91 c5 00 	lds	r24, 0x00C5
     a9e:	90 91 c6 00 	lds	r25, 0x00C6
     aa2:	c8 17       	cp	r28, r24
     aa4:	d9 07       	cpc	r29, r25
     aa6:	50 f4       	brcc	.+20     	; 0xabc <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     aa8:	bf 01       	movw	r22, r30
     aaa:	6e 5f       	subi	r22, 0xFE	; 254
     aac:	7f 4f       	sbci	r23, 0xFF	; 255
     aae:	80 91 c3 00 	lds	r24, 0x00C3
     ab2:	90 91 c4 00 	lds	r25, 0x00C4
     ab6:	0e 94 12 07 	call	0xe24	; 0xe24 <vListInsert>
     aba:	09 c0       	rjmp	.+18     	; 0xace <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     abc:	bf 01       	movw	r22, r30
     abe:	6e 5f       	subi	r22, 0xFE	; 254
     ac0:	7f 4f       	sbci	r23, 0xFF	; 255
     ac2:	80 91 c1 00 	lds	r24, 0x00C1
     ac6:	90 91 c2 00 	lds	r25, 0x00C2
     aca:	0e 94 12 07 	call	0xe24	; 0xe24 <vListInsert>
	}

	if( pxEventList )
     ace:	01 15       	cp	r16, r1
     ad0:	11 05       	cpc	r17, r1
     ad2:	49 f0       	breq	.+18     	; 0xae6 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     ad4:	60 91 91 00 	lds	r22, 0x0091
     ad8:	70 91 92 00 	lds	r23, 0x0092
     adc:	64 5f       	subi	r22, 0xF4	; 244
     ade:	7f 4f       	sbci	r23, 0xFF	; 255
     ae0:	c8 01       	movw	r24, r16
     ae2:	0e 94 12 07 	call	0xe24	; 0xe24 <vListInsert>
	}
}
     ae6:	df 91       	pop	r29
     ae8:	cf 91       	pop	r28
     aea:	1f 91       	pop	r17
     aec:	0f 91       	pop	r16
     aee:	08 95       	ret

00000af0 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     af0:	cf 92       	push	r12
     af2:	df 92       	push	r13
     af4:	ef 92       	push	r14
     af6:	ff 92       	push	r15
     af8:	0f 93       	push	r16
     afa:	1f 93       	push	r17
     afc:	cf 93       	push	r28
     afe:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     b00:	80 91 b8 00 	lds	r24, 0x00B8
     b04:	88 23       	and	r24, r24
     b06:	b9 f1       	breq	.+110    	; 0xb76 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     b08:	0f 2e       	mov	r0, r31
     b0a:	fd eb       	ldi	r31, 0xBD	; 189
     b0c:	ef 2e       	mov	r14, r31
     b0e:	f0 e0       	ldi	r31, 0x00	; 0
     b10:	ff 2e       	mov	r15, r31
     b12:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     b14:	0f 2e       	mov	r0, r31
     b16:	f8 eb       	ldi	r31, 0xB8	; 184
     b18:	cf 2e       	mov	r12, r31
     b1a:	f0 e0       	ldi	r31, 0x00	; 0
     b1c:	df 2e       	mov	r13, r31
     b1e:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     b20:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     b22:	d7 01       	movw	r26, r14
     b24:	ed 91       	ld	r30, X+
     b26:	fc 91       	ld	r31, X
     b28:	c6 81       	ldd	r28, Z+6	; 0x06
     b2a:	d7 81       	ldd	r29, Z+7	; 0x07
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     b2c:	ce 01       	movw	r24, r28
     b2e:	0c 96       	adiw	r24, 0x0c	; 12
     b30:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     b34:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     b36:	8e 01       	movw	r16, r28
     b38:	0e 5f       	subi	r16, 0xFE	; 254
     b3a:	1f 4f       	sbci	r17, 0xFF	; 255
     b3c:	c8 01       	movw	r24, r16
     b3e:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     b42:	8e 89       	ldd	r24, Y+22	; 0x16
     b44:	90 91 93 00 	lds	r25, 0x0093
     b48:	98 17       	cp	r25, r24
     b4a:	10 f4       	brcc	.+4      	; 0xb50 <vCoRoutineSchedule+0x60>
     b4c:	80 93 93 00 	sts	0x0093, r24
     b50:	90 e0       	ldi	r25, 0x00	; 0
     b52:	9c 01       	movw	r18, r24
     b54:	22 0f       	add	r18, r18
     b56:	33 1f       	adc	r19, r19
     b58:	22 0f       	add	r18, r18
     b5a:	33 1f       	adc	r19, r19
     b5c:	22 0f       	add	r18, r18
     b5e:	33 1f       	adc	r19, r19
     b60:	82 0f       	add	r24, r18
     b62:	93 1f       	adc	r25, r19
     b64:	8c 56       	subi	r24, 0x6C	; 108
     b66:	9f 4f       	sbci	r25, 0xFF	; 255
     b68:	b8 01       	movw	r22, r16
     b6a:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     b6e:	f6 01       	movw	r30, r12
     b70:	80 81       	ld	r24, Z
     b72:	88 23       	and	r24, r24
     b74:	a9 f6       	brne	.-86     	; 0xb20 <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     b76:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <xTaskGetTickCount>
     b7a:	20 91 c7 00 	lds	r18, 0x00C7
     b7e:	30 91 c8 00 	lds	r19, 0x00C8
     b82:	82 1b       	sub	r24, r18
     b84:	93 0b       	sbc	r25, r19
     b86:	90 93 ca 00 	sts	0x00CA, r25
     b8a:	80 93 c9 00 	sts	0x00C9, r24
     b8e:	74 c0       	rjmp	.+232    	; 0xc78 <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     b90:	20 91 c5 00 	lds	r18, 0x00C5
     b94:	30 91 c6 00 	lds	r19, 0x00C6
     b98:	2f 5f       	subi	r18, 0xFF	; 255
     b9a:	3f 4f       	sbci	r19, 0xFF	; 255
     b9c:	30 93 c6 00 	sts	0x00C6, r19
     ba0:	20 93 c5 00 	sts	0x00C5, r18
		xPassedTicks--;
     ba4:	01 97       	sbiw	r24, 0x01	; 1
     ba6:	90 93 ca 00 	sts	0x00CA, r25
     baa:	80 93 c9 00 	sts	0x00C9, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     bae:	21 15       	cp	r18, r1
     bb0:	31 05       	cpc	r19, r1
     bb2:	81 f4       	brne	.+32     	; 0xbd4 <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     bb4:	80 91 c1 00 	lds	r24, 0x00C1
     bb8:	90 91 c2 00 	lds	r25, 0x00C2
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     bbc:	20 91 c3 00 	lds	r18, 0x00C3
     bc0:	30 91 c4 00 	lds	r19, 0x00C4
     bc4:	30 93 c2 00 	sts	0x00C2, r19
     bc8:	20 93 c1 00 	sts	0x00C1, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     bcc:	90 93 c4 00 	sts	0x00C4, r25
     bd0:	80 93 c3 00 	sts	0x00C3, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     bd4:	e0 91 c1 00 	lds	r30, 0x00C1
     bd8:	f0 91 c2 00 	lds	r31, 0x00C2
     bdc:	80 81       	ld	r24, Z
     bde:	88 23       	and	r24, r24
     be0:	09 f4       	brne	.+2      	; 0xbe4 <vCoRoutineSchedule+0xf4>
     be2:	4a c0       	rjmp	.+148    	; 0xc78 <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     be4:	05 80       	ldd	r0, Z+5	; 0x05
     be6:	f6 81       	ldd	r31, Z+6	; 0x06
     be8:	e0 2d       	mov	r30, r0
     bea:	c6 81       	ldd	r28, Z+6	; 0x06
     bec:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     bee:	2a 81       	ldd	r18, Y+2	; 0x02
     bf0:	3b 81       	ldd	r19, Y+3	; 0x03
     bf2:	80 91 c5 00 	lds	r24, 0x00C5
     bf6:	90 91 c6 00 	lds	r25, 0x00C6
     bfa:	82 17       	cp	r24, r18
     bfc:	93 07       	cpc	r25, r19
     bfe:	78 f4       	brcc	.+30     	; 0xc1e <vCoRoutineSchedule+0x12e>
     c00:	3b c0       	rjmp	.+118    	; 0xc78 <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     c02:	05 80       	ldd	r0, Z+5	; 0x05
     c04:	f6 81       	ldd	r31, Z+6	; 0x06
     c06:	e0 2d       	mov	r30, r0
     c08:	c6 81       	ldd	r28, Z+6	; 0x06
     c0a:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     c0c:	2a 81       	ldd	r18, Y+2	; 0x02
     c0e:	3b 81       	ldd	r19, Y+3	; 0x03
     c10:	80 91 c5 00 	lds	r24, 0x00C5
     c14:	90 91 c6 00 	lds	r25, 0x00C6
     c18:	82 17       	cp	r24, r18
     c1a:	93 07       	cpc	r25, r19
     c1c:	68 f1       	brcs	.+90     	; 0xc78 <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     c1e:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
     c20:	8e 01       	movw	r16, r28
     c22:	0e 5f       	subi	r16, 0xFE	; 254
     c24:	1f 4f       	sbci	r17, 0xFF	; 255
     c26:	c8 01       	movw	r24, r16
     c28:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     c2c:	8c 89       	ldd	r24, Y+20	; 0x14
     c2e:	9d 89       	ldd	r25, Y+21	; 0x15
     c30:	00 97       	sbiw	r24, 0x00	; 0
     c32:	21 f0       	breq	.+8      	; 0xc3c <vCoRoutineSchedule+0x14c>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
     c34:	ce 01       	movw	r24, r28
     c36:	0c 96       	adiw	r24, 0x0c	; 12
     c38:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     c3c:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     c3e:	8e 89       	ldd	r24, Y+22	; 0x16
     c40:	90 91 93 00 	lds	r25, 0x0093
     c44:	98 17       	cp	r25, r24
     c46:	10 f4       	brcc	.+4      	; 0xc4c <vCoRoutineSchedule+0x15c>
     c48:	80 93 93 00 	sts	0x0093, r24
     c4c:	90 e0       	ldi	r25, 0x00	; 0
     c4e:	9c 01       	movw	r18, r24
     c50:	22 0f       	add	r18, r18
     c52:	33 1f       	adc	r19, r19
     c54:	22 0f       	add	r18, r18
     c56:	33 1f       	adc	r19, r19
     c58:	22 0f       	add	r18, r18
     c5a:	33 1f       	adc	r19, r19
     c5c:	82 0f       	add	r24, r18
     c5e:	93 1f       	adc	r25, r19
     c60:	8c 56       	subi	r24, 0x6C	; 108
     c62:	9f 4f       	sbci	r25, 0xFF	; 255
     c64:	b8 01       	movw	r22, r16
     c66:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     c6a:	e0 91 c1 00 	lds	r30, 0x00C1
     c6e:	f0 91 c2 00 	lds	r31, 0x00C2
     c72:	80 81       	ld	r24, Z
     c74:	88 23       	and	r24, r24
     c76:	29 f6       	brne	.-118    	; 0xc02 <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     c78:	80 91 c9 00 	lds	r24, 0x00C9
     c7c:	90 91 ca 00 	lds	r25, 0x00CA
     c80:	00 97       	sbiw	r24, 0x00	; 0
     c82:	09 f0       	breq	.+2      	; 0xc86 <vCoRoutineSchedule+0x196>
     c84:	85 cf       	rjmp	.-246    	; 0xb90 <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     c86:	80 91 c5 00 	lds	r24, 0x00C5
     c8a:	90 91 c6 00 	lds	r25, 0x00C6
     c8e:	90 93 c8 00 	sts	0x00C8, r25
     c92:	80 93 c7 00 	sts	0x00C7, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     c96:	20 91 93 00 	lds	r18, 0x0093
     c9a:	82 2f       	mov	r24, r18
     c9c:	90 e0       	ldi	r25, 0x00	; 0
     c9e:	fc 01       	movw	r30, r24
     ca0:	ee 0f       	add	r30, r30
     ca2:	ff 1f       	adc	r31, r31
     ca4:	ee 0f       	add	r30, r30
     ca6:	ff 1f       	adc	r31, r31
     ca8:	ee 0f       	add	r30, r30
     caa:	ff 1f       	adc	r31, r31
     cac:	e8 0f       	add	r30, r24
     cae:	f9 1f       	adc	r31, r25
     cb0:	ec 56       	subi	r30, 0x6C	; 108
     cb2:	ff 4f       	sbci	r31, 0xFF	; 255
     cb4:	30 81       	ld	r19, Z
     cb6:	33 23       	and	r19, r19
     cb8:	d9 f4       	brne	.+54     	; 0xcf0 <vCoRoutineSchedule+0x200>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     cba:	22 23       	and	r18, r18
     cbc:	31 f4       	brne	.+12     	; 0xcca <vCoRoutineSchedule+0x1da>
     cbe:	47 c0       	rjmp	.+142    	; 0xd4e <vCoRoutineSchedule+0x25e>
     cc0:	22 23       	and	r18, r18
     cc2:	19 f4       	brne	.+6      	; 0xcca <vCoRoutineSchedule+0x1da>
     cc4:	20 93 93 00 	sts	0x0093, r18
     cc8:	42 c0       	rjmp	.+132    	; 0xd4e <vCoRoutineSchedule+0x25e>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     cca:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     ccc:	82 2f       	mov	r24, r18
     cce:	90 e0       	ldi	r25, 0x00	; 0
     cd0:	fc 01       	movw	r30, r24
     cd2:	ee 0f       	add	r30, r30
     cd4:	ff 1f       	adc	r31, r31
     cd6:	ee 0f       	add	r30, r30
     cd8:	ff 1f       	adc	r31, r31
     cda:	ee 0f       	add	r30, r30
     cdc:	ff 1f       	adc	r31, r31
     cde:	e8 0f       	add	r30, r24
     ce0:	f9 1f       	adc	r31, r25
     ce2:	ec 56       	subi	r30, 0x6C	; 108
     ce4:	ff 4f       	sbci	r31, 0xFF	; 255
     ce6:	30 81       	ld	r19, Z
     ce8:	33 23       	and	r19, r19
     cea:	51 f3       	breq	.-44     	; 0xcc0 <vCoRoutineSchedule+0x1d0>
     cec:	20 93 93 00 	sts	0x0093, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     cf0:	fc 01       	movw	r30, r24
     cf2:	ee 0f       	add	r30, r30
     cf4:	ff 1f       	adc	r31, r31
     cf6:	ee 0f       	add	r30, r30
     cf8:	ff 1f       	adc	r31, r31
     cfa:	ee 0f       	add	r30, r30
     cfc:	ff 1f       	adc	r31, r31
     cfe:	8e 0f       	add	r24, r30
     d00:	9f 1f       	adc	r25, r31
     d02:	fc 01       	movw	r30, r24
     d04:	ec 56       	subi	r30, 0x6C	; 108
     d06:	ff 4f       	sbci	r31, 0xFF	; 255
     d08:	a1 81       	ldd	r26, Z+1	; 0x01
     d0a:	b2 81       	ldd	r27, Z+2	; 0x02
     d0c:	12 96       	adiw	r26, 0x02	; 2
     d0e:	0d 90       	ld	r0, X+
     d10:	bc 91       	ld	r27, X
     d12:	a0 2d       	mov	r26, r0
     d14:	b2 83       	std	Z+2, r27	; 0x02
     d16:	a1 83       	std	Z+1, r26	; 0x01
     d18:	cf 01       	movw	r24, r30
     d1a:	03 96       	adiw	r24, 0x03	; 3
     d1c:	a8 17       	cp	r26, r24
     d1e:	b9 07       	cpc	r27, r25
     d20:	31 f4       	brne	.+12     	; 0xd2e <vCoRoutineSchedule+0x23e>
     d22:	12 96       	adiw	r26, 0x02	; 2
     d24:	8d 91       	ld	r24, X+
     d26:	9c 91       	ld	r25, X
     d28:	13 97       	sbiw	r26, 0x03	; 3
     d2a:	92 83       	std	Z+2, r25	; 0x02
     d2c:	81 83       	std	Z+1, r24	; 0x01
     d2e:	01 80       	ldd	r0, Z+1	; 0x01
     d30:	f2 81       	ldd	r31, Z+2	; 0x02
     d32:	e0 2d       	mov	r30, r0
     d34:	a6 81       	ldd	r26, Z+6	; 0x06
     d36:	b7 81       	ldd	r27, Z+7	; 0x07
     d38:	b0 93 92 00 	sts	0x0092, r27
     d3c:	a0 93 91 00 	sts	0x0091, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     d40:	ed 91       	ld	r30, X+
     d42:	fc 91       	ld	r31, X
     d44:	11 97       	sbiw	r26, 0x01	; 1
     d46:	cd 01       	movw	r24, r26
     d48:	57 96       	adiw	r26, 0x17	; 23
     d4a:	6c 91       	ld	r22, X
     d4c:	09 95       	icall

	return;
}
     d4e:	df 91       	pop	r29
     d50:	cf 91       	pop	r28
     d52:	1f 91       	pop	r17
     d54:	0f 91       	pop	r16
     d56:	ff 90       	pop	r15
     d58:	ef 90       	pop	r14
     d5a:	df 90       	pop	r13
     d5c:	cf 90       	pop	r12
     d5e:	08 95       	ret

00000d60 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     d60:	0f 93       	push	r16
     d62:	1f 93       	push	r17
     d64:	cf 93       	push	r28
     d66:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     d68:	dc 01       	movw	r26, r24
     d6a:	15 96       	adiw	r26, 0x05	; 5
     d6c:	ed 91       	ld	r30, X+
     d6e:	fc 91       	ld	r31, X
     d70:	16 97       	sbiw	r26, 0x06	; 6
     d72:	06 81       	ldd	r16, Z+6	; 0x06
     d74:	17 81       	ldd	r17, Z+7	; 0x07
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     d76:	e8 01       	movw	r28, r16
     d78:	2c 96       	adiw	r28, 0x0c	; 12
     d7a:	ce 01       	movw	r24, r28
     d7c:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     d80:	88 eb       	ldi	r24, 0xB8	; 184
     d82:	90 e0       	ldi	r25, 0x00	; 0
     d84:	be 01       	movw	r22, r28
     d86:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     d8a:	e0 91 91 00 	lds	r30, 0x0091
     d8e:	f0 91 92 00 	lds	r31, 0x0092
	{
		xReturn = pdTRUE;
     d92:	81 e0       	ldi	r24, 0x01	; 1
     d94:	d8 01       	movw	r26, r16
     d96:	56 96       	adiw	r26, 0x16	; 22
     d98:	2c 91       	ld	r18, X
     d9a:	56 97       	sbiw	r26, 0x16	; 22
     d9c:	96 89       	ldd	r25, Z+22	; 0x16
     d9e:	29 17       	cp	r18, r25
     da0:	08 f4       	brcc	.+2      	; 0xda4 <xCoRoutineRemoveFromEventList+0x44>
     da2:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     da4:	df 91       	pop	r29
     da6:	cf 91       	pop	r28
     da8:	1f 91       	pop	r17
     daa:	0f 91       	pop	r16
     dac:	08 95       	ret

00000dae <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     dae:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     db0:	03 96       	adiw	r24, 0x03	; 3
     db2:	92 83       	std	Z+2, r25	; 0x02
     db4:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     db6:	2f ef       	ldi	r18, 0xFF	; 255
     db8:	3f ef       	ldi	r19, 0xFF	; 255
     dba:	34 83       	std	Z+4, r19	; 0x04
     dbc:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     dbe:	96 83       	std	Z+6, r25	; 0x06
     dc0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     dc2:	90 87       	std	Z+8, r25	; 0x08
     dc4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     dc6:	10 82       	st	Z, r1
}
     dc8:	08 95       	ret

00000dca <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     dca:	fc 01       	movw	r30, r24
     dcc:	11 86       	std	Z+9, r1	; 0x09
     dce:	10 86       	std	Z+8, r1	; 0x08
}
     dd0:	08 95       	ret

00000dd2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     dd2:	cf 93       	push	r28
     dd4:	df 93       	push	r29
     dd6:	ec 01       	movw	r28, r24
     dd8:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     dda:	89 81       	ldd	r24, Y+1	; 0x01
     ddc:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     dde:	dc 01       	movw	r26, r24
     de0:	12 96       	adiw	r26, 0x02	; 2
     de2:	2d 91       	ld	r18, X+
     de4:	3c 91       	ld	r19, X
     de6:	13 97       	sbiw	r26, 0x03	; 3
     de8:	33 83       	std	Z+3, r19	; 0x03
     dea:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     dec:	29 81       	ldd	r18, Y+1	; 0x01
     dee:	3a 81       	ldd	r19, Y+2	; 0x02
     df0:	35 83       	std	Z+5, r19	; 0x05
     df2:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     df4:	12 96       	adiw	r26, 0x02	; 2
     df6:	2d 91       	ld	r18, X+
     df8:	3c 91       	ld	r19, X
     dfa:	13 97       	sbiw	r26, 0x03	; 3
     dfc:	d9 01       	movw	r26, r18
     dfe:	15 96       	adiw	r26, 0x05	; 5
     e00:	7c 93       	st	X, r23
     e02:	6e 93       	st	-X, r22
     e04:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     e06:	dc 01       	movw	r26, r24
     e08:	13 96       	adiw	r26, 0x03	; 3
     e0a:	7c 93       	st	X, r23
     e0c:	6e 93       	st	-X, r22
     e0e:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     e10:	7a 83       	std	Y+2, r23	; 0x02
     e12:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     e14:	d1 87       	std	Z+9, r29	; 0x09
     e16:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
     e18:	88 81       	ld	r24, Y
     e1a:	8f 5f       	subi	r24, 0xFF	; 255
     e1c:	88 83       	st	Y, r24
}
     e1e:	df 91       	pop	r29
     e20:	cf 91       	pop	r28
     e22:	08 95       	ret

00000e24 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     e24:	cf 93       	push	r28
     e26:	df 93       	push	r29
     e28:	ac 01       	movw	r20, r24
     e2a:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     e2c:	28 81       	ld	r18, Y
     e2e:	39 81       	ldd	r19, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     e30:	8f ef       	ldi	r24, 0xFF	; 255
     e32:	2f 3f       	cpi	r18, 0xFF	; 255
     e34:	38 07       	cpc	r19, r24
     e36:	21 f4       	brne	.+8      	; 0xe40 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     e38:	fa 01       	movw	r30, r20
     e3a:	a7 81       	ldd	r26, Z+7	; 0x07
     e3c:	b0 85       	ldd	r27, Z+8	; 0x08
     e3e:	18 c0       	rjmp	.+48     	; 0xe70 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     e40:	da 01       	movw	r26, r20
     e42:	13 96       	adiw	r26, 0x03	; 3
     e44:	fa 01       	movw	r30, r20
     e46:	85 81       	ldd	r24, Z+5	; 0x05
     e48:	96 81       	ldd	r25, Z+6	; 0x06
     e4a:	fc 01       	movw	r30, r24
     e4c:	80 81       	ld	r24, Z
     e4e:	91 81       	ldd	r25, Z+1	; 0x01
     e50:	28 17       	cp	r18, r24
     e52:	39 07       	cpc	r19, r25
     e54:	68 f0       	brcs	.+26     	; 0xe70 <vListInsert+0x4c>
     e56:	12 96       	adiw	r26, 0x02	; 2
     e58:	0d 90       	ld	r0, X+
     e5a:	bc 91       	ld	r27, X
     e5c:	a0 2d       	mov	r26, r0
     e5e:	12 96       	adiw	r26, 0x02	; 2
     e60:	ed 91       	ld	r30, X+
     e62:	fc 91       	ld	r31, X
     e64:	13 97       	sbiw	r26, 0x03	; 3
     e66:	80 81       	ld	r24, Z
     e68:	91 81       	ldd	r25, Z+1	; 0x01
     e6a:	28 17       	cp	r18, r24
     e6c:	39 07       	cpc	r19, r25
     e6e:	98 f7       	brcc	.-26     	; 0xe56 <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     e70:	12 96       	adiw	r26, 0x02	; 2
     e72:	ed 91       	ld	r30, X+
     e74:	fc 91       	ld	r31, X
     e76:	13 97       	sbiw	r26, 0x03	; 3
     e78:	fb 83       	std	Y+3, r31	; 0x03
     e7a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     e7c:	d5 83       	std	Z+5, r29	; 0x05
     e7e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     e80:	bd 83       	std	Y+5, r27	; 0x05
     e82:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     e84:	13 96       	adiw	r26, 0x03	; 3
     e86:	dc 93       	st	X, r29
     e88:	ce 93       	st	-X, r28
     e8a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     e8c:	59 87       	std	Y+9, r21	; 0x09
     e8e:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     e90:	fa 01       	movw	r30, r20
     e92:	80 81       	ld	r24, Z
     e94:	8f 5f       	subi	r24, 0xFF	; 255
     e96:	80 83       	st	Z, r24
}
     e98:	df 91       	pop	r29
     e9a:	cf 91       	pop	r28
     e9c:	08 95       	ret

00000e9e <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
     e9e:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     ea0:	a2 81       	ldd	r26, Z+2	; 0x02
     ea2:	b3 81       	ldd	r27, Z+3	; 0x03
     ea4:	84 81       	ldd	r24, Z+4	; 0x04
     ea6:	95 81       	ldd	r25, Z+5	; 0x05
     ea8:	15 96       	adiw	r26, 0x05	; 5
     eaa:	9c 93       	st	X, r25
     eac:	8e 93       	st	-X, r24
     eae:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     eb0:	a4 81       	ldd	r26, Z+4	; 0x04
     eb2:	b5 81       	ldd	r27, Z+5	; 0x05
     eb4:	82 81       	ldd	r24, Z+2	; 0x02
     eb6:	93 81       	ldd	r25, Z+3	; 0x03
     eb8:	13 96       	adiw	r26, 0x03	; 3
     eba:	9c 93       	st	X, r25
     ebc:	8e 93       	st	-X, r24
     ebe:	12 97       	sbiw	r26, 0x02	; 2

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     ec0:	a0 85       	ldd	r26, Z+8	; 0x08
     ec2:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     ec4:	11 96       	adiw	r26, 0x01	; 1
     ec6:	8d 91       	ld	r24, X+
     ec8:	9c 91       	ld	r25, X
     eca:	12 97       	sbiw	r26, 0x02	; 2
     ecc:	8e 17       	cp	r24, r30
     ece:	9f 07       	cpc	r25, r31
     ed0:	31 f4       	brne	.+12     	; 0xede <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     ed2:	84 81       	ldd	r24, Z+4	; 0x04
     ed4:	95 81       	ldd	r25, Z+5	; 0x05
     ed6:	12 96       	adiw	r26, 0x02	; 2
     ed8:	9c 93       	st	X, r25
     eda:	8e 93       	st	-X, r24
     edc:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     ede:	11 86       	std	Z+9, r1	; 0x09
     ee0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     ee2:	8c 91       	ld	r24, X
     ee4:	81 50       	subi	r24, 0x01	; 1
     ee6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     ee8:	8c 91       	ld	r24, X
}
     eea:	08 95       	ret

00000eec <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     eec:	21 e1       	ldi	r18, 0x11	; 17
     eee:	fc 01       	movw	r30, r24
     ef0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     ef2:	31 97       	sbiw	r30, 0x01	; 1
     ef4:	32 e2       	ldi	r19, 0x22	; 34
     ef6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     ef8:	fc 01       	movw	r30, r24
     efa:	32 97       	sbiw	r30, 0x02	; 2
     efc:	a3 e3       	ldi	r26, 0x33	; 51
     efe:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     f00:	fc 01       	movw	r30, r24
     f02:	33 97       	sbiw	r30, 0x03	; 3
     f04:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     f06:	fc 01       	movw	r30, r24
     f08:	34 97       	sbiw	r30, 0x04	; 4
     f0a:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     f0c:	fc 01       	movw	r30, r24
     f0e:	35 97       	sbiw	r30, 0x05	; 5
     f10:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     f12:	fc 01       	movw	r30, r24
     f14:	36 97       	sbiw	r30, 0x06	; 6
     f16:	60 e8       	ldi	r22, 0x80	; 128
     f18:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     f1a:	fc 01       	movw	r30, r24
     f1c:	37 97       	sbiw	r30, 0x07	; 7
     f1e:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     f20:	fc 01       	movw	r30, r24
     f22:	38 97       	sbiw	r30, 0x08	; 8
     f24:	62 e0       	ldi	r22, 0x02	; 2
     f26:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     f28:	fc 01       	movw	r30, r24
     f2a:	39 97       	sbiw	r30, 0x09	; 9
     f2c:	63 e0       	ldi	r22, 0x03	; 3
     f2e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     f30:	fc 01       	movw	r30, r24
     f32:	3a 97       	sbiw	r30, 0x0a	; 10
     f34:	64 e0       	ldi	r22, 0x04	; 4
     f36:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     f38:	fc 01       	movw	r30, r24
     f3a:	3b 97       	sbiw	r30, 0x0b	; 11
     f3c:	65 e0       	ldi	r22, 0x05	; 5
     f3e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     f40:	fc 01       	movw	r30, r24
     f42:	3c 97       	sbiw	r30, 0x0c	; 12
     f44:	66 e0       	ldi	r22, 0x06	; 6
     f46:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     f48:	fc 01       	movw	r30, r24
     f4a:	3d 97       	sbiw	r30, 0x0d	; 13
     f4c:	67 e0       	ldi	r22, 0x07	; 7
     f4e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     f50:	fc 01       	movw	r30, r24
     f52:	3e 97       	sbiw	r30, 0x0e	; 14
     f54:	68 e0       	ldi	r22, 0x08	; 8
     f56:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     f58:	fc 01       	movw	r30, r24
     f5a:	3f 97       	sbiw	r30, 0x0f	; 15
     f5c:	69 e0       	ldi	r22, 0x09	; 9
     f5e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     f60:	fc 01       	movw	r30, r24
     f62:	70 97       	sbiw	r30, 0x10	; 16
     f64:	60 e1       	ldi	r22, 0x10	; 16
     f66:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     f68:	fc 01       	movw	r30, r24
     f6a:	71 97       	sbiw	r30, 0x11	; 17
     f6c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     f6e:	fc 01       	movw	r30, r24
     f70:	72 97       	sbiw	r30, 0x12	; 18
     f72:	22 e1       	ldi	r18, 0x12	; 18
     f74:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     f76:	fc 01       	movw	r30, r24
     f78:	73 97       	sbiw	r30, 0x13	; 19
     f7a:	23 e1       	ldi	r18, 0x13	; 19
     f7c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     f7e:	fc 01       	movw	r30, r24
     f80:	74 97       	sbiw	r30, 0x14	; 20
     f82:	24 e1       	ldi	r18, 0x14	; 20
     f84:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     f86:	fc 01       	movw	r30, r24
     f88:	75 97       	sbiw	r30, 0x15	; 21
     f8a:	25 e1       	ldi	r18, 0x15	; 21
     f8c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     f8e:	fc 01       	movw	r30, r24
     f90:	76 97       	sbiw	r30, 0x16	; 22
     f92:	26 e1       	ldi	r18, 0x16	; 22
     f94:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     f96:	fc 01       	movw	r30, r24
     f98:	77 97       	sbiw	r30, 0x17	; 23
     f9a:	27 e1       	ldi	r18, 0x17	; 23
     f9c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     f9e:	fc 01       	movw	r30, r24
     fa0:	78 97       	sbiw	r30, 0x18	; 24
     fa2:	28 e1       	ldi	r18, 0x18	; 24
     fa4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     fa6:	fc 01       	movw	r30, r24
     fa8:	79 97       	sbiw	r30, 0x19	; 25
     faa:	29 e1       	ldi	r18, 0x19	; 25
     fac:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     fae:	fc 01       	movw	r30, r24
     fb0:	7a 97       	sbiw	r30, 0x1a	; 26
     fb2:	20 e2       	ldi	r18, 0x20	; 32
     fb4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     fb6:	fc 01       	movw	r30, r24
     fb8:	7b 97       	sbiw	r30, 0x1b	; 27
     fba:	21 e2       	ldi	r18, 0x21	; 33
     fbc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     fbe:	fc 01       	movw	r30, r24
     fc0:	7c 97       	sbiw	r30, 0x1c	; 28
     fc2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     fc4:	fc 01       	movw	r30, r24
     fc6:	7d 97       	sbiw	r30, 0x1d	; 29
     fc8:	23 e2       	ldi	r18, 0x23	; 35
     fca:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     fcc:	fc 01       	movw	r30, r24
     fce:	7e 97       	sbiw	r30, 0x1e	; 30
     fd0:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     fd2:	fc 01       	movw	r30, r24
     fd4:	7f 97       	sbiw	r30, 0x1f	; 31
     fd6:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     fd8:	fc 01       	movw	r30, r24
     fda:	b0 97       	sbiw	r30, 0x20	; 32
     fdc:	26 e2       	ldi	r18, 0x26	; 38
     fde:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     fe0:	fc 01       	movw	r30, r24
     fe2:	b1 97       	sbiw	r30, 0x21	; 33
     fe4:	27 e2       	ldi	r18, 0x27	; 39
     fe6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     fe8:	fc 01       	movw	r30, r24
     fea:	b2 97       	sbiw	r30, 0x22	; 34
     fec:	28 e2       	ldi	r18, 0x28	; 40
     fee:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     ff0:	fc 01       	movw	r30, r24
     ff2:	b3 97       	sbiw	r30, 0x23	; 35
     ff4:	29 e2       	ldi	r18, 0x29	; 41
     ff6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     ff8:	fc 01       	movw	r30, r24
     ffa:	b4 97       	sbiw	r30, 0x24	; 36
     ffc:	20 e3       	ldi	r18, 0x30	; 48
     ffe:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1000:	fc 01       	movw	r30, r24
    1002:	b5 97       	sbiw	r30, 0x25	; 37
    1004:	21 e3       	ldi	r18, 0x31	; 49
    1006:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1008:	86 97       	sbiw	r24, 0x26	; 38
}
    100a:	08 95       	ret

0000100c <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    100c:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    100e:	8c e7       	ldi	r24, 0x7C	; 124
    1010:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    1012:	8b e0       	ldi	r24, 0x0B	; 11
    1014:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1016:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1018:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    101a:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    101c:	a0 91 a9 06 	lds	r26, 0x06A9
    1020:	b0 91 aa 06 	lds	r27, 0x06AA
    1024:	cd 91       	ld	r28, X+
    1026:	cd bf       	out	0x3d, r28	; 61
    1028:	dd 91       	ld	r29, X+
    102a:	de bf       	out	0x3e, r29	; 62
    102c:	ff 91       	pop	r31
    102e:	ef 91       	pop	r30
    1030:	df 91       	pop	r29
    1032:	cf 91       	pop	r28
    1034:	bf 91       	pop	r27
    1036:	af 91       	pop	r26
    1038:	9f 91       	pop	r25
    103a:	8f 91       	pop	r24
    103c:	7f 91       	pop	r23
    103e:	6f 91       	pop	r22
    1040:	5f 91       	pop	r21
    1042:	4f 91       	pop	r20
    1044:	3f 91       	pop	r19
    1046:	2f 91       	pop	r18
    1048:	1f 91       	pop	r17
    104a:	0f 91       	pop	r16
    104c:	ff 90       	pop	r15
    104e:	ef 90       	pop	r14
    1050:	df 90       	pop	r13
    1052:	cf 90       	pop	r12
    1054:	bf 90       	pop	r11
    1056:	af 90       	pop	r10
    1058:	9f 90       	pop	r9
    105a:	8f 90       	pop	r8
    105c:	7f 90       	pop	r7
    105e:	6f 90       	pop	r6
    1060:	5f 90       	pop	r5
    1062:	4f 90       	pop	r4
    1064:	3f 90       	pop	r3
    1066:	2f 90       	pop	r2
    1068:	1f 90       	pop	r1
    106a:	0f 90       	pop	r0
    106c:	0f be       	out	0x3f, r0	; 63
    106e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1070:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1072:	81 e0       	ldi	r24, 0x01	; 1
    1074:	08 95       	ret

00001076 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1076:	08 95       	ret

00001078 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1078:	0f 92       	push	r0
    107a:	0f b6       	in	r0, 0x3f	; 63
    107c:	f8 94       	cli
    107e:	0f 92       	push	r0
    1080:	1f 92       	push	r1
    1082:	11 24       	eor	r1, r1
    1084:	2f 92       	push	r2
    1086:	3f 92       	push	r3
    1088:	4f 92       	push	r4
    108a:	5f 92       	push	r5
    108c:	6f 92       	push	r6
    108e:	7f 92       	push	r7
    1090:	8f 92       	push	r8
    1092:	9f 92       	push	r9
    1094:	af 92       	push	r10
    1096:	bf 92       	push	r11
    1098:	cf 92       	push	r12
    109a:	df 92       	push	r13
    109c:	ef 92       	push	r14
    109e:	ff 92       	push	r15
    10a0:	0f 93       	push	r16
    10a2:	1f 93       	push	r17
    10a4:	2f 93       	push	r18
    10a6:	3f 93       	push	r19
    10a8:	4f 93       	push	r20
    10aa:	5f 93       	push	r21
    10ac:	6f 93       	push	r22
    10ae:	7f 93       	push	r23
    10b0:	8f 93       	push	r24
    10b2:	9f 93       	push	r25
    10b4:	af 93       	push	r26
    10b6:	bf 93       	push	r27
    10b8:	cf 93       	push	r28
    10ba:	df 93       	push	r29
    10bc:	ef 93       	push	r30
    10be:	ff 93       	push	r31
    10c0:	a0 91 a9 06 	lds	r26, 0x06A9
    10c4:	b0 91 aa 06 	lds	r27, 0x06AA
    10c8:	0d b6       	in	r0, 0x3d	; 61
    10ca:	0d 92       	st	X+, r0
    10cc:	0e b6       	in	r0, 0x3e	; 62
    10ce:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    10d0:	0e 94 32 11 	call	0x2264	; 0x2264 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    10d4:	a0 91 a9 06 	lds	r26, 0x06A9
    10d8:	b0 91 aa 06 	lds	r27, 0x06AA
    10dc:	cd 91       	ld	r28, X+
    10de:	cd bf       	out	0x3d, r28	; 61
    10e0:	dd 91       	ld	r29, X+
    10e2:	de bf       	out	0x3e, r29	; 62
    10e4:	ff 91       	pop	r31
    10e6:	ef 91       	pop	r30
    10e8:	df 91       	pop	r29
    10ea:	cf 91       	pop	r28
    10ec:	bf 91       	pop	r27
    10ee:	af 91       	pop	r26
    10f0:	9f 91       	pop	r25
    10f2:	8f 91       	pop	r24
    10f4:	7f 91       	pop	r23
    10f6:	6f 91       	pop	r22
    10f8:	5f 91       	pop	r21
    10fa:	4f 91       	pop	r20
    10fc:	3f 91       	pop	r19
    10fe:	2f 91       	pop	r18
    1100:	1f 91       	pop	r17
    1102:	0f 91       	pop	r16
    1104:	ff 90       	pop	r15
    1106:	ef 90       	pop	r14
    1108:	df 90       	pop	r13
    110a:	cf 90       	pop	r12
    110c:	bf 90       	pop	r11
    110e:	af 90       	pop	r10
    1110:	9f 90       	pop	r9
    1112:	8f 90       	pop	r8
    1114:	7f 90       	pop	r7
    1116:	6f 90       	pop	r6
    1118:	5f 90       	pop	r5
    111a:	4f 90       	pop	r4
    111c:	3f 90       	pop	r3
    111e:	2f 90       	pop	r2
    1120:	1f 90       	pop	r1
    1122:	0f 90       	pop	r0
    1124:	0f be       	out	0x3f, r0	; 63
    1126:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1128:	08 95       	ret

0000112a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    112a:	0f 92       	push	r0
    112c:	0f b6       	in	r0, 0x3f	; 63
    112e:	f8 94       	cli
    1130:	0f 92       	push	r0
    1132:	1f 92       	push	r1
    1134:	11 24       	eor	r1, r1
    1136:	2f 92       	push	r2
    1138:	3f 92       	push	r3
    113a:	4f 92       	push	r4
    113c:	5f 92       	push	r5
    113e:	6f 92       	push	r6
    1140:	7f 92       	push	r7
    1142:	8f 92       	push	r8
    1144:	9f 92       	push	r9
    1146:	af 92       	push	r10
    1148:	bf 92       	push	r11
    114a:	cf 92       	push	r12
    114c:	df 92       	push	r13
    114e:	ef 92       	push	r14
    1150:	ff 92       	push	r15
    1152:	0f 93       	push	r16
    1154:	1f 93       	push	r17
    1156:	2f 93       	push	r18
    1158:	3f 93       	push	r19
    115a:	4f 93       	push	r20
    115c:	5f 93       	push	r21
    115e:	6f 93       	push	r22
    1160:	7f 93       	push	r23
    1162:	8f 93       	push	r24
    1164:	9f 93       	push	r25
    1166:	af 93       	push	r26
    1168:	bf 93       	push	r27
    116a:	cf 93       	push	r28
    116c:	df 93       	push	r29
    116e:	ef 93       	push	r30
    1170:	ff 93       	push	r31
    1172:	a0 91 a9 06 	lds	r26, 0x06A9
    1176:	b0 91 aa 06 	lds	r27, 0x06AA
    117a:	0d b6       	in	r0, 0x3d	; 61
    117c:	0d 92       	st	X+, r0
    117e:	0e b6       	in	r0, 0x3e	; 62
    1180:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1182:	0e 94 2f 0f 	call	0x1e5e	; 0x1e5e <vTaskIncrementTick>
	vTaskSwitchContext();
    1186:	0e 94 32 11 	call	0x2264	; 0x2264 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    118a:	a0 91 a9 06 	lds	r26, 0x06A9
    118e:	b0 91 aa 06 	lds	r27, 0x06AA
    1192:	cd 91       	ld	r28, X+
    1194:	cd bf       	out	0x3d, r28	; 61
    1196:	dd 91       	ld	r29, X+
    1198:	de bf       	out	0x3e, r29	; 62
    119a:	ff 91       	pop	r31
    119c:	ef 91       	pop	r30
    119e:	df 91       	pop	r29
    11a0:	cf 91       	pop	r28
    11a2:	bf 91       	pop	r27
    11a4:	af 91       	pop	r26
    11a6:	9f 91       	pop	r25
    11a8:	8f 91       	pop	r24
    11aa:	7f 91       	pop	r23
    11ac:	6f 91       	pop	r22
    11ae:	5f 91       	pop	r21
    11b0:	4f 91       	pop	r20
    11b2:	3f 91       	pop	r19
    11b4:	2f 91       	pop	r18
    11b6:	1f 91       	pop	r17
    11b8:	0f 91       	pop	r16
    11ba:	ff 90       	pop	r15
    11bc:	ef 90       	pop	r14
    11be:	df 90       	pop	r13
    11c0:	cf 90       	pop	r12
    11c2:	bf 90       	pop	r11
    11c4:	af 90       	pop	r10
    11c6:	9f 90       	pop	r9
    11c8:	8f 90       	pop	r8
    11ca:	7f 90       	pop	r7
    11cc:	6f 90       	pop	r6
    11ce:	5f 90       	pop	r5
    11d0:	4f 90       	pop	r4
    11d2:	3f 90       	pop	r3
    11d4:	2f 90       	pop	r2
    11d6:	1f 90       	pop	r1
    11d8:	0f 90       	pop	r0
    11da:	0f be       	out	0x3f, r0	; 63
    11dc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    11de:	08 95       	ret

000011e0 <__vector_7>:
	 * count is incremented after the context is saved.
	 */ 
//	void TIMER0_COMPA_vect( void ) __attribute__ ( ( SIGNAL, naked ) );
//	void TIMER0_COMPA_vect( void )
	ISR (TIMER1_COMPA_vect)
	{
    11e0:	1f 92       	push	r1
    11e2:	0f 92       	push	r0
    11e4:	0f b6       	in	r0, 0x3f	; 63
    11e6:	0f 92       	push	r0
    11e8:	11 24       	eor	r1, r1
    11ea:	2f 93       	push	r18
    11ec:	3f 93       	push	r19
    11ee:	4f 93       	push	r20
    11f0:	5f 93       	push	r21
    11f2:	6f 93       	push	r22
    11f4:	7f 93       	push	r23
    11f6:	8f 93       	push	r24
    11f8:	9f 93       	push	r25
    11fa:	af 93       	push	r26
    11fc:	bf 93       	push	r27
    11fe:	ef 93       	push	r30
    1200:	ff 93       	push	r31
		vPortYieldFromTick();
    1202:	0e 94 95 08 	call	0x112a	; 0x112a <vPortYieldFromTick>
//		asm volatile ( "reti" );
	}
    1206:	ff 91       	pop	r31
    1208:	ef 91       	pop	r30
    120a:	bf 91       	pop	r27
    120c:	af 91       	pop	r26
    120e:	9f 91       	pop	r25
    1210:	8f 91       	pop	r24
    1212:	7f 91       	pop	r23
    1214:	6f 91       	pop	r22
    1216:	5f 91       	pop	r21
    1218:	4f 91       	pop	r20
    121a:	3f 91       	pop	r19
    121c:	2f 91       	pop	r18
    121e:	0f 90       	pop	r0
    1220:	0f be       	out	0x3f, r0	; 63
    1222:	0f 90       	pop	r0
    1224:	1f 90       	pop	r1
    1226:	18 95       	reti

00001228 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1228:	0f 93       	push	r16
    122a:	1f 93       	push	r17
    122c:	cf 93       	push	r28
    122e:	df 93       	push	r29
    1230:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1232:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1236:	00 91 cb 00 	lds	r16, 0x00CB
    123a:	10 91 cc 00 	lds	r17, 0x00CC
    123e:	c0 0f       	add	r28, r16
    1240:	d1 1f       	adc	r29, r17
    1242:	85 e0       	ldi	r24, 0x05	; 5
    1244:	cc 3d       	cpi	r28, 0xDC	; 220
    1246:	d8 07       	cpc	r29, r24
    1248:	50 f4       	brcc	.+20     	; 0x125e <pvPortMalloc+0x36>
    124a:	0c 17       	cp	r16, r28
    124c:	1d 07       	cpc	r17, r29
    124e:	50 f4       	brcc	.+20     	; 0x1264 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1250:	03 53       	subi	r16, 0x33	; 51
    1252:	1f 4f       	sbci	r17, 0xFF	; 255
			xNextFreeByte += xWantedSize;
    1254:	d0 93 cc 00 	sts	0x00CC, r29
    1258:	c0 93 cb 00 	sts	0x00CB, r28
    125c:	05 c0       	rjmp	.+10     	; 0x1268 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    125e:	00 e0       	ldi	r16, 0x00	; 0
    1260:	10 e0       	ldi	r17, 0x00	; 0
    1262:	02 c0       	rjmp	.+4      	; 0x1268 <pvPortMalloc+0x40>
    1264:	00 e0       	ldi	r16, 0x00	; 0
    1266:	10 e0       	ldi	r17, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;
		}
	}
	xTaskResumeAll();
    1268:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    126c:	80 2f       	mov	r24, r16
    126e:	91 2f       	mov	r25, r17
    1270:	df 91       	pop	r29
    1272:	cf 91       	pop	r28
    1274:	1f 91       	pop	r17
    1276:	0f 91       	pop	r16
    1278:	08 95       	ret

0000127a <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    127a:	08 95       	ret

0000127c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    127c:	10 92 cc 00 	sts	0x00CC, r1
    1280:	10 92 cb 00 	sts	0x00CB, r1
}
    1284:	08 95       	ret

00001286 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    1286:	20 91 cb 00 	lds	r18, 0x00CB
    128a:	30 91 cc 00 	lds	r19, 0x00CC
    128e:	8c ed       	ldi	r24, 0xDC	; 220
    1290:	95 e0       	ldi	r25, 0x05	; 5
    1292:	82 1b       	sub	r24, r18
    1294:	93 0b       	sbc	r25, r19
}
    1296:	08 95       	ret

00001298 <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    1298:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    129a:	0f b6       	in	r0, 0x3f	; 63
    129c:	f8 94       	cli
    129e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    12a0:	22 8d       	ldd	r18, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    12a2:	0f 90       	pop	r0
    12a4:	0f be       	out	0x3f, r0	; 63
static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    12a6:	81 e0       	ldi	r24, 0x01	; 1
    12a8:	93 8d       	ldd	r25, Z+27	; 0x1b
    12aa:	29 13       	cpse	r18, r25
    12ac:	80 e0       	ldi	r24, 0x00	; 0
	taskEXIT_CRITICAL();

	return xReturn;
}
    12ae:	08 95       	ret

000012b0 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    12b0:	cf 93       	push	r28
    12b2:	df 93       	push	r29
    12b4:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    12b6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    12b8:	22 23       	and	r18, r18
    12ba:	a9 f1       	breq	.+106    	; 0x1326 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    12bc:	44 23       	and	r20, r20
    12be:	b9 f4       	brne	.+46     	; 0x12ee <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    12c0:	8c 81       	ldd	r24, Y+4	; 0x04
    12c2:	9d 81       	ldd	r25, Y+5	; 0x05
    12c4:	42 2f       	mov	r20, r18
    12c6:	50 e0       	ldi	r21, 0x00	; 0
    12c8:	0e 94 49 13 	call	0x2692	; 0x2692 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    12cc:	2c 8d       	ldd	r18, Y+28	; 0x1c
    12ce:	8c 81       	ldd	r24, Y+4	; 0x04
    12d0:	9d 81       	ldd	r25, Y+5	; 0x05
    12d2:	82 0f       	add	r24, r18
    12d4:	91 1d       	adc	r25, r1
    12d6:	9d 83       	std	Y+5, r25	; 0x05
    12d8:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    12da:	2a 81       	ldd	r18, Y+2	; 0x02
    12dc:	3b 81       	ldd	r19, Y+3	; 0x03
    12de:	82 17       	cp	r24, r18
    12e0:	93 07       	cpc	r25, r19
    12e2:	08 f1       	brcs	.+66     	; 0x1326 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    12e4:	88 81       	ld	r24, Y
    12e6:	99 81       	ldd	r25, Y+1	; 0x01
    12e8:	9d 83       	std	Y+5, r25	; 0x05
    12ea:	8c 83       	std	Y+4, r24	; 0x04
    12ec:	1c c0       	rjmp	.+56     	; 0x1326 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    12ee:	8e 81       	ldd	r24, Y+6	; 0x06
    12f0:	9f 81       	ldd	r25, Y+7	; 0x07
    12f2:	42 2f       	mov	r20, r18
    12f4:	50 e0       	ldi	r21, 0x00	; 0
    12f6:	0e 94 49 13 	call	0x2692	; 0x2692 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    12fa:	4c 8d       	ldd	r20, Y+28	; 0x1c
    12fc:	50 e0       	ldi	r21, 0x00	; 0
    12fe:	50 95       	com	r21
    1300:	41 95       	neg	r20
    1302:	5f 4f       	sbci	r21, 0xFF	; 255
    1304:	8e 81       	ldd	r24, Y+6	; 0x06
    1306:	9f 81       	ldd	r25, Y+7	; 0x07
    1308:	84 0f       	add	r24, r20
    130a:	95 1f       	adc	r25, r21
    130c:	9f 83       	std	Y+7, r25	; 0x07
    130e:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1310:	28 81       	ld	r18, Y
    1312:	39 81       	ldd	r19, Y+1	; 0x01
    1314:	82 17       	cp	r24, r18
    1316:	93 07       	cpc	r25, r19
    1318:	30 f4       	brcc	.+12     	; 0x1326 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    131a:	8a 81       	ldd	r24, Y+2	; 0x02
    131c:	9b 81       	ldd	r25, Y+3	; 0x03
    131e:	48 0f       	add	r20, r24
    1320:	59 1f       	adc	r21, r25
    1322:	5f 83       	std	Y+7, r21	; 0x07
    1324:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1326:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1328:	8f 5f       	subi	r24, 0xFF	; 255
    132a:	8a 8f       	std	Y+26, r24	; 0x1a
}
    132c:	df 91       	pop	r29
    132e:	cf 91       	pop	r28
    1330:	08 95       	ret

00001332 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1332:	cf 93       	push	r28
    1334:	df 93       	push	r29
    1336:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1338:	cd 91       	ld	r28, X+
    133a:	dc 91       	ld	r29, X
    133c:	11 97       	sbiw	r26, 0x01	; 1
    133e:	20 97       	sbiw	r28, 0x00	; 0
    1340:	21 f1       	breq	.+72     	; 0x138a <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1342:	5c 96       	adiw	r26, 0x1c	; 28
    1344:	4c 91       	ld	r20, X
    1346:	5c 97       	sbiw	r26, 0x1c	; 28
    1348:	16 96       	adiw	r26, 0x06	; 6
    134a:	2d 91       	ld	r18, X+
    134c:	3c 91       	ld	r19, X
    134e:	17 97       	sbiw	r26, 0x07	; 7
    1350:	24 0f       	add	r18, r20
    1352:	31 1d       	adc	r19, r1
    1354:	17 96       	adiw	r26, 0x07	; 7
    1356:	3c 93       	st	X, r19
    1358:	2e 93       	st	-X, r18
    135a:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    135c:	12 96       	adiw	r26, 0x02	; 2
    135e:	ed 91       	ld	r30, X+
    1360:	fc 91       	ld	r31, X
    1362:	13 97       	sbiw	r26, 0x03	; 3
    1364:	2e 17       	cp	r18, r30
    1366:	3f 07       	cpc	r19, r31
    1368:	20 f0       	brcs	.+8      	; 0x1372 <prvCopyDataFromQueue+0x40>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    136a:	17 96       	adiw	r26, 0x07	; 7
    136c:	dc 93       	st	X, r29
    136e:	ce 93       	st	-X, r28
    1370:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1372:	16 96       	adiw	r26, 0x06	; 6
    1374:	3c 91       	ld	r19, X
    1376:	16 97       	sbiw	r26, 0x06	; 6
    1378:	17 96       	adiw	r26, 0x07	; 7
    137a:	2c 91       	ld	r18, X
    137c:	86 2f       	mov	r24, r22
    137e:	97 2f       	mov	r25, r23
    1380:	63 2f       	mov	r22, r19
    1382:	72 2f       	mov	r23, r18
    1384:	50 e0       	ldi	r21, 0x00	; 0
    1386:	0e 94 49 13 	call	0x2692	; 0x2692 <memcpy>
	}
}
    138a:	df 91       	pop	r29
    138c:	cf 91       	pop	r28
    138e:	08 95       	ret

00001390 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1390:	0f 93       	push	r16
    1392:	1f 93       	push	r17
    1394:	cf 93       	push	r28
    1396:	df 93       	push	r29
    1398:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    139a:	0f b6       	in	r0, 0x3f	; 63
    139c:	f8 94       	cli
    139e:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    13a0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13a2:	18 16       	cp	r1, r24
    13a4:	c4 f4       	brge	.+48     	; 0x13d6 <prvUnlockQueue+0x46>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13a6:	89 89       	ldd	r24, Y+17	; 0x11
    13a8:	88 23       	and	r24, r24
    13aa:	29 f4       	brne	.+10     	; 0x13b6 <prvUnlockQueue+0x26>
    13ac:	14 c0       	rjmp	.+40     	; 0x13d6 <prvUnlockQueue+0x46>
    13ae:	89 89       	ldd	r24, Y+17	; 0x11
    13b0:	88 23       	and	r24, r24
    13b2:	21 f4       	brne	.+8      	; 0x13bc <prvUnlockQueue+0x2c>
    13b4:	10 c0       	rjmp	.+32     	; 0x13d6 <prvUnlockQueue+0x46>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13b6:	8e 01       	movw	r16, r28
    13b8:	0f 5e       	subi	r16, 0xEF	; 239
    13ba:	1f 4f       	sbci	r17, 0xFF	; 255
    13bc:	c8 01       	movw	r24, r16
    13be:	0e 94 ac 11 	call	0x2358	; 0x2358 <xTaskRemoveFromEventList>
    13c2:	88 23       	and	r24, r24
    13c4:	11 f0       	breq	.+4      	; 0x13ca <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    13c6:	0e 94 35 12 	call	0x246a	; 0x246a <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    13ca:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13cc:	81 50       	subi	r24, 0x01	; 1
    13ce:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    13d0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13d2:	18 16       	cp	r1, r24
    13d4:	64 f3       	brlt	.-40     	; 0x13ae <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    13d6:	8f ef       	ldi	r24, 0xFF	; 255
    13d8:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    13da:	0f 90       	pop	r0
    13dc:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    13de:	0f b6       	in	r0, 0x3f	; 63
    13e0:	f8 94       	cli
    13e2:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    13e4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    13e6:	18 16       	cp	r1, r24
    13e8:	c4 f4       	brge	.+48     	; 0x141a <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13ea:	88 85       	ldd	r24, Y+8	; 0x08
    13ec:	88 23       	and	r24, r24
    13ee:	29 f4       	brne	.+10     	; 0x13fa <prvUnlockQueue+0x6a>
    13f0:	14 c0       	rjmp	.+40     	; 0x141a <prvUnlockQueue+0x8a>
    13f2:	88 85       	ldd	r24, Y+8	; 0x08
    13f4:	88 23       	and	r24, r24
    13f6:	21 f4       	brne	.+8      	; 0x1400 <prvUnlockQueue+0x70>
    13f8:	10 c0       	rjmp	.+32     	; 0x141a <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    13fa:	8e 01       	movw	r16, r28
    13fc:	08 5f       	subi	r16, 0xF8	; 248
    13fe:	1f 4f       	sbci	r17, 0xFF	; 255
    1400:	c8 01       	movw	r24, r16
    1402:	0e 94 ac 11 	call	0x2358	; 0x2358 <xTaskRemoveFromEventList>
    1406:	88 23       	and	r24, r24
    1408:	11 f0       	breq	.+4      	; 0x140e <prvUnlockQueue+0x7e>
				{
					vTaskMissedYield();
    140a:	0e 94 35 12 	call	0x246a	; 0x246a <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    140e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1410:	81 50       	subi	r24, 0x01	; 1
    1412:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1414:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1416:	18 16       	cp	r1, r24
    1418:	64 f3       	brlt	.-40     	; 0x13f2 <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    141a:	8f ef       	ldi	r24, 0xFF	; 255
    141c:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    141e:	0f 90       	pop	r0
    1420:	0f be       	out	0x3f, r0	; 63
}
    1422:	df 91       	pop	r29
    1424:	cf 91       	pop	r28
    1426:	1f 91       	pop	r17
    1428:	0f 91       	pop	r16
    142a:	08 95       	ret

0000142c <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    142c:	cf 93       	push	r28
    142e:	df 93       	push	r29
    1430:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1432:	0f b6       	in	r0, 0x3f	; 63
    1434:	f8 94       	cli
    1436:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1438:	48 81       	ld	r20, Y
    143a:	59 81       	ldd	r21, Y+1	; 0x01
    143c:	2b 8d       	ldd	r18, Y+27	; 0x1b
    143e:	30 e0       	ldi	r19, 0x00	; 0
    1440:	ec 8d       	ldd	r30, Y+28	; 0x1c
    1442:	f0 e0       	ldi	r31, 0x00	; 0
    1444:	2e 9f       	mul	r18, r30
    1446:	c0 01       	movw	r24, r0
    1448:	2f 9f       	mul	r18, r31
    144a:	90 0d       	add	r25, r0
    144c:	3e 9f       	mul	r19, r30
    144e:	90 0d       	add	r25, r0
    1450:	11 24       	eor	r1, r1
    1452:	84 0f       	add	r24, r20
    1454:	95 1f       	adc	r25, r21
    1456:	9b 83       	std	Y+3, r25	; 0x03
    1458:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    145a:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    145c:	5d 83       	std	Y+5, r21	; 0x05
    145e:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    1460:	c9 01       	movw	r24, r18
    1462:	01 97       	sbiw	r24, 0x01	; 1
    1464:	e8 9f       	mul	r30, r24
    1466:	90 01       	movw	r18, r0
    1468:	e9 9f       	mul	r30, r25
    146a:	30 0d       	add	r19, r0
    146c:	f8 9f       	mul	r31, r24
    146e:	30 0d       	add	r19, r0
    1470:	11 24       	eor	r1, r1
    1472:	24 0f       	add	r18, r20
    1474:	35 1f       	adc	r19, r21
    1476:	3f 83       	std	Y+7, r19	; 0x07
    1478:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    147a:	8f ef       	ldi	r24, 0xFF	; 255
    147c:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    147e:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1480:	66 23       	and	r22, r22
    1482:	61 f4       	brne	.+24     	; 0x149c <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1484:	88 85       	ldd	r24, Y+8	; 0x08
    1486:	88 23       	and	r24, r24
    1488:	89 f0       	breq	.+34     	; 0x14ac <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    148a:	ce 01       	movw	r24, r28
    148c:	08 96       	adiw	r24, 0x08	; 8
    148e:	0e 94 ac 11 	call	0x2358	; 0x2358 <xTaskRemoveFromEventList>
    1492:	81 30       	cpi	r24, 0x01	; 1
    1494:	59 f4       	brne	.+22     	; 0x14ac <xQueueGenericReset+0x80>
				{
					portYIELD_WITHIN_API();
    1496:	0e 94 3c 08 	call	0x1078	; 0x1078 <vPortYield>
    149a:	08 c0       	rjmp	.+16     	; 0x14ac <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    149c:	ce 01       	movw	r24, r28
    149e:	08 96       	adiw	r24, 0x08	; 8
    14a0:	0e 94 d7 06 	call	0xdae	; 0xdae <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    14a4:	ce 01       	movw	r24, r28
    14a6:	41 96       	adiw	r24, 0x11	; 17
    14a8:	0e 94 d7 06 	call	0xdae	; 0xdae <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    14ac:	0f 90       	pop	r0
    14ae:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    14b0:	81 e0       	ldi	r24, 0x01	; 1
    14b2:	df 91       	pop	r29
    14b4:	cf 91       	pop	r28
    14b6:	08 95       	ret

000014b8 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    14b8:	0f 93       	push	r16
    14ba:	1f 93       	push	r17
    14bc:	cf 93       	push	r28
    14be:	df 93       	push	r29
    14c0:	18 2f       	mov	r17, r24
    14c2:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    14c4:	88 23       	and	r24, r24
    14c6:	f9 f0       	breq	.+62     	; 0x1506 <xQueueGenericCreate+0x4e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    14c8:	8f e1       	ldi	r24, 0x1F	; 31
    14ca:	90 e0       	ldi	r25, 0x00	; 0
    14cc:	0e 94 14 09 	call	0x1228	; 0x1228 <pvPortMalloc>
    14d0:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    14d2:	00 97       	sbiw	r24, 0x00	; 0
    14d4:	d9 f0       	breq	.+54     	; 0x150c <xQueueGenericCreate+0x54>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    14d6:	01 9f       	mul	r16, r17
    14d8:	c0 01       	movw	r24, r0
    14da:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    14dc:	01 96       	adiw	r24, 0x01	; 1
    14de:	0e 94 14 09 	call	0x1228	; 0x1228 <pvPortMalloc>
    14e2:	99 83       	std	Y+1, r25	; 0x01
    14e4:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    14e6:	00 97       	sbiw	r24, 0x00	; 0
    14e8:	41 f0       	breq	.+16     	; 0x14fa <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    14ea:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    14ec:	0c 8f       	std	Y+28, r16	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    14ee:	ce 01       	movw	r24, r28
    14f0:	61 e0       	ldi	r22, 0x01	; 1
    14f2:	0e 94 16 0a 	call	0x142c	; 0x142c <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    14f6:	ce 01       	movw	r24, r28
    14f8:	0b c0       	rjmp	.+22     	; 0x1510 <xQueueGenericCreate+0x58>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    14fa:	ce 01       	movw	r24, r28
    14fc:	0e 94 3d 09 	call	0x127a	; 0x127a <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1500:	80 e0       	ldi	r24, 0x00	; 0
    1502:	90 e0       	ldi	r25, 0x00	; 0
    1504:	05 c0       	rjmp	.+10     	; 0x1510 <xQueueGenericCreate+0x58>
    1506:	80 e0       	ldi	r24, 0x00	; 0
    1508:	90 e0       	ldi	r25, 0x00	; 0
    150a:	02 c0       	rjmp	.+4      	; 0x1510 <xQueueGenericCreate+0x58>
    150c:	80 e0       	ldi	r24, 0x00	; 0
    150e:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    1510:	df 91       	pop	r29
    1512:	cf 91       	pop	r28
    1514:	1f 91       	pop	r17
    1516:	0f 91       	pop	r16
    1518:	08 95       	ret

0000151a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    151a:	8f 92       	push	r8
    151c:	9f 92       	push	r9
    151e:	bf 92       	push	r11
    1520:	cf 92       	push	r12
    1522:	df 92       	push	r13
    1524:	ef 92       	push	r14
    1526:	ff 92       	push	r15
    1528:	0f 93       	push	r16
    152a:	1f 93       	push	r17
    152c:	cf 93       	push	r28
    152e:	df 93       	push	r29
    1530:	00 d0       	rcall	.+0      	; 0x1532 <xQueueGenericSend+0x18>
    1532:	00 d0       	rcall	.+0      	; 0x1534 <xQueueGenericSend+0x1a>
    1534:	0f 92       	push	r0
    1536:	cd b7       	in	r28, 0x3d	; 61
    1538:	de b7       	in	r29, 0x3e	; 62
    153a:	8c 01       	movw	r16, r24
    153c:	4b 01       	movw	r8, r22
    153e:	5d 83       	std	Y+5, r21	; 0x05
    1540:	4c 83       	std	Y+4, r20	; 0x04
    1542:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1544:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1546:	ee 24       	eor	r14, r14
    1548:	e3 94       	inc	r14
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    154a:	cc 24       	eor	r12, r12
    154c:	dd 24       	eor	r13, r13
    154e:	68 94       	set
    1550:	c3 f8       	bld	r12, 3
    1552:	c8 0e       	add	r12, r24
    1554:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1556:	0f b6       	in	r0, 0x3f	; 63
    1558:	f8 94       	cli
    155a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    155c:	f8 01       	movw	r30, r16
    155e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1560:	83 8d       	ldd	r24, Z+27	; 0x1b
    1562:	98 17       	cp	r25, r24
    1564:	a8 f4       	brcc	.+42     	; 0x1590 <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1566:	c8 01       	movw	r24, r16
    1568:	b4 01       	movw	r22, r8
    156a:	4b 2d       	mov	r20, r11
    156c:	0e 94 58 09 	call	0x12b0	; 0x12b0 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1570:	f8 01       	movw	r30, r16
    1572:	81 89       	ldd	r24, Z+17	; 0x11
    1574:	88 23       	and	r24, r24
    1576:	41 f0       	breq	.+16     	; 0x1588 <xQueueGenericSend+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1578:	c8 01       	movw	r24, r16
    157a:	41 96       	adiw	r24, 0x11	; 17
    157c:	0e 94 ac 11 	call	0x2358	; 0x2358 <xTaskRemoveFromEventList>
    1580:	81 30       	cpi	r24, 0x01	; 1
    1582:	11 f4       	brne	.+4      	; 0x1588 <xQueueGenericSend+0x6e>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1584:	0e 94 3c 08 	call	0x1078	; 0x1078 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1588:	0f 90       	pop	r0
    158a:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    158c:	81 e0       	ldi	r24, 0x01	; 1
    158e:	4c c0       	rjmp	.+152    	; 0x1628 <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1590:	8c 81       	ldd	r24, Y+4	; 0x04
    1592:	9d 81       	ldd	r25, Y+5	; 0x05
    1594:	00 97       	sbiw	r24, 0x00	; 0
    1596:	21 f4       	brne	.+8      	; 0x15a0 <xQueueGenericSend+0x86>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1598:	0f 90       	pop	r0
    159a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    159c:	80 e0       	ldi	r24, 0x00	; 0
    159e:	44 c0       	rjmp	.+136    	; 0x1628 <xQueueGenericSend+0x10e>
				}
				else if( xEntryTimeSet == pdFALSE )
    15a0:	ff 20       	and	r15, r15
    15a2:	29 f4       	brne	.+10     	; 0x15ae <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    15a4:	ce 01       	movw	r24, r28
    15a6:	01 96       	adiw	r24, 0x01	; 1
    15a8:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    15ac:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    15ae:	0f 90       	pop	r0
    15b0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    15b2:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    15b6:	0f b6       	in	r0, 0x3f	; 63
    15b8:	f8 94       	cli
    15ba:	0f 92       	push	r0
    15bc:	f8 01       	movw	r30, r16
    15be:	85 8d       	ldd	r24, Z+29	; 0x1d
    15c0:	8f 3f       	cpi	r24, 0xFF	; 255
    15c2:	09 f4       	brne	.+2      	; 0x15c6 <xQueueGenericSend+0xac>
    15c4:	15 8e       	std	Z+29, r1	; 0x1d
    15c6:	f8 01       	movw	r30, r16
    15c8:	86 8d       	ldd	r24, Z+30	; 0x1e
    15ca:	8f 3f       	cpi	r24, 0xFF	; 255
    15cc:	09 f4       	brne	.+2      	; 0x15d0 <xQueueGenericSend+0xb6>
    15ce:	16 8e       	std	Z+30, r1	; 0x1e
    15d0:	0f 90       	pop	r0
    15d2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    15d4:	ce 01       	movw	r24, r28
    15d6:	01 96       	adiw	r24, 0x01	; 1
    15d8:	be 01       	movw	r22, r28
    15da:	6c 5f       	subi	r22, 0xFC	; 252
    15dc:	7f 4f       	sbci	r23, 0xFF	; 255
    15de:	0e 94 ff 11 	call	0x23fe	; 0x23fe <xTaskCheckForTimeOut>
    15e2:	88 23       	and	r24, r24
    15e4:	d9 f4       	brne	.+54     	; 0x161c <xQueueGenericSend+0x102>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    15e6:	c8 01       	movw	r24, r16
    15e8:	0e 94 4c 09 	call	0x1298	; 0x1298 <prvIsQueueFull>
    15ec:	88 23       	and	r24, r24
    15ee:	81 f0       	breq	.+32     	; 0x1610 <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    15f0:	6c 81       	ldd	r22, Y+4	; 0x04
    15f2:	7d 81       	ldd	r23, Y+5	; 0x05
    15f4:	c6 01       	movw	r24, r12
    15f6:	0e 94 8f 11 	call	0x231e	; 0x231e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    15fa:	c8 01       	movw	r24, r16
    15fc:	0e 94 c8 09 	call	0x1390	; 0x1390 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1600:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <xTaskResumeAll>
    1604:	88 23       	and	r24, r24
    1606:	09 f0       	breq	.+2      	; 0x160a <xQueueGenericSend+0xf0>
    1608:	a6 cf       	rjmp	.-180    	; 0x1556 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
    160a:	0e 94 3c 08 	call	0x1078	; 0x1078 <vPortYield>
    160e:	a3 cf       	rjmp	.-186    	; 0x1556 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1610:	c8 01       	movw	r24, r16
    1612:	0e 94 c8 09 	call	0x1390	; 0x1390 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1616:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <xTaskResumeAll>
    161a:	9d cf       	rjmp	.-198    	; 0x1556 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    161c:	c8 01       	movw	r24, r16
    161e:	0e 94 c8 09 	call	0x1390	; 0x1390 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1622:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1626:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1628:	0f 90       	pop	r0
    162a:	0f 90       	pop	r0
    162c:	0f 90       	pop	r0
    162e:	0f 90       	pop	r0
    1630:	0f 90       	pop	r0
    1632:	df 91       	pop	r29
    1634:	cf 91       	pop	r28
    1636:	1f 91       	pop	r17
    1638:	0f 91       	pop	r16
    163a:	ff 90       	pop	r15
    163c:	ef 90       	pop	r14
    163e:	df 90       	pop	r13
    1640:	cf 90       	pop	r12
    1642:	bf 90       	pop	r11
    1644:	9f 90       	pop	r9
    1646:	8f 90       	pop	r8
    1648:	08 95       	ret

0000164a <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    164a:	0f 93       	push	r16
    164c:	1f 93       	push	r17
    164e:	cf 93       	push	r28
    1650:	df 93       	push	r29
    1652:	ec 01       	movw	r28, r24
    1654:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1656:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1658:	8b 8d       	ldd	r24, Y+27	; 0x1b
    165a:	98 17       	cp	r25, r24
    165c:	e0 f4       	brcc	.+56     	; 0x1696 <xQueueGenericSendFromISR+0x4c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    165e:	ce 01       	movw	r24, r28
    1660:	42 2f       	mov	r20, r18
    1662:	0e 94 58 09 	call	0x12b0	; 0x12b0 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1666:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1668:	8f 3f       	cpi	r24, 0xFF	; 255
    166a:	81 f4       	brne	.+32     	; 0x168c <xQueueGenericSendFromISR+0x42>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    166c:	89 89       	ldd	r24, Y+17	; 0x11
    166e:	88 23       	and	r24, r24
    1670:	a1 f0       	breq	.+40     	; 0x169a <xQueueGenericSendFromISR+0x50>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1672:	ce 01       	movw	r24, r28
    1674:	41 96       	adiw	r24, 0x11	; 17
    1676:	0e 94 ac 11 	call	0x2358	; 0x2358 <xTaskRemoveFromEventList>
    167a:	88 23       	and	r24, r24
    167c:	81 f0       	breq	.+32     	; 0x169e <xQueueGenericSendFromISR+0x54>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    167e:	01 15       	cp	r16, r1
    1680:	11 05       	cpc	r17, r1
    1682:	79 f0       	breq	.+30     	; 0x16a2 <xQueueGenericSendFromISR+0x58>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1684:	81 e0       	ldi	r24, 0x01	; 1
    1686:	f8 01       	movw	r30, r16
    1688:	80 83       	st	Z, r24
    168a:	0c c0       	rjmp	.+24     	; 0x16a4 <xQueueGenericSendFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    168c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    168e:	8f 5f       	subi	r24, 0xFF	; 255
    1690:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1692:	81 e0       	ldi	r24, 0x01	; 1
    1694:	07 c0       	rjmp	.+14     	; 0x16a4 <xQueueGenericSendFromISR+0x5a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1696:	80 e0       	ldi	r24, 0x00	; 0
    1698:	05 c0       	rjmp	.+10     	; 0x16a4 <xQueueGenericSendFromISR+0x5a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    169a:	81 e0       	ldi	r24, 0x01	; 1
    169c:	03 c0       	rjmp	.+6      	; 0x16a4 <xQueueGenericSendFromISR+0x5a>
    169e:	81 e0       	ldi	r24, 0x01	; 1
    16a0:	01 c0       	rjmp	.+2      	; 0x16a4 <xQueueGenericSendFromISR+0x5a>
    16a2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    16a4:	df 91       	pop	r29
    16a6:	cf 91       	pop	r28
    16a8:	1f 91       	pop	r17
    16aa:	0f 91       	pop	r16
    16ac:	08 95       	ret

000016ae <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    16ae:	8f 92       	push	r8
    16b0:	9f 92       	push	r9
    16b2:	bf 92       	push	r11
    16b4:	cf 92       	push	r12
    16b6:	df 92       	push	r13
    16b8:	ef 92       	push	r14
    16ba:	ff 92       	push	r15
    16bc:	0f 93       	push	r16
    16be:	1f 93       	push	r17
    16c0:	cf 93       	push	r28
    16c2:	df 93       	push	r29
    16c4:	00 d0       	rcall	.+0      	; 0x16c6 <xQueueGenericReceive+0x18>
    16c6:	00 d0       	rcall	.+0      	; 0x16c8 <xQueueGenericReceive+0x1a>
    16c8:	0f 92       	push	r0
    16ca:	cd b7       	in	r28, 0x3d	; 61
    16cc:	de b7       	in	r29, 0x3e	; 62
    16ce:	8c 01       	movw	r16, r24
    16d0:	4b 01       	movw	r8, r22
    16d2:	5d 83       	std	Y+5, r21	; 0x05
    16d4:	4c 83       	std	Y+4, r20	; 0x04
    16d6:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    16d8:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    16da:	ee 24       	eor	r14, r14
    16dc:	e3 94       	inc	r14
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16de:	0f 2e       	mov	r0, r31
    16e0:	f1 e1       	ldi	r31, 0x11	; 17
    16e2:	cf 2e       	mov	r12, r31
    16e4:	dd 24       	eor	r13, r13
    16e6:	f0 2d       	mov	r31, r0
    16e8:	c8 0e       	add	r12, r24
    16ea:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    16ec:	0f b6       	in	r0, 0x3f	; 63
    16ee:	f8 94       	cli
    16f0:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    16f2:	f8 01       	movw	r30, r16
    16f4:	82 8d       	ldd	r24, Z+26	; 0x1a
    16f6:	88 23       	and	r24, r24
    16f8:	51 f1       	breq	.+84     	; 0x174e <xQueueGenericReceive+0xa0>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    16fa:	e6 80       	ldd	r14, Z+6	; 0x06
    16fc:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    16fe:	c8 01       	movw	r24, r16
    1700:	b4 01       	movw	r22, r8
    1702:	0e 94 99 09 	call	0x1332	; 0x1332 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1706:	bb 20       	and	r11, r11
    1708:	81 f4       	brne	.+32     	; 0x172a <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    170a:	f8 01       	movw	r30, r16
    170c:	82 8d       	ldd	r24, Z+26	; 0x1a
    170e:	81 50       	subi	r24, 0x01	; 1
    1710:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1712:	80 85       	ldd	r24, Z+8	; 0x08
    1714:	88 23       	and	r24, r24
    1716:	b9 f0       	breq	.+46     	; 0x1746 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1718:	c8 01       	movw	r24, r16
    171a:	08 96       	adiw	r24, 0x08	; 8
    171c:	0e 94 ac 11 	call	0x2358	; 0x2358 <xTaskRemoveFromEventList>
    1720:	81 30       	cpi	r24, 0x01	; 1
    1722:	89 f4       	brne	.+34     	; 0x1746 <xQueueGenericReceive+0x98>
						{
							portYIELD_WITHIN_API();
    1724:	0e 94 3c 08 	call	0x1078	; 0x1078 <vPortYield>
    1728:	0e c0       	rjmp	.+28     	; 0x1746 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    172a:	f8 01       	movw	r30, r16
    172c:	f7 82       	std	Z+7, r15	; 0x07
    172e:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1730:	81 89       	ldd	r24, Z+17	; 0x11
    1732:	88 23       	and	r24, r24
    1734:	41 f0       	breq	.+16     	; 0x1746 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1736:	c8 01       	movw	r24, r16
    1738:	41 96       	adiw	r24, 0x11	; 17
    173a:	0e 94 ac 11 	call	0x2358	; 0x2358 <xTaskRemoveFromEventList>
    173e:	88 23       	and	r24, r24
    1740:	11 f0       	breq	.+4      	; 0x1746 <xQueueGenericReceive+0x98>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1742:	0e 94 3c 08 	call	0x1078	; 0x1078 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    1746:	0f 90       	pop	r0
    1748:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    174a:	81 e0       	ldi	r24, 0x01	; 1
    174c:	50 c0       	rjmp	.+160    	; 0x17ee <xQueueGenericReceive+0x140>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    174e:	8c 81       	ldd	r24, Y+4	; 0x04
    1750:	9d 81       	ldd	r25, Y+5	; 0x05
    1752:	00 97       	sbiw	r24, 0x00	; 0
    1754:	21 f4       	brne	.+8      	; 0x175e <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1756:	0f 90       	pop	r0
    1758:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    175a:	80 e0       	ldi	r24, 0x00	; 0
    175c:	48 c0       	rjmp	.+144    	; 0x17ee <xQueueGenericReceive+0x140>
				}
				else if( xEntryTimeSet == pdFALSE )
    175e:	ff 20       	and	r15, r15
    1760:	29 f4       	brne	.+10     	; 0x176c <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1762:	ce 01       	movw	r24, r28
    1764:	01 96       	adiw	r24, 0x01	; 1
    1766:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    176a:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    176c:	0f 90       	pop	r0
    176e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1770:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1774:	0f b6       	in	r0, 0x3f	; 63
    1776:	f8 94       	cli
    1778:	0f 92       	push	r0
    177a:	f8 01       	movw	r30, r16
    177c:	85 8d       	ldd	r24, Z+29	; 0x1d
    177e:	8f 3f       	cpi	r24, 0xFF	; 255
    1780:	09 f4       	brne	.+2      	; 0x1784 <xQueueGenericReceive+0xd6>
    1782:	15 8e       	std	Z+29, r1	; 0x1d
    1784:	f8 01       	movw	r30, r16
    1786:	86 8d       	ldd	r24, Z+30	; 0x1e
    1788:	8f 3f       	cpi	r24, 0xFF	; 255
    178a:	09 f4       	brne	.+2      	; 0x178e <xQueueGenericReceive+0xe0>
    178c:	16 8e       	std	Z+30, r1	; 0x1e
    178e:	0f 90       	pop	r0
    1790:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1792:	ce 01       	movw	r24, r28
    1794:	01 96       	adiw	r24, 0x01	; 1
    1796:	be 01       	movw	r22, r28
    1798:	6c 5f       	subi	r22, 0xFC	; 252
    179a:	7f 4f       	sbci	r23, 0xFF	; 255
    179c:	0e 94 ff 11 	call	0x23fe	; 0x23fe <xTaskCheckForTimeOut>
    17a0:	88 23       	and	r24, r24
    17a2:	f9 f4       	brne	.+62     	; 0x17e2 <xQueueGenericReceive+0x134>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    17a4:	0f b6       	in	r0, 0x3f	; 63
    17a6:	f8 94       	cli
    17a8:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    17aa:	f8 01       	movw	r30, r16
    17ac:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    17ae:	0f 90       	pop	r0
    17b0:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17b2:	88 23       	and	r24, r24
    17b4:	81 f4       	brne	.+32     	; 0x17d6 <xQueueGenericReceive+0x128>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17b6:	6c 81       	ldd	r22, Y+4	; 0x04
    17b8:	7d 81       	ldd	r23, Y+5	; 0x05
    17ba:	c6 01       	movw	r24, r12
    17bc:	0e 94 8f 11 	call	0x231e	; 0x231e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    17c0:	c8 01       	movw	r24, r16
    17c2:	0e 94 c8 09 	call	0x1390	; 0x1390 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    17c6:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <xTaskResumeAll>
    17ca:	88 23       	and	r24, r24
    17cc:	09 f0       	breq	.+2      	; 0x17d0 <xQueueGenericReceive+0x122>
    17ce:	8e cf       	rjmp	.-228    	; 0x16ec <xQueueGenericReceive+0x3e>
				{
					portYIELD_WITHIN_API();
    17d0:	0e 94 3c 08 	call	0x1078	; 0x1078 <vPortYield>
    17d4:	8b cf       	rjmp	.-234    	; 0x16ec <xQueueGenericReceive+0x3e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    17d6:	c8 01       	movw	r24, r16
    17d8:	0e 94 c8 09 	call	0x1390	; 0x1390 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    17dc:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <xTaskResumeAll>
    17e0:	85 cf       	rjmp	.-246    	; 0x16ec <xQueueGenericReceive+0x3e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    17e2:	c8 01       	movw	r24, r16
    17e4:	0e 94 c8 09 	call	0x1390	; 0x1390 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    17e8:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    17ec:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    17ee:	0f 90       	pop	r0
    17f0:	0f 90       	pop	r0
    17f2:	0f 90       	pop	r0
    17f4:	0f 90       	pop	r0
    17f6:	0f 90       	pop	r0
    17f8:	df 91       	pop	r29
    17fa:	cf 91       	pop	r28
    17fc:	1f 91       	pop	r17
    17fe:	0f 91       	pop	r16
    1800:	ff 90       	pop	r15
    1802:	ef 90       	pop	r14
    1804:	df 90       	pop	r13
    1806:	cf 90       	pop	r12
    1808:	bf 90       	pop	r11
    180a:	9f 90       	pop	r9
    180c:	8f 90       	pop	r8
    180e:	08 95       	ret

00001810 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    1810:	0f 93       	push	r16
    1812:	1f 93       	push	r17
    1814:	cf 93       	push	r28
    1816:	df 93       	push	r29
    1818:	ec 01       	movw	r28, r24
    181a:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    181c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    181e:	88 23       	and	r24, r24
    1820:	f1 f0       	breq	.+60     	; 0x185e <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1822:	ce 01       	movw	r24, r28
    1824:	0e 94 99 09 	call	0x1332	; 0x1332 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1828:	8a 8d       	ldd	r24, Y+26	; 0x1a
    182a:	81 50       	subi	r24, 0x01	; 1
    182c:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    182e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1830:	8f 3f       	cpi	r24, 0xFF	; 255
    1832:	81 f4       	brne	.+32     	; 0x1854 <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1834:	88 85       	ldd	r24, Y+8	; 0x08
    1836:	88 23       	and	r24, r24
    1838:	a1 f0       	breq	.+40     	; 0x1862 <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    183a:	ce 01       	movw	r24, r28
    183c:	08 96       	adiw	r24, 0x08	; 8
    183e:	0e 94 ac 11 	call	0x2358	; 0x2358 <xTaskRemoveFromEventList>
    1842:	88 23       	and	r24, r24
    1844:	81 f0       	breq	.+32     	; 0x1866 <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1846:	01 15       	cp	r16, r1
    1848:	11 05       	cpc	r17, r1
    184a:	79 f0       	breq	.+30     	; 0x186a <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    184c:	81 e0       	ldi	r24, 0x01	; 1
    184e:	f8 01       	movw	r30, r16
    1850:	80 83       	st	Z, r24
    1852:	0c c0       	rjmp	.+24     	; 0x186c <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1854:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1856:	8f 5f       	subi	r24, 0xFF	; 255
    1858:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    185a:	81 e0       	ldi	r24, 0x01	; 1
    185c:	07 c0       	rjmp	.+14     	; 0x186c <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    185e:	80 e0       	ldi	r24, 0x00	; 0
    1860:	05 c0       	rjmp	.+10     	; 0x186c <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1862:	81 e0       	ldi	r24, 0x01	; 1
    1864:	03 c0       	rjmp	.+6      	; 0x186c <xQueueReceiveFromISR+0x5c>
    1866:	81 e0       	ldi	r24, 0x01	; 1
    1868:	01 c0       	rjmp	.+2      	; 0x186c <xQueueReceiveFromISR+0x5c>
    186a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    186c:	df 91       	pop	r29
    186e:	cf 91       	pop	r28
    1870:	1f 91       	pop	r17
    1872:	0f 91       	pop	r16
    1874:	08 95       	ret

00001876 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1876:	0f b6       	in	r0, 0x3f	; 63
    1878:	f8 94       	cli
    187a:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    187c:	fc 01       	movw	r30, r24
    187e:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1880:	0f 90       	pop	r0
    1882:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1884:	08 95       	ret

00001886 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1886:	fc 01       	movw	r30, r24
    1888:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    188a:	08 95       	ret

0000188c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    188c:	cf 93       	push	r28
    188e:	df 93       	push	r29
    1890:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1892:	88 81       	ld	r24, Y
    1894:	99 81       	ldd	r25, Y+1	; 0x01
    1896:	0e 94 3d 09 	call	0x127a	; 0x127a <vPortFree>
	vPortFree( pxQueue );
    189a:	ce 01       	movw	r24, r28
    189c:	0e 94 3d 09 	call	0x127a	; 0x127a <vPortFree>
}
    18a0:	df 91       	pop	r29
    18a2:	cf 91       	pop	r28
    18a4:	08 95       	ret

000018a6 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    18a6:	fc 01       	movw	r30, r24
    18a8:	92 8d       	ldd	r25, Z+26	; 0x1a
    18aa:	81 e0       	ldi	r24, 0x01	; 1
    18ac:	91 11       	cpse	r25, r1
    18ae:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    18b0:	08 95       	ret

000018b2 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    18b2:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    18b4:	22 8d       	ldd	r18, Z+26	; 0x1a
    18b6:	81 e0       	ldi	r24, 0x01	; 1
    18b8:	93 8d       	ldd	r25, Z+27	; 0x1b
    18ba:	29 13       	cpse	r18, r25
    18bc:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    18be:	08 95       	ret

000018c0 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType xTicksToWait )
{
    18c0:	ef 92       	push	r14
    18c2:	ff 92       	push	r15
    18c4:	0f 93       	push	r16
    18c6:	1f 93       	push	r17
    18c8:	cf 93       	push	r28
    18ca:	df 93       	push	r29
    18cc:	ec 01       	movw	r28, r24
    18ce:	7b 01       	movw	r14, r22
    18d0:	8a 01       	movw	r16, r20
signed portBASE_TYPE xReturn;

	/* If the queue is already full we may have to block.  A critical section
	is required to prevent an interrupt removing something from the queue
	between the check to see if the queue is full and blocking on the queue. */
	portDISABLE_INTERRUPTS();
    18d2:	f8 94       	cli
	{
		if( prvIsQueueFull( pxQueue ) != pdFALSE )
    18d4:	0e 94 4c 09 	call	0x1298	; 0x1298 <prvIsQueueFull>
    18d8:	88 23       	and	r24, r24
    18da:	79 f0       	breq	.+30     	; 0x18fa <xQueueCRSend+0x3a>
		{
			/* The queue is full - do we want to block or just leave without
			posting? */
			if( xTicksToWait > ( portTickType ) 0 )
    18dc:	01 15       	cp	r16, r1
    18de:	11 05       	cpc	r17, r1
    18e0:	49 f0       	breq	.+18     	; 0x18f4 <xQueueCRSend+0x34>
			{
				/* As this is called from a coroutine we cannot block directly, but
				return indicating that we need to block. */
				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    18e2:	be 01       	movw	r22, r28
    18e4:	68 5f       	subi	r22, 0xF8	; 248
    18e6:	7f 4f       	sbci	r23, 0xFF	; 255
    18e8:	c8 01       	movw	r24, r16
    18ea:	0e 94 35 05 	call	0xa6a	; 0xa6a <vCoRoutineAddToDelayedList>
				portENABLE_INTERRUPTS();
    18ee:	78 94       	sei
				return errQUEUE_BLOCKED;
    18f0:	8c ef       	ldi	r24, 0xFC	; 252
    18f2:	20 c0       	rjmp	.+64     	; 0x1934 <xQueueCRSend+0x74>
			}
			else
			{
				portENABLE_INTERRUPTS();
    18f4:	78 94       	sei
				return errQUEUE_FULL;
    18f6:	80 e0       	ldi	r24, 0x00	; 0
    18f8:	1d c0       	rjmp	.+58     	; 0x1934 <xQueueCRSend+0x74>
			}
		}
	}
	portENABLE_INTERRUPTS();
    18fa:	78 94       	sei

	portNOP();
    18fc:	00 00       	nop

	portDISABLE_INTERRUPTS();
    18fe:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1900:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1902:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1904:	98 17       	cp	r25, r24
    1906:	80 f4       	brcc	.+32     	; 0x1928 <xQueueCRSend+0x68>
		{
			/* There is room in the queue, copy the data into the queue. */
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1908:	ce 01       	movw	r24, r28
    190a:	b7 01       	movw	r22, r14
    190c:	40 e0       	ldi	r20, 0x00	; 0
    190e:	0e 94 58 09 	call	0x12b0	; 0x12b0 <prvCopyDataToQueue>
			xReturn = pdPASS;

			/* Were any co-routines waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1912:	89 89       	ldd	r24, Y+17	; 0x11
    1914:	88 23       	and	r24, r24
    1916:	51 f0       	breq	.+20     	; 0x192c <xQueueCRSend+0x6c>
			{
				/* In this instance the co-routine could be placed directly
				into the ready list as we are within a critical section.
				Instead the same pending ready list mechanism is used as if
				the event were caused from within an interrupt. */
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1918:	ce 01       	movw	r24, r28
    191a:	41 96       	adiw	r24, 0x11	; 17
    191c:	0e 94 b0 06 	call	0xd60	; 0xd60 <xCoRoutineRemoveFromEventList>
    1920:	88 23       	and	r24, r24
    1922:	31 f4       	brne	.+12     	; 0x1930 <xQueueCRSend+0x70>
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			/* There is room in the queue, copy the data into the queue. */
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
			xReturn = pdPASS;
    1924:	81 e0       	ldi	r24, 0x01	; 1
    1926:	05 c0       	rjmp	.+10     	; 0x1932 <xQueueCRSend+0x72>
				}
			}
		}
		else
		{
			xReturn = errQUEUE_FULL;
    1928:	80 e0       	ldi	r24, 0x00	; 0
    192a:	03 c0       	rjmp	.+6      	; 0x1932 <xQueueCRSend+0x72>
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			/* There is room in the queue, copy the data into the queue. */
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
			xReturn = pdPASS;
    192c:	81 e0       	ldi	r24, 0x01	; 1
    192e:	01 c0       	rjmp	.+2      	; 0x1932 <xQueueCRSend+0x72>
				the event were caused from within an interrupt. */
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
				{
					/* The co-routine waiting has a higher priority so record
					that a yield might be appropriate. */
					xReturn = errQUEUE_YIELD;
    1930:	8b ef       	ldi	r24, 0xFB	; 251
		else
		{
			xReturn = errQUEUE_FULL;
		}
	}
	portENABLE_INTERRUPTS();
    1932:	78 94       	sei

	return xReturn;
}
    1934:	df 91       	pop	r29
    1936:	cf 91       	pop	r28
    1938:	1f 91       	pop	r17
    193a:	0f 91       	pop	r16
    193c:	ff 90       	pop	r15
    193e:	ef 90       	pop	r14
    1940:	08 95       	ret

00001942 <xQueueCRReceive>:
#endif
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToWait )
{
    1942:	cf 93       	push	r28
    1944:	df 93       	push	r29
    1946:	ec 01       	movw	r28, r24
signed portBASE_TYPE xReturn;

	/* If the queue is already empty we may have to block.  A critical section
	is required to prevent an interrupt adding something to the queue
	between the check to see if the queue is empty and blocking on the queue. */
	portDISABLE_INTERRUPTS();
    1948:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
    194a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    194c:	88 23       	and	r24, r24
    194e:	79 f4       	brne	.+30     	; 0x196e <xQueueCRReceive+0x2c>
		{
			/* There are no messages in the queue, do we want to block or just
			leave with nothing? */
			if( xTicksToWait > ( portTickType ) 0 )
    1950:	41 15       	cp	r20, r1
    1952:	51 05       	cpc	r21, r1
    1954:	49 f0       	breq	.+18     	; 0x1968 <xQueueCRReceive+0x26>
			{
				/* As this is a co-routine we cannot block directly, but return
				indicating that we need to block. */
				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1956:	be 01       	movw	r22, r28
    1958:	6f 5e       	subi	r22, 0xEF	; 239
    195a:	7f 4f       	sbci	r23, 0xFF	; 255
    195c:	ca 01       	movw	r24, r20
    195e:	0e 94 35 05 	call	0xa6a	; 0xa6a <vCoRoutineAddToDelayedList>
				portENABLE_INTERRUPTS();
    1962:	78 94       	sei
				return errQUEUE_BLOCKED;
    1964:	8c ef       	ldi	r24, 0xFC	; 252
    1966:	36 c0       	rjmp	.+108    	; 0x19d4 <xQueueCRReceive+0x92>
			}
			else
			{
				portENABLE_INTERRUPTS();
    1968:	78 94       	sei
				return errQUEUE_FULL;
    196a:	80 e0       	ldi	r24, 0x00	; 0
    196c:	33 c0       	rjmp	.+102    	; 0x19d4 <xQueueCRReceive+0x92>
			}
		}
	}
	portENABLE_INTERRUPTS();
    196e:	78 94       	sei

	portNOP();
    1970:	00 00       	nop

	portDISABLE_INTERRUPTS();
    1972:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1974:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1976:	88 23       	and	r24, r24
    1978:	39 f1       	breq	.+78     	; 0x19c8 <xQueueCRReceive+0x86>
		{
			/* Data is available from the queue. */
			pxQueue->pcReadFrom += pxQueue->uxItemSize;
    197a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    197c:	2e 81       	ldd	r18, Y+6	; 0x06
    197e:	3f 81       	ldd	r19, Y+7	; 0x07
    1980:	24 0f       	add	r18, r20
    1982:	31 1d       	adc	r19, r1
    1984:	3f 83       	std	Y+7, r19	; 0x07
    1986:	2e 83       	std	Y+6, r18	; 0x06
			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1988:	ea 81       	ldd	r30, Y+2	; 0x02
    198a:	fb 81       	ldd	r31, Y+3	; 0x03
    198c:	2e 17       	cp	r18, r30
    198e:	3f 07       	cpc	r19, r31
    1990:	20 f0       	brcs	.+8      	; 0x199a <xQueueCRReceive+0x58>
			{
				pxQueue->pcReadFrom = pxQueue->pcHead;
    1992:	88 81       	ld	r24, Y
    1994:	99 81       	ldd	r25, Y+1	; 0x01
    1996:	9f 83       	std	Y+7, r25	; 0x07
    1998:	8e 83       	std	Y+6, r24	; 0x06
			}
			--( pxQueue->uxMessagesWaiting );
    199a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    199c:	81 50       	subi	r24, 0x01	; 1
    199e:	8a 8f       	std	Y+26, r24	; 0x1a
			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    19a0:	3e 81       	ldd	r19, Y+6	; 0x06
    19a2:	2f 81       	ldd	r18, Y+7	; 0x07
    19a4:	86 2f       	mov	r24, r22
    19a6:	97 2f       	mov	r25, r23
    19a8:	63 2f       	mov	r22, r19
    19aa:	72 2f       	mov	r23, r18
    19ac:	50 e0       	ldi	r21, 0x00	; 0
    19ae:	0e 94 49 13 	call	0x2692	; 0x2692 <memcpy>

			xReturn = pdPASS;

			/* Were any co-routines waiting for space to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    19b2:	88 85       	ldd	r24, Y+8	; 0x08
    19b4:	88 23       	and	r24, r24
    19b6:	51 f0       	breq	.+20     	; 0x19cc <xQueueCRReceive+0x8a>
			{
				/* In this instance the co-routine could be placed directly
				into the ready list as we are within a critical section.
				Instead the same pending ready list mechanism is used as if
				the event were caused from within an interrupt. */
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    19b8:	ce 01       	movw	r24, r28
    19ba:	08 96       	adiw	r24, 0x08	; 8
    19bc:	0e 94 b0 06 	call	0xd60	; 0xd60 <xCoRoutineRemoveFromEventList>
    19c0:	88 23       	and	r24, r24
    19c2:	31 f4       	brne	.+12     	; 0x19d0 <xQueueCRReceive+0x8e>
				pxQueue->pcReadFrom = pxQueue->pcHead;
			}
			--( pxQueue->uxMessagesWaiting );
			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			xReturn = pdPASS;
    19c4:	81 e0       	ldi	r24, 0x01	; 1
    19c6:	05 c0       	rjmp	.+10     	; 0x19d2 <xQueueCRReceive+0x90>
				}
			}
		}
		else
		{
			xReturn = pdFAIL;
    19c8:	80 e0       	ldi	r24, 0x00	; 0
    19ca:	03 c0       	rjmp	.+6      	; 0x19d2 <xQueueCRReceive+0x90>
				pxQueue->pcReadFrom = pxQueue->pcHead;
			}
			--( pxQueue->uxMessagesWaiting );
			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			xReturn = pdPASS;
    19cc:	81 e0       	ldi	r24, 0x01	; 1
    19ce:	01 c0       	rjmp	.+2      	; 0x19d2 <xQueueCRReceive+0x90>
				into the ready list as we are within a critical section.
				Instead the same pending ready list mechanism is used as if
				the event were caused from within an interrupt. */
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					xReturn = errQUEUE_YIELD;
    19d0:	8b ef       	ldi	r24, 0xFB	; 251
		else
		{
			xReturn = pdFAIL;
		}
	}
	portENABLE_INTERRUPTS();
    19d2:	78 94       	sei

	return xReturn;
}
    19d4:	df 91       	pop	r29
    19d6:	cf 91       	pop	r28
    19d8:	08 95       	ret

000019da <xQueueCRSendFromISR>:



#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
{
    19da:	1f 93       	push	r17
    19dc:	cf 93       	push	r28
    19de:	df 93       	push	r29
    19e0:	ec 01       	movw	r28, r24
    19e2:	14 2f       	mov	r17, r20
	/* Cannot block within an ISR so if there is no space on the queue then
	exit without doing anything. */
	if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    19e4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    19e6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    19e8:	98 17       	cp	r25, r24
    19ea:	88 f4       	brcc	.+34     	; 0x1a0e <xQueueCRSendFromISR+0x34>
	{
		prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    19ec:	ce 01       	movw	r24, r28
    19ee:	40 e0       	ldi	r20, 0x00	; 0
    19f0:	0e 94 58 09 	call	0x12b0	; 0x12b0 <prvCopyDataToQueue>

		/* We only want to wake one co-routine per ISR, so check that a
		co-routine has not already been woken. */
		if( xCoRoutinePreviouslyWoken == pdFALSE )
    19f4:	11 23       	and	r17, r17
    19f6:	59 f4       	brne	.+22     	; 0x1a0e <xQueueCRSendFromISR+0x34>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19f8:	89 89       	ldd	r24, Y+17	; 0x11
    19fa:	88 23       	and	r24, r24
    19fc:	41 f0       	breq	.+16     	; 0x1a0e <xQueueCRSendFromISR+0x34>
			{
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    19fe:	ce 01       	movw	r24, r28
    1a00:	41 96       	adiw	r24, 0x11	; 17
    1a02:	0e 94 b0 06 	call	0xd60	; 0xd60 <xCoRoutineRemoveFromEventList>
/*-----------------------------------------------------------*/



#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
    1a06:	11 e0       	ldi	r17, 0x01	; 1
    1a08:	88 23       	and	r24, r24
    1a0a:	09 f4       	brne	.+2      	; 0x1a0e <xQueueCRSendFromISR+0x34>
    1a0c:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
	}

	return xCoRoutinePreviouslyWoken;
}
    1a0e:	81 2f       	mov	r24, r17
    1a10:	df 91       	pop	r29
    1a12:	cf 91       	pop	r28
    1a14:	1f 91       	pop	r17
    1a16:	08 95       	ret

00001a18 <xQueueCRReceiveFromISR>:
#endif
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE_TYPE *pxCoRoutineWoken )
{
    1a18:	0f 93       	push	r16
    1a1a:	1f 93       	push	r17
    1a1c:	cf 93       	push	r28
    1a1e:	df 93       	push	r29
    1a20:	ec 01       	movw	r28, r24
    1a22:	86 2f       	mov	r24, r22
    1a24:	97 2f       	mov	r25, r23
    1a26:	8a 01       	movw	r16, r20
signed portBASE_TYPE xReturn;

	/* We cannot block from an ISR, so check there is data available. If
	not then just leave without doing anything. */
	if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1a28:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1a2a:	22 23       	and	r18, r18
    1a2c:	49 f1       	breq	.+82     	; 0x1a80 <xQueueCRReceiveFromISR+0x68>
	{
		/* Copy the data from the queue. */
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1a2e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1a30:	2e 81       	ldd	r18, Y+6	; 0x06
    1a32:	3f 81       	ldd	r19, Y+7	; 0x07
    1a34:	24 0f       	add	r18, r20
    1a36:	31 1d       	adc	r19, r1
    1a38:	3f 83       	std	Y+7, r19	; 0x07
    1a3a:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1a3c:	ea 81       	ldd	r30, Y+2	; 0x02
    1a3e:	fb 81       	ldd	r31, Y+3	; 0x03
    1a40:	2e 17       	cp	r18, r30
    1a42:	3f 07       	cpc	r19, r31
    1a44:	20 f0       	brcs	.+8      	; 0x1a4e <xQueueCRReceiveFromISR+0x36>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1a46:	28 81       	ld	r18, Y
    1a48:	39 81       	ldd	r19, Y+1	; 0x01
    1a4a:	3f 83       	std	Y+7, r19	; 0x07
    1a4c:	2e 83       	std	Y+6, r18	; 0x06
		}
		--( pxQueue->uxMessagesWaiting );
    1a4e:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1a50:	21 50       	subi	r18, 0x01	; 1
    1a52:	2a 8f       	std	Y+26, r18	; 0x1a
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1a54:	6e 81       	ldd	r22, Y+6	; 0x06
    1a56:	7f 81       	ldd	r23, Y+7	; 0x07
    1a58:	50 e0       	ldi	r21, 0x00	; 0
    1a5a:	0e 94 49 13 	call	0x2692	; 0x2692 <memcpy>

		if( ( *pxCoRoutineWoken ) == pdFALSE )
    1a5e:	f8 01       	movw	r30, r16
    1a60:	80 81       	ld	r24, Z
    1a62:	88 23       	and	r24, r24
    1a64:	79 f4       	brne	.+30     	; 0x1a84 <xQueueCRReceiveFromISR+0x6c>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a66:	88 85       	ldd	r24, Y+8	; 0x08
    1a68:	88 23       	and	r24, r24
    1a6a:	71 f0       	breq	.+28     	; 0x1a88 <xQueueCRReceiveFromISR+0x70>
			{
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a6c:	ce 01       	movw	r24, r28
    1a6e:	08 96       	adiw	r24, 0x08	; 8
    1a70:	0e 94 b0 06 	call	0xd60	; 0xd60 <xCoRoutineRemoveFromEventList>
    1a74:	88 23       	and	r24, r24
    1a76:	51 f0       	breq	.+20     	; 0x1a8c <xQueueCRReceiveFromISR+0x74>
				{
					*pxCoRoutineWoken = pdTRUE;
    1a78:	81 e0       	ldi	r24, 0x01	; 1
    1a7a:	f8 01       	movw	r30, r16
    1a7c:	80 83       	st	Z, r24
    1a7e:	07 c0       	rjmp	.+14     	; 0x1a8e <xQueueCRReceiveFromISR+0x76>

		xReturn = pdPASS;
	}
	else
	{
		xReturn = pdFAIL;
    1a80:	80 e0       	ldi	r24, 0x00	; 0
    1a82:	05 c0       	rjmp	.+10     	; 0x1a8e <xQueueCRReceiveFromISR+0x76>
					*pxCoRoutineWoken = pdTRUE;
				}
			}
		}

		xReturn = pdPASS;
    1a84:	81 e0       	ldi	r24, 0x01	; 1
    1a86:	03 c0       	rjmp	.+6      	; 0x1a8e <xQueueCRReceiveFromISR+0x76>
    1a88:	81 e0       	ldi	r24, 0x01	; 1
    1a8a:	01 c0       	rjmp	.+2      	; 0x1a8e <xQueueCRReceiveFromISR+0x76>
    1a8c:	81 e0       	ldi	r24, 0x01	; 1
	{
		xReturn = pdFAIL;
	}

	return xReturn;
}
    1a8e:	df 91       	pop	r29
    1a90:	cf 91       	pop	r28
    1a92:	1f 91       	pop	r17
    1a94:	0f 91       	pop	r16
    1a96:	08 95       	ret

00001a98 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1a98:	cf 93       	push	r28
    1a9a:	df 93       	push	r29
    1a9c:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1a9e:	e0 91 a9 06 	lds	r30, 0x06A9
    1aa2:	f0 91 aa 06 	lds	r31, 0x06AA
    1aa6:	93 83       	std	Z+3, r25	; 0x03
    1aa8:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    1aaa:	80 91 b1 06 	lds	r24, 0x06B1
    1aae:	90 91 b2 06 	lds	r25, 0x06B2
    1ab2:	c8 17       	cp	r28, r24
    1ab4:	d9 07       	cpc	r29, r25
    1ab6:	68 f4       	brcc	.+26     	; 0x1ad2 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1ab8:	80 91 b5 06 	lds	r24, 0x06B5
    1abc:	90 91 b6 06 	lds	r25, 0x06B6
    1ac0:	60 91 a9 06 	lds	r22, 0x06A9
    1ac4:	70 91 aa 06 	lds	r23, 0x06AA
    1ac8:	6e 5f       	subi	r22, 0xFE	; 254
    1aca:	7f 4f       	sbci	r23, 0xFF	; 255
    1acc:	0e 94 12 07 	call	0xe24	; 0xe24 <vListInsert>
    1ad0:	17 c0       	rjmp	.+46     	; 0x1b00 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1ad2:	80 91 b7 06 	lds	r24, 0x06B7
    1ad6:	90 91 b8 06 	lds	r25, 0x06B8
    1ada:	60 91 a9 06 	lds	r22, 0x06A9
    1ade:	70 91 aa 06 	lds	r23, 0x06AA
    1ae2:	6e 5f       	subi	r22, 0xFE	; 254
    1ae4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ae6:	0e 94 12 07 	call	0xe24	; 0xe24 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1aea:	80 91 67 00 	lds	r24, 0x0067
    1aee:	90 91 68 00 	lds	r25, 0x0068
    1af2:	c8 17       	cp	r28, r24
    1af4:	d9 07       	cpc	r29, r25
    1af6:	20 f4       	brcc	.+8      	; 0x1b00 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1af8:	d0 93 68 00 	sts	0x0068, r29
    1afc:	c0 93 67 00 	sts	0x0067, r28
		}
	}
}
    1b00:	df 91       	pop	r29
    1b02:	cf 91       	pop	r28
    1b04:	08 95       	ret

00001b06 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1b06:	4f 92       	push	r4
    1b08:	5f 92       	push	r5
    1b0a:	6f 92       	push	r6
    1b0c:	7f 92       	push	r7
    1b0e:	8f 92       	push	r8
    1b10:	9f 92       	push	r9
    1b12:	bf 92       	push	r11
    1b14:	cf 92       	push	r12
    1b16:	df 92       	push	r13
    1b18:	ef 92       	push	r14
    1b1a:	ff 92       	push	r15
    1b1c:	0f 93       	push	r16
    1b1e:	1f 93       	push	r17
    1b20:	cf 93       	push	r28
    1b22:	df 93       	push	r29
    1b24:	2c 01       	movw	r4, r24
    1b26:	4b 01       	movw	r8, r22
    1b28:	ea 01       	movw	r28, r20
    1b2a:	39 01       	movw	r6, r18
    1b2c:	b0 2e       	mov	r11, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1b2e:	81 e2       	ldi	r24, 0x21	; 33
    1b30:	90 e0       	ldi	r25, 0x00	; 0
    1b32:	0e 94 14 09 	call	0x1228	; 0x1228 <pvPortMalloc>
    1b36:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    1b38:	00 97       	sbiw	r24, 0x00	; 0
    1b3a:	09 f4       	brne	.+2      	; 0x1b3e <xTaskGenericCreate+0x38>
    1b3c:	e2 c0       	rjmp	.+452    	; 0x1d02 <xTaskGenericCreate+0x1fc>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1b3e:	c1 14       	cp	r12, r1
    1b40:	d1 04       	cpc	r13, r1
    1b42:	09 f0       	breq	.+2      	; 0x1b46 <xTaskGenericCreate+0x40>
    1b44:	f3 c0       	rjmp	.+486    	; 0x1d2c <xTaskGenericCreate+0x226>
    1b46:	ce 01       	movw	r24, r28
    1b48:	0e 94 14 09 	call	0x1228	; 0x1228 <pvPortMalloc>
    1b4c:	6c 01       	movw	r12, r24
    1b4e:	f8 01       	movw	r30, r16
    1b50:	90 8f       	std	Z+24, r25	; 0x18
    1b52:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1b54:	00 97       	sbiw	r24, 0x00	; 0
    1b56:	29 f4       	brne	.+10     	; 0x1b62 <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1b58:	c8 01       	movw	r24, r16
    1b5a:	0e 94 3d 09 	call	0x127a	; 0x127a <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1b5e:	8f ef       	ldi	r24, 0xFF	; 255
    1b60:	d5 c0       	rjmp	.+426    	; 0x1d0c <xTaskGenericCreate+0x206>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    1b62:	c6 01       	movw	r24, r12
    1b64:	65 ea       	ldi	r22, 0xA5	; 165
    1b66:	70 e0       	ldi	r23, 0x00	; 0
    1b68:	ae 01       	movw	r20, r28
    1b6a:	0e 94 52 13 	call	0x26a4	; 0x26a4 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1b6e:	9e 01       	movw	r18, r28
    1b70:	21 50       	subi	r18, 0x01	; 1
    1b72:	30 40       	sbci	r19, 0x00	; 0
    1b74:	f8 01       	movw	r30, r16
    1b76:	87 89       	ldd	r24, Z+23	; 0x17
    1b78:	90 8d       	ldd	r25, Z+24	; 0x18
    1b7a:	6c 01       	movw	r12, r24
    1b7c:	c2 0e       	add	r12, r18
    1b7e:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1b80:	c8 01       	movw	r24, r16
    1b82:	49 96       	adiw	r24, 0x19	; 25
    1b84:	b4 01       	movw	r22, r8
    1b86:	48 e0       	ldi	r20, 0x08	; 8
    1b88:	50 e0       	ldi	r21, 0x00	; 0
    1b8a:	0e 94 59 13 	call	0x26b2	; 0x26b2 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1b8e:	f8 01       	movw	r30, r16
    1b90:	10 a2       	lds	r17, 0x90
    1b92:	cb 2d       	mov	r28, r11
    1b94:	f3 e0       	ldi	r31, 0x03	; 3
    1b96:	fb 15       	cp	r31, r11
    1b98:	08 f4       	brcc	.+2      	; 0x1b9c <xTaskGenericCreate+0x96>
    1b9a:	c3 e0       	ldi	r28, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    1b9c:	f8 01       	movw	r30, r16
    1b9e:	c6 8b       	std	Z+22, r28	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1ba0:	88 24       	eor	r8, r8
    1ba2:	99 24       	eor	r9, r9
    1ba4:	68 94       	set
    1ba6:	81 f8       	bld	r8, 1
    1ba8:	80 0e       	add	r8, r16
    1baa:	91 1e       	adc	r9, r17
    1bac:	c4 01       	movw	r24, r8
    1bae:	0e 94 e5 06 	call	0xdca	; 0xdca <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1bb2:	c8 01       	movw	r24, r16
    1bb4:	0c 96       	adiw	r24, 0x0c	; 12
    1bb6:	0e 94 e5 06 	call	0xdca	; 0xdca <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1bba:	f8 01       	movw	r30, r16
    1bbc:	11 87       	std	Z+9, r17	; 0x09
    1bbe:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1bc0:	84 e0       	ldi	r24, 0x04	; 4
    1bc2:	90 e0       	ldi	r25, 0x00	; 0
    1bc4:	8c 1b       	sub	r24, r28
    1bc6:	91 09       	sbc	r25, r1
    1bc8:	95 87       	std	Z+13, r25	; 0x0d
    1bca:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1bcc:	13 8b       	std	Z+19, r17	; 0x13
    1bce:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1bd0:	c6 01       	movw	r24, r12
    1bd2:	b2 01       	movw	r22, r4
    1bd4:	a3 01       	movw	r20, r6
    1bd6:	0e 94 76 07 	call	0xeec	; 0xeec <pxPortInitialiseStack>
    1bda:	f8 01       	movw	r30, r16
    1bdc:	91 83       	std	Z+1, r25	; 0x01
    1bde:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1be0:	e1 14       	cp	r14, r1
    1be2:	f1 04       	cpc	r15, r1
    1be4:	19 f0       	breq	.+6      	; 0x1bec <xTaskGenericCreate+0xe6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1be6:	f7 01       	movw	r30, r14
    1be8:	11 83       	std	Z+1, r17	; 0x01
    1bea:	00 83       	st	Z, r16
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1bec:	0f b6       	in	r0, 0x3f	; 63
    1bee:	f8 94       	cli
    1bf0:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1bf2:	80 91 b3 06 	lds	r24, 0x06B3
    1bf6:	8f 5f       	subi	r24, 0xFF	; 255
    1bf8:	80 93 b3 06 	sts	0x06B3, r24
			if( pxCurrentTCB == NULL )
    1bfc:	80 91 a9 06 	lds	r24, 0x06A9
    1c00:	90 91 aa 06 	lds	r25, 0x06AA
    1c04:	00 97       	sbiw	r24, 0x00	; 0
    1c06:	d9 f5       	brne	.+118    	; 0x1c7e <xTaskGenericCreate+0x178>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1c08:	10 93 aa 06 	sts	0x06AA, r17
    1c0c:	00 93 a9 06 	sts	0x06A9, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1c10:	80 91 b3 06 	lds	r24, 0x06B3
    1c14:	81 30       	cpi	r24, 0x01	; 1
    1c16:	09 f0       	breq	.+2      	; 0x1c1a <xTaskGenericCreate+0x114>
    1c18:	41 c0       	rjmp	.+130    	; 0x1c9c <xTaskGenericCreate+0x196>
    1c1a:	c0 e0       	ldi	r28, 0x00	; 0
    1c1c:	d0 e0       	ldi	r29, 0x00	; 0
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    1c1e:	ce 01       	movw	r24, r28
    1c20:	88 0f       	add	r24, r24
    1c22:	99 1f       	adc	r25, r25
    1c24:	88 0f       	add	r24, r24
    1c26:	99 1f       	adc	r25, r25
    1c28:	88 0f       	add	r24, r24
    1c2a:	99 1f       	adc	r25, r25
    1c2c:	8c 0f       	add	r24, r28
    1c2e:	9d 1f       	adc	r25, r29
    1c30:	85 54       	subi	r24, 0x45	; 69
    1c32:	99 4f       	sbci	r25, 0xF9	; 249
    1c34:	0e 94 d7 06 	call	0xdae	; 0xdae <vListInitialise>
    1c38:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    1c3a:	c4 30       	cpi	r28, 0x04	; 4
    1c3c:	d1 05       	cpc	r29, r1
    1c3e:	79 f7       	brne	.-34     	; 0x1c1e <xTaskGenericCreate+0x118>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1c40:	cf ed       	ldi	r28, 0xDF	; 223
    1c42:	d6 e0       	ldi	r29, 0x06	; 6
    1c44:	ce 01       	movw	r24, r28
    1c46:	0e 94 d7 06 	call	0xdae	; 0xdae <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1c4a:	0f 2e       	mov	r0, r31
    1c4c:	f8 ee       	ldi	r31, 0xE8	; 232
    1c4e:	ef 2e       	mov	r14, r31
    1c50:	f6 e0       	ldi	r31, 0x06	; 6
    1c52:	ff 2e       	mov	r15, r31
    1c54:	f0 2d       	mov	r31, r0
    1c56:	c7 01       	movw	r24, r14
    1c58:	0e 94 d7 06 	call	0xdae	; 0xdae <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1c5c:	81 ef       	ldi	r24, 0xF1	; 241
    1c5e:	96 e0       	ldi	r25, 0x06	; 6
    1c60:	0e 94 d7 06 	call	0xdae	; 0xdae <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    1c64:	8a ef       	ldi	r24, 0xFA	; 250
    1c66:	96 e0       	ldi	r25, 0x06	; 6
    1c68:	0e 94 d7 06 	call	0xdae	; 0xdae <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1c6c:	d0 93 b8 06 	sts	0x06B8, r29
    1c70:	c0 93 b7 06 	sts	0x06B7, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1c74:	f0 92 b6 06 	sts	0x06B6, r15
    1c78:	e0 92 b5 06 	sts	0x06B5, r14
    1c7c:	0f c0       	rjmp	.+30     	; 0x1c9c <xTaskGenericCreate+0x196>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1c7e:	80 91 af 06 	lds	r24, 0x06AF
    1c82:	88 23       	and	r24, r24
    1c84:	59 f4       	brne	.+22     	; 0x1c9c <xTaskGenericCreate+0x196>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1c86:	e0 91 a9 06 	lds	r30, 0x06A9
    1c8a:	f0 91 aa 06 	lds	r31, 0x06AA
    1c8e:	86 89       	ldd	r24, Z+22	; 0x16
    1c90:	b8 16       	cp	r11, r24
    1c92:	20 f0       	brcs	.+8      	; 0x1c9c <xTaskGenericCreate+0x196>
					{
						pxCurrentTCB = pxNewTCB;
    1c94:	10 93 aa 06 	sts	0x06AA, r17
    1c98:	00 93 a9 06 	sts	0x06A9, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1c9c:	f8 01       	movw	r30, r16
    1c9e:	86 89       	ldd	r24, Z+22	; 0x16
    1ca0:	90 91 b9 06 	lds	r25, 0x06B9
    1ca4:	98 17       	cp	r25, r24
    1ca6:	10 f4       	brcc	.+4      	; 0x1cac <xTaskGenericCreate+0x1a6>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1ca8:	80 93 b9 06 	sts	0x06B9, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1cac:	90 91 ba 06 	lds	r25, 0x06BA
    1cb0:	9f 5f       	subi	r25, 0xFF	; 255
    1cb2:	90 93 ba 06 	sts	0x06BA, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    1cb6:	90 91 b0 06 	lds	r25, 0x06B0
    1cba:	98 17       	cp	r25, r24
    1cbc:	10 f4       	brcc	.+4      	; 0x1cc2 <xTaskGenericCreate+0x1bc>
    1cbe:	80 93 b0 06 	sts	0x06B0, r24
    1cc2:	90 e0       	ldi	r25, 0x00	; 0
    1cc4:	9c 01       	movw	r18, r24
    1cc6:	22 0f       	add	r18, r18
    1cc8:	33 1f       	adc	r19, r19
    1cca:	22 0f       	add	r18, r18
    1ccc:	33 1f       	adc	r19, r19
    1cce:	22 0f       	add	r18, r18
    1cd0:	33 1f       	adc	r19, r19
    1cd2:	82 0f       	add	r24, r18
    1cd4:	93 1f       	adc	r25, r19
    1cd6:	85 54       	subi	r24, 0x45	; 69
    1cd8:	99 4f       	sbci	r25, 0xF9	; 249
    1cda:	b4 01       	movw	r22, r8
    1cdc:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1ce0:	0f 90       	pop	r0
    1ce2:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1ce4:	80 91 af 06 	lds	r24, 0x06AF
    1ce8:	88 23       	and	r24, r24
    1cea:	69 f0       	breq	.+26     	; 0x1d06 <xTaskGenericCreate+0x200>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1cec:	e0 91 a9 06 	lds	r30, 0x06A9
    1cf0:	f0 91 aa 06 	lds	r31, 0x06AA
    1cf4:	86 89       	ldd	r24, Z+22	; 0x16
    1cf6:	8b 15       	cp	r24, r11
    1cf8:	40 f4       	brcc	.+16     	; 0x1d0a <xTaskGenericCreate+0x204>
			{
				portYIELD_WITHIN_API();
    1cfa:	0e 94 3c 08 	call	0x1078	; 0x1078 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1cfe:	81 e0       	ldi	r24, 0x01	; 1
    1d00:	05 c0       	rjmp	.+10     	; 0x1d0c <xTaskGenericCreate+0x206>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1d02:	8f ef       	ldi	r24, 0xFF	; 255
    1d04:	03 c0       	rjmp	.+6      	; 0x1d0c <xTaskGenericCreate+0x206>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1d06:	81 e0       	ldi	r24, 0x01	; 1
    1d08:	01 c0       	rjmp	.+2      	; 0x1d0c <xTaskGenericCreate+0x206>
    1d0a:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    1d0c:	df 91       	pop	r29
    1d0e:	cf 91       	pop	r28
    1d10:	1f 91       	pop	r17
    1d12:	0f 91       	pop	r16
    1d14:	ff 90       	pop	r15
    1d16:	ef 90       	pop	r14
    1d18:	df 90       	pop	r13
    1d1a:	cf 90       	pop	r12
    1d1c:	bf 90       	pop	r11
    1d1e:	9f 90       	pop	r9
    1d20:	8f 90       	pop	r8
    1d22:	7f 90       	pop	r7
    1d24:	6f 90       	pop	r6
    1d26:	5f 90       	pop	r5
    1d28:	4f 90       	pop	r4
    1d2a:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1d2c:	fc 01       	movw	r30, r24
    1d2e:	d0 8e       	std	Z+24, r13	; 0x18
    1d30:	c7 8a       	std	Z+23, r12	; 0x17
    1d32:	17 cf       	rjmp	.-466    	; 0x1b62 <xTaskGenericCreate+0x5c>

00001d34 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1d34:	ef 92       	push	r14
    1d36:	ff 92       	push	r15
    1d38:	0f 93       	push	r16
    1d3a:	1f 93       	push	r17
    1d3c:	cf 93       	push	r28
    1d3e:	df 93       	push	r29
    1d40:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1d42:	0f b6       	in	r0, 0x3f	; 63
    1d44:	f8 94       	cli
    1d46:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1d48:	80 91 a9 06 	lds	r24, 0x06A9
    1d4c:	90 91 aa 06 	lds	r25, 0x06AA
    1d50:	e8 16       	cp	r14, r24
    1d52:	f9 06       	cpc	r15, r25
    1d54:	21 f0       	breq	.+8      	; 0x1d5e <vTaskDelete+0x2a>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1d56:	e1 14       	cp	r14, r1
    1d58:	f1 04       	cpc	r15, r1
    1d5a:	41 f4       	brne	.+16     	; 0x1d6c <vTaskDelete+0x38>
    1d5c:	02 c0       	rjmp	.+4      	; 0x1d62 <vTaskDelete+0x2e>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
			{
				pxTaskToDelete = NULL;
    1d5e:	ee 24       	eor	r14, r14
    1d60:	ff 24       	eor	r15, r15
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1d62:	c0 91 a9 06 	lds	r28, 0x06A9
    1d66:	d0 91 aa 06 	lds	r29, 0x06AA
    1d6a:	01 c0       	rjmp	.+2      	; 0x1d6e <vTaskDelete+0x3a>
    1d6c:	e7 01       	movw	r28, r14

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1d6e:	8e 01       	movw	r16, r28
    1d70:	0e 5f       	subi	r16, 0xFE	; 254
    1d72:	1f 4f       	sbci	r17, 0xFF	; 255
    1d74:	c8 01       	movw	r24, r16
    1d76:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1d7a:	8c 89       	ldd	r24, Y+20	; 0x14
    1d7c:	9d 89       	ldd	r25, Y+21	; 0x15
    1d7e:	00 97       	sbiw	r24, 0x00	; 0
    1d80:	21 f0       	breq	.+8      	; 0x1d8a <vTaskDelete+0x56>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
    1d82:	ce 01       	movw	r24, r28
    1d84:	0c 96       	adiw	r24, 0x0c	; 12
    1d86:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1d8a:	8a ef       	ldi	r24, 0xFA	; 250
    1d8c:	96 e0       	ldi	r25, 0x06	; 6
    1d8e:	b8 01       	movw	r22, r16
    1d90:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1d94:	80 91 b4 06 	lds	r24, 0x06B4
    1d98:	8f 5f       	subi	r24, 0xFF	; 255
    1d9a:	80 93 b4 06 	sts	0x06B4, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1d9e:	80 91 ba 06 	lds	r24, 0x06BA
    1da2:	8f 5f       	subi	r24, 0xFF	; 255
    1da4:	80 93 ba 06 	sts	0x06BA, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1da8:	0f 90       	pop	r0
    1daa:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1dac:	80 91 af 06 	lds	r24, 0x06AF
    1db0:	88 23       	and	r24, r24
    1db2:	29 f0       	breq	.+10     	; 0x1dbe <vTaskDelete+0x8a>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1db4:	e1 14       	cp	r14, r1
    1db6:	f1 04       	cpc	r15, r1
    1db8:	11 f4       	brne	.+4      	; 0x1dbe <vTaskDelete+0x8a>
			{
				portYIELD_WITHIN_API();
    1dba:	0e 94 3c 08 	call	0x1078	; 0x1078 <vPortYield>
			}
		}
	}
    1dbe:	df 91       	pop	r29
    1dc0:	cf 91       	pop	r28
    1dc2:	1f 91       	pop	r17
    1dc4:	0f 91       	pop	r16
    1dc6:	ff 90       	pop	r15
    1dc8:	ef 90       	pop	r14
    1dca:	08 95       	ret

00001dcc <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1dcc:	af 92       	push	r10
    1dce:	bf 92       	push	r11
    1dd0:	cf 92       	push	r12
    1dd2:	df 92       	push	r13
    1dd4:	ef 92       	push	r14
    1dd6:	ff 92       	push	r15
    1dd8:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1dda:	85 e8       	ldi	r24, 0x85	; 133
    1ddc:	90 e1       	ldi	r25, 0x10	; 16
    1dde:	62 e6       	ldi	r22, 0x62	; 98
    1de0:	70 e0       	ldi	r23, 0x00	; 0
    1de2:	45 e5       	ldi	r20, 0x55	; 85
    1de4:	50 e0       	ldi	r21, 0x00	; 0
    1de6:	20 e0       	ldi	r18, 0x00	; 0
    1de8:	30 e0       	ldi	r19, 0x00	; 0
    1dea:	00 e0       	ldi	r16, 0x00	; 0
    1dec:	ee 24       	eor	r14, r14
    1dee:	ff 24       	eor	r15, r15
    1df0:	cc 24       	eor	r12, r12
    1df2:	dd 24       	eor	r13, r13
    1df4:	aa 24       	eor	r10, r10
    1df6:	bb 24       	eor	r11, r11
    1df8:	0e 94 83 0d 	call	0x1b06	; 0x1b06 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1dfc:	81 30       	cpi	r24, 0x01	; 1
    1dfe:	49 f4       	brne	.+18     	; 0x1e12 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1e00:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1e02:	80 93 af 06 	sts	0x06AF, r24
		xTickCount = ( portTickType ) 0U;
    1e06:	10 92 b2 06 	sts	0x06B2, r1
    1e0a:	10 92 b1 06 	sts	0x06B1, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1e0e:	0e 94 06 08 	call	0x100c	; 0x100c <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1e12:	0f 91       	pop	r16
    1e14:	ff 90       	pop	r15
    1e16:	ef 90       	pop	r14
    1e18:	df 90       	pop	r13
    1e1a:	cf 90       	pop	r12
    1e1c:	bf 90       	pop	r11
    1e1e:	af 90       	pop	r10
    1e20:	08 95       	ret

00001e22 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1e22:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1e24:	10 92 af 06 	sts	0x06AF, r1
	vPortEndScheduler();
    1e28:	0e 94 3b 08 	call	0x1076	; 0x1076 <vPortEndScheduler>
}
    1e2c:	08 95       	ret

00001e2e <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1e2e:	80 91 ae 06 	lds	r24, 0x06AE
    1e32:	8f 5f       	subi	r24, 0xFF	; 255
    1e34:	80 93 ae 06 	sts	0x06AE, r24
}
    1e38:	08 95       	ret

00001e3a <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1e3a:	0f b6       	in	r0, 0x3f	; 63
    1e3c:	f8 94       	cli
    1e3e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1e40:	80 91 b1 06 	lds	r24, 0x06B1
    1e44:	90 91 b2 06 	lds	r25, 0x06B2
	}
	taskEXIT_CRITICAL();
    1e48:	0f 90       	pop	r0
    1e4a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1e4c:	08 95       	ret

00001e4e <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    1e4e:	80 91 b1 06 	lds	r24, 0x06B1
    1e52:	90 91 b2 06 	lds	r25, 0x06B2
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1e56:	08 95       	ret

00001e58 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1e58:	80 91 b3 06 	lds	r24, 0x06B3
}
    1e5c:	08 95       	ret

00001e5e <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1e5e:	0f 93       	push	r16
    1e60:	1f 93       	push	r17
    1e62:	cf 93       	push	r28
    1e64:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1e66:	80 91 ae 06 	lds	r24, 0x06AE
    1e6a:	88 23       	and	r24, r24
    1e6c:	09 f0       	breq	.+2      	; 0x1e70 <vTaskIncrementTick+0x12>
    1e6e:	b3 c0       	rjmp	.+358    	; 0x1fd6 <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    1e70:	80 91 b1 06 	lds	r24, 0x06B1
    1e74:	90 91 b2 06 	lds	r25, 0x06B2
    1e78:	01 96       	adiw	r24, 0x01	; 1
    1e7a:	90 93 b2 06 	sts	0x06B2, r25
    1e7e:	80 93 b1 06 	sts	0x06B1, r24
		if( xTickCount == ( portTickType ) 0U )
    1e82:	80 91 b1 06 	lds	r24, 0x06B1
    1e86:	90 91 b2 06 	lds	r25, 0x06B2
    1e8a:	00 97       	sbiw	r24, 0x00	; 0
    1e8c:	99 f5       	brne	.+102    	; 0x1ef4 <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
    1e8e:	80 91 b7 06 	lds	r24, 0x06B7
    1e92:	90 91 b8 06 	lds	r25, 0x06B8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1e96:	20 91 b5 06 	lds	r18, 0x06B5
    1e9a:	30 91 b6 06 	lds	r19, 0x06B6
    1e9e:	30 93 b8 06 	sts	0x06B8, r19
    1ea2:	20 93 b7 06 	sts	0x06B7, r18
			pxOverflowDelayedTaskList = pxTemp;
    1ea6:	90 93 b6 06 	sts	0x06B6, r25
    1eaa:	80 93 b5 06 	sts	0x06B5, r24
			xNumOfOverflows++;
    1eae:	80 91 ab 06 	lds	r24, 0x06AB
    1eb2:	8f 5f       	subi	r24, 0xFF	; 255
    1eb4:	80 93 ab 06 	sts	0x06AB, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1eb8:	e0 91 b7 06 	lds	r30, 0x06B7
    1ebc:	f0 91 b8 06 	lds	r31, 0x06B8
    1ec0:	80 81       	ld	r24, Z
    1ec2:	88 23       	and	r24, r24
    1ec4:	39 f4       	brne	.+14     	; 0x1ed4 <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1ec6:	8f ef       	ldi	r24, 0xFF	; 255
    1ec8:	9f ef       	ldi	r25, 0xFF	; 255
    1eca:	90 93 68 00 	sts	0x0068, r25
    1ece:	80 93 67 00 	sts	0x0067, r24
    1ed2:	10 c0       	rjmp	.+32     	; 0x1ef4 <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1ed4:	e0 91 b7 06 	lds	r30, 0x06B7
    1ed8:	f0 91 b8 06 	lds	r31, 0x06B8
    1edc:	05 80       	ldd	r0, Z+5	; 0x05
    1ede:	f6 81       	ldd	r31, Z+6	; 0x06
    1ee0:	e0 2d       	mov	r30, r0
    1ee2:	06 80       	ldd	r0, Z+6	; 0x06
    1ee4:	f7 81       	ldd	r31, Z+7	; 0x07
    1ee6:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1ee8:	82 81       	ldd	r24, Z+2	; 0x02
    1eea:	93 81       	ldd	r25, Z+3	; 0x03
    1eec:	90 93 68 00 	sts	0x0068, r25
    1ef0:	80 93 67 00 	sts	0x0067, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1ef4:	20 91 b1 06 	lds	r18, 0x06B1
    1ef8:	30 91 b2 06 	lds	r19, 0x06B2
    1efc:	80 91 67 00 	lds	r24, 0x0067
    1f00:	90 91 68 00 	lds	r25, 0x0068
    1f04:	28 17       	cp	r18, r24
    1f06:	39 07       	cpc	r19, r25
    1f08:	08 f4       	brcc	.+2      	; 0x1f0c <vTaskIncrementTick+0xae>
    1f0a:	6a c0       	rjmp	.+212    	; 0x1fe0 <vTaskIncrementTick+0x182>
    1f0c:	e0 91 b7 06 	lds	r30, 0x06B7
    1f10:	f0 91 b8 06 	lds	r31, 0x06B8
    1f14:	80 81       	ld	r24, Z
    1f16:	88 23       	and	r24, r24
    1f18:	99 f0       	breq	.+38     	; 0x1f40 <vTaskIncrementTick+0xe2>
    1f1a:	e0 91 b7 06 	lds	r30, 0x06B7
    1f1e:	f0 91 b8 06 	lds	r31, 0x06B8
    1f22:	05 80       	ldd	r0, Z+5	; 0x05
    1f24:	f6 81       	ldd	r31, Z+6	; 0x06
    1f26:	e0 2d       	mov	r30, r0
    1f28:	c6 81       	ldd	r28, Z+6	; 0x06
    1f2a:	d7 81       	ldd	r29, Z+7	; 0x07
    1f2c:	8a 81       	ldd	r24, Y+2	; 0x02
    1f2e:	9b 81       	ldd	r25, Y+3	; 0x03
    1f30:	20 91 b1 06 	lds	r18, 0x06B1
    1f34:	30 91 b2 06 	lds	r19, 0x06B2
    1f38:	28 17       	cp	r18, r24
    1f3a:	39 07       	cpc	r19, r25
    1f3c:	f8 f4       	brcc	.+62     	; 0x1f7c <vTaskIncrementTick+0x11e>
    1f3e:	19 c0       	rjmp	.+50     	; 0x1f72 <vTaskIncrementTick+0x114>
    1f40:	8f ef       	ldi	r24, 0xFF	; 255
    1f42:	9f ef       	ldi	r25, 0xFF	; 255
    1f44:	90 93 68 00 	sts	0x0068, r25
    1f48:	80 93 67 00 	sts	0x0067, r24
    1f4c:	49 c0       	rjmp	.+146    	; 0x1fe0 <vTaskIncrementTick+0x182>
    1f4e:	e0 91 b7 06 	lds	r30, 0x06B7
    1f52:	f0 91 b8 06 	lds	r31, 0x06B8
    1f56:	05 80       	ldd	r0, Z+5	; 0x05
    1f58:	f6 81       	ldd	r31, Z+6	; 0x06
    1f5a:	e0 2d       	mov	r30, r0
    1f5c:	c6 81       	ldd	r28, Z+6	; 0x06
    1f5e:	d7 81       	ldd	r29, Z+7	; 0x07
    1f60:	8a 81       	ldd	r24, Y+2	; 0x02
    1f62:	9b 81       	ldd	r25, Y+3	; 0x03
    1f64:	20 91 b1 06 	lds	r18, 0x06B1
    1f68:	30 91 b2 06 	lds	r19, 0x06B2
    1f6c:	28 17       	cp	r18, r24
    1f6e:	39 07       	cpc	r19, r25
    1f70:	28 f4       	brcc	.+10     	; 0x1f7c <vTaskIncrementTick+0x11e>
    1f72:	90 93 68 00 	sts	0x0068, r25
    1f76:	80 93 67 00 	sts	0x0067, r24
    1f7a:	32 c0       	rjmp	.+100    	; 0x1fe0 <vTaskIncrementTick+0x182>
    1f7c:	8e 01       	movw	r16, r28
    1f7e:	0e 5f       	subi	r16, 0xFE	; 254
    1f80:	1f 4f       	sbci	r17, 0xFF	; 255
    1f82:	c8 01       	movw	r24, r16
    1f84:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>
    1f88:	8c 89       	ldd	r24, Y+20	; 0x14
    1f8a:	9d 89       	ldd	r25, Y+21	; 0x15
    1f8c:	00 97       	sbiw	r24, 0x00	; 0
    1f8e:	21 f0       	breq	.+8      	; 0x1f98 <vTaskIncrementTick+0x13a>
    1f90:	ce 01       	movw	r24, r28
    1f92:	0c 96       	adiw	r24, 0x0c	; 12
    1f94:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>
    1f98:	8e 89       	ldd	r24, Y+22	; 0x16
    1f9a:	90 91 b0 06 	lds	r25, 0x06B0
    1f9e:	98 17       	cp	r25, r24
    1fa0:	10 f4       	brcc	.+4      	; 0x1fa6 <vTaskIncrementTick+0x148>
    1fa2:	80 93 b0 06 	sts	0x06B0, r24
    1fa6:	90 e0       	ldi	r25, 0x00	; 0
    1fa8:	9c 01       	movw	r18, r24
    1faa:	22 0f       	add	r18, r18
    1fac:	33 1f       	adc	r19, r19
    1fae:	22 0f       	add	r18, r18
    1fb0:	33 1f       	adc	r19, r19
    1fb2:	22 0f       	add	r18, r18
    1fb4:	33 1f       	adc	r19, r19
    1fb6:	82 0f       	add	r24, r18
    1fb8:	93 1f       	adc	r25, r19
    1fba:	85 54       	subi	r24, 0x45	; 69
    1fbc:	99 4f       	sbci	r25, 0xF9	; 249
    1fbe:	b8 01       	movw	r22, r16
    1fc0:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <vListInsertEnd>
    1fc4:	e0 91 b7 06 	lds	r30, 0x06B7
    1fc8:	f0 91 b8 06 	lds	r31, 0x06B8
    1fcc:	80 81       	ld	r24, Z
    1fce:	88 23       	and	r24, r24
    1fd0:	09 f0       	breq	.+2      	; 0x1fd4 <vTaskIncrementTick+0x176>
    1fd2:	bd cf       	rjmp	.-134    	; 0x1f4e <vTaskIncrementTick+0xf0>
    1fd4:	b5 cf       	rjmp	.-150    	; 0x1f40 <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    1fd6:	80 91 ad 06 	lds	r24, 0x06AD
    1fda:	8f 5f       	subi	r24, 0xFF	; 255
    1fdc:	80 93 ad 06 	sts	0x06AD, r24
		{
			vApplicationTickHook();
		}
	}
	#endif
}
    1fe0:	df 91       	pop	r29
    1fe2:	cf 91       	pop	r28
    1fe4:	1f 91       	pop	r17
    1fe6:	0f 91       	pop	r16
    1fe8:	08 95       	ret

00001fea <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1fea:	af 92       	push	r10
    1fec:	bf 92       	push	r11
    1fee:	cf 92       	push	r12
    1ff0:	df 92       	push	r13
    1ff2:	ef 92       	push	r14
    1ff4:	ff 92       	push	r15
    1ff6:	0f 93       	push	r16
    1ff8:	1f 93       	push	r17
    1ffa:	cf 93       	push	r28
    1ffc:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1ffe:	0f b6       	in	r0, 0x3f	; 63
    2000:	f8 94       	cli
    2002:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2004:	80 91 ae 06 	lds	r24, 0x06AE
    2008:	81 50       	subi	r24, 0x01	; 1
    200a:	80 93 ae 06 	sts	0x06AE, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    200e:	80 91 ae 06 	lds	r24, 0x06AE
    2012:	88 23       	and	r24, r24
    2014:	09 f0       	breq	.+2      	; 0x2018 <xTaskResumeAll+0x2e>
    2016:	69 c0       	rjmp	.+210    	; 0x20ea <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2018:	80 91 b3 06 	lds	r24, 0x06B3
    201c:	88 23       	and	r24, r24
    201e:	81 f5       	brne	.+96     	; 0x2080 <xTaskResumeAll+0x96>
    2020:	67 c0       	rjmp	.+206    	; 0x20f0 <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2022:	d6 01       	movw	r26, r12
    2024:	ed 91       	ld	r30, X+
    2026:	fc 91       	ld	r31, X
    2028:	c6 81       	ldd	r28, Z+6	; 0x06
    202a:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
    202c:	ce 01       	movw	r24, r28
    202e:	0c 96       	adiw	r24, 0x0c	; 12
    2030:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
    2034:	8e 01       	movw	r16, r28
    2036:	0e 5f       	subi	r16, 0xFE	; 254
    2038:	1f 4f       	sbci	r17, 0xFF	; 255
    203a:	c8 01       	movw	r24, r16
    203c:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2040:	8e 89       	ldd	r24, Y+22	; 0x16
    2042:	90 91 b0 06 	lds	r25, 0x06B0
    2046:	98 17       	cp	r25, r24
    2048:	10 f4       	brcc	.+4      	; 0x204e <xTaskResumeAll+0x64>
    204a:	80 93 b0 06 	sts	0x06B0, r24
    204e:	90 e0       	ldi	r25, 0x00	; 0
    2050:	9c 01       	movw	r18, r24
    2052:	22 0f       	add	r18, r18
    2054:	33 1f       	adc	r19, r19
    2056:	22 0f       	add	r18, r18
    2058:	33 1f       	adc	r19, r19
    205a:	22 0f       	add	r18, r18
    205c:	33 1f       	adc	r19, r19
    205e:	82 0f       	add	r24, r18
    2060:	93 1f       	adc	r25, r19
    2062:	85 54       	subi	r24, 0x45	; 69
    2064:	99 4f       	sbci	r25, 0xF9	; 249
    2066:	b8 01       	movw	r22, r16
    2068:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    206c:	e0 91 a9 06 	lds	r30, 0x06A9
    2070:	f0 91 aa 06 	lds	r31, 0x06AA
    2074:	9e 89       	ldd	r25, Y+22	; 0x16
    2076:	86 89       	ldd	r24, Z+22	; 0x16
    2078:	98 17       	cp	r25, r24
    207a:	88 f0       	brcs	.+34     	; 0x209e <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    207c:	ba 2c       	mov	r11, r10
    207e:	0f c0       	rjmp	.+30     	; 0x209e <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2080:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2082:	0f 2e       	mov	r0, r31
    2084:	f1 ef       	ldi	r31, 0xF1	; 241
    2086:	ef 2e       	mov	r14, r31
    2088:	f6 e0       	ldi	r31, 0x06	; 6
    208a:	ff 2e       	mov	r15, r31
    208c:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    208e:	0f 2e       	mov	r0, r31
    2090:	f6 ef       	ldi	r31, 0xF6	; 246
    2092:	cf 2e       	mov	r12, r31
    2094:	f6 e0       	ldi	r31, 0x06	; 6
    2096:	df 2e       	mov	r13, r31
    2098:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    209a:	aa 24       	eor	r10, r10
    209c:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    209e:	f7 01       	movw	r30, r14
    20a0:	80 81       	ld	r24, Z
    20a2:	88 23       	and	r24, r24
    20a4:	09 f0       	breq	.+2      	; 0x20a8 <xTaskResumeAll+0xbe>
    20a6:	bd cf       	rjmp	.-134    	; 0x2022 <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    20a8:	80 91 ad 06 	lds	r24, 0x06AD
    20ac:	88 23       	and	r24, r24
    20ae:	81 f0       	breq	.+32     	; 0x20d0 <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    20b0:	80 91 ad 06 	lds	r24, 0x06AD
    20b4:	88 23       	and	r24, r24
    20b6:	99 f0       	breq	.+38     	; 0x20de <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    20b8:	0e 94 2f 0f 	call	0x1e5e	; 0x1e5e <vTaskIncrementTick>
						--uxMissedTicks;
    20bc:	80 91 ad 06 	lds	r24, 0x06AD
    20c0:	81 50       	subi	r24, 0x01	; 1
    20c2:	80 93 ad 06 	sts	0x06AD, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    20c6:	80 91 ad 06 	lds	r24, 0x06AD
    20ca:	88 23       	and	r24, r24
    20cc:	a9 f7       	brne	.-22     	; 0x20b8 <xTaskResumeAll+0xce>
    20ce:	07 c0       	rjmp	.+14     	; 0x20de <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    20d0:	f1 e0       	ldi	r31, 0x01	; 1
    20d2:	bf 16       	cp	r11, r31
    20d4:	21 f0       	breq	.+8      	; 0x20de <xTaskResumeAll+0xf4>
    20d6:	80 91 ac 06 	lds	r24, 0x06AC
    20da:	81 30       	cpi	r24, 0x01	; 1
    20dc:	41 f4       	brne	.+16     	; 0x20ee <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    20de:	10 92 ac 06 	sts	0x06AC, r1
					portYIELD_WITHIN_API();
    20e2:	0e 94 3c 08 	call	0x1078	; 0x1078 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    20e6:	81 e0       	ldi	r24, 0x01	; 1
    20e8:	03 c0       	rjmp	.+6      	; 0x20f0 <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    20ea:	80 e0       	ldi	r24, 0x00	; 0
    20ec:	01 c0       	rjmp	.+2      	; 0x20f0 <xTaskResumeAll+0x106>
    20ee:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    20f0:	0f 90       	pop	r0
    20f2:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    20f4:	df 91       	pop	r29
    20f6:	cf 91       	pop	r28
    20f8:	1f 91       	pop	r17
    20fa:	0f 91       	pop	r16
    20fc:	ff 90       	pop	r15
    20fe:	ef 90       	pop	r14
    2100:	df 90       	pop	r13
    2102:	cf 90       	pop	r12
    2104:	bf 90       	pop	r11
    2106:	af 90       	pop	r10
    2108:	08 95       	ret

0000210a <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    210a:	0a ef       	ldi	r16, 0xFA	; 250
    210c:	16 e0       	ldi	r17, 0x06	; 6
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    210e:	0f 2e       	mov	r0, r31
    2110:	ff ef       	ldi	r31, 0xFF	; 255
    2112:	ef 2e       	mov	r14, r31
    2114:	f6 e0       	ldi	r31, 0x06	; 6
    2116:	ff 2e       	mov	r15, r31
    2118:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    211a:	0f 2e       	mov	r0, r31
    211c:	fb eb       	ldi	r31, 0xBB	; 187
    211e:	cf 2e       	mov	r12, r31
    2120:	f6 e0       	ldi	r31, 0x06	; 6
    2122:	df 2e       	mov	r13, r31
    2124:	f0 2d       	mov	r31, r0
    2126:	27 c0       	rjmp	.+78     	; 0x2176 <prvIdleTask+0x6c>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
    2128:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    212c:	d8 01       	movw	r26, r16
    212e:	cc 91       	ld	r28, X
			xTaskResumeAll();
    2130:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2134:	cc 23       	and	r28, r28
    2136:	f9 f0       	breq	.+62     	; 0x2176 <prvIdleTask+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    2138:	0f b6       	in	r0, 0x3f	; 63
    213a:	f8 94       	cli
    213c:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    213e:	d7 01       	movw	r26, r14
    2140:	ed 91       	ld	r30, X+
    2142:	fc 91       	ld	r31, X
    2144:	c6 81       	ldd	r28, Z+6	; 0x06
    2146:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xGenericListItem ) );
    2148:	ce 01       	movw	r24, r28
    214a:	02 96       	adiw	r24, 0x02	; 2
    214c:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>
					--uxCurrentNumberOfTasks;
    2150:	80 91 b3 06 	lds	r24, 0x06B3
    2154:	81 50       	subi	r24, 0x01	; 1
    2156:	80 93 b3 06 	sts	0x06B3, r24
					--uxTasksDeleted;
    215a:	80 91 b4 06 	lds	r24, 0x06B4
    215e:	81 50       	subi	r24, 0x01	; 1
    2160:	80 93 b4 06 	sts	0x06B4, r24
				}
				taskEXIT_CRITICAL();
    2164:	0f 90       	pop	r0
    2166:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2168:	8f 89       	ldd	r24, Y+23	; 0x17
    216a:	98 8d       	ldd	r25, Y+24	; 0x18
    216c:	0e 94 3d 09 	call	0x127a	; 0x127a <vPortFree>
		vPortFree( pxTCB );
    2170:	ce 01       	movw	r24, r28
    2172:	0e 94 3d 09 	call	0x127a	; 0x127a <vPortFree>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    2176:	80 91 b4 06 	lds	r24, 0x06B4
    217a:	88 23       	and	r24, r24
    217c:	a9 f6       	brne	.-86     	; 0x2128 <prvIdleTask+0x1e>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    217e:	f6 01       	movw	r30, r12
    2180:	80 81       	ld	r24, Z
    2182:	82 30       	cpi	r24, 0x02	; 2
    2184:	10 f0       	brcs	.+4      	; 0x218a <prvIdleTask+0x80>
			{
				taskYIELD();
    2186:	0e 94 3c 08 	call	0x1078	; 0x1078 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    218a:	0e 94 33 13 	call	0x2666	; 0x2666 <vApplicationIdleHook>
				}
				xTaskResumeAll();
			}
		}
		#endif
	}
    218e:	f3 cf       	rjmp	.-26     	; 0x2176 <prvIdleTask+0x6c>

00002190 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2190:	cf 93       	push	r28
    2192:	df 93       	push	r29
    2194:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2196:	00 97       	sbiw	r24, 0x00	; 0
    2198:	b1 f0       	breq	.+44     	; 0x21c6 <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    219a:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    219e:	80 91 b1 06 	lds	r24, 0x06B1
    21a2:	90 91 b2 06 	lds	r25, 0x06B2
    21a6:	c8 0f       	add	r28, r24
    21a8:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    21aa:	80 91 a9 06 	lds	r24, 0x06A9
    21ae:	90 91 aa 06 	lds	r25, 0x06AA
    21b2:	02 96       	adiw	r24, 0x02	; 2
    21b4:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    21b8:	ce 01       	movw	r24, r28
    21ba:	0e 94 4c 0d 	call	0x1a98	; 0x1a98 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    21be:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    21c2:	88 23       	and	r24, r24
    21c4:	11 f4       	brne	.+4      	; 0x21ca <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    21c6:	0e 94 3c 08 	call	0x1078	; 0x1078 <vPortYield>
		}
	}
    21ca:	df 91       	pop	r29
    21cc:	cf 91       	pop	r28
    21ce:	08 95       	ret

000021d0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    21d0:	0f 93       	push	r16
    21d2:	1f 93       	push	r17
    21d4:	cf 93       	push	r28
    21d6:	df 93       	push	r29
    21d8:	8c 01       	movw	r16, r24
    21da:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    21dc:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    21e0:	f8 01       	movw	r30, r16
    21e2:	80 81       	ld	r24, Z
    21e4:	91 81       	ldd	r25, Z+1	; 0x01
    21e6:	c8 0f       	add	r28, r24
    21e8:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    21ea:	20 91 b1 06 	lds	r18, 0x06B1
    21ee:	30 91 b2 06 	lds	r19, 0x06B2
    21f2:	28 17       	cp	r18, r24
    21f4:	39 07       	cpc	r19, r25
    21f6:	68 f4       	brcc	.+26     	; 0x2212 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    21f8:	c8 17       	cp	r28, r24
    21fa:	d9 07       	cpc	r29, r25
    21fc:	50 f5       	brcc	.+84     	; 0x2252 <vTaskDelayUntil+0x82>
    21fe:	80 91 b1 06 	lds	r24, 0x06B1
    2202:	90 91 b2 06 	lds	r25, 0x06B2
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2206:	d1 83       	std	Z+1, r29	; 0x01
    2208:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    220a:	8c 17       	cp	r24, r28
    220c:	9d 07       	cpc	r25, r29
    220e:	b0 f4       	brcc	.+44     	; 0x223c <vTaskDelayUntil+0x6c>
    2210:	0b c0       	rjmp	.+22     	; 0x2228 <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2212:	c8 17       	cp	r28, r24
    2214:	d9 07       	cpc	r29, r25
    2216:	c8 f0       	brcs	.+50     	; 0x224a <vTaskDelayUntil+0x7a>
    2218:	80 91 b1 06 	lds	r24, 0x06B1
    221c:	90 91 b2 06 	lds	r25, 0x06B2
    2220:	8c 17       	cp	r24, r28
    2222:	9d 07       	cpc	r25, r29
    2224:	90 f0       	brcs	.+36     	; 0x224a <vTaskDelayUntil+0x7a>
    2226:	15 c0       	rjmp	.+42     	; 0x2252 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    2228:	80 91 a9 06 	lds	r24, 0x06A9
    222c:	90 91 aa 06 	lds	r25, 0x06AA
    2230:	02 96       	adiw	r24, 0x02	; 2
    2232:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2236:	ce 01       	movw	r24, r28
    2238:	0e 94 4c 0d 	call	0x1a98	; 0x1a98 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    223c:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2240:	88 23       	and	r24, r24
    2242:	59 f4       	brne	.+22     	; 0x225a <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    2244:	0e 94 3c 08 	call	0x1078	; 0x1078 <vPortYield>
    2248:	08 c0       	rjmp	.+16     	; 0x225a <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    224a:	f8 01       	movw	r30, r16
    224c:	d1 83       	std	Z+1, r29	; 0x01
    224e:	c0 83       	st	Z, r28
    2250:	eb cf       	rjmp	.-42     	; 0x2228 <vTaskDelayUntil+0x58>
    2252:	f8 01       	movw	r30, r16
    2254:	d1 83       	std	Z+1, r29	; 0x01
    2256:	c0 83       	st	Z, r28
    2258:	f1 cf       	rjmp	.-30     	; 0x223c <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    225a:	df 91       	pop	r29
    225c:	cf 91       	pop	r28
    225e:	1f 91       	pop	r17
    2260:	0f 91       	pop	r16
    2262:	08 95       	ret

00002264 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2264:	80 91 ae 06 	lds	r24, 0x06AE
    2268:	88 23       	and	r24, r24
    226a:	99 f4       	brne	.+38     	; 0x2292 <vTaskSwitchContext+0x2e>
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    226c:	80 91 b0 06 	lds	r24, 0x06B0
    2270:	90 e0       	ldi	r25, 0x00	; 0
    2272:	fc 01       	movw	r30, r24
    2274:	ee 0f       	add	r30, r30
    2276:	ff 1f       	adc	r31, r31
    2278:	ee 0f       	add	r30, r30
    227a:	ff 1f       	adc	r31, r31
    227c:	ee 0f       	add	r30, r30
    227e:	ff 1f       	adc	r31, r31
    2280:	8e 0f       	add	r24, r30
    2282:	9f 1f       	adc	r25, r31
    2284:	fc 01       	movw	r30, r24
    2286:	e5 54       	subi	r30, 0x45	; 69
    2288:	f9 4f       	sbci	r31, 0xF9	; 249
    228a:	80 81       	ld	r24, Z
    228c:	88 23       	and	r24, r24
    228e:	29 f0       	breq	.+10     	; 0x229a <vTaskSwitchContext+0x36>
    2290:	1b c0       	rjmp	.+54     	; 0x22c8 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2292:	81 e0       	ldi	r24, 0x01	; 1
    2294:	80 93 ac 06 	sts	0x06AC, r24
    2298:	08 95       	ret
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    229a:	80 91 b0 06 	lds	r24, 0x06B0
    229e:	81 50       	subi	r24, 0x01	; 1
    22a0:	80 93 b0 06 	sts	0x06B0, r24
    22a4:	80 91 b0 06 	lds	r24, 0x06B0
    22a8:	90 e0       	ldi	r25, 0x00	; 0
    22aa:	fc 01       	movw	r30, r24
    22ac:	ee 0f       	add	r30, r30
    22ae:	ff 1f       	adc	r31, r31
    22b0:	ee 0f       	add	r30, r30
    22b2:	ff 1f       	adc	r31, r31
    22b4:	ee 0f       	add	r30, r30
    22b6:	ff 1f       	adc	r31, r31
    22b8:	8e 0f       	add	r24, r30
    22ba:	9f 1f       	adc	r25, r31
    22bc:	fc 01       	movw	r30, r24
    22be:	e5 54       	subi	r30, 0x45	; 69
    22c0:	f9 4f       	sbci	r31, 0xF9	; 249
    22c2:	80 81       	ld	r24, Z
    22c4:	88 23       	and	r24, r24
    22c6:	49 f3       	breq	.-46     	; 0x229a <vTaskSwitchContext+0x36>
    22c8:	80 91 b0 06 	lds	r24, 0x06B0
    22cc:	90 e0       	ldi	r25, 0x00	; 0
    22ce:	fc 01       	movw	r30, r24
    22d0:	ee 0f       	add	r30, r30
    22d2:	ff 1f       	adc	r31, r31
    22d4:	ee 0f       	add	r30, r30
    22d6:	ff 1f       	adc	r31, r31
    22d8:	ee 0f       	add	r30, r30
    22da:	ff 1f       	adc	r31, r31
    22dc:	e8 0f       	add	r30, r24
    22de:	f9 1f       	adc	r31, r25
    22e0:	e5 54       	subi	r30, 0x45	; 69
    22e2:	f9 4f       	sbci	r31, 0xF9	; 249
    22e4:	a1 81       	ldd	r26, Z+1	; 0x01
    22e6:	b2 81       	ldd	r27, Z+2	; 0x02
    22e8:	12 96       	adiw	r26, 0x02	; 2
    22ea:	0d 90       	ld	r0, X+
    22ec:	bc 91       	ld	r27, X
    22ee:	a0 2d       	mov	r26, r0
    22f0:	b2 83       	std	Z+2, r27	; 0x02
    22f2:	a1 83       	std	Z+1, r26	; 0x01
    22f4:	cf 01       	movw	r24, r30
    22f6:	03 96       	adiw	r24, 0x03	; 3
    22f8:	a8 17       	cp	r26, r24
    22fa:	b9 07       	cpc	r27, r25
    22fc:	31 f4       	brne	.+12     	; 0x230a <vTaskSwitchContext+0xa6>
    22fe:	12 96       	adiw	r26, 0x02	; 2
    2300:	8d 91       	ld	r24, X+
    2302:	9c 91       	ld	r25, X
    2304:	13 97       	sbiw	r26, 0x03	; 3
    2306:	92 83       	std	Z+2, r25	; 0x02
    2308:	81 83       	std	Z+1, r24	; 0x01
    230a:	01 80       	ldd	r0, Z+1	; 0x01
    230c:	f2 81       	ldd	r31, Z+2	; 0x02
    230e:	e0 2d       	mov	r30, r0
    2310:	86 81       	ldd	r24, Z+6	; 0x06
    2312:	97 81       	ldd	r25, Z+7	; 0x07
    2314:	90 93 aa 06 	sts	0x06AA, r25
    2318:	80 93 a9 06 	sts	0x06A9, r24
    231c:	08 95       	ret

0000231e <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    231e:	cf 93       	push	r28
    2320:	df 93       	push	r29
    2322:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2324:	60 91 a9 06 	lds	r22, 0x06A9
    2328:	70 91 aa 06 	lds	r23, 0x06AA
    232c:	64 5f       	subi	r22, 0xF4	; 244
    232e:	7f 4f       	sbci	r23, 0xFF	; 255
    2330:	0e 94 12 07 	call	0xe24	; 0xe24 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    2334:	80 91 a9 06 	lds	r24, 0x06A9
    2338:	90 91 aa 06 	lds	r25, 0x06AA
    233c:	02 96       	adiw	r24, 0x02	; 2
    233e:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2342:	80 91 b1 06 	lds	r24, 0x06B1
    2346:	90 91 b2 06 	lds	r25, 0x06B2
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    234a:	8c 0f       	add	r24, r28
    234c:	9d 1f       	adc	r25, r29
    234e:	0e 94 4c 0d 	call	0x1a98	; 0x1a98 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2352:	df 91       	pop	r29
    2354:	cf 91       	pop	r28
    2356:	08 95       	ret

00002358 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2358:	0f 93       	push	r16
    235a:	1f 93       	push	r17
    235c:	cf 93       	push	r28
    235e:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2360:	dc 01       	movw	r26, r24
    2362:	15 96       	adiw	r26, 0x05	; 5
    2364:	ed 91       	ld	r30, X+
    2366:	fc 91       	ld	r31, X
    2368:	16 97       	sbiw	r26, 0x06	; 6
    236a:	06 81       	ldd	r16, Z+6	; 0x06
    236c:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    236e:	e8 01       	movw	r28, r16
    2370:	2c 96       	adiw	r28, 0x0c	; 12
    2372:	ce 01       	movw	r24, r28
    2374:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2378:	80 91 ae 06 	lds	r24, 0x06AE
    237c:	88 23       	and	r24, r24
    237e:	e9 f4       	brne	.+58     	; 0x23ba <xTaskRemoveFromEventList+0x62>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2380:	e8 01       	movw	r28, r16
    2382:	22 96       	adiw	r28, 0x02	; 2
    2384:	ce 01       	movw	r24, r28
    2386:	0e 94 4f 07 	call	0xe9e	; 0xe9e <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    238a:	f8 01       	movw	r30, r16
    238c:	86 89       	ldd	r24, Z+22	; 0x16
    238e:	90 91 b0 06 	lds	r25, 0x06B0
    2392:	98 17       	cp	r25, r24
    2394:	10 f4       	brcc	.+4      	; 0x239a <xTaskRemoveFromEventList+0x42>
    2396:	80 93 b0 06 	sts	0x06B0, r24
    239a:	90 e0       	ldi	r25, 0x00	; 0
    239c:	9c 01       	movw	r18, r24
    239e:	22 0f       	add	r18, r18
    23a0:	33 1f       	adc	r19, r19
    23a2:	22 0f       	add	r18, r18
    23a4:	33 1f       	adc	r19, r19
    23a6:	22 0f       	add	r18, r18
    23a8:	33 1f       	adc	r19, r19
    23aa:	82 0f       	add	r24, r18
    23ac:	93 1f       	adc	r25, r19
    23ae:	85 54       	subi	r24, 0x45	; 69
    23b0:	99 4f       	sbci	r25, 0xF9	; 249
    23b2:	be 01       	movw	r22, r28
    23b4:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <vListInsertEnd>
    23b8:	05 c0       	rjmp	.+10     	; 0x23c4 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    23ba:	81 ef       	ldi	r24, 0xF1	; 241
    23bc:	96 e0       	ldi	r25, 0x06	; 6
    23be:	be 01       	movw	r22, r28
    23c0:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    23c4:	e0 91 a9 06 	lds	r30, 0x06A9
    23c8:	f0 91 aa 06 	lds	r31, 0x06AA
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    23cc:	81 e0       	ldi	r24, 0x01	; 1
    23ce:	d8 01       	movw	r26, r16
    23d0:	56 96       	adiw	r26, 0x16	; 22
    23d2:	2c 91       	ld	r18, X
    23d4:	56 97       	sbiw	r26, 0x16	; 22
    23d6:	96 89       	ldd	r25, Z+22	; 0x16
    23d8:	29 17       	cp	r18, r25
    23da:	08 f4       	brcc	.+2      	; 0x23de <xTaskRemoveFromEventList+0x86>
    23dc:	80 e0       	ldi	r24, 0x00	; 0
}
    23de:	df 91       	pop	r29
    23e0:	cf 91       	pop	r28
    23e2:	1f 91       	pop	r17
    23e4:	0f 91       	pop	r16
    23e6:	08 95       	ret

000023e8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    23e8:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    23ea:	80 91 ab 06 	lds	r24, 0x06AB
    23ee:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    23f0:	80 91 b1 06 	lds	r24, 0x06B1
    23f4:	90 91 b2 06 	lds	r25, 0x06B2
    23f8:	92 83       	std	Z+2, r25	; 0x02
    23fa:	81 83       	std	Z+1, r24	; 0x01
}
    23fc:	08 95       	ret

000023fe <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    23fe:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2400:	0f b6       	in	r0, 0x3f	; 63
    2402:	f8 94       	cli
    2404:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2406:	80 91 ab 06 	lds	r24, 0x06AB
    240a:	90 81       	ld	r25, Z
    240c:	98 17       	cp	r25, r24
    240e:	49 f0       	breq	.+18     	; 0x2422 <xTaskCheckForTimeOut+0x24>
    2410:	80 91 b1 06 	lds	r24, 0x06B1
    2414:	90 91 b2 06 	lds	r25, 0x06B2
    2418:	21 81       	ldd	r18, Z+1	; 0x01
    241a:	32 81       	ldd	r19, Z+2	; 0x02
    241c:	82 17       	cp	r24, r18
    241e:	93 07       	cpc	r25, r19
    2420:	f0 f4       	brcc	.+60     	; 0x245e <xTaskCheckForTimeOut+0x60>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2422:	80 91 b1 06 	lds	r24, 0x06B1
    2426:	90 91 b2 06 	lds	r25, 0x06B2
    242a:	21 81       	ldd	r18, Z+1	; 0x01
    242c:	32 81       	ldd	r19, Z+2	; 0x02
    242e:	db 01       	movw	r26, r22
    2430:	4d 91       	ld	r20, X+
    2432:	5c 91       	ld	r21, X
    2434:	11 97       	sbiw	r26, 0x01	; 1
    2436:	82 1b       	sub	r24, r18
    2438:	93 0b       	sbc	r25, r19
    243a:	84 17       	cp	r24, r20
    243c:	95 07       	cpc	r25, r21
    243e:	88 f4       	brcc	.+34     	; 0x2462 <xTaskCheckForTimeOut+0x64>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2440:	80 91 b1 06 	lds	r24, 0x06B1
    2444:	90 91 b2 06 	lds	r25, 0x06B2
    2448:	28 1b       	sub	r18, r24
    244a:	39 0b       	sbc	r19, r25
    244c:	24 0f       	add	r18, r20
    244e:	35 1f       	adc	r19, r21
    2450:	2d 93       	st	X+, r18
    2452:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    2454:	cf 01       	movw	r24, r30
    2456:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    245a:	80 e0       	ldi	r24, 0x00	; 0
    245c:	03 c0       	rjmp	.+6      	; 0x2464 <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    245e:	81 e0       	ldi	r24, 0x01	; 1
    2460:	01 c0       	rjmp	.+2      	; 0x2464 <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2462:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2464:	0f 90       	pop	r0
    2466:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2468:	08 95       	ret

0000246a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    246a:	81 e0       	ldi	r24, 0x01	; 1
    246c:	80 93 ac 06 	sts	0x06AC, r24
}
    2470:	08 95       	ret

00002472 <spi_overhead>:
extern uint8_t reset_value;
void spi_overhead(void)
{
	for(;;)
	{
		ds1620_temp=SPI_DATA_MOSI[SPI_ds1620_temp];
    2472:	09 e5       	ldi	r16, 0x59	; 89
    2474:	17 e0       	ldi	r17, 0x07	; 7
		stove_mode_room_temp_target_var=SPI_DATA_MOSI[SPI_stove_mode_target_temp_var];
    2476:	78 01       	movw	r14, r16
    2478:	08 94       	sec
    247a:	e1 1c       	adc	r14, r1
    247c:	f1 1c       	adc	r15, r1
		switch (SPI_DATA_MOSI[SPI_basement_control])
    247e:	cc 24       	eor	r12, r12
    2480:	dd 24       	eor	r13, r13
    2482:	68 94       	set
    2484:	c1 f8       	bld	r12, 1
    2486:	c0 0e       	add	r12, r16
    2488:	d1 1e       	adc	r13, r17
			break;
			case stove_control_reset_normal:
			stove_control_reset(stove_control_reset_normal);
			break;			
		}
		SPI_DATA_MISO[SPI_LOOPBACK]=stove_mode_start_first; //SPI_DATA_MOSI[SPI_LOOPBACK];
    248a:	c8 e4       	ldi	r28, 0x48	; 72
    248c:	d7 e0       	ldi	r29, 0x07	; 7
		SPI_DATA_MISO[SPI_STOVE_MODE]=stove_mode;
    248e:	0f 2e       	mov	r0, r31
    2490:	f3 e0       	ldi	r31, 0x03	; 3
    2492:	af 2e       	mov	r10, r31
    2494:	bb 24       	eor	r11, r11
    2496:	f0 2d       	mov	r31, r0
    2498:	ac 0e       	add	r10, r28
    249a:	bd 1e       	adc	r11, r29
		SPI_DATA_MISO[SPI_ADC_VALUE1]=ADC_VALUE1;
    249c:	4e 01       	movw	r8, r28
    249e:	08 94       	sec
    24a0:	81 1c       	adc	r8, r1
    24a2:	91 1c       	adc	r9, r1
		SPI_DATA_MISO[SPI_ADC_VALUE2]=ADC_VALUE2;
    24a4:	66 24       	eor	r6, r6
    24a6:	77 24       	eor	r7, r7
    24a8:	68 94       	set
    24aa:	61 f8       	bld	r6, 1
    24ac:	6c 0e       	add	r6, r28
    24ae:	7d 1e       	adc	r7, r29
		SPI_DATA_MISO[SPI_HIGH_STEPPER_POS]=(STEPPER_POS >> 8);
    24b0:	44 24       	eor	r4, r4
    24b2:	55 24       	eor	r5, r5
    24b4:	68 94       	set
    24b6:	42 f8       	bld	r4, 2
    24b8:	4c 0e       	add	r4, r28
    24ba:	5d 1e       	adc	r5, r29
		SPI_DATA_MISO[SPI_LOW_STEPPER_POS]=(STEPPER_POS & 0XFF);
    24bc:	0f 2e       	mov	r0, r31
    24be:	f5 e0       	ldi	r31, 0x05	; 5
    24c0:	2f 2e       	mov	r2, r31
    24c2:	33 24       	eor	r3, r3
    24c4:	f0 2d       	mov	r31, r0
    24c6:	2c 0e       	add	r2, r28
    24c8:	3d 1e       	adc	r3, r29
extern uint8_t reset_value;
void spi_overhead(void)
{
	for(;;)
	{
		ds1620_temp=SPI_DATA_MOSI[SPI_ds1620_temp];
    24ca:	f8 01       	movw	r30, r16
    24cc:	80 81       	ld	r24, Z
    24ce:	80 93 8a 07 	sts	0x078A, r24
		stove_mode_room_temp_target_var=SPI_DATA_MOSI[SPI_stove_mode_target_temp_var];
    24d2:	f7 01       	movw	r30, r14
    24d4:	80 81       	ld	r24, Z
    24d6:	80 93 85 07 	sts	0x0785, r24
		switch (SPI_DATA_MOSI[SPI_basement_control])
    24da:	f6 01       	movw	r30, r12
    24dc:	80 81       	ld	r24, Z
    24de:	81 30       	cpi	r24, 0x01	; 1
    24e0:	29 f0       	breq	.+10     	; 0x24ec <spi_overhead+0x7a>
    24e2:	82 30       	cpi	r24, 0x02	; 2
    24e4:	31 f4       	brne	.+12     	; 0x24f2 <spi_overhead+0x80>
		{
			case stove_control_reset_nite:
			stove_control_reset(stove_control_reset_nite);
    24e6:	0e 94 6d 02 	call	0x4da	; 0x4da <stove_control_reset>
			break;
    24ea:	03 c0       	rjmp	.+6      	; 0x24f2 <spi_overhead+0x80>
			case stove_control_reset_normal:
			stove_control_reset(stove_control_reset_normal);
    24ec:	81 e0       	ldi	r24, 0x01	; 1
    24ee:	0e 94 6d 02 	call	0x4da	; 0x4da <stove_control_reset>
			break;			
		}
		SPI_DATA_MISO[SPI_LOOPBACK]=stove_mode_start_first; //SPI_DATA_MOSI[SPI_LOOPBACK];
    24f2:	80 91 7a 07 	lds	r24, 0x077A
    24f6:	88 83       	st	Y, r24
		SPI_DATA_MISO[SPI_STOVE_MODE]=stove_mode;
    24f8:	80 91 7e 07 	lds	r24, 0x077E
    24fc:	f5 01       	movw	r30, r10
    24fe:	80 83       	st	Z, r24
		SPI_DATA_MISO[SPI_ADC_VALUE1]=ADC_VALUE1;
    2500:	80 91 04 07 	lds	r24, 0x0704
    2504:	f4 01       	movw	r30, r8
    2506:	80 83       	st	Z, r24
		SPI_DATA_MISO[SPI_ADC_VALUE2]=ADC_VALUE2;
    2508:	80 91 05 07 	lds	r24, 0x0705
    250c:	f3 01       	movw	r30, r6
    250e:	80 83       	st	Z, r24
		SPI_DATA_MISO[SPI_HIGH_STEPPER_POS]=(STEPPER_POS >> 8);
    2510:	80 91 6f 07 	lds	r24, 0x076F
    2514:	90 91 70 07 	lds	r25, 0x0770
    2518:	f2 01       	movw	r30, r4
    251a:	90 83       	st	Z, r25
		SPI_DATA_MISO[SPI_LOW_STEPPER_POS]=(STEPPER_POS & 0XFF);
    251c:	f1 01       	movw	r30, r2
    251e:	80 83       	st	Z, r24
		SPI_DATA_MISO[SPI_HIGH_STEPPER_POS_CURRENT]=(STEPPER_POS_CURRENT >> 8);
    2520:	80 91 6b 07 	lds	r24, 0x076B
    2524:	90 91 6c 07 	lds	r25, 0x076C
    2528:	ee e4       	ldi	r30, 0x4E	; 78
    252a:	f7 e0       	ldi	r31, 0x07	; 7
    252c:	90 83       	st	Z, r25
		SPI_DATA_MISO[SPI_LOW_STEPPER_POS_CURRENT]=(STEPPER_POS_CURRENT & 0XFF);
    252e:	31 96       	adiw	r30, 0x01	; 1
    2530:	80 83       	st	Z, r24
		SPI_DATA_MISO[SPI_stove_target_temp]=stove_target_temp;
    2532:	80 91 87 07 	lds	r24, 0x0787
    2536:	31 96       	adiw	r30, 0x01	; 1
    2538:	80 83       	st	Z, r24
		SPI_DATA_MISO[SPI_stove_target_temp_lockout]=stove_target_temp_lockout;
    253a:	80 91 79 07 	lds	r24, 0x0779
    253e:	31 96       	adiw	r30, 0x01	; 1
    2540:	80 83       	st	Z, r24
		SPI_DATA_MISO[SPI_HIGH_stove_run_change_count]=(stove_run_change_count >> 8);
    2542:	80 91 77 07 	lds	r24, 0x0777
    2546:	90 91 78 07 	lds	r25, 0x0778
    254a:	9a 87       	std	Y+10, r25	; 0x0a
		SPI_DATA_MISO[SPI_LOW_stove_run_change_count]=(stove_run_change_count & 0XFF);
    254c:	8b 87       	std	Y+11, r24	; 0x0b
		SPI_DATA_MISO[SPI_HIGH_stove_cooldown_count]=(stove_cooldown_count >> 8);
    254e:	80 91 73 07 	lds	r24, 0x0773
    2552:	90 91 74 07 	lds	r25, 0x0774
    2556:	9c 87       	std	Y+12, r25	; 0x0c
		SPI_DATA_MISO[SPI_LOW_stove_cooldown_count]=(stove_cooldown_count & 0XFF);
    2558:	8d 87       	std	Y+13, r24	; 0x0d
		SPI_DATA_MISO[SPI_STEPPER_DISPLAY]=STEPPER_DISPLAY;
    255a:	80 91 6e 07 	lds	r24, 0x076E
    255e:	8e 87       	std	Y+14, r24	; 0x0e
		vTaskDelay(100);
    2560:	84 e6       	ldi	r24, 0x64	; 100
    2562:	90 e0       	ldi	r25, 0x00	; 0
    2564:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskDelay>
		if ((PINA & (_BV(PA5))) != (_BV(PA5)) )
    2568:	cd 99       	sbic	0x19, 5	; 25
    256a:	15 c0       	rjmp	.+42     	; 0x2596 <spi_overhead+0x124>
		{
			stove_control_reset(stove_control_reset_normal);
    256c:	81 e0       	ldi	r24, 0x01	; 1
    256e:	0e 94 6d 02 	call	0x4da	; 0x4da <stove_control_reset>
			reset_count++;
    2572:	80 91 8b 07 	lds	r24, 0x078B
    2576:	8f 5f       	subi	r24, 0xFF	; 255
    2578:	80 93 8b 07 	sts	0x078B, r24
			PORTA &= ~(_BV(PA4));
    257c:	dc 98       	cbi	0x1b, 4	; 27
			if (reset_count > 10)
    257e:	8b 30       	cpi	r24, 0x0B	; 11
    2580:	60 f0       	brcs	.+24     	; 0x259a <spi_overhead+0x128>
			{
				stove_control_reset(stove_control_reset_nite);
    2582:	82 e0       	ldi	r24, 0x02	; 2
    2584:	0e 94 6d 02 	call	0x4da	; 0x4da <stove_control_reset>
				PORTA |= _BV(PA4);
    2588:	dc 9a       	sbi	0x1b, 4	; 27
				vTaskDelay(100);
    258a:	84 e6       	ldi	r24, 0x64	; 100
    258c:	90 e0       	ldi	r25, 0x00	; 0
    258e:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskDelay>
				PORTA &= ~(_BV(PA4));						
    2592:	dc 98       	cbi	0x1b, 4	; 27
    2594:	02 c0       	rjmp	.+4      	; 0x259a <spi_overhead+0x128>
			}
		}
		else
		{
			reset_count=0;
    2596:	10 92 8b 07 	sts	0x078B, r1
		}
		if ((stove_mode & 0x03) == MODE_FEED)
    259a:	80 91 7e 07 	lds	r24, 0x077E
    259e:	83 70       	andi	r24, 0x03	; 3
    25a0:	82 30       	cpi	r24, 0x02	; 2
    25a2:	11 f4       	brne	.+4      	; 0x25a8 <spi_overhead+0x136>
		{
			PORTA |= _BV(PA4);
    25a4:	dc 9a       	sbi	0x1b, 4	; 27
    25a6:	91 cf       	rjmp	.-222    	; 0x24ca <spi_overhead+0x58>
		}
		else
		{
			PORTA &= ~(_BV(PA4));
    25a8:	dc 98       	cbi	0x1b, 4	; 27
    25aa:	8f cf       	rjmp	.-226    	; 0x24ca <spi_overhead+0x58>

000025ac <main>:
		}
	}	
}
short main( void )
{	
    25ac:	af 92       	push	r10
    25ae:	bf 92       	push	r11
    25b0:	cf 92       	push	r12
    25b2:	df 92       	push	r13
    25b4:	ef 92       	push	r14
    25b6:	ff 92       	push	r15
    25b8:	0f 93       	push	r16
	reset_value = MCUCSR;
    25ba:	84 b7       	in	r24, 0x34	; 52
    25bc:	80 93 89 07 	sts	0x0789, r24
	PORTA |=_BV(PA5);
    25c0:	dd 9a       	sbi	0x1b, 5	; 27
	DDRA &= ~(_BV(PA5));
    25c2:	d5 98       	cbi	0x1a, 5	; 26
	
	PORTA |= _BV(PA2);
    25c4:	da 9a       	sbi	0x1b, 2	; 27
	DDRA |= _BV(PA2);
    25c6:	d2 9a       	sbi	0x1a, 2	; 26
	PORTA |= _BV(PA4);
    25c8:	dc 9a       	sbi	0x1b, 4	; 27
	DDRA |= _BV(PA4);
    25ca:	d4 9a       	sbi	0x1a, 4	; 26
	
//	DDRB = 0xFF;
//	PORTB = 0;
    adc_init();
    25cc:	0e 94 49 00 	call	0x92	; 0x92 <adc_init>
	stepper_init();
    25d0:	0e 94 3c 01 	call	0x278	; 0x278 <stepper_init>
	stove_control_init();
    25d4:	0e 94 98 02 	call	0x530	; 0x530 <stove_control_init>
	spi_slave_init();
    25d8:	0e 94 c3 00 	call	0x186	; 0x186 <spi_slave_init>
	
	

	xTaskCreate( stepper, "Stepper", configMINIMAL_STACK_SIZE,NULL,3,NULL );
    25dc:	8d e8       	ldi	r24, 0x8D	; 141
    25de:	91 e0       	ldi	r25, 0x01	; 1
    25e0:	69 e6       	ldi	r22, 0x69	; 105
    25e2:	70 e0       	ldi	r23, 0x00	; 0
    25e4:	45 e5       	ldi	r20, 0x55	; 85
    25e6:	50 e0       	ldi	r21, 0x00	; 0
    25e8:	20 e0       	ldi	r18, 0x00	; 0
    25ea:	30 e0       	ldi	r19, 0x00	; 0
    25ec:	03 e0       	ldi	r16, 0x03	; 3
    25ee:	ee 24       	eor	r14, r14
    25f0:	ff 24       	eor	r15, r15
    25f2:	cc 24       	eor	r12, r12
    25f4:	dd 24       	eor	r13, r13
    25f6:	aa 24       	eor	r10, r10
    25f8:	bb 24       	eor	r11, r11
    25fa:	0e 94 83 0d 	call	0x1b06	; 0x1b06 <xTaskGenericCreate>
	xTaskCreate( adc, "ADC", configMINIMAL_STACK_SIZE,NULL,3,NULL );
    25fe:	89 e5       	ldi	r24, 0x59	; 89
    2600:	90 e0       	ldi	r25, 0x00	; 0
    2602:	61 e7       	ldi	r22, 0x71	; 113
    2604:	70 e0       	ldi	r23, 0x00	; 0
    2606:	45 e5       	ldi	r20, 0x55	; 85
    2608:	50 e0       	ldi	r21, 0x00	; 0
    260a:	20 e0       	ldi	r18, 0x00	; 0
    260c:	30 e0       	ldi	r19, 0x00	; 0
    260e:	0e 94 83 0d 	call	0x1b06	; 0x1b06 <xTaskGenericCreate>
	xTaskCreate( stove_control, "STOVECTR", configMINIMAL_STACK_SIZE,NULL,3,NULL );
    2612:	85 ea       	ldi	r24, 0xA5	; 165
    2614:	94 e0       	ldi	r25, 0x04	; 4
    2616:	65 e7       	ldi	r22, 0x75	; 117
    2618:	70 e0       	ldi	r23, 0x00	; 0
    261a:	45 e5       	ldi	r20, 0x55	; 85
    261c:	50 e0       	ldi	r21, 0x00	; 0
    261e:	20 e0       	ldi	r18, 0x00	; 0
    2620:	30 e0       	ldi	r19, 0x00	; 0
    2622:	0e 94 83 0d 	call	0x1b06	; 0x1b06 <xTaskGenericCreate>
	xTaskCreate( spi_slave, "SPIslave", configMINIMAL_STACK_SIZE,NULL,3,NULL );
    2626:	8b e0       	ldi	r24, 0x0B	; 11
    2628:	91 e0       	ldi	r25, 0x01	; 1
    262a:	6e e7       	ldi	r22, 0x7E	; 126
    262c:	70 e0       	ldi	r23, 0x00	; 0
    262e:	45 e5       	ldi	r20, 0x55	; 85
    2630:	50 e0       	ldi	r21, 0x00	; 0
    2632:	20 e0       	ldi	r18, 0x00	; 0
    2634:	30 e0       	ldi	r19, 0x00	; 0
    2636:	0e 94 83 0d 	call	0x1b06	; 0x1b06 <xTaskGenericCreate>
	xTaskCreate( spi_overhead, "SPIover", configMINIMAL_STACK_SIZE,NULL,3,NULL );
    263a:	89 e3       	ldi	r24, 0x39	; 57
    263c:	92 e1       	ldi	r25, 0x12	; 18
    263e:	67 e8       	ldi	r22, 0x87	; 135
    2640:	70 e0       	ldi	r23, 0x00	; 0
    2642:	45 e5       	ldi	r20, 0x55	; 85
    2644:	50 e0       	ldi	r21, 0x00	; 0
    2646:	20 e0       	ldi	r18, 0x00	; 0
    2648:	30 e0       	ldi	r19, 0x00	; 0
    264a:	0e 94 83 0d 	call	0x1b06	; 0x1b06 <xTaskGenericCreate>
	
	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION 
	as 1 in portmacro.h.  To use the cooperative scheduler define 
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
    264e:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <vTaskStartScheduler>

	return 0;
}
    2652:	80 e0       	ldi	r24, 0x00	; 0
    2654:	90 e0       	ldi	r25, 0x00	; 0
    2656:	0f 91       	pop	r16
    2658:	ff 90       	pop	r15
    265a:	ef 90       	pop	r14
    265c:	df 90       	pop	r13
    265e:	cf 90       	pop	r12
    2660:	bf 90       	pop	r11
    2662:	af 90       	pop	r10
    2664:	08 95       	ret

00002666 <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
	for( ;; )
	{
		asm volatile("nop\n\t");
    2666:	00 00       	nop
    2668:	fe cf       	rjmp	.-4      	; 0x2666 <vApplicationIdleHook>

0000266a <__udivmodhi4>:
    266a:	aa 1b       	sub	r26, r26
    266c:	bb 1b       	sub	r27, r27
    266e:	51 e1       	ldi	r21, 0x11	; 17
    2670:	07 c0       	rjmp	.+14     	; 0x2680 <__udivmodhi4_ep>

00002672 <__udivmodhi4_loop>:
    2672:	aa 1f       	adc	r26, r26
    2674:	bb 1f       	adc	r27, r27
    2676:	a6 17       	cp	r26, r22
    2678:	b7 07       	cpc	r27, r23
    267a:	10 f0       	brcs	.+4      	; 0x2680 <__udivmodhi4_ep>
    267c:	a6 1b       	sub	r26, r22
    267e:	b7 0b       	sbc	r27, r23

00002680 <__udivmodhi4_ep>:
    2680:	88 1f       	adc	r24, r24
    2682:	99 1f       	adc	r25, r25
    2684:	5a 95       	dec	r21
    2686:	a9 f7       	brne	.-22     	; 0x2672 <__udivmodhi4_loop>
    2688:	80 95       	com	r24
    268a:	90 95       	com	r25
    268c:	bc 01       	movw	r22, r24
    268e:	cd 01       	movw	r24, r26
    2690:	08 95       	ret

00002692 <memcpy>:
    2692:	fb 01       	movw	r30, r22
    2694:	dc 01       	movw	r26, r24
    2696:	02 c0       	rjmp	.+4      	; 0x269c <memcpy+0xa>
    2698:	01 90       	ld	r0, Z+
    269a:	0d 92       	st	X+, r0
    269c:	41 50       	subi	r20, 0x01	; 1
    269e:	50 40       	sbci	r21, 0x00	; 0
    26a0:	d8 f7       	brcc	.-10     	; 0x2698 <memcpy+0x6>
    26a2:	08 95       	ret

000026a4 <memset>:
    26a4:	dc 01       	movw	r26, r24
    26a6:	01 c0       	rjmp	.+2      	; 0x26aa <memset+0x6>
    26a8:	6d 93       	st	X+, r22
    26aa:	41 50       	subi	r20, 0x01	; 1
    26ac:	50 40       	sbci	r21, 0x00	; 0
    26ae:	e0 f7       	brcc	.-8      	; 0x26a8 <memset+0x4>
    26b0:	08 95       	ret

000026b2 <strncpy>:
    26b2:	fb 01       	movw	r30, r22
    26b4:	dc 01       	movw	r26, r24
    26b6:	41 50       	subi	r20, 0x01	; 1
    26b8:	50 40       	sbci	r21, 0x00	; 0
    26ba:	48 f0       	brcs	.+18     	; 0x26ce <strncpy+0x1c>
    26bc:	01 90       	ld	r0, Z+
    26be:	0d 92       	st	X+, r0
    26c0:	00 20       	and	r0, r0
    26c2:	c9 f7       	brne	.-14     	; 0x26b6 <strncpy+0x4>
    26c4:	01 c0       	rjmp	.+2      	; 0x26c8 <strncpy+0x16>
    26c6:	1d 92       	st	X+, r1
    26c8:	41 50       	subi	r20, 0x01	; 1
    26ca:	50 40       	sbci	r21, 0x00	; 0
    26cc:	e0 f7       	brcc	.-8      	; 0x26c6 <strncpy+0x14>
    26ce:	08 95       	ret

000026d0 <_exit>:
    26d0:	f8 94       	cli

000026d2 <__stop_program>:
    26d2:	ff cf       	rjmp	.-2      	; 0x26d2 <__stop_program>
