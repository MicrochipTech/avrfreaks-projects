
upstairsstove.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002f36  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000003a  00800060  00002f36  00002fea  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000711  0080009a  0080009a  00003024  2**0
                  ALLOC
  3 .eeprom       00000001  00810000  00810000  00003024  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00000ca8  00000000  00000000  00003028  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      0000033b  00000000  00000000  00003cd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000240  00000000  00000000  00004010  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00003787  00000000  00000000  00004250  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000010c2  00000000  00000000  000079d7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000019b3  00000000  00000000  00008a99  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000b74  00000000  00000000  0000a44c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000168c  00000000  00000000  0000afc0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002999  00000000  00000000  0000c64c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000110  00000000  00000000  0000efe5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 4f 0d 	jmp	0x1a9e	; 0x1a9e <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e3       	ldi	r30, 0x36	; 54
      68:	ff e2       	ldi	r31, 0x2F	; 47
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 39       	cpi	r26, 0x9A	; 154
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	aa e9       	ldi	r26, 0x9A	; 154
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ab 3a       	cpi	r26, 0xAB	; 171
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 98 16 	call	0x2d30	; 0x2d30 <main>
      8a:	0c 94 99 17 	jmp	0x2f32	; 0x2f32 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <adc_init>:
uint8_t ADC_VALUE3;


void adc_init(void)
{
	ADMUX = _BV(REFS0) | _BV(REFS1) | _BV(ADLAR);
      92:	80 ee       	ldi	r24, 0xE0	; 224
      94:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= (ADC_CLOCK_SCALER | _BV(ADEN));
      96:	86 b1       	in	r24, 0x06	; 6
      98:	86 68       	ori	r24, 0x86	; 134
      9a:	86 b9       	out	0x06, r24	; 6
	ADCSRA |= _BV(ADSC);
      9c:	36 9a       	sbi	0x06, 6	; 6
      9e:	e0 e1       	ldi	r30, 0x10	; 16
      a0:	f7 e0       	ldi	r31, 0x07	; 7
uint8_t ADC_VALUE1;
uint8_t ADC_VALUE2;
uint8_t ADC_VALUE3;


void adc_init(void)
      a2:	80 e5       	ldi	r24, 0x50	; 80
      a4:	97 e0       	ldi	r25, 0x07	; 7
	ADMUX = _BV(REFS0) | _BV(REFS1) | _BV(ADLAR);
	ADCSRA |= (ADC_CLOCK_SCALER | _BV(ADEN));
	ADCSRA |= _BV(ADSC);
	for (uint8_t x = 0; x < 64 ; x++ )
	{
		ADC_BUFFER[x] = 0xff;
      a6:	2f ef       	ldi	r18, 0xFF	; 255
      a8:	21 93       	st	Z+, r18
void adc_init(void)
{
	ADMUX = _BV(REFS0) | _BV(REFS1) | _BV(ADLAR);
	ADCSRA |= (ADC_CLOCK_SCALER | _BV(ADEN));
	ADCSRA |= _BV(ADSC);
	for (uint8_t x = 0; x < 64 ; x++ )
      aa:	e8 17       	cp	r30, r24
      ac:	f9 07       	cpc	r31, r25
      ae:	e1 f7       	brne	.-8      	; 0xa8 <adc_init+0x16>
	{
		ADC_BUFFER[x] = 0xff;
	}
}
      b0:	08 95       	ret

000000b2 <adc>:
		while (bit_is_clear(ADCSRA,ADIF)) 
		{
				vTaskDelay(1);
		}
		
		ADC_BUFFER_SUM -= ADC_BUFFER[ADC_BUFFER_POS];
      b2:	c0 e1       	ldi	r28, 0x10	; 16
      b4:	d7 e0       	ldi	r29, 0x07	; 7

void adc(void)
{
	for( ;; )
	{
		ADMUX &= ~(_BV(MUX0));
      b6:	38 98       	cbi	0x07, 0	; 7
		
		ADCSRA |= _BV(ADSC);
      b8:	36 9a       	sbi	0x06, 6	; 6
		
		while (bit_is_clear(ADCSRA,ADIF)) 
      ba:	34 99       	sbic	0x06, 4	; 6
      bc:	06 c0       	rjmp	.+12     	; 0xca <adc+0x18>
		{
				vTaskDelay(1);
      be:	81 e0       	ldi	r24, 0x01	; 1
      c0:	90 e0       	ldi	r25, 0x00	; 0
      c2:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
	{
		ADMUX &= ~(_BV(MUX0));
		
		ADCSRA |= _BV(ADSC);
		
		while (bit_is_clear(ADCSRA,ADIF)) 
      c6:	34 9b       	sbis	0x06, 4	; 6
      c8:	fa cf       	rjmp	.-12     	; 0xbe <adc+0xc>
		{
				vTaskDelay(1);
		}
		
		ADC_BUFFER_SUM -= ADC_BUFFER[ADC_BUFFER_POS];
      ca:	20 91 9a 00 	lds	r18, 0x009A
      ce:	fe 01       	movw	r30, r28
      d0:	e2 0f       	add	r30, r18
      d2:	f1 1d       	adc	r31, r1
      d4:	30 81       	ld	r19, Z
      d6:	80 91 60 00 	lds	r24, 0x0060
      da:	90 91 61 00 	lds	r25, 0x0061
      de:	83 1b       	sub	r24, r19
      e0:	91 09       	sbc	r25, r1
      e2:	90 93 61 00 	sts	0x0061, r25
      e6:	80 93 60 00 	sts	0x0060, r24
		ADC_BUFFER[ADC_BUFFER_POS] = ADCH;
      ea:	35 b1       	in	r19, 0x05	; 5
      ec:	30 83       	st	Z, r19
		ADC_BUFFER_SUM += ADC_BUFFER[ADC_BUFFER_POS];
      ee:	83 0f       	add	r24, r19
      f0:	91 1d       	adc	r25, r1
      f2:	90 93 61 00 	sts	0x0061, r25
      f6:	80 93 60 00 	sts	0x0060, r24
		ADC_VALUE1 = (ADC_BUFFER_SUM >> 6);
      fa:	00 24       	eor	r0, r0
      fc:	88 0f       	add	r24, r24
      fe:	99 1f       	adc	r25, r25
     100:	00 1c       	adc	r0, r0
     102:	88 0f       	add	r24, r24
     104:	99 1f       	adc	r25, r25
     106:	00 1c       	adc	r0, r0
     108:	89 2f       	mov	r24, r25
     10a:	90 2d       	mov	r25, r0
     10c:	80 93 0e 07 	sts	0x070E, r24
		ADC_BUFFER_POS++;
     110:	2f 5f       	subi	r18, 0xFF	; 255
		ADC_BUFFER_POS &= 0x3f;
     112:	2f 73       	andi	r18, 0x3F	; 63
     114:	20 93 9a 00 	sts	0x009A, r18
		
		vTaskDelay(ADC_DELAY);
     118:	84 ef       	ldi	r24, 0xF4	; 244
     11a:	91 e0       	ldi	r25, 0x01	; 1
     11c:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
		
		ADMUX |= _BV(MUX0);
     120:	38 9a       	sbi	0x07, 0	; 7
		
		ADCSRA |= _BV(ADSC);
     122:	36 9a       	sbi	0x06, 6	; 6
		
		while (bit_is_clear(ADCSRA,ADIF))
     124:	34 99       	sbic	0x06, 4	; 6
     126:	06 c0       	rjmp	.+12     	; 0x134 <adc+0x82>
		{
			vTaskDelay(1);
     128:	81 e0       	ldi	r24, 0x01	; 1
     12a:	90 e0       	ldi	r25, 0x00	; 0
     12c:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
		
		ADMUX |= _BV(MUX0);
		
		ADCSRA |= _BV(ADSC);
		
		while (bit_is_clear(ADCSRA,ADIF))
     130:	34 9b       	sbis	0x06, 4	; 6
     132:	fa cf       	rjmp	.-12     	; 0x128 <adc+0x76>
		{
			vTaskDelay(1);
		}
		
		ADC_VALUE2 = ADCH;
     134:	85 b1       	in	r24, 0x05	; 5
     136:	80 93 0f 07 	sts	0x070F, r24
		
		vTaskDelay(ADC_DELAY);
     13a:	84 ef       	ldi	r24, 0xF4	; 244
     13c:	91 e0       	ldi	r25, 0x01	; 1
     13e:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
		ADMUX &= ~(_BV(MUX0));
     142:	38 98       	cbi	0x07, 0	; 7
		#ifndef DOWN_STAIRS_
		
		ADMUX |= _BV(MUX2);
     144:	3a 9a       	sbi	0x07, 2	; 7
		
		ADCSRA |= _BV(ADSC);
     146:	36 9a       	sbi	0x06, 6	; 6
		
		while (bit_is_clear(ADCSRA,ADIF))
     148:	34 99       	sbic	0x06, 4	; 6
     14a:	06 c0       	rjmp	.+12     	; 0x158 <adc+0xa6>
		{
			vTaskDelay(1);
     14c:	81 e0       	ldi	r24, 0x01	; 1
     14e:	90 e0       	ldi	r25, 0x00	; 0
     150:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
		
		ADMUX |= _BV(MUX2);
		
		ADCSRA |= _BV(ADSC);
		
		while (bit_is_clear(ADCSRA,ADIF))
     154:	34 9b       	sbis	0x06, 4	; 6
     156:	fa cf       	rjmp	.-12     	; 0x14c <adc+0x9a>
		{
			vTaskDelay(1);
		}
		
		ADC_VALUE3 = ADCH;
     158:	85 b1       	in	r24, 0x05	; 5
     15a:	80 93 0d 07 	sts	0x070D, r24
		vTaskDelay(ADC_DELAY);
     15e:	84 ef       	ldi	r24, 0xF4	; 244
     160:	91 e0       	ldi	r25, 0x01	; 1
     162:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
		ADMUX &= ~(_BV(MUX2));
     166:	3a 98       	cbi	0x07, 2	; 7
		#endif	
	}
     168:	a6 cf       	rjmp	.-180    	; 0xb6 <adc+0x4>

0000016a <ds_1620_write_byte>:


uint16_t ds1620_temp;

void ds_1620_write_byte(uint8_t ds1620_data_var1)
{
     16a:	ef 92       	push	r14
     16c:	ff 92       	push	r15
     16e:	0f 93       	push	r16
     170:	1f 93       	push	r17
     172:	cf 93       	push	r28
     174:	df 93       	push	r29
     176:	00 e0       	ldi	r16, 0x00	; 0
     178:	10 e0       	ldi	r17, 0x00	; 0
	for ( uint8_t ds1620_bit_count = 0; ds1620_bit_count < 8 ; ds1620_bit_count++ )
		{
			vTaskDelay(ds1620_clk_delay);
			ds1620_PORT &= ~_BV(ds1620_clk);
			if ((ds1620_data_var1 & 1<<(ds1620_bit_count)) == 1<<(ds1620_bit_count))
     17a:	ee 24       	eor	r14, r14
     17c:	ff 24       	eor	r15, r15
     17e:	e3 94       	inc	r14
     180:	c8 2f       	mov	r28, r24
     182:	d0 e0       	ldi	r29, 0x00	; 0

void ds_1620_write_byte(uint8_t ds1620_data_var1)
{
	for ( uint8_t ds1620_bit_count = 0; ds1620_bit_count < 8 ; ds1620_bit_count++ )
		{
			vTaskDelay(ds1620_clk_delay);
     184:	85 e0       	ldi	r24, 0x05	; 5
     186:	90 e0       	ldi	r25, 0x00	; 0
     188:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
			ds1620_PORT &= ~_BV(ds1620_clk);
     18c:	ac 98       	cbi	0x15, 4	; 21
			if ((ds1620_data_var1 & 1<<(ds1620_bit_count)) == 1<<(ds1620_bit_count))
     18e:	c7 01       	movw	r24, r14
     190:	00 2e       	mov	r0, r16
     192:	02 c0       	rjmp	.+4      	; 0x198 <ds_1620_write_byte+0x2e>
     194:	88 0f       	add	r24, r24
     196:	99 1f       	adc	r25, r25
     198:	0a 94       	dec	r0
     19a:	e2 f7       	brpl	.-8      	; 0x194 <ds_1620_write_byte+0x2a>
     19c:	9c 01       	movw	r18, r24
     19e:	2c 23       	and	r18, r28
     1a0:	3d 23       	and	r19, r29
     1a2:	82 17       	cp	r24, r18
     1a4:	93 07       	cpc	r25, r19
     1a6:	11 f4       	brne	.+4      	; 0x1ac <ds_1620_write_byte+0x42>
			{
				ds1620_PORT |= _BV(ds1620_data);
     1a8:	ae 9a       	sbi	0x15, 6	; 21
     1aa:	01 c0       	rjmp	.+2      	; 0x1ae <ds_1620_write_byte+0x44>
			}
			else
			{
				ds1620_PORT &= ~_BV(ds1620_data);
     1ac:	ae 98       	cbi	0x15, 6	; 21
			}
			vTaskDelay(ds1620_clk_delay);
     1ae:	85 e0       	ldi	r24, 0x05	; 5
     1b0:	90 e0       	ldi	r25, 0x00	; 0
     1b2:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
			ds1620_PORT |=_BV(ds1620_clk);
     1b6:	ac 9a       	sbi	0x15, 4	; 21
     1b8:	0f 5f       	subi	r16, 0xFF	; 255
     1ba:	1f 4f       	sbci	r17, 0xFF	; 255

uint16_t ds1620_temp;

void ds_1620_write_byte(uint8_t ds1620_data_var1)
{
	for ( uint8_t ds1620_bit_count = 0; ds1620_bit_count < 8 ; ds1620_bit_count++ )
     1bc:	08 30       	cpi	r16, 0x08	; 8
     1be:	11 05       	cpc	r17, r1
     1c0:	09 f7       	brne	.-62     	; 0x184 <ds_1620_write_byte+0x1a>
				ds1620_PORT &= ~_BV(ds1620_data);
			}
			vTaskDelay(ds1620_clk_delay);
			ds1620_PORT |=_BV(ds1620_clk);
		}
}
     1c2:	df 91       	pop	r29
     1c4:	cf 91       	pop	r28
     1c6:	1f 91       	pop	r17
     1c8:	0f 91       	pop	r16
     1ca:	ff 90       	pop	r15
     1cc:	ef 90       	pop	r14
     1ce:	08 95       	ret

000001d0 <ds1620_init>:

void ds1620_init(void)
{
		ds1620_DDR |= _BV(ds1620_clk) | _BV(ds1620_data) | _BV(ds1620_rst);
     1d0:	84 b3       	in	r24, 0x14	; 20
     1d2:	80 6d       	ori	r24, 0xD0	; 208
     1d4:	84 bb       	out	0x14, r24	; 20
		ds1620_PORT &= ~_BV(ds1620_clk);
     1d6:	ac 98       	cbi	0x15, 4	; 21
		ds1620_PORT |= _BV(ds1620_rst);
     1d8:	af 9a       	sbi	0x15, 7	; 21

}
     1da:	08 95       	ret

000001dc <ds1620_read>:
		ds1620_PORT |= _BV(ds1620_rst);
		ds_1620_write_byte(0xAA);
		vTaskDelay(ds1620_clk_delay);
		ds1620_PORT &= ~_BV(ds1620_data);
		ds1620_DDR &= ~_BV(ds1620_data);
		vTaskDelay(ds1620_clk_delay);
     1dc:	ee 24       	eor	r14, r14
     1de:	ff 24       	eor	r15, r15
	uint16_t ds1620_data_bit;
	uint8_t testa = 0;
	for ( ;; )
	{
		//ds1620_PORT &= ~_BV(ds1620_rst2);
		vTaskDelay(ds1620_clk_delay);
     1e0:	85 e0       	ldi	r24, 0x05	; 5
     1e2:	90 e0       	ldi	r25, 0x00	; 0
     1e4:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
		ds1620_DDR |= _BV(ds1620_clk) | _BV(ds1620_data) | _BV(ds1620_rst);
     1e8:	84 b3       	in	r24, 0x14	; 20
     1ea:	80 6d       	ori	r24, 0xD0	; 208
     1ec:	84 bb       	out	0x14, r24	; 20
		ds1620_PORT &= ~_BV(ds1620_clk);
     1ee:	ac 98       	cbi	0x15, 4	; 21
		ds1620_PORT &= ~_BV(ds1620_rst);
     1f0:	af 98       	cbi	0x15, 7	; 21
		vTaskDelay(ds1620_clk_delay);
     1f2:	85 e0       	ldi	r24, 0x05	; 5
     1f4:	90 e0       	ldi	r25, 0x00	; 0
     1f6:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
		ds1620_PORT |= _BV(ds1620_rst);
     1fa:	af 9a       	sbi	0x15, 7	; 21
		vTaskDelay(ds1620_clk_delay);
     1fc:	85 e0       	ldi	r24, 0x05	; 5
     1fe:	90 e0       	ldi	r25, 0x00	; 0
     200:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
				
	//	ds_1620_write_byte(0x0c);
	//	vTaskDelay(20);
	//	ds_1620_write_byte(0x10);
	//	vTaskDelay(100);
		ds_1620_write_byte(0xEE);
     204:	8e ee       	ldi	r24, 0xEE	; 238
     206:	0e 94 b5 00 	call	0x16a	; 0x16a <ds_1620_write_byte>
		vTaskDelay(ds1620_clk_delay);
     20a:	85 e0       	ldi	r24, 0x05	; 5
     20c:	90 e0       	ldi	r25, 0x00	; 0
     20e:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
		ds1620_PORT &= ~_BV(ds1620_rst);
     212:	af 98       	cbi	0x15, 7	; 21
		vTaskDelay(ds1620_clk_delay);	
     214:	85 e0       	ldi	r24, 0x05	; 5
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
		ds1620_PORT |= _BV(ds1620_rst);
     21c:	af 9a       	sbi	0x15, 7	; 21
		ds_1620_write_byte(0xAA);
     21e:	8a ea       	ldi	r24, 0xAA	; 170
     220:	0e 94 b5 00 	call	0x16a	; 0x16a <ds_1620_write_byte>
		vTaskDelay(ds1620_clk_delay);
     224:	85 e0       	ldi	r24, 0x05	; 5
     226:	90 e0       	ldi	r25, 0x00	; 0
     228:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
		ds1620_PORT &= ~_BV(ds1620_data);
     22c:	ae 98       	cbi	0x15, 6	; 21
		ds1620_DDR &= ~_BV(ds1620_data);
     22e:	a6 98       	cbi	0x14, 6	; 20
		vTaskDelay(ds1620_clk_delay);
     230:	85 e0       	ldi	r24, 0x05	; 5
     232:	90 e0       	ldi	r25, 0x00	; 0
     234:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
     238:	e7 01       	movw	r28, r14
		ds1620_data_var = 0;
     23a:	87 01       	movw	r16, r14
		testa = 0;
		for ( ds1620_bit_count = 0; ds1620_bit_count < 9 ; ds1620_bit_count++ )
		{
			testa++;
			ds1620_PORT &= ~_BV(ds1620_clk);
     23c:	ac 98       	cbi	0x15, 4	; 21
			vTaskDelay(ds1620_clk_delay);
     23e:	85 e0       	ldi	r24, 0x05	; 5
     240:	90 e0       	ldi	r25, 0x00	; 0
     242:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
			ds1620_data_bit = ds1620_PIN;
     246:	83 b3       	in	r24, 0x13	; 19
     248:	90 e0       	ldi	r25, 0x00	; 0
			ds1620_data_bit &= _BV(ds1620_data);
     24a:	80 74       	andi	r24, 0x40	; 64
     24c:	90 70       	andi	r25, 0x00	; 0
			ds1620_data_bit >>= ds1620_data;
     24e:	00 24       	eor	r0, r0
     250:	88 0f       	add	r24, r24
     252:	99 1f       	adc	r25, r25
     254:	00 1c       	adc	r0, r0
     256:	88 0f       	add	r24, r24
     258:	99 1f       	adc	r25, r25
     25a:	00 1c       	adc	r0, r0
     25c:	89 2f       	mov	r24, r25
     25e:	90 2d       	mov	r25, r0
			ds1620_data_bit <<= ds1620_bit_count;
     260:	0c 2e       	mov	r0, r28
     262:	02 c0       	rjmp	.+4      	; 0x268 <ds1620_read+0x8c>
     264:	88 0f       	add	r24, r24
     266:	99 1f       	adc	r25, r25
     268:	0a 94       	dec	r0
     26a:	e2 f7       	brpl	.-8      	; 0x264 <ds1620_read+0x88>
			ds1620_data_var |= ds1620_data_bit;
     26c:	08 2b       	or	r16, r24
     26e:	19 2b       	or	r17, r25
			ds1620_PORT |=_BV(ds1620_clk);
     270:	ac 9a       	sbi	0x15, 4	; 21
			vTaskDelay(ds1620_clk_delay);	
     272:	85 e0       	ldi	r24, 0x05	; 5
     274:	90 e0       	ldi	r25, 0x00	; 0
     276:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
     27a:	21 96       	adiw	r28, 0x01	; 1
		ds1620_PORT &= ~_BV(ds1620_data);
		ds1620_DDR &= ~_BV(ds1620_data);
		vTaskDelay(ds1620_clk_delay);
		ds1620_data_var = 0;
		testa = 0;
		for ( ds1620_bit_count = 0; ds1620_bit_count < 9 ; ds1620_bit_count++ )
     27c:	c9 30       	cpi	r28, 0x09	; 9
     27e:	d1 05       	cpc	r29, r1
     280:	e9 f6       	brne	.-70     	; 0x23c <ds1620_read+0x60>
			ds1620_data_var |= ds1620_data_bit;
			ds1620_PORT |=_BV(ds1620_clk);
			vTaskDelay(ds1620_clk_delay);	
		}
		
		ds1620_temp = ds1620_data_var;
     282:	10 93 51 07 	sts	0x0751, r17
     286:	00 93 50 07 	sts	0x0750, r16
	}	
     28a:	aa cf       	rjmp	.-172    	; 0x1e0 <ds1620_read+0x4>

0000028c <lcd_delay>:
#include "spi.h"

uint8_t lcd_display_mode;

static void lcd_delay(void)
{
     28c:	88 ec       	ldi	r24, 0xC8	; 200
	uint8_t i;
	for ( i = 0 ; i < LCD_SHORT_DELAY_50us ; i++ )
	{
		asm volatile("nop\n\t");
     28e:	00 00       	nop
		asm volatile("nop\n\t");
     290:	00 00       	nop
     292:	81 50       	subi	r24, 0x01	; 1
uint8_t lcd_display_mode;

static void lcd_delay(void)
{
	uint8_t i;
	for ( i = 0 ; i < LCD_SHORT_DELAY_50us ; i++ )
     294:	e1 f7       	brne	.-8      	; 0x28e <lcd_delay+0x2>
	{
		asm volatile("nop\n\t");
		asm volatile("nop\n\t");
	}		 
}
     296:	08 95       	ret

00000298 <lcd_putc>:
static void lcd_putc(uint8_t lcd_bts)
{
     298:	cf 93       	push	r28
     29a:	c8 2f       	mov	r28, r24
	uint8_t temp;
	temp = lcd_bts >> 4;
	temp &= 0x0F;
	temp = temp << LCD_DATA_NIB;
	LCD_PORT &= ~(_BV(LCD_DATA0_PIN) | _BV (LCD_DATA1_PIN) | _BV (LCD_DATA2_PIN) | _BV (LCD_DATA3_PIN));
     29c:	82 b3       	in	r24, 0x12	; 18
     29e:	80 7f       	andi	r24, 0xF0	; 240
     2a0:	82 bb       	out	0x12, r24	; 18
	LCD_PORT |= temp;
     2a2:	82 b3       	in	r24, 0x12	; 18
}
static void lcd_putc(uint8_t lcd_bts)
{
	uint8_t temp;
	temp = lcd_bts >> 4;
	temp &= 0x0F;
     2a4:	9c 2f       	mov	r25, r28
     2a6:	92 95       	swap	r25
     2a8:	9f 70       	andi	r25, 0x0F	; 15
	temp = temp << LCD_DATA_NIB;
	LCD_PORT &= ~(_BV(LCD_DATA0_PIN) | _BV (LCD_DATA1_PIN) | _BV (LCD_DATA2_PIN) | _BV (LCD_DATA3_PIN));
	LCD_PORT |= temp;
     2aa:	89 2b       	or	r24, r25
     2ac:	82 bb       	out	0x12, r24	; 18
	lcd_delay();
     2ae:	0e 94 46 01 	call	0x28c	; 0x28c <lcd_delay>
	LCD_PORT &= ~_BV(LCD_E_PIN);
     2b2:	94 98       	cbi	0x12, 4	; 18
	lcd_delay();
     2b4:	0e 94 46 01 	call	0x28c	; 0x28c <lcd_delay>
	LCD_PORT |= _BV(LCD_E_PIN);
     2b8:	94 9a       	sbi	0x12, 4	; 18

	temp = lcd_bts;
	temp &= 0x0F;
	temp = temp << LCD_DATA_NIB;
	LCD_PORT &= ~(_BV(LCD_DATA0_PIN) | _BV (LCD_DATA1_PIN) | _BV (LCD_DATA2_PIN) | _BV (LCD_DATA3_PIN));
     2ba:	82 b3       	in	r24, 0x12	; 18
     2bc:	80 7f       	andi	r24, 0xF0	; 240
     2be:	82 bb       	out	0x12, r24	; 18
	LCD_PORT |= temp;
     2c0:	82 b3       	in	r24, 0x12	; 18
	LCD_PORT &= ~_BV(LCD_E_PIN);
	lcd_delay();
	LCD_PORT |= _BV(LCD_E_PIN);

	temp = lcd_bts;
	temp &= 0x0F;
     2c2:	cf 70       	andi	r28, 0x0F	; 15
	temp = temp << LCD_DATA_NIB;
	LCD_PORT &= ~(_BV(LCD_DATA0_PIN) | _BV (LCD_DATA1_PIN) | _BV (LCD_DATA2_PIN) | _BV (LCD_DATA3_PIN));
	LCD_PORT |= temp;
     2c4:	c8 2b       	or	r28, r24
     2c6:	c2 bb       	out	0x12, r28	; 18
	lcd_delay();
     2c8:	0e 94 46 01 	call	0x28c	; 0x28c <lcd_delay>
	LCD_PORT &= ~_BV(LCD_E_PIN);
     2cc:	94 98       	cbi	0x12, 4	; 18
	lcd_delay();
     2ce:	0e 94 46 01 	call	0x28c	; 0x28c <lcd_delay>
	LCD_PORT |= _BV(LCD_E_PIN);
     2d2:	94 9a       	sbi	0x12, 4	; 18
	
}
     2d4:	cf 91       	pop	r28
     2d6:	08 95       	ret

000002d8 <lcd_display_stepper_pos>:
	lcd_display_stepper_pos(SPI_DATA_MISO[SPI_STEPPER_DISPLAY],SPI_DATA_MISO[SPI_ADC_VALUE1],SPI_DATA_MISO[SPI_stove_target_temp]);
}


void lcd_display_stepper_pos(uint8_t pos_count,uint8_t current_temp,uint8_t target_temp)
{
     2d8:	ff 92       	push	r15
     2da:	0f 93       	push	r16
     2dc:	1f 93       	push	r17
     2de:	cf 93       	push	r28
     2e0:	df 93       	push	r29
     2e2:	c8 2f       	mov	r28, r24
     2e4:	f6 2e       	mov	r15, r22
     2e6:	04 2f       	mov	r16, r20
	lcd_putc('O');
     2e8:	8f e4       	ldi	r24, 0x4F	; 79
     2ea:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
	SPI_DATA_MOSI[SPI_STEPPER_DISPLAY]=pos_count;
     2ee:	c0 93 83 07 	sts	0x0783, r28
	for (uint8_t i; i<5; i++)
     2f2:	10 e0       	ldi	r17, 0x00	; 0
	{
		if (i==pos_count)
     2f4:	1c 17       	cp	r17, r28
     2f6:	39 f4       	brne	.+14     	; 0x306 <lcd_display_stepper_pos+0x2e>
		{
			lcd_display_stepper_dir(current_temp,target_temp);
     2f8:	8f 2d       	mov	r24, r15
     2fa:	90 e0       	ldi	r25, 0x00	; 0
     2fc:	60 2f       	mov	r22, r16
     2fe:	70 e0       	ldi	r23, 0x00	; 0
     300:	0e 94 aa 01 	call	0x354	; 0x354 <lcd_display_stepper_dir>
     304:	03 c0       	rjmp	.+6      	; 0x30c <lcd_display_stepper_pos+0x34>
		}
		else
		{
			lcd_putc('-');
     306:	8d e2       	ldi	r24, 0x2D	; 45
     308:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>

void lcd_display_stepper_pos(uint8_t pos_count,uint8_t current_temp,uint8_t target_temp)
{
	lcd_putc('O');
	SPI_DATA_MOSI[SPI_STEPPER_DISPLAY]=pos_count;
	for (uint8_t i; i<5; i++)
     30c:	1f 5f       	subi	r17, 0xFF	; 255
     30e:	15 30       	cpi	r17, 0x05	; 5
     310:	89 f7       	brne	.-30     	; 0x2f4 <lcd_display_stepper_pos+0x1c>
		{
			lcd_putc('-');
		}
	}

	lcd_putc('+');
     312:	8b e2       	ldi	r24, 0x2B	; 43
     314:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>

	for (uint8_t i; i<12; i++)
     318:	10 e0       	ldi	r17, 0x00	; 0
	{
		if (i==(pos_count-6))
     31a:	d0 e0       	ldi	r29, 0x00	; 0
     31c:	26 97       	sbiw	r28, 0x06	; 6
     31e:	81 2f       	mov	r24, r17
     320:	90 e0       	ldi	r25, 0x00	; 0
     322:	8c 17       	cp	r24, r28
     324:	9d 07       	cpc	r25, r29
     326:	39 f4       	brne	.+14     	; 0x336 <lcd_display_stepper_pos+0x5e>
		{
			lcd_display_stepper_dir(current_temp,target_temp);
     328:	8f 2d       	mov	r24, r15
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	60 2f       	mov	r22, r16
     32e:	70 e0       	ldi	r23, 0x00	; 0
     330:	0e 94 aa 01 	call	0x354	; 0x354 <lcd_display_stepper_dir>
     334:	03 c0       	rjmp	.+6      	; 0x33c <lcd_display_stepper_pos+0x64>
		}
		else
		{
			lcd_putc('-');
     336:	8d e2       	ldi	r24, 0x2D	; 45
     338:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		}
	}

	lcd_putc('+');

	for (uint8_t i; i<12; i++)
     33c:	1f 5f       	subi	r17, 0xFF	; 255
     33e:	1c 30       	cpi	r17, 0x0C	; 12
     340:	71 f7       	brne	.-36     	; 0x31e <lcd_display_stepper_pos+0x46>
		else
		{
			lcd_putc('-');
		}
	}
	lcd_putc('C');
     342:	83 e4       	ldi	r24, 0x43	; 67
     344:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
}
     348:	df 91       	pop	r29
     34a:	cf 91       	pop	r28
     34c:	1f 91       	pop	r17
     34e:	0f 91       	pop	r16
     350:	ff 90       	pop	r15
     352:	08 95       	ret

00000354 <lcd_display_stepper_dir>:

void lcd_display_stepper_dir(uint8_t current_temp, uint8_t target_temp)
{
	if (current_temp == target_temp)
     354:	86 17       	cp	r24, r22
     356:	21 f4       	brne	.+8      	; 0x360 <lcd_display_stepper_dir+0xc>
	{
		lcd_putc('=');
     358:	8d e3       	ldi	r24, 0x3D	; 61
     35a:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
     35e:	08 95       	ret
	}
	else
	{
		if (current_temp < target_temp)
     360:	86 17       	cp	r24, r22
     362:	20 f4       	brcc	.+8      	; 0x36c <lcd_display_stepper_dir+0x18>
		{
			lcd_putc(0x7f);
     364:	8f e7       	ldi	r24, 0x7F	; 127
     366:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
     36a:	08 95       	ret
		}
		else
		{
			lcd_putc(0x7e);	
     36c:	8e e7       	ldi	r24, 0x7E	; 126
     36e:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
     372:	08 95       	ret

00000374 <lcd_display_stove_mode>:
		}
	}
}

void lcd_display_stove_mode(uint8_t stove_mode_var)
{
     374:	cf 93       	push	r28
     376:	c8 2f       	mov	r28, r24
	switch ((stove_mode_var & 0x03))
     378:	90 e0       	ldi	r25, 0x00	; 0
     37a:	83 70       	andi	r24, 0x03	; 3
     37c:	90 70       	andi	r25, 0x00	; 0
     37e:	81 30       	cpi	r24, 0x01	; 1
     380:	91 05       	cpc	r25, r1
     382:	a9 f0       	breq	.+42     	; 0x3ae <lcd_display_stove_mode+0x3a>
     384:	82 30       	cpi	r24, 0x02	; 2
     386:	91 05       	cpc	r25, r1
     388:	11 f1       	breq	.+68     	; 0x3ce <lcd_display_stove_mode+0x5a>
     38a:	00 97       	sbiw	r24, 0x00	; 0
     38c:	81 f5       	brne	.+96     	; 0x3ee <lcd_display_stove_mode+0x7a>
	{
		case MODE_NORM:
		lcd_putc('N');
     38e:	8e e4       	ldi	r24, 0x4E	; 78
     390:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('O');
     394:	8f e4       	ldi	r24, 0x4F	; 79
     396:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('R');
     39a:	82 e5       	ldi	r24, 0x52	; 82
     39c:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('M');
     3a0:	8d e4       	ldi	r24, 0x4D	; 77
     3a2:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc(' ');
     3a6:	80 e2       	ldi	r24, 0x20	; 32
     3a8:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		break;
     3ac:	2f c0       	rjmp	.+94     	; 0x40c <lcd_display_stove_mode+0x98>
		case MODE_NITE:
		lcd_putc('N');
     3ae:	8e e4       	ldi	r24, 0x4E	; 78
     3b0:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('I');
     3b4:	89 e4       	ldi	r24, 0x49	; 73
     3b6:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('T');
     3ba:	84 e5       	ldi	r24, 0x54	; 84
     3bc:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('E');
     3c0:	85 e4       	ldi	r24, 0x45	; 69
     3c2:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc(' ');
     3c6:	80 e2       	ldi	r24, 0x20	; 32
     3c8:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		break;
     3cc:	1f c0       	rjmp	.+62     	; 0x40c <lcd_display_stove_mode+0x98>
		case MODE_FEED:
		lcd_putc('F');
     3ce:	86 e4       	ldi	r24, 0x46	; 70
     3d0:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('E');
     3d4:	85 e4       	ldi	r24, 0x45	; 69
     3d6:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('E');
     3da:	85 e4       	ldi	r24, 0x45	; 69
     3dc:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('D');
     3e0:	84 e4       	ldi	r24, 0x44	; 68
     3e2:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc(' ');
     3e6:	80 e2       	ldi	r24, 0x20	; 32
     3e8:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		break;
     3ec:	0f c0       	rjmp	.+30     	; 0x40c <lcd_display_stove_mode+0x98>
		default:
		lcd_putc('N');
     3ee:	8e e4       	ldi	r24, 0x4E	; 78
     3f0:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('O');
     3f4:	8f e4       	ldi	r24, 0x4F	; 79
     3f6:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc(' ');
     3fa:	80 e2       	ldi	r24, 0x20	; 32
     3fc:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc(' ');
     400:	80 e2       	ldi	r24, 0x20	; 32
     402:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('C');
     406:	83 e4       	ldi	r24, 0x43	; 67
     408:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		break;

	}
	

	switch (((stove_mode_var & 0xF0)>>4))
     40c:	c2 95       	swap	r28
     40e:	cf 70       	andi	r28, 0x0F	; 15
     410:	8c 2f       	mov	r24, r28
     412:	90 e0       	ldi	r25, 0x00	; 0
     414:	83 30       	cpi	r24, 0x03	; 3
     416:	91 05       	cpc	r25, r1
     418:	29 f1       	breq	.+74     	; 0x464 <lcd_display_stove_mode+0xf0>
     41a:	84 30       	cpi	r24, 0x04	; 4
     41c:	91 05       	cpc	r25, r1
     41e:	3c f4       	brge	.+14     	; 0x42e <lcd_display_stove_mode+0xba>
     420:	81 30       	cpi	r24, 0x01	; 1
     422:	91 05       	cpc	r25, r1
     424:	59 f0       	breq	.+22     	; 0x43c <lcd_display_stove_mode+0xc8>
     426:	82 30       	cpi	r24, 0x02	; 2
     428:	91 05       	cpc	r25, r1
     42a:	d1 f5       	brne	.+116    	; 0x4a0 <lcd_display_stove_mode+0x12c>
     42c:	11 c0       	rjmp	.+34     	; 0x450 <lcd_display_stove_mode+0xdc>
     42e:	84 30       	cpi	r24, 0x04	; 4
     430:	91 05       	cpc	r25, r1
     432:	11 f1       	breq	.+68     	; 0x478 <lcd_display_stove_mode+0x104>
     434:	85 30       	cpi	r24, 0x05	; 5
     436:	91 05       	cpc	r25, r1
     438:	99 f5       	brne	.+102    	; 0x4a0 <lcd_display_stove_mode+0x12c>
     43a:	28 c0       	rjmp	.+80     	; 0x48c <lcd_display_stove_mode+0x118>
	{
		case MODE_SRT:
		lcd_putc('S');
     43c:	83 e5       	ldi	r24, 0x53	; 83
     43e:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('R');
     442:	82 e5       	ldi	r24, 0x52	; 82
     444:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('T');
     448:	84 e5       	ldi	r24, 0x54	; 84
     44a:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		break;
     44e:	31 c0       	rjmp	.+98     	; 0x4b2 <lcd_display_stove_mode+0x13e>
		case MODE_HOT:
		lcd_putc('H');
     450:	88 e4       	ldi	r24, 0x48	; 72
     452:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('O');
     456:	8f e4       	ldi	r24, 0x4F	; 79
     458:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('T');
     45c:	84 e5       	ldi	r24, 0x54	; 84
     45e:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		break;
     462:	27 c0       	rjmp	.+78     	; 0x4b2 <lcd_display_stove_mode+0x13e>
		case MODE_MED:
		lcd_putc('M');
     464:	8d e4       	ldi	r24, 0x4D	; 77
     466:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('E');
     46a:	85 e4       	ldi	r24, 0x45	; 69
     46c:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('D');
     470:	84 e4       	ldi	r24, 0x44	; 68
     472:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		break;
     476:	1d c0       	rjmp	.+58     	; 0x4b2 <lcd_display_stove_mode+0x13e>
		case MODE_LOW:
		lcd_putc('L');
     478:	8c e4       	ldi	r24, 0x4C	; 76
     47a:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('O');
     47e:	8f e4       	ldi	r24, 0x4F	; 79
     480:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('W');
     484:	87 e5       	ldi	r24, 0x57	; 87
     486:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		break;
     48a:	13 c0       	rjmp	.+38     	; 0x4b2 <lcd_display_stove_mode+0x13e>
		case MODE_OFF:
		lcd_putc('O');
     48c:	8f e4       	ldi	r24, 0x4F	; 79
     48e:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('F');
     492:	86 e4       	ldi	r24, 0x46	; 70
     494:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('F');
     498:	86 e4       	ldi	r24, 0x46	; 70
     49a:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		break;
     49e:	09 c0       	rjmp	.+18     	; 0x4b2 <lcd_display_stove_mode+0x13e>
		default:
		lcd_putc('O');
     4a0:	8f e4       	ldi	r24, 0x4F	; 79
     4a2:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('M');
     4a6:	8d e4       	ldi	r24, 0x4D	; 77
     4a8:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc('M');
     4ac:	8d e4       	ldi	r24, 0x4D	; 77
     4ae:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		break;
	}		
}
     4b2:	cf 91       	pop	r28
     4b4:	08 95       	ret

000004b6 <lcd_putv>:
	LCD_PORT |= _BV(LCD_E_PIN);
	
}
char data[10];
void lcd_putv(uint16_t lcd_varible, uint8_t lcd_numtype, uint8_t lcd_digits )
{
     4b6:	0f 93       	push	r16
     4b8:	1f 93       	push	r17
     4ba:	cf 93       	push	r28
     4bc:	26 2f       	mov	r18, r22
     4be:	04 2f       	mov	r16, r20
			uint8_t x=lcd_digits;
			
			itoa(lcd_varible, data,lcd_numtype);
     4c0:	62 e5       	ldi	r22, 0x52	; 82
     4c2:	77 e0       	ldi	r23, 0x07	; 7
     4c4:	42 2f       	mov	r20, r18
     4c6:	50 e0       	ldi	r21, 0x00	; 0
     4c8:	0e 94 4f 17 	call	0x2e9e	; 0x2e9e <itoa>
			for (uint8_t i=0; data[i] != 0x00 ; i++)
     4cc:	80 91 52 07 	lds	r24, 0x0752
     4d0:	88 23       	and	r24, r24
     4d2:	79 f0       	breq	.+30     	; 0x4f2 <lcd_putv+0x3c>
     4d4:	c0 2f       	mov	r28, r16
     4d6:	20 e0       	ldi	r18, 0x00	; 0
     4d8:	82 e5       	ldi	r24, 0x52	; 82
     4da:	97 e0       	ldi	r25, 0x07	; 7
			{
					lcd_digits--;
     4dc:	c1 50       	subi	r28, 0x01	; 1
void lcd_putv(uint16_t lcd_varible, uint8_t lcd_numtype, uint8_t lcd_digits )
{
			uint8_t x=lcd_digits;
			
			itoa(lcd_varible, data,lcd_numtype);
			for (uint8_t i=0; data[i] != 0x00 ; i++)
     4de:	2f 5f       	subi	r18, 0xFF	; 255
     4e0:	fc 01       	movw	r30, r24
     4e2:	e2 0f       	add	r30, r18
     4e4:	f1 1d       	adc	r31, r1
     4e6:	30 81       	ld	r19, Z
     4e8:	33 23       	and	r19, r19
     4ea:	c1 f7       	brne	.-16     	; 0x4dc <lcd_putv+0x26>
			{
					lcd_digits--;
			}
			
			if (lcd_digits > x)
     4ec:	0c 17       	cp	r16, r28
     4ee:	e0 f0       	brcs	.+56     	; 0x528 <lcd_putv+0x72>
     4f0:	01 c0       	rjmp	.+2      	; 0x4f4 <lcd_putv+0x3e>
void lcd_putv(uint16_t lcd_varible, uint8_t lcd_numtype, uint8_t lcd_digits )
{
			uint8_t x=lcd_digits;
			
			itoa(lcd_varible, data,lcd_numtype);
			for (uint8_t i=0; data[i] != 0x00 ; i++)
     4f2:	c0 2f       	mov	r28, r16
			if (lcd_digits > x)
			{
				lcd_digits=0;
			}
						
			for (uint8_t i=0; i<lcd_digits; i++)
     4f4:	cc 23       	and	r28, r28
     4f6:	39 f0       	breq	.+14     	; 0x506 <lcd_putv+0x50>
     4f8:	00 e0       	ldi	r16, 0x00	; 0
			{
				lcd_putc(' ');
     4fa:	80 e2       	ldi	r24, 0x20	; 32
     4fc:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
			if (lcd_digits > x)
			{
				lcd_digits=0;
			}
						
			for (uint8_t i=0; i<lcd_digits; i++)
     500:	0f 5f       	subi	r16, 0xFF	; 255
     502:	0c 17       	cp	r16, r28
     504:	d1 f7       	brne	.-12     	; 0x4fa <lcd_putv+0x44>
			{
				lcd_putc(' ');
			}			
			for (uint8_t i=0; data[i] != 0x00; i++)
     506:	80 91 52 07 	lds	r24, 0x0752
     50a:	88 23       	and	r24, r24
     50c:	89 f0       	breq	.+34     	; 0x530 <lcd_putv+0x7a>
     50e:	c0 e0       	ldi	r28, 0x00	; 0
     510:	02 e5       	ldi	r16, 0x52	; 82
     512:	17 e0       	ldi	r17, 0x07	; 7
			{
				lcd_putc(data[i]);
     514:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
						
			for (uint8_t i=0; i<lcd_digits; i++)
			{
				lcd_putc(' ');
			}			
			for (uint8_t i=0; data[i] != 0x00; i++)
     518:	cf 5f       	subi	r28, 0xFF	; 255
     51a:	f8 01       	movw	r30, r16
     51c:	ec 0f       	add	r30, r28
     51e:	f1 1d       	adc	r31, r1
     520:	80 81       	ld	r24, Z
     522:	88 23       	and	r24, r24
     524:	b9 f7       	brne	.-18     	; 0x514 <lcd_putv+0x5e>
     526:	04 c0       	rjmp	.+8      	; 0x530 <lcd_putv+0x7a>
     528:	80 91 52 07 	lds	r24, 0x0752
     52c:	c0 e0       	ldi	r28, 0x00	; 0
     52e:	f0 cf       	rjmp	.-32     	; 0x510 <lcd_putv+0x5a>
			{
				lcd_putc(data[i]);
			}

}
     530:	cf 91       	pop	r28
     532:	1f 91       	pop	r17
     534:	0f 91       	pop	r16
     536:	08 95       	ret

00000538 <lcd_display_diag>:
		break;
	}		
}

void lcd_display_diag(void)
{
     538:	0f 93       	push	r16
     53a:	1f 93       	push	r17
     53c:	cf 93       	push	r28
     53e:	df 93       	push	r29
		lcd_putv(stove_mode_room_temp_target_var,16,2);
     540:	80 91 a6 07 	lds	r24, 0x07A6
     544:	90 e0       	ldi	r25, 0x00	; 0
     546:	60 e1       	ldi	r22, 0x10	; 16
     548:	42 e0       	ldi	r20, 0x02	; 2
     54a:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
		lcd_putv((ds1620_temp/2),16,2);
     54e:	80 91 50 07 	lds	r24, 0x0750
     552:	90 91 51 07 	lds	r25, 0x0751
     556:	96 95       	lsr	r25
     558:	87 95       	ror	r24
     55a:	60 e1       	ldi	r22, 0x10	; 16
     55c:	42 e0       	ldi	r20, 0x02	; 2
     55e:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
		lcd_putv(stove_mode,16,2);
     562:	80 91 9f 07 	lds	r24, 0x079F
     566:	90 e0       	ldi	r25, 0x00	; 0
     568:	60 e1       	ldi	r22, 0x10	; 16
     56a:	42 e0       	ldi	r20, 0x02	; 2
     56c:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
		lcd_putv(ADC_VALUE1,16,2);
     570:	80 91 0e 07 	lds	r24, 0x070E
     574:	90 e0       	ldi	r25, 0x00	; 0
     576:	60 e1       	ldi	r22, 0x10	; 16
     578:	42 e0       	ldi	r20, 0x02	; 2
     57a:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
		lcd_putv(ADC_VALUE2,16,2);
     57e:	80 91 0f 07 	lds	r24, 0x070F
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	60 e1       	ldi	r22, 0x10	; 16
     586:	42 e0       	ldi	r20, 0x02	; 2
     588:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
		lcd_putv(ADC_VALUE3,16,2);
     58c:	80 91 0d 07 	lds	r24, 0x070D
     590:	90 e0       	ldi	r25, 0x00	; 0
     592:	60 e1       	ldi	r22, 0x10	; 16
     594:	42 e0       	ldi	r20, 0x02	; 2
     596:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
		lcd_putv(STEPPER_POS,16,4);
     59a:	80 91 8c 07 	lds	r24, 0x078C
     59e:	90 91 8d 07 	lds	r25, 0x078D
     5a2:	60 e1       	ldi	r22, 0x10	; 16
     5a4:	44 e0       	ldi	r20, 0x04	; 4
     5a6:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
		lcd_putv(STEPPER_POS_CURRENT,16,4);
     5aa:	80 91 88 07 	lds	r24, 0x0788
     5ae:	90 91 89 07 	lds	r25, 0x0789
     5b2:	60 e1       	ldi	r22, 0x10	; 16
     5b4:	44 e0       	ldi	r20, 0x04	; 4
     5b6:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
		lcd_putv(stove_target_temp,16,2);
     5ba:	80 91 a8 07 	lds	r24, 0x07A8
     5be:	90 e0       	ldi	r25, 0x00	; 0
     5c0:	60 e1       	ldi	r22, 0x10	; 16
     5c2:	42 e0       	ldi	r20, 0x02	; 2
     5c4:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
		lcd_putv(stove_target_temp_lockout,16,2);
     5c8:	80 91 96 07 	lds	r24, 0x0796
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	60 e1       	ldi	r22, 0x10	; 16
     5d0:	42 e0       	ldi	r20, 0x02	; 2
     5d2:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
		lcd_putv(stove_run_change_count,16,4);
     5d6:	80 91 94 07 	lds	r24, 0x0794
     5da:	90 91 95 07 	lds	r25, 0x0795
     5de:	60 e1       	ldi	r22, 0x10	; 16
     5e0:	44 e0       	ldi	r20, 0x04	; 4
     5e2:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
		lcd_putv(stove_cooldown_count,16,4);
     5e6:	80 91 90 07 	lds	r24, 0x0790
     5ea:	90 91 91 07 	lds	r25, 0x0791
     5ee:	60 e1       	ldi	r22, 0x10	; 16
     5f0:	44 e0       	ldi	r20, 0x04	; 4
     5f2:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
		lcd_putc(' ');
     5f6:	80 e2       	ldi	r24, 0x20	; 32
     5f8:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc(' ');
     5fc:	80 e2       	ldi	r24, 0x20	; 32
     5fe:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc(' ');
     602:	80 e2       	ldi	r24, 0x20	; 32
     604:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc(' ');
     608:	80 e2       	ldi	r24, 0x20	; 32
     60a:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc(' ');
     60e:	80 e2       	ldi	r24, 0x20	; 32
     610:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc(' ');
     614:	80 e2       	ldi	r24, 0x20	; 32
     616:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc(' ');
     61a:	80 e2       	ldi	r24, 0x20	; 32
     61c:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		lcd_putc(' ');
     620:	80 e2       	ldi	r24, 0x20	; 32
     622:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
     626:	c4 e6       	ldi	r28, 0x64	; 100
     628:	d7 e0       	ldi	r29, 0x07	; 7
		lcd_putc('M');
		break;
	}		
}

void lcd_display_diag(void)
     62a:	8e 01       	movw	r16, r28
     62c:	00 5f       	subi	r16, 0xF0	; 240
     62e:	1f 4f       	sbci	r17, 0xFF	; 255
		lcd_putc(' ');
		lcd_putc(' ');
		lcd_putc(' ');
		for (uint8_t i=0;i<16;i++)
		{
			lcd_putv(SPI_DATA_MISO[i],16,2);
     630:	89 91       	ld	r24, Y+
     632:	90 e0       	ldi	r25, 0x00	; 0
     634:	60 e1       	ldi	r22, 0x10	; 16
     636:	42 e0       	ldi	r20, 0x02	; 2
     638:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
		lcd_putc(' ');
		lcd_putc(' ');
		lcd_putc(' ');
		lcd_putc(' ');
		lcd_putc(' ');
		for (uint8_t i=0;i<16;i++)
     63c:	c0 17       	cp	r28, r16
     63e:	d1 07       	cpc	r29, r17
     640:	b9 f7       	brne	.-18     	; 0x630 <lcd_display_diag+0xf8>
		{
			lcd_putv(SPI_DATA_MISO[i],16,2);
		}

		lcd_putv(SPI_DATA_MISO[SPI_STOVE_MODE],16,2);
     642:	80 91 68 07 	lds	r24, 0x0768
     646:	90 e0       	ldi	r25, 0x00	; 0
     648:	60 e1       	ldi	r22, 0x10	; 16
     64a:	42 e0       	ldi	r20, 0x02	; 2
     64c:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
		lcd_putv(stove_mode,16,2);
     650:	80 91 9f 07 	lds	r24, 0x079F
     654:	90 e0       	ldi	r25, 0x00	; 0
     656:	60 e1       	ldi	r22, 0x10	; 16
     658:	42 e0       	ldi	r20, 0x02	; 2
     65a:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
		lcd_putv(SPI_DATA_MISO[SPI_LOOPBACK],16,2);	
     65e:	80 91 65 07 	lds	r24, 0x0765
     662:	90 e0       	ldi	r25, 0x00	; 0
     664:	60 e1       	ldi	r22, 0x10	; 16
     666:	42 e0       	ldi	r20, 0x02	; 2
     668:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
     66c:	df 91       	pop	r29
     66e:	cf 91       	pop	r28
     670:	1f 91       	pop	r17
     672:	0f 91       	pop	r16
     674:	08 95       	ret

00000676 <lcd_display_normal>:
	}
}


void lcd_display_normal(void)
{
     676:	0f 93       	push	r16
     678:	1f 93       	push	r17
     67a:	cf 93       	push	r28
     67c:	df 93       	push	r29
	lcd_display_stove_mode(stove_mode);
     67e:	ca eb       	ldi	r28, 0xBA	; 186
     680:	d1 e0       	ldi	r29, 0x01	; 1
     682:	80 91 9f 07 	lds	r24, 0x079F
     686:	90 e0       	ldi	r25, 0x00	; 0
     688:	fe 01       	movw	r30, r28
     68a:	09 95       	icall
	lcd_putc(' ');
     68c:	80 e2       	ldi	r24, 0x20	; 32
     68e:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
	lcd_putv((ADC_VALUE1*4),10,4);
     692:	80 91 0e 07 	lds	r24, 0x070E
     696:	90 e0       	ldi	r25, 0x00	; 0
     698:	88 0f       	add	r24, r24
     69a:	99 1f       	adc	r25, r25
     69c:	88 0f       	add	r24, r24
     69e:	99 1f       	adc	r25, r25
     6a0:	6a e0       	ldi	r22, 0x0A	; 10
     6a2:	44 e0       	ldi	r20, 0x04	; 4
     6a4:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
	lcd_putc(' ');
     6a8:	80 e2       	ldi	r24, 0x20	; 32
     6aa:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
	lcd_putc('R');
     6ae:	82 e5       	ldi	r24, 0x52	; 82
     6b0:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
	lcd_putc(' ');	
     6b4:	80 e2       	ldi	r24, 0x20	; 32
     6b6:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
	lcd_putv((ds1620_temp/2),10,2);
     6ba:	80 91 50 07 	lds	r24, 0x0750
     6be:	90 91 51 07 	lds	r25, 0x0751
     6c2:	96 95       	lsr	r25
     6c4:	87 95       	ror	r24
     6c6:	6a e0       	ldi	r22, 0x0A	; 10
     6c8:	42 e0       	ldi	r20, 0x02	; 2
     6ca:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
	lcd_putc('.');
     6ce:	8e e2       	ldi	r24, 0x2E	; 46
     6d0:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
	if ((ds1620_temp & 0x01) == 1)
     6d4:	80 91 50 07 	lds	r24, 0x0750
     6d8:	80 ff       	sbrs	r24, 0
     6da:	04 c0       	rjmp	.+8      	; 0x6e4 <lcd_display_normal+0x6e>
	{
		lcd_putc('5');
     6dc:	85 e3       	ldi	r24, 0x35	; 53
     6de:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
     6e2:	03 c0       	rjmp	.+6      	; 0x6ea <lcd_display_normal+0x74>
	}
	else
	{
		lcd_putc('0');
     6e4:	80 e3       	ldi	r24, 0x30	; 48
     6e6:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
	}
	lcd_display_stove_mode(SPI_DATA_MISO[SPI_STOVE_MODE]);
     6ea:	80 91 68 07 	lds	r24, 0x0768
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	fe 01       	movw	r30, r28
     6f2:	09 95       	icall
	lcd_putc(' ');
     6f4:	80 e2       	ldi	r24, 0x20	; 32
     6f6:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
	lcd_putv(((SPI_DATA_MISO[SPI_ADC_VALUE1])*4),10,4);
     6fa:	c6 e6       	ldi	r28, 0x66	; 102
     6fc:	d7 e0       	ldi	r29, 0x07	; 7
     6fe:	88 81       	ld	r24, Y
     700:	90 e0       	ldi	r25, 0x00	; 0
     702:	88 0f       	add	r24, r24
     704:	99 1f       	adc	r25, r25
     706:	88 0f       	add	r24, r24
     708:	99 1f       	adc	r25, r25
     70a:	6a e0       	ldi	r22, 0x0A	; 10
     70c:	44 e0       	ldi	r20, 0x04	; 4
     70e:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
	lcd_putc(' ');
     712:	80 e2       	ldi	r24, 0x20	; 32
     714:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
	lcd_putc('T');
     718:	84 e5       	ldi	r24, 0x54	; 84
     71a:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
	lcd_putv(stove_mode_room_temp_target_var,10,3);
     71e:	80 91 a6 07 	lds	r24, 0x07A6
     722:	90 e0       	ldi	r25, 0x00	; 0
     724:	6a e0       	ldi	r22, 0x0A	; 10
     726:	43 e0       	ldi	r20, 0x03	; 3
     728:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <lcd_putv>
	lcd_putc('.');
     72c:	8e e2       	ldi	r24, 0x2E	; 46
     72e:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
	lcd_putc('0');
     732:	80 e3       	ldi	r24, 0x30	; 48
     734:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
	lcd_display_stepper_pos(STEPPER_DISPLAY,ADC_VALUE1,stove_target_temp);
     738:	0c e6       	ldi	r16, 0x6C	; 108
     73a:	11 e0       	ldi	r17, 0x01	; 1
     73c:	60 91 0e 07 	lds	r22, 0x070E
     740:	40 91 a8 07 	lds	r20, 0x07A8
     744:	80 91 8b 07 	lds	r24, 0x078B
     748:	90 e0       	ldi	r25, 0x00	; 0
     74a:	70 e0       	ldi	r23, 0x00	; 0
     74c:	50 e0       	ldi	r21, 0x00	; 0
     74e:	f8 01       	movw	r30, r16
     750:	09 95       	icall
	lcd_display_stepper_pos(SPI_DATA_MISO[SPI_STEPPER_DISPLAY],SPI_DATA_MISO[SPI_ADC_VALUE1],SPI_DATA_MISO[SPI_stove_target_temp]);
     752:	68 81       	ld	r22, Y
     754:	40 91 6d 07 	lds	r20, 0x076D
     758:	80 91 73 07 	lds	r24, 0x0773
     75c:	90 e0       	ldi	r25, 0x00	; 0
     75e:	70 e0       	ldi	r23, 0x00	; 0
     760:	50 e0       	ldi	r21, 0x00	; 0
     762:	f8 01       	movw	r30, r16
     764:	09 95       	icall
}
     766:	df 91       	pop	r29
     768:	cf 91       	pop	r28
     76a:	1f 91       	pop	r17
     76c:	0f 91       	pop	r16
     76e:	08 95       	ret

00000770 <lcd_init>:
				lcd_putc(data[i]);
			}

}
void lcd_init (void)
{
     770:	0f 93       	push	r16
     772:	1f 93       	push	r17
     774:	cf 93       	push	r28
     776:	df 93       	push	r29
     778:	c8 ee       	ldi	r28, 0xE8	; 232
     77a:	d3 e0       	ldi	r29, 0x03	; 3
    for (uint16_t i=0; i < 1000; i++)
	{
		lcd_delay();
     77c:	0e 94 46 01 	call	0x28c	; 0x28c <lcd_delay>
     780:	21 97       	sbiw	r28, 0x01	; 1
			}

}
void lcd_init (void)
{
    for (uint16_t i=0; i < 1000; i++)
     782:	e1 f7       	brne	.-8      	; 0x77c <lcd_init+0xc>
	{
		lcd_delay();
	}
	//vTaskDelay(100);
	LCD_PORT &= ~(_BV(LCD_DATA0_PIN) | _BV (LCD_DATA1_PIN) | _BV (LCD_DATA2_PIN) | _BV (LCD_DATA3_PIN) | _BV (LCD_RS_PIN) | _BV (LCD_E_PIN) | _BV(LCD_LED_PIN));
     784:	82 b3       	in	r24, 0x12	; 18
     786:	80 72       	andi	r24, 0x20	; 32
     788:	82 bb       	out	0x12, r24	; 18
	LCD_DDR  |= (_BV(LCD_DATA0_PIN) | _BV (LCD_DATA1_PIN) | _BV (LCD_DATA2_PIN) | _BV (LCD_DATA3_PIN) | _BV (LCD_RS_PIN) | _BV (LCD_E_PIN) | _BV(LCD_LED_PIN));
     78a:	81 b3       	in	r24, 0x11	; 17
     78c:	8f 6d       	ori	r24, 0xDF	; 223
     78e:	81 bb       	out	0x11, r24	; 17
     790:	c3 e0       	ldi	r28, 0x03	; 3
     792:	d0 e0       	ldi	r29, 0x00	; 0
	{
		LCD_PORT |= _BV(LCD_E_PIN);
		lcd_delay();
		LCD_PORT &= ~LCD_DATA_MASK;
		LCD_PORT |= LCD_FUNC_RESET << LCD_DATA_NIB;
		LCD_PORT &= ~_BV(LCD_E_PIN);
     794:	08 ec       	ldi	r16, 0xC8	; 200
	//vTaskDelay(100);
	LCD_PORT &= ~(_BV(LCD_DATA0_PIN) | _BV (LCD_DATA1_PIN) | _BV (LCD_DATA2_PIN) | _BV (LCD_DATA3_PIN) | _BV (LCD_RS_PIN) | _BV (LCD_E_PIN) | _BV(LCD_LED_PIN));
	LCD_DDR  |= (_BV(LCD_DATA0_PIN) | _BV (LCD_DATA1_PIN) | _BV (LCD_DATA2_PIN) | _BV (LCD_DATA3_PIN) | _BV (LCD_RS_PIN) | _BV (LCD_E_PIN) | _BV(LCD_LED_PIN));
	for (uint16_t i=0 ; i < 3; i++)
	{
		LCD_PORT |= _BV(LCD_E_PIN);
     796:	94 9a       	sbi	0x12, 4	; 18
		lcd_delay();
     798:	0e 94 46 01 	call	0x28c	; 0x28c <lcd_delay>
		LCD_PORT &= ~LCD_DATA_MASK;
     79c:	90 98       	cbi	0x12, 0	; 18
		LCD_PORT |= LCD_FUNC_RESET << LCD_DATA_NIB;
     79e:	82 b3       	in	r24, 0x12	; 18
     7a0:	83 60       	ori	r24, 0x03	; 3
     7a2:	82 bb       	out	0x12, r24	; 18
		LCD_PORT &= ~_BV(LCD_E_PIN);
     7a4:	94 98       	cbi	0x12, 4	; 18
     7a6:	10 2f       	mov	r17, r16
		//vTaskDelay(10);
		for (uint8_t t=0; t < 200; t++)
		{
			lcd_delay();	
     7a8:	0e 94 46 01 	call	0x28c	; 0x28c <lcd_delay>
     7ac:	11 50       	subi	r17, 0x01	; 1
		lcd_delay();
		LCD_PORT &= ~LCD_DATA_MASK;
		LCD_PORT |= LCD_FUNC_RESET << LCD_DATA_NIB;
		LCD_PORT &= ~_BV(LCD_E_PIN);
		//vTaskDelay(10);
		for (uint8_t t=0; t < 200; t++)
     7ae:	e1 f7       	brne	.-8      	; 0x7a8 <lcd_init+0x38>
     7b0:	21 97       	sbiw	r28, 0x01	; 1
		lcd_delay();
	}
	//vTaskDelay(100);
	LCD_PORT &= ~(_BV(LCD_DATA0_PIN) | _BV (LCD_DATA1_PIN) | _BV (LCD_DATA2_PIN) | _BV (LCD_DATA3_PIN) | _BV (LCD_RS_PIN) | _BV (LCD_E_PIN) | _BV(LCD_LED_PIN));
	LCD_DDR  |= (_BV(LCD_DATA0_PIN) | _BV (LCD_DATA1_PIN) | _BV (LCD_DATA2_PIN) | _BV (LCD_DATA3_PIN) | _BV (LCD_RS_PIN) | _BV (LCD_E_PIN) | _BV(LCD_LED_PIN));
	for (uint16_t i=0 ; i < 3; i++)
     7b2:	89 f7       	brne	.-30     	; 0x796 <lcd_init+0x26>
		for (uint8_t t=0; t < 200; t++)
		{
			lcd_delay();	
		}
	}	
	LCD_PORT |= _BV(LCD_E_PIN);
     7b4:	94 9a       	sbi	0x12, 4	; 18
	lcd_delay();
     7b6:	0e 94 46 01 	call	0x28c	; 0x28c <lcd_delay>
	LCD_PORT &= ~LCD_DATA_MASK;
     7ba:	90 98       	cbi	0x12, 0	; 18
	LCD_PORT |= LCD_FUNC_INIT_4bit << LCD_DATA_NIB;
     7bc:	91 9a       	sbi	0x12, 1	; 18
	LCD_PORT &= ~_BV(LCD_E_PIN);
     7be:	94 98       	cbi	0x12, 4	; 18
	lcd_delay();
     7c0:	0e 94 46 01 	call	0x28c	; 0x28c <lcd_delay>
	LCD_PORT |= _BV(LCD_E_PIN);
     7c4:	94 9a       	sbi	0x12, 4	; 18
	lcd_delay();
     7c6:	0e 94 46 01 	call	0x28c	; 0x28c <lcd_delay>
	lcd_putc(LCD_FUNC_INIT);
     7ca:	88 e2       	ldi	r24, 0x28	; 40
     7cc:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
	lcd_putc((LCD_SHOW | LCD_SHOW_ON));
     7d0:	8c e0       	ldi	r24, 0x0C	; 12
     7d2:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
	lcd_putc((LCD_MODE | LCD_MODE_RIGHT));
     7d6:	86 e0       	ldi	r24, 0x06	; 6
     7d8:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
	lcd_putc(LCD_CLR);
     7dc:	81 e0       	ldi	r24, 0x01	; 1
     7de:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>

	
}
     7e2:	df 91       	pop	r29
     7e4:	cf 91       	pop	r28
     7e6:	1f 91       	pop	r17
     7e8:	0f 91       	pop	r16
     7ea:	08 95       	ret

000007ec <lcd_task>:
void lcd_task(void)
{

	for ( ;; )
	{
		SPI_DATA_MOSI[SPI_ds1620_temp]=(ds1620_temp/2);
     7ec:	c6 e7       	ldi	r28, 0x76	; 118
     7ee:	d7 e0       	ldi	r29, 0x07	; 7
		SPI_DATA_MOSI[SPI_stove_mode_target_temp_var]=stove_mode_room_temp_target_var;
     7f0:	8e 01       	movw	r16, r28
     7f2:	0f 5f       	subi	r16, 0xFF	; 255
     7f4:	1f 4f       	sbci	r17, 0xFF	; 255
void lcd_task(void)
{

	for ( ;; )
	{
		SPI_DATA_MOSI[SPI_ds1620_temp]=(ds1620_temp/2);
     7f6:	80 91 50 07 	lds	r24, 0x0750
     7fa:	90 91 51 07 	lds	r25, 0x0751
     7fe:	96 95       	lsr	r25
     800:	87 95       	ror	r24
     802:	88 83       	st	Y, r24
		SPI_DATA_MOSI[SPI_stove_mode_target_temp_var]=stove_mode_room_temp_target_var;
     804:	80 91 a6 07 	lds	r24, 0x07A6
     808:	f8 01       	movw	r30, r16
     80a:	80 83       	st	Z, r24
		if (ADC_VALUE3 > LCD_LIGHT_SENCE)
     80c:	80 91 0d 07 	lds	r24, 0x070D
     810:	81 3c       	cpi	r24, 0xC1	; 193
     812:	10 f0       	brcs	.+4      	; 0x818 <lcd_task+0x2c>
		{
			LCD_PORT |= _BV(LCD_LED_PIN);
     814:	97 9a       	sbi	0x12, 7	; 18
     816:	01 c0       	rjmp	.+2      	; 0x81a <lcd_task+0x2e>
		}
		else
		{
			LCD_PORT &= ~_BV(LCD_LED_PIN);
     818:	97 98       	cbi	0x12, 7	; 18
		}
		LCD_PORT &= ~_BV(LCD_RS_PIN);
     81a:	96 98       	cbi	0x12, 6	; 18
		lcd_putc(LCD_HOME);
     81c:	82 e0       	ldi	r24, 0x02	; 2
     81e:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
		LCD_PORT |= _BV(LCD_RS_PIN);		
     822:	96 9a       	sbi	0x12, 6	; 18
		vTaskDelay(3);
     824:	83 e0       	ldi	r24, 0x03	; 3
     826:	90 e0       	ldi	r25, 0x00	; 0
     828:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
		if ((lcd_display_mode & 0xf0)== 0x10)
     82c:	40 91 5c 07 	lds	r20, 0x075C
     830:	84 2f       	mov	r24, r20
     832:	90 e0       	ldi	r25, 0x00	; 0
     834:	9c 01       	movw	r18, r24
     836:	20 7f       	andi	r18, 0xF0	; 240
     838:	30 70       	andi	r19, 0x00	; 0
     83a:	20 31       	cpi	r18, 0x10	; 16
     83c:	31 05       	cpc	r19, r1
     83e:	59 f4       	brne	.+22     	; 0x856 <lcd_task+0x6a>
		{
			if ((lcd_display_mode & 0x0f)==LCD_MODE_DIAG)
     840:	8f 70       	andi	r24, 0x0F	; 15
     842:	90 70       	andi	r25, 0x00	; 0
     844:	81 30       	cpi	r24, 0x01	; 1
     846:	91 05       	cpc	r25, r1
     848:	19 f4       	brne	.+6      	; 0x850 <lcd_task+0x64>
			{
				lcd_display_diag();
     84a:	0e 94 9c 02 	call	0x538	; 0x538 <lcd_display_diag>
     84e:	d3 cf       	rjmp	.-90     	; 0x7f6 <lcd_task+0xa>
			}
			else
			{		
				lcd_display_normal();
     850:	0e 94 3b 03 	call	0x676	; 0x676 <lcd_display_normal>
     854:	d0 cf       	rjmp	.-96     	; 0x7f6 <lcd_task+0xa>
			}
		}
		else
		{
			lcd_display_mode |= 0x10;
     856:	40 61       	ori	r20, 0x10	; 16
     858:	40 93 5c 07 	sts	0x075C, r20
			LCD_PORT &= ~_BV(LCD_RS_PIN);
     85c:	96 98       	cbi	0x12, 6	; 18
			lcd_putc(LCD_CLR);
     85e:	81 e0       	ldi	r24, 0x01	; 1
     860:	0e 94 4c 01 	call	0x298	; 0x298 <lcd_putc>
			LCD_PORT |= _BV(LCD_RS_PIN);
     864:	96 9a       	sbi	0x12, 6	; 18
     866:	c7 cf       	rjmp	.-114    	; 0x7f6 <lcd_task+0xa>

00000868 <keypad_init>:
uint8_t keypad_multi;
uint8_t menu_key_last;

void keypad_init(void)
{
	KEYPAD_PORT |= (_BV(KEYPAD_PIN0) | _BV(KEYPAD_PIN1) | _BV(KEYPAD_PIN2) | _BV(KEYPAD_PIN3));
     868:	88 b3       	in	r24, 0x18	; 24
     86a:	8f 60       	ori	r24, 0x0F	; 15
     86c:	88 bb       	out	0x18, r24	; 24
	KEYPAD_DDR &= ~(_BV(KEYPAD_PIN0) | _BV(KEYPAD_PIN1) | _BV(KEYPAD_PIN2) | _BV(KEYPAD_PIN3));
     86e:	87 b3       	in	r24, 0x17	; 23
     870:	80 7f       	andi	r24, 0xF0	; 240
     872:	87 bb       	out	0x17, r24	; 23
	keypad_temp=0;
     874:	10 92 61 07 	sts	0x0761, r1
	keypad_count=0;
     878:	10 92 5e 07 	sts	0x075E, r1
     87c:	10 92 5d 07 	sts	0x075D, r1
}
     880:	08 95       	ret

00000882 <keypad>:

void keypad(void)
{
	for(;;)
	{
		if ((~KEYPAD_PIN & KEYPAD_MASK) != 0 )
     882:	86 b3       	in	r24, 0x16	; 22
     884:	90 e0       	ldi	r25, 0x00	; 0
     886:	80 95       	com	r24
     888:	90 95       	com	r25
     88a:	8f 70       	andi	r24, 0x0F	; 15
     88c:	90 70       	andi	r25, 0x00	; 0
     88e:	00 97       	sbiw	r24, 0x00	; 0
     890:	c9 f1       	breq	.+114    	; 0x904 <keypad+0x82>
		{
			if ((~KEYPAD_PIN & KEYPAD_MASK) == keypad_temp)
     892:	26 b3       	in	r18, 0x16	; 22
     894:	40 91 61 07 	lds	r20, 0x0761
     898:	30 e0       	ldi	r19, 0x00	; 0
     89a:	20 95       	com	r18
     89c:	30 95       	com	r19
     89e:	2f 70       	andi	r18, 0x0F	; 15
     8a0:	30 70       	andi	r19, 0x00	; 0
     8a2:	84 2f       	mov	r24, r20
     8a4:	90 e0       	ldi	r25, 0x00	; 0
     8a6:	28 17       	cp	r18, r24
     8a8:	39 07       	cpc	r19, r25
     8aa:	11 f5       	brne	.+68     	; 0x8f0 <keypad+0x6e>
			{
				if (keypad_count>(KEYPAD_DEBOUNCE_COUNT/2))
     8ac:	80 91 5d 07 	lds	r24, 0x075D
     8b0:	90 91 5e 07 	lds	r25, 0x075E
     8b4:	83 33       	cpi	r24, 0x33	; 51
     8b6:	91 05       	cpc	r25, r1
     8b8:	88 f0       	brcs	.+34     	; 0x8dc <keypad+0x5a>
				{
					keypad_out=keypad_temp;
     8ba:	40 93 5f 07 	sts	0x075F, r20
					if (keypad_count> (KEYPAD_AUTO_KEY_COUNT/2))
     8be:	21 e0       	ldi	r18, 0x01	; 1
     8c0:	85 3f       	cpi	r24, 0xF5	; 245
     8c2:	92 07       	cpc	r25, r18
     8c4:	58 f0       	brcs	.+22     	; 0x8dc <keypad+0x5a>
					{
						keypad_out=0;
     8c6:	10 92 5f 07 	sts	0x075F, r1
						keypad_count=0;
     8ca:	10 92 5e 07 	sts	0x075E, r1
     8ce:	10 92 5d 07 	sts	0x075D, r1
						keypad_multi++;
     8d2:	80 91 62 07 	lds	r24, 0x0762
     8d6:	8f 5f       	subi	r24, 0xFF	; 255
     8d8:	80 93 62 07 	sts	0x0762, r24
					}
				}
				keypad_count++;				
     8dc:	80 91 5d 07 	lds	r24, 0x075D
     8e0:	90 91 5e 07 	lds	r25, 0x075E
     8e4:	01 96       	adiw	r24, 0x01	; 1
     8e6:	90 93 5e 07 	sts	0x075E, r25
     8ea:	80 93 5d 07 	sts	0x075D, r24
     8ee:	14 c0       	rjmp	.+40     	; 0x918 <keypad+0x96>
			}
			else
			{
				keypad_temp= ~KEYPAD_PIN & KEYPAD_MASK;
     8f0:	86 b3       	in	r24, 0x16	; 22
     8f2:	80 95       	com	r24
     8f4:	8f 70       	andi	r24, 0x0F	; 15
     8f6:	80 93 61 07 	sts	0x0761, r24
				keypad_count=0;
     8fa:	10 92 5e 07 	sts	0x075E, r1
     8fe:	10 92 5d 07 	sts	0x075D, r1
     902:	0a c0       	rjmp	.+20     	; 0x918 <keypad+0x96>
			}
		}
		else
		{
			keypad_temp=0;
     904:	10 92 61 07 	sts	0x0761, r1
			keypad_multi=0;
     908:	10 92 62 07 	sts	0x0762, r1
			keypad_count=0;
     90c:	10 92 5e 07 	sts	0x075E, r1
     910:	10 92 5d 07 	sts	0x075D, r1
			keypad_out=0;
     914:	10 92 5f 07 	sts	0x075F, r1
		}
		vTaskDelay(2);
     918:	82 e0       	ldi	r24, 0x02	; 2
     91a:	90 e0       	ldi	r25, 0x00	; 0
     91c:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
	}
     920:	b0 cf       	rjmp	.-160    	; 0x882 <keypad>

00000922 <menu_init>:
}
void menu_init(void)
{
	
}
     922:	08 95       	ret

00000924 <menu>:
						{
							lcd_display_mode=LCD_MODE_NORMAL;
						}
						else
						{
							lcd_display_mode=LCD_MODE_DIAG;
     924:	11 e0       	ldi	r17, 0x01	; 1
						SPI_DATA_MOSI[SPI_basement_control] = stove_control_reset_normal;
					}
				}
				else
				{
					SPI_DATA_MOSI[SPI_basement_control] = 0xFF;
     926:	c8 e7       	ldi	r28, 0x78	; 120
     928:	d7 e0       	ldi	r29, 0x07	; 7
     92a:	0f ef       	ldi	r16, 0xFF	; 255
				{
					if (keypad_multi!=0)
					{
						if (keypad_multi>=2)
						{
							SPI_DATA_MOSI[SPI_basement_control] = stove_control_reset_nite;
     92c:	ff 24       	eor	r15, r15
     92e:	68 94       	set
     930:	f1 f8       	bld	r15, 1
}
void menu(void)
{
	for (;;)
	{
		if (keypad_out != 0)
     932:	80 91 5f 07 	lds	r24, 0x075F
     936:	88 23       	and	r24, r24
     938:	09 f4       	brne	.+2      	; 0x93c <menu+0x18>
     93a:	45 c0       	rjmp	.+138    	; 0x9c6 <menu+0xa2>
		{
			if (keypad_out != menu_key_last)
     93c:	90 91 60 07 	lds	r25, 0x0760
     940:	89 17       	cp	r24, r25
     942:	09 f4       	brne	.+2      	; 0x946 <menu+0x22>
     944:	40 c0       	rjmp	.+128    	; 0x9c6 <menu+0xa2>
			{
				if ((keypad_out & (1<<KEYPAD_RST)) == (1<<KEYPAD_RST))
     946:	83 ff       	sbrs	r24, 3
     948:	0d c0       	rjmp	.+26     	; 0x964 <menu+0x40>
				{
					if (keypad_multi!=0)
     94a:	80 91 62 07 	lds	r24, 0x0762
     94e:	88 23       	and	r24, r24
     950:	31 f0       	breq	.+12     	; 0x95e <menu+0x3a>
					{
						if (keypad_multi>=2)
     952:	82 30       	cpi	r24, 0x02	; 2
     954:	38 f0       	brcs	.+14     	; 0x964 <menu+0x40>
						{
							stove_control_reset(stove_control_reset_nite);
     956:	8f 2d       	mov	r24, r15
     958:	0e 94 b6 06 	call	0xd6c	; 0xd6c <stove_control_reset>
     95c:	03 c0       	rjmp	.+6      	; 0x964 <menu+0x40>
						}
					}
					else
					{
						stove_control_reset(stove_control_reset_normal);
     95e:	81 2f       	mov	r24, r17
     960:	0e 94 b6 06 	call	0xd6c	; 0xd6c <stove_control_reset>
					}
				}
				if ((keypad_out & (1<<KEYPAD_RST_BASEMENT)) == (1<<KEYPAD_RST_BASEMENT))
     964:	80 91 5f 07 	lds	r24, 0x075F
     968:	82 ff       	sbrs	r24, 2
     96a:	0a c0       	rjmp	.+20     	; 0x980 <menu+0x5c>
				{
					if (keypad_multi!=0)
     96c:	80 91 62 07 	lds	r24, 0x0762
     970:	88 23       	and	r24, r24
     972:	21 f0       	breq	.+8      	; 0x97c <menu+0x58>
					{
						if (keypad_multi>=2)
     974:	82 30       	cpi	r24, 0x02	; 2
     976:	28 f0       	brcs	.+10     	; 0x982 <menu+0x5e>
						{
							SPI_DATA_MOSI[SPI_basement_control] = stove_control_reset_nite;
     978:	f8 82       	st	Y, r15
     97a:	03 c0       	rjmp	.+6      	; 0x982 <menu+0x5e>
						}
					}
					else
					{
						SPI_DATA_MOSI[SPI_basement_control] = stove_control_reset_normal;
     97c:	18 83       	st	Y, r17
     97e:	01 c0       	rjmp	.+2      	; 0x982 <menu+0x5e>
					}
				}
				else
				{
					SPI_DATA_MOSI[SPI_basement_control] = 0xFF;
     980:	08 83       	st	Y, r16
				}
				if ((keypad_out & ((1<<KEYPAD_UP) | (1<<KEYPAD_DOWN))) == ((1<<KEYPAD_UP) | (1<<KEYPAD_DOWN)))
     982:	80 91 5f 07 	lds	r24, 0x075F
     986:	90 e0       	ldi	r25, 0x00	; 0
     988:	9c 01       	movw	r18, r24
     98a:	23 70       	andi	r18, 0x03	; 3
     98c:	30 70       	andi	r19, 0x00	; 0
     98e:	23 30       	cpi	r18, 0x03	; 3
     990:	31 05       	cpc	r19, r1
     992:	59 f4       	brne	.+22     	; 0x9aa <menu+0x86>
					{
						if ((lcd_display_mode & 0x0f) == LCD_MODE_DIAG)
     994:	80 91 5c 07 	lds	r24, 0x075C
     998:	8f 70       	andi	r24, 0x0F	; 15
     99a:	81 30       	cpi	r24, 0x01	; 1
     99c:	19 f4       	brne	.+6      	; 0x9a4 <menu+0x80>
						{
							lcd_display_mode=LCD_MODE_NORMAL;
     99e:	10 92 5c 07 	sts	0x075C, r1
     9a2:	11 c0       	rjmp	.+34     	; 0x9c6 <menu+0xa2>
						}
						else
						{
							lcd_display_mode=LCD_MODE_DIAG;
     9a4:	10 93 5c 07 	sts	0x075C, r17
     9a8:	0e c0       	rjmp	.+28     	; 0x9c6 <menu+0xa2>
						}
					}
				else
				{
					if ((keypad_out & (1<<KEYPAD_UP)) == (1<<KEYPAD_UP))
     9aa:	80 ff       	sbrs	r24, 0
     9ac:	05 c0       	rjmp	.+10     	; 0x9b8 <menu+0x94>
					{
						stove_mode_room_temp_target_var++;
     9ae:	20 91 a6 07 	lds	r18, 0x07A6
     9b2:	2f 5f       	subi	r18, 0xFF	; 255
     9b4:	20 93 a6 07 	sts	0x07A6, r18
					}
					if ((keypad_out & (1<<KEYPAD_DOWN)) == (1<<KEYPAD_DOWN))
     9b8:	81 ff       	sbrs	r24, 1
     9ba:	05 c0       	rjmp	.+10     	; 0x9c6 <menu+0xa2>
					{
						stove_mode_room_temp_target_var--;
     9bc:	80 91 a6 07 	lds	r24, 0x07A6
     9c0:	81 50       	subi	r24, 0x01	; 1
     9c2:	80 93 a6 07 	sts	0x07A6, r24
					}
				}									
			}
		}				
	menu_key_last=keypad_out;
     9c6:	80 91 5f 07 	lds	r24, 0x075F
     9ca:	80 93 60 07 	sts	0x0760, r24
	vTaskDelay(2);		
     9ce:	82 e0       	ldi	r24, 0x02	; 2
     9d0:	90 e0       	ldi	r25, 0x00	; 0
     9d2:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
	}
     9d6:	ad cf       	rjmp	.-166    	; 0x932 <menu+0xe>

000009d8 <spi_master_init>:
uint8_t SPI_DATA_MOSI[SPI_DATA_BUFFER_SIZE];
uint8_t SPI_DATA_COUNT;

void spi_master_init(void)
{
	SPI_SLAVE_SELECT_PORT |= (_BV(SPI_SLAVE_SELECT_SS));
     9d8:	c4 9a       	sbi	0x18, 4	; 24
	SPI_SLAVE_SELECT_DDR |= _BV(SPI_SLAVE_SELECT_SS);
     9da:	bc 9a       	sbi	0x17, 4	; 23
	/* Set MOSI and SCK output, all others input */
	DDR_SPI = (1<<DD_MOSI)|(1<<DD_SCK);
     9dc:	80 ea       	ldi	r24, 0xA0	; 160
     9de:	87 bb       	out	0x17, r24	; 23
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);
     9e0:	83 e5       	ldi	r24, 0x53	; 83
     9e2:	8d b9       	out	0x0d, r24	; 13
//	PORT_SPI |= (_BV(DD_MISO))  | (_BV(DD_SCK)); //| (_BV(DD_MOSI))
	SPI_SLAVE_SELECT_DDR |= _BV(SPI_SLAVE_SELECT_SS);
     9e4:	bc 9a       	sbi	0x17, 4	; 23

	
	SPI_DATA_MISO[14]=0xac;
     9e6:	8c ea       	ldi	r24, 0xAC	; 172
     9e8:	80 93 72 07 	sts	0x0772, r24
	SPI_DATA_MISO[15]=0xdd;
     9ec:	8d ed       	ldi	r24, 0xDD	; 221
     9ee:	80 93 73 07 	sts	0x0773, r24
//	for (uint8_t i=0;i<16;i++)
//	{
//	SPI_DATA_MOSI[i]=0xbd;
//	}	
	
}
     9f2:	08 95       	ret

000009f4 <spi_slave_init>:

void spi_slave_init(void)
{
	/* Set MISO output, all others input */
	DDR_SPI = (1<<DD_MISO);
     9f4:	80 e4       	ldi	r24, 0x40	; 64
     9f6:	87 bb       	out	0x17, r24	; 23
	/* Enable SPI */
	SPCR = (1<<SPE)| (1<<SPIE);
     9f8:	80 ec       	ldi	r24, 0xC0	; 192
     9fa:	8d b9       	out	0x0d, r24	; 13
//    PORT_SPI |= (_BV(DD_MOSI)) | (_BV(DD_SCK));
}
     9fc:	08 95       	ret

000009fe <spi_master>:
{
	for (;;)
	{
		SPI_SLAVE_SELECT_PORT &= ~(_BV(SPI_SLAVE_SELECT_SS));
		SPI_SLAVE_SELECT_DDR |= _BV(SPI_SLAVE_SELECT_SS);
		SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);
     9fe:	0f 2e       	mov	r0, r31
     a00:	f3 e5       	ldi	r31, 0x53	; 83
     a02:	7f 2e       	mov	r7, r31
     a04:	f0 2d       	mov	r31, r0
		vTaskDelay(SPI_MASTER_DELAY_SHORT);
     a06:	0f 2e       	mov	r0, r31
     a08:	f4 e7       	ldi	r31, 0x74	; 116
     a0a:	af 2e       	mov	r10, r31
     a0c:	f7 e0       	ldi	r31, 0x07	; 7
     a0e:	bf 2e       	mov	r11, r31
     a10:	f0 2d       	mov	r31, r0
	/* Enable SPI */
	SPCR = (1<<SPE)| (1<<SPIE);
//    PORT_SPI |= (_BV(DD_MOSI)) | (_BV(DD_SCK));
}

void spi_master(void)
     a12:	ee 24       	eor	r14, r14
     a14:	ff 24       	eor	r15, r15
     a16:	68 94       	set
     a18:	e4 f8       	bld	r14, 4
     a1a:	ea 0c       	add	r14, r10
     a1c:	fb 1c       	adc	r15, r11
     a1e:	88 24       	eor	r8, r8
     a20:	8a 94       	dec	r8
     a22:	98 2c       	mov	r9, r8
			/* Wait for transmission complete */
			while ((SPSR & (_BV(SPIF))) == 0)
			{
			vTaskDelay(SPI_MASTER_DELAY_SHORT);
			}				
			SPI_DATA_MISO[((i-1) & SPI_DATA_BUFFER_MASK)]=SPDR;
     a24:	0f 2e       	mov	r0, r31
     a26:	f4 e6       	ldi	r31, 0x64	; 100
     a28:	cf 2e       	mov	r12, r31
     a2a:	f7 e0       	ldi	r31, 0x07	; 7
     a2c:	df 2e       	mov	r13, r31
     a2e:	f0 2d       	mov	r31, r0

void spi_master(void)
{
	for (;;)
	{
		SPI_SLAVE_SELECT_PORT &= ~(_BV(SPI_SLAVE_SELECT_SS));
     a30:	c4 98       	cbi	0x18, 4	; 24
		SPI_SLAVE_SELECT_DDR |= _BV(SPI_SLAVE_SELECT_SS);
     a32:	bc 9a       	sbi	0x17, 4	; 23
		SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);
     a34:	7d b8       	out	0x0d, r7	; 13
		vTaskDelay(SPI_MASTER_DELAY_SHORT);
     a36:	8a e0       	ldi	r24, 0x0A	; 10
     a38:	90 e0       	ldi	r25, 0x00	; 0
     a3a:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
     a3e:	e5 01       	movw	r28, r10
	/* Enable SPI */
	SPCR = (1<<SPE)| (1<<SPIE);
//    PORT_SPI |= (_BV(DD_MOSI)) | (_BV(DD_SCK));
}

void spi_master(void)
     a40:	84 01       	movw	r16, r8
		vTaskDelay(SPI_MASTER_DELAY_SHORT);

		for (uint8_t i=0; i < SPI_DATA_BUFFER_SIZE; i++ )
		{
			/* Start transmission */
			SPDR = (SPI_DATA_MOSI[i]);
     a42:	89 91       	ld	r24, Y+
     a44:	8f b9       	out	0x0f, r24	; 15
			/* Wait for transmission complete */
			while ((SPSR & (_BV(SPIF))) == 0)
     a46:	77 99       	sbic	0x0e, 7	; 14
     a48:	06 c0       	rjmp	.+12     	; 0xa56 <spi_master+0x58>
			{
			vTaskDelay(SPI_MASTER_DELAY_SHORT);
     a4a:	8a e0       	ldi	r24, 0x0A	; 10
     a4c:	90 e0       	ldi	r25, 0x00	; 0
     a4e:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
		for (uint8_t i=0; i < SPI_DATA_BUFFER_SIZE; i++ )
		{
			/* Start transmission */
			SPDR = (SPI_DATA_MOSI[i]);
			/* Wait for transmission complete */
			while ((SPSR & (_BV(SPIF))) == 0)
     a52:	77 9b       	sbis	0x0e, 7	; 14
     a54:	fa cf       	rjmp	.-12     	; 0xa4a <spi_master+0x4c>
			{
			vTaskDelay(SPI_MASTER_DELAY_SHORT);
			}				
			SPI_DATA_MISO[((i-1) & SPI_DATA_BUFFER_MASK)]=SPDR;
     a56:	2f b1       	in	r18, 0x0f	; 15
     a58:	c8 01       	movw	r24, r16
     a5a:	8f 70       	andi	r24, 0x0F	; 15
     a5c:	90 70       	andi	r25, 0x00	; 0
     a5e:	8c 0d       	add	r24, r12
     a60:	9d 1d       	adc	r25, r13
     a62:	fc 01       	movw	r30, r24
     a64:	20 83       	st	Z, r18
     a66:	0f 5f       	subi	r16, 0xFF	; 255
     a68:	1f 4f       	sbci	r17, 0xFF	; 255
		SPI_SLAVE_SELECT_PORT &= ~(_BV(SPI_SLAVE_SELECT_SS));
		SPI_SLAVE_SELECT_DDR |= _BV(SPI_SLAVE_SELECT_SS);
		SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);
		vTaskDelay(SPI_MASTER_DELAY_SHORT);

		for (uint8_t i=0; i < SPI_DATA_BUFFER_SIZE; i++ )
     a6a:	ce 15       	cp	r28, r14
     a6c:	df 05       	cpc	r29, r15
     a6e:	49 f7       	brne	.-46     	; 0xa42 <spi_master+0x44>
			vTaskDelay(SPI_MASTER_DELAY_SHORT);
			}				
			SPI_DATA_MISO[((i-1) & SPI_DATA_BUFFER_MASK)]=SPDR;

		}		
		vTaskDelay((SPI_MASTER_DELAY_LONG/2));
     a70:	82 e3       	ldi	r24, 0x32	; 50
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
		SPI_SLAVE_SELECT_PORT |= _BV(SPI_SLAVE_SELECT_SS);
     a78:	c4 9a       	sbi	0x18, 4	; 24
		vTaskDelay((SPI_MASTER_DELAY_LONG/2));
     a7a:	82 e3       	ldi	r24, 0x32	; 50
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
	}	
     a82:	d6 cf       	rjmp	.-84     	; 0xa30 <spi_master+0x32>

00000a84 <spi_slave>:

void spi_slave(void)
{
	for (;;)
	{
		if ( (SPI_SLAVE_SELECT_PIN & (_BV(SPI_SLAVE_SELECT_SS)))== (_BV(SPI_SLAVE_SELECT_SS))) 
     a84:	b4 9b       	sbis	0x16, 4	; 22
     a86:	02 c0       	rjmp	.+4      	; 0xa8c <spi_slave+0x8>
		{
			SPI_DATA_COUNT=0;	
     a88:	10 92 63 07 	sts	0x0763, r1
		}		
		vTaskDelay(SPI_SLAVE_DELAY);
     a8c:	85 e0       	ldi	r24, 0x05	; 5
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
	}	
     a94:	f7 cf       	rjmp	.-18     	; 0xa84 <spi_slave>

00000a96 <stepper_init>:
uint16_t STEPPER_POS_INTERNAL;
uint8_t STEPPER_DISPLAY;

void stepper_init (void)
{
	STEPPER_PORT &= ~(0x0f << STEPPER_SHIFT);
     a96:	85 b3       	in	r24, 0x15	; 21
     a98:	80 7f       	andi	r24, 0xF0	; 240
     a9a:	85 bb       	out	0x15, r24	; 21
	STEPPER_STOP_PORT |= _BV(STEPPER_STOP);
     a9c:	df 9a       	sbi	0x1b, 7	; 27
	STEPPER_DDR |= (0x0f << STEPPER_SHIFT);
     a9e:	84 b3       	in	r24, 0x14	; 20
     aa0:	8f 60       	ori	r24, 0x0F	; 15
     aa2:	84 bb       	out	0x14, r24	; 20
	STEPPER_STOP_DDR |= _BV(STEPPER_STOP);
     aa4:	d7 9a       	sbi	0x1a, 7	; 26
	
	STEPPER_CYCLE[0] = STEPPER_CYCLE1;
     aa6:	8c e0       	ldi	r24, 0x0C	; 12
     aa8:	80 93 84 07 	sts	0x0784, r24
	STEPPER_CYCLE[1] = STEPPER_CYCLE2;
     aac:	89 e0       	ldi	r24, 0x09	; 9
     aae:	80 93 85 07 	sts	0x0785, r24
	STEPPER_CYCLE[2] = STEPPER_CYCLE3;
     ab2:	83 e0       	ldi	r24, 0x03	; 3
     ab4:	80 93 86 07 	sts	0x0786, r24
	STEPPER_CYCLE[3] = STEPPER_CYCLE4;
     ab8:	86 e0       	ldi	r24, 0x06	; 6
     aba:	80 93 87 07 	sts	0x0787, r24
	STEPPER_POS_INTERNAL=STEPPER_POS_START;
     abe:	80 e0       	ldi	r24, 0x00	; 0
     ac0:	90 e4       	ldi	r25, 0x40	; 64
     ac2:	90 93 8f 07 	sts	0x078F, r25
     ac6:	80 93 8e 07 	sts	0x078E, r24
	STEPPER_POS=STEPPER_POS_START;
     aca:	90 93 8d 07 	sts	0x078D, r25
     ace:	80 93 8c 07 	sts	0x078C, r24
	STEPPER_POS_CURRENT=STEPPER_POS_CURRENT_START;
     ad2:	10 92 89 07 	sts	0x0789, r1
     ad6:	10 92 88 07 	sts	0x0788, r1
	STEPPER_INIT_DONE=0;
     ada:	10 92 8a 07 	sts	0x078A, r1

}
     ade:	08 95       	ret

00000ae0 <stepper_pos_calc>:

void stepper_pos_calc(void)
{ 
	if (STEPPER_POS_CURRENT >= damper_open_pos)
     ae0:	80 91 88 07 	lds	r24, 0x0788
     ae4:	90 91 89 07 	lds	r25, 0x0789
     ae8:	2e e0       	ldi	r18, 0x0E	; 14
     aea:	80 35       	cpi	r24, 0x50	; 80
     aec:	92 07       	cpc	r25, r18
     aee:	50 f0       	brcs	.+20     	; 0xb04 <stepper_pos_calc+0x24>
	{
		STEPPER_DISPLAY = ((STEPPER_POS_CURRENT-damper_open_pos)/((damper_close_pos-damper_open_pos)/11));
     af0:	80 55       	subi	r24, 0x50	; 80
     af2:	9e 40       	sbci	r25, 0x0E	; 14
     af4:	6e e3       	ldi	r22, 0x3E	; 62
     af6:	72 e0       	ldi	r23, 0x02	; 2
     af8:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <__udivmodhi4>
		STEPPER_DISPLAY += 6;
     afc:	6a 5f       	subi	r22, 0xFA	; 250
     afe:	60 93 8b 07 	sts	0x078B, r22
     b02:	08 c0       	rjmp	.+16     	; 0xb14 <stepper_pos_calc+0x34>
	}
	else
	{
		STEPPER_DISPLAY = ((STEPPER_POS_CURRENT-bottem_open_pos)/((damper_open_pos-bottem_open_pos)/5));
     b04:	80 50       	subi	r24, 0x00	; 0
     b06:	93 40       	sbci	r25, 0x03	; 3
     b08:	63 e4       	ldi	r22, 0x43	; 67
     b0a:	72 e0       	ldi	r23, 0x02	; 2
     b0c:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <__udivmodhi4>
     b10:	60 93 8b 07 	sts	0x078B, r22
	}
	if (STEPPER_POS_CURRENT > damper_close_pos)
     b14:	80 91 88 07 	lds	r24, 0x0788
     b18:	90 91 89 07 	lds	r25, 0x0789
     b1c:	27 e2       	ldi	r18, 0x27	; 39
     b1e:	81 30       	cpi	r24, 0x01	; 1
     b20:	92 07       	cpc	r25, r18
     b22:	18 f0       	brcs	.+6      	; 0xb2a <stepper_pos_calc+0x4a>
	{
		STEPPER_DISPLAY=0x11;	
     b24:	21 e1       	ldi	r18, 0x11	; 17
     b26:	20 93 8b 07 	sts	0x078B, r18
	}
	if (STEPPER_POS_CURRENT < bottem_open_pos)
     b2a:	23 e0       	ldi	r18, 0x03	; 3
     b2c:	80 30       	cpi	r24, 0x00	; 0
     b2e:	92 07       	cpc	r25, r18
     b30:	10 f4       	brcc	.+4      	; 0xb36 <stepper_pos_calc+0x56>
	{
		STEPPER_DISPLAY=0;
     b32:	10 92 8b 07 	sts	0x078B, r1
     b36:	08 95       	ret

00000b38 <stepper>:
		STEPPER_STOP_VAR >>= STEPPER_STOP;
		if (STEPPER_STOP_VAR != 0x01 )
		{
			if ((STEPPER_POS_CURRENT & 0xff00) != (STEPPER_POS_STOP & 0xFF00))
			{
				STEPPER_POS_CURRENT = STEPPER_POS_STOP;
     b38:	0f ef       	ldi	r16, 0xFF	; 255
     b3a:	1f e2       	ldi	r17, 0x2F	; 47
				STEPPER_POS_INTERNAL= STEPPER_POS_STOP;
				STEPPER_INIT_DONE = 1;
     b3c:	c1 e0       	ldi	r28, 0x01	; 1
	uint16_t STEPPER_STEP = 0;
	uint8_t  STEPPER_STOP_VAR;
	
	for ( ;; )
	{
		stepper_pos_calc();	
     b3e:	0e 94 70 05 	call	0xae0	; 0xae0 <stepper_pos_calc>
		STEPPER_STOP_VAR = STEPPER_STOP_PIN & _BV(STEPPER_STOP);
		STEPPER_STOP_VAR >>= STEPPER_STOP;
		if (STEPPER_STOP_VAR != 0x01 )
     b42:	cf 99       	sbic	0x19, 7	; 25
     b44:	10 c0       	rjmp	.+32     	; 0xb66 <stepper+0x2e>
		{
			if ((STEPPER_POS_CURRENT & 0xff00) != (STEPPER_POS_STOP & 0xFF00))
     b46:	80 91 88 07 	lds	r24, 0x0788
     b4a:	90 91 89 07 	lds	r25, 0x0789
     b4e:	80 70       	andi	r24, 0x00	; 0
     b50:	2f e2       	ldi	r18, 0x2F	; 47
     b52:	80 30       	cpi	r24, 0x00	; 0
     b54:	92 07       	cpc	r25, r18
     b56:	39 f0       	breq	.+14     	; 0xb66 <stepper+0x2e>
			{
				STEPPER_POS_CURRENT = STEPPER_POS_STOP;
     b58:	10 93 89 07 	sts	0x0789, r17
     b5c:	00 93 88 07 	sts	0x0788, r16
				STEPPER_POS_INTERNAL= STEPPER_POS_STOP;
				STEPPER_INIT_DONE = 1;
     b60:	c0 93 8a 07 	sts	0x078A, r28
     b64:	04 c0       	rjmp	.+8      	; 0xb6e <stepper+0x36>
			}							
		}
		if (STEPPER_INIT_DONE == 1)
     b66:	80 91 8a 07 	lds	r24, 0x078A
     b6a:	81 30       	cpi	r24, 0x01	; 1
     b6c:	41 f4       	brne	.+16     	; 0xb7e <stepper+0x46>
		{
			STEPPER_POS_INTERNAL=STEPPER_POS;
     b6e:	80 91 8c 07 	lds	r24, 0x078C
     b72:	90 91 8d 07 	lds	r25, 0x078D
     b76:	90 93 8f 07 	sts	0x078F, r25
     b7a:	80 93 8e 07 	sts	0x078E, r24

		}
		if (STEPPER_POS_INTERNAL == STEPPER_POS_CURRENT)
     b7e:	20 91 8e 07 	lds	r18, 0x078E
     b82:	30 91 8f 07 	lds	r19, 0x078F
     b86:	80 91 88 07 	lds	r24, 0x0788
     b8a:	90 91 89 07 	lds	r25, 0x0789
     b8e:	28 17       	cp	r18, r24
     b90:	39 07       	cpc	r19, r25
     b92:	21 f4       	brne	.+8      	; 0xb9c <stepper+0x64>
		{
			STEPPER_PORT &= ~(0x0f << STEPPER_SHIFT);	
     b94:	85 b3       	in	r24, 0x15	; 21
     b96:	80 7f       	andi	r24, 0xF0	; 240
     b98:	85 bb       	out	0x15, r24	; 21
     b9a:	26 c0       	rjmp	.+76     	; 0xbe8 <stepper+0xb0>
		}
		else
		{
			if (STEPPER_POS_INTERNAL > STEPPER_POS_CURRENT)
     b9c:	82 17       	cp	r24, r18
     b9e:	93 07       	cpc	r25, r19
     ba0:	90 f4       	brcc	.+36     	; 0xbc6 <stepper+0x8e>
			{
				STEPPER_POS_CURRENT++;
     ba2:	01 96       	adiw	r24, 0x01	; 1
     ba4:	90 93 89 07 	sts	0x0789, r25
     ba8:	80 93 88 07 	sts	0x0788, r24
				STEPPER_STEP = STEPPER_POS_CURRENT;
				STEPPER_STEP &= 0b11;
                STEPPER_PORT &= ~(0x0f << STEPPER_SHIFT);
     bac:	25 b3       	in	r18, 0x15	; 21
     bae:	20 7f       	andi	r18, 0xF0	; 240
     bb0:	25 bb       	out	0x15, r18	; 21
				STEPPER_PORT |= (STEPPER_CYCLE[STEPPER_STEP] << STEPPER_SHIFT);
     bb2:	25 b3       	in	r18, 0x15	; 21
		{
			if (STEPPER_POS_INTERNAL > STEPPER_POS_CURRENT)
			{
				STEPPER_POS_CURRENT++;
				STEPPER_STEP = STEPPER_POS_CURRENT;
				STEPPER_STEP &= 0b11;
     bb4:	83 70       	andi	r24, 0x03	; 3
     bb6:	90 70       	andi	r25, 0x00	; 0
                STEPPER_PORT &= ~(0x0f << STEPPER_SHIFT);
				STEPPER_PORT |= (STEPPER_CYCLE[STEPPER_STEP] << STEPPER_SHIFT);
     bb8:	fc 01       	movw	r30, r24
     bba:	ec 57       	subi	r30, 0x7C	; 124
     bbc:	f8 4f       	sbci	r31, 0xF8	; 248
     bbe:	80 81       	ld	r24, Z
     bc0:	82 2b       	or	r24, r18
     bc2:	85 bb       	out	0x15, r24	; 21
     bc4:	11 c0       	rjmp	.+34     	; 0xbe8 <stepper+0xb0>
			}
			else
			{
				STEPPER_POS_CURRENT--;
     bc6:	01 97       	sbiw	r24, 0x01	; 1
     bc8:	90 93 89 07 	sts	0x0789, r25
     bcc:	80 93 88 07 	sts	0x0788, r24
				STEPPER_STEP = STEPPER_POS_CURRENT;
				STEPPER_STEP &= 0b11;
				STEPPER_PORT &= ~(0x0f << STEPPER_SHIFT);
     bd0:	25 b3       	in	r18, 0x15	; 21
     bd2:	20 7f       	andi	r18, 0xF0	; 240
     bd4:	25 bb       	out	0x15, r18	; 21
				STEPPER_PORT |= (STEPPER_CYCLE[STEPPER_STEP] << STEPPER_SHIFT);				
     bd6:	25 b3       	in	r18, 0x15	; 21
			}
			else
			{
				STEPPER_POS_CURRENT--;
				STEPPER_STEP = STEPPER_POS_CURRENT;
				STEPPER_STEP &= 0b11;
     bd8:	83 70       	andi	r24, 0x03	; 3
     bda:	90 70       	andi	r25, 0x00	; 0
				STEPPER_PORT &= ~(0x0f << STEPPER_SHIFT);
				STEPPER_PORT |= (STEPPER_CYCLE[STEPPER_STEP] << STEPPER_SHIFT);				
     bdc:	fc 01       	movw	r30, r24
     bde:	ec 57       	subi	r30, 0x7C	; 124
     be0:	f8 4f       	sbci	r31, 0xF8	; 248
     be2:	80 81       	ld	r24, Z
     be4:	82 2b       	or	r24, r18
     be6:	85 bb       	out	0x15, r24	; 21
			}
		}

	vTaskDelay (STEPPER_SPEED);
     be8:	86 e0       	ldi	r24, 0x06	; 6
     bea:	90 e0       	ldi	r25, 0x00	; 0
     bec:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
		
	}
     bf0:	a6 cf       	rjmp	.-180    	; 0xb3e <stepper+0x6>

00000bf2 <stove_cooldown_test>:
	}		
}

void stove_cooldown_test(uint8_t stove_target_temp_test, uint16_t stove_cooldown_count_amount )
{
	if (STEPPER_POS != stove_run_lower_limit)
     bf2:	40 91 8c 07 	lds	r20, 0x078C
     bf6:	50 91 8d 07 	lds	r21, 0x078D
     bfa:	20 91 92 07 	lds	r18, 0x0792
     bfe:	30 91 93 07 	lds	r19, 0x0793
     c02:	42 17       	cp	r20, r18
     c04:	53 07       	cpc	r21, r19
     c06:	21 f0       	breq	.+8      	; 0xc10 <stove_cooldown_test+0x1e>
	{
		stove_cooldown_count=0;
     c08:	10 92 91 07 	sts	0x0791, r1
     c0c:	10 92 90 07 	sts	0x0790, r1
	}
	if (ADC_VALUE1 >= stove_target_temp)
     c10:	20 91 0e 07 	lds	r18, 0x070E
     c14:	90 91 a8 07 	lds	r25, 0x07A8
     c18:	29 17       	cp	r18, r25
     c1a:	28 f0       	brcs	.+10     	; 0xc26 <stove_cooldown_test+0x34>
	{
		stove_cooldown_count=0;
     c1c:	10 92 91 07 	sts	0x0791, r1
     c20:	10 92 90 07 	sts	0x0790, r1
     c24:	08 95       	ret
	}
	else
	{
		if (stove_cooldown_count <= stove_cooldown_count_amount) 
     c26:	20 91 90 07 	lds	r18, 0x0790
     c2a:	30 91 91 07 	lds	r19, 0x0791
     c2e:	62 17       	cp	r22, r18
     c30:	73 07       	cpc	r23, r19
     c32:	38 f0       	brcs	.+14     	; 0xc42 <stove_cooldown_test+0x50>
		{
			stove_cooldown_count++;
     c34:	2f 5f       	subi	r18, 0xFF	; 255
     c36:	3f 4f       	sbci	r19, 0xFF	; 255
     c38:	30 93 91 07 	sts	0x0791, r19
     c3c:	20 93 90 07 	sts	0x0790, r18
     c40:	08 95       	ret
		}
		else
		{
			stove_target_temp=stove_target_temp_test;
     c42:	80 93 a8 07 	sts	0x07A8, r24
			stove_target_temp_lockout=stove_target_temp_test;
     c46:	80 93 96 07 	sts	0x0796, r24
			stove_cooldown_count=0;
     c4a:	10 92 91 07 	sts	0x0791, r1
     c4e:	10 92 90 07 	sts	0x0790, r1
     c52:	08 95       	ret

00000c54 <stove_target_temp_config>:
		}
	}
}

void stove_target_temp_config(uint8_t stove_target_temp_higher, uint8_t stove_target_temp_lower, uint16_t stove_run_change_count_len)
{   
     c54:	78 2f       	mov	r23, r24
     c56:	fa 01       	movw	r30, r20
	if (ds1620_temp == (stove_mode_room_temp_target_var*2))
     c58:	80 91 a6 07 	lds	r24, 0x07A6
     c5c:	90 e0       	ldi	r25, 0x00	; 0
     c5e:	40 91 50 07 	lds	r20, 0x0750
     c62:	50 91 51 07 	lds	r21, 0x0751
     c66:	9c 01       	movw	r18, r24
     c68:	22 0f       	add	r18, r18
     c6a:	33 1f       	adc	r19, r19
     c6c:	24 17       	cp	r18, r20
     c6e:	35 07       	cpc	r19, r21
     c70:	21 f4       	brne	.+8      	; 0xc7a <stove_target_temp_config+0x26>
	{
		stove_run_change_temp_count=0;
     c72:	10 92 a5 07 	sts	0x07A5, r1
     c76:	10 92 a4 07 	sts	0x07A4, r1
	}
	if (ds1620_temp >= ((stove_mode_room_temp_target_var+stove_mode_room_temp_over)*2))
     c7a:	01 96       	adiw	r24, 0x01	; 1
     c7c:	88 0f       	add	r24, r24
     c7e:	99 1f       	adc	r25, r25
     c80:	48 17       	cp	r20, r24
     c82:	59 07       	cpc	r21, r25
     c84:	98 f0       	brcs	.+38     	; 0xcac <stove_target_temp_config+0x58>
	{
		if (stove_run_change_temp_count <= stove_run_change_count_len)
     c86:	80 91 a4 07 	lds	r24, 0x07A4
     c8a:	90 91 a5 07 	lds	r25, 0x07A5
     c8e:	e8 17       	cp	r30, r24
     c90:	f9 07       	cpc	r31, r25
     c92:	30 f0       	brcs	.+12     	; 0xca0 <stove_target_temp_config+0x4c>
		{
			stove_run_change_temp_count++;
     c94:	01 96       	adiw	r24, 0x01	; 1
     c96:	90 93 a5 07 	sts	0x07A5, r25
     c9a:	80 93 a4 07 	sts	0x07A4, r24
     c9e:	06 c0       	rjmp	.+12     	; 0xcac <stove_target_temp_config+0x58>
		}
		else 
		{
			stove_run_change_temp_count=0;
     ca0:	10 92 a5 07 	sts	0x07A5, r1
     ca4:	10 92 a4 07 	sts	0x07A4, r1
			stove_target_temp=stove_target_temp_lower;			
     ca8:	60 93 a8 07 	sts	0x07A8, r22
		}
	}
	if (ds1620_temp <=((stove_mode_room_temp_target_var-stove_mode_room_temp_under)*2))
     cac:	20 91 a6 07 	lds	r18, 0x07A6
     cb0:	30 e0       	ldi	r19, 0x00	; 0
     cb2:	21 50       	subi	r18, 0x01	; 1
     cb4:	30 40       	sbci	r19, 0x00	; 0
     cb6:	22 0f       	add	r18, r18
     cb8:	33 1f       	adc	r19, r19
     cba:	80 91 50 07 	lds	r24, 0x0750
     cbe:	90 91 51 07 	lds	r25, 0x0751
     cc2:	28 17       	cp	r18, r24
     cc4:	39 07       	cpc	r19, r25
     cc6:	98 f0       	brcs	.+38     	; 0xcee <stove_target_temp_config+0x9a>
	{
		if (stove_run_change_temp_count <= stove_run_change_count_len)
     cc8:	80 91 a4 07 	lds	r24, 0x07A4
     ccc:	90 91 a5 07 	lds	r25, 0x07A5
     cd0:	e8 17       	cp	r30, r24
     cd2:	f9 07       	cpc	r31, r25
     cd4:	30 f0       	brcs	.+12     	; 0xce2 <stove_target_temp_config+0x8e>
		{
			stove_run_change_temp_count++;
     cd6:	01 96       	adiw	r24, 0x01	; 1
     cd8:	90 93 a5 07 	sts	0x07A5, r25
     cdc:	80 93 a4 07 	sts	0x07A4, r24
     ce0:	08 95       	ret
		}
		else
		{
			stove_run_change_temp_count=0;
     ce2:	10 92 a5 07 	sts	0x07A5, r1
     ce6:	10 92 a4 07 	sts	0x07A4, r1
			stove_target_temp=stove_target_temp_higher;
     cea:	70 93 a8 07 	sts	0x07A8, r23
     cee:	08 95       	ret

00000cf0 <stove_mode_buzzer>:

#ifndef DOWN_STAIRS_

void stove_mode_buzzer(void)
{
	if ((stove_mode & (1<<MODE_BEEP_bit)) == (1<<MODE_BEEP_bit))
     cf0:	80 91 9f 07 	lds	r24, 0x079F
     cf4:	83 ff       	sbrs	r24, 3
     cf6:	1a c0       	rjmp	.+52     	; 0xd2c <stove_mode_buzzer+0x3c>
	{
		if (stove_control_buzzer_count_upstairs < stove_control_buzzer_short)
     cf8:	80 91 9a 07 	lds	r24, 0x079A
     cfc:	90 91 9b 07 	lds	r25, 0x079B
     d00:	00 97       	sbiw	r24, 0x00	; 0
     d02:	11 f4       	brne	.+4      	; 0xd08 <stove_mode_buzzer+0x18>
		{
			stove_control_buzzer_PORT &= ~(_BV(stove_control_buzzer_PI));
     d04:	de 98       	cbi	0x1b, 6	; 27
     d06:	01 c0       	rjmp	.+2      	; 0xd0a <stove_mode_buzzer+0x1a>
		}
		else
		{
			stove_control_buzzer_PORT |= _BV(stove_control_buzzer_PI);
     d08:	de 9a       	sbi	0x1b, 6	; 27
		}
		stove_control_buzzer_count_upstairs++;
     d0a:	80 91 9a 07 	lds	r24, 0x079A
     d0e:	90 91 9b 07 	lds	r25, 0x079B
     d12:	01 96       	adiw	r24, 0x01	; 1
     d14:	90 93 9b 07 	sts	0x079B, r25
     d18:	80 93 9a 07 	sts	0x079A, r24
		if (stove_control_buzzer_count_upstairs == stove_control_buzzer_long)
     d1c:	2b e0       	ldi	r18, 0x0B	; 11
     d1e:	88 3b       	cpi	r24, 0xB8	; 184
     d20:	92 07       	cpc	r25, r18
     d22:	21 f4       	brne	.+8      	; 0xd2c <stove_mode_buzzer+0x3c>
		{
			stove_control_buzzer_count_upstairs=0;
     d24:	10 92 9b 07 	sts	0x079B, r1
     d28:	10 92 9a 07 	sts	0x079A, r1
		}
	}
	if 	((SPI_DATA_MISO[SPI_STOVE_MODE] & (1<<MODE_BEEP_bit)) == (1<<MODE_BEEP_bit))
     d2c:	80 91 68 07 	lds	r24, 0x0768
     d30:	83 ff       	sbrs	r24, 3
     d32:	1a c0       	rjmp	.+52     	; 0xd68 <stove_mode_buzzer+0x78>
	{
		if (stove_control_buzzer_count_downstairs < stove_control_buzzer_short)
     d34:	80 91 97 07 	lds	r24, 0x0797
     d38:	90 91 98 07 	lds	r25, 0x0798
     d3c:	00 97       	sbiw	r24, 0x00	; 0
     d3e:	11 f4       	brne	.+4      	; 0xd44 <stove_mode_buzzer+0x54>
		{
			stove_control_buzzer_PORT &= ~(_BV(stove_control_buzzer_PI));
     d40:	de 98       	cbi	0x1b, 6	; 27
     d42:	01 c0       	rjmp	.+2      	; 0xd46 <stove_mode_buzzer+0x56>
		}
		else
		{
			stove_control_buzzer_PORT |= _BV(stove_control_buzzer_PI);
     d44:	de 9a       	sbi	0x1b, 6	; 27
		}
		stove_control_buzzer_count_downstairs++;
     d46:	80 91 97 07 	lds	r24, 0x0797
     d4a:	90 91 98 07 	lds	r25, 0x0798
     d4e:	01 96       	adiw	r24, 0x01	; 1
     d50:	90 93 98 07 	sts	0x0798, r25
     d54:	80 93 97 07 	sts	0x0797, r24
		if (stove_control_buzzer_count_downstairs == stove_control_buzzer_long)
     d58:	2b e0       	ldi	r18, 0x0B	; 11
     d5a:	88 3b       	cpi	r24, 0xB8	; 184
     d5c:	92 07       	cpc	r25, r18
     d5e:	21 f4       	brne	.+8      	; 0xd68 <stove_mode_buzzer+0x78>
		{
			stove_control_buzzer_count_downstairs=0;
     d60:	10 92 98 07 	sts	0x0798, r1
     d64:	10 92 97 07 	sts	0x0797, r1
     d68:	08 95       	ret

00000d6a <stove_control_nite_mode>:
}

void stove_control_nite_mode(void)
{
	
}
     d6a:	08 95       	ret

00000d6c <stove_control_reset>:

void stove_control_reset(uint8_t stove_control_reset_mode)
{
     d6c:	cf 93       	push	r28
     d6e:	c8 2f       	mov	r28, r24
#ifndef DOWN_STAIRS_	
	cli();
     d70:	f8 94       	cli
	eeprom_update_byte(&stove_mode_room_temp_target_ee,stove_mode_room_temp_target_var);
     d72:	80 e0       	ldi	r24, 0x00	; 0
     d74:	90 e0       	ldi	r25, 0x00	; 0
     d76:	60 91 a6 07 	lds	r22, 0x07A6
     d7a:	0e 94 78 17 	call	0x2ef0	; 0x2ef0 <__eeupd_byte_m32>
	sei();
     d7e:	78 94       	sei
	stove_control_buzzer_count_upstairs=0;
     d80:	10 92 9b 07 	sts	0x079B, r1
     d84:	10 92 9a 07 	sts	0x079A, r1
#endif
#ifdef DOWN_STAIRS_
	stove_mode_room_temp_target_var=stove_mode_room_temp_target;
#endif
	
	stove_mode_start_first=0;
     d88:	10 92 99 07 	sts	0x0799, r1
	stove_run_upper_limit = damper_close_pos;
     d8c:	80 e0       	ldi	r24, 0x00	; 0
     d8e:	97 e2       	ldi	r25, 0x27	; 39
     d90:	90 93 9e 07 	sts	0x079E, r25
     d94:	80 93 9d 07 	sts	0x079D, r24
	stove_run_lower_limit = damper_open_pos;
     d98:	80 e5       	ldi	r24, 0x50	; 80
     d9a:	9e e0       	ldi	r25, 0x0E	; 14
     d9c:	90 93 93 07 	sts	0x0793, r25
     da0:	80 93 92 07 	sts	0x0792, r24
	stove_target_temp_lockout=stove_start_temp;
     da4:	88 ec       	ldi	r24, 0xC8	; 200
     da6:	80 93 96 07 	sts	0x0796, r24
	stove_target_temp=stove_run_hot_temp;
     daa:	88 ea       	ldi	r24, 0xA8	; 168
     dac:	80 93 a8 07 	sts	0x07A8, r24
	stove_cooldown_count=0;
     db0:	10 92 91 07 	sts	0x0791, r1
     db4:	10 92 90 07 	sts	0x0790, r1
	stove_mode &= 0xF0;
     db8:	80 91 9f 07 	lds	r24, 0x079F
     dbc:	80 7f       	andi	r24, 0xF0	; 240
     dbe:	80 93 9f 07 	sts	0x079F, r24
	if (stove_target_temp == 00 )
	{
		stove_target_temp=stove_run_hot_temp; 
	}
		
	if (stove_control_reset_mode == stove_control_reset_nite)
     dc2:	c2 30       	cpi	r28, 0x02	; 2
     dc4:	41 f4       	brne	.+16     	; 0xdd6 <stove_control_reset+0x6a>
	{
		stove_target_temp_lockout=stove_run_cool_temp;
     dc6:	94 e6       	ldi	r25, 0x64	; 100
     dc8:	90 93 96 07 	sts	0x0796, r25
		stove_target_temp=stove_run_cool_temp;
     dcc:	90 93 a8 07 	sts	0x07A8, r25
		stove_mode &= 0xF0;
		stove_mode |= MODE_NITE;	
     dd0:	81 60       	ori	r24, 0x01	; 1
     dd2:	80 93 9f 07 	sts	0x079F, r24
		stove_control_nite_mode();
	}
}
     dd6:	cf 91       	pop	r28
     dd8:	08 95       	ret

00000dda <stove_control_init>:
#endif



void stove_control_init(void)
{
     dda:	cf 93       	push	r28
     ddc:	df 93       	push	r29
#ifndef DOWN_STAIRS_	
	stove_mode_room_temp_target_var =eeprom_read_byte(&stove_mode_room_temp_target_ee);
     dde:	80 e0       	ldi	r24, 0x00	; 0
     de0:	90 e0       	ldi	r25, 0x00	; 0
     de2:	0e 94 70 17 	call	0x2ee0	; 0x2ee0 <__eerd_byte_m32>
     de6:	80 93 a6 07 	sts	0x07A6, r24
	stove_control_buzzer_PORT |= (_BV(stove_control_buzzer_PI));
     dea:	de 9a       	sbi	0x1b, 6	; 27
	stove_control_buzzer_DDR |= _BV(stove_control_buzzer_PI);
     dec:	d6 9a       	sbi	0x1a, 6	; 26
#endif

	stove_control_led_PORT &= ~(_BV(stove_control_led_PI));
     dee:	dd 98       	cbi	0x1b, 5	; 27
	stove_control_led_DDR |=_BV(stove_control_led_PI);
     df0:	d5 9a       	sbi	0x1a, 5	; 26
	
	STEPPER_POS=damper_shutdown_pos;  
     df2:	c0 e0       	ldi	r28, 0x00	; 0
     df4:	dc e2       	ldi	r29, 0x2C	; 44
     df6:	d0 93 8d 07 	sts	0x078D, r29
     dfa:	c0 93 8c 07 	sts	0x078C, r28
	stove_target_temp = stove_start_temp;
     dfe:	88 ec       	ldi	r24, 0xC8	; 200
     e00:	80 93 a8 07 	sts	0x07A8, r24
	stove_run_change_count = 0;
     e04:	10 92 95 07 	sts	0x0795, r1
     e08:	10 92 94 07 	sts	0x0794, r1
	stove_run_upper_limit = damper_close_pos;
     e0c:	80 e0       	ldi	r24, 0x00	; 0
     e0e:	97 e2       	ldi	r25, 0x27	; 39
     e10:	90 93 9e 07 	sts	0x079E, r25
     e14:	80 93 9d 07 	sts	0x079D, r24
	stove_run_lower_limit = damper_open_pos;
     e18:	80 e5       	ldi	r24, 0x50	; 80
     e1a:	9e e0       	ldi	r25, 0x0E	; 14
     e1c:	90 93 93 07 	sts	0x0793, r25
     e20:	80 93 92 07 	sts	0x0792, r24
	stove_run_limit_result = 0;
     e24:	10 92 a7 07 	sts	0x07A7, r1
	stove_target_temp_lockout=0;
     e28:	10 92 96 07 	sts	0x0796, r1
	stove_mode=0;
	stove_mode &= 0xF0;
	stove_mode |= MODE_NORM;
	stove_mode |= (4<<MODE_SRT);
     e2c:	88 e0       	ldi	r24, 0x08	; 8
     e2e:	80 93 9f 07 	sts	0x079F, r24

	stove_control_reset(stove_control_reset_normal);
     e32:	81 e0       	ldi	r24, 0x01	; 1
     e34:	0e 94 b6 06 	call	0xd6c	; 0xd6c <stove_control_reset>
	stove_mode_start_first=2;
     e38:	82 e0       	ldi	r24, 0x02	; 2
     e3a:	80 93 99 07 	sts	0x0799, r24
	STEPPER_POS=damper_shutdown_pos;
     e3e:	d0 93 8d 07 	sts	0x078D, r29
     e42:	c0 93 8c 07 	sts	0x078C, r28
}
     e46:	df 91       	pop	r29
     e48:	cf 91       	pop	r28
     e4a:	08 95       	ret

00000e4c <stove_control_change_damper_pos>:
	}
}

void stove_control_change_damper_pos(uint8_t i)
{
	stove_run_limit_result = 0;
     e4c:	10 92 a7 07 	sts	0x07A7, r1
	
	if (i == 1)
     e50:	81 30       	cpi	r24, 0x01	; 1
     e52:	49 f5       	brne	.+82     	; 0xea6 <stove_control_change_damper_pos+0x5a>
	{
		if (STEPPER_POS >= stove_run_change_steps)
     e54:	20 91 8c 07 	lds	r18, 0x078C
     e58:	30 91 8d 07 	lds	r19, 0x078D
     e5c:	80 91 a0 07 	lds	r24, 0x07A0
     e60:	90 91 a1 07 	lds	r25, 0x07A1
     e64:	28 17       	cp	r18, r24
     e66:	39 07       	cpc	r19, r25
     e68:	38 f0       	brcs	.+14     	; 0xe78 <stove_control_change_damper_pos+0x2c>
		{
			STEPPER_POS -= stove_run_change_steps;
     e6a:	28 1b       	sub	r18, r24
     e6c:	39 0b       	sbc	r19, r25
     e6e:	30 93 8d 07 	sts	0x078D, r19
     e72:	20 93 8c 07 	sts	0x078C, r18
     e76:	04 c0       	rjmp	.+8      	; 0xe80 <stove_control_change_damper_pos+0x34>
		}
		else
		{
			STEPPER_POS = 0;
     e78:	10 92 8d 07 	sts	0x078D, r1
     e7c:	10 92 8c 07 	sts	0x078C, r1
		}
		
		if (STEPPER_POS < stove_run_lower_limit)
     e80:	80 91 92 07 	lds	r24, 0x0792
     e84:	90 91 93 07 	lds	r25, 0x0793
     e88:	20 91 8c 07 	lds	r18, 0x078C
     e8c:	30 91 8d 07 	lds	r19, 0x078D
     e90:	28 17       	cp	r18, r24
     e92:	39 07       	cpc	r19, r25
     e94:	a8 f5       	brcc	.+106    	; 0xf00 <stove_control_change_damper_pos+0xb4>
		{
			STEPPER_POS = stove_run_lower_limit;
     e96:	90 93 8d 07 	sts	0x078D, r25
     e9a:	80 93 8c 07 	sts	0x078C, r24
			stove_run_limit_result = 1 ;
     e9e:	81 e0       	ldi	r24, 0x01	; 1
     ea0:	80 93 a7 07 	sts	0x07A7, r24
     ea4:	08 95       	ret
		}

	}
	else
	{
		if ((0xFFFF - STEPPER_POS) >= stove_run_change_steps)
     ea6:	80 91 8c 07 	lds	r24, 0x078C
     eaa:	90 91 8d 07 	lds	r25, 0x078D
     eae:	20 91 a0 07 	lds	r18, 0x07A0
     eb2:	30 91 a1 07 	lds	r19, 0x07A1
     eb6:	ac 01       	movw	r20, r24
     eb8:	40 95       	com	r20
     eba:	50 95       	com	r21
     ebc:	42 17       	cp	r20, r18
     ebe:	53 07       	cpc	r21, r19
     ec0:	38 f0       	brcs	.+14     	; 0xed0 <stove_control_change_damper_pos+0x84>
		{
			STEPPER_POS += stove_run_change_steps;
     ec2:	82 0f       	add	r24, r18
     ec4:	93 1f       	adc	r25, r19
     ec6:	90 93 8d 07 	sts	0x078D, r25
     eca:	80 93 8c 07 	sts	0x078C, r24
     ece:	06 c0       	rjmp	.+12     	; 0xedc <stove_control_change_damper_pos+0x90>
		}
		else
		{
			STEPPER_POS = 0xFFFF;
     ed0:	8f ef       	ldi	r24, 0xFF	; 255
     ed2:	9f ef       	ldi	r25, 0xFF	; 255
     ed4:	90 93 8d 07 	sts	0x078D, r25
     ed8:	80 93 8c 07 	sts	0x078C, r24
		}
		
		if (STEPPER_POS > stove_run_upper_limit)
     edc:	80 91 9d 07 	lds	r24, 0x079D
     ee0:	90 91 9e 07 	lds	r25, 0x079E
     ee4:	20 91 8c 07 	lds	r18, 0x078C
     ee8:	30 91 8d 07 	lds	r19, 0x078D
     eec:	82 17       	cp	r24, r18
     eee:	93 07       	cpc	r25, r19
     ef0:	38 f4       	brcc	.+14     	; 0xf00 <stove_control_change_damper_pos+0xb4>
		{
			STEPPER_POS = stove_run_upper_limit;
     ef2:	90 93 8d 07 	sts	0x078D, r25
     ef6:	80 93 8c 07 	sts	0x078C, r24
			stove_run_limit_result = 2 ;
     efa:	82 e0       	ldi	r24, 0x02	; 2
     efc:	80 93 a7 07 	sts	0x07A7, r24
     f00:	08 95       	ret

00000f02 <stove_control_fuzzy>:
		/*
		Test stove temp against target temp if equal do nothing
		if not see how far away from target 
		if    mask     then        delay  and amount of change
		*/
		if (ADC_VALUE1 != stove_target_temp)
     f02:	20 91 0e 07 	lds	r18, 0x070E
     f06:	80 91 a8 07 	lds	r24, 0x07A8
     f0a:	28 17       	cp	r18, r24
     f0c:	09 f4       	brne	.+2      	; 0xf10 <stove_control_fuzzy+0xe>
     f0e:	44 c0       	rjmp	.+136    	; 0xf98 <stove_control_fuzzy+0x96>
		{
			if ((ADC_VALUE1 & (~stove_run_change_stage2_mask)) == (stove_target_temp & (~stove_run_change_stage2_mask)))
     f10:	90 e0       	ldi	r25, 0x00	; 0
     f12:	30 e0       	ldi	r19, 0x00	; 0
     f14:	82 27       	eor	r24, r18
     f16:	93 27       	eor	r25, r19
     f18:	9c 01       	movw	r18, r24
     f1a:	2c 7f       	andi	r18, 0xFC	; 252
     f1c:	21 15       	cp	r18, r1
     f1e:	31 05       	cpc	r19, r1
     f20:	69 f4       	brne	.+26     	; 0xf3c <stove_control_fuzzy+0x3a>
			{
				stove_run_change_count_len = stove_run_change_count_len_stage1;
     f22:	8f e4       	ldi	r24, 0x4F	; 79
     f24:	90 e0       	ldi	r25, 0x00	; 0
     f26:	90 93 a3 07 	sts	0x07A3, r25
     f2a:	80 93 a2 07 	sts	0x07A2, r24
				stove_run_change_steps = stove_run_change_steps_stage1;
     f2e:	80 e3       	ldi	r24, 0x30	; 48
     f30:	90 e0       	ldi	r25, 0x00	; 0
     f32:	90 93 a1 07 	sts	0x07A1, r25
     f36:	80 93 a0 07 	sts	0x07A0, r24
     f3a:	2e c0       	rjmp	.+92     	; 0xf98 <stove_control_fuzzy+0x96>
			}
			else
			{
				if ((ADC_VALUE1 & (~stove_run_change_stage3_mask)) == (stove_target_temp & (~stove_run_change_stage3_mask)))
     f3c:	9c 01       	movw	r18, r24
     f3e:	20 7f       	andi	r18, 0xF0	; 240
     f40:	21 15       	cp	r18, r1
     f42:	31 05       	cpc	r19, r1
     f44:	69 f4       	brne	.+26     	; 0xf60 <stove_control_fuzzy+0x5e>
				{
					stove_run_change_count_len = stove_run_change_count_len_stage2;
     f46:	8f e1       	ldi	r24, 0x1F	; 31
     f48:	90 e0       	ldi	r25, 0x00	; 0
     f4a:	90 93 a3 07 	sts	0x07A3, r25
     f4e:	80 93 a2 07 	sts	0x07A2, r24
					stove_run_change_steps = stove_run_change_steps_stage2;				
     f52:	80 e5       	ldi	r24, 0x50	; 80
     f54:	90 e0       	ldi	r25, 0x00	; 0
     f56:	90 93 a1 07 	sts	0x07A1, r25
     f5a:	80 93 a0 07 	sts	0x07A0, r24
     f5e:	1c c0       	rjmp	.+56     	; 0xf98 <stove_control_fuzzy+0x96>
				}
				else
				{
					if ((ADC_VALUE1 & (~stove_run_change_stage4_mask)) == (stove_target_temp & (~stove_run_change_stage4_mask)))
     f60:	80 7c       	andi	r24, 0xC0	; 192
     f62:	00 97       	sbiw	r24, 0x00	; 0
     f64:	69 f4       	brne	.+26     	; 0xf80 <stove_control_fuzzy+0x7e>
					{
						stove_run_change_count_len = stove_run_change_count_len_stage3;
     f66:	86 e0       	ldi	r24, 0x06	; 6
     f68:	90 e0       	ldi	r25, 0x00	; 0
     f6a:	90 93 a3 07 	sts	0x07A3, r25
     f6e:	80 93 a2 07 	sts	0x07A2, r24
						stove_run_change_steps = stove_run_change_steps_stage3;
     f72:	80 e8       	ldi	r24, 0x80	; 128
     f74:	90 e0       	ldi	r25, 0x00	; 0
     f76:	90 93 a1 07 	sts	0x07A1, r25
     f7a:	80 93 a0 07 	sts	0x07A0, r24
     f7e:	0c c0       	rjmp	.+24     	; 0xf98 <stove_control_fuzzy+0x96>
					}
					else
					{
						stove_run_change_count_len = stove_run_change_count_len_stage4;
     f80:	83 e0       	ldi	r24, 0x03	; 3
     f82:	90 e0       	ldi	r25, 0x00	; 0
     f84:	90 93 a3 07 	sts	0x07A3, r25
     f88:	80 93 a2 07 	sts	0x07A2, r24
						stove_run_change_steps = stove_run_change_steps_stage4;
     f8c:	80 ec       	ldi	r24, 0xC0	; 192
     f8e:	90 e0       	ldi	r25, 0x00	; 0
     f90:	90 93 a1 07 	sts	0x07A1, r25
     f94:	80 93 a0 07 	sts	0x07A0, r24
			}
		}
		
		// delay for speed
		
		if ( stove_run_change_count <= stove_run_change_count_len )
     f98:	80 91 94 07 	lds	r24, 0x0794
     f9c:	90 91 95 07 	lds	r25, 0x0795
     fa0:	20 91 a2 07 	lds	r18, 0x07A2
     fa4:	30 91 a3 07 	lds	r19, 0x07A3
     fa8:	28 17       	cp	r18, r24
     faa:	39 07       	cpc	r19, r25
     fac:	30 f0       	brcs	.+12     	; 0xfba <stove_control_fuzzy+0xb8>
		{
			stove_run_change_count++;
     fae:	01 96       	adiw	r24, 0x01	; 1
     fb0:	90 93 95 07 	sts	0x0795, r25
     fb4:	80 93 94 07 	sts	0x0794, r24
     fb8:	08 95       	ret
		{
			/*
			once delay is done figure out if the stove temp is moving in the right direction if it is do nothing
			else change damper position
			*/
			stove_run_change_count = 0;
     fba:	10 92 95 07 	sts	0x0795, r1
     fbe:	10 92 94 07 	sts	0x0794, r1
			if (ADC_VALUE1 < stove_target_temp)
     fc2:	80 91 0e 07 	lds	r24, 0x070E
     fc6:	90 91 a8 07 	lds	r25, 0x07A8
     fca:	89 17       	cp	r24, r25
     fcc:	68 f4       	brcc	.+26     	; 0xfe8 <stove_control_fuzzy+0xe6>
			{
				if (ADC_VALUE1 <= stove_target_temp_ref) 
     fce:	90 91 9c 07 	lds	r25, 0x079C
     fd2:	98 17       	cp	r25, r24
     fd4:	30 f0       	brcs	.+12     	; 0xfe2 <stove_control_fuzzy+0xe0>
				{
					stove_target_temp_ref=ADC_VALUE1;
     fd6:	80 93 9c 07 	sts	0x079C, r24
					stove_control_change_damper_pos(open_damper);
     fda:	81 e0       	ldi	r24, 0x01	; 1
     fdc:	0e 94 26 07 	call	0xe4c	; 0xe4c <stove_control_change_damper_pos>
     fe0:	08 95       	ret
				}
				else
				{
					stove_target_temp_ref=ADC_VALUE1;
     fe2:	80 93 9c 07 	sts	0x079C, r24
     fe6:	08 95       	ret
				}
			}
			else
			{
				if (ADC_VALUE1 >= stove_target_temp_ref) 
     fe8:	90 91 9c 07 	lds	r25, 0x079C
     fec:	89 17       	cp	r24, r25
     fee:	30 f0       	brcs	.+12     	; 0xffc <stove_control_fuzzy+0xfa>
				{
					stove_target_temp_ref=ADC_VALUE1;
     ff0:	80 93 9c 07 	sts	0x079C, r24
					stove_control_change_damper_pos(close_damper);
     ff4:	80 e0       	ldi	r24, 0x00	; 0
     ff6:	0e 94 26 07 	call	0xe4c	; 0xe4c <stove_control_change_damper_pos>
     ffa:	08 95       	ret
				}
				else
				{
					stove_target_temp_ref=ADC_VALUE1;
     ffc:	80 93 9c 07 	sts	0x079C, r24
    1000:	08 95       	ret

00001002 <stove_control_checks>:
*		set nite mode if required
*/

void stove_control_checks(void)
{
	if (stove_target_temp!=stove_shutdown_temp)
    1002:	80 91 a8 07 	lds	r24, 0x07A8
    1006:	88 23       	and	r24, r24
    1008:	09 f4       	brne	.+2      	; 0x100c <stove_control_checks+0xa>
    100a:	a2 c0       	rjmp	.+324    	; 0x1150 <stove_control_checks+0x14e>
	{
		if (stove_mode_start_first==0)
    100c:	80 91 99 07 	lds	r24, 0x0799
    1010:	88 23       	and	r24, r24
    1012:	b1 f4       	brne	.+44     	; 0x1040 <stove_control_checks+0x3e>
		{
			stove_mode_start_first=1;
    1014:	81 e0       	ldi	r24, 0x01	; 1
    1016:	80 93 99 07 	sts	0x0799, r24
			
			if (ADC_VALUE2 < stove_back_temp) 
    101a:	80 91 0f 07 	lds	r24, 0x070F
    101e:	80 3c       	cpi	r24, 0xC0	; 192
    1020:	78 f4       	brcc	.+30     	; 0x1040 <stove_control_checks+0x3e>
			{
				stove_run_lower_limit = bottem_open_pos;
    1022:	80 e0       	ldi	r24, 0x00	; 0
    1024:	93 e0       	ldi	r25, 0x03	; 3
    1026:	90 93 93 07 	sts	0x0793, r25
    102a:	80 93 92 07 	sts	0x0792, r24
				stove_target_temp = stove_start_temp;
    102e:	28 ec       	ldi	r18, 0xC8	; 200
    1030:	20 93 a8 07 	sts	0x07A8, r18
				stove_target_temp_lockout= stove_start_temp;
    1034:	20 93 96 07 	sts	0x0796, r18
				STEPPER_POS=bottem_open_pos;
    1038:	90 93 8d 07 	sts	0x078D, r25
    103c:	80 93 8c 07 	sts	0x078C, r24
			}		
		}
		if (stove_target_temp > stove_target_temp_lockout)
    1040:	80 91 96 07 	lds	r24, 0x0796
    1044:	90 91 a8 07 	lds	r25, 0x07A8
    1048:	89 17       	cp	r24, r25
    104a:	10 f4       	brcc	.+4      	; 0x1050 <stove_control_checks+0x4e>
		{
			stove_target_temp=stove_target_temp_lockout;
    104c:	80 93 a8 07 	sts	0x07A8, r24
		}
		if (stove_target_temp == stove_start_temp)
    1050:	80 91 a8 07 	lds	r24, 0x07A8
    1054:	88 3c       	cpi	r24, 0xC8	; 200
    1056:	99 f4       	brne	.+38     	; 0x107e <stove_control_checks+0x7c>
		{
			if (ADC_VALUE2 > stove_back_temp)
    1058:	80 91 0f 07 	lds	r24, 0x070F
    105c:	81 3c       	cpi	r24, 0xC1	; 193
    105e:	48 f0       	brcs	.+18     	; 0x1072 <stove_control_checks+0x70>
			{
				stove_run_lower_limit = damper_open_pos;
    1060:	80 e5       	ldi	r24, 0x50	; 80
    1062:	9e e0       	ldi	r25, 0x0E	; 14
    1064:	90 93 93 07 	sts	0x0793, r25
    1068:	80 93 92 07 	sts	0x0792, r24
				stove_target_temp = stove_run_hot_temp;
    106c:	88 ea       	ldi	r24, 0xA8	; 168
    106e:	80 93 a8 07 	sts	0x07A8, r24
			}
			stove_cooldown_test(stove_run_hot_temp,stove_mode_warmup_count);
    1072:	88 ea       	ldi	r24, 0xA8	; 168
    1074:	90 e0       	ldi	r25, 0x00	; 0
    1076:	64 e8       	ldi	r22, 0x84	; 132
    1078:	73 e0       	ldi	r23, 0x03	; 3
    107a:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <stove_cooldown_test>
		}
		if (stove_target_temp == stove_run_hot_temp)
    107e:	80 91 a8 07 	lds	r24, 0x07A8
    1082:	88 3a       	cpi	r24, 0xA8	; 168
    1084:	71 f4       	brne	.+28     	; 0x10a2 <stove_control_checks+0xa0>
		{
			stove_cooldown_test(stove_run_med_temp,stove_mode_high_temp_lower_count);
    1086:	8c e8       	ldi	r24, 0x8C	; 140
    1088:	90 e0       	ldi	r25, 0x00	; 0
    108a:	64 e8       	ldi	r22, 0x84	; 132
    108c:	73 e0       	ldi	r23, 0x03	; 3
    108e:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <stove_cooldown_test>
			stove_target_temp_config(stove_run_hot_temp,stove_run_med_temp,stove_mode_high_temp_lower_count);		
    1092:	88 ea       	ldi	r24, 0xA8	; 168
    1094:	90 e0       	ldi	r25, 0x00	; 0
    1096:	6c e8       	ldi	r22, 0x8C	; 140
    1098:	70 e0       	ldi	r23, 0x00	; 0
    109a:	44 e8       	ldi	r20, 0x84	; 132
    109c:	53 e0       	ldi	r21, 0x03	; 3
    109e:	0e 94 2a 06 	call	0xc54	; 0xc54 <stove_target_temp_config>
		}
		if (stove_target_temp == stove_run_med_temp)
    10a2:	80 91 a8 07 	lds	r24, 0x07A8
    10a6:	8c 38       	cpi	r24, 0x8C	; 140
    10a8:	71 f4       	brne	.+28     	; 0x10c6 <stove_control_checks+0xc4>
		{
			stove_cooldown_test(stove_run_cool_temp,stove_mode_med_temp_lower_count);		
    10aa:	84 e6       	ldi	r24, 0x64	; 100
    10ac:	90 e0       	ldi	r25, 0x00	; 0
    10ae:	62 ec       	ldi	r22, 0xC2	; 194
    10b0:	71 e0       	ldi	r23, 0x01	; 1
    10b2:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <stove_cooldown_test>
			stove_target_temp_config(stove_run_hot_temp,stove_run_cool_temp,stove_mode_med_temp_lower_count);
    10b6:	88 ea       	ldi	r24, 0xA8	; 168
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	64 e6       	ldi	r22, 0x64	; 100
    10bc:	70 e0       	ldi	r23, 0x00	; 0
    10be:	42 ec       	ldi	r20, 0xC2	; 194
    10c0:	51 e0       	ldi	r21, 0x01	; 1
    10c2:	0e 94 2a 06 	call	0xc54	; 0xc54 <stove_target_temp_config>
		}
		if (stove_target_temp == stove_run_cool_temp)
    10c6:	80 91 a8 07 	lds	r24, 0x07A8
    10ca:	84 36       	cpi	r24, 0x64	; 100
    10cc:	c9 f4       	brne	.+50     	; 0x1100 <stove_control_checks+0xfe>
		{
			stove_cooldown_test(stove_shutdown_temp,stove_mode_low_temp_lower_count);	
    10ce:	80 e0       	ldi	r24, 0x00	; 0
    10d0:	90 e0       	ldi	r25, 0x00	; 0
    10d2:	64 e8       	ldi	r22, 0x84	; 132
    10d4:	73 e0       	ldi	r23, 0x03	; 3
    10d6:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <stove_cooldown_test>
			stove_target_temp_config(stove_run_med_temp,stove_run_cool_temp,stove_mode_low_temp_lower_count);
    10da:	8c e8       	ldi	r24, 0x8C	; 140
    10dc:	90 e0       	ldi	r25, 0x00	; 0
    10de:	64 e6       	ldi	r22, 0x64	; 100
    10e0:	70 e0       	ldi	r23, 0x00	; 0
    10e2:	44 e8       	ldi	r20, 0x84	; 132
    10e4:	53 e0       	ldi	r21, 0x03	; 3
    10e6:	0e 94 2a 06 	call	0xc54	; 0xc54 <stove_target_temp_config>
			if(stove_cooldown_count >= (stove_mode_low_temp_lower_count/2))
    10ea:	80 91 90 07 	lds	r24, 0x0790
    10ee:	90 91 91 07 	lds	r25, 0x0791
    10f2:	21 e0       	ldi	r18, 0x01	; 1
    10f4:	82 3c       	cpi	r24, 0xC2	; 194
    10f6:	92 07       	cpc	r25, r18
    10f8:	18 f0       	brcs	.+6      	; 0x1100 <stove_control_checks+0xfe>
			{
				stove_target_temp_lockout=stove_run_cool_temp;
    10fa:	84 e6       	ldi	r24, 0x64	; 100
    10fc:	80 93 96 07 	sts	0x0796, r24
			}
		}
		if (stove_target_temp == stove_shutdown_temp)
    1100:	80 91 a8 07 	lds	r24, 0x07A8
    1104:	88 23       	and	r24, r24
    1106:	59 f4       	brne	.+22     	; 0x111e <stove_control_checks+0x11c>
		{
			stove_run_upper_limit=damper_shutdown_pos;
    1108:	80 e0       	ldi	r24, 0x00	; 0
    110a:	9c e2       	ldi	r25, 0x2C	; 44
    110c:	90 93 9e 07 	sts	0x079E, r25
    1110:	80 93 9d 07 	sts	0x079D, r24
			STEPPER_POS=damper_shutdown_pos;
    1114:	90 93 8d 07 	sts	0x078D, r25
    1118:	80 93 8c 07 	sts	0x078C, r24
    111c:	06 c0       	rjmp	.+12     	; 0x112a <stove_control_checks+0x128>
		}
		if (stove_target_temp > stove_target_temp_lockout)
    111e:	90 91 96 07 	lds	r25, 0x0796
    1122:	98 17       	cp	r25, r24
    1124:	10 f4       	brcc	.+4      	; 0x112a <stove_control_checks+0x128>
		{
			stove_target_temp=stove_target_temp_lockout;
    1126:	90 93 a8 07 	sts	0x07A8, r25
		}
		if (stove_mode_start_first == 2)
    112a:	80 91 99 07 	lds	r24, 0x0799
    112e:	82 30       	cpi	r24, 0x02	; 2
    1130:	79 f4       	brne	.+30     	; 0x1150 <stove_control_checks+0x14e>
		{
			vTaskDelay(1000);
    1132:	88 ee       	ldi	r24, 0xE8	; 232
    1134:	93 e0       	ldi	r25, 0x03	; 3
    1136:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
			if (ADC_VALUE2 > stove_back_temp)
    113a:	80 91 0f 07 	lds	r24, 0x070F
    113e:	81 3c       	cpi	r24, 0xC1	; 193
    1140:	18 f0       	brcs	.+6      	; 0x1148 <stove_control_checks+0x146>
			{
				stove_mode_start_first=0;
    1142:	10 92 99 07 	sts	0x0799, r1
    1146:	08 95       	ret
			}
			else
			{
				stove_target_temp=stove_shutdown_temp;
    1148:	10 92 a8 07 	sts	0x07A8, r1
				stove_target_temp_lockout=stove_shutdown_temp;
    114c:	10 92 96 07 	sts	0x0796, r1
    1150:	08 95       	ret

00001152 <stove_control_mode_check>:
	
}

void stove_control_mode_check(void)
{
	switch (stove_target_temp)
    1152:	80 91 a8 07 	lds	r24, 0x07A8
    1156:	8c 38       	cpi	r24, 0x8C	; 140
    1158:	c9 f0       	breq	.+50     	; 0x118c <stove_control_mode_check+0x3a>
    115a:	8d 38       	cpi	r24, 0x8D	; 141
    115c:	28 f4       	brcc	.+10     	; 0x1168 <stove_control_mode_check+0x16>
    115e:	88 23       	and	r24, r24
    1160:	19 f1       	breq	.+70     	; 0x11a8 <stove_control_mode_check+0x56>
    1162:	84 36       	cpi	r24, 0x64	; 100
    1164:	39 f5       	brne	.+78     	; 0x11b4 <stove_control_mode_check+0x62>
    1166:	19 c0       	rjmp	.+50     	; 0x119a <stove_control_mode_check+0x48>
    1168:	88 3a       	cpi	r24, 0xA8	; 168
    116a:	49 f0       	breq	.+18     	; 0x117e <stove_control_mode_check+0x2c>
    116c:	88 3c       	cpi	r24, 0xC8	; 200
    116e:	11 f5       	brne	.+68     	; 0x11b4 <stove_control_mode_check+0x62>
	{
		case stove_start_temp:
			stove_mode &= 0x0f;
    1170:	80 91 9f 07 	lds	r24, 0x079F
    1174:	8f 70       	andi	r24, 0x0F	; 15
			stove_mode |= (MODE_SRT<<4);
    1176:	80 61       	ori	r24, 0x10	; 16
    1178:	80 93 9f 07 	sts	0x079F, r24
		break;
    117c:	1b c0       	rjmp	.+54     	; 0x11b4 <stove_control_mode_check+0x62>
		case stove_run_hot_temp :
			stove_mode &= 0x0f;
    117e:	80 91 9f 07 	lds	r24, 0x079F
    1182:	8f 70       	andi	r24, 0x0F	; 15
			stove_mode |= (MODE_HOT<<4);
    1184:	80 62       	ori	r24, 0x20	; 32
    1186:	80 93 9f 07 	sts	0x079F, r24
		break;
    118a:	14 c0       	rjmp	.+40     	; 0x11b4 <stove_control_mode_check+0x62>
		case stove_run_med_temp :
			stove_mode &= 0x0f;
    118c:	80 91 9f 07 	lds	r24, 0x079F
    1190:	8f 70       	andi	r24, 0x0F	; 15
			stove_mode |= (MODE_MED<<4);	
    1192:	80 63       	ori	r24, 0x30	; 48
    1194:	80 93 9f 07 	sts	0x079F, r24
		break;
    1198:	0d c0       	rjmp	.+26     	; 0x11b4 <stove_control_mode_check+0x62>
		case stove_run_cool_temp :
			stove_mode &= 0x0f;
    119a:	80 91 9f 07 	lds	r24, 0x079F
    119e:	8f 70       	andi	r24, 0x0F	; 15
			stove_mode |= (MODE_LOW<<4);
    11a0:	80 64       	ori	r24, 0x40	; 64
    11a2:	80 93 9f 07 	sts	0x079F, r24
		break;
    11a6:	06 c0       	rjmp	.+12     	; 0x11b4 <stove_control_mode_check+0x62>
		case stove_shutdown_temp :
			stove_mode &= 0x0f;
    11a8:	80 91 9f 07 	lds	r24, 0x079F
			stove_mode |= (MODE_OFF<<4);
    11ac:	83 70       	andi	r24, 0x03	; 3
			stove_mode &= ~((1<<MODE_LED_bit) | (1<<MODE_BEEP_bit));
    11ae:	80 65       	ori	r24, 0x50	; 80
    11b0:	80 93 9f 07 	sts	0x079F, r24
		break;
	}
	if ((stove_mode & 0x03) != MODE_NITE)
    11b4:	80 91 9f 07 	lds	r24, 0x079F
    11b8:	98 2f       	mov	r25, r24
    11ba:	93 70       	andi	r25, 0x03	; 3
    11bc:	91 30       	cpi	r25, 0x01	; 1
    11be:	b1 f0       	breq	.+44     	; 0x11ec <stove_control_mode_check+0x9a>
	{
		if (stove_target_temp_lockout == stove_start_temp)
    11c0:	90 91 96 07 	lds	r25, 0x0796
    11c4:	98 3c       	cpi	r25, 0xC8	; 200
    11c6:	21 f4       	brne	.+8      	; 0x11d0 <stove_control_mode_check+0x7e>
		{
			stove_mode &= 0xFC;
			stove_mode |= MODE_NORM;
			stove_mode &= ~(1<<MODE_LED_bit);
			stove_mode &= ~(1<<MODE_BEEP_bit);
    11c8:	80 7f       	andi	r24, 0xF0	; 240
    11ca:	80 93 9f 07 	sts	0x079F, r24
    11ce:	04 c0       	rjmp	.+8      	; 0x11d8 <stove_control_mode_check+0x86>
		}
		else
		{
			stove_mode &= 0xFC;
    11d0:	8c 7f       	andi	r24, 0xFC	; 252
			stove_mode |= MODE_FEED;
			stove_mode |= (1<<MODE_LED_bit);
			stove_mode |= (1<<MODE_BEEP_bit);
    11d2:	8e 60       	ori	r24, 0x0E	; 14
    11d4:	80 93 9f 07 	sts	0x079F, r24
						
		}
		if (stove_target_temp_lockout == stove_shutdown_temp)
    11d8:	80 91 96 07 	lds	r24, 0x0796
    11dc:	88 23       	and	r24, r24
    11de:	49 f4       	brne	.+18     	; 0x11f2 <stove_control_mode_check+0xa0>
		{
			stove_mode &= ~(1<<MODE_LED_bit);
			stove_mode &= ~(1<<MODE_BEEP_bit);
    11e0:	80 91 9f 07 	lds	r24, 0x079F
    11e4:	83 7f       	andi	r24, 0xF3	; 243
    11e6:	80 93 9f 07 	sts	0x079F, r24
    11ea:	08 95       	ret
		}
	}
	else
	{
		stove_mode &= ~(1<<MODE_LED_bit);
		stove_mode &= ~(1<<MODE_BEEP_bit);
    11ec:	83 7f       	andi	r24, 0xF3	; 243
    11ee:	80 93 9f 07 	sts	0x079F, r24
    11f2:	08 95       	ret

000011f4 <stove_control_led>:
	}
}

void stove_control_led(void)
{
	if ((stove_mode & (1<<MODE_LED_bit)) == (1<<MODE_LED_bit))
    11f4:	80 91 9f 07 	lds	r24, 0x079F
    11f8:	82 ff       	sbrs	r24, 2
    11fa:	02 c0       	rjmp	.+4      	; 0x1200 <stove_control_led+0xc>
	{
		stove_control_led_PORT |= _BV(stove_control_led_PI);
    11fc:	dd 9a       	sbi	0x1b, 5	; 27
    11fe:	01 c0       	rjmp	.+2      	; 0x1202 <stove_control_led+0xe>
	}
	else
	{
		stove_control_led_PORT &= ~(_BV(stove_control_led_PI));
    1200:	dd 98       	cbi	0x1b, 5	; 27
	}

#ifndef DOWN_STAIRS_
	stove_mode_buzzer();
    1202:	0e 94 78 06 	call	0xcf0	; 0xcf0 <stove_mode_buzzer>

	
#endif

}
    1206:	08 95       	ret

00001208 <stove_control>:

void stove_control(void)
{
	for ( ;; )
	{
		vTaskDelay(1000);
    1208:	88 ee       	ldi	r24, 0xE8	; 232
    120a:	93 e0       	ldi	r25, 0x03	; 3
    120c:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
		stove_control_fuzzy(); // call fuzzy control for temp adjust
    1210:	0e 94 81 07 	call	0xf02	; 0xf02 <stove_control_fuzzy>
		stove_control_checks();
    1214:	0e 94 01 08 	call	0x1002	; 0x1002 <stove_control_checks>
		stove_control_mode_check();
    1218:	0e 94 a9 08 	call	0x1152	; 0x1152 <stove_control_mode_check>
		stove_control_led();
    121c:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <stove_control_led>
    1220:	f3 cf       	rjmp	.-26     	; 0x1208 <stove_control>

00001222 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1222:	af 92       	push	r10
    1224:	bf 92       	push	r11
    1226:	cf 92       	push	r12
    1228:	df 92       	push	r13
    122a:	ef 92       	push	r14
    122c:	ff 92       	push	r15
    122e:	0f 93       	push	r16
    1230:	1f 93       	push	r17
    1232:	cf 93       	push	r28
    1234:	df 93       	push	r29
    1236:	6c 01       	movw	r12, r24
    1238:	e6 2e       	mov	r14, r22
    123a:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    123c:	8a e1       	ldi	r24, 0x1A	; 26
    123e:	90 e0       	ldi	r25, 0x00	; 0
    1240:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <pvPortMalloc>
    1244:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
    1246:	00 97       	sbiw	r24, 0x00	; 0
    1248:	09 f4       	brne	.+2      	; 0x124c <xCoRoutineCreate+0x2a>
    124a:	62 c0       	rjmp	.+196    	; 0x1310 <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    124c:	80 91 9b 00 	lds	r24, 0x009B
    1250:	90 91 9c 00 	lds	r25, 0x009C
    1254:	00 97       	sbiw	r24, 0x00	; 0
    1256:	39 f5       	brne	.+78     	; 0x12a6 <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1258:	10 93 9c 00 	sts	0x009C, r17
    125c:	00 93 9b 00 	sts	0x009B, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1260:	ce e9       	ldi	r28, 0x9E	; 158
    1262:	d0 e0       	ldi	r29, 0x00	; 0
    1264:	ce 01       	movw	r24, r28
    1266:	0e 94 36 0b 	call	0x166c	; 0x166c <vListInitialise>
    126a:	ce 01       	movw	r24, r28
    126c:	09 96       	adiw	r24, 0x09	; 9
    126e:	0e 94 36 0b 	call	0x166c	; 0x166c <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    1272:	c0 eb       	ldi	r28, 0xB0	; 176
    1274:	d0 e0       	ldi	r29, 0x00	; 0
    1276:	ce 01       	movw	r24, r28
    1278:	0e 94 36 0b 	call	0x166c	; 0x166c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    127c:	0f 2e       	mov	r0, r31
    127e:	f9 eb       	ldi	r31, 0xB9	; 185
    1280:	af 2e       	mov	r10, r31
    1282:	f0 e0       	ldi	r31, 0x00	; 0
    1284:	bf 2e       	mov	r11, r31
    1286:	f0 2d       	mov	r31, r0
    1288:	c5 01       	movw	r24, r10
    128a:	0e 94 36 0b 	call	0x166c	; 0x166c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    128e:	82 ec       	ldi	r24, 0xC2	; 194
    1290:	90 e0       	ldi	r25, 0x00	; 0
    1292:	0e 94 36 0b 	call	0x166c	; 0x166c <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1296:	d0 93 cc 00 	sts	0x00CC, r29
    129a:	c0 93 cb 00 	sts	0x00CB, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    129e:	b0 92 ce 00 	sts	0x00CE, r11
    12a2:	a0 92 cd 00 	sts	0x00CD, r10
    12a6:	ce 2d       	mov	r28, r14
    12a8:	e1 10       	cpse	r14, r1
    12aa:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    12ac:	f8 01       	movw	r30, r16
    12ae:	11 8e       	std	Z+25, r1	; 0x19
    12b0:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    12b2:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    12b4:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    12b6:	c1 92       	st	Z+, r12
    12b8:	d1 92       	st	Z+, r13
    12ba:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    12bc:	cf 01       	movw	r24, r30
    12be:	0e 94 44 0b 	call	0x1688	; 0x1688 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    12c2:	c8 01       	movw	r24, r16
    12c4:	0c 96       	adiw	r24, 0x0c	; 12
    12c6:	0e 94 44 0b 	call	0x1688	; 0x1688 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    12ca:	f8 01       	movw	r30, r16
    12cc:	11 87       	std	Z+9, r17	; 0x09
    12ce:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    12d0:	13 8b       	std	Z+19, r17	; 0x13
    12d2:	02 8b       	std	Z+18, r16	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    12d4:	84 e0       	ldi	r24, 0x04	; 4
    12d6:	90 e0       	ldi	r25, 0x00	; 0
    12d8:	8c 1b       	sub	r24, r28
    12da:	91 09       	sbc	r25, r1
    12dc:	95 87       	std	Z+13, r25	; 0x0d
    12de:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    12e0:	86 89       	ldd	r24, Z+22	; 0x16
    12e2:	90 91 9d 00 	lds	r25, 0x009D
    12e6:	98 17       	cp	r25, r24
    12e8:	10 f4       	brcc	.+4      	; 0x12ee <xCoRoutineCreate+0xcc>
    12ea:	80 93 9d 00 	sts	0x009D, r24
    12ee:	90 e0       	ldi	r25, 0x00	; 0
    12f0:	9c 01       	movw	r18, r24
    12f2:	22 0f       	add	r18, r18
    12f4:	33 1f       	adc	r19, r19
    12f6:	22 0f       	add	r18, r18
    12f8:	33 1f       	adc	r19, r19
    12fa:	22 0f       	add	r18, r18
    12fc:	33 1f       	adc	r19, r19
    12fe:	82 0f       	add	r24, r18
    1300:	93 1f       	adc	r25, r19
    1302:	82 56       	subi	r24, 0x62	; 98
    1304:	9f 4f       	sbci	r25, 0xFF	; 255
    1306:	b7 01       	movw	r22, r14
    1308:	0e 94 48 0b 	call	0x1690	; 0x1690 <vListInsertEnd>

		xReturn = pdPASS;
    130c:	81 e0       	ldi	r24, 0x01	; 1
    130e:	01 c0       	rjmp	.+2      	; 0x1312 <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1310:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
    1312:	df 91       	pop	r29
    1314:	cf 91       	pop	r28
    1316:	1f 91       	pop	r17
    1318:	0f 91       	pop	r16
    131a:	ff 90       	pop	r15
    131c:	ef 90       	pop	r14
    131e:	df 90       	pop	r13
    1320:	cf 90       	pop	r12
    1322:	bf 90       	pop	r11
    1324:	af 90       	pop	r10
    1326:	08 95       	ret

00001328 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    1328:	0f 93       	push	r16
    132a:	1f 93       	push	r17
    132c:	cf 93       	push	r28
    132e:	df 93       	push	r29
    1330:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1332:	c0 91 cf 00 	lds	r28, 0x00CF
    1336:	d0 91 d0 00 	lds	r29, 0x00D0
    133a:	c8 0f       	add	r28, r24
    133c:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    133e:	80 91 9b 00 	lds	r24, 0x009B
    1342:	90 91 9c 00 	lds	r25, 0x009C
    1346:	02 96       	adiw	r24, 0x02	; 2
    1348:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    134c:	e0 91 9b 00 	lds	r30, 0x009B
    1350:	f0 91 9c 00 	lds	r31, 0x009C
    1354:	d3 83       	std	Z+3, r29	; 0x03
    1356:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1358:	80 91 cf 00 	lds	r24, 0x00CF
    135c:	90 91 d0 00 	lds	r25, 0x00D0
    1360:	c8 17       	cp	r28, r24
    1362:	d9 07       	cpc	r29, r25
    1364:	50 f4       	brcc	.+20     	; 0x137a <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1366:	bf 01       	movw	r22, r30
    1368:	6e 5f       	subi	r22, 0xFE	; 254
    136a:	7f 4f       	sbci	r23, 0xFF	; 255
    136c:	80 91 cd 00 	lds	r24, 0x00CD
    1370:	90 91 ce 00 	lds	r25, 0x00CE
    1374:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <vListInsert>
    1378:	09 c0       	rjmp	.+18     	; 0x138c <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    137a:	bf 01       	movw	r22, r30
    137c:	6e 5f       	subi	r22, 0xFE	; 254
    137e:	7f 4f       	sbci	r23, 0xFF	; 255
    1380:	80 91 cb 00 	lds	r24, 0x00CB
    1384:	90 91 cc 00 	lds	r25, 0x00CC
    1388:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <vListInsert>
	}

	if( pxEventList )
    138c:	01 15       	cp	r16, r1
    138e:	11 05       	cpc	r17, r1
    1390:	49 f0       	breq	.+18     	; 0x13a4 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1392:	60 91 9b 00 	lds	r22, 0x009B
    1396:	70 91 9c 00 	lds	r23, 0x009C
    139a:	64 5f       	subi	r22, 0xF4	; 244
    139c:	7f 4f       	sbci	r23, 0xFF	; 255
    139e:	c8 01       	movw	r24, r16
    13a0:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <vListInsert>
	}
}
    13a4:	df 91       	pop	r29
    13a6:	cf 91       	pop	r28
    13a8:	1f 91       	pop	r17
    13aa:	0f 91       	pop	r16
    13ac:	08 95       	ret

000013ae <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    13ae:	cf 92       	push	r12
    13b0:	df 92       	push	r13
    13b2:	ef 92       	push	r14
    13b4:	ff 92       	push	r15
    13b6:	0f 93       	push	r16
    13b8:	1f 93       	push	r17
    13ba:	cf 93       	push	r28
    13bc:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    13be:	80 91 c2 00 	lds	r24, 0x00C2
    13c2:	88 23       	and	r24, r24
    13c4:	b9 f1       	breq	.+110    	; 0x1434 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    13c6:	0f 2e       	mov	r0, r31
    13c8:	f7 ec       	ldi	r31, 0xC7	; 199
    13ca:	ef 2e       	mov	r14, r31
    13cc:	f0 e0       	ldi	r31, 0x00	; 0
    13ce:	ff 2e       	mov	r15, r31
    13d0:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    13d2:	0f 2e       	mov	r0, r31
    13d4:	f2 ec       	ldi	r31, 0xC2	; 194
    13d6:	cf 2e       	mov	r12, r31
    13d8:	f0 e0       	ldi	r31, 0x00	; 0
    13da:	df 2e       	mov	r13, r31
    13dc:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    13de:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    13e0:	d7 01       	movw	r26, r14
    13e2:	ed 91       	ld	r30, X+
    13e4:	fc 91       	ld	r31, X
    13e6:	c6 81       	ldd	r28, Z+6	; 0x06
    13e8:	d7 81       	ldd	r29, Z+7	; 0x07
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    13ea:	ce 01       	movw	r24, r28
    13ec:	0c 96       	adiw	r24, 0x0c	; 12
    13ee:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    13f2:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    13f4:	8e 01       	movw	r16, r28
    13f6:	0e 5f       	subi	r16, 0xFE	; 254
    13f8:	1f 4f       	sbci	r17, 0xFF	; 255
    13fa:	c8 01       	movw	r24, r16
    13fc:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    1400:	8e 89       	ldd	r24, Y+22	; 0x16
    1402:	90 91 9d 00 	lds	r25, 0x009D
    1406:	98 17       	cp	r25, r24
    1408:	10 f4       	brcc	.+4      	; 0x140e <vCoRoutineSchedule+0x60>
    140a:	80 93 9d 00 	sts	0x009D, r24
    140e:	90 e0       	ldi	r25, 0x00	; 0
    1410:	9c 01       	movw	r18, r24
    1412:	22 0f       	add	r18, r18
    1414:	33 1f       	adc	r19, r19
    1416:	22 0f       	add	r18, r18
    1418:	33 1f       	adc	r19, r19
    141a:	22 0f       	add	r18, r18
    141c:	33 1f       	adc	r19, r19
    141e:	82 0f       	add	r24, r18
    1420:	93 1f       	adc	r25, r19
    1422:	82 56       	subi	r24, 0x62	; 98
    1424:	9f 4f       	sbci	r25, 0xFF	; 255
    1426:	b8 01       	movw	r22, r16
    1428:	0e 94 48 0b 	call	0x1690	; 0x1690 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    142c:	f6 01       	movw	r30, r12
    142e:	80 81       	ld	r24, Z
    1430:	88 23       	and	r24, r24
    1432:	a9 f6       	brne	.-86     	; 0x13de <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1434:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <xTaskGetTickCount>
    1438:	20 91 d1 00 	lds	r18, 0x00D1
    143c:	30 91 d2 00 	lds	r19, 0x00D2
    1440:	82 1b       	sub	r24, r18
    1442:	93 0b       	sbc	r25, r19
    1444:	90 93 d4 00 	sts	0x00D4, r25
    1448:	80 93 d3 00 	sts	0x00D3, r24
    144c:	74 c0       	rjmp	.+232    	; 0x1536 <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    144e:	20 91 cf 00 	lds	r18, 0x00CF
    1452:	30 91 d0 00 	lds	r19, 0x00D0
    1456:	2f 5f       	subi	r18, 0xFF	; 255
    1458:	3f 4f       	sbci	r19, 0xFF	; 255
    145a:	30 93 d0 00 	sts	0x00D0, r19
    145e:	20 93 cf 00 	sts	0x00CF, r18
		xPassedTicks--;
    1462:	01 97       	sbiw	r24, 0x01	; 1
    1464:	90 93 d4 00 	sts	0x00D4, r25
    1468:	80 93 d3 00 	sts	0x00D3, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    146c:	21 15       	cp	r18, r1
    146e:	31 05       	cpc	r19, r1
    1470:	81 f4       	brne	.+32     	; 0x1492 <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1472:	80 91 cb 00 	lds	r24, 0x00CB
    1476:	90 91 cc 00 	lds	r25, 0x00CC
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    147a:	20 91 cd 00 	lds	r18, 0x00CD
    147e:	30 91 ce 00 	lds	r19, 0x00CE
    1482:	30 93 cc 00 	sts	0x00CC, r19
    1486:	20 93 cb 00 	sts	0x00CB, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
    148a:	90 93 ce 00 	sts	0x00CE, r25
    148e:	80 93 cd 00 	sts	0x00CD, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1492:	e0 91 cb 00 	lds	r30, 0x00CB
    1496:	f0 91 cc 00 	lds	r31, 0x00CC
    149a:	80 81       	ld	r24, Z
    149c:	88 23       	and	r24, r24
    149e:	09 f4       	brne	.+2      	; 0x14a2 <vCoRoutineSchedule+0xf4>
    14a0:	4a c0       	rjmp	.+148    	; 0x1536 <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    14a2:	05 80       	ldd	r0, Z+5	; 0x05
    14a4:	f6 81       	ldd	r31, Z+6	; 0x06
    14a6:	e0 2d       	mov	r30, r0
    14a8:	c6 81       	ldd	r28, Z+6	; 0x06
    14aa:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    14ac:	2a 81       	ldd	r18, Y+2	; 0x02
    14ae:	3b 81       	ldd	r19, Y+3	; 0x03
    14b0:	80 91 cf 00 	lds	r24, 0x00CF
    14b4:	90 91 d0 00 	lds	r25, 0x00D0
    14b8:	82 17       	cp	r24, r18
    14ba:	93 07       	cpc	r25, r19
    14bc:	78 f4       	brcc	.+30     	; 0x14dc <vCoRoutineSchedule+0x12e>
    14be:	3b c0       	rjmp	.+118    	; 0x1536 <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    14c0:	05 80       	ldd	r0, Z+5	; 0x05
    14c2:	f6 81       	ldd	r31, Z+6	; 0x06
    14c4:	e0 2d       	mov	r30, r0
    14c6:	c6 81       	ldd	r28, Z+6	; 0x06
    14c8:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    14ca:	2a 81       	ldd	r18, Y+2	; 0x02
    14cc:	3b 81       	ldd	r19, Y+3	; 0x03
    14ce:	80 91 cf 00 	lds	r24, 0x00CF
    14d2:	90 91 d0 00 	lds	r25, 0x00D0
    14d6:	82 17       	cp	r24, r18
    14d8:	93 07       	cpc	r25, r19
    14da:	68 f1       	brcs	.+90     	; 0x1536 <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    14dc:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
    14de:	8e 01       	movw	r16, r28
    14e0:	0e 5f       	subi	r16, 0xFE	; 254
    14e2:	1f 4f       	sbci	r17, 0xFF	; 255
    14e4:	c8 01       	movw	r24, r16
    14e6:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    14ea:	8c 89       	ldd	r24, Y+20	; 0x14
    14ec:	9d 89       	ldd	r25, Y+21	; 0x15
    14ee:	00 97       	sbiw	r24, 0x00	; 0
    14f0:	21 f0       	breq	.+8      	; 0x14fa <vCoRoutineSchedule+0x14c>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
    14f2:	ce 01       	movw	r24, r28
    14f4:	0c 96       	adiw	r24, 0x0c	; 12
    14f6:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    14fa:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    14fc:	8e 89       	ldd	r24, Y+22	; 0x16
    14fe:	90 91 9d 00 	lds	r25, 0x009D
    1502:	98 17       	cp	r25, r24
    1504:	10 f4       	brcc	.+4      	; 0x150a <vCoRoutineSchedule+0x15c>
    1506:	80 93 9d 00 	sts	0x009D, r24
    150a:	90 e0       	ldi	r25, 0x00	; 0
    150c:	9c 01       	movw	r18, r24
    150e:	22 0f       	add	r18, r18
    1510:	33 1f       	adc	r19, r19
    1512:	22 0f       	add	r18, r18
    1514:	33 1f       	adc	r19, r19
    1516:	22 0f       	add	r18, r18
    1518:	33 1f       	adc	r19, r19
    151a:	82 0f       	add	r24, r18
    151c:	93 1f       	adc	r25, r19
    151e:	82 56       	subi	r24, 0x62	; 98
    1520:	9f 4f       	sbci	r25, 0xFF	; 255
    1522:	b8 01       	movw	r22, r16
    1524:	0e 94 48 0b 	call	0x1690	; 0x1690 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1528:	e0 91 cb 00 	lds	r30, 0x00CB
    152c:	f0 91 cc 00 	lds	r31, 0x00CC
    1530:	80 81       	ld	r24, Z
    1532:	88 23       	and	r24, r24
    1534:	29 f6       	brne	.-118    	; 0x14c0 <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1536:	80 91 d3 00 	lds	r24, 0x00D3
    153a:	90 91 d4 00 	lds	r25, 0x00D4
    153e:	00 97       	sbiw	r24, 0x00	; 0
    1540:	09 f0       	breq	.+2      	; 0x1544 <vCoRoutineSchedule+0x196>
    1542:	85 cf       	rjmp	.-246    	; 0x144e <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    1544:	80 91 cf 00 	lds	r24, 0x00CF
    1548:	90 91 d0 00 	lds	r25, 0x00D0
    154c:	90 93 d2 00 	sts	0x00D2, r25
    1550:	80 93 d1 00 	sts	0x00D1, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1554:	20 91 9d 00 	lds	r18, 0x009D
    1558:	82 2f       	mov	r24, r18
    155a:	90 e0       	ldi	r25, 0x00	; 0
    155c:	fc 01       	movw	r30, r24
    155e:	ee 0f       	add	r30, r30
    1560:	ff 1f       	adc	r31, r31
    1562:	ee 0f       	add	r30, r30
    1564:	ff 1f       	adc	r31, r31
    1566:	ee 0f       	add	r30, r30
    1568:	ff 1f       	adc	r31, r31
    156a:	e8 0f       	add	r30, r24
    156c:	f9 1f       	adc	r31, r25
    156e:	e2 56       	subi	r30, 0x62	; 98
    1570:	ff 4f       	sbci	r31, 0xFF	; 255
    1572:	30 81       	ld	r19, Z
    1574:	33 23       	and	r19, r19
    1576:	d9 f4       	brne	.+54     	; 0x15ae <vCoRoutineSchedule+0x200>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1578:	22 23       	and	r18, r18
    157a:	31 f4       	brne	.+12     	; 0x1588 <vCoRoutineSchedule+0x1da>
    157c:	47 c0       	rjmp	.+142    	; 0x160c <vCoRoutineSchedule+0x25e>
    157e:	22 23       	and	r18, r18
    1580:	19 f4       	brne	.+6      	; 0x1588 <vCoRoutineSchedule+0x1da>
    1582:	20 93 9d 00 	sts	0x009D, r18
    1586:	42 c0       	rjmp	.+132    	; 0x160c <vCoRoutineSchedule+0x25e>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1588:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    158a:	82 2f       	mov	r24, r18
    158c:	90 e0       	ldi	r25, 0x00	; 0
    158e:	fc 01       	movw	r30, r24
    1590:	ee 0f       	add	r30, r30
    1592:	ff 1f       	adc	r31, r31
    1594:	ee 0f       	add	r30, r30
    1596:	ff 1f       	adc	r31, r31
    1598:	ee 0f       	add	r30, r30
    159a:	ff 1f       	adc	r31, r31
    159c:	e8 0f       	add	r30, r24
    159e:	f9 1f       	adc	r31, r25
    15a0:	e2 56       	subi	r30, 0x62	; 98
    15a2:	ff 4f       	sbci	r31, 0xFF	; 255
    15a4:	30 81       	ld	r19, Z
    15a6:	33 23       	and	r19, r19
    15a8:	51 f3       	breq	.-44     	; 0x157e <vCoRoutineSchedule+0x1d0>
    15aa:	20 93 9d 00 	sts	0x009D, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    15ae:	fc 01       	movw	r30, r24
    15b0:	ee 0f       	add	r30, r30
    15b2:	ff 1f       	adc	r31, r31
    15b4:	ee 0f       	add	r30, r30
    15b6:	ff 1f       	adc	r31, r31
    15b8:	ee 0f       	add	r30, r30
    15ba:	ff 1f       	adc	r31, r31
    15bc:	8e 0f       	add	r24, r30
    15be:	9f 1f       	adc	r25, r31
    15c0:	fc 01       	movw	r30, r24
    15c2:	e2 56       	subi	r30, 0x62	; 98
    15c4:	ff 4f       	sbci	r31, 0xFF	; 255
    15c6:	a1 81       	ldd	r26, Z+1	; 0x01
    15c8:	b2 81       	ldd	r27, Z+2	; 0x02
    15ca:	12 96       	adiw	r26, 0x02	; 2
    15cc:	0d 90       	ld	r0, X+
    15ce:	bc 91       	ld	r27, X
    15d0:	a0 2d       	mov	r26, r0
    15d2:	b2 83       	std	Z+2, r27	; 0x02
    15d4:	a1 83       	std	Z+1, r26	; 0x01
    15d6:	cf 01       	movw	r24, r30
    15d8:	03 96       	adiw	r24, 0x03	; 3
    15da:	a8 17       	cp	r26, r24
    15dc:	b9 07       	cpc	r27, r25
    15de:	31 f4       	brne	.+12     	; 0x15ec <vCoRoutineSchedule+0x23e>
    15e0:	12 96       	adiw	r26, 0x02	; 2
    15e2:	8d 91       	ld	r24, X+
    15e4:	9c 91       	ld	r25, X
    15e6:	13 97       	sbiw	r26, 0x03	; 3
    15e8:	92 83       	std	Z+2, r25	; 0x02
    15ea:	81 83       	std	Z+1, r24	; 0x01
    15ec:	01 80       	ldd	r0, Z+1	; 0x01
    15ee:	f2 81       	ldd	r31, Z+2	; 0x02
    15f0:	e0 2d       	mov	r30, r0
    15f2:	a6 81       	ldd	r26, Z+6	; 0x06
    15f4:	b7 81       	ldd	r27, Z+7	; 0x07
    15f6:	b0 93 9c 00 	sts	0x009C, r27
    15fa:	a0 93 9b 00 	sts	0x009B, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    15fe:	ed 91       	ld	r30, X+
    1600:	fc 91       	ld	r31, X
    1602:	11 97       	sbiw	r26, 0x01	; 1
    1604:	cd 01       	movw	r24, r26
    1606:	57 96       	adiw	r26, 0x17	; 23
    1608:	6c 91       	ld	r22, X
    160a:	09 95       	icall

	return;
}
    160c:	df 91       	pop	r29
    160e:	cf 91       	pop	r28
    1610:	1f 91       	pop	r17
    1612:	0f 91       	pop	r16
    1614:	ff 90       	pop	r15
    1616:	ef 90       	pop	r14
    1618:	df 90       	pop	r13
    161a:	cf 90       	pop	r12
    161c:	08 95       	ret

0000161e <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    161e:	0f 93       	push	r16
    1620:	1f 93       	push	r17
    1622:	cf 93       	push	r28
    1624:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1626:	dc 01       	movw	r26, r24
    1628:	15 96       	adiw	r26, 0x05	; 5
    162a:	ed 91       	ld	r30, X+
    162c:	fc 91       	ld	r31, X
    162e:	16 97       	sbiw	r26, 0x06	; 6
    1630:	06 81       	ldd	r16, Z+6	; 0x06
    1632:	17 81       	ldd	r17, Z+7	; 0x07
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1634:	e8 01       	movw	r28, r16
    1636:	2c 96       	adiw	r28, 0x0c	; 12
    1638:	ce 01       	movw	r24, r28
    163a:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    163e:	82 ec       	ldi	r24, 0xC2	; 194
    1640:	90 e0       	ldi	r25, 0x00	; 0
    1642:	be 01       	movw	r22, r28
    1644:	0e 94 48 0b 	call	0x1690	; 0x1690 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1648:	e0 91 9b 00 	lds	r30, 0x009B
    164c:	f0 91 9c 00 	lds	r31, 0x009C
	{
		xReturn = pdTRUE;
    1650:	81 e0       	ldi	r24, 0x01	; 1
    1652:	d8 01       	movw	r26, r16
    1654:	56 96       	adiw	r26, 0x16	; 22
    1656:	2c 91       	ld	r18, X
    1658:	56 97       	sbiw	r26, 0x16	; 22
    165a:	96 89       	ldd	r25, Z+22	; 0x16
    165c:	29 17       	cp	r18, r25
    165e:	08 f4       	brcc	.+2      	; 0x1662 <xCoRoutineRemoveFromEventList+0x44>
    1660:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1662:	df 91       	pop	r29
    1664:	cf 91       	pop	r28
    1666:	1f 91       	pop	r17
    1668:	0f 91       	pop	r16
    166a:	08 95       	ret

0000166c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    166c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    166e:	03 96       	adiw	r24, 0x03	; 3
    1670:	92 83       	std	Z+2, r25	; 0x02
    1672:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1674:	2f ef       	ldi	r18, 0xFF	; 255
    1676:	3f ef       	ldi	r19, 0xFF	; 255
    1678:	34 83       	std	Z+4, r19	; 0x04
    167a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    167c:	96 83       	std	Z+6, r25	; 0x06
    167e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1680:	90 87       	std	Z+8, r25	; 0x08
    1682:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1684:	10 82       	st	Z, r1
}
    1686:	08 95       	ret

00001688 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1688:	fc 01       	movw	r30, r24
    168a:	11 86       	std	Z+9, r1	; 0x09
    168c:	10 86       	std	Z+8, r1	; 0x08
}
    168e:	08 95       	ret

00001690 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1690:	cf 93       	push	r28
    1692:	df 93       	push	r29
    1694:	ec 01       	movw	r28, r24
    1696:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1698:	89 81       	ldd	r24, Y+1	; 0x01
    169a:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    169c:	dc 01       	movw	r26, r24
    169e:	12 96       	adiw	r26, 0x02	; 2
    16a0:	2d 91       	ld	r18, X+
    16a2:	3c 91       	ld	r19, X
    16a4:	13 97       	sbiw	r26, 0x03	; 3
    16a6:	33 83       	std	Z+3, r19	; 0x03
    16a8:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    16aa:	29 81       	ldd	r18, Y+1	; 0x01
    16ac:	3a 81       	ldd	r19, Y+2	; 0x02
    16ae:	35 83       	std	Z+5, r19	; 0x05
    16b0:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    16b2:	12 96       	adiw	r26, 0x02	; 2
    16b4:	2d 91       	ld	r18, X+
    16b6:	3c 91       	ld	r19, X
    16b8:	13 97       	sbiw	r26, 0x03	; 3
    16ba:	d9 01       	movw	r26, r18
    16bc:	15 96       	adiw	r26, 0x05	; 5
    16be:	7c 93       	st	X, r23
    16c0:	6e 93       	st	-X, r22
    16c2:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    16c4:	dc 01       	movw	r26, r24
    16c6:	13 96       	adiw	r26, 0x03	; 3
    16c8:	7c 93       	st	X, r23
    16ca:	6e 93       	st	-X, r22
    16cc:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    16ce:	7a 83       	std	Y+2, r23	; 0x02
    16d0:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    16d2:	d1 87       	std	Z+9, r29	; 0x09
    16d4:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
    16d6:	88 81       	ld	r24, Y
    16d8:	8f 5f       	subi	r24, 0xFF	; 255
    16da:	88 83       	st	Y, r24
}
    16dc:	df 91       	pop	r29
    16de:	cf 91       	pop	r28
    16e0:	08 95       	ret

000016e2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    16e2:	cf 93       	push	r28
    16e4:	df 93       	push	r29
    16e6:	ac 01       	movw	r20, r24
    16e8:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    16ea:	28 81       	ld	r18, Y
    16ec:	39 81       	ldd	r19, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    16ee:	8f ef       	ldi	r24, 0xFF	; 255
    16f0:	2f 3f       	cpi	r18, 0xFF	; 255
    16f2:	38 07       	cpc	r19, r24
    16f4:	21 f4       	brne	.+8      	; 0x16fe <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    16f6:	fa 01       	movw	r30, r20
    16f8:	a7 81       	ldd	r26, Z+7	; 0x07
    16fa:	b0 85       	ldd	r27, Z+8	; 0x08
    16fc:	18 c0       	rjmp	.+48     	; 0x172e <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    16fe:	da 01       	movw	r26, r20
    1700:	13 96       	adiw	r26, 0x03	; 3
    1702:	fa 01       	movw	r30, r20
    1704:	85 81       	ldd	r24, Z+5	; 0x05
    1706:	96 81       	ldd	r25, Z+6	; 0x06
    1708:	fc 01       	movw	r30, r24
    170a:	80 81       	ld	r24, Z
    170c:	91 81       	ldd	r25, Z+1	; 0x01
    170e:	28 17       	cp	r18, r24
    1710:	39 07       	cpc	r19, r25
    1712:	68 f0       	brcs	.+26     	; 0x172e <vListInsert+0x4c>
    1714:	12 96       	adiw	r26, 0x02	; 2
    1716:	0d 90       	ld	r0, X+
    1718:	bc 91       	ld	r27, X
    171a:	a0 2d       	mov	r26, r0
    171c:	12 96       	adiw	r26, 0x02	; 2
    171e:	ed 91       	ld	r30, X+
    1720:	fc 91       	ld	r31, X
    1722:	13 97       	sbiw	r26, 0x03	; 3
    1724:	80 81       	ld	r24, Z
    1726:	91 81       	ldd	r25, Z+1	; 0x01
    1728:	28 17       	cp	r18, r24
    172a:	39 07       	cpc	r19, r25
    172c:	98 f7       	brcc	.-26     	; 0x1714 <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    172e:	12 96       	adiw	r26, 0x02	; 2
    1730:	ed 91       	ld	r30, X+
    1732:	fc 91       	ld	r31, X
    1734:	13 97       	sbiw	r26, 0x03	; 3
    1736:	fb 83       	std	Y+3, r31	; 0x03
    1738:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    173a:	d5 83       	std	Z+5, r29	; 0x05
    173c:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    173e:	bd 83       	std	Y+5, r27	; 0x05
    1740:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1742:	13 96       	adiw	r26, 0x03	; 3
    1744:	dc 93       	st	X, r29
    1746:	ce 93       	st	-X, r28
    1748:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    174a:	59 87       	std	Y+9, r21	; 0x09
    174c:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
    174e:	fa 01       	movw	r30, r20
    1750:	80 81       	ld	r24, Z
    1752:	8f 5f       	subi	r24, 0xFF	; 255
    1754:	80 83       	st	Z, r24
}
    1756:	df 91       	pop	r29
    1758:	cf 91       	pop	r28
    175a:	08 95       	ret

0000175c <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    175c:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    175e:	a2 81       	ldd	r26, Z+2	; 0x02
    1760:	b3 81       	ldd	r27, Z+3	; 0x03
    1762:	84 81       	ldd	r24, Z+4	; 0x04
    1764:	95 81       	ldd	r25, Z+5	; 0x05
    1766:	15 96       	adiw	r26, 0x05	; 5
    1768:	9c 93       	st	X, r25
    176a:	8e 93       	st	-X, r24
    176c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    176e:	a4 81       	ldd	r26, Z+4	; 0x04
    1770:	b5 81       	ldd	r27, Z+5	; 0x05
    1772:	82 81       	ldd	r24, Z+2	; 0x02
    1774:	93 81       	ldd	r25, Z+3	; 0x03
    1776:	13 96       	adiw	r26, 0x03	; 3
    1778:	9c 93       	st	X, r25
    177a:	8e 93       	st	-X, r24
    177c:	12 97       	sbiw	r26, 0x02	; 2

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    177e:	a0 85       	ldd	r26, Z+8	; 0x08
    1780:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1782:	11 96       	adiw	r26, 0x01	; 1
    1784:	8d 91       	ld	r24, X+
    1786:	9c 91       	ld	r25, X
    1788:	12 97       	sbiw	r26, 0x02	; 2
    178a:	8e 17       	cp	r24, r30
    178c:	9f 07       	cpc	r25, r31
    178e:	31 f4       	brne	.+12     	; 0x179c <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1790:	84 81       	ldd	r24, Z+4	; 0x04
    1792:	95 81       	ldd	r25, Z+5	; 0x05
    1794:	12 96       	adiw	r26, 0x02	; 2
    1796:	9c 93       	st	X, r25
    1798:	8e 93       	st	-X, r24
    179a:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    179c:	11 86       	std	Z+9, r1	; 0x09
    179e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    17a0:	8c 91       	ld	r24, X
    17a2:	81 50       	subi	r24, 0x01	; 1
    17a4:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    17a6:	8c 91       	ld	r24, X
}
    17a8:	08 95       	ret

000017aa <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    17aa:	21 e1       	ldi	r18, 0x11	; 17
    17ac:	fc 01       	movw	r30, r24
    17ae:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    17b0:	31 97       	sbiw	r30, 0x01	; 1
    17b2:	32 e2       	ldi	r19, 0x22	; 34
    17b4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    17b6:	fc 01       	movw	r30, r24
    17b8:	32 97       	sbiw	r30, 0x02	; 2
    17ba:	a3 e3       	ldi	r26, 0x33	; 51
    17bc:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    17be:	fc 01       	movw	r30, r24
    17c0:	33 97       	sbiw	r30, 0x03	; 3
    17c2:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    17c4:	fc 01       	movw	r30, r24
    17c6:	34 97       	sbiw	r30, 0x04	; 4
    17c8:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    17ca:	fc 01       	movw	r30, r24
    17cc:	35 97       	sbiw	r30, 0x05	; 5
    17ce:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    17d0:	fc 01       	movw	r30, r24
    17d2:	36 97       	sbiw	r30, 0x06	; 6
    17d4:	60 e8       	ldi	r22, 0x80	; 128
    17d6:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    17d8:	fc 01       	movw	r30, r24
    17da:	37 97       	sbiw	r30, 0x07	; 7
    17dc:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    17de:	fc 01       	movw	r30, r24
    17e0:	38 97       	sbiw	r30, 0x08	; 8
    17e2:	62 e0       	ldi	r22, 0x02	; 2
    17e4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    17e6:	fc 01       	movw	r30, r24
    17e8:	39 97       	sbiw	r30, 0x09	; 9
    17ea:	63 e0       	ldi	r22, 0x03	; 3
    17ec:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    17ee:	fc 01       	movw	r30, r24
    17f0:	3a 97       	sbiw	r30, 0x0a	; 10
    17f2:	64 e0       	ldi	r22, 0x04	; 4
    17f4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    17f6:	fc 01       	movw	r30, r24
    17f8:	3b 97       	sbiw	r30, 0x0b	; 11
    17fa:	65 e0       	ldi	r22, 0x05	; 5
    17fc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    17fe:	fc 01       	movw	r30, r24
    1800:	3c 97       	sbiw	r30, 0x0c	; 12
    1802:	66 e0       	ldi	r22, 0x06	; 6
    1804:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    1806:	fc 01       	movw	r30, r24
    1808:	3d 97       	sbiw	r30, 0x0d	; 13
    180a:	67 e0       	ldi	r22, 0x07	; 7
    180c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    180e:	fc 01       	movw	r30, r24
    1810:	3e 97       	sbiw	r30, 0x0e	; 14
    1812:	68 e0       	ldi	r22, 0x08	; 8
    1814:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1816:	fc 01       	movw	r30, r24
    1818:	3f 97       	sbiw	r30, 0x0f	; 15
    181a:	69 e0       	ldi	r22, 0x09	; 9
    181c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    181e:	fc 01       	movw	r30, r24
    1820:	70 97       	sbiw	r30, 0x10	; 16
    1822:	60 e1       	ldi	r22, 0x10	; 16
    1824:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1826:	fc 01       	movw	r30, r24
    1828:	71 97       	sbiw	r30, 0x11	; 17
    182a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    182c:	fc 01       	movw	r30, r24
    182e:	72 97       	sbiw	r30, 0x12	; 18
    1830:	22 e1       	ldi	r18, 0x12	; 18
    1832:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1834:	fc 01       	movw	r30, r24
    1836:	73 97       	sbiw	r30, 0x13	; 19
    1838:	23 e1       	ldi	r18, 0x13	; 19
    183a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    183c:	fc 01       	movw	r30, r24
    183e:	74 97       	sbiw	r30, 0x14	; 20
    1840:	24 e1       	ldi	r18, 0x14	; 20
    1842:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1844:	fc 01       	movw	r30, r24
    1846:	75 97       	sbiw	r30, 0x15	; 21
    1848:	25 e1       	ldi	r18, 0x15	; 21
    184a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    184c:	fc 01       	movw	r30, r24
    184e:	76 97       	sbiw	r30, 0x16	; 22
    1850:	26 e1       	ldi	r18, 0x16	; 22
    1852:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1854:	fc 01       	movw	r30, r24
    1856:	77 97       	sbiw	r30, 0x17	; 23
    1858:	27 e1       	ldi	r18, 0x17	; 23
    185a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    185c:	fc 01       	movw	r30, r24
    185e:	78 97       	sbiw	r30, 0x18	; 24
    1860:	28 e1       	ldi	r18, 0x18	; 24
    1862:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1864:	fc 01       	movw	r30, r24
    1866:	79 97       	sbiw	r30, 0x19	; 25
    1868:	29 e1       	ldi	r18, 0x19	; 25
    186a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    186c:	fc 01       	movw	r30, r24
    186e:	7a 97       	sbiw	r30, 0x1a	; 26
    1870:	20 e2       	ldi	r18, 0x20	; 32
    1872:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1874:	fc 01       	movw	r30, r24
    1876:	7b 97       	sbiw	r30, 0x1b	; 27
    1878:	21 e2       	ldi	r18, 0x21	; 33
    187a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    187c:	fc 01       	movw	r30, r24
    187e:	7c 97       	sbiw	r30, 0x1c	; 28
    1880:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1882:	fc 01       	movw	r30, r24
    1884:	7d 97       	sbiw	r30, 0x1d	; 29
    1886:	23 e2       	ldi	r18, 0x23	; 35
    1888:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    188a:	fc 01       	movw	r30, r24
    188c:	7e 97       	sbiw	r30, 0x1e	; 30
    188e:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1890:	fc 01       	movw	r30, r24
    1892:	7f 97       	sbiw	r30, 0x1f	; 31
    1894:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1896:	fc 01       	movw	r30, r24
    1898:	b0 97       	sbiw	r30, 0x20	; 32
    189a:	26 e2       	ldi	r18, 0x26	; 38
    189c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    189e:	fc 01       	movw	r30, r24
    18a0:	b1 97       	sbiw	r30, 0x21	; 33
    18a2:	27 e2       	ldi	r18, 0x27	; 39
    18a4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    18a6:	fc 01       	movw	r30, r24
    18a8:	b2 97       	sbiw	r30, 0x22	; 34
    18aa:	28 e2       	ldi	r18, 0x28	; 40
    18ac:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    18ae:	fc 01       	movw	r30, r24
    18b0:	b3 97       	sbiw	r30, 0x23	; 35
    18b2:	29 e2       	ldi	r18, 0x29	; 41
    18b4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    18b6:	fc 01       	movw	r30, r24
    18b8:	b4 97       	sbiw	r30, 0x24	; 36
    18ba:	20 e3       	ldi	r18, 0x30	; 48
    18bc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    18be:	fc 01       	movw	r30, r24
    18c0:	b5 97       	sbiw	r30, 0x25	; 37
    18c2:	21 e3       	ldi	r18, 0x31	; 49
    18c4:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    18c6:	86 97       	sbiw	r24, 0x26	; 38
}
    18c8:	08 95       	ret

000018ca <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    18ca:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    18cc:	8c e7       	ldi	r24, 0x7C	; 124
    18ce:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    18d0:	8b e0       	ldi	r24, 0x0B	; 11
    18d2:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    18d4:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    18d6:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    18d8:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    18da:	a0 91 b3 06 	lds	r26, 0x06B3
    18de:	b0 91 b4 06 	lds	r27, 0x06B4
    18e2:	cd 91       	ld	r28, X+
    18e4:	cd bf       	out	0x3d, r28	; 61
    18e6:	dd 91       	ld	r29, X+
    18e8:	de bf       	out	0x3e, r29	; 62
    18ea:	ff 91       	pop	r31
    18ec:	ef 91       	pop	r30
    18ee:	df 91       	pop	r29
    18f0:	cf 91       	pop	r28
    18f2:	bf 91       	pop	r27
    18f4:	af 91       	pop	r26
    18f6:	9f 91       	pop	r25
    18f8:	8f 91       	pop	r24
    18fa:	7f 91       	pop	r23
    18fc:	6f 91       	pop	r22
    18fe:	5f 91       	pop	r21
    1900:	4f 91       	pop	r20
    1902:	3f 91       	pop	r19
    1904:	2f 91       	pop	r18
    1906:	1f 91       	pop	r17
    1908:	0f 91       	pop	r16
    190a:	ff 90       	pop	r15
    190c:	ef 90       	pop	r14
    190e:	df 90       	pop	r13
    1910:	cf 90       	pop	r12
    1912:	bf 90       	pop	r11
    1914:	af 90       	pop	r10
    1916:	9f 90       	pop	r9
    1918:	8f 90       	pop	r8
    191a:	7f 90       	pop	r7
    191c:	6f 90       	pop	r6
    191e:	5f 90       	pop	r5
    1920:	4f 90       	pop	r4
    1922:	3f 90       	pop	r3
    1924:	2f 90       	pop	r2
    1926:	1f 90       	pop	r1
    1928:	0f 90       	pop	r0
    192a:	0f be       	out	0x3f, r0	; 63
    192c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    192e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1930:	81 e0       	ldi	r24, 0x01	; 1
    1932:	08 95       	ret

00001934 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1934:	08 95       	ret

00001936 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1936:	0f 92       	push	r0
    1938:	0f b6       	in	r0, 0x3f	; 63
    193a:	f8 94       	cli
    193c:	0f 92       	push	r0
    193e:	1f 92       	push	r1
    1940:	11 24       	eor	r1, r1
    1942:	2f 92       	push	r2
    1944:	3f 92       	push	r3
    1946:	4f 92       	push	r4
    1948:	5f 92       	push	r5
    194a:	6f 92       	push	r6
    194c:	7f 92       	push	r7
    194e:	8f 92       	push	r8
    1950:	9f 92       	push	r9
    1952:	af 92       	push	r10
    1954:	bf 92       	push	r11
    1956:	cf 92       	push	r12
    1958:	df 92       	push	r13
    195a:	ef 92       	push	r14
    195c:	ff 92       	push	r15
    195e:	0f 93       	push	r16
    1960:	1f 93       	push	r17
    1962:	2f 93       	push	r18
    1964:	3f 93       	push	r19
    1966:	4f 93       	push	r20
    1968:	5f 93       	push	r21
    196a:	6f 93       	push	r22
    196c:	7f 93       	push	r23
    196e:	8f 93       	push	r24
    1970:	9f 93       	push	r25
    1972:	af 93       	push	r26
    1974:	bf 93       	push	r27
    1976:	cf 93       	push	r28
    1978:	df 93       	push	r29
    197a:	ef 93       	push	r30
    197c:	ff 93       	push	r31
    197e:	a0 91 b3 06 	lds	r26, 0x06B3
    1982:	b0 91 b4 06 	lds	r27, 0x06B4
    1986:	0d b6       	in	r0, 0x3d	; 61
    1988:	0d 92       	st	X+, r0
    198a:	0e b6       	in	r0, 0x3e	; 62
    198c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    198e:	0e 94 91 15 	call	0x2b22	; 0x2b22 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1992:	a0 91 b3 06 	lds	r26, 0x06B3
    1996:	b0 91 b4 06 	lds	r27, 0x06B4
    199a:	cd 91       	ld	r28, X+
    199c:	cd bf       	out	0x3d, r28	; 61
    199e:	dd 91       	ld	r29, X+
    19a0:	de bf       	out	0x3e, r29	; 62
    19a2:	ff 91       	pop	r31
    19a4:	ef 91       	pop	r30
    19a6:	df 91       	pop	r29
    19a8:	cf 91       	pop	r28
    19aa:	bf 91       	pop	r27
    19ac:	af 91       	pop	r26
    19ae:	9f 91       	pop	r25
    19b0:	8f 91       	pop	r24
    19b2:	7f 91       	pop	r23
    19b4:	6f 91       	pop	r22
    19b6:	5f 91       	pop	r21
    19b8:	4f 91       	pop	r20
    19ba:	3f 91       	pop	r19
    19bc:	2f 91       	pop	r18
    19be:	1f 91       	pop	r17
    19c0:	0f 91       	pop	r16
    19c2:	ff 90       	pop	r15
    19c4:	ef 90       	pop	r14
    19c6:	df 90       	pop	r13
    19c8:	cf 90       	pop	r12
    19ca:	bf 90       	pop	r11
    19cc:	af 90       	pop	r10
    19ce:	9f 90       	pop	r9
    19d0:	8f 90       	pop	r8
    19d2:	7f 90       	pop	r7
    19d4:	6f 90       	pop	r6
    19d6:	5f 90       	pop	r5
    19d8:	4f 90       	pop	r4
    19da:	3f 90       	pop	r3
    19dc:	2f 90       	pop	r2
    19de:	1f 90       	pop	r1
    19e0:	0f 90       	pop	r0
    19e2:	0f be       	out	0x3f, r0	; 63
    19e4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    19e6:	08 95       	ret

000019e8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    19e8:	0f 92       	push	r0
    19ea:	0f b6       	in	r0, 0x3f	; 63
    19ec:	f8 94       	cli
    19ee:	0f 92       	push	r0
    19f0:	1f 92       	push	r1
    19f2:	11 24       	eor	r1, r1
    19f4:	2f 92       	push	r2
    19f6:	3f 92       	push	r3
    19f8:	4f 92       	push	r4
    19fa:	5f 92       	push	r5
    19fc:	6f 92       	push	r6
    19fe:	7f 92       	push	r7
    1a00:	8f 92       	push	r8
    1a02:	9f 92       	push	r9
    1a04:	af 92       	push	r10
    1a06:	bf 92       	push	r11
    1a08:	cf 92       	push	r12
    1a0a:	df 92       	push	r13
    1a0c:	ef 92       	push	r14
    1a0e:	ff 92       	push	r15
    1a10:	0f 93       	push	r16
    1a12:	1f 93       	push	r17
    1a14:	2f 93       	push	r18
    1a16:	3f 93       	push	r19
    1a18:	4f 93       	push	r20
    1a1a:	5f 93       	push	r21
    1a1c:	6f 93       	push	r22
    1a1e:	7f 93       	push	r23
    1a20:	8f 93       	push	r24
    1a22:	9f 93       	push	r25
    1a24:	af 93       	push	r26
    1a26:	bf 93       	push	r27
    1a28:	cf 93       	push	r28
    1a2a:	df 93       	push	r29
    1a2c:	ef 93       	push	r30
    1a2e:	ff 93       	push	r31
    1a30:	a0 91 b3 06 	lds	r26, 0x06B3
    1a34:	b0 91 b4 06 	lds	r27, 0x06B4
    1a38:	0d b6       	in	r0, 0x3d	; 61
    1a3a:	0d 92       	st	X+, r0
    1a3c:	0e b6       	in	r0, 0x3e	; 62
    1a3e:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1a40:	0e 94 8e 13 	call	0x271c	; 0x271c <vTaskIncrementTick>
	vTaskSwitchContext();
    1a44:	0e 94 91 15 	call	0x2b22	; 0x2b22 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1a48:	a0 91 b3 06 	lds	r26, 0x06B3
    1a4c:	b0 91 b4 06 	lds	r27, 0x06B4
    1a50:	cd 91       	ld	r28, X+
    1a52:	cd bf       	out	0x3d, r28	; 61
    1a54:	dd 91       	ld	r29, X+
    1a56:	de bf       	out	0x3e, r29	; 62
    1a58:	ff 91       	pop	r31
    1a5a:	ef 91       	pop	r30
    1a5c:	df 91       	pop	r29
    1a5e:	cf 91       	pop	r28
    1a60:	bf 91       	pop	r27
    1a62:	af 91       	pop	r26
    1a64:	9f 91       	pop	r25
    1a66:	8f 91       	pop	r24
    1a68:	7f 91       	pop	r23
    1a6a:	6f 91       	pop	r22
    1a6c:	5f 91       	pop	r21
    1a6e:	4f 91       	pop	r20
    1a70:	3f 91       	pop	r19
    1a72:	2f 91       	pop	r18
    1a74:	1f 91       	pop	r17
    1a76:	0f 91       	pop	r16
    1a78:	ff 90       	pop	r15
    1a7a:	ef 90       	pop	r14
    1a7c:	df 90       	pop	r13
    1a7e:	cf 90       	pop	r12
    1a80:	bf 90       	pop	r11
    1a82:	af 90       	pop	r10
    1a84:	9f 90       	pop	r9
    1a86:	8f 90       	pop	r8
    1a88:	7f 90       	pop	r7
    1a8a:	6f 90       	pop	r6
    1a8c:	5f 90       	pop	r5
    1a8e:	4f 90       	pop	r4
    1a90:	3f 90       	pop	r3
    1a92:	2f 90       	pop	r2
    1a94:	1f 90       	pop	r1
    1a96:	0f 90       	pop	r0
    1a98:	0f be       	out	0x3f, r0	; 63
    1a9a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1a9c:	08 95       	ret

00001a9e <__vector_7>:
	 * count is incremented after the context is saved.
	 */ 
//	void TIMER0_COMPA_vect( void ) __attribute__ ( ( SIGNAL, naked ) );
//	void TIMER0_COMPA_vect( void )
	ISR (TIMER1_COMPA_vect)
	{
    1a9e:	1f 92       	push	r1
    1aa0:	0f 92       	push	r0
    1aa2:	0f b6       	in	r0, 0x3f	; 63
    1aa4:	0f 92       	push	r0
    1aa6:	11 24       	eor	r1, r1
    1aa8:	2f 93       	push	r18
    1aaa:	3f 93       	push	r19
    1aac:	4f 93       	push	r20
    1aae:	5f 93       	push	r21
    1ab0:	6f 93       	push	r22
    1ab2:	7f 93       	push	r23
    1ab4:	8f 93       	push	r24
    1ab6:	9f 93       	push	r25
    1ab8:	af 93       	push	r26
    1aba:	bf 93       	push	r27
    1abc:	ef 93       	push	r30
    1abe:	ff 93       	push	r31
		vPortYieldFromTick();
    1ac0:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <vPortYieldFromTick>
//		asm volatile ( "reti" );
	}
    1ac4:	ff 91       	pop	r31
    1ac6:	ef 91       	pop	r30
    1ac8:	bf 91       	pop	r27
    1aca:	af 91       	pop	r26
    1acc:	9f 91       	pop	r25
    1ace:	8f 91       	pop	r24
    1ad0:	7f 91       	pop	r23
    1ad2:	6f 91       	pop	r22
    1ad4:	5f 91       	pop	r21
    1ad6:	4f 91       	pop	r20
    1ad8:	3f 91       	pop	r19
    1ada:	2f 91       	pop	r18
    1adc:	0f 90       	pop	r0
    1ade:	0f be       	out	0x3f, r0	; 63
    1ae0:	0f 90       	pop	r0
    1ae2:	1f 90       	pop	r1
    1ae4:	18 95       	reti

00001ae6 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1ae6:	0f 93       	push	r16
    1ae8:	1f 93       	push	r17
    1aea:	cf 93       	push	r28
    1aec:	df 93       	push	r29
    1aee:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1af0:	0e 94 76 13 	call	0x26ec	; 0x26ec <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1af4:	00 91 d5 00 	lds	r16, 0x00D5
    1af8:	10 91 d6 00 	lds	r17, 0x00D6
    1afc:	c0 0f       	add	r28, r16
    1afe:	d1 1f       	adc	r29, r17
    1b00:	85 e0       	ldi	r24, 0x05	; 5
    1b02:	cc 3d       	cpi	r28, 0xDC	; 220
    1b04:	d8 07       	cpc	r29, r24
    1b06:	50 f4       	brcc	.+20     	; 0x1b1c <pvPortMalloc+0x36>
    1b08:	0c 17       	cp	r16, r28
    1b0a:	1d 07       	cpc	r17, r29
    1b0c:	50 f4       	brcc	.+20     	; 0x1b22 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1b0e:	09 52       	subi	r16, 0x29	; 41
    1b10:	1f 4f       	sbci	r17, 0xFF	; 255
			xNextFreeByte += xWantedSize;
    1b12:	d0 93 d6 00 	sts	0x00D6, r29
    1b16:	c0 93 d5 00 	sts	0x00D5, r28
    1b1a:	05 c0       	rjmp	.+10     	; 0x1b26 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1b1c:	00 e0       	ldi	r16, 0x00	; 0
    1b1e:	10 e0       	ldi	r17, 0x00	; 0
    1b20:	02 c0       	rjmp	.+4      	; 0x1b26 <pvPortMalloc+0x40>
    1b22:	00 e0       	ldi	r16, 0x00	; 0
    1b24:	10 e0       	ldi	r17, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;
		}
	}
	xTaskResumeAll();
    1b26:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1b2a:	80 2f       	mov	r24, r16
    1b2c:	91 2f       	mov	r25, r17
    1b2e:	df 91       	pop	r29
    1b30:	cf 91       	pop	r28
    1b32:	1f 91       	pop	r17
    1b34:	0f 91       	pop	r16
    1b36:	08 95       	ret

00001b38 <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    1b38:	08 95       	ret

00001b3a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1b3a:	10 92 d6 00 	sts	0x00D6, r1
    1b3e:	10 92 d5 00 	sts	0x00D5, r1
}
    1b42:	08 95       	ret

00001b44 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    1b44:	20 91 d5 00 	lds	r18, 0x00D5
    1b48:	30 91 d6 00 	lds	r19, 0x00D6
    1b4c:	8c ed       	ldi	r24, 0xDC	; 220
    1b4e:	95 e0       	ldi	r25, 0x05	; 5
    1b50:	82 1b       	sub	r24, r18
    1b52:	93 0b       	sbc	r25, r19
}
    1b54:	08 95       	ret

00001b56 <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    1b56:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1b58:	0f b6       	in	r0, 0x3f	; 63
    1b5a:	f8 94       	cli
    1b5c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1b5e:	22 8d       	ldd	r18, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1b60:	0f 90       	pop	r0
    1b62:	0f be       	out	0x3f, r0	; 63
static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1b64:	81 e0       	ldi	r24, 0x01	; 1
    1b66:	93 8d       	ldd	r25, Z+27	; 0x1b
    1b68:	29 13       	cpse	r18, r25
    1b6a:	80 e0       	ldi	r24, 0x00	; 0
	taskEXIT_CRITICAL();

	return xReturn;
}
    1b6c:	08 95       	ret

00001b6e <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1b6e:	cf 93       	push	r28
    1b70:	df 93       	push	r29
    1b72:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1b74:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1b76:	22 23       	and	r18, r18
    1b78:	a9 f1       	breq	.+106    	; 0x1be4 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1b7a:	44 23       	and	r20, r20
    1b7c:	b9 f4       	brne	.+46     	; 0x1bac <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1b7e:	8c 81       	ldd	r24, Y+4	; 0x04
    1b80:	9d 81       	ldd	r25, Y+5	; 0x05
    1b82:	42 2f       	mov	r20, r18
    1b84:	50 e0       	ldi	r21, 0x00	; 0
    1b86:	0e 94 30 17 	call	0x2e60	; 0x2e60 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1b8a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1b8c:	8c 81       	ldd	r24, Y+4	; 0x04
    1b8e:	9d 81       	ldd	r25, Y+5	; 0x05
    1b90:	82 0f       	add	r24, r18
    1b92:	91 1d       	adc	r25, r1
    1b94:	9d 83       	std	Y+5, r25	; 0x05
    1b96:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1b98:	2a 81       	ldd	r18, Y+2	; 0x02
    1b9a:	3b 81       	ldd	r19, Y+3	; 0x03
    1b9c:	82 17       	cp	r24, r18
    1b9e:	93 07       	cpc	r25, r19
    1ba0:	08 f1       	brcs	.+66     	; 0x1be4 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1ba2:	88 81       	ld	r24, Y
    1ba4:	99 81       	ldd	r25, Y+1	; 0x01
    1ba6:	9d 83       	std	Y+5, r25	; 0x05
    1ba8:	8c 83       	std	Y+4, r24	; 0x04
    1baa:	1c c0       	rjmp	.+56     	; 0x1be4 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1bac:	8e 81       	ldd	r24, Y+6	; 0x06
    1bae:	9f 81       	ldd	r25, Y+7	; 0x07
    1bb0:	42 2f       	mov	r20, r18
    1bb2:	50 e0       	ldi	r21, 0x00	; 0
    1bb4:	0e 94 30 17 	call	0x2e60	; 0x2e60 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1bb8:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1bba:	50 e0       	ldi	r21, 0x00	; 0
    1bbc:	50 95       	com	r21
    1bbe:	41 95       	neg	r20
    1bc0:	5f 4f       	sbci	r21, 0xFF	; 255
    1bc2:	8e 81       	ldd	r24, Y+6	; 0x06
    1bc4:	9f 81       	ldd	r25, Y+7	; 0x07
    1bc6:	84 0f       	add	r24, r20
    1bc8:	95 1f       	adc	r25, r21
    1bca:	9f 83       	std	Y+7, r25	; 0x07
    1bcc:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1bce:	28 81       	ld	r18, Y
    1bd0:	39 81       	ldd	r19, Y+1	; 0x01
    1bd2:	82 17       	cp	r24, r18
    1bd4:	93 07       	cpc	r25, r19
    1bd6:	30 f4       	brcc	.+12     	; 0x1be4 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1bd8:	8a 81       	ldd	r24, Y+2	; 0x02
    1bda:	9b 81       	ldd	r25, Y+3	; 0x03
    1bdc:	48 0f       	add	r20, r24
    1bde:	59 1f       	adc	r21, r25
    1be0:	5f 83       	std	Y+7, r21	; 0x07
    1be2:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1be4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1be6:	8f 5f       	subi	r24, 0xFF	; 255
    1be8:	8a 8f       	std	Y+26, r24	; 0x1a
}
    1bea:	df 91       	pop	r29
    1bec:	cf 91       	pop	r28
    1bee:	08 95       	ret

00001bf0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1bf0:	cf 93       	push	r28
    1bf2:	df 93       	push	r29
    1bf4:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1bf6:	cd 91       	ld	r28, X+
    1bf8:	dc 91       	ld	r29, X
    1bfa:	11 97       	sbiw	r26, 0x01	; 1
    1bfc:	20 97       	sbiw	r28, 0x00	; 0
    1bfe:	21 f1       	breq	.+72     	; 0x1c48 <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1c00:	5c 96       	adiw	r26, 0x1c	; 28
    1c02:	4c 91       	ld	r20, X
    1c04:	5c 97       	sbiw	r26, 0x1c	; 28
    1c06:	16 96       	adiw	r26, 0x06	; 6
    1c08:	2d 91       	ld	r18, X+
    1c0a:	3c 91       	ld	r19, X
    1c0c:	17 97       	sbiw	r26, 0x07	; 7
    1c0e:	24 0f       	add	r18, r20
    1c10:	31 1d       	adc	r19, r1
    1c12:	17 96       	adiw	r26, 0x07	; 7
    1c14:	3c 93       	st	X, r19
    1c16:	2e 93       	st	-X, r18
    1c18:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1c1a:	12 96       	adiw	r26, 0x02	; 2
    1c1c:	ed 91       	ld	r30, X+
    1c1e:	fc 91       	ld	r31, X
    1c20:	13 97       	sbiw	r26, 0x03	; 3
    1c22:	2e 17       	cp	r18, r30
    1c24:	3f 07       	cpc	r19, r31
    1c26:	20 f0       	brcs	.+8      	; 0x1c30 <prvCopyDataFromQueue+0x40>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1c28:	17 96       	adiw	r26, 0x07	; 7
    1c2a:	dc 93       	st	X, r29
    1c2c:	ce 93       	st	-X, r28
    1c2e:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1c30:	16 96       	adiw	r26, 0x06	; 6
    1c32:	3c 91       	ld	r19, X
    1c34:	16 97       	sbiw	r26, 0x06	; 6
    1c36:	17 96       	adiw	r26, 0x07	; 7
    1c38:	2c 91       	ld	r18, X
    1c3a:	86 2f       	mov	r24, r22
    1c3c:	97 2f       	mov	r25, r23
    1c3e:	63 2f       	mov	r22, r19
    1c40:	72 2f       	mov	r23, r18
    1c42:	50 e0       	ldi	r21, 0x00	; 0
    1c44:	0e 94 30 17 	call	0x2e60	; 0x2e60 <memcpy>
	}
}
    1c48:	df 91       	pop	r29
    1c4a:	cf 91       	pop	r28
    1c4c:	08 95       	ret

00001c4e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1c4e:	0f 93       	push	r16
    1c50:	1f 93       	push	r17
    1c52:	cf 93       	push	r28
    1c54:	df 93       	push	r29
    1c56:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1c58:	0f b6       	in	r0, 0x3f	; 63
    1c5a:	f8 94       	cli
    1c5c:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1c5e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1c60:	18 16       	cp	r1, r24
    1c62:	c4 f4       	brge	.+48     	; 0x1c94 <prvUnlockQueue+0x46>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c64:	89 89       	ldd	r24, Y+17	; 0x11
    1c66:	88 23       	and	r24, r24
    1c68:	29 f4       	brne	.+10     	; 0x1c74 <prvUnlockQueue+0x26>
    1c6a:	14 c0       	rjmp	.+40     	; 0x1c94 <prvUnlockQueue+0x46>
    1c6c:	89 89       	ldd	r24, Y+17	; 0x11
    1c6e:	88 23       	and	r24, r24
    1c70:	21 f4       	brne	.+8      	; 0x1c7a <prvUnlockQueue+0x2c>
    1c72:	10 c0       	rjmp	.+32     	; 0x1c94 <prvUnlockQueue+0x46>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c74:	8e 01       	movw	r16, r28
    1c76:	0f 5e       	subi	r16, 0xEF	; 239
    1c78:	1f 4f       	sbci	r17, 0xFF	; 255
    1c7a:	c8 01       	movw	r24, r16
    1c7c:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <xTaskRemoveFromEventList>
    1c80:	88 23       	and	r24, r24
    1c82:	11 f0       	breq	.+4      	; 0x1c88 <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1c84:	0e 94 94 16 	call	0x2d28	; 0x2d28 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1c88:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1c8a:	81 50       	subi	r24, 0x01	; 1
    1c8c:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1c8e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1c90:	18 16       	cp	r1, r24
    1c92:	64 f3       	brlt	.-40     	; 0x1c6c <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1c94:	8f ef       	ldi	r24, 0xFF	; 255
    1c96:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1c98:	0f 90       	pop	r0
    1c9a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1c9c:	0f b6       	in	r0, 0x3f	; 63
    1c9e:	f8 94       	cli
    1ca0:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1ca2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1ca4:	18 16       	cp	r1, r24
    1ca6:	c4 f4       	brge	.+48     	; 0x1cd8 <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ca8:	88 85       	ldd	r24, Y+8	; 0x08
    1caa:	88 23       	and	r24, r24
    1cac:	29 f4       	brne	.+10     	; 0x1cb8 <prvUnlockQueue+0x6a>
    1cae:	14 c0       	rjmp	.+40     	; 0x1cd8 <prvUnlockQueue+0x8a>
    1cb0:	88 85       	ldd	r24, Y+8	; 0x08
    1cb2:	88 23       	and	r24, r24
    1cb4:	21 f4       	brne	.+8      	; 0x1cbe <prvUnlockQueue+0x70>
    1cb6:	10 c0       	rjmp	.+32     	; 0x1cd8 <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1cb8:	8e 01       	movw	r16, r28
    1cba:	08 5f       	subi	r16, 0xF8	; 248
    1cbc:	1f 4f       	sbci	r17, 0xFF	; 255
    1cbe:	c8 01       	movw	r24, r16
    1cc0:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <xTaskRemoveFromEventList>
    1cc4:	88 23       	and	r24, r24
    1cc6:	11 f0       	breq	.+4      	; 0x1ccc <prvUnlockQueue+0x7e>
				{
					vTaskMissedYield();
    1cc8:	0e 94 94 16 	call	0x2d28	; 0x2d28 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1ccc:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1cce:	81 50       	subi	r24, 0x01	; 1
    1cd0:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1cd2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1cd4:	18 16       	cp	r1, r24
    1cd6:	64 f3       	brlt	.-40     	; 0x1cb0 <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1cd8:	8f ef       	ldi	r24, 0xFF	; 255
    1cda:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1cdc:	0f 90       	pop	r0
    1cde:	0f be       	out	0x3f, r0	; 63
}
    1ce0:	df 91       	pop	r29
    1ce2:	cf 91       	pop	r28
    1ce4:	1f 91       	pop	r17
    1ce6:	0f 91       	pop	r16
    1ce8:	08 95       	ret

00001cea <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    1cea:	cf 93       	push	r28
    1cec:	df 93       	push	r29
    1cee:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1cf0:	0f b6       	in	r0, 0x3f	; 63
    1cf2:	f8 94       	cli
    1cf4:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1cf6:	48 81       	ld	r20, Y
    1cf8:	59 81       	ldd	r21, Y+1	; 0x01
    1cfa:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1cfc:	30 e0       	ldi	r19, 0x00	; 0
    1cfe:	ec 8d       	ldd	r30, Y+28	; 0x1c
    1d00:	f0 e0       	ldi	r31, 0x00	; 0
    1d02:	2e 9f       	mul	r18, r30
    1d04:	c0 01       	movw	r24, r0
    1d06:	2f 9f       	mul	r18, r31
    1d08:	90 0d       	add	r25, r0
    1d0a:	3e 9f       	mul	r19, r30
    1d0c:	90 0d       	add	r25, r0
    1d0e:	11 24       	eor	r1, r1
    1d10:	84 0f       	add	r24, r20
    1d12:	95 1f       	adc	r25, r21
    1d14:	9b 83       	std	Y+3, r25	; 0x03
    1d16:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1d18:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1d1a:	5d 83       	std	Y+5, r21	; 0x05
    1d1c:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    1d1e:	c9 01       	movw	r24, r18
    1d20:	01 97       	sbiw	r24, 0x01	; 1
    1d22:	e8 9f       	mul	r30, r24
    1d24:	90 01       	movw	r18, r0
    1d26:	e9 9f       	mul	r30, r25
    1d28:	30 0d       	add	r19, r0
    1d2a:	f8 9f       	mul	r31, r24
    1d2c:	30 0d       	add	r19, r0
    1d2e:	11 24       	eor	r1, r1
    1d30:	24 0f       	add	r18, r20
    1d32:	35 1f       	adc	r19, r21
    1d34:	3f 83       	std	Y+7, r19	; 0x07
    1d36:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1d38:	8f ef       	ldi	r24, 0xFF	; 255
    1d3a:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1d3c:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1d3e:	66 23       	and	r22, r22
    1d40:	61 f4       	brne	.+24     	; 0x1d5a <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d42:	88 85       	ldd	r24, Y+8	; 0x08
    1d44:	88 23       	and	r24, r24
    1d46:	89 f0       	breq	.+34     	; 0x1d6a <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1d48:	ce 01       	movw	r24, r28
    1d4a:	08 96       	adiw	r24, 0x08	; 8
    1d4c:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <xTaskRemoveFromEventList>
    1d50:	81 30       	cpi	r24, 0x01	; 1
    1d52:	59 f4       	brne	.+22     	; 0x1d6a <xQueueGenericReset+0x80>
				{
					portYIELD_WITHIN_API();
    1d54:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vPortYield>
    1d58:	08 c0       	rjmp	.+16     	; 0x1d6a <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1d5a:	ce 01       	movw	r24, r28
    1d5c:	08 96       	adiw	r24, 0x08	; 8
    1d5e:	0e 94 36 0b 	call	0x166c	; 0x166c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1d62:	ce 01       	movw	r24, r28
    1d64:	41 96       	adiw	r24, 0x11	; 17
    1d66:	0e 94 36 0b 	call	0x166c	; 0x166c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1d6a:	0f 90       	pop	r0
    1d6c:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1d6e:	81 e0       	ldi	r24, 0x01	; 1
    1d70:	df 91       	pop	r29
    1d72:	cf 91       	pop	r28
    1d74:	08 95       	ret

00001d76 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    1d76:	0f 93       	push	r16
    1d78:	1f 93       	push	r17
    1d7a:	cf 93       	push	r28
    1d7c:	df 93       	push	r29
    1d7e:	18 2f       	mov	r17, r24
    1d80:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1d82:	88 23       	and	r24, r24
    1d84:	f9 f0       	breq	.+62     	; 0x1dc4 <xQueueGenericCreate+0x4e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1d86:	8f e1       	ldi	r24, 0x1F	; 31
    1d88:	90 e0       	ldi	r25, 0x00	; 0
    1d8a:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <pvPortMalloc>
    1d8e:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1d90:	00 97       	sbiw	r24, 0x00	; 0
    1d92:	d9 f0       	breq	.+54     	; 0x1dca <xQueueGenericCreate+0x54>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1d94:	01 9f       	mul	r16, r17
    1d96:	c0 01       	movw	r24, r0
    1d98:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1d9a:	01 96       	adiw	r24, 0x01	; 1
    1d9c:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <pvPortMalloc>
    1da0:	99 83       	std	Y+1, r25	; 0x01
    1da2:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1da4:	00 97       	sbiw	r24, 0x00	; 0
    1da6:	41 f0       	breq	.+16     	; 0x1db8 <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1da8:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1daa:	0c 8f       	std	Y+28, r16	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    1dac:	ce 01       	movw	r24, r28
    1dae:	61 e0       	ldi	r22, 0x01	; 1
    1db0:	0e 94 75 0e 	call	0x1cea	; 0x1cea <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1db4:	ce 01       	movw	r24, r28
    1db6:	0b c0       	rjmp	.+22     	; 0x1dce <xQueueGenericCreate+0x58>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1db8:	ce 01       	movw	r24, r28
    1dba:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1dbe:	80 e0       	ldi	r24, 0x00	; 0
    1dc0:	90 e0       	ldi	r25, 0x00	; 0
    1dc2:	05 c0       	rjmp	.+10     	; 0x1dce <xQueueGenericCreate+0x58>
    1dc4:	80 e0       	ldi	r24, 0x00	; 0
    1dc6:	90 e0       	ldi	r25, 0x00	; 0
    1dc8:	02 c0       	rjmp	.+4      	; 0x1dce <xQueueGenericCreate+0x58>
    1dca:	80 e0       	ldi	r24, 0x00	; 0
    1dcc:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    1dce:	df 91       	pop	r29
    1dd0:	cf 91       	pop	r28
    1dd2:	1f 91       	pop	r17
    1dd4:	0f 91       	pop	r16
    1dd6:	08 95       	ret

00001dd8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1dd8:	8f 92       	push	r8
    1dda:	9f 92       	push	r9
    1ddc:	bf 92       	push	r11
    1dde:	cf 92       	push	r12
    1de0:	df 92       	push	r13
    1de2:	ef 92       	push	r14
    1de4:	ff 92       	push	r15
    1de6:	0f 93       	push	r16
    1de8:	1f 93       	push	r17
    1dea:	cf 93       	push	r28
    1dec:	df 93       	push	r29
    1dee:	00 d0       	rcall	.+0      	; 0x1df0 <xQueueGenericSend+0x18>
    1df0:	00 d0       	rcall	.+0      	; 0x1df2 <xQueueGenericSend+0x1a>
    1df2:	0f 92       	push	r0
    1df4:	cd b7       	in	r28, 0x3d	; 61
    1df6:	de b7       	in	r29, 0x3e	; 62
    1df8:	8c 01       	movw	r16, r24
    1dfa:	4b 01       	movw	r8, r22
    1dfc:	5d 83       	std	Y+5, r21	; 0x05
    1dfe:	4c 83       	std	Y+4, r20	; 0x04
    1e00:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1e02:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1e04:	ee 24       	eor	r14, r14
    1e06:	e3 94       	inc	r14
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1e08:	cc 24       	eor	r12, r12
    1e0a:	dd 24       	eor	r13, r13
    1e0c:	68 94       	set
    1e0e:	c3 f8       	bld	r12, 3
    1e10:	c8 0e       	add	r12, r24
    1e12:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1e14:	0f b6       	in	r0, 0x3f	; 63
    1e16:	f8 94       	cli
    1e18:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1e1a:	f8 01       	movw	r30, r16
    1e1c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e1e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e20:	98 17       	cp	r25, r24
    1e22:	a8 f4       	brcc	.+42     	; 0x1e4e <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1e24:	c8 01       	movw	r24, r16
    1e26:	b4 01       	movw	r22, r8
    1e28:	4b 2d       	mov	r20, r11
    1e2a:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e2e:	f8 01       	movw	r30, r16
    1e30:	81 89       	ldd	r24, Z+17	; 0x11
    1e32:	88 23       	and	r24, r24
    1e34:	41 f0       	breq	.+16     	; 0x1e46 <xQueueGenericSend+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1e36:	c8 01       	movw	r24, r16
    1e38:	41 96       	adiw	r24, 0x11	; 17
    1e3a:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <xTaskRemoveFromEventList>
    1e3e:	81 30       	cpi	r24, 0x01	; 1
    1e40:	11 f4       	brne	.+4      	; 0x1e46 <xQueueGenericSend+0x6e>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1e42:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1e46:	0f 90       	pop	r0
    1e48:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1e4a:	81 e0       	ldi	r24, 0x01	; 1
    1e4c:	4c c0       	rjmp	.+152    	; 0x1ee6 <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1e4e:	8c 81       	ldd	r24, Y+4	; 0x04
    1e50:	9d 81       	ldd	r25, Y+5	; 0x05
    1e52:	00 97       	sbiw	r24, 0x00	; 0
    1e54:	21 f4       	brne	.+8      	; 0x1e5e <xQueueGenericSend+0x86>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1e56:	0f 90       	pop	r0
    1e58:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1e5a:	80 e0       	ldi	r24, 0x00	; 0
    1e5c:	44 c0       	rjmp	.+136    	; 0x1ee6 <xQueueGenericSend+0x10e>
				}
				else if( xEntryTimeSet == pdFALSE )
    1e5e:	ff 20       	and	r15, r15
    1e60:	29 f4       	brne	.+10     	; 0x1e6c <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1e62:	ce 01       	movw	r24, r28
    1e64:	01 96       	adiw	r24, 0x01	; 1
    1e66:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1e6a:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    1e6c:	0f 90       	pop	r0
    1e6e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1e70:	0e 94 76 13 	call	0x26ec	; 0x26ec <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1e74:	0f b6       	in	r0, 0x3f	; 63
    1e76:	f8 94       	cli
    1e78:	0f 92       	push	r0
    1e7a:	f8 01       	movw	r30, r16
    1e7c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e7e:	8f 3f       	cpi	r24, 0xFF	; 255
    1e80:	09 f4       	brne	.+2      	; 0x1e84 <xQueueGenericSend+0xac>
    1e82:	15 8e       	std	Z+29, r1	; 0x1d
    1e84:	f8 01       	movw	r30, r16
    1e86:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e88:	8f 3f       	cpi	r24, 0xFF	; 255
    1e8a:	09 f4       	brne	.+2      	; 0x1e8e <xQueueGenericSend+0xb6>
    1e8c:	16 8e       	std	Z+30, r1	; 0x1e
    1e8e:	0f 90       	pop	r0
    1e90:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e92:	ce 01       	movw	r24, r28
    1e94:	01 96       	adiw	r24, 0x01	; 1
    1e96:	be 01       	movw	r22, r28
    1e98:	6c 5f       	subi	r22, 0xFC	; 252
    1e9a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e9c:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <xTaskCheckForTimeOut>
    1ea0:	88 23       	and	r24, r24
    1ea2:	d9 f4       	brne	.+54     	; 0x1eda <xQueueGenericSend+0x102>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1ea4:	c8 01       	movw	r24, r16
    1ea6:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <prvIsQueueFull>
    1eaa:	88 23       	and	r24, r24
    1eac:	81 f0       	breq	.+32     	; 0x1ece <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1eae:	6c 81       	ldd	r22, Y+4	; 0x04
    1eb0:	7d 81       	ldd	r23, Y+5	; 0x05
    1eb2:	c6 01       	movw	r24, r12
    1eb4:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1eb8:	c8 01       	movw	r24, r16
    1eba:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1ebe:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
    1ec2:	88 23       	and	r24, r24
    1ec4:	09 f0       	breq	.+2      	; 0x1ec8 <xQueueGenericSend+0xf0>
    1ec6:	a6 cf       	rjmp	.-180    	; 0x1e14 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
    1ec8:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vPortYield>
    1ecc:	a3 cf       	rjmp	.-186    	; 0x1e14 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1ece:	c8 01       	movw	r24, r16
    1ed0:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1ed4:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
    1ed8:	9d cf       	rjmp	.-198    	; 0x1e14 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1eda:	c8 01       	movw	r24, r16
    1edc:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ee0:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1ee4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1ee6:	0f 90       	pop	r0
    1ee8:	0f 90       	pop	r0
    1eea:	0f 90       	pop	r0
    1eec:	0f 90       	pop	r0
    1eee:	0f 90       	pop	r0
    1ef0:	df 91       	pop	r29
    1ef2:	cf 91       	pop	r28
    1ef4:	1f 91       	pop	r17
    1ef6:	0f 91       	pop	r16
    1ef8:	ff 90       	pop	r15
    1efa:	ef 90       	pop	r14
    1efc:	df 90       	pop	r13
    1efe:	cf 90       	pop	r12
    1f00:	bf 90       	pop	r11
    1f02:	9f 90       	pop	r9
    1f04:	8f 90       	pop	r8
    1f06:	08 95       	ret

00001f08 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1f08:	0f 93       	push	r16
    1f0a:	1f 93       	push	r17
    1f0c:	cf 93       	push	r28
    1f0e:	df 93       	push	r29
    1f10:	ec 01       	movw	r28, r24
    1f12:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1f14:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1f16:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1f18:	98 17       	cp	r25, r24
    1f1a:	e0 f4       	brcc	.+56     	; 0x1f54 <xQueueGenericSendFromISR+0x4c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1f1c:	ce 01       	movw	r24, r28
    1f1e:	42 2f       	mov	r20, r18
    1f20:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1f24:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f26:	8f 3f       	cpi	r24, 0xFF	; 255
    1f28:	81 f4       	brne	.+32     	; 0x1f4a <xQueueGenericSendFromISR+0x42>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f2a:	89 89       	ldd	r24, Y+17	; 0x11
    1f2c:	88 23       	and	r24, r24
    1f2e:	a1 f0       	breq	.+40     	; 0x1f58 <xQueueGenericSendFromISR+0x50>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f30:	ce 01       	movw	r24, r28
    1f32:	41 96       	adiw	r24, 0x11	; 17
    1f34:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <xTaskRemoveFromEventList>
    1f38:	88 23       	and	r24, r24
    1f3a:	81 f0       	breq	.+32     	; 0x1f5c <xQueueGenericSendFromISR+0x54>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    1f3c:	01 15       	cp	r16, r1
    1f3e:	11 05       	cpc	r17, r1
    1f40:	79 f0       	breq	.+30     	; 0x1f60 <xQueueGenericSendFromISR+0x58>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1f42:	81 e0       	ldi	r24, 0x01	; 1
    1f44:	f8 01       	movw	r30, r16
    1f46:	80 83       	st	Z, r24
    1f48:	0c c0       	rjmp	.+24     	; 0x1f62 <xQueueGenericSendFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1f4a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f4c:	8f 5f       	subi	r24, 0xFF	; 255
    1f4e:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1f50:	81 e0       	ldi	r24, 0x01	; 1
    1f52:	07 c0       	rjmp	.+14     	; 0x1f62 <xQueueGenericSendFromISR+0x5a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1f54:	80 e0       	ldi	r24, 0x00	; 0
    1f56:	05 c0       	rjmp	.+10     	; 0x1f62 <xQueueGenericSendFromISR+0x5a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1f58:	81 e0       	ldi	r24, 0x01	; 1
    1f5a:	03 c0       	rjmp	.+6      	; 0x1f62 <xQueueGenericSendFromISR+0x5a>
    1f5c:	81 e0       	ldi	r24, 0x01	; 1
    1f5e:	01 c0       	rjmp	.+2      	; 0x1f62 <xQueueGenericSendFromISR+0x5a>
    1f60:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1f62:	df 91       	pop	r29
    1f64:	cf 91       	pop	r28
    1f66:	1f 91       	pop	r17
    1f68:	0f 91       	pop	r16
    1f6a:	08 95       	ret

00001f6c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1f6c:	8f 92       	push	r8
    1f6e:	9f 92       	push	r9
    1f70:	bf 92       	push	r11
    1f72:	cf 92       	push	r12
    1f74:	df 92       	push	r13
    1f76:	ef 92       	push	r14
    1f78:	ff 92       	push	r15
    1f7a:	0f 93       	push	r16
    1f7c:	1f 93       	push	r17
    1f7e:	cf 93       	push	r28
    1f80:	df 93       	push	r29
    1f82:	00 d0       	rcall	.+0      	; 0x1f84 <xQueueGenericReceive+0x18>
    1f84:	00 d0       	rcall	.+0      	; 0x1f86 <xQueueGenericReceive+0x1a>
    1f86:	0f 92       	push	r0
    1f88:	cd b7       	in	r28, 0x3d	; 61
    1f8a:	de b7       	in	r29, 0x3e	; 62
    1f8c:	8c 01       	movw	r16, r24
    1f8e:	4b 01       	movw	r8, r22
    1f90:	5d 83       	std	Y+5, r21	; 0x05
    1f92:	4c 83       	std	Y+4, r20	; 0x04
    1f94:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1f96:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1f98:	ee 24       	eor	r14, r14
    1f9a:	e3 94       	inc	r14
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1f9c:	0f 2e       	mov	r0, r31
    1f9e:	f1 e1       	ldi	r31, 0x11	; 17
    1fa0:	cf 2e       	mov	r12, r31
    1fa2:	dd 24       	eor	r13, r13
    1fa4:	f0 2d       	mov	r31, r0
    1fa6:	c8 0e       	add	r12, r24
    1fa8:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1faa:	0f b6       	in	r0, 0x3f	; 63
    1fac:	f8 94       	cli
    1fae:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1fb0:	f8 01       	movw	r30, r16
    1fb2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fb4:	88 23       	and	r24, r24
    1fb6:	51 f1       	breq	.+84     	; 0x200c <xQueueGenericReceive+0xa0>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1fb8:	e6 80       	ldd	r14, Z+6	; 0x06
    1fba:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1fbc:	c8 01       	movw	r24, r16
    1fbe:	b4 01       	movw	r22, r8
    1fc0:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1fc4:	bb 20       	and	r11, r11
    1fc6:	81 f4       	brne	.+32     	; 0x1fe8 <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1fc8:	f8 01       	movw	r30, r16
    1fca:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fcc:	81 50       	subi	r24, 0x01	; 1
    1fce:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1fd0:	80 85       	ldd	r24, Z+8	; 0x08
    1fd2:	88 23       	and	r24, r24
    1fd4:	b9 f0       	breq	.+46     	; 0x2004 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1fd6:	c8 01       	movw	r24, r16
    1fd8:	08 96       	adiw	r24, 0x08	; 8
    1fda:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <xTaskRemoveFromEventList>
    1fde:	81 30       	cpi	r24, 0x01	; 1
    1fe0:	89 f4       	brne	.+34     	; 0x2004 <xQueueGenericReceive+0x98>
						{
							portYIELD_WITHIN_API();
    1fe2:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vPortYield>
    1fe6:	0e c0       	rjmp	.+28     	; 0x2004 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1fe8:	f8 01       	movw	r30, r16
    1fea:	f7 82       	std	Z+7, r15	; 0x07
    1fec:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1fee:	81 89       	ldd	r24, Z+17	; 0x11
    1ff0:	88 23       	and	r24, r24
    1ff2:	41 f0       	breq	.+16     	; 0x2004 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ff4:	c8 01       	movw	r24, r16
    1ff6:	41 96       	adiw	r24, 0x11	; 17
    1ff8:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <xTaskRemoveFromEventList>
    1ffc:	88 23       	and	r24, r24
    1ffe:	11 f0       	breq	.+4      	; 0x2004 <xQueueGenericReceive+0x98>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    2000:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    2004:	0f 90       	pop	r0
    2006:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2008:	81 e0       	ldi	r24, 0x01	; 1
    200a:	50 c0       	rjmp	.+160    	; 0x20ac <xQueueGenericReceive+0x140>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    200c:	8c 81       	ldd	r24, Y+4	; 0x04
    200e:	9d 81       	ldd	r25, Y+5	; 0x05
    2010:	00 97       	sbiw	r24, 0x00	; 0
    2012:	21 f4       	brne	.+8      	; 0x201c <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2014:	0f 90       	pop	r0
    2016:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2018:	80 e0       	ldi	r24, 0x00	; 0
    201a:	48 c0       	rjmp	.+144    	; 0x20ac <xQueueGenericReceive+0x140>
				}
				else if( xEntryTimeSet == pdFALSE )
    201c:	ff 20       	and	r15, r15
    201e:	29 f4       	brne	.+10     	; 0x202a <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2020:	ce 01       	movw	r24, r28
    2022:	01 96       	adiw	r24, 0x01	; 1
    2024:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2028:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    202a:	0f 90       	pop	r0
    202c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    202e:	0e 94 76 13 	call	0x26ec	; 0x26ec <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2032:	0f b6       	in	r0, 0x3f	; 63
    2034:	f8 94       	cli
    2036:	0f 92       	push	r0
    2038:	f8 01       	movw	r30, r16
    203a:	85 8d       	ldd	r24, Z+29	; 0x1d
    203c:	8f 3f       	cpi	r24, 0xFF	; 255
    203e:	09 f4       	brne	.+2      	; 0x2042 <xQueueGenericReceive+0xd6>
    2040:	15 8e       	std	Z+29, r1	; 0x1d
    2042:	f8 01       	movw	r30, r16
    2044:	86 8d       	ldd	r24, Z+30	; 0x1e
    2046:	8f 3f       	cpi	r24, 0xFF	; 255
    2048:	09 f4       	brne	.+2      	; 0x204c <xQueueGenericReceive+0xe0>
    204a:	16 8e       	std	Z+30, r1	; 0x1e
    204c:	0f 90       	pop	r0
    204e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2050:	ce 01       	movw	r24, r28
    2052:	01 96       	adiw	r24, 0x01	; 1
    2054:	be 01       	movw	r22, r28
    2056:	6c 5f       	subi	r22, 0xFC	; 252
    2058:	7f 4f       	sbci	r23, 0xFF	; 255
    205a:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <xTaskCheckForTimeOut>
    205e:	88 23       	and	r24, r24
    2060:	f9 f4       	brne	.+62     	; 0x20a0 <xQueueGenericReceive+0x134>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2062:	0f b6       	in	r0, 0x3f	; 63
    2064:	f8 94       	cli
    2066:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2068:	f8 01       	movw	r30, r16
    206a:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    206c:	0f 90       	pop	r0
    206e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2070:	88 23       	and	r24, r24
    2072:	81 f4       	brne	.+32     	; 0x2094 <xQueueGenericReceive+0x128>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2074:	6c 81       	ldd	r22, Y+4	; 0x04
    2076:	7d 81       	ldd	r23, Y+5	; 0x05
    2078:	c6 01       	movw	r24, r12
    207a:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    207e:	c8 01       	movw	r24, r16
    2080:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2084:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
    2088:	88 23       	and	r24, r24
    208a:	09 f0       	breq	.+2      	; 0x208e <xQueueGenericReceive+0x122>
    208c:	8e cf       	rjmp	.-228    	; 0x1faa <xQueueGenericReceive+0x3e>
				{
					portYIELD_WITHIN_API();
    208e:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vPortYield>
    2092:	8b cf       	rjmp	.-234    	; 0x1faa <xQueueGenericReceive+0x3e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2094:	c8 01       	movw	r24, r16
    2096:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    209a:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
    209e:	85 cf       	rjmp	.-246    	; 0x1faa <xQueueGenericReceive+0x3e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    20a0:	c8 01       	movw	r24, r16
    20a2:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    20a6:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    20aa:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    20ac:	0f 90       	pop	r0
    20ae:	0f 90       	pop	r0
    20b0:	0f 90       	pop	r0
    20b2:	0f 90       	pop	r0
    20b4:	0f 90       	pop	r0
    20b6:	df 91       	pop	r29
    20b8:	cf 91       	pop	r28
    20ba:	1f 91       	pop	r17
    20bc:	0f 91       	pop	r16
    20be:	ff 90       	pop	r15
    20c0:	ef 90       	pop	r14
    20c2:	df 90       	pop	r13
    20c4:	cf 90       	pop	r12
    20c6:	bf 90       	pop	r11
    20c8:	9f 90       	pop	r9
    20ca:	8f 90       	pop	r8
    20cc:	08 95       	ret

000020ce <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    20ce:	0f 93       	push	r16
    20d0:	1f 93       	push	r17
    20d2:	cf 93       	push	r28
    20d4:	df 93       	push	r29
    20d6:	ec 01       	movw	r28, r24
    20d8:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    20da:	8a 8d       	ldd	r24, Y+26	; 0x1a
    20dc:	88 23       	and	r24, r24
    20de:	f1 f0       	breq	.+60     	; 0x211c <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    20e0:	ce 01       	movw	r24, r28
    20e2:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    20e6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    20e8:	81 50       	subi	r24, 0x01	; 1
    20ea:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    20ec:	8d 8d       	ldd	r24, Y+29	; 0x1d
    20ee:	8f 3f       	cpi	r24, 0xFF	; 255
    20f0:	81 f4       	brne	.+32     	; 0x2112 <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    20f2:	88 85       	ldd	r24, Y+8	; 0x08
    20f4:	88 23       	and	r24, r24
    20f6:	a1 f0       	breq	.+40     	; 0x2120 <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    20f8:	ce 01       	movw	r24, r28
    20fa:	08 96       	adiw	r24, 0x08	; 8
    20fc:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <xTaskRemoveFromEventList>
    2100:	88 23       	and	r24, r24
    2102:	81 f0       	breq	.+32     	; 0x2124 <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2104:	01 15       	cp	r16, r1
    2106:	11 05       	cpc	r17, r1
    2108:	79 f0       	breq	.+30     	; 0x2128 <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    210a:	81 e0       	ldi	r24, 0x01	; 1
    210c:	f8 01       	movw	r30, r16
    210e:	80 83       	st	Z, r24
    2110:	0c c0       	rjmp	.+24     	; 0x212a <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2112:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2114:	8f 5f       	subi	r24, 0xFF	; 255
    2116:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2118:	81 e0       	ldi	r24, 0x01	; 1
    211a:	07 c0       	rjmp	.+14     	; 0x212a <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    211c:	80 e0       	ldi	r24, 0x00	; 0
    211e:	05 c0       	rjmp	.+10     	; 0x212a <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    2120:	81 e0       	ldi	r24, 0x01	; 1
    2122:	03 c0       	rjmp	.+6      	; 0x212a <xQueueReceiveFromISR+0x5c>
    2124:	81 e0       	ldi	r24, 0x01	; 1
    2126:	01 c0       	rjmp	.+2      	; 0x212a <xQueueReceiveFromISR+0x5c>
    2128:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    212a:	df 91       	pop	r29
    212c:	cf 91       	pop	r28
    212e:	1f 91       	pop	r17
    2130:	0f 91       	pop	r16
    2132:	08 95       	ret

00002134 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2134:	0f b6       	in	r0, 0x3f	; 63
    2136:	f8 94       	cli
    2138:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    213a:	fc 01       	movw	r30, r24
    213c:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    213e:	0f 90       	pop	r0
    2140:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    2142:	08 95       	ret

00002144 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    2144:	fc 01       	movw	r30, r24
    2146:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    2148:	08 95       	ret

0000214a <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    214a:	cf 93       	push	r28
    214c:	df 93       	push	r29
    214e:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    2150:	88 81       	ld	r24, Y
    2152:	99 81       	ldd	r25, Y+1	; 0x01
    2154:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vPortFree>
	vPortFree( pxQueue );
    2158:	ce 01       	movw	r24, r28
    215a:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vPortFree>
}
    215e:	df 91       	pop	r29
    2160:	cf 91       	pop	r28
    2162:	08 95       	ret

00002164 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2164:	fc 01       	movw	r30, r24
    2166:	92 8d       	ldd	r25, Z+26	; 0x1a
    2168:	81 e0       	ldi	r24, 0x01	; 1
    216a:	91 11       	cpse	r25, r1
    216c:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    216e:	08 95       	ret

00002170 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    2170:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2172:	22 8d       	ldd	r18, Z+26	; 0x1a
    2174:	81 e0       	ldi	r24, 0x01	; 1
    2176:	93 8d       	ldd	r25, Z+27	; 0x1b
    2178:	29 13       	cpse	r18, r25
    217a:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    217c:	08 95       	ret

0000217e <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType xTicksToWait )
{
    217e:	ef 92       	push	r14
    2180:	ff 92       	push	r15
    2182:	0f 93       	push	r16
    2184:	1f 93       	push	r17
    2186:	cf 93       	push	r28
    2188:	df 93       	push	r29
    218a:	ec 01       	movw	r28, r24
    218c:	7b 01       	movw	r14, r22
    218e:	8a 01       	movw	r16, r20
signed portBASE_TYPE xReturn;

	/* If the queue is already full we may have to block.  A critical section
	is required to prevent an interrupt removing something from the queue
	between the check to see if the queue is full and blocking on the queue. */
	portDISABLE_INTERRUPTS();
    2190:	f8 94       	cli
	{
		if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2192:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <prvIsQueueFull>
    2196:	88 23       	and	r24, r24
    2198:	79 f0       	breq	.+30     	; 0x21b8 <xQueueCRSend+0x3a>
		{
			/* The queue is full - do we want to block or just leave without
			posting? */
			if( xTicksToWait > ( portTickType ) 0 )
    219a:	01 15       	cp	r16, r1
    219c:	11 05       	cpc	r17, r1
    219e:	49 f0       	breq	.+18     	; 0x21b2 <xQueueCRSend+0x34>
			{
				/* As this is called from a coroutine we cannot block directly, but
				return indicating that we need to block. */
				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    21a0:	be 01       	movw	r22, r28
    21a2:	68 5f       	subi	r22, 0xF8	; 248
    21a4:	7f 4f       	sbci	r23, 0xFF	; 255
    21a6:	c8 01       	movw	r24, r16
    21a8:	0e 94 94 09 	call	0x1328	; 0x1328 <vCoRoutineAddToDelayedList>
				portENABLE_INTERRUPTS();
    21ac:	78 94       	sei
				return errQUEUE_BLOCKED;
    21ae:	8c ef       	ldi	r24, 0xFC	; 252
    21b0:	20 c0       	rjmp	.+64     	; 0x21f2 <xQueueCRSend+0x74>
			}
			else
			{
				portENABLE_INTERRUPTS();
    21b2:	78 94       	sei
				return errQUEUE_FULL;
    21b4:	80 e0       	ldi	r24, 0x00	; 0
    21b6:	1d c0       	rjmp	.+58     	; 0x21f2 <xQueueCRSend+0x74>
			}
		}
	}
	portENABLE_INTERRUPTS();
    21b8:	78 94       	sei

	portNOP();
    21ba:	00 00       	nop

	portDISABLE_INTERRUPTS();
    21bc:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    21be:	9a 8d       	ldd	r25, Y+26	; 0x1a
    21c0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    21c2:	98 17       	cp	r25, r24
    21c4:	80 f4       	brcc	.+32     	; 0x21e6 <xQueueCRSend+0x68>
		{
			/* There is room in the queue, copy the data into the queue. */
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    21c6:	ce 01       	movw	r24, r28
    21c8:	b7 01       	movw	r22, r14
    21ca:	40 e0       	ldi	r20, 0x00	; 0
    21cc:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <prvCopyDataToQueue>
			xReturn = pdPASS;

			/* Were any co-routines waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    21d0:	89 89       	ldd	r24, Y+17	; 0x11
    21d2:	88 23       	and	r24, r24
    21d4:	51 f0       	breq	.+20     	; 0x21ea <xQueueCRSend+0x6c>
			{
				/* In this instance the co-routine could be placed directly
				into the ready list as we are within a critical section.
				Instead the same pending ready list mechanism is used as if
				the event were caused from within an interrupt. */
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    21d6:	ce 01       	movw	r24, r28
    21d8:	41 96       	adiw	r24, 0x11	; 17
    21da:	0e 94 0f 0b 	call	0x161e	; 0x161e <xCoRoutineRemoveFromEventList>
    21de:	88 23       	and	r24, r24
    21e0:	31 f4       	brne	.+12     	; 0x21ee <xQueueCRSend+0x70>
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			/* There is room in the queue, copy the data into the queue. */
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
			xReturn = pdPASS;
    21e2:	81 e0       	ldi	r24, 0x01	; 1
    21e4:	05 c0       	rjmp	.+10     	; 0x21f0 <xQueueCRSend+0x72>
				}
			}
		}
		else
		{
			xReturn = errQUEUE_FULL;
    21e6:	80 e0       	ldi	r24, 0x00	; 0
    21e8:	03 c0       	rjmp	.+6      	; 0x21f0 <xQueueCRSend+0x72>
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			/* There is room in the queue, copy the data into the queue. */
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
			xReturn = pdPASS;
    21ea:	81 e0       	ldi	r24, 0x01	; 1
    21ec:	01 c0       	rjmp	.+2      	; 0x21f0 <xQueueCRSend+0x72>
				the event were caused from within an interrupt. */
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
				{
					/* The co-routine waiting has a higher priority so record
					that a yield might be appropriate. */
					xReturn = errQUEUE_YIELD;
    21ee:	8b ef       	ldi	r24, 0xFB	; 251
		else
		{
			xReturn = errQUEUE_FULL;
		}
	}
	portENABLE_INTERRUPTS();
    21f0:	78 94       	sei

	return xReturn;
}
    21f2:	df 91       	pop	r29
    21f4:	cf 91       	pop	r28
    21f6:	1f 91       	pop	r17
    21f8:	0f 91       	pop	r16
    21fa:	ff 90       	pop	r15
    21fc:	ef 90       	pop	r14
    21fe:	08 95       	ret

00002200 <xQueueCRReceive>:
#endif
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToWait )
{
    2200:	cf 93       	push	r28
    2202:	df 93       	push	r29
    2204:	ec 01       	movw	r28, r24
signed portBASE_TYPE xReturn;

	/* If the queue is already empty we may have to block.  A critical section
	is required to prevent an interrupt adding something to the queue
	between the check to see if the queue is empty and blocking on the queue. */
	portDISABLE_INTERRUPTS();
    2206:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
    2208:	8a 8d       	ldd	r24, Y+26	; 0x1a
    220a:	88 23       	and	r24, r24
    220c:	79 f4       	brne	.+30     	; 0x222c <xQueueCRReceive+0x2c>
		{
			/* There are no messages in the queue, do we want to block or just
			leave with nothing? */
			if( xTicksToWait > ( portTickType ) 0 )
    220e:	41 15       	cp	r20, r1
    2210:	51 05       	cpc	r21, r1
    2212:	49 f0       	breq	.+18     	; 0x2226 <xQueueCRReceive+0x26>
			{
				/* As this is a co-routine we cannot block directly, but return
				indicating that we need to block. */
				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    2214:	be 01       	movw	r22, r28
    2216:	6f 5e       	subi	r22, 0xEF	; 239
    2218:	7f 4f       	sbci	r23, 0xFF	; 255
    221a:	ca 01       	movw	r24, r20
    221c:	0e 94 94 09 	call	0x1328	; 0x1328 <vCoRoutineAddToDelayedList>
				portENABLE_INTERRUPTS();
    2220:	78 94       	sei
				return errQUEUE_BLOCKED;
    2222:	8c ef       	ldi	r24, 0xFC	; 252
    2224:	36 c0       	rjmp	.+108    	; 0x2292 <xQueueCRReceive+0x92>
			}
			else
			{
				portENABLE_INTERRUPTS();
    2226:	78 94       	sei
				return errQUEUE_FULL;
    2228:	80 e0       	ldi	r24, 0x00	; 0
    222a:	33 c0       	rjmp	.+102    	; 0x2292 <xQueueCRReceive+0x92>
			}
		}
	}
	portENABLE_INTERRUPTS();
    222c:	78 94       	sei

	portNOP();
    222e:	00 00       	nop

	portDISABLE_INTERRUPTS();
    2230:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2232:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2234:	88 23       	and	r24, r24
    2236:	39 f1       	breq	.+78     	; 0x2286 <xQueueCRReceive+0x86>
		{
			/* Data is available from the queue. */
			pxQueue->pcReadFrom += pxQueue->uxItemSize;
    2238:	4c 8d       	ldd	r20, Y+28	; 0x1c
    223a:	2e 81       	ldd	r18, Y+6	; 0x06
    223c:	3f 81       	ldd	r19, Y+7	; 0x07
    223e:	24 0f       	add	r18, r20
    2240:	31 1d       	adc	r19, r1
    2242:	3f 83       	std	Y+7, r19	; 0x07
    2244:	2e 83       	std	Y+6, r18	; 0x06
			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    2246:	ea 81       	ldd	r30, Y+2	; 0x02
    2248:	fb 81       	ldd	r31, Y+3	; 0x03
    224a:	2e 17       	cp	r18, r30
    224c:	3f 07       	cpc	r19, r31
    224e:	20 f0       	brcs	.+8      	; 0x2258 <xQueueCRReceive+0x58>
			{
				pxQueue->pcReadFrom = pxQueue->pcHead;
    2250:	88 81       	ld	r24, Y
    2252:	99 81       	ldd	r25, Y+1	; 0x01
    2254:	9f 83       	std	Y+7, r25	; 0x07
    2256:	8e 83       	std	Y+6, r24	; 0x06
			}
			--( pxQueue->uxMessagesWaiting );
    2258:	8a 8d       	ldd	r24, Y+26	; 0x1a
    225a:	81 50       	subi	r24, 0x01	; 1
    225c:	8a 8f       	std	Y+26, r24	; 0x1a
			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    225e:	3e 81       	ldd	r19, Y+6	; 0x06
    2260:	2f 81       	ldd	r18, Y+7	; 0x07
    2262:	86 2f       	mov	r24, r22
    2264:	97 2f       	mov	r25, r23
    2266:	63 2f       	mov	r22, r19
    2268:	72 2f       	mov	r23, r18
    226a:	50 e0       	ldi	r21, 0x00	; 0
    226c:	0e 94 30 17 	call	0x2e60	; 0x2e60 <memcpy>

			xReturn = pdPASS;

			/* Were any co-routines waiting for space to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2270:	88 85       	ldd	r24, Y+8	; 0x08
    2272:	88 23       	and	r24, r24
    2274:	51 f0       	breq	.+20     	; 0x228a <xQueueCRReceive+0x8a>
			{
				/* In this instance the co-routine could be placed directly
				into the ready list as we are within a critical section.
				Instead the same pending ready list mechanism is used as if
				the event were caused from within an interrupt. */
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2276:	ce 01       	movw	r24, r28
    2278:	08 96       	adiw	r24, 0x08	; 8
    227a:	0e 94 0f 0b 	call	0x161e	; 0x161e <xCoRoutineRemoveFromEventList>
    227e:	88 23       	and	r24, r24
    2280:	31 f4       	brne	.+12     	; 0x228e <xQueueCRReceive+0x8e>
				pxQueue->pcReadFrom = pxQueue->pcHead;
			}
			--( pxQueue->uxMessagesWaiting );
			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			xReturn = pdPASS;
    2282:	81 e0       	ldi	r24, 0x01	; 1
    2284:	05 c0       	rjmp	.+10     	; 0x2290 <xQueueCRReceive+0x90>
				}
			}
		}
		else
		{
			xReturn = pdFAIL;
    2286:	80 e0       	ldi	r24, 0x00	; 0
    2288:	03 c0       	rjmp	.+6      	; 0x2290 <xQueueCRReceive+0x90>
				pxQueue->pcReadFrom = pxQueue->pcHead;
			}
			--( pxQueue->uxMessagesWaiting );
			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			xReturn = pdPASS;
    228a:	81 e0       	ldi	r24, 0x01	; 1
    228c:	01 c0       	rjmp	.+2      	; 0x2290 <xQueueCRReceive+0x90>
				into the ready list as we are within a critical section.
				Instead the same pending ready list mechanism is used as if
				the event were caused from within an interrupt. */
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					xReturn = errQUEUE_YIELD;
    228e:	8b ef       	ldi	r24, 0xFB	; 251
		else
		{
			xReturn = pdFAIL;
		}
	}
	portENABLE_INTERRUPTS();
    2290:	78 94       	sei

	return xReturn;
}
    2292:	df 91       	pop	r29
    2294:	cf 91       	pop	r28
    2296:	08 95       	ret

00002298 <xQueueCRSendFromISR>:



#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
{
    2298:	1f 93       	push	r17
    229a:	cf 93       	push	r28
    229c:	df 93       	push	r29
    229e:	ec 01       	movw	r28, r24
    22a0:	14 2f       	mov	r17, r20
	/* Cannot block within an ISR so if there is no space on the queue then
	exit without doing anything. */
	if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    22a2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    22a4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    22a6:	98 17       	cp	r25, r24
    22a8:	88 f4       	brcc	.+34     	; 0x22cc <xQueueCRSendFromISR+0x34>
	{
		prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    22aa:	ce 01       	movw	r24, r28
    22ac:	40 e0       	ldi	r20, 0x00	; 0
    22ae:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <prvCopyDataToQueue>

		/* We only want to wake one co-routine per ISR, so check that a
		co-routine has not already been woken. */
		if( xCoRoutinePreviouslyWoken == pdFALSE )
    22b2:	11 23       	and	r17, r17
    22b4:	59 f4       	brne	.+22     	; 0x22cc <xQueueCRSendFromISR+0x34>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22b6:	89 89       	ldd	r24, Y+17	; 0x11
    22b8:	88 23       	and	r24, r24
    22ba:	41 f0       	breq	.+16     	; 0x22cc <xQueueCRSendFromISR+0x34>
			{
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22bc:	ce 01       	movw	r24, r28
    22be:	41 96       	adiw	r24, 0x11	; 17
    22c0:	0e 94 0f 0b 	call	0x161e	; 0x161e <xCoRoutineRemoveFromEventList>
/*-----------------------------------------------------------*/



#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
    22c4:	11 e0       	ldi	r17, 0x01	; 1
    22c6:	88 23       	and	r24, r24
    22c8:	09 f4       	brne	.+2      	; 0x22cc <xQueueCRSendFromISR+0x34>
    22ca:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
	}

	return xCoRoutinePreviouslyWoken;
}
    22cc:	81 2f       	mov	r24, r17
    22ce:	df 91       	pop	r29
    22d0:	cf 91       	pop	r28
    22d2:	1f 91       	pop	r17
    22d4:	08 95       	ret

000022d6 <xQueueCRReceiveFromISR>:
#endif
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE_TYPE *pxCoRoutineWoken )
{
    22d6:	0f 93       	push	r16
    22d8:	1f 93       	push	r17
    22da:	cf 93       	push	r28
    22dc:	df 93       	push	r29
    22de:	ec 01       	movw	r28, r24
    22e0:	86 2f       	mov	r24, r22
    22e2:	97 2f       	mov	r25, r23
    22e4:	8a 01       	movw	r16, r20
signed portBASE_TYPE xReturn;

	/* We cannot block from an ISR, so check there is data available. If
	not then just leave without doing anything. */
	if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    22e6:	2a 8d       	ldd	r18, Y+26	; 0x1a
    22e8:	22 23       	and	r18, r18
    22ea:	49 f1       	breq	.+82     	; 0x233e <xQueueCRReceiveFromISR+0x68>
	{
		/* Copy the data from the queue. */
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    22ec:	4c 8d       	ldd	r20, Y+28	; 0x1c
    22ee:	2e 81       	ldd	r18, Y+6	; 0x06
    22f0:	3f 81       	ldd	r19, Y+7	; 0x07
    22f2:	24 0f       	add	r18, r20
    22f4:	31 1d       	adc	r19, r1
    22f6:	3f 83       	std	Y+7, r19	; 0x07
    22f8:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    22fa:	ea 81       	ldd	r30, Y+2	; 0x02
    22fc:	fb 81       	ldd	r31, Y+3	; 0x03
    22fe:	2e 17       	cp	r18, r30
    2300:	3f 07       	cpc	r19, r31
    2302:	20 f0       	brcs	.+8      	; 0x230c <xQueueCRReceiveFromISR+0x36>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    2304:	28 81       	ld	r18, Y
    2306:	39 81       	ldd	r19, Y+1	; 0x01
    2308:	3f 83       	std	Y+7, r19	; 0x07
    230a:	2e 83       	std	Y+6, r18	; 0x06
		}
		--( pxQueue->uxMessagesWaiting );
    230c:	2a 8d       	ldd	r18, Y+26	; 0x1a
    230e:	21 50       	subi	r18, 0x01	; 1
    2310:	2a 8f       	std	Y+26, r18	; 0x1a
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2312:	6e 81       	ldd	r22, Y+6	; 0x06
    2314:	7f 81       	ldd	r23, Y+7	; 0x07
    2316:	50 e0       	ldi	r21, 0x00	; 0
    2318:	0e 94 30 17 	call	0x2e60	; 0x2e60 <memcpy>

		if( ( *pxCoRoutineWoken ) == pdFALSE )
    231c:	f8 01       	movw	r30, r16
    231e:	80 81       	ld	r24, Z
    2320:	88 23       	and	r24, r24
    2322:	79 f4       	brne	.+30     	; 0x2342 <xQueueCRReceiveFromISR+0x6c>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2324:	88 85       	ldd	r24, Y+8	; 0x08
    2326:	88 23       	and	r24, r24
    2328:	71 f0       	breq	.+28     	; 0x2346 <xQueueCRReceiveFromISR+0x70>
			{
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    232a:	ce 01       	movw	r24, r28
    232c:	08 96       	adiw	r24, 0x08	; 8
    232e:	0e 94 0f 0b 	call	0x161e	; 0x161e <xCoRoutineRemoveFromEventList>
    2332:	88 23       	and	r24, r24
    2334:	51 f0       	breq	.+20     	; 0x234a <xQueueCRReceiveFromISR+0x74>
				{
					*pxCoRoutineWoken = pdTRUE;
    2336:	81 e0       	ldi	r24, 0x01	; 1
    2338:	f8 01       	movw	r30, r16
    233a:	80 83       	st	Z, r24
    233c:	07 c0       	rjmp	.+14     	; 0x234c <xQueueCRReceiveFromISR+0x76>

		xReturn = pdPASS;
	}
	else
	{
		xReturn = pdFAIL;
    233e:	80 e0       	ldi	r24, 0x00	; 0
    2340:	05 c0       	rjmp	.+10     	; 0x234c <xQueueCRReceiveFromISR+0x76>
					*pxCoRoutineWoken = pdTRUE;
				}
			}
		}

		xReturn = pdPASS;
    2342:	81 e0       	ldi	r24, 0x01	; 1
    2344:	03 c0       	rjmp	.+6      	; 0x234c <xQueueCRReceiveFromISR+0x76>
    2346:	81 e0       	ldi	r24, 0x01	; 1
    2348:	01 c0       	rjmp	.+2      	; 0x234c <xQueueCRReceiveFromISR+0x76>
    234a:	81 e0       	ldi	r24, 0x01	; 1
	{
		xReturn = pdFAIL;
	}

	return xReturn;
}
    234c:	df 91       	pop	r29
    234e:	cf 91       	pop	r28
    2350:	1f 91       	pop	r17
    2352:	0f 91       	pop	r16
    2354:	08 95       	ret

00002356 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    2356:	cf 93       	push	r28
    2358:	df 93       	push	r29
    235a:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    235c:	e0 91 b3 06 	lds	r30, 0x06B3
    2360:	f0 91 b4 06 	lds	r31, 0x06B4
    2364:	93 83       	std	Z+3, r25	; 0x03
    2366:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    2368:	80 91 bb 06 	lds	r24, 0x06BB
    236c:	90 91 bc 06 	lds	r25, 0x06BC
    2370:	c8 17       	cp	r28, r24
    2372:	d9 07       	cpc	r29, r25
    2374:	68 f4       	brcc	.+26     	; 0x2390 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2376:	80 91 bf 06 	lds	r24, 0x06BF
    237a:	90 91 c0 06 	lds	r25, 0x06C0
    237e:	60 91 b3 06 	lds	r22, 0x06B3
    2382:	70 91 b4 06 	lds	r23, 0x06B4
    2386:	6e 5f       	subi	r22, 0xFE	; 254
    2388:	7f 4f       	sbci	r23, 0xFF	; 255
    238a:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <vListInsert>
    238e:	17 c0       	rjmp	.+46     	; 0x23be <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2390:	80 91 c1 06 	lds	r24, 0x06C1
    2394:	90 91 c2 06 	lds	r25, 0x06C2
    2398:	60 91 b3 06 	lds	r22, 0x06B3
    239c:	70 91 b4 06 	lds	r23, 0x06B4
    23a0:	6e 5f       	subi	r22, 0xFE	; 254
    23a2:	7f 4f       	sbci	r23, 0xFF	; 255
    23a4:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    23a8:	80 91 67 00 	lds	r24, 0x0067
    23ac:	90 91 68 00 	lds	r25, 0x0068
    23b0:	c8 17       	cp	r28, r24
    23b2:	d9 07       	cpc	r29, r25
    23b4:	20 f4       	brcc	.+8      	; 0x23be <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    23b6:	d0 93 68 00 	sts	0x0068, r29
    23ba:	c0 93 67 00 	sts	0x0067, r28
		}
	}
}
    23be:	df 91       	pop	r29
    23c0:	cf 91       	pop	r28
    23c2:	08 95       	ret

000023c4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    23c4:	4f 92       	push	r4
    23c6:	5f 92       	push	r5
    23c8:	6f 92       	push	r6
    23ca:	7f 92       	push	r7
    23cc:	8f 92       	push	r8
    23ce:	9f 92       	push	r9
    23d0:	bf 92       	push	r11
    23d2:	cf 92       	push	r12
    23d4:	df 92       	push	r13
    23d6:	ef 92       	push	r14
    23d8:	ff 92       	push	r15
    23da:	0f 93       	push	r16
    23dc:	1f 93       	push	r17
    23de:	cf 93       	push	r28
    23e0:	df 93       	push	r29
    23e2:	2c 01       	movw	r4, r24
    23e4:	4b 01       	movw	r8, r22
    23e6:	ea 01       	movw	r28, r20
    23e8:	39 01       	movw	r6, r18
    23ea:	b0 2e       	mov	r11, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    23ec:	81 e2       	ldi	r24, 0x21	; 33
    23ee:	90 e0       	ldi	r25, 0x00	; 0
    23f0:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <pvPortMalloc>
    23f4:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    23f6:	00 97       	sbiw	r24, 0x00	; 0
    23f8:	09 f4       	brne	.+2      	; 0x23fc <xTaskGenericCreate+0x38>
    23fa:	e2 c0       	rjmp	.+452    	; 0x25c0 <xTaskGenericCreate+0x1fc>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    23fc:	c1 14       	cp	r12, r1
    23fe:	d1 04       	cpc	r13, r1
    2400:	09 f0       	breq	.+2      	; 0x2404 <xTaskGenericCreate+0x40>
    2402:	f3 c0       	rjmp	.+486    	; 0x25ea <xTaskGenericCreate+0x226>
    2404:	ce 01       	movw	r24, r28
    2406:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <pvPortMalloc>
    240a:	6c 01       	movw	r12, r24
    240c:	f8 01       	movw	r30, r16
    240e:	90 8f       	std	Z+24, r25	; 0x18
    2410:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2412:	00 97       	sbiw	r24, 0x00	; 0
    2414:	29 f4       	brne	.+10     	; 0x2420 <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2416:	c8 01       	movw	r24, r16
    2418:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    241c:	8f ef       	ldi	r24, 0xFF	; 255
    241e:	d5 c0       	rjmp	.+426    	; 0x25ca <xTaskGenericCreate+0x206>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2420:	c6 01       	movw	r24, r12
    2422:	65 ea       	ldi	r22, 0xA5	; 165
    2424:	70 e0       	ldi	r23, 0x00	; 0
    2426:	ae 01       	movw	r20, r28
    2428:	0e 94 39 17 	call	0x2e72	; 0x2e72 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    242c:	9e 01       	movw	r18, r28
    242e:	21 50       	subi	r18, 0x01	; 1
    2430:	30 40       	sbci	r19, 0x00	; 0
    2432:	f8 01       	movw	r30, r16
    2434:	87 89       	ldd	r24, Z+23	; 0x17
    2436:	90 8d       	ldd	r25, Z+24	; 0x18
    2438:	6c 01       	movw	r12, r24
    243a:	c2 0e       	add	r12, r18
    243c:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    243e:	c8 01       	movw	r24, r16
    2440:	49 96       	adiw	r24, 0x19	; 25
    2442:	b4 01       	movw	r22, r8
    2444:	48 e0       	ldi	r20, 0x08	; 8
    2446:	50 e0       	ldi	r21, 0x00	; 0
    2448:	0e 94 40 17 	call	0x2e80	; 0x2e80 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    244c:	f8 01       	movw	r30, r16
    244e:	10 a2       	lds	r17, 0x90
    2450:	cb 2d       	mov	r28, r11
    2452:	f3 e0       	ldi	r31, 0x03	; 3
    2454:	fb 15       	cp	r31, r11
    2456:	08 f4       	brcc	.+2      	; 0x245a <xTaskGenericCreate+0x96>
    2458:	c3 e0       	ldi	r28, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    245a:	f8 01       	movw	r30, r16
    245c:	c6 8b       	std	Z+22, r28	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    245e:	88 24       	eor	r8, r8
    2460:	99 24       	eor	r9, r9
    2462:	68 94       	set
    2464:	81 f8       	bld	r8, 1
    2466:	80 0e       	add	r8, r16
    2468:	91 1e       	adc	r9, r17
    246a:	c4 01       	movw	r24, r8
    246c:	0e 94 44 0b 	call	0x1688	; 0x1688 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2470:	c8 01       	movw	r24, r16
    2472:	0c 96       	adiw	r24, 0x0c	; 12
    2474:	0e 94 44 0b 	call	0x1688	; 0x1688 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2478:	f8 01       	movw	r30, r16
    247a:	11 87       	std	Z+9, r17	; 0x09
    247c:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    247e:	84 e0       	ldi	r24, 0x04	; 4
    2480:	90 e0       	ldi	r25, 0x00	; 0
    2482:	8c 1b       	sub	r24, r28
    2484:	91 09       	sbc	r25, r1
    2486:	95 87       	std	Z+13, r25	; 0x0d
    2488:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    248a:	13 8b       	std	Z+19, r17	; 0x13
    248c:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    248e:	c6 01       	movw	r24, r12
    2490:	b2 01       	movw	r22, r4
    2492:	a3 01       	movw	r20, r6
    2494:	0e 94 d5 0b 	call	0x17aa	; 0x17aa <pxPortInitialiseStack>
    2498:	f8 01       	movw	r30, r16
    249a:	91 83       	std	Z+1, r25	; 0x01
    249c:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    249e:	e1 14       	cp	r14, r1
    24a0:	f1 04       	cpc	r15, r1
    24a2:	19 f0       	breq	.+6      	; 0x24aa <xTaskGenericCreate+0xe6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    24a4:	f7 01       	movw	r30, r14
    24a6:	11 83       	std	Z+1, r17	; 0x01
    24a8:	00 83       	st	Z, r16
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    24aa:	0f b6       	in	r0, 0x3f	; 63
    24ac:	f8 94       	cli
    24ae:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    24b0:	80 91 bd 06 	lds	r24, 0x06BD
    24b4:	8f 5f       	subi	r24, 0xFF	; 255
    24b6:	80 93 bd 06 	sts	0x06BD, r24
			if( pxCurrentTCB == NULL )
    24ba:	80 91 b3 06 	lds	r24, 0x06B3
    24be:	90 91 b4 06 	lds	r25, 0x06B4
    24c2:	00 97       	sbiw	r24, 0x00	; 0
    24c4:	d9 f5       	brne	.+118    	; 0x253c <xTaskGenericCreate+0x178>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    24c6:	10 93 b4 06 	sts	0x06B4, r17
    24ca:	00 93 b3 06 	sts	0x06B3, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    24ce:	80 91 bd 06 	lds	r24, 0x06BD
    24d2:	81 30       	cpi	r24, 0x01	; 1
    24d4:	09 f0       	breq	.+2      	; 0x24d8 <xTaskGenericCreate+0x114>
    24d6:	41 c0       	rjmp	.+130    	; 0x255a <xTaskGenericCreate+0x196>
    24d8:	c0 e0       	ldi	r28, 0x00	; 0
    24da:	d0 e0       	ldi	r29, 0x00	; 0
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    24dc:	ce 01       	movw	r24, r28
    24de:	88 0f       	add	r24, r24
    24e0:	99 1f       	adc	r25, r25
    24e2:	88 0f       	add	r24, r24
    24e4:	99 1f       	adc	r25, r25
    24e6:	88 0f       	add	r24, r24
    24e8:	99 1f       	adc	r25, r25
    24ea:	8c 0f       	add	r24, r28
    24ec:	9d 1f       	adc	r25, r29
    24ee:	8b 53       	subi	r24, 0x3B	; 59
    24f0:	99 4f       	sbci	r25, 0xF9	; 249
    24f2:	0e 94 36 0b 	call	0x166c	; 0x166c <vListInitialise>
    24f6:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    24f8:	c4 30       	cpi	r28, 0x04	; 4
    24fa:	d1 05       	cpc	r29, r1
    24fc:	79 f7       	brne	.-34     	; 0x24dc <xTaskGenericCreate+0x118>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    24fe:	c9 ee       	ldi	r28, 0xE9	; 233
    2500:	d6 e0       	ldi	r29, 0x06	; 6
    2502:	ce 01       	movw	r24, r28
    2504:	0e 94 36 0b 	call	0x166c	; 0x166c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2508:	0f 2e       	mov	r0, r31
    250a:	f2 ef       	ldi	r31, 0xF2	; 242
    250c:	ef 2e       	mov	r14, r31
    250e:	f6 e0       	ldi	r31, 0x06	; 6
    2510:	ff 2e       	mov	r15, r31
    2512:	f0 2d       	mov	r31, r0
    2514:	c7 01       	movw	r24, r14
    2516:	0e 94 36 0b 	call	0x166c	; 0x166c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    251a:	8b ef       	ldi	r24, 0xFB	; 251
    251c:	96 e0       	ldi	r25, 0x06	; 6
    251e:	0e 94 36 0b 	call	0x166c	; 0x166c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2522:	84 e0       	ldi	r24, 0x04	; 4
    2524:	97 e0       	ldi	r25, 0x07	; 7
    2526:	0e 94 36 0b 	call	0x166c	; 0x166c <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    252a:	d0 93 c2 06 	sts	0x06C2, r29
    252e:	c0 93 c1 06 	sts	0x06C1, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2532:	f0 92 c0 06 	sts	0x06C0, r15
    2536:	e0 92 bf 06 	sts	0x06BF, r14
    253a:	0f c0       	rjmp	.+30     	; 0x255a <xTaskGenericCreate+0x196>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    253c:	80 91 b9 06 	lds	r24, 0x06B9
    2540:	88 23       	and	r24, r24
    2542:	59 f4       	brne	.+22     	; 0x255a <xTaskGenericCreate+0x196>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2544:	e0 91 b3 06 	lds	r30, 0x06B3
    2548:	f0 91 b4 06 	lds	r31, 0x06B4
    254c:	86 89       	ldd	r24, Z+22	; 0x16
    254e:	b8 16       	cp	r11, r24
    2550:	20 f0       	brcs	.+8      	; 0x255a <xTaskGenericCreate+0x196>
					{
						pxCurrentTCB = pxNewTCB;
    2552:	10 93 b4 06 	sts	0x06B4, r17
    2556:	00 93 b3 06 	sts	0x06B3, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    255a:	f8 01       	movw	r30, r16
    255c:	86 89       	ldd	r24, Z+22	; 0x16
    255e:	90 91 c3 06 	lds	r25, 0x06C3
    2562:	98 17       	cp	r25, r24
    2564:	10 f4       	brcc	.+4      	; 0x256a <xTaskGenericCreate+0x1a6>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    2566:	80 93 c3 06 	sts	0x06C3, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    256a:	90 91 c4 06 	lds	r25, 0x06C4
    256e:	9f 5f       	subi	r25, 0xFF	; 255
    2570:	90 93 c4 06 	sts	0x06C4, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    2574:	90 91 ba 06 	lds	r25, 0x06BA
    2578:	98 17       	cp	r25, r24
    257a:	10 f4       	brcc	.+4      	; 0x2580 <xTaskGenericCreate+0x1bc>
    257c:	80 93 ba 06 	sts	0x06BA, r24
    2580:	90 e0       	ldi	r25, 0x00	; 0
    2582:	9c 01       	movw	r18, r24
    2584:	22 0f       	add	r18, r18
    2586:	33 1f       	adc	r19, r19
    2588:	22 0f       	add	r18, r18
    258a:	33 1f       	adc	r19, r19
    258c:	22 0f       	add	r18, r18
    258e:	33 1f       	adc	r19, r19
    2590:	82 0f       	add	r24, r18
    2592:	93 1f       	adc	r25, r19
    2594:	8b 53       	subi	r24, 0x3B	; 59
    2596:	99 4f       	sbci	r25, 0xF9	; 249
    2598:	b4 01       	movw	r22, r8
    259a:	0e 94 48 0b 	call	0x1690	; 0x1690 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    259e:	0f 90       	pop	r0
    25a0:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    25a2:	80 91 b9 06 	lds	r24, 0x06B9
    25a6:	88 23       	and	r24, r24
    25a8:	69 f0       	breq	.+26     	; 0x25c4 <xTaskGenericCreate+0x200>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    25aa:	e0 91 b3 06 	lds	r30, 0x06B3
    25ae:	f0 91 b4 06 	lds	r31, 0x06B4
    25b2:	86 89       	ldd	r24, Z+22	; 0x16
    25b4:	8b 15       	cp	r24, r11
    25b6:	40 f4       	brcc	.+16     	; 0x25c8 <xTaskGenericCreate+0x204>
			{
				portYIELD_WITHIN_API();
    25b8:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    25bc:	81 e0       	ldi	r24, 0x01	; 1
    25be:	05 c0       	rjmp	.+10     	; 0x25ca <xTaskGenericCreate+0x206>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    25c0:	8f ef       	ldi	r24, 0xFF	; 255
    25c2:	03 c0       	rjmp	.+6      	; 0x25ca <xTaskGenericCreate+0x206>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    25c4:	81 e0       	ldi	r24, 0x01	; 1
    25c6:	01 c0       	rjmp	.+2      	; 0x25ca <xTaskGenericCreate+0x206>
    25c8:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    25ca:	df 91       	pop	r29
    25cc:	cf 91       	pop	r28
    25ce:	1f 91       	pop	r17
    25d0:	0f 91       	pop	r16
    25d2:	ff 90       	pop	r15
    25d4:	ef 90       	pop	r14
    25d6:	df 90       	pop	r13
    25d8:	cf 90       	pop	r12
    25da:	bf 90       	pop	r11
    25dc:	9f 90       	pop	r9
    25de:	8f 90       	pop	r8
    25e0:	7f 90       	pop	r7
    25e2:	6f 90       	pop	r6
    25e4:	5f 90       	pop	r5
    25e6:	4f 90       	pop	r4
    25e8:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    25ea:	fc 01       	movw	r30, r24
    25ec:	d0 8e       	std	Z+24, r13	; 0x18
    25ee:	c7 8a       	std	Z+23, r12	; 0x17
    25f0:	17 cf       	rjmp	.-466    	; 0x2420 <xTaskGenericCreate+0x5c>

000025f2 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    25f2:	ef 92       	push	r14
    25f4:	ff 92       	push	r15
    25f6:	0f 93       	push	r16
    25f8:	1f 93       	push	r17
    25fa:	cf 93       	push	r28
    25fc:	df 93       	push	r29
    25fe:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    2600:	0f b6       	in	r0, 0x3f	; 63
    2602:	f8 94       	cli
    2604:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    2606:	80 91 b3 06 	lds	r24, 0x06B3
    260a:	90 91 b4 06 	lds	r25, 0x06B4
    260e:	e8 16       	cp	r14, r24
    2610:	f9 06       	cpc	r15, r25
    2612:	21 f0       	breq	.+8      	; 0x261c <vTaskDelete+0x2a>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2614:	e1 14       	cp	r14, r1
    2616:	f1 04       	cpc	r15, r1
    2618:	41 f4       	brne	.+16     	; 0x262a <vTaskDelete+0x38>
    261a:	02 c0       	rjmp	.+4      	; 0x2620 <vTaskDelete+0x2e>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
			{
				pxTaskToDelete = NULL;
    261c:	ee 24       	eor	r14, r14
    261e:	ff 24       	eor	r15, r15
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2620:	c0 91 b3 06 	lds	r28, 0x06B3
    2624:	d0 91 b4 06 	lds	r29, 0x06B4
    2628:	01 c0       	rjmp	.+2      	; 0x262c <vTaskDelete+0x3a>
    262a:	e7 01       	movw	r28, r14

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    262c:	8e 01       	movw	r16, r28
    262e:	0e 5f       	subi	r16, 0xFE	; 254
    2630:	1f 4f       	sbci	r17, 0xFF	; 255
    2632:	c8 01       	movw	r24, r16
    2634:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    2638:	8c 89       	ldd	r24, Y+20	; 0x14
    263a:	9d 89       	ldd	r25, Y+21	; 0x15
    263c:	00 97       	sbiw	r24, 0x00	; 0
    263e:	21 f0       	breq	.+8      	; 0x2648 <vTaskDelete+0x56>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
    2640:	ce 01       	movw	r24, r28
    2642:	0c 96       	adiw	r24, 0x0c	; 12
    2644:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2648:	84 e0       	ldi	r24, 0x04	; 4
    264a:	97 e0       	ldi	r25, 0x07	; 7
    264c:	b8 01       	movw	r22, r16
    264e:	0e 94 48 0b 	call	0x1690	; 0x1690 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    2652:	80 91 be 06 	lds	r24, 0x06BE
    2656:	8f 5f       	subi	r24, 0xFF	; 255
    2658:	80 93 be 06 	sts	0x06BE, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    265c:	80 91 c4 06 	lds	r24, 0x06C4
    2660:	8f 5f       	subi	r24, 0xFF	; 255
    2662:	80 93 c4 06 	sts	0x06C4, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    2666:	0f 90       	pop	r0
    2668:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    266a:	80 91 b9 06 	lds	r24, 0x06B9
    266e:	88 23       	and	r24, r24
    2670:	29 f0       	breq	.+10     	; 0x267c <vTaskDelete+0x8a>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    2672:	e1 14       	cp	r14, r1
    2674:	f1 04       	cpc	r15, r1
    2676:	11 f4       	brne	.+4      	; 0x267c <vTaskDelete+0x8a>
			{
				portYIELD_WITHIN_API();
    2678:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vPortYield>
			}
		}
	}
    267c:	df 91       	pop	r29
    267e:	cf 91       	pop	r28
    2680:	1f 91       	pop	r17
    2682:	0f 91       	pop	r16
    2684:	ff 90       	pop	r15
    2686:	ef 90       	pop	r14
    2688:	08 95       	ret

0000268a <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    268a:	af 92       	push	r10
    268c:	bf 92       	push	r11
    268e:	cf 92       	push	r12
    2690:	df 92       	push	r13
    2692:	ef 92       	push	r14
    2694:	ff 92       	push	r15
    2696:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2698:	84 ee       	ldi	r24, 0xE4	; 228
    269a:	94 e1       	ldi	r25, 0x14	; 20
    269c:	62 e6       	ldi	r22, 0x62	; 98
    269e:	70 e0       	ldi	r23, 0x00	; 0
    26a0:	45 e5       	ldi	r20, 0x55	; 85
    26a2:	50 e0       	ldi	r21, 0x00	; 0
    26a4:	20 e0       	ldi	r18, 0x00	; 0
    26a6:	30 e0       	ldi	r19, 0x00	; 0
    26a8:	00 e0       	ldi	r16, 0x00	; 0
    26aa:	ee 24       	eor	r14, r14
    26ac:	ff 24       	eor	r15, r15
    26ae:	cc 24       	eor	r12, r12
    26b0:	dd 24       	eor	r13, r13
    26b2:	aa 24       	eor	r10, r10
    26b4:	bb 24       	eor	r11, r11
    26b6:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    26ba:	81 30       	cpi	r24, 0x01	; 1
    26bc:	49 f4       	brne	.+18     	; 0x26d0 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    26be:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    26c0:	80 93 b9 06 	sts	0x06B9, r24
		xTickCount = ( portTickType ) 0U;
    26c4:	10 92 bc 06 	sts	0x06BC, r1
    26c8:	10 92 bb 06 	sts	0x06BB, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    26cc:	0e 94 65 0c 	call	0x18ca	; 0x18ca <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    26d0:	0f 91       	pop	r16
    26d2:	ff 90       	pop	r15
    26d4:	ef 90       	pop	r14
    26d6:	df 90       	pop	r13
    26d8:	cf 90       	pop	r12
    26da:	bf 90       	pop	r11
    26dc:	af 90       	pop	r10
    26de:	08 95       	ret

000026e0 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    26e0:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    26e2:	10 92 b9 06 	sts	0x06B9, r1
	vPortEndScheduler();
    26e6:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vPortEndScheduler>
}
    26ea:	08 95       	ret

000026ec <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    26ec:	80 91 b8 06 	lds	r24, 0x06B8
    26f0:	8f 5f       	subi	r24, 0xFF	; 255
    26f2:	80 93 b8 06 	sts	0x06B8, r24
}
    26f6:	08 95       	ret

000026f8 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    26f8:	0f b6       	in	r0, 0x3f	; 63
    26fa:	f8 94       	cli
    26fc:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    26fe:	80 91 bb 06 	lds	r24, 0x06BB
    2702:	90 91 bc 06 	lds	r25, 0x06BC
	}
	taskEXIT_CRITICAL();
    2706:	0f 90       	pop	r0
    2708:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    270a:	08 95       	ret

0000270c <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    270c:	80 91 bb 06 	lds	r24, 0x06BB
    2710:	90 91 bc 06 	lds	r25, 0x06BC
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2714:	08 95       	ret

00002716 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2716:	80 91 bd 06 	lds	r24, 0x06BD
}
    271a:	08 95       	ret

0000271c <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    271c:	0f 93       	push	r16
    271e:	1f 93       	push	r17
    2720:	cf 93       	push	r28
    2722:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2724:	80 91 b8 06 	lds	r24, 0x06B8
    2728:	88 23       	and	r24, r24
    272a:	09 f0       	breq	.+2      	; 0x272e <vTaskIncrementTick+0x12>
    272c:	b3 c0       	rjmp	.+358    	; 0x2894 <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    272e:	80 91 bb 06 	lds	r24, 0x06BB
    2732:	90 91 bc 06 	lds	r25, 0x06BC
    2736:	01 96       	adiw	r24, 0x01	; 1
    2738:	90 93 bc 06 	sts	0x06BC, r25
    273c:	80 93 bb 06 	sts	0x06BB, r24
		if( xTickCount == ( portTickType ) 0U )
    2740:	80 91 bb 06 	lds	r24, 0x06BB
    2744:	90 91 bc 06 	lds	r25, 0x06BC
    2748:	00 97       	sbiw	r24, 0x00	; 0
    274a:	99 f5       	brne	.+102    	; 0x27b2 <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
    274c:	80 91 c1 06 	lds	r24, 0x06C1
    2750:	90 91 c2 06 	lds	r25, 0x06C2
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2754:	20 91 bf 06 	lds	r18, 0x06BF
    2758:	30 91 c0 06 	lds	r19, 0x06C0
    275c:	30 93 c2 06 	sts	0x06C2, r19
    2760:	20 93 c1 06 	sts	0x06C1, r18
			pxOverflowDelayedTaskList = pxTemp;
    2764:	90 93 c0 06 	sts	0x06C0, r25
    2768:	80 93 bf 06 	sts	0x06BF, r24
			xNumOfOverflows++;
    276c:	80 91 b5 06 	lds	r24, 0x06B5
    2770:	8f 5f       	subi	r24, 0xFF	; 255
    2772:	80 93 b5 06 	sts	0x06B5, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2776:	e0 91 c1 06 	lds	r30, 0x06C1
    277a:	f0 91 c2 06 	lds	r31, 0x06C2
    277e:	80 81       	ld	r24, Z
    2780:	88 23       	and	r24, r24
    2782:	39 f4       	brne	.+14     	; 0x2792 <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2784:	8f ef       	ldi	r24, 0xFF	; 255
    2786:	9f ef       	ldi	r25, 0xFF	; 255
    2788:	90 93 68 00 	sts	0x0068, r25
    278c:	80 93 67 00 	sts	0x0067, r24
    2790:	10 c0       	rjmp	.+32     	; 0x27b2 <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2792:	e0 91 c1 06 	lds	r30, 0x06C1
    2796:	f0 91 c2 06 	lds	r31, 0x06C2
    279a:	05 80       	ldd	r0, Z+5	; 0x05
    279c:	f6 81       	ldd	r31, Z+6	; 0x06
    279e:	e0 2d       	mov	r30, r0
    27a0:	06 80       	ldd	r0, Z+6	; 0x06
    27a2:	f7 81       	ldd	r31, Z+7	; 0x07
    27a4:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    27a6:	82 81       	ldd	r24, Z+2	; 0x02
    27a8:	93 81       	ldd	r25, Z+3	; 0x03
    27aa:	90 93 68 00 	sts	0x0068, r25
    27ae:	80 93 67 00 	sts	0x0067, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    27b2:	20 91 bb 06 	lds	r18, 0x06BB
    27b6:	30 91 bc 06 	lds	r19, 0x06BC
    27ba:	80 91 67 00 	lds	r24, 0x0067
    27be:	90 91 68 00 	lds	r25, 0x0068
    27c2:	28 17       	cp	r18, r24
    27c4:	39 07       	cpc	r19, r25
    27c6:	08 f4       	brcc	.+2      	; 0x27ca <vTaskIncrementTick+0xae>
    27c8:	6a c0       	rjmp	.+212    	; 0x289e <vTaskIncrementTick+0x182>
    27ca:	e0 91 c1 06 	lds	r30, 0x06C1
    27ce:	f0 91 c2 06 	lds	r31, 0x06C2
    27d2:	80 81       	ld	r24, Z
    27d4:	88 23       	and	r24, r24
    27d6:	99 f0       	breq	.+38     	; 0x27fe <vTaskIncrementTick+0xe2>
    27d8:	e0 91 c1 06 	lds	r30, 0x06C1
    27dc:	f0 91 c2 06 	lds	r31, 0x06C2
    27e0:	05 80       	ldd	r0, Z+5	; 0x05
    27e2:	f6 81       	ldd	r31, Z+6	; 0x06
    27e4:	e0 2d       	mov	r30, r0
    27e6:	c6 81       	ldd	r28, Z+6	; 0x06
    27e8:	d7 81       	ldd	r29, Z+7	; 0x07
    27ea:	8a 81       	ldd	r24, Y+2	; 0x02
    27ec:	9b 81       	ldd	r25, Y+3	; 0x03
    27ee:	20 91 bb 06 	lds	r18, 0x06BB
    27f2:	30 91 bc 06 	lds	r19, 0x06BC
    27f6:	28 17       	cp	r18, r24
    27f8:	39 07       	cpc	r19, r25
    27fa:	f8 f4       	brcc	.+62     	; 0x283a <vTaskIncrementTick+0x11e>
    27fc:	19 c0       	rjmp	.+50     	; 0x2830 <vTaskIncrementTick+0x114>
    27fe:	8f ef       	ldi	r24, 0xFF	; 255
    2800:	9f ef       	ldi	r25, 0xFF	; 255
    2802:	90 93 68 00 	sts	0x0068, r25
    2806:	80 93 67 00 	sts	0x0067, r24
    280a:	49 c0       	rjmp	.+146    	; 0x289e <vTaskIncrementTick+0x182>
    280c:	e0 91 c1 06 	lds	r30, 0x06C1
    2810:	f0 91 c2 06 	lds	r31, 0x06C2
    2814:	05 80       	ldd	r0, Z+5	; 0x05
    2816:	f6 81       	ldd	r31, Z+6	; 0x06
    2818:	e0 2d       	mov	r30, r0
    281a:	c6 81       	ldd	r28, Z+6	; 0x06
    281c:	d7 81       	ldd	r29, Z+7	; 0x07
    281e:	8a 81       	ldd	r24, Y+2	; 0x02
    2820:	9b 81       	ldd	r25, Y+3	; 0x03
    2822:	20 91 bb 06 	lds	r18, 0x06BB
    2826:	30 91 bc 06 	lds	r19, 0x06BC
    282a:	28 17       	cp	r18, r24
    282c:	39 07       	cpc	r19, r25
    282e:	28 f4       	brcc	.+10     	; 0x283a <vTaskIncrementTick+0x11e>
    2830:	90 93 68 00 	sts	0x0068, r25
    2834:	80 93 67 00 	sts	0x0067, r24
    2838:	32 c0       	rjmp	.+100    	; 0x289e <vTaskIncrementTick+0x182>
    283a:	8e 01       	movw	r16, r28
    283c:	0e 5f       	subi	r16, 0xFE	; 254
    283e:	1f 4f       	sbci	r17, 0xFF	; 255
    2840:	c8 01       	movw	r24, r16
    2842:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>
    2846:	8c 89       	ldd	r24, Y+20	; 0x14
    2848:	9d 89       	ldd	r25, Y+21	; 0x15
    284a:	00 97       	sbiw	r24, 0x00	; 0
    284c:	21 f0       	breq	.+8      	; 0x2856 <vTaskIncrementTick+0x13a>
    284e:	ce 01       	movw	r24, r28
    2850:	0c 96       	adiw	r24, 0x0c	; 12
    2852:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>
    2856:	8e 89       	ldd	r24, Y+22	; 0x16
    2858:	90 91 ba 06 	lds	r25, 0x06BA
    285c:	98 17       	cp	r25, r24
    285e:	10 f4       	brcc	.+4      	; 0x2864 <vTaskIncrementTick+0x148>
    2860:	80 93 ba 06 	sts	0x06BA, r24
    2864:	90 e0       	ldi	r25, 0x00	; 0
    2866:	9c 01       	movw	r18, r24
    2868:	22 0f       	add	r18, r18
    286a:	33 1f       	adc	r19, r19
    286c:	22 0f       	add	r18, r18
    286e:	33 1f       	adc	r19, r19
    2870:	22 0f       	add	r18, r18
    2872:	33 1f       	adc	r19, r19
    2874:	82 0f       	add	r24, r18
    2876:	93 1f       	adc	r25, r19
    2878:	8b 53       	subi	r24, 0x3B	; 59
    287a:	99 4f       	sbci	r25, 0xF9	; 249
    287c:	b8 01       	movw	r22, r16
    287e:	0e 94 48 0b 	call	0x1690	; 0x1690 <vListInsertEnd>
    2882:	e0 91 c1 06 	lds	r30, 0x06C1
    2886:	f0 91 c2 06 	lds	r31, 0x06C2
    288a:	80 81       	ld	r24, Z
    288c:	88 23       	and	r24, r24
    288e:	09 f0       	breq	.+2      	; 0x2892 <vTaskIncrementTick+0x176>
    2890:	bd cf       	rjmp	.-134    	; 0x280c <vTaskIncrementTick+0xf0>
    2892:	b5 cf       	rjmp	.-150    	; 0x27fe <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    2894:	80 91 b7 06 	lds	r24, 0x06B7
    2898:	8f 5f       	subi	r24, 0xFF	; 255
    289a:	80 93 b7 06 	sts	0x06B7, r24
		{
			vApplicationTickHook();
		}
	}
	#endif
}
    289e:	df 91       	pop	r29
    28a0:	cf 91       	pop	r28
    28a2:	1f 91       	pop	r17
    28a4:	0f 91       	pop	r16
    28a6:	08 95       	ret

000028a8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    28a8:	af 92       	push	r10
    28aa:	bf 92       	push	r11
    28ac:	cf 92       	push	r12
    28ae:	df 92       	push	r13
    28b0:	ef 92       	push	r14
    28b2:	ff 92       	push	r15
    28b4:	0f 93       	push	r16
    28b6:	1f 93       	push	r17
    28b8:	cf 93       	push	r28
    28ba:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    28bc:	0f b6       	in	r0, 0x3f	; 63
    28be:	f8 94       	cli
    28c0:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    28c2:	80 91 b8 06 	lds	r24, 0x06B8
    28c6:	81 50       	subi	r24, 0x01	; 1
    28c8:	80 93 b8 06 	sts	0x06B8, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    28cc:	80 91 b8 06 	lds	r24, 0x06B8
    28d0:	88 23       	and	r24, r24
    28d2:	09 f0       	breq	.+2      	; 0x28d6 <xTaskResumeAll+0x2e>
    28d4:	69 c0       	rjmp	.+210    	; 0x29a8 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    28d6:	80 91 bd 06 	lds	r24, 0x06BD
    28da:	88 23       	and	r24, r24
    28dc:	81 f5       	brne	.+96     	; 0x293e <xTaskResumeAll+0x96>
    28de:	67 c0       	rjmp	.+206    	; 0x29ae <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    28e0:	d6 01       	movw	r26, r12
    28e2:	ed 91       	ld	r30, X+
    28e4:	fc 91       	ld	r31, X
    28e6:	c6 81       	ldd	r28, Z+6	; 0x06
    28e8:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
    28ea:	ce 01       	movw	r24, r28
    28ec:	0c 96       	adiw	r24, 0x0c	; 12
    28ee:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
    28f2:	8e 01       	movw	r16, r28
    28f4:	0e 5f       	subi	r16, 0xFE	; 254
    28f6:	1f 4f       	sbci	r17, 0xFF	; 255
    28f8:	c8 01       	movw	r24, r16
    28fa:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    28fe:	8e 89       	ldd	r24, Y+22	; 0x16
    2900:	90 91 ba 06 	lds	r25, 0x06BA
    2904:	98 17       	cp	r25, r24
    2906:	10 f4       	brcc	.+4      	; 0x290c <xTaskResumeAll+0x64>
    2908:	80 93 ba 06 	sts	0x06BA, r24
    290c:	90 e0       	ldi	r25, 0x00	; 0
    290e:	9c 01       	movw	r18, r24
    2910:	22 0f       	add	r18, r18
    2912:	33 1f       	adc	r19, r19
    2914:	22 0f       	add	r18, r18
    2916:	33 1f       	adc	r19, r19
    2918:	22 0f       	add	r18, r18
    291a:	33 1f       	adc	r19, r19
    291c:	82 0f       	add	r24, r18
    291e:	93 1f       	adc	r25, r19
    2920:	8b 53       	subi	r24, 0x3B	; 59
    2922:	99 4f       	sbci	r25, 0xF9	; 249
    2924:	b8 01       	movw	r22, r16
    2926:	0e 94 48 0b 	call	0x1690	; 0x1690 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    292a:	e0 91 b3 06 	lds	r30, 0x06B3
    292e:	f0 91 b4 06 	lds	r31, 0x06B4
    2932:	9e 89       	ldd	r25, Y+22	; 0x16
    2934:	86 89       	ldd	r24, Z+22	; 0x16
    2936:	98 17       	cp	r25, r24
    2938:	88 f0       	brcs	.+34     	; 0x295c <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    293a:	ba 2c       	mov	r11, r10
    293c:	0f c0       	rjmp	.+30     	; 0x295c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    293e:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2940:	0f 2e       	mov	r0, r31
    2942:	fb ef       	ldi	r31, 0xFB	; 251
    2944:	ef 2e       	mov	r14, r31
    2946:	f6 e0       	ldi	r31, 0x06	; 6
    2948:	ff 2e       	mov	r15, r31
    294a:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    294c:	0f 2e       	mov	r0, r31
    294e:	f0 e0       	ldi	r31, 0x00	; 0
    2950:	cf 2e       	mov	r12, r31
    2952:	f7 e0       	ldi	r31, 0x07	; 7
    2954:	df 2e       	mov	r13, r31
    2956:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    2958:	aa 24       	eor	r10, r10
    295a:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    295c:	f7 01       	movw	r30, r14
    295e:	80 81       	ld	r24, Z
    2960:	88 23       	and	r24, r24
    2962:	09 f0       	breq	.+2      	; 0x2966 <xTaskResumeAll+0xbe>
    2964:	bd cf       	rjmp	.-134    	; 0x28e0 <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2966:	80 91 b7 06 	lds	r24, 0x06B7
    296a:	88 23       	and	r24, r24
    296c:	81 f0       	breq	.+32     	; 0x298e <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    296e:	80 91 b7 06 	lds	r24, 0x06B7
    2972:	88 23       	and	r24, r24
    2974:	99 f0       	breq	.+38     	; 0x299c <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    2976:	0e 94 8e 13 	call	0x271c	; 0x271c <vTaskIncrementTick>
						--uxMissedTicks;
    297a:	80 91 b7 06 	lds	r24, 0x06B7
    297e:	81 50       	subi	r24, 0x01	; 1
    2980:	80 93 b7 06 	sts	0x06B7, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2984:	80 91 b7 06 	lds	r24, 0x06B7
    2988:	88 23       	and	r24, r24
    298a:	a9 f7       	brne	.-22     	; 0x2976 <xTaskResumeAll+0xce>
    298c:	07 c0       	rjmp	.+14     	; 0x299c <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    298e:	f1 e0       	ldi	r31, 0x01	; 1
    2990:	bf 16       	cp	r11, r31
    2992:	21 f0       	breq	.+8      	; 0x299c <xTaskResumeAll+0xf4>
    2994:	80 91 b6 06 	lds	r24, 0x06B6
    2998:	81 30       	cpi	r24, 0x01	; 1
    299a:	41 f4       	brne	.+16     	; 0x29ac <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    299c:	10 92 b6 06 	sts	0x06B6, r1
					portYIELD_WITHIN_API();
    29a0:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    29a4:	81 e0       	ldi	r24, 0x01	; 1
    29a6:	03 c0       	rjmp	.+6      	; 0x29ae <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    29a8:	80 e0       	ldi	r24, 0x00	; 0
    29aa:	01 c0       	rjmp	.+2      	; 0x29ae <xTaskResumeAll+0x106>
    29ac:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    29ae:	0f 90       	pop	r0
    29b0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    29b2:	df 91       	pop	r29
    29b4:	cf 91       	pop	r28
    29b6:	1f 91       	pop	r17
    29b8:	0f 91       	pop	r16
    29ba:	ff 90       	pop	r15
    29bc:	ef 90       	pop	r14
    29be:	df 90       	pop	r13
    29c0:	cf 90       	pop	r12
    29c2:	bf 90       	pop	r11
    29c4:	af 90       	pop	r10
    29c6:	08 95       	ret

000029c8 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    29c8:	04 e0       	ldi	r16, 0x04	; 4
    29ca:	17 e0       	ldi	r17, 0x07	; 7
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    29cc:	0f 2e       	mov	r0, r31
    29ce:	f9 e0       	ldi	r31, 0x09	; 9
    29d0:	ef 2e       	mov	r14, r31
    29d2:	f7 e0       	ldi	r31, 0x07	; 7
    29d4:	ff 2e       	mov	r15, r31
    29d6:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    29d8:	0f 2e       	mov	r0, r31
    29da:	f5 ec       	ldi	r31, 0xC5	; 197
    29dc:	cf 2e       	mov	r12, r31
    29de:	f6 e0       	ldi	r31, 0x06	; 6
    29e0:	df 2e       	mov	r13, r31
    29e2:	f0 2d       	mov	r31, r0
    29e4:	27 c0       	rjmp	.+78     	; 0x2a34 <prvIdleTask+0x6c>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
    29e6:	0e 94 76 13 	call	0x26ec	; 0x26ec <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    29ea:	d8 01       	movw	r26, r16
    29ec:	cc 91       	ld	r28, X
			xTaskResumeAll();
    29ee:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    29f2:	cc 23       	and	r28, r28
    29f4:	f9 f0       	breq	.+62     	; 0x2a34 <prvIdleTask+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    29f6:	0f b6       	in	r0, 0x3f	; 63
    29f8:	f8 94       	cli
    29fa:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    29fc:	d7 01       	movw	r26, r14
    29fe:	ed 91       	ld	r30, X+
    2a00:	fc 91       	ld	r31, X
    2a02:	c6 81       	ldd	r28, Z+6	; 0x06
    2a04:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xGenericListItem ) );
    2a06:	ce 01       	movw	r24, r28
    2a08:	02 96       	adiw	r24, 0x02	; 2
    2a0a:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>
					--uxCurrentNumberOfTasks;
    2a0e:	80 91 bd 06 	lds	r24, 0x06BD
    2a12:	81 50       	subi	r24, 0x01	; 1
    2a14:	80 93 bd 06 	sts	0x06BD, r24
					--uxTasksDeleted;
    2a18:	80 91 be 06 	lds	r24, 0x06BE
    2a1c:	81 50       	subi	r24, 0x01	; 1
    2a1e:	80 93 be 06 	sts	0x06BE, r24
				}
				taskEXIT_CRITICAL();
    2a22:	0f 90       	pop	r0
    2a24:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2a26:	8f 89       	ldd	r24, Y+23	; 0x17
    2a28:	98 8d       	ldd	r25, Y+24	; 0x18
    2a2a:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vPortFree>
		vPortFree( pxTCB );
    2a2e:	ce 01       	movw	r24, r28
    2a30:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vPortFree>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    2a34:	80 91 be 06 	lds	r24, 0x06BE
    2a38:	88 23       	and	r24, r24
    2a3a:	a9 f6       	brne	.-86     	; 0x29e6 <prvIdleTask+0x1e>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    2a3c:	f6 01       	movw	r30, r12
    2a3e:	80 81       	ld	r24, Z
    2a40:	82 30       	cpi	r24, 0x02	; 2
    2a42:	10 f0       	brcs	.+4      	; 0x2a48 <prvIdleTask+0x80>
			{
				taskYIELD();
    2a44:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    2a48:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <vApplicationIdleHook>
				}
				xTaskResumeAll();
			}
		}
		#endif
	}
    2a4c:	f3 cf       	rjmp	.-26     	; 0x2a34 <prvIdleTask+0x6c>

00002a4e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2a4e:	cf 93       	push	r28
    2a50:	df 93       	push	r29
    2a52:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2a54:	00 97       	sbiw	r24, 0x00	; 0
    2a56:	b1 f0       	breq	.+44     	; 0x2a84 <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    2a58:	0e 94 76 13 	call	0x26ec	; 0x26ec <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2a5c:	80 91 bb 06 	lds	r24, 0x06BB
    2a60:	90 91 bc 06 	lds	r25, 0x06BC
    2a64:	c8 0f       	add	r28, r24
    2a66:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    2a68:	80 91 b3 06 	lds	r24, 0x06B3
    2a6c:	90 91 b4 06 	lds	r25, 0x06B4
    2a70:	02 96       	adiw	r24, 0x02	; 2
    2a72:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2a76:	ce 01       	movw	r24, r28
    2a78:	0e 94 ab 11 	call	0x2356	; 0x2356 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2a7c:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2a80:	88 23       	and	r24, r24
    2a82:	11 f4       	brne	.+4      	; 0x2a88 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    2a84:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vPortYield>
		}
	}
    2a88:	df 91       	pop	r29
    2a8a:	cf 91       	pop	r28
    2a8c:	08 95       	ret

00002a8e <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2a8e:	0f 93       	push	r16
    2a90:	1f 93       	push	r17
    2a92:	cf 93       	push	r28
    2a94:	df 93       	push	r29
    2a96:	8c 01       	movw	r16, r24
    2a98:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2a9a:	0e 94 76 13 	call	0x26ec	; 0x26ec <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2a9e:	f8 01       	movw	r30, r16
    2aa0:	80 81       	ld	r24, Z
    2aa2:	91 81       	ldd	r25, Z+1	; 0x01
    2aa4:	c8 0f       	add	r28, r24
    2aa6:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    2aa8:	20 91 bb 06 	lds	r18, 0x06BB
    2aac:	30 91 bc 06 	lds	r19, 0x06BC
    2ab0:	28 17       	cp	r18, r24
    2ab2:	39 07       	cpc	r19, r25
    2ab4:	68 f4       	brcc	.+26     	; 0x2ad0 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2ab6:	c8 17       	cp	r28, r24
    2ab8:	d9 07       	cpc	r29, r25
    2aba:	50 f5       	brcc	.+84     	; 0x2b10 <vTaskDelayUntil+0x82>
    2abc:	80 91 bb 06 	lds	r24, 0x06BB
    2ac0:	90 91 bc 06 	lds	r25, 0x06BC
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2ac4:	d1 83       	std	Z+1, r29	; 0x01
    2ac6:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    2ac8:	8c 17       	cp	r24, r28
    2aca:	9d 07       	cpc	r25, r29
    2acc:	b0 f4       	brcc	.+44     	; 0x2afa <vTaskDelayUntil+0x6c>
    2ace:	0b c0       	rjmp	.+22     	; 0x2ae6 <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2ad0:	c8 17       	cp	r28, r24
    2ad2:	d9 07       	cpc	r29, r25
    2ad4:	c8 f0       	brcs	.+50     	; 0x2b08 <vTaskDelayUntil+0x7a>
    2ad6:	80 91 bb 06 	lds	r24, 0x06BB
    2ada:	90 91 bc 06 	lds	r25, 0x06BC
    2ade:	8c 17       	cp	r24, r28
    2ae0:	9d 07       	cpc	r25, r29
    2ae2:	90 f0       	brcs	.+36     	; 0x2b08 <vTaskDelayUntil+0x7a>
    2ae4:	15 c0       	rjmp	.+42     	; 0x2b10 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    2ae6:	80 91 b3 06 	lds	r24, 0x06B3
    2aea:	90 91 b4 06 	lds	r25, 0x06B4
    2aee:	02 96       	adiw	r24, 0x02	; 2
    2af0:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2af4:	ce 01       	movw	r24, r28
    2af6:	0e 94 ab 11 	call	0x2356	; 0x2356 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2afa:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2afe:	88 23       	and	r24, r24
    2b00:	59 f4       	brne	.+22     	; 0x2b18 <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    2b02:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vPortYield>
    2b06:	08 c0       	rjmp	.+16     	; 0x2b18 <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2b08:	f8 01       	movw	r30, r16
    2b0a:	d1 83       	std	Z+1, r29	; 0x01
    2b0c:	c0 83       	st	Z, r28
    2b0e:	eb cf       	rjmp	.-42     	; 0x2ae6 <vTaskDelayUntil+0x58>
    2b10:	f8 01       	movw	r30, r16
    2b12:	d1 83       	std	Z+1, r29	; 0x01
    2b14:	c0 83       	st	Z, r28
    2b16:	f1 cf       	rjmp	.-30     	; 0x2afa <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2b18:	df 91       	pop	r29
    2b1a:	cf 91       	pop	r28
    2b1c:	1f 91       	pop	r17
    2b1e:	0f 91       	pop	r16
    2b20:	08 95       	ret

00002b22 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2b22:	80 91 b8 06 	lds	r24, 0x06B8
    2b26:	88 23       	and	r24, r24
    2b28:	99 f4       	brne	.+38     	; 0x2b50 <vTaskSwitchContext+0x2e>
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    2b2a:	80 91 ba 06 	lds	r24, 0x06BA
    2b2e:	90 e0       	ldi	r25, 0x00	; 0
    2b30:	fc 01       	movw	r30, r24
    2b32:	ee 0f       	add	r30, r30
    2b34:	ff 1f       	adc	r31, r31
    2b36:	ee 0f       	add	r30, r30
    2b38:	ff 1f       	adc	r31, r31
    2b3a:	ee 0f       	add	r30, r30
    2b3c:	ff 1f       	adc	r31, r31
    2b3e:	8e 0f       	add	r24, r30
    2b40:	9f 1f       	adc	r25, r31
    2b42:	fc 01       	movw	r30, r24
    2b44:	eb 53       	subi	r30, 0x3B	; 59
    2b46:	f9 4f       	sbci	r31, 0xF9	; 249
    2b48:	80 81       	ld	r24, Z
    2b4a:	88 23       	and	r24, r24
    2b4c:	29 f0       	breq	.+10     	; 0x2b58 <vTaskSwitchContext+0x36>
    2b4e:	1b c0       	rjmp	.+54     	; 0x2b86 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2b50:	81 e0       	ldi	r24, 0x01	; 1
    2b52:	80 93 b6 06 	sts	0x06B6, r24
    2b56:	08 95       	ret
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    2b58:	80 91 ba 06 	lds	r24, 0x06BA
    2b5c:	81 50       	subi	r24, 0x01	; 1
    2b5e:	80 93 ba 06 	sts	0x06BA, r24
    2b62:	80 91 ba 06 	lds	r24, 0x06BA
    2b66:	90 e0       	ldi	r25, 0x00	; 0
    2b68:	fc 01       	movw	r30, r24
    2b6a:	ee 0f       	add	r30, r30
    2b6c:	ff 1f       	adc	r31, r31
    2b6e:	ee 0f       	add	r30, r30
    2b70:	ff 1f       	adc	r31, r31
    2b72:	ee 0f       	add	r30, r30
    2b74:	ff 1f       	adc	r31, r31
    2b76:	8e 0f       	add	r24, r30
    2b78:	9f 1f       	adc	r25, r31
    2b7a:	fc 01       	movw	r30, r24
    2b7c:	eb 53       	subi	r30, 0x3B	; 59
    2b7e:	f9 4f       	sbci	r31, 0xF9	; 249
    2b80:	80 81       	ld	r24, Z
    2b82:	88 23       	and	r24, r24
    2b84:	49 f3       	breq	.-46     	; 0x2b58 <vTaskSwitchContext+0x36>
    2b86:	80 91 ba 06 	lds	r24, 0x06BA
    2b8a:	90 e0       	ldi	r25, 0x00	; 0
    2b8c:	fc 01       	movw	r30, r24
    2b8e:	ee 0f       	add	r30, r30
    2b90:	ff 1f       	adc	r31, r31
    2b92:	ee 0f       	add	r30, r30
    2b94:	ff 1f       	adc	r31, r31
    2b96:	ee 0f       	add	r30, r30
    2b98:	ff 1f       	adc	r31, r31
    2b9a:	e8 0f       	add	r30, r24
    2b9c:	f9 1f       	adc	r31, r25
    2b9e:	eb 53       	subi	r30, 0x3B	; 59
    2ba0:	f9 4f       	sbci	r31, 0xF9	; 249
    2ba2:	a1 81       	ldd	r26, Z+1	; 0x01
    2ba4:	b2 81       	ldd	r27, Z+2	; 0x02
    2ba6:	12 96       	adiw	r26, 0x02	; 2
    2ba8:	0d 90       	ld	r0, X+
    2baa:	bc 91       	ld	r27, X
    2bac:	a0 2d       	mov	r26, r0
    2bae:	b2 83       	std	Z+2, r27	; 0x02
    2bb0:	a1 83       	std	Z+1, r26	; 0x01
    2bb2:	cf 01       	movw	r24, r30
    2bb4:	03 96       	adiw	r24, 0x03	; 3
    2bb6:	a8 17       	cp	r26, r24
    2bb8:	b9 07       	cpc	r27, r25
    2bba:	31 f4       	brne	.+12     	; 0x2bc8 <vTaskSwitchContext+0xa6>
    2bbc:	12 96       	adiw	r26, 0x02	; 2
    2bbe:	8d 91       	ld	r24, X+
    2bc0:	9c 91       	ld	r25, X
    2bc2:	13 97       	sbiw	r26, 0x03	; 3
    2bc4:	92 83       	std	Z+2, r25	; 0x02
    2bc6:	81 83       	std	Z+1, r24	; 0x01
    2bc8:	01 80       	ldd	r0, Z+1	; 0x01
    2bca:	f2 81       	ldd	r31, Z+2	; 0x02
    2bcc:	e0 2d       	mov	r30, r0
    2bce:	86 81       	ldd	r24, Z+6	; 0x06
    2bd0:	97 81       	ldd	r25, Z+7	; 0x07
    2bd2:	90 93 b4 06 	sts	0x06B4, r25
    2bd6:	80 93 b3 06 	sts	0x06B3, r24
    2bda:	08 95       	ret

00002bdc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2bdc:	cf 93       	push	r28
    2bde:	df 93       	push	r29
    2be0:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2be2:	60 91 b3 06 	lds	r22, 0x06B3
    2be6:	70 91 b4 06 	lds	r23, 0x06B4
    2bea:	64 5f       	subi	r22, 0xF4	; 244
    2bec:	7f 4f       	sbci	r23, 0xFF	; 255
    2bee:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    2bf2:	80 91 b3 06 	lds	r24, 0x06B3
    2bf6:	90 91 b4 06 	lds	r25, 0x06B4
    2bfa:	02 96       	adiw	r24, 0x02	; 2
    2bfc:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2c00:	80 91 bb 06 	lds	r24, 0x06BB
    2c04:	90 91 bc 06 	lds	r25, 0x06BC
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2c08:	8c 0f       	add	r24, r28
    2c0a:	9d 1f       	adc	r25, r29
    2c0c:	0e 94 ab 11 	call	0x2356	; 0x2356 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2c10:	df 91       	pop	r29
    2c12:	cf 91       	pop	r28
    2c14:	08 95       	ret

00002c16 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2c16:	0f 93       	push	r16
    2c18:	1f 93       	push	r17
    2c1a:	cf 93       	push	r28
    2c1c:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2c1e:	dc 01       	movw	r26, r24
    2c20:	15 96       	adiw	r26, 0x05	; 5
    2c22:	ed 91       	ld	r30, X+
    2c24:	fc 91       	ld	r31, X
    2c26:	16 97       	sbiw	r26, 0x06	; 6
    2c28:	06 81       	ldd	r16, Z+6	; 0x06
    2c2a:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2c2c:	e8 01       	movw	r28, r16
    2c2e:	2c 96       	adiw	r28, 0x0c	; 12
    2c30:	ce 01       	movw	r24, r28
    2c32:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2c36:	80 91 b8 06 	lds	r24, 0x06B8
    2c3a:	88 23       	and	r24, r24
    2c3c:	e9 f4       	brne	.+58     	; 0x2c78 <xTaskRemoveFromEventList+0x62>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2c3e:	e8 01       	movw	r28, r16
    2c40:	22 96       	adiw	r28, 0x02	; 2
    2c42:	ce 01       	movw	r24, r28
    2c44:	0e 94 ae 0b 	call	0x175c	; 0x175c <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2c48:	f8 01       	movw	r30, r16
    2c4a:	86 89       	ldd	r24, Z+22	; 0x16
    2c4c:	90 91 ba 06 	lds	r25, 0x06BA
    2c50:	98 17       	cp	r25, r24
    2c52:	10 f4       	brcc	.+4      	; 0x2c58 <xTaskRemoveFromEventList+0x42>
    2c54:	80 93 ba 06 	sts	0x06BA, r24
    2c58:	90 e0       	ldi	r25, 0x00	; 0
    2c5a:	9c 01       	movw	r18, r24
    2c5c:	22 0f       	add	r18, r18
    2c5e:	33 1f       	adc	r19, r19
    2c60:	22 0f       	add	r18, r18
    2c62:	33 1f       	adc	r19, r19
    2c64:	22 0f       	add	r18, r18
    2c66:	33 1f       	adc	r19, r19
    2c68:	82 0f       	add	r24, r18
    2c6a:	93 1f       	adc	r25, r19
    2c6c:	8b 53       	subi	r24, 0x3B	; 59
    2c6e:	99 4f       	sbci	r25, 0xF9	; 249
    2c70:	be 01       	movw	r22, r28
    2c72:	0e 94 48 0b 	call	0x1690	; 0x1690 <vListInsertEnd>
    2c76:	05 c0       	rjmp	.+10     	; 0x2c82 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2c78:	8b ef       	ldi	r24, 0xFB	; 251
    2c7a:	96 e0       	ldi	r25, 0x06	; 6
    2c7c:	be 01       	movw	r22, r28
    2c7e:	0e 94 48 0b 	call	0x1690	; 0x1690 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2c82:	e0 91 b3 06 	lds	r30, 0x06B3
    2c86:	f0 91 b4 06 	lds	r31, 0x06B4
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2c8a:	81 e0       	ldi	r24, 0x01	; 1
    2c8c:	d8 01       	movw	r26, r16
    2c8e:	56 96       	adiw	r26, 0x16	; 22
    2c90:	2c 91       	ld	r18, X
    2c92:	56 97       	sbiw	r26, 0x16	; 22
    2c94:	96 89       	ldd	r25, Z+22	; 0x16
    2c96:	29 17       	cp	r18, r25
    2c98:	08 f4       	brcc	.+2      	; 0x2c9c <xTaskRemoveFromEventList+0x86>
    2c9a:	80 e0       	ldi	r24, 0x00	; 0
}
    2c9c:	df 91       	pop	r29
    2c9e:	cf 91       	pop	r28
    2ca0:	1f 91       	pop	r17
    2ca2:	0f 91       	pop	r16
    2ca4:	08 95       	ret

00002ca6 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2ca6:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2ca8:	80 91 b5 06 	lds	r24, 0x06B5
    2cac:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2cae:	80 91 bb 06 	lds	r24, 0x06BB
    2cb2:	90 91 bc 06 	lds	r25, 0x06BC
    2cb6:	92 83       	std	Z+2, r25	; 0x02
    2cb8:	81 83       	std	Z+1, r24	; 0x01
}
    2cba:	08 95       	ret

00002cbc <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2cbc:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2cbe:	0f b6       	in	r0, 0x3f	; 63
    2cc0:	f8 94       	cli
    2cc2:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2cc4:	80 91 b5 06 	lds	r24, 0x06B5
    2cc8:	90 81       	ld	r25, Z
    2cca:	98 17       	cp	r25, r24
    2ccc:	49 f0       	breq	.+18     	; 0x2ce0 <xTaskCheckForTimeOut+0x24>
    2cce:	80 91 bb 06 	lds	r24, 0x06BB
    2cd2:	90 91 bc 06 	lds	r25, 0x06BC
    2cd6:	21 81       	ldd	r18, Z+1	; 0x01
    2cd8:	32 81       	ldd	r19, Z+2	; 0x02
    2cda:	82 17       	cp	r24, r18
    2cdc:	93 07       	cpc	r25, r19
    2cde:	f0 f4       	brcc	.+60     	; 0x2d1c <xTaskCheckForTimeOut+0x60>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2ce0:	80 91 bb 06 	lds	r24, 0x06BB
    2ce4:	90 91 bc 06 	lds	r25, 0x06BC
    2ce8:	21 81       	ldd	r18, Z+1	; 0x01
    2cea:	32 81       	ldd	r19, Z+2	; 0x02
    2cec:	db 01       	movw	r26, r22
    2cee:	4d 91       	ld	r20, X+
    2cf0:	5c 91       	ld	r21, X
    2cf2:	11 97       	sbiw	r26, 0x01	; 1
    2cf4:	82 1b       	sub	r24, r18
    2cf6:	93 0b       	sbc	r25, r19
    2cf8:	84 17       	cp	r24, r20
    2cfa:	95 07       	cpc	r25, r21
    2cfc:	88 f4       	brcc	.+34     	; 0x2d20 <xTaskCheckForTimeOut+0x64>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2cfe:	80 91 bb 06 	lds	r24, 0x06BB
    2d02:	90 91 bc 06 	lds	r25, 0x06BC
    2d06:	28 1b       	sub	r18, r24
    2d08:	39 0b       	sbc	r19, r25
    2d0a:	24 0f       	add	r18, r20
    2d0c:	35 1f       	adc	r19, r21
    2d0e:	2d 93       	st	X+, r18
    2d10:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    2d12:	cf 01       	movw	r24, r30
    2d14:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2d18:	80 e0       	ldi	r24, 0x00	; 0
    2d1a:	03 c0       	rjmp	.+6      	; 0x2d22 <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2d1c:	81 e0       	ldi	r24, 0x01	; 1
    2d1e:	01 c0       	rjmp	.+2      	; 0x2d22 <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2d20:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2d22:	0f 90       	pop	r0
    2d24:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2d26:	08 95       	ret

00002d28 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2d28:	81 e0       	ldi	r24, 0x01	; 1
    2d2a:	80 93 b6 06 	sts	0x06B6, r24
}
    2d2e:	08 95       	ret

00002d30 <main>:

uint8_t reset_value;
extern uint8_t reset_value;

short main( void )
{	
    2d30:	af 92       	push	r10
    2d32:	bf 92       	push	r11
    2d34:	cf 92       	push	r12
    2d36:	df 92       	push	r13
    2d38:	ef 92       	push	r14
    2d3a:	ff 92       	push	r15
    2d3c:	0f 93       	push	r16
	reset_value = MCUCSR;
    2d3e:	84 b7       	in	r24, 0x34	; 52
    2d40:	80 93 aa 07 	sts	0x07AA, r24
	PORTA |= _BV(PA4);
    2d44:	dc 9a       	sbi	0x1b, 4	; 27
	DDRA &= ~(_BV(PA4));
    2d46:	d4 98       	cbi	0x1a, 4	; 26
	PORTA |= _BV(PA5);
    2d48:	dd 9a       	sbi	0x1b, 5	; 27
	DDRA |= _BV(PA5);
    2d4a:	d5 9a       	sbi	0x1a, 5	; 26
//	DDRB = 0xFF;
//	PORTB = 0;
    adc_init();
    2d4c:	0e 94 49 00 	call	0x92	; 0x92 <adc_init>
	stepper_init();
    2d50:	0e 94 4b 05 	call	0xa96	; 0xa96 <stepper_init>
	stove_control_init();
    2d54:	0e 94 ed 06 	call	0xdda	; 0xdda <stove_control_init>
	lcd_init();
    2d58:	0e 94 b8 03 	call	0x770	; 0x770 <lcd_init>
	ds1620_init();
    2d5c:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <ds1620_init>
	keypad_init();
    2d60:	0e 94 34 04 	call	0x868	; 0x868 <keypad_init>
	menu_init();
    2d64:	0e 94 91 04 	call	0x922	; 0x922 <menu_init>
	spi_master_init();
    2d68:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <spi_master_init>
	

	xTaskCreate( ds1620_read, "ds1620", configMINIMAL_STACK_SIZE,NULL,2,NULL );
    2d6c:	8e ee       	ldi	r24, 0xEE	; 238
    2d6e:	90 e0       	ldi	r25, 0x00	; 0
    2d70:	69 e6       	ldi	r22, 0x69	; 105
    2d72:	70 e0       	ldi	r23, 0x00	; 0
    2d74:	45 e5       	ldi	r20, 0x55	; 85
    2d76:	50 e0       	ldi	r21, 0x00	; 0
    2d78:	20 e0       	ldi	r18, 0x00	; 0
    2d7a:	30 e0       	ldi	r19, 0x00	; 0
    2d7c:	02 e0       	ldi	r16, 0x02	; 2
    2d7e:	ee 24       	eor	r14, r14
    2d80:	ff 24       	eor	r15, r15
    2d82:	cc 24       	eor	r12, r12
    2d84:	dd 24       	eor	r13, r13
    2d86:	aa 24       	eor	r10, r10
    2d88:	bb 24       	eor	r11, r11
    2d8a:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <xTaskGenericCreate>
	xTaskCreate( lcd_task, "LCD", configMINIMAL_STACK_SIZE,NULL,2,NULL );
    2d8e:	86 ef       	ldi	r24, 0xF6	; 246
    2d90:	93 e0       	ldi	r25, 0x03	; 3
    2d92:	60 e7       	ldi	r22, 0x70	; 112
    2d94:	70 e0       	ldi	r23, 0x00	; 0
    2d96:	45 e5       	ldi	r20, 0x55	; 85
    2d98:	50 e0       	ldi	r21, 0x00	; 0
    2d9a:	20 e0       	ldi	r18, 0x00	; 0
    2d9c:	30 e0       	ldi	r19, 0x00	; 0
    2d9e:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <xTaskGenericCreate>
	xTaskCreate( stepper, "Stepper", configMINIMAL_STACK_SIZE,NULL,3,NULL );
    2da2:	8c e9       	ldi	r24, 0x9C	; 156
    2da4:	95 e0       	ldi	r25, 0x05	; 5
    2da6:	64 e7       	ldi	r22, 0x74	; 116
    2da8:	70 e0       	ldi	r23, 0x00	; 0
    2daa:	45 e5       	ldi	r20, 0x55	; 85
    2dac:	50 e0       	ldi	r21, 0x00	; 0
    2dae:	20 e0       	ldi	r18, 0x00	; 0
    2db0:	30 e0       	ldi	r19, 0x00	; 0
    2db2:	03 e0       	ldi	r16, 0x03	; 3
    2db4:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <xTaskGenericCreate>
	xTaskCreate( adc, "ADC", configMINIMAL_STACK_SIZE,NULL,3,NULL );
    2db8:	89 e5       	ldi	r24, 0x59	; 89
    2dba:	90 e0       	ldi	r25, 0x00	; 0
    2dbc:	6c e7       	ldi	r22, 0x7C	; 124
    2dbe:	70 e0       	ldi	r23, 0x00	; 0
    2dc0:	45 e5       	ldi	r20, 0x55	; 85
    2dc2:	50 e0       	ldi	r21, 0x00	; 0
    2dc4:	20 e0       	ldi	r18, 0x00	; 0
    2dc6:	30 e0       	ldi	r19, 0x00	; 0
    2dc8:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <xTaskGenericCreate>
	xTaskCreate( stove_control, "STOVECTR", configMINIMAL_STACK_SIZE,NULL,3,NULL );
    2dcc:	84 e0       	ldi	r24, 0x04	; 4
    2dce:	99 e0       	ldi	r25, 0x09	; 9
    2dd0:	60 e8       	ldi	r22, 0x80	; 128
    2dd2:	70 e0       	ldi	r23, 0x00	; 0
    2dd4:	45 e5       	ldi	r20, 0x55	; 85
    2dd6:	50 e0       	ldi	r21, 0x00	; 0
    2dd8:	20 e0       	ldi	r18, 0x00	; 0
    2dda:	30 e0       	ldi	r19, 0x00	; 0
    2ddc:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <xTaskGenericCreate>
	xTaskCreate( keypad, "KeyPad", configMINIMAL_STACK_SIZE,NULL,3,NULL );
    2de0:	81 e4       	ldi	r24, 0x41	; 65
    2de2:	94 e0       	ldi	r25, 0x04	; 4
    2de4:	69 e8       	ldi	r22, 0x89	; 137
    2de6:	70 e0       	ldi	r23, 0x00	; 0
    2de8:	45 e5       	ldi	r20, 0x55	; 85
    2dea:	50 e0       	ldi	r21, 0x00	; 0
    2dec:	20 e0       	ldi	r18, 0x00	; 0
    2dee:	30 e0       	ldi	r19, 0x00	; 0
    2df0:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <xTaskGenericCreate>
	xTaskCreate( menu, "Menu", configMINIMAL_STACK_SIZE,NULL,3,NULL );
    2df4:	82 e9       	ldi	r24, 0x92	; 146
    2df6:	94 e0       	ldi	r25, 0x04	; 4
    2df8:	60 e9       	ldi	r22, 0x90	; 144
    2dfa:	70 e0       	ldi	r23, 0x00	; 0
    2dfc:	45 e5       	ldi	r20, 0x55	; 85
    2dfe:	50 e0       	ldi	r21, 0x00	; 0
    2e00:	20 e0       	ldi	r18, 0x00	; 0
    2e02:	30 e0       	ldi	r19, 0x00	; 0
    2e04:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <xTaskGenericCreate>
	xTaskCreate( spi_master, "SPI", configMINIMAL_STACK_SIZE,NULL,3,NULL );
    2e08:	8f ef       	ldi	r24, 0xFF	; 255
    2e0a:	94 e0       	ldi	r25, 0x04	; 4
    2e0c:	65 e9       	ldi	r22, 0x95	; 149
    2e0e:	70 e0       	ldi	r23, 0x00	; 0
    2e10:	45 e5       	ldi	r20, 0x55	; 85
    2e12:	50 e0       	ldi	r21, 0x00	; 0
    2e14:	20 e0       	ldi	r18, 0x00	; 0
    2e16:	30 e0       	ldi	r19, 0x00	; 0
    2e18:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <xTaskGenericCreate>
	
	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION 
	as 1 in portmacro.h.  To use the cooperative scheduler define 
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
    2e1c:	0e 94 45 13 	call	0x268a	; 0x268a <vTaskStartScheduler>

	return 0;
}
    2e20:	80 e0       	ldi	r24, 0x00	; 0
    2e22:	90 e0       	ldi	r25, 0x00	; 0
    2e24:	0f 91       	pop	r16
    2e26:	ff 90       	pop	r15
    2e28:	ef 90       	pop	r14
    2e2a:	df 90       	pop	r13
    2e2c:	cf 90       	pop	r12
    2e2e:	bf 90       	pop	r11
    2e30:	af 90       	pop	r10
    2e32:	08 95       	ret

00002e34 <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
	for( ;; )
	{
		asm volatile("nop\n\t");
    2e34:	00 00       	nop
    2e36:	fe cf       	rjmp	.-4      	; 0x2e34 <vApplicationIdleHook>

00002e38 <__udivmodhi4>:
    2e38:	aa 1b       	sub	r26, r26
    2e3a:	bb 1b       	sub	r27, r27
    2e3c:	51 e1       	ldi	r21, 0x11	; 17
    2e3e:	07 c0       	rjmp	.+14     	; 0x2e4e <__udivmodhi4_ep>

00002e40 <__udivmodhi4_loop>:
    2e40:	aa 1f       	adc	r26, r26
    2e42:	bb 1f       	adc	r27, r27
    2e44:	a6 17       	cp	r26, r22
    2e46:	b7 07       	cpc	r27, r23
    2e48:	10 f0       	brcs	.+4      	; 0x2e4e <__udivmodhi4_ep>
    2e4a:	a6 1b       	sub	r26, r22
    2e4c:	b7 0b       	sbc	r27, r23

00002e4e <__udivmodhi4_ep>:
    2e4e:	88 1f       	adc	r24, r24
    2e50:	99 1f       	adc	r25, r25
    2e52:	5a 95       	dec	r21
    2e54:	a9 f7       	brne	.-22     	; 0x2e40 <__udivmodhi4_loop>
    2e56:	80 95       	com	r24
    2e58:	90 95       	com	r25
    2e5a:	bc 01       	movw	r22, r24
    2e5c:	cd 01       	movw	r24, r26
    2e5e:	08 95       	ret

00002e60 <memcpy>:
    2e60:	fb 01       	movw	r30, r22
    2e62:	dc 01       	movw	r26, r24
    2e64:	02 c0       	rjmp	.+4      	; 0x2e6a <memcpy+0xa>
    2e66:	01 90       	ld	r0, Z+
    2e68:	0d 92       	st	X+, r0
    2e6a:	41 50       	subi	r20, 0x01	; 1
    2e6c:	50 40       	sbci	r21, 0x00	; 0
    2e6e:	d8 f7       	brcc	.-10     	; 0x2e66 <memcpy+0x6>
    2e70:	08 95       	ret

00002e72 <memset>:
    2e72:	dc 01       	movw	r26, r24
    2e74:	01 c0       	rjmp	.+2      	; 0x2e78 <memset+0x6>
    2e76:	6d 93       	st	X+, r22
    2e78:	41 50       	subi	r20, 0x01	; 1
    2e7a:	50 40       	sbci	r21, 0x00	; 0
    2e7c:	e0 f7       	brcc	.-8      	; 0x2e76 <memset+0x4>
    2e7e:	08 95       	ret

00002e80 <strncpy>:
    2e80:	fb 01       	movw	r30, r22
    2e82:	dc 01       	movw	r26, r24
    2e84:	41 50       	subi	r20, 0x01	; 1
    2e86:	50 40       	sbci	r21, 0x00	; 0
    2e88:	48 f0       	brcs	.+18     	; 0x2e9c <strncpy+0x1c>
    2e8a:	01 90       	ld	r0, Z+
    2e8c:	0d 92       	st	X+, r0
    2e8e:	00 20       	and	r0, r0
    2e90:	c9 f7       	brne	.-14     	; 0x2e84 <strncpy+0x4>
    2e92:	01 c0       	rjmp	.+2      	; 0x2e96 <strncpy+0x16>
    2e94:	1d 92       	st	X+, r1
    2e96:	41 50       	subi	r20, 0x01	; 1
    2e98:	50 40       	sbci	r21, 0x00	; 0
    2e9a:	e0 f7       	brcc	.-8      	; 0x2e94 <strncpy+0x14>
    2e9c:	08 95       	ret

00002e9e <itoa>:
    2e9e:	fb 01       	movw	r30, r22
    2ea0:	9f 01       	movw	r18, r30
    2ea2:	e8 94       	clt
    2ea4:	42 30       	cpi	r20, 0x02	; 2
    2ea6:	c4 f0       	brlt	.+48     	; 0x2ed8 <itoa+0x3a>
    2ea8:	45 32       	cpi	r20, 0x25	; 37
    2eaa:	b4 f4       	brge	.+44     	; 0x2ed8 <itoa+0x3a>
    2eac:	4a 30       	cpi	r20, 0x0A	; 10
    2eae:	29 f4       	brne	.+10     	; 0x2eba <itoa+0x1c>
    2eb0:	97 fb       	bst	r25, 7
    2eb2:	1e f4       	brtc	.+6      	; 0x2eba <itoa+0x1c>
    2eb4:	90 95       	com	r25
    2eb6:	81 95       	neg	r24
    2eb8:	9f 4f       	sbci	r25, 0xFF	; 255
    2eba:	64 2f       	mov	r22, r20
    2ebc:	77 27       	eor	r23, r23
    2ebe:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <__udivmodhi4>
    2ec2:	80 5d       	subi	r24, 0xD0	; 208
    2ec4:	8a 33       	cpi	r24, 0x3A	; 58
    2ec6:	0c f0       	brlt	.+2      	; 0x2eca <itoa+0x2c>
    2ec8:	89 5d       	subi	r24, 0xD9	; 217
    2eca:	81 93       	st	Z+, r24
    2ecc:	cb 01       	movw	r24, r22
    2ece:	00 97       	sbiw	r24, 0x00	; 0
    2ed0:	a1 f7       	brne	.-24     	; 0x2eba <itoa+0x1c>
    2ed2:	16 f4       	brtc	.+4      	; 0x2ed8 <itoa+0x3a>
    2ed4:	5d e2       	ldi	r21, 0x2D	; 45
    2ed6:	51 93       	st	Z+, r21
    2ed8:	10 82       	st	Z, r1
    2eda:	c9 01       	movw	r24, r18
    2edc:	0c 94 89 17 	jmp	0x2f12	; 0x2f12 <strrev>

00002ee0 <__eerd_byte_m32>:
    2ee0:	e1 99       	sbic	0x1c, 1	; 28
    2ee2:	fe cf       	rjmp	.-4      	; 0x2ee0 <__eerd_byte_m32>
    2ee4:	9f bb       	out	0x1f, r25	; 31
    2ee6:	8e bb       	out	0x1e, r24	; 30
    2ee8:	e0 9a       	sbi	0x1c, 0	; 28
    2eea:	99 27       	eor	r25, r25
    2eec:	8d b3       	in	r24, 0x1d	; 29
    2eee:	08 95       	ret

00002ef0 <__eeupd_byte_m32>:
    2ef0:	26 2f       	mov	r18, r22

00002ef2 <__eeupd_r18_m32>:
    2ef2:	e1 99       	sbic	0x1c, 1	; 28
    2ef4:	fe cf       	rjmp	.-4      	; 0x2ef2 <__eeupd_r18_m32>
    2ef6:	9f bb       	out	0x1f, r25	; 31
    2ef8:	8e bb       	out	0x1e, r24	; 30
    2efa:	e0 9a       	sbi	0x1c, 0	; 28
    2efc:	01 97       	sbiw	r24, 0x01	; 1
    2efe:	0d b2       	in	r0, 0x1d	; 29
    2f00:	02 16       	cp	r0, r18
    2f02:	31 f0       	breq	.+12     	; 0x2f10 <__eeupd_r18_m32+0x1e>
    2f04:	2d bb       	out	0x1d, r18	; 29
    2f06:	0f b6       	in	r0, 0x3f	; 63
    2f08:	f8 94       	cli
    2f0a:	e2 9a       	sbi	0x1c, 2	; 28
    2f0c:	e1 9a       	sbi	0x1c, 1	; 28
    2f0e:	0f be       	out	0x3f, r0	; 63
    2f10:	08 95       	ret

00002f12 <strrev>:
    2f12:	dc 01       	movw	r26, r24
    2f14:	fc 01       	movw	r30, r24
    2f16:	67 2f       	mov	r22, r23
    2f18:	71 91       	ld	r23, Z+
    2f1a:	77 23       	and	r23, r23
    2f1c:	e1 f7       	brne	.-8      	; 0x2f16 <strrev+0x4>
    2f1e:	32 97       	sbiw	r30, 0x02	; 2
    2f20:	04 c0       	rjmp	.+8      	; 0x2f2a <strrev+0x18>
    2f22:	7c 91       	ld	r23, X
    2f24:	6d 93       	st	X+, r22
    2f26:	70 83       	st	Z, r23
    2f28:	62 91       	ld	r22, -Z
    2f2a:	ae 17       	cp	r26, r30
    2f2c:	bf 07       	cpc	r27, r31
    2f2e:	c8 f3       	brcs	.-14     	; 0x2f22 <strrev+0x10>
    2f30:	08 95       	ret

00002f32 <_exit>:
    2f32:	f8 94       	cli

00002f34 <__stop_program>:
    2f34:	ff cf       	rjmp	.-2      	; 0x2f34 <__stop_program>
