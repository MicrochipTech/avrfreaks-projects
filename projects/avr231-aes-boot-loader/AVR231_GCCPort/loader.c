//=============================================================================
// Copyright (C) 2003 Atmel Corporation
//
// File:            loader.c
// Compiler:        IAR Atmel AVR C/EC++ Compiler
// Output Size:
// Based on work by:ØE, VU
// Created:         4-Feb-2003  JP (Atmel Finland)
// Modified:
//
// Support Mail:    avr@atmel.com
//
// Description:     Loader receives encrypted data frames (generated using
//                  'create' tool and sent by 'update' tool), decrypts them and
//                  executes the commands described in frames.
//
//                  For more information, refer to the Application Note
//                  Documentation.
//
// Other Info:      
//=============================================================================

#include <avr/io.h>
#include <avr/boot.h>
#include <avr/wdt.h>
#include <avr/pgmspace.h>

#include "aesglobal.h"
#include "aesflash.h"
#include "bootldr.h"
#include "loader.h"
#include "bus.h"
#include "crc.h"
#include "aes.h"

//=============================================================================
// Initial vector for cipher block unchaining (INITIALVECTOR_x are
// defined in 'bootldr.h' which is generated by 'create' tool)
//=============================================================================

#if KEY_COUNT > 0

const unsigned char initialVector[16] PROGMEM =
{
    (uint8_t)(INITIALVECTOR_3 >> 24),
    (uint8_t)(INITIALVECTOR_3 >> 16),
    (uint8_t)(INITIALVECTOR_3 >> 8),
    (uint8_t)(INITIALVECTOR_3 >> 0),
    (uint8_t)(INITIALVECTOR_2 >> 24),
    (uint8_t)(INITIALVECTOR_2 >> 16),
    (uint8_t)(INITIALVECTOR_2 >> 8),
    (uint8_t)(INITIALVECTOR_2 >> 0),
    (uint8_t)(INITIALVECTOR_1 >> 24),
    (uint8_t)(INITIALVECTOR_1 >> 16),
    (uint8_t)(INITIALVECTOR_1 >> 8),
    (uint8_t)(INITIALVECTOR_1 >> 0),
    (uint8_t)(INITIALVECTOR_0 >> 24),
    (uint8_t)(INITIALVECTOR_0 >> 16),
    (uint8_t)(INITIALVECTOR_0 >> 8),
    (uint8_t)(INITIALVECTOR_0 >> 0)
};

#endif

//=============================================================================
// Loader routine. For more information about the format of frames, please
// refer to the Application Note Documentation.
//=============================================================================

union
{
    struct
    {
        uint8_t m_rxBuffer[BUFFER_SIZE];            // Receive buffer
        uint8_t m_pageBuffer[PAGE_SIZE];            // Page is assembled here before
                                                    // getting programmed to flash memory
    } part1;

#if KEY_COUNT > 0
    struct
    {
        uint8_t m_tempbuf[256];                     // Temp buffer for aesInit.
    } part2;
#endif
} sharedbufs;

#define rxBuffer   sharedbufs.part1.m_rxBuffer
#define pageBuffer sharedbufs.part1.m_pageBuffer

#if KEY_COUNT > 0
#define tempbuf    sharedbufs.part2.m_tempbuf
#endif

void loader(void)
{

#if KEY_COUNT > 0

    static uint8_t chainCipherBlock[16];

    // Copy Initial Vector to start the cipher block unchaining
#if defined(RAMPZ)
    memcpy_PF(chainCipherBlock, pflash_byte3(initialVector), initialVector, 16);
#else
    memcpy_PN(chainCipherBlock, initialVector, 16);
#endif
    aesInit(tempbuf);                               // Init AES algorithm.
#endif

    // Prepare bus for incoming frames...
    busPrepare();

    // Start the Watchdog Timer
    wdt_enable(WDTO_2S);

    //-----------------------------------------------------------
    // ASCII diagram by RLP (Juniper Systems, Inc., USA)
    //
    //-----------------------------------------------------------
    // RX FRAME
    //-----------------------------------------------------------
    //  Encrypted update "frame" format:
    //  ___ _____________________  ____________________ ___
    // | L |           Chained & // Encrypted Data     | C |
    // |___|_____________________//____________________|___|
    //
    //
    // The Decrypted update "frame" format:
    //  ___ _______ ________ ________        ________ _ ___
    // | : | : : : |        |        |......|        | | : |
    // |___|_______|________|________|......|________|_|___|
    //  L L S S S S RRRRRRRR RRRRRRRR ...... RRRRRRRR Z C C
    //  |_| |_____| |_______________________________| | |_|
    //   |     |                     |                |  |
    //   |     |                     |                |  CRC [2]
    //   |     |                     |                EOF [1]
    //   |     |                     Record(s) [var]
    //   |     Signature [4]
    //   Frame Length [2]
    //
    //  The actual update frame STARTS with first signature byte
    //  and ENDS with the EOF byte. Frame Length and CRC bytes
    //  (2 bytes each) are NOT part of the update frame
    //-----------------------------------------------------------

    // Loop forever
    // (the loop is broken by Watchdog when RESET record is received)

    for (;;)
    {
        uint16_t     crc;
        frameindex_t frameSize;

        // Get the frame size
        frameSize = ((frameindex_t)busReceiveByte() << 8) | busReceiveByte();
        // Restrict frame size to the allocated buffer size
        // Should result in a crc failure if adjusted
        frameSize = (frameSize > BUFFER_SIZE ? BUFFER_SIZE : frameSize);

        // Receive a frame of data from communication interface and calculate its CRC.

        {
            uint8_t *pTmpBuf = rxBuffer;
            frameindex_t   n = frameSize;

            crc = 0;

            do
            {
				*pTmpBuf = busReceiveByte();
				crc = CRC(crc, *pTmpBuf++);

                wdt_reset();
            }
            while (--n);
        }

        // CRC is OK?
        if (crc == 0x0000)
        {
            uint8_t *pRcvBuf = rxBuffer;

#if KEY_COUNT > 0

            {
			    // Decrypt 16 bytes, CRC-bytes are ignored.

                frameSize -= 2;
                uint8_t *pTmpBuf = rxBuffer;

                do
                {
                    wdt_reset();
                    aesDecrypt(pTmpBuf, chainCipherBlock);
                    pTmpBuf += 16;
                }
                while (frameSize -= 16);
            }
#endif

            // Check that the signature is correct

            if ((*pRcvBuf++ == (uint8_t)(SIGNATURE >> 24)) &&
                (*pRcvBuf++ == (uint8_t)(SIGNATURE >> 16)) &&
                (*pRcvBuf++ == (uint8_t)(SIGNATURE >> 8)) &&
                (*pRcvBuf++ == (uint8_t)(SIGNATURE >> 0)))
            {

                prog_uchar      *address;
                uint8_t         bits;
                frameindex_t    size;
                uint8_t         ftype;

                // Continue parsing the frames until the 'End Of Frame' is received
                while ((ftype = *pRcvBuf++) != TYPE_EOF)
                {
                    wdt_reset();

                    // Receive Lock Bits (used in TYPE_LOCKBITS)
                    bits = *pRcvBuf++;

                    // Destination Address (note: 'bits' and 'address' overlap)
                    // bits contains rampz address byte

                    address = (prog_uchar *)((uint16_t)*pRcvBuf++ << 8);
                    address = (prog_uchar *)((uint16_t)address | *pRcvBuf++);

                    size = ((uint16_t)*pRcvBuf++ << 8);
                    size |= *pRcvBuf++;

                    switch (ftype)
                    {
                        // Erase page
                        case TYPE_ERASE:
                        {
						#if defined(RAMPZ)
                            spmErasePage(address, bits);
						#else
                            spmErasePage(address);
						#endif
                        }
                        // Fall-through!

                        // Prepare for incoming data chunks by copying the page
                        // contents into the page buffer
                        case TYPE_PREPARE:
                        {
						#if defined(RAMPZ)
                            memcpy_PF(pageBuffer, bits, address, size);
						#else
                            memcpy_PN(pageBuffer, address, size);
						#endif
                            break;
                        }

                        // Chunk of data is written into the page buffer
                        case TYPE_DATA:
                        {
                            uint8_t *pPageBuff = &pageBuffer[(uint16_t)(address) & 0xffff];

                            do
                            {
                                *pPageBuff++ = *pRcvBuf++;
                            }
                            while (--size);

                            break;
                        }

                        // Program page buffer into flash page
                        case TYPE_PROGRAM:
                        {
						#if defined(RAMPZ)
                            spmWritePage(address, pageBuffer, size, bits);
                            spmErasePage(address, bits);
                            spmProgramPage(address, bits);
						#else
                            spmWritePage(address, pageBuffer, size);
                            spmErasePage(address);
                            spmProgramPage(address);
						#endif
                            break;
                        }

                        // Write a chunk of data into EEPROM
                        case TYPE_EEPROM:
                        {
                            do
                            {
                                wdt_reset();

                                EEAR = (uint16_t)address++;
                                EEDR = *(pRcvBuf++);
                                set_bit(EECR, EEMWE);
                                set_bit(EECR, EEWE);

                                loop_until_bit_is_set(EECR, EEWE);
                            } 
							while (--size);

                            break;
                        }

                        // Write Lock Bits
                        case TYPE_LOCKBITS:
                        {
                            spmWriteLockBits(bits);
                            break;
                        }

                        // Reset (let the Watchdog Timer expire)!
                        case TYPE_RESET:
                        {
                            busReplyByte(ERROR_OK);
                            spmEnableRWW();
                            for (;;);
                        }

                        // Nonsense frames, one byte long
                        default:
                        {
                            pRcvBuf -= 5;
                            break;
                        }
                    }                               // switch
                }                                   // while type!= EOF
            }                                       // if signature matches

            busReplyByte(ERROR_OK);
        }                                           // if crc is ok
        else
            busReplyByte(ERROR_CRC);
    }                                               // endless loop
}

