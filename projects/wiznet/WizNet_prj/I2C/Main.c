/*********************************************************************************************************
	Программа для AT90CAN128 c установленным модулем Ethernet IIM7010A WIZnet Inc на шину I2C.
 _________________________________________________________________________________________________________
*	
* Программа предназначена для контроллера AT90CAN128. Частота кварца - 6 МГц. Питание - 5В
* В состав устройства входят:
* два светодиодных индикатора,
* поддержка модуля Ethernet по шине I2C.
* супервизор питания.
----------------------------------------------------------------------------------------------------
* Микрокотроллер общается с модулем по интерфейсу I2C, который обозначен
* здесь как TWI. Используется встроенный в контроллер механизм поддержки TWI, 
* поэтому всегда должно быть разрешены рерывания от TWI, запрещать прерывания
* битом глобального запрета нельзя.
* Кроме 2х линий интерфейса TWI, контроллер использует 2е линии для аппаратного
* сброса модуля.
* Модулю присвоен адрес - 1 на шине TWI, это делается установкой на входе A14~A8. (A14...A9=0, A8=1)
* Модуль получает сетевые и протокольные установки, указанные в файле defGlobal.h.
* Для нормальной работы системы по приему и передаче UDP пакетов, должна регулярно
* вызываться функция ETH_work().
* Функция ETH_work() не содержит циклов ожидания каких-то событий и временных задержек, и
* это требуется от других функций, которые будут дополнительно включены в программу.
----------------------------------------------------------------------------------------------------
*
* Для приема/передачи данных надо использовать структуру - struct Request;   
* struct Request
* {	
*	unsigned char		req;	// признак запроса.
*	unsigned char		leng;	// длина информации для разбора.
* };
* Если req != 0, это указывает требование обработки на часть или хвост пакета.
* Член leng указывает на длину принятой информации.
* Обработчик входного сообщения должен сбросить признак req, и использовать первые leng байт
* сопряженного буфера.
* Замечание: особенностью приема UDP пакета является наличие 8и служебных байт в заголовке.
* Первые 2а байта заголовка - это длина сообщения, включая сам счетчик длины, затем 4е
* байта - IP адрес источника сообщения, затем 2а байта - номер порта источника сообщения.
* Старший байт в полях длины, IP адреса и номера порта идут первыми.
* После размещаются пользовательские UDP данные.

----------------------------------------------------------------------------------------------------
*
* Выходные порты контроллера:
* PA1 (out) - высокий включение светодиода VH1 (зеленый или желтый)
* PA2 (out) - высокий включение светодиода VH2 (красный)

* PD1 (ok) - сигнал SDA интерфейка I2C.
* PD0 (out) - сигнал SCL интерфейка I2C.
*_________________________________________________________________________________________________________
*
* Программа устанавливает нулевой таймер на частоту прерывания 25 Гц, для формирования временных задержек
* свечения светодиодов индикации. Обработка таймера происдодит в прерывании.
* Каждый тик таймера декрементирует до нуля переменные массива time_out[4]. Переменная с индексом ноль,
* задействована на индикацию признака нормальной работы, миганием зеленого индикатора.
* time_out[0] - для индикации работы процессора
* time_out[1] - для индикации приема пакета
* time_out[2] - для задержки сброса модуля Ethernet
* time_out[3] - для фиксации зависания интерфейса TWI
*_________________________________________________________________________________________________________
* 
****************************************************************************/
//#define MYTEST
/****************************************************************/
#include <avr/io.h>
#include <avr/wdt.h>
#include "headers/MACRO.H"
#include "headers/defConstant.h"
#include "headers/defGlobal.h"
#include "headers/defFunction.h"
/****************************************************************/

int		main(void);

/****************************************************************/

int main(void)
{
	wdt_disable();
	initCPU();									// Hardware CPU initialization
	INT_enable();								// разрешение прерываний
	
	GREEN_ON();
	RED_OFF();

	while(1)
	{
		if(time_out[1] == 0) RED_OFF();		// выключение светодиода по истечении заданного времени
		if(time_out[0] == 0)					// задержка для организации мигания светодиода индикации работы
		{
			time_out[0]=25;						// установка таймера
			GREEN_TOG();						// переключение светодиода работы
		}
		/*----------------------*/
		wdt_reset();							// сброс внутреннего сторожевого таймера
		/*----------------------*/
		while(ETH_dsc.countError > MAX_ERROR);	// Блокировка и сброс всей системы после 32х ошибок модуля Ethernet.
		while(time_out[3] == 0);				// Блокировка и сброс всей системы если завис интерфейс TWI.
		/*----------------------*/
		if(TWI_stat.TWI_state == TWI_BUSY);	// Если TWI занят, то ничего делать нельзя.
		else ETH_work();						// Работа с модулем Ethernet.
		/*----------------------*/
		#ifdef MYTEST              				// для проведения отладки небольших фрагментов программы
		{
			unsigned char i;
			if(ETHrc.req)
			{
				ETHrc.req=0;
				for(i=0; i< ETHrc.leng; i++) ethTRbuff[i]=ethRCbuff[i];
				ETHtr.leng=ETHrc.leng;
				ETHtr.req=1;
			}
		}
		#endif
		/*----------------------*/
	}
	return 0;
}
/****************************************************************/
/****************************************************************/
