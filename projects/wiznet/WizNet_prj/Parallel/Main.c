/*********************************************************************************************************
	Программа для устройства c установленным модулем Ethernet IIM7010A WIZnet Inc.
	Для пересылки данных используется UDP протокол.
 _________________________________________________________________________________________________________
*	
* Программа предназначена для контроллера AT90CAN128. Частота кварца - 6 МГц. Питание - 3.3В
* В состав устройства входят модуль Ethernet IIM7010A WIZnet Inc., два светодиодных индикатора,
* аппаратный WDT, совмещенный с супервизором питания.
----------------------------------------------------------------------------------------------------
* Микрокотроллер общается с модулем Ethernet побайтно в режиме indirect Bus mode в диапазоне адресов 0xfff0-0xfff3. 
	0xfff0 регистр-IDM_OR d7=IND_EN d1=L/B d0=AUTO_INC
	0xfff1 регистр-IDM_AR0 indirect bus I/F mode address0 register
	0xfff2 регистр-IDM_AR1 indirect bus I/F mode address1 register
	0xfff3 регистр-IDM_DR  indirect bus I/F mode data register
----------------------------------------------------------------------------------------------------
* Адрес 0xfff6 использован для сброса модуля Ethernet и установки страницы энерго-независимой памяти.
	0xfff6 Запись d6=reset_ethernet
	0xfff6 Чтение d6=reset_ethernet
----------------------------------------------------------------------------------------------------
*
* Выходные порты контроллера:
* PE3 - высокий включение зеленого светодиода VH1
* PE2 - высокий включение красного светодиода VH2
* PD4 - активно-низкий сигнал снижения бортового питания до 4.58В
* PD7 - переключение - сброс внешнего сторожевого таймера
*_________________________________________________________________________________________________________
*
* Модуль получает сетевые и протокольные установки, указанные в файле defGlobal.h.
* Создается UDP сокет.
* Для нормальной работы системы по приему и передаче UDP пакетов, должна регулярно
* вызываться функция ETH_work().
*_________________________________________________________________________________________________________
*
* Для приема данных надо использовать структуру - struct ETH_Request	ETH_Rec;   
* struct ETH_Request
* {	
*	unsigned char		req;	// признак запроса разбора пришедшего пакета или части пакета от сети ethernet
*	unsigned char		leng;	// длина принятой информации для разбора, вместе с 8и байтовым заголовком
* };
* Если ETH_Rec.req != 0, это указывает на прием нового пакета, или его части из сети.
* Член leng указывает на длину принятой информации.
* Обработчик входного сообщения должен сбросить признак ETH_Rec.rec, и использовать первые leng байт
* приемного буфера ethRCbuff[]. Причем, если пойман целиком весь пакет, то первые 8мь байт
* будут служебные. Первые 2а байта - это длина сообщения, включая сам счетчик длины, затем 4е
* байта - IP адрес источника сообщения, затем 2а байта - номер порта источника сообщения.
* Старший байт в полях длины, IP адреса и номера порта идут первыми.
* После идут пользовательские UDP данные.
*_________________________________________________________________________________________________________
*
* Для организаии передачи данных в формате UDP пакетов, используется структура
* struct ETH_Request	ETH_Send;
* struct ETH_Request
* {	
*	unsigned char	req;	// признак запроса передачи пакета к модулю ethernet
*	unsigned char	leng;	// длина запрошенного к передаче пакета
* };
* Предварительно проверяют признак активного запроса передачи req.
* Если признак сброшен, то можно активизировать посылку следующей порции данных в буфер передачи.
* Данные помещают в буфер.
* Записывают длину передаваемых данных в компонент leng структуры и выставляют
* признак запроса передачи пакета к модулю ethernet req=1.
*_________________________________________________________________________________________________________
*
* Особое внимание нужно обратить на размеры буфера приемника и передатчика.
* Счетчики длины сделаны типа unsigned char.
* ethTRbuff[ETH_TR_SIZE] - служебный буфер передатчика, непосредственно в него пользователь запись не производит.
* ethRCbuff[ETH_RC_SIZE] - буфер приемника, пользователь читает отсюда принятый пакет.
*
* ETH_RC_SIZE		dd		// Размер буфера данных пакета, который пришел по сети ethernet.
* ETH_TR_SIZE		dd-8	// Размер буфера данных промежуточного хранения предназначенных для передачи по ethernet.
* где dd <= 255. Устанавливаются в файле defConstant.h!
*_________________________________________________________________________________________________________
* 
* Программа устанавливает нулевой таймер на частоту прерывания 25 Гц, для формирования временных задержек
* свечения светодиодов индикации. Обработка таймера происдодит в прерывании.
* Каждый тик таймера декрементирует до нуля переменные массива time_out[4]. Переменная с индексом ноль,
* задействована на индикацию признака нормальной работы, миганием зеленого индикатора.
*_________________________________________________________________________________________________________
* 
* Программа устанавливает и обслуживает внутренний и внешний сторожевой таймер.
* Отсутствует контроль правильности функционирования модуля Ethernet, 
* поэтому модуль никогда не пересбрасываеся аппаратно после инициялизации.
* Если в будущем появится критерий неустранимого сбоя модуля,
* то сброс модуля и повторная инициализация может быть проведена
* простой установкой в 0 элемента структуры ETH_stat.phase.
****************************************************************************/
//#define MYTEST
/****************************************************************/
#include <avr/io.h>
#include <avr/wdt.h>
#include "headers/MACRO.H"
#include "headers/defConstant.h"
#include "headers/defGlobal.h"
#include "headers/defFunction.h"
/****************************************************************/

int		main(void);

/****************************************************************/

int main(void)
{
	wdt_disable();
	initCPU();									// Hardware CPU initialization
	INT_enable();								// разрешение прерываний
	
	#ifdef MYTEST								// для проведения отладки небольших фрагментов программы
	{
	
	}
	#endif
	
	GREEN_ON();
	RED_OFF();
	ETH_stat.initRequest = 1;					//признак-требование установки модуля из FLASH

	while(1)
	{
		/**/
		while((PIND & 0x10) == 0)				//останов выполнения программы при снижении бортового питания
		{
			WDText();							// сброс внешнего сторожевого таймера
			wdt_reset();						// сброс внутреннего сторожевого таймера
			if(time_out[1] == 0)				// задержка для организации мигания светодиода индикации ошибки питания
			{
				time_out[1]=12;					// сброс таймера
				RED_TOG();						// переключение светодиода индикации ошибки питания
				GREEN_OFF();					// выключение светодиода работы
			}
		}
		/**/
		if(time_out[1] == 0) RED_OFF();		// выключение светодиода по истечении заданного времени
		if(time_out[0] == 0)					// задержка для организации мигания светодиода индикации работы
		{
			time_out[0]=25;						// установка таймера
			GREEN_TOG();						// переключение светодиода работы
		}
		WDText();								// сброс внешнего сторожевого таймера
		wdt_reset();							// сброс внутреннего сторожевого таймера
		ETH_work();								// работа с модулем WIZnet
	}
	return 0;
}


/****************************************************************/
/****************************************************************/
