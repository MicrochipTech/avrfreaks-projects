
mme_boot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001822  00030000  00030000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000320  00802000  00031822  000018b6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004c7  00802320  00802320  00001bd6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001bd6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001c08  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001c0  00000000  00000000  00001c48  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000057d2  00000000  00000000  00001e08  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002f4d  00000000  00000000  000075da  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001d82  00000000  00000000  0000a527  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000069c  00000000  00000000  0000c2ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000026fd  00000000  00000000  0000c948  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000025f4  00000000  00000000  0000f045  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000190  00000000  00000000  00011639  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00030000 <__vectors>:
   30000:	fd c0       	rjmp	.+506    	; 0x301fc <__ctors_end>
   30002:	00 00       	nop
   30004:	1b c1       	rjmp	.+566    	; 0x3023c <__bad_interrupt>
   30006:	00 00       	nop
   30008:	19 c1       	rjmp	.+562    	; 0x3023c <__bad_interrupt>
   3000a:	00 00       	nop
   3000c:	17 c1       	rjmp	.+558    	; 0x3023c <__bad_interrupt>
   3000e:	00 00       	nop
   30010:	15 c1       	rjmp	.+554    	; 0x3023c <__bad_interrupt>
   30012:	00 00       	nop
   30014:	13 c1       	rjmp	.+550    	; 0x3023c <__bad_interrupt>
   30016:	00 00       	nop
   30018:	11 c1       	rjmp	.+546    	; 0x3023c <__bad_interrupt>
   3001a:	00 00       	nop
   3001c:	0f c1       	rjmp	.+542    	; 0x3023c <__bad_interrupt>
   3001e:	00 00       	nop
   30020:	0d c1       	rjmp	.+538    	; 0x3023c <__bad_interrupt>
   30022:	00 00       	nop
   30024:	0b c1       	rjmp	.+534    	; 0x3023c <__bad_interrupt>
   30026:	00 00       	nop
   30028:	09 c1       	rjmp	.+530    	; 0x3023c <__bad_interrupt>
   3002a:	00 00       	nop
   3002c:	07 c1       	rjmp	.+526    	; 0x3023c <__bad_interrupt>
   3002e:	00 00       	nop
   30030:	05 c1       	rjmp	.+522    	; 0x3023c <__bad_interrupt>
   30032:	00 00       	nop
   30034:	03 c1       	rjmp	.+518    	; 0x3023c <__bad_interrupt>
   30036:	00 00       	nop
   30038:	ba c7       	rjmp	.+3956   	; 0x30fae <__vector_14>
   3003a:	00 00       	nop
   3003c:	ff c0       	rjmp	.+510    	; 0x3023c <__bad_interrupt>
   3003e:	00 00       	nop
   30040:	fd c0       	rjmp	.+506    	; 0x3023c <__bad_interrupt>
   30042:	00 00       	nop
   30044:	fb c0       	rjmp	.+502    	; 0x3023c <__bad_interrupt>
   30046:	00 00       	nop
   30048:	f9 c0       	rjmp	.+498    	; 0x3023c <__bad_interrupt>
   3004a:	00 00       	nop
   3004c:	f7 c0       	rjmp	.+494    	; 0x3023c <__bad_interrupt>
   3004e:	00 00       	nop
   30050:	f5 c0       	rjmp	.+490    	; 0x3023c <__bad_interrupt>
   30052:	00 00       	nop
   30054:	f3 c0       	rjmp	.+486    	; 0x3023c <__bad_interrupt>
   30056:	00 00       	nop
   30058:	f1 c0       	rjmp	.+482    	; 0x3023c <__bad_interrupt>
   3005a:	00 00       	nop
   3005c:	ef c0       	rjmp	.+478    	; 0x3023c <__bad_interrupt>
   3005e:	00 00       	nop
   30060:	ed c0       	rjmp	.+474    	; 0x3023c <__bad_interrupt>
   30062:	00 00       	nop
   30064:	eb c0       	rjmp	.+470    	; 0x3023c <__bad_interrupt>
   30066:	00 00       	nop
   30068:	e9 c0       	rjmp	.+466    	; 0x3023c <__bad_interrupt>
   3006a:	00 00       	nop
   3006c:	e7 c0       	rjmp	.+462    	; 0x3023c <__bad_interrupt>
   3006e:	00 00       	nop
   30070:	e5 c0       	rjmp	.+458    	; 0x3023c <__bad_interrupt>
   30072:	00 00       	nop
   30074:	e3 c0       	rjmp	.+454    	; 0x3023c <__bad_interrupt>
   30076:	00 00       	nop
   30078:	e1 c0       	rjmp	.+450    	; 0x3023c <__bad_interrupt>
   3007a:	00 00       	nop
   3007c:	df c0       	rjmp	.+446    	; 0x3023c <__bad_interrupt>
   3007e:	00 00       	nop
   30080:	dd c0       	rjmp	.+442    	; 0x3023c <__bad_interrupt>
   30082:	00 00       	nop
   30084:	db c0       	rjmp	.+438    	; 0x3023c <__bad_interrupt>
   30086:	00 00       	nop
   30088:	d9 c0       	rjmp	.+434    	; 0x3023c <__bad_interrupt>
   3008a:	00 00       	nop
   3008c:	d7 c0       	rjmp	.+430    	; 0x3023c <__bad_interrupt>
   3008e:	00 00       	nop
   30090:	d5 c0       	rjmp	.+426    	; 0x3023c <__bad_interrupt>
   30092:	00 00       	nop
   30094:	d3 c0       	rjmp	.+422    	; 0x3023c <__bad_interrupt>
   30096:	00 00       	nop
   30098:	d1 c0       	rjmp	.+418    	; 0x3023c <__bad_interrupt>
   3009a:	00 00       	nop
   3009c:	cf c0       	rjmp	.+414    	; 0x3023c <__bad_interrupt>
   3009e:	00 00       	nop
   300a0:	cd c0       	rjmp	.+410    	; 0x3023c <__bad_interrupt>
   300a2:	00 00       	nop
   300a4:	cb c0       	rjmp	.+406    	; 0x3023c <__bad_interrupt>
   300a6:	00 00       	nop
   300a8:	c9 c0       	rjmp	.+402    	; 0x3023c <__bad_interrupt>
   300aa:	00 00       	nop
   300ac:	c7 c0       	rjmp	.+398    	; 0x3023c <__bad_interrupt>
   300ae:	00 00       	nop
   300b0:	c5 c0       	rjmp	.+394    	; 0x3023c <__bad_interrupt>
   300b2:	00 00       	nop
   300b4:	c3 c0       	rjmp	.+390    	; 0x3023c <__bad_interrupt>
   300b6:	00 00       	nop
   300b8:	c1 c0       	rjmp	.+386    	; 0x3023c <__bad_interrupt>
   300ba:	00 00       	nop
   300bc:	bf c0       	rjmp	.+382    	; 0x3023c <__bad_interrupt>
   300be:	00 00       	nop
   300c0:	bd c0       	rjmp	.+378    	; 0x3023c <__bad_interrupt>
   300c2:	00 00       	nop
   300c4:	bb c0       	rjmp	.+374    	; 0x3023c <__bad_interrupt>
   300c6:	00 00       	nop
   300c8:	b9 c0       	rjmp	.+370    	; 0x3023c <__bad_interrupt>
   300ca:	00 00       	nop
   300cc:	b7 c0       	rjmp	.+366    	; 0x3023c <__bad_interrupt>
   300ce:	00 00       	nop
   300d0:	b5 c0       	rjmp	.+362    	; 0x3023c <__bad_interrupt>
   300d2:	00 00       	nop
   300d4:	b3 c0       	rjmp	.+358    	; 0x3023c <__bad_interrupt>
   300d6:	00 00       	nop
   300d8:	b1 c0       	rjmp	.+354    	; 0x3023c <__bad_interrupt>
   300da:	00 00       	nop
   300dc:	af c0       	rjmp	.+350    	; 0x3023c <__bad_interrupt>
   300de:	00 00       	nop
   300e0:	ad c0       	rjmp	.+346    	; 0x3023c <__bad_interrupt>
   300e2:	00 00       	nop
   300e4:	ab c0       	rjmp	.+342    	; 0x3023c <__bad_interrupt>
   300e6:	00 00       	nop
   300e8:	a9 c0       	rjmp	.+338    	; 0x3023c <__bad_interrupt>
   300ea:	00 00       	nop
   300ec:	a7 c0       	rjmp	.+334    	; 0x3023c <__bad_interrupt>
   300ee:	00 00       	nop
   300f0:	a5 c0       	rjmp	.+330    	; 0x3023c <__bad_interrupt>
   300f2:	00 00       	nop
   300f4:	a3 c0       	rjmp	.+326    	; 0x3023c <__bad_interrupt>
   300f6:	00 00       	nop
   300f8:	a1 c0       	rjmp	.+322    	; 0x3023c <__bad_interrupt>
   300fa:	00 00       	nop
   300fc:	9f c0       	rjmp	.+318    	; 0x3023c <__bad_interrupt>
   300fe:	00 00       	nop
   30100:	9d c0       	rjmp	.+314    	; 0x3023c <__bad_interrupt>
   30102:	00 00       	nop
   30104:	9b c0       	rjmp	.+310    	; 0x3023c <__bad_interrupt>
   30106:	00 00       	nop
   30108:	99 c0       	rjmp	.+306    	; 0x3023c <__bad_interrupt>
   3010a:	00 00       	nop
   3010c:	97 c0       	rjmp	.+302    	; 0x3023c <__bad_interrupt>
   3010e:	00 00       	nop
   30110:	95 c0       	rjmp	.+298    	; 0x3023c <__bad_interrupt>
   30112:	00 00       	nop
   30114:	93 c0       	rjmp	.+294    	; 0x3023c <__bad_interrupt>
   30116:	00 00       	nop
   30118:	91 c0       	rjmp	.+290    	; 0x3023c <__bad_interrupt>
   3011a:	00 00       	nop
   3011c:	8f c0       	rjmp	.+286    	; 0x3023c <__bad_interrupt>
   3011e:	00 00       	nop
   30120:	8d c0       	rjmp	.+282    	; 0x3023c <__bad_interrupt>
   30122:	00 00       	nop
   30124:	8b c0       	rjmp	.+278    	; 0x3023c <__bad_interrupt>
   30126:	00 00       	nop
   30128:	89 c0       	rjmp	.+274    	; 0x3023c <__bad_interrupt>
   3012a:	00 00       	nop
   3012c:	87 c0       	rjmp	.+270    	; 0x3023c <__bad_interrupt>
   3012e:	00 00       	nop
   30130:	85 c0       	rjmp	.+266    	; 0x3023c <__bad_interrupt>
   30132:	00 00       	nop
   30134:	83 c0       	rjmp	.+262    	; 0x3023c <__bad_interrupt>
   30136:	00 00       	nop
   30138:	81 c0       	rjmp	.+258    	; 0x3023c <__bad_interrupt>
   3013a:	00 00       	nop
   3013c:	7f c0       	rjmp	.+254    	; 0x3023c <__bad_interrupt>
   3013e:	00 00       	nop
   30140:	7d c0       	rjmp	.+250    	; 0x3023c <__bad_interrupt>
   30142:	00 00       	nop
   30144:	7b c0       	rjmp	.+246    	; 0x3023c <__bad_interrupt>
   30146:	00 00       	nop
   30148:	79 c0       	rjmp	.+242    	; 0x3023c <__bad_interrupt>
   3014a:	00 00       	nop
   3014c:	77 c0       	rjmp	.+238    	; 0x3023c <__bad_interrupt>
   3014e:	00 00       	nop
   30150:	75 c0       	rjmp	.+234    	; 0x3023c <__bad_interrupt>
   30152:	00 00       	nop
   30154:	73 c0       	rjmp	.+230    	; 0x3023c <__bad_interrupt>
   30156:	00 00       	nop
   30158:	71 c0       	rjmp	.+226    	; 0x3023c <__bad_interrupt>
   3015a:	00 00       	nop
   3015c:	6f c0       	rjmp	.+222    	; 0x3023c <__bad_interrupt>
   3015e:	00 00       	nop
   30160:	6d c0       	rjmp	.+218    	; 0x3023c <__bad_interrupt>
   30162:	00 00       	nop
   30164:	6b c0       	rjmp	.+214    	; 0x3023c <__bad_interrupt>
   30166:	00 00       	nop
   30168:	69 c0       	rjmp	.+210    	; 0x3023c <__bad_interrupt>
   3016a:	00 00       	nop
   3016c:	67 c0       	rjmp	.+206    	; 0x3023c <__bad_interrupt>
   3016e:	00 00       	nop
   30170:	65 c0       	rjmp	.+202    	; 0x3023c <__bad_interrupt>
   30172:	00 00       	nop
   30174:	63 c0       	rjmp	.+198    	; 0x3023c <__bad_interrupt>
   30176:	00 00       	nop
   30178:	61 c0       	rjmp	.+194    	; 0x3023c <__bad_interrupt>
   3017a:	00 00       	nop
   3017c:	5f c0       	rjmp	.+190    	; 0x3023c <__bad_interrupt>
   3017e:	00 00       	nop
   30180:	5d c0       	rjmp	.+186    	; 0x3023c <__bad_interrupt>
   30182:	00 00       	nop
   30184:	5b c0       	rjmp	.+182    	; 0x3023c <__bad_interrupt>
   30186:	00 00       	nop
   30188:	59 c0       	rjmp	.+178    	; 0x3023c <__bad_interrupt>
   3018a:	00 00       	nop
   3018c:	57 c0       	rjmp	.+174    	; 0x3023c <__bad_interrupt>
   3018e:	00 00       	nop
   30190:	55 c0       	rjmp	.+170    	; 0x3023c <__bad_interrupt>
   30192:	00 00       	nop
   30194:	53 c0       	rjmp	.+166    	; 0x3023c <__bad_interrupt>
   30196:	00 00       	nop
   30198:	51 c0       	rjmp	.+162    	; 0x3023c <__bad_interrupt>
   3019a:	00 00       	nop
   3019c:	4f c0       	rjmp	.+158    	; 0x3023c <__bad_interrupt>
   3019e:	00 00       	nop
   301a0:	4d c0       	rjmp	.+154    	; 0x3023c <__bad_interrupt>
   301a2:	00 00       	nop
   301a4:	4b c0       	rjmp	.+150    	; 0x3023c <__bad_interrupt>
   301a6:	00 00       	nop
   301a8:	49 c0       	rjmp	.+146    	; 0x3023c <__bad_interrupt>
   301aa:	00 00       	nop
   301ac:	47 c0       	rjmp	.+142    	; 0x3023c <__bad_interrupt>
   301ae:	00 00       	nop
   301b0:	45 c0       	rjmp	.+138    	; 0x3023c <__bad_interrupt>
   301b2:	00 00       	nop
   301b4:	43 c0       	rjmp	.+134    	; 0x3023c <__bad_interrupt>
   301b6:	00 00       	nop
   301b8:	41 c0       	rjmp	.+130    	; 0x3023c <__bad_interrupt>
   301ba:	00 00       	nop
   301bc:	3f c0       	rjmp	.+126    	; 0x3023c <__bad_interrupt>
   301be:	00 00       	nop
   301c0:	3d c0       	rjmp	.+122    	; 0x3023c <__bad_interrupt>
   301c2:	00 00       	nop
   301c4:	3b c0       	rjmp	.+118    	; 0x3023c <__bad_interrupt>
   301c6:	00 00       	nop
   301c8:	39 c0       	rjmp	.+114    	; 0x3023c <__bad_interrupt>
   301ca:	00 00       	nop
   301cc:	37 c0       	rjmp	.+110    	; 0x3023c <__bad_interrupt>
   301ce:	00 00       	nop
   301d0:	35 c0       	rjmp	.+106    	; 0x3023c <__bad_interrupt>
   301d2:	00 00       	nop
   301d4:	33 c0       	rjmp	.+102    	; 0x3023c <__bad_interrupt>
   301d6:	00 00       	nop
   301d8:	31 c0       	rjmp	.+98     	; 0x3023c <__bad_interrupt>
   301da:	00 00       	nop
   301dc:	2f c0       	rjmp	.+94     	; 0x3023c <__bad_interrupt>
   301de:	00 00       	nop
   301e0:	2d c0       	rjmp	.+90     	; 0x3023c <__bad_interrupt>
   301e2:	00 00       	nop
   301e4:	2b c0       	rjmp	.+86     	; 0x3023c <__bad_interrupt>
   301e6:	00 00       	nop
   301e8:	29 c0       	rjmp	.+82     	; 0x3023c <__bad_interrupt>
   301ea:	00 00       	nop
   301ec:	27 c0       	rjmp	.+78     	; 0x3023c <__bad_interrupt>
   301ee:	00 00       	nop
   301f0:	25 c0       	rjmp	.+74     	; 0x3023c <__bad_interrupt>
   301f2:	00 00       	nop
   301f4:	23 c0       	rjmp	.+70     	; 0x3023c <__bad_interrupt>
   301f6:	00 00       	nop
   301f8:	21 c0       	rjmp	.+66     	; 0x3023c <__bad_interrupt>
	...

000301fc <__ctors_end>:
   301fc:	11 24       	eor	r1, r1
   301fe:	1f be       	out	0x3f, r1	; 63
   30200:	cf ef       	ldi	r28, 0xFF	; 255
   30202:	cd bf       	out	0x3d, r28	; 61
   30204:	df e5       	ldi	r29, 0x5F	; 95
   30206:	de bf       	out	0x3e, r29	; 62
   30208:	01 e0       	ldi	r16, 0x01	; 1
   3020a:	0c bf       	out	0x3c, r16	; 60

0003020c <__do_copy_data>:
   3020c:	13 e2       	ldi	r17, 0x23	; 35
   3020e:	a0 e0       	ldi	r26, 0x00	; 0
   30210:	b0 e2       	ldi	r27, 0x20	; 32
   30212:	e2 e2       	ldi	r30, 0x22	; 34
   30214:	f8 e1       	ldi	r31, 0x18	; 24
   30216:	03 e0       	ldi	r16, 0x03	; 3
   30218:	0b bf       	out	0x3b, r16	; 59
   3021a:	02 c0       	rjmp	.+4      	; 0x30220 <__do_copy_data+0x14>
   3021c:	07 90       	elpm	r0, Z+
   3021e:	0d 92       	st	X+, r0
   30220:	a0 32       	cpi	r26, 0x20	; 32
   30222:	b1 07       	cpc	r27, r17
   30224:	d9 f7       	brne	.-10     	; 0x3021c <__do_copy_data+0x10>

00030226 <__do_clear_bss>:
   30226:	27 e2       	ldi	r18, 0x27	; 39
   30228:	a0 e2       	ldi	r26, 0x20	; 32
   3022a:	b3 e2       	ldi	r27, 0x23	; 35
   3022c:	01 c0       	rjmp	.+2      	; 0x30230 <.do_clear_bss_start>

0003022e <.do_clear_bss_loop>:
   3022e:	1d 92       	st	X+, r1

00030230 <.do_clear_bss_start>:
   30230:	a7 3e       	cpi	r26, 0xE7	; 231
   30232:	b2 07       	cpc	r27, r18
   30234:	e1 f7       	brne	.-8      	; 0x3022e <.do_clear_bss_loop>
   30236:	23 d7       	rcall	.+3654   	; 0x3107e <main>
   30238:	0d 94 0f 8c 	jmp	0x3181e	; 0x3181e <_exit>

0003023c <__bad_interrupt>:
   3023c:	e1 ce       	rjmp	.-574    	; 0x30000 <__vectors>

0003023e <SP_ReadByte>:

.section .text
.global SP_ReadByte

SP_ReadByte:
	in	r19, RAMPZ      ; Save RAMPZ.
   3023e:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24      ; Load RAMPZ with the MSB of the address.
   30240:	8b bf       	out	0x3b, r24	; 59
	movw	ZL, r22         ; Move the low bytes to the Z pointer
   30242:	fb 01       	movw	r30, r22
	elpm	r24, Z          ; Extended load byte from address pointed to by Z.
   30244:	86 91       	elpm	r24, Z
	out	RAMPZ, r19      ; Restore RAMPZ register.
   30246:	3b bf       	out	0x3b, r19	; 59
	ret
   30248:	08 95       	ret

0003024a <SP_ReadWord>:

.section .text
.global SP_ReadWord

SP_ReadWord:
	in	r19, RAMPZ      ; Save RAMPZ.
   3024a:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24      ; Load RAMPZ with the MSB of the address.
   3024c:	8b bf       	out	0x3b, r24	; 59
	movw	ZL, r22         ; Move the low bytes to the Z pointer
   3024e:	fb 01       	movw	r30, r22
	elpm	r24, Z+         ; Extended load byte from address pointed to by Z.
   30250:	87 91       	elpm	r24, Z+
	elpm	r25, Z          ; Extended load byte from address pointed to by Z.
   30252:	96 91       	elpm	r25, Z
	out	RAMPZ, r19      ; Restore RAMPZ register.
   30254:	3b bf       	out	0x3b, r19	; 59
	ret
   30256:	08 95       	ret

00030258 <SP_ReadCalibrationByte>:

.section .text
.global SP_ReadCalibrationByte	

SP_ReadCalibrationByte:
	ldi	r20, NVM_CMD_READ_CALIB_ROW_gc    ; Prepare NVM command in R20.
   30258:	42 e0       	ldi	r20, 0x02	; 2
	rjmp	SP_CommonLPM                      ; Jump to common LPM code.
   3025a:	8c c0       	rjmp	.+280    	; 0x30374 <SP_CommonLPM>

0003025c <SP_ReadUserSignatureByte>:

.section .text	
.global SP_ReadUserSignatureByte

SP_ReadUserSignatureByte:
	ldi	r20, NVM_CMD_READ_USER_SIG_ROW_gc  ; Prepare NVM command in R20.
   3025c:	41 e0       	ldi	r20, 0x01	; 1
	rjmp	SP_CommonLPM                       ; Jump to common LPM code.
   3025e:	8a c0       	rjmp	.+276    	; 0x30374 <SP_CommonLPM>

00030260 <SP_ReadFuseByte>:

.section .text	
.global SP_ReadFuseByte

SP_ReadFuseByte:
	sts	NVM_ADDR0, r24              ; Load fuse byte index into NVM Address Register 0.
   30260:	80 93 c0 01 	sts	0x01C0, r24	; 0x8001c0 <__TEXT_REGION_LENGTH__+0x7001c0>
	clr	r24                         ; Prepare a zero.
   30264:	88 27       	eor	r24, r24
	sts	NVM_ADDR1, r24              ; Load zero into NVM Address Register 1.
   30266:	80 93 c1 01 	sts	0x01C1, r24	; 0x8001c1 <__TEXT_REGION_LENGTH__+0x7001c1>
	sts	NVM_ADDR2, r24              ; Load zero into NVM Address Register 2.
   3026a:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <__TEXT_REGION_LENGTH__+0x7001c2>
	ldi	r20, NVM_CMD_READ_FUSES_gc  ; Prepare NVM command in R20.
   3026e:	47 e0       	ldi	r20, 0x07	; 7
	rcall	SP_CommonCMD                ; Jump to common NVM Action code.
   30270:	71 d0       	rcall	.+226    	; 0x30354 <SP_CommonCMD>
	movw	r24, r22                    ; Move low byte to 1 byte return address.
   30272:	cb 01       	movw	r24, r22
	ret
   30274:	08 95       	ret

00030276 <SP_WriteLockBits>:

.section .text	
.global SP_WriteLockBits

SP_WriteLockBits:
	sts	NVM_DATA0, r24                  ; Load lock bits into NVM Data Register 0.
   30276:	80 93 c4 01 	sts	0x01C4, r24	; 0x8001c4 <__TEXT_REGION_LENGTH__+0x7001c4>
	ldi	r20, NVM_CMD_WRITE_LOCK_BITS_gc ; Prepare NVM command in R20.
   3027a:	48 e0       	ldi	r20, 0x08	; 8
	rjmp	SP_CommonCMD                    ; Jump to common NVM Action code.
   3027c:	6b c0       	rjmp	.+214    	; 0x30354 <SP_CommonCMD>

0003027e <SP_ReadLockBits>:

.section .text		
.global SP_ReadLockBits

SP_ReadLockBits:
	lds	r24, NVM_LOCKBITS       ; Read IO-mapped lock bits.
   3027e:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <__TEXT_REGION_LENGTH__+0x7001d0>
	ret
   30282:	08 95       	ret

00030284 <SP_EraseUserSignatureRow>:

.section .text
.global SP_EraseUserSignatureRow

SP_EraseUserSignatureRow:
	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
   30284:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_ERASE_USER_SIG_ROW_gc ; Prepare NVM command in R20.
   30286:	48 e1       	ldi	r20, 0x18	; 24
	jmp 	SP_CommonSPM                       ; Jump to common SPM code.
   30288:	7a c0       	rjmp	.+244    	; 0x3037e <SP_CommonSPM>

0003028a <SP_WriteUserSignatureRow>:

.section .text
.global SP_WriteUserSignatureRow

SP_WriteUserSignatureRow:
	in	r19, RAMPZ                          ; Save RAMPZ, which is restored in SP_CommonSPM.
   3028a:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_WRITE_USER_SIG_ROW_gc  ; Prepare NVM command in R20.
	jmp	SP_CommonSPM                        ; Jump to common SPM code.
   3028c:	4a e1       	ldi	r20, 0x1A	; 26
   3028e:	77 c0       	rjmp	.+238    	; 0x3037e <SP_CommonSPM>

00030290 <SP_EraseApplicationSection>:

.section .text
.global SP_EraseApplicationSection

SP_EraseApplicationSection:
	in	r19, RAMPZ                 ; Save RAMPZ, which is restored in SP_CommonSPM.
   30290:	3b b7       	in	r19, 0x3b	; 59
	clr	r24                        ; Prepare a zero.
   30292:	88 27       	eor	r24, r24
	clr	r25
   30294:	99 27       	eor	r25, r25
	out	RAMPZ, r24                 ; Point into Application area.
	ldi	r20, NVM_CMD_ERASE_APP_gc  ; Prepare NVM command in R20.
   30296:	8b bf       	out	0x3b, r24	; 59
	jmp	SP_CommonSPM               ; Jump to common SPM code.
   30298:	40 e2       	ldi	r20, 0x20	; 32
   3029a:	71 c0       	rjmp	.+226    	; 0x3037e <SP_CommonSPM>

0003029c <SP_EraseApplicationPage>:

.section .text	
.global SP_EraseApplicationPage

SP_EraseApplicationPage:
	in	r19, RAMPZ                      ; Save RAMPZ, which is restored in SP_CommonSPM.
   3029c:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                      ; Load RAMPZ with the MSB of the address.
	movw    r24, r22                        ; Move low bytes for ZH:ZL to R25:R24
   3029e:	8b bf       	out	0x3b, r24	; 59
	ldi	r20, NVM_CMD_ERASE_APP_PAGE_gc  ; Prepare NVM command in R20.
   302a0:	cb 01       	movw	r24, r22
	jmp	SP_CommonSPM                    ; Jump to common SPM code.
   302a2:	42 e2       	ldi	r20, 0x22	; 34

.section .text
.global SP_LoadFlashWord

SP_LoadFlashWord:
	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
   302a4:	6c c0       	rjmp	.+216    	; 0x3037e <SP_CommonSPM>

000302a6 <SP_LoadFlashWord>:
	movw	r0, r22                            ; Prepare flash word in R1:R0.
   302a6:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_LOAD_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
   302a8:	0b 01       	movw	r0, r22
	jmp	SP_CommonSPM                       ; Jump to common SPM code.
   302aa:	43 e2       	ldi	r20, 0x23	; 35
   302ac:	68 c0       	rjmp	.+208    	; 0x3037e <SP_CommonSPM>

000302ae <SP_LoadFlashPage>:
		
.section .text
.global SP_LoadFlashPage

SP_LoadFlashPage:
	clr	ZL              ; Clear low byte of Z, to indicate start of page.
   302ae:	ee 27       	eor	r30, r30
	clr	ZH              ; Clear high byte of Z, to indicate start of page.
   302b0:	ff 27       	eor	r31, r31

	out	RAMPX, r1       ; Clear RAMPX pointer.
   302b2:	19 be       	out	0x39, r1	; 57
	movw	XL, r24         ; Load X with data buffer address.
   302b4:	dc 01       	movw	r26, r24

	ldi 	r20, NVM_CMD_LOAD_FLASH_BUFFER_gc  ; Prepare NVM command code in R20.
   302b6:	43 e2       	ldi	r20, 0x23	; 35
	sts	NVM_CMD, r20                       ; Load it into NVM command register.
   302b8:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>

#if APP_SECTION_PAGE_SIZE > 512
	ldi	r22, ((APP_SECTION_PAGE_SIZE/2) >> 8)
#endif

	ldi	r21, ((APP_SECTION_PAGE_SIZE/2)&0xFF)    ; Load R21 with page word count.
   302bc:	50 e0       	ldi	r21, 0x00	; 0
	ldi	r18, CCP_SPM_gc                    ; Prepare Protect SPM signature in R16.
   302be:	2d e9       	ldi	r18, 0x9D	; 157

000302c0 <SP_LoadFlashPage_1>:

SP_LoadFlashPage_1:
	ld	r0, X+         ; Load low byte from buffer into R0.
   302c0:	0d 90       	ld	r0, X+
	ld	r1, X+         ; Load high byte from buffer into R1.
   302c2:	1d 90       	ld	r1, X+
	sts	CCP, r18       ; Enable SPM operation (this disables interrupts for 4 cycles).
   302c4:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
	spm                    ; Self-program.
   302c8:	e8 95       	spm
	adiw	ZL, 2          ; Move Z to next Flash word.
   302ca:	32 96       	adiw	r30, 0x02	; 2

#if APP_SECTION_PAGE_SIZE > 512
	subi	r21, 1         ; Decrement word count.
	sbci	r22, 0
#else
	dec	r21            ; Decrement word count.
   302cc:	5a 95       	dec	r21
#endif

	brne	SP_LoadFlashPage_1   ; Repeat until word cont is zero.
   302ce:	c1 f7       	brne	.-16     	; 0x302c0 <SP_LoadFlashPage_1>

	clr	r1                   ; Clear R1 for GCC _zero_reg_ to function properly.
   302d0:	11 24       	eor	r1, r1
	ret
   302d2:	08 95       	ret

000302d4 <SP_ReadFlashPage>:
.section .text		
.global SP_ReadFlashPage

SP_ReadFlashPage:

	in	r19, RAMPZ                   ; Save RAMPZ during assembly.
   302d4:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r22                   ; Load RAMPZ with MSB of address
   302d6:	6b bf       	out	0x3b, r22	; 59
	movw    ZL, r20                      ; Load Z with Flash address.
   302d8:	fa 01       	movw	r30, r20

	out	RAMPX, r1                    ; Load RAMPX with data pointer
   302da:	19 be       	out	0x39, r1	; 57
	movw	XL, r24                      ; Load X with data buffer address.
   302dc:	dc 01       	movw	r26, r24

	ldi	r20, NVM_CMD_NO_OPERATION_gc ; Prepare NVM command code in R20.
   302de:	40 e0       	ldi	r20, 0x00	; 0
	sts	NVM_CMD, r20                 ; Set NVM command to No Operation so that LPM reads Flash.
   302e0:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>

#if APP_SECTION_PAGE_SIZE > 512
	ldi	r22, ((APP_SECTION_PAGE_SIZE/2) >> 8) ; Load R22 with byte cont high if flash page is large.
#endif	

	ldi	r21, ((APP_SECTION_PAGE_SIZE)&0xFF)   ; Load R21 with byte count.
   302e4:	50 e0       	ldi	r21, 0x00	; 0

000302e6 <SP_ReadFlashPage_1>:

SP_ReadFlashPage_1:
	elpm	r24, Z+                         ; Load Flash bytes into R18:r19
   302e6:	87 91       	elpm	r24, Z+
	elpm	r25, Z+
   302e8:	97 91       	elpm	r25, Z+
	st	X+, r24                         ; Write bytes to buffer.
   302ea:	8d 93       	st	X+, r24
	st	X+, r25
   302ec:	9d 93       	st	X+, r25

#if APP_SECTION_PAGE_SIZE > 512
	subi	r21, 1                          ; Decrement word count.
	sbci	r22, 0
#else
	dec	r21                             ; Decrement word count.
   302ee:	5a 95       	dec	r21
#endif	

	brne	SP_ReadFlashPage_1              ; Repeat until byte count is zero.
   302f0:	d1 f7       	brne	.-12     	; 0x302e6 <SP_ReadFlashPage_1>

	out	RAMPZ, r19
   302f2:	3b bf       	out	0x3b, r19	; 59

.section .text		
.global SP_WriteApplicationPage

SP_WriteApplicationPage:
	in	r19, RAMPZ                       ; Save RAMPZ, which is restored in SP_CommonSPM.
   302f4:	08 95       	ret

000302f6 <SP_WriteApplicationPage>:
	out	RAMPZ, r24                       ; Load RAMPZ with the MSB of the address.
   302f6:	3b b7       	in	r19, 0x3b	; 59
	movw	r24, r22                         ; Move low bytes of address to ZH:ZL from R23:R22
   302f8:	8b bf       	out	0x3b, r24	; 59
	ldi	r20, NVM_CMD_WRITE_APP_PAGE_gc   ; Prepare NVM command in R20.
   302fa:	cb 01       	movw	r24, r22
	jmp	SP_CommonSPM                     ; Jump to common SPM code.
   302fc:	44 e2       	ldi	r20, 0x24	; 36

.section .text
.global SP_EraseWriteApplicationPage

SP_EraseWriteApplicationPage:
	in	r19, RAMPZ                            ; Save RAMPZ, which is restored in SP_CommonSPM.
   302fe:	3f c0       	rjmp	.+126    	; 0x3037e <SP_CommonSPM>

00030300 <SP_EraseWriteApplicationPage>:
	out	RAMPZ, r24                            ; Load RAMPZ with the MSB of the address.
	movw	r24, r22                              ; Move low bytes of address to ZH:ZL from R23:R22
   30300:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_ERASE_WRITE_APP_PAGE_gc  ; Prepare NVM command in R20.
   30302:	8b bf       	out	0x3b, r24	; 59
	jmp	SP_CommonSPM                          ; Jump to common SPM code.
   30304:	cb 01       	movw	r24, r22
   30306:	45 e2       	ldi	r20, 0x25	; 37
.section .text		
.global SP_EraseFlashBuffer

SP_EraseFlashBuffer:
	in	r19, RAMPZ                          ; Save RAMPZ, which is restored in SP_CommonSPM.
	ldi	r20, NVM_CMD_ERASE_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
   30308:	3a c0       	rjmp	.+116    	; 0x3037e <SP_CommonSPM>

0003030a <SP_EraseFlashBuffer>:
	jmp	SP_CommonSPM                        ; Jump to common SPM code.
   3030a:	3b b7       	in	r19, 0x3b	; 59
   3030c:	46 e2       	ldi	r20, 0x26	; 38

.section .text		
.global SP_EraseBootPage

SP_EraseBootPage:
	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
   3030e:	37 c0       	rjmp	.+110    	; 0x3037e <SP_CommonSPM>

00030310 <SP_EraseBootPage>:
	out	RAMPZ, r24                         ; Load RAMPZ with the MSB of the address.
	movw	r24, r22                           ; Move low bytes of address to ZH:ZL from R23:R22
   30310:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_ERASE_BOOT_PAGE_gc    ; Prepare NVM command in R20.
   30312:	8b bf       	out	0x3b, r24	; 59
	jmp	SP_CommonSPM                       ; Jump to common SPM code.
   30314:	cb 01       	movw	r24, r22
   30316:	4a e2       	ldi	r20, 0x2A	; 42
.section .text		
.global SP_WriteBootPage

SP_WriteBootPage:
	in	r19, RAMPZ                       ; Save RAMPZ, which is restored in SP_CommonSPM.
	out	RAMPZ, r24                       ; Load RAMPZ with the MSB of the address.
   30318:	32 c0       	rjmp	.+100    	; 0x3037e <SP_CommonSPM>

0003031a <SP_WriteBootPage>:
	movw	r24, r22                         ; Move low bytes of address to ZH:ZL from R23:R22
   3031a:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_WRITE_BOOT_PAGE_gc  ; Prepare NVM command in R20.
   3031c:	8b bf       	out	0x3b, r24	; 59
	jmp	SP_CommonSPM                     ; Jump to common SPM code.
   3031e:	cb 01       	movw	r24, r22
   30320:	4c e2       	ldi	r20, 0x2C	; 44

.section .text		
.global SP_EraseWriteBootPage

SP_EraseWriteBootPage:
	in	r19, RAMPZ                             ; Save RAMPZ, which is restored in SP_CommonSPM.
   30322:	2d c0       	rjmp	.+90     	; 0x3037e <SP_CommonSPM>

00030324 <SP_EraseWriteBootPage>:
	out	RAMPZ, r24                             ; Load RAMPZ with the MSB of the address.
   30324:	3b b7       	in	r19, 0x3b	; 59
	movw	r24, r22                               ; Move low bytes of address to ZH:ZL from R23:R22
   30326:	8b bf       	out	0x3b, r24	; 59
	ldi	r20, NVM_CMD_ERASE_WRITE_BOOT_PAGE_gc  ; Prepare NVM command in R20.
   30328:	cb 01       	movw	r24, r22
	jmp	SP_CommonSPM                           ; Jump to common SPM code.
   3032a:	4d e2       	ldi	r20, 0x2D	; 45
   3032c:	28 c0       	rjmp	.+80     	; 0x3037e <SP_CommonSPM>

0003032e <SP_ApplicationCRC>:

.section .text	
.global SP_ApplicationCRC

SP_ApplicationCRC:
	ldi	r20, NVM_CMD_APP_CRC_gc    ; Prepare NVM command in R20.
   3032e:	48 e3       	ldi	r20, 0x38	; 56
	rjmp	SP_CommonCMD               ; Jump to common NVM Action code.
   30330:	11 c0       	rjmp	.+34     	; 0x30354 <SP_CommonCMD>

00030332 <SP_BootCRC>:

.section .text
.global SP_BootCRC

SP_BootCRC:
	ldi	r20, NVM_CMD_BOOT_CRC_gc   ; Prepare NVM command in R20.
   30332:	49 e3       	ldi	r20, 0x39	; 57
	rjmp	SP_CommonCMD               ; Jump to common NVM Action code.
   30334:	0f c0       	rjmp	.+30     	; 0x30354 <SP_CommonCMD>

00030336 <SP_LockSPM>:

.section .text
.global SP_LockSPM

SP_LockSPM:
	ldi	r18, CCP_IOREG_gc     ; Prepare Protect IO-register signature in R18.
   30336:	28 ed       	ldi	r18, 0xD8	; 216
	sts	CCP, r18              ; Enable IO-register operation (this disables interrupts for 4 cycles).
   30338:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
	ldi	r18, NVM_SPMLOCK_bm   ; Prepare bitmask for locking SPM into R18.
   3033c:	21 e0       	ldi	r18, 0x01	; 1
	sts	NVM_CTRLB, r18        ; Load bitmask into NVM Control Register B, which locks SPM.
   3033e:	20 93 cc 01 	sts	0x01CC, r18	; 0x8001cc <__TEXT_REGION_LENGTH__+0x7001cc>
	ret
   30342:	08 95       	ret

00030344 <SP_WaitForSPM>:

.section .text
.global SP_WaitForSPM		

SP_WaitForSPM:
	lds	r18, NVM_STATUS     ; Load the NVM Status register.
   30344:	20 91 cf 01 	lds	r18, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7001cf>
	sbrc	r18, NVM_NVMBUSY_bp ; Check if bit is cleared.
   30348:	27 fd       	sbrc	r18, 7
	rjmp	SP_WaitForSPM       ; Repeat check if bit is not cleared.
   3034a:	fc cf       	rjmp	.-8      	; 0x30344 <SP_WaitForSPM>
	clr	r18
   3034c:	22 27       	eor	r18, r18
	sts	NVM_CMD, r18        ; Clear up command register to NO_OPERATION.
   3034e:	20 93 ca 01 	sts	0x01CA, r18	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	ret
   30352:	08 95       	ret

00030354 <SP_CommonCMD>:
; ---

.section .text		

SP_CommonCMD:
	sts	NVM_CMD, r20        ; Load command into NVM Command register.
   30354:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	ldi	r18, CCP_IOREG_gc   ; Prepare Protect IO-register signature in R18.
   30358:	28 ed       	ldi	r18, 0xD8	; 216
	ldi	r19, NVM_CMDEX_bm   ; Prepare bitmask for setting NVM Command Execute bit into R19.
   3035a:	31 e0       	ldi	r19, 0x01	; 1
	sts	CCP, r18            ; Enable IO-register operation (this disables interrupts for 4 cycles).
   3035c:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
	sts	NVM_CTRLA, r19      ; Load bitmask into NVM Control Register A, which executes the command.
   30360:	30 93 cb 01 	sts	0x01CB, r19	; 0x8001cb <__TEXT_REGION_LENGTH__+0x7001cb>
	lds	r22, NVM_DATA0      ; Load NVM Data Register 0 into R22.
   30364:	60 91 c4 01 	lds	r22, 0x01C4	; 0x8001c4 <__TEXT_REGION_LENGTH__+0x7001c4>
	lds	r23, NVM_DATA1      ; Load NVM Data Register 1 into R23.
   30368:	70 91 c5 01 	lds	r23, 0x01C5	; 0x8001c5 <__TEXT_REGION_LENGTH__+0x7001c5>
	lds	r24, NVM_DATA2      ; Load NVM Data Register 2 into R24.
   3036c:	80 91 c6 01 	lds	r24, 0x01C6	; 0x8001c6 <__TEXT_REGION_LENGTH__+0x7001c6>
	clr	r25                 ; Clear R25 in order to return a clean 32-bit value.
   30370:	99 27       	eor	r25, r25
	ret
   30372:	08 95       	ret

00030374 <SP_CommonLPM>:
; ---

.section .text		

SP_CommonLPM:
	movw	ZL, r24             ; Load index into Z.
   30374:	fc 01       	movw	r30, r24
	sts	NVM_CMD, r20        ; Load prepared command into NVM Command register.
   30376:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	lpm	r24,Z
   3037a:	84 91       	lpm	r24, Z
	ret
   3037c:	08 95       	ret

0003037e <SP_CommonSPM>:
; ---

.section .text

SP_CommonSPM:
	movw	ZL, r24          ; Load R25:R24 into Z.
   3037e:	fc 01       	movw	r30, r24
	sts	NVM_CMD, r20     ; Load prepared command into NVM Command register.
   30380:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	ldi	r18, CCP_SPM_gc  ; Prepare Protect SPM signature in R18
   30384:	2d e9       	ldi	r18, 0x9D	; 157
	sts	CCP, r18         ; Enable SPM operation (this disables interrupts for 4 cycles).
   30386:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
	spm                      ; Self-program.
   3038a:	e8 95       	spm
	clr	r1               ; Clear R1 for GCC _zero_reg_ to function properly.
   3038c:	11 24       	eor	r1, r1
	out	RAMPZ, r19       ; Restore RAMPZ register.
   3038e:	3b bf       	out	0x3b, r19	; 59
	ret
   30390:	08 95       	ret

00030392 <AddRoundKey>:
    BlockCopy(output, input);
    memset(output + remainders, 0, KEYLEN - remainders); /* add 0-padding */
    state = (state_t*)output;
    Cipher();
  }
}
   30392:	cf 93       	push	r28
   30394:	df 93       	push	r29
   30396:	60 91 d4 23 	lds	r22, 0x23D4	; 0x8023d4 <state>
   3039a:	70 91 d5 23 	lds	r23, 0x23D5	; 0x8023d5 <state+0x1>
   3039e:	20 e1       	ldi	r18, 0x10	; 16
   303a0:	82 9f       	mul	r24, r18
   303a2:	c0 01       	movw	r24, r0
   303a4:	11 24       	eor	r1, r1
   303a6:	ac 01       	movw	r20, r24
   303a8:	48 5d       	subi	r20, 0xD8	; 216
   303aa:	5c 4d       	sbci	r21, 0xDC	; 220
   303ac:	eb 01       	movw	r28, r22
   303ae:	60 96       	adiw	r28, 0x10	; 16
   303b0:	0e c0       	rjmp	.+28     	; 0x303ce <AddRoundKey+0x3c>
   303b2:	9d 91       	ld	r25, X+
   303b4:	20 81       	ld	r18, Z
   303b6:	92 27       	eor	r25, r18
   303b8:	91 93       	st	Z+, r25
   303ba:	a4 17       	cp	r26, r20
   303bc:	b5 07       	cpc	r27, r21
   303be:	c9 f7       	brne	.-14     	; 0x303b2 <AddRoundKey+0x20>
   303c0:	6c 5f       	subi	r22, 0xFC	; 252
   303c2:	7f 4f       	sbci	r23, 0xFF	; 255
   303c4:	4c 5f       	subi	r20, 0xFC	; 252
   303c6:	5f 4f       	sbci	r21, 0xFF	; 255
   303c8:	6c 17       	cp	r22, r28
   303ca:	7d 07       	cpc	r23, r29
   303cc:	21 f0       	breq	.+8      	; 0x303d6 <AddRoundKey+0x44>
   303ce:	da 01       	movw	r26, r20
   303d0:	14 97       	sbiw	r26, 0x04	; 4
   303d2:	fb 01       	movw	r30, r22
   303d4:	ee cf       	rjmp	.-36     	; 0x303b2 <AddRoundKey+0x20>
   303d6:	df 91       	pop	r29
   303d8:	cf 91       	pop	r28
   303da:	08 95       	ret

000303dc <xtime>:
   303dc:	98 2f       	mov	r25, r24
   303de:	99 1f       	adc	r25, r25
   303e0:	99 27       	eor	r25, r25
   303e2:	99 1f       	adc	r25, r25
   303e4:	2b e1       	ldi	r18, 0x1B	; 27
   303e6:	92 9f       	mul	r25, r18
   303e8:	90 2d       	mov	r25, r0
   303ea:	11 24       	eor	r1, r1
   303ec:	88 0f       	add	r24, r24
   303ee:	89 27       	eor	r24, r25
   303f0:	08 95       	ret

000303f2 <InvSubBytes>:
   303f2:	20 91 d4 23 	lds	r18, 0x23D4	; 0x8023d4 <state>
   303f6:	30 91 d5 23 	lds	r19, 0x23D5	; 0x8023d5 <state+0x1>
   303fa:	b9 01       	movw	r22, r18
   303fc:	6c 5f       	subi	r22, 0xFC	; 252
   303fe:	7f 4f       	sbci	r23, 0xFF	; 255
   30400:	0f c0       	rjmp	.+30     	; 0x30420 <InvSubBytes+0x2e>
   30402:	ec 91       	ld	r30, X
   30404:	f0 e0       	ldi	r31, 0x00	; 0
   30406:	e1 5e       	subi	r30, 0xE1	; 225
   30408:	fe 4d       	sbci	r31, 0xDE	; 222
   3040a:	80 81       	ld	r24, Z
   3040c:	8c 93       	st	X, r24
   3040e:	14 96       	adiw	r26, 0x04	; 4
   30410:	a4 17       	cp	r26, r20
   30412:	b5 07       	cpc	r27, r21
   30414:	b1 f7       	brne	.-20     	; 0x30402 <InvSubBytes+0x10>
   30416:	2f 5f       	subi	r18, 0xFF	; 255
   30418:	3f 4f       	sbci	r19, 0xFF	; 255
   3041a:	62 17       	cp	r22, r18
   3041c:	73 07       	cpc	r23, r19
   3041e:	29 f0       	breq	.+10     	; 0x3042a <InvSubBytes+0x38>
   30420:	a9 01       	movw	r20, r18
   30422:	40 5f       	subi	r20, 0xF0	; 240
   30424:	5f 4f       	sbci	r21, 0xFF	; 255
   30426:	d9 01       	movw	r26, r18
   30428:	ec cf       	rjmp	.-40     	; 0x30402 <InvSubBytes+0x10>
   3042a:	08 95       	ret

0003042c <InvShiftRows>:
   3042c:	e0 91 d4 23 	lds	r30, 0x23D4	; 0x8023d4 <state>
   30430:	f0 91 d5 23 	lds	r31, 0x23D5	; 0x8023d5 <state+0x1>
   30434:	85 85       	ldd	r24, Z+13	; 0x0d
   30436:	91 85       	ldd	r25, Z+9	; 0x09
   30438:	95 87       	std	Z+13, r25	; 0x0d
   3043a:	95 81       	ldd	r25, Z+5	; 0x05
   3043c:	91 87       	std	Z+9, r25	; 0x09
   3043e:	91 81       	ldd	r25, Z+1	; 0x01
   30440:	95 83       	std	Z+5, r25	; 0x05
   30442:	81 83       	std	Z+1, r24	; 0x01
   30444:	82 81       	ldd	r24, Z+2	; 0x02
   30446:	92 85       	ldd	r25, Z+10	; 0x0a
   30448:	92 83       	std	Z+2, r25	; 0x02
   3044a:	82 87       	std	Z+10, r24	; 0x0a
   3044c:	86 81       	ldd	r24, Z+6	; 0x06
   3044e:	96 85       	ldd	r25, Z+14	; 0x0e
   30450:	96 83       	std	Z+6, r25	; 0x06
   30452:	86 87       	std	Z+14, r24	; 0x0e
   30454:	83 81       	ldd	r24, Z+3	; 0x03
   30456:	97 81       	ldd	r25, Z+7	; 0x07
   30458:	93 83       	std	Z+3, r25	; 0x03
   3045a:	93 85       	ldd	r25, Z+11	; 0x0b
   3045c:	97 83       	std	Z+7, r25	; 0x07
   3045e:	97 85       	ldd	r25, Z+15	; 0x0f
   30460:	93 87       	std	Z+11, r25	; 0x0b
   30462:	87 87       	std	Z+15, r24	; 0x0f
   30464:	08 95       	ret

00030466 <InvCipher>:
   30466:	2f 92       	push	r2
   30468:	3f 92       	push	r3
   3046a:	4f 92       	push	r4
   3046c:	5f 92       	push	r5
   3046e:	6f 92       	push	r6
   30470:	7f 92       	push	r7
   30472:	8f 92       	push	r8
   30474:	9f 92       	push	r9
   30476:	af 92       	push	r10
   30478:	bf 92       	push	r11
   3047a:	cf 92       	push	r12
   3047c:	df 92       	push	r13
   3047e:	ef 92       	push	r14
   30480:	ff 92       	push	r15
   30482:	0f 93       	push	r16
   30484:	1f 93       	push	r17
   30486:	cf 93       	push	r28
   30488:	df 93       	push	r29
   3048a:	00 d0       	rcall	.+0      	; 0x3048c <InvCipher+0x26>
   3048c:	1f 92       	push	r1
   3048e:	cd b7       	in	r28, 0x3d	; 61
   30490:	de b7       	in	r29, 0x3e	; 62
   30492:	8a e0       	ldi	r24, 0x0A	; 10
   30494:	7e df       	rcall	.-260    	; 0x30392 <AddRoundKey>
   30496:	0f 2e       	mov	r0, r31
   30498:	f9 e0       	ldi	r31, 0x09	; 9
   3049a:	2f 2e       	mov	r2, r31
   3049c:	f0 2d       	mov	r31, r0
   3049e:	c6 df       	rcall	.-116    	; 0x3042c <InvShiftRows>
   304a0:	a8 df       	rcall	.-176    	; 0x303f2 <InvSubBytes>
   304a2:	82 2d       	mov	r24, r2
   304a4:	76 df       	rcall	.-276    	; 0x30392 <AddRoundKey>
   304a6:	00 91 d4 23 	lds	r16, 0x23D4	; 0x8023d4 <state>
   304aa:	10 91 d5 23 	lds	r17, 0x23D5	; 0x8023d5 <state+0x1>
   304ae:	c8 01       	movw	r24, r16
   304b0:	40 96       	adiw	r24, 0x10	; 16
   304b2:	89 83       	std	Y+1, r24	; 0x01
   304b4:	9a 83       	std	Y+2, r25	; 0x02
   304b6:	f8 01       	movw	r30, r16
   304b8:	c0 80       	ld	r12, Z
   304ba:	d1 80       	ldd	r13, Z+1	; 0x01
   304bc:	e2 80       	ldd	r14, Z+2	; 0x02
   304be:	83 80       	ldd	r8, Z+3	; 0x03
   304c0:	8c 2d       	mov	r24, r12
   304c2:	8c df       	rcall	.-232    	; 0x303dc <xtime>
   304c4:	38 2e       	mov	r3, r24
   304c6:	8a df       	rcall	.-236    	; 0x303dc <xtime>
   304c8:	f8 2e       	mov	r15, r24
   304ca:	88 df       	rcall	.-240    	; 0x303dc <xtime>
   304cc:	98 2e       	mov	r9, r24
   304ce:	8d 2d       	mov	r24, r13
   304d0:	85 df       	rcall	.-246    	; 0x303dc <xtime>
   304d2:	8b 83       	std	Y+3, r24	; 0x03
   304d4:	83 df       	rcall	.-250    	; 0x303dc <xtime>
   304d6:	58 2e       	mov	r5, r24
   304d8:	81 df       	rcall	.-254    	; 0x303dc <xtime>
   304da:	a8 2e       	mov	r10, r24
   304dc:	8e 2d       	mov	r24, r14
   304de:	7e df       	rcall	.-260    	; 0x303dc <xtime>
   304e0:	48 2e       	mov	r4, r24
   304e2:	7c df       	rcall	.-264    	; 0x303dc <xtime>
   304e4:	8c 83       	std	Y+4, r24	; 0x04
   304e6:	7a df       	rcall	.-268    	; 0x303dc <xtime>
   304e8:	b8 2e       	mov	r11, r24
   304ea:	88 2d       	mov	r24, r8
   304ec:	77 df       	rcall	.-274    	; 0x303dc <xtime>
   304ee:	68 2e       	mov	r6, r24
   304f0:	75 df       	rcall	.-278    	; 0x303dc <xtime>
   304f2:	78 2e       	mov	r7, r24
   304f4:	73 df       	rcall	.-282    	; 0x303dc <xtime>
   304f6:	93 2d       	mov	r25, r3
   304f8:	9f 25       	eor	r25, r15
   304fa:	99 25       	eor	r25, r9
   304fc:	fb 81       	ldd	r31, Y+3	; 0x03
   304fe:	9f 27       	eor	r25, r31
   30500:	9a 25       	eor	r25, r10
   30502:	2c 81       	ldd	r18, Y+4	; 0x04
   30504:	92 27       	eor	r25, r18
   30506:	9b 25       	eor	r25, r11
   30508:	98 27       	eor	r25, r24
   3050a:	9d 25       	eor	r25, r13
   3050c:	9e 25       	eor	r25, r14
   3050e:	98 25       	eor	r25, r8
   30510:	f8 01       	movw	r30, r16
   30512:	90 83       	st	Z, r25
   30514:	9b 81       	ldd	r25, Y+3	; 0x03
   30516:	99 25       	eor	r25, r9
   30518:	95 25       	eor	r25, r5
   3051a:	9a 25       	eor	r25, r10
   3051c:	94 25       	eor	r25, r4
   3051e:	9b 25       	eor	r25, r11
   30520:	97 25       	eor	r25, r7
   30522:	98 27       	eor	r25, r24
   30524:	9c 25       	eor	r25, r12
   30526:	9e 25       	eor	r25, r14
   30528:	98 25       	eor	r25, r8
   3052a:	91 83       	std	Z+1, r25	; 0x01
   3052c:	f9 24       	eor	r15, r9
   3052e:	fa 24       	eor	r15, r10
   30530:	4f 24       	eor	r4, r15
   30532:	24 25       	eor	r18, r4
   30534:	2b 25       	eor	r18, r11
   30536:	26 25       	eor	r18, r6
   30538:	28 27       	eor	r18, r24
   3053a:	2c 25       	eor	r18, r12
   3053c:	2d 25       	eor	r18, r13
   3053e:	82 26       	eor	r8, r18
   30540:	82 82       	std	Z+2, r8	; 0x02
   30542:	93 24       	eor	r9, r3
   30544:	95 24       	eor	r9, r5
   30546:	a9 24       	eor	r10, r9
   30548:	ba 24       	eor	r11, r10
   3054a:	b6 24       	eor	r11, r6
   3054c:	7b 24       	eor	r7, r11
   3054e:	87 25       	eor	r24, r7
   30550:	c8 26       	eor	r12, r24
   30552:	dc 24       	eor	r13, r12
   30554:	ed 24       	eor	r14, r13
   30556:	e3 82       	std	Z+3, r14	; 0x03
   30558:	0c 5f       	subi	r16, 0xFC	; 252
   3055a:	1f 4f       	sbci	r17, 0xFF	; 255
   3055c:	89 81       	ldd	r24, Y+1	; 0x01
   3055e:	9a 81       	ldd	r25, Y+2	; 0x02
   30560:	08 17       	cp	r16, r24
   30562:	19 07       	cpc	r17, r25
   30564:	09 f0       	breq	.+2      	; 0x30568 <InvCipher+0x102>
   30566:	a7 cf       	rjmp	.-178    	; 0x304b6 <InvCipher+0x50>
   30568:	2a 94       	dec	r2
   3056a:	21 10       	cpse	r2, r1
   3056c:	98 cf       	rjmp	.-208    	; 0x3049e <InvCipher+0x38>
   3056e:	5e df       	rcall	.-324    	; 0x3042c <InvShiftRows>
   30570:	40 df       	rcall	.-384    	; 0x303f2 <InvSubBytes>
   30572:	80 e0       	ldi	r24, 0x00	; 0
   30574:	0e df       	rcall	.-484    	; 0x30392 <AddRoundKey>
   30576:	24 96       	adiw	r28, 0x04	; 4
   30578:	cd bf       	out	0x3d, r28	; 61
   3057a:	de bf       	out	0x3e, r29	; 62
   3057c:	df 91       	pop	r29
   3057e:	cf 91       	pop	r28
   30580:	1f 91       	pop	r17
   30582:	0f 91       	pop	r16
   30584:	ff 90       	pop	r15
   30586:	ef 90       	pop	r14
   30588:	df 90       	pop	r13
   3058a:	cf 90       	pop	r12
   3058c:	bf 90       	pop	r11
   3058e:	af 90       	pop	r10
   30590:	9f 90       	pop	r9
   30592:	8f 90       	pop	r8
   30594:	7f 90       	pop	r7
   30596:	6f 90       	pop	r6
   30598:	5f 90       	pop	r5
   3059a:	4f 90       	pop	r4
   3059c:	3f 90       	pop	r3
   3059e:	2f 90       	pop	r2
   305a0:	08 95       	ret

000305a2 <BlockCopy>:
   305a2:	fb 01       	movw	r30, r22
   305a4:	dc 01       	movw	r26, r24
   305a6:	9b 01       	movw	r18, r22
   305a8:	20 5f       	subi	r18, 0xF0	; 240
   305aa:	3f 4f       	sbci	r19, 0xFF	; 255
   305ac:	81 91       	ld	r24, Z+
   305ae:	8d 93       	st	X+, r24
   305b0:	e2 17       	cp	r30, r18
   305b2:	f3 07       	cpc	r31, r19
   305b4:	d9 f7       	brne	.-10     	; 0x305ac <BlockCopy+0xa>
   305b6:	08 95       	ret

000305b8 <XorWithIv>:
   305b8:	a0 91 20 23 	lds	r26, 0x2320	; 0x802320 <__data_end>
   305bc:	b0 91 21 23 	lds	r27, 0x2321	; 0x802321 <__data_end+0x1>
   305c0:	fc 01       	movw	r30, r24
   305c2:	ac 01       	movw	r20, r24
   305c4:	40 5f       	subi	r20, 0xF0	; 240
   305c6:	5f 4f       	sbci	r21, 0xFF	; 255
   305c8:	9d 91       	ld	r25, X+
   305ca:	20 81       	ld	r18, Z
   305cc:	92 27       	eor	r25, r18
   305ce:	91 93       	st	Z+, r25
   305d0:	e4 17       	cp	r30, r20
   305d2:	f5 07       	cpc	r31, r21
   305d4:	c9 f7       	brne	.-14     	; 0x305c8 <XorWithIv+0x10>
   305d6:	08 95       	ret

000305d8 <KeyExpansion>:
   305d8:	6f 92       	push	r6
   305da:	7f 92       	push	r7
   305dc:	8f 92       	push	r8
   305de:	9f 92       	push	r9
   305e0:	af 92       	push	r10
   305e2:	bf 92       	push	r11
   305e4:	cf 92       	push	r12
   305e6:	df 92       	push	r13
   305e8:	ef 92       	push	r14
   305ea:	ff 92       	push	r15
   305ec:	1f 93       	push	r17
   305ee:	cf 93       	push	r28
   305f0:	df 93       	push	r29
   305f2:	00 d0       	rcall	.+0      	; 0x305f4 <KeyExpansion+0x1c>
   305f4:	1f 92       	push	r1
   305f6:	cd b7       	in	r28, 0x3d	; 61
   305f8:	de b7       	in	r29, 0x3e	; 62
   305fa:	80 91 22 23 	lds	r24, 0x2322	; 0x802322 <Key>
   305fe:	90 91 23 23 	lds	r25, 0x2323	; 0x802323 <Key+0x1>
   30602:	0f 2e       	mov	r0, r31
   30604:	f4 e2       	ldi	r31, 0x24	; 36
   30606:	6f 2e       	mov	r6, r31
   30608:	f3 e2       	ldi	r31, 0x23	; 35
   3060a:	7f 2e       	mov	r7, r31
   3060c:	f0 2d       	mov	r31, r0
   3060e:	44 e3       	ldi	r20, 0x34	; 52
   30610:	53 e2       	ldi	r21, 0x23	; 35
   30612:	d3 01       	movw	r26, r6
   30614:	fc 01       	movw	r30, r24
   30616:	20 81       	ld	r18, Z
   30618:	2c 93       	st	X, r18
   3061a:	21 81       	ldd	r18, Z+1	; 0x01
   3061c:	11 96       	adiw	r26, 0x01	; 1
   3061e:	2c 93       	st	X, r18
   30620:	11 97       	sbiw	r26, 0x01	; 1
   30622:	22 81       	ldd	r18, Z+2	; 0x02
   30624:	12 96       	adiw	r26, 0x02	; 2
   30626:	2c 93       	st	X, r18
   30628:	12 97       	sbiw	r26, 0x02	; 2
   3062a:	23 81       	ldd	r18, Z+3	; 0x03
   3062c:	13 96       	adiw	r26, 0x03	; 3
   3062e:	2c 93       	st	X, r18
   30630:	13 97       	sbiw	r26, 0x03	; 3
   30632:	04 96       	adiw	r24, 0x04	; 4
   30634:	14 96       	adiw	r26, 0x04	; 4
   30636:	a4 17       	cp	r26, r20
   30638:	b5 07       	cpc	r27, r21
   3063a:	61 f7       	brne	.-40     	; 0x30614 <KeyExpansion+0x3c>
   3063c:	64 ec       	ldi	r22, 0xC4	; 196
   3063e:	73 e2       	ldi	r23, 0x23	; 35
   30640:	c1 2c       	mov	r12, r1
   30642:	d1 2c       	mov	r13, r1
   30644:	76 01       	movw	r14, r12
   30646:	68 94       	set
   30648:	c2 f8       	bld	r12, 2
   3064a:	ae 01       	movw	r20, r28
   3064c:	4b 5f       	subi	r20, 0xFB	; 251
   3064e:	5f 4f       	sbci	r21, 0xFF	; 255
   30650:	58 c0       	rjmp	.+176    	; 0x30702 <KeyExpansion+0x12a>
   30652:	dc 01       	movw	r26, r24
   30654:	2d 91       	ld	r18, X+
   30656:	cd 01       	movw	r24, r26
   30658:	21 93       	st	Z+, r18
   3065a:	e4 17       	cp	r30, r20
   3065c:	f5 07       	cpc	r31, r21
   3065e:	c9 f7       	brne	.-14     	; 0x30652 <KeyExpansion+0x7a>
   30660:	46 01       	movw	r8, r12
   30662:	57 01       	movw	r10, r14
   30664:	b3 e0       	ldi	r27, 0x03	; 3
   30666:	8b 22       	and	r8, r27
   30668:	99 24       	eor	r9, r9
   3066a:	aa 24       	eor	r10, r10
   3066c:	bb 24       	eor	r11, r11
   3066e:	89 28       	or	r8, r9
   30670:	8a 28       	or	r8, r10
   30672:	8b 28       	or	r8, r11
   30674:	51 f5       	brne	.+84     	; 0x306ca <KeyExpansion+0xf2>
   30676:	e9 81       	ldd	r30, Y+1	; 0x01
   30678:	8c 81       	ldd	r24, Y+4	; 0x04
   3067a:	2a 81       	ldd	r18, Y+2	; 0x02
   3067c:	30 e0       	ldi	r19, 0x00	; 0
   3067e:	21 5e       	subi	r18, 0xE1	; 225
   30680:	3d 4d       	sbci	r19, 0xDD	; 221
   30682:	d9 01       	movw	r26, r18
   30684:	1c 91       	ld	r17, X
   30686:	2b 81       	ldd	r18, Y+3	; 0x03
   30688:	30 e0       	ldi	r19, 0x00	; 0
   3068a:	21 5e       	subi	r18, 0xE1	; 225
   3068c:	3d 4d       	sbci	r19, 0xDD	; 221
   3068e:	d9 01       	movw	r26, r18
   30690:	9c 91       	ld	r25, X
   30692:	9a 83       	std	Y+2, r25	; 0x02
   30694:	90 e0       	ldi	r25, 0x00	; 0
   30696:	81 5e       	subi	r24, 0xE1	; 225
   30698:	9d 4d       	sbci	r25, 0xDD	; 221
   3069a:	dc 01       	movw	r26, r24
   3069c:	8c 91       	ld	r24, X
   3069e:	8b 83       	std	Y+3, r24	; 0x03
   306a0:	f0 e0       	ldi	r31, 0x00	; 0
   306a2:	e1 5e       	subi	r30, 0xE1	; 225
   306a4:	fd 4d       	sbci	r31, 0xDD	; 221
   306a6:	80 81       	ld	r24, Z
   306a8:	8c 83       	std	Y+4, r24	; 0x04
   306aa:	46 01       	movw	r8, r12
   306ac:	57 01       	movw	r10, r14
   306ae:	b6 94       	lsr	r11
   306b0:	a7 94       	ror	r10
   306b2:	97 94       	ror	r9
   306b4:	87 94       	ror	r8
   306b6:	b6 94       	lsr	r11
   306b8:	a7 94       	ror	r10
   306ba:	97 94       	ror	r9
   306bc:	87 94       	ror	r8
   306be:	f4 01       	movw	r30, r8
   306c0:	e0 5e       	subi	r30, 0xE0	; 224
   306c2:	ff 4d       	sbci	r31, 0xDF	; 223
   306c4:	80 81       	ld	r24, Z
   306c6:	81 27       	eor	r24, r17
   306c8:	89 83       	std	Y+1, r24	; 0x01
   306ca:	f3 01       	movw	r30, r6
   306cc:	90 81       	ld	r25, Z
   306ce:	89 81       	ldd	r24, Y+1	; 0x01
   306d0:	89 27       	eor	r24, r25
   306d2:	80 8b       	std	Z+16, r24	; 0x10
   306d4:	91 81       	ldd	r25, Z+1	; 0x01
   306d6:	8a 81       	ldd	r24, Y+2	; 0x02
   306d8:	89 27       	eor	r24, r25
   306da:	81 8b       	std	Z+17, r24	; 0x11
   306dc:	92 81       	ldd	r25, Z+2	; 0x02
   306de:	8b 81       	ldd	r24, Y+3	; 0x03
   306e0:	89 27       	eor	r24, r25
   306e2:	82 8b       	std	Z+18, r24	; 0x12
   306e4:	93 81       	ldd	r25, Z+3	; 0x03
   306e6:	8c 81       	ldd	r24, Y+4	; 0x04
   306e8:	89 27       	eor	r24, r25
   306ea:	83 8b       	std	Z+19, r24	; 0x13
   306ec:	ff ef       	ldi	r31, 0xFF	; 255
   306ee:	cf 1a       	sub	r12, r31
   306f0:	df 0a       	sbc	r13, r31
   306f2:	ef 0a       	sbc	r14, r31
   306f4:	ff 0a       	sbc	r15, r31
   306f6:	84 e0       	ldi	r24, 0x04	; 4
   306f8:	68 0e       	add	r6, r24
   306fa:	71 1c       	adc	r7, r1
   306fc:	66 16       	cp	r6, r22
   306fe:	77 06       	cpc	r7, r23
   30700:	29 f0       	breq	.+10     	; 0x3070c <KeyExpansion+0x134>
   30702:	c3 01       	movw	r24, r6
   30704:	0c 96       	adiw	r24, 0x0c	; 12
   30706:	fe 01       	movw	r30, r28
   30708:	31 96       	adiw	r30, 0x01	; 1
   3070a:	a3 cf       	rjmp	.-186    	; 0x30652 <KeyExpansion+0x7a>
   3070c:	24 96       	adiw	r28, 0x04	; 4
   3070e:	cd bf       	out	0x3d, r28	; 61
   30710:	de bf       	out	0x3e, r29	; 62
   30712:	df 91       	pop	r29
   30714:	cf 91       	pop	r28
   30716:	1f 91       	pop	r17
   30718:	ff 90       	pop	r15
   3071a:	ef 90       	pop	r14
   3071c:	df 90       	pop	r13
   3071e:	cf 90       	pop	r12
   30720:	bf 90       	pop	r11
   30722:	af 90       	pop	r10
   30724:	9f 90       	pop	r9
   30726:	8f 90       	pop	r8
   30728:	7f 90       	pop	r7
   3072a:	6f 90       	pop	r6
   3072c:	08 95       	ret

0003072e <AES128_CBC_decrypt_buffer>:

void AES128_CBC_decrypt_buffer(uint8_t* output, uint8_t* input, uint32_t length, const uint8_t* key, const uint8_t* iv)
{
   3072e:	7f 92       	push	r7
   30730:	8f 92       	push	r8
   30732:	9f 92       	push	r9
   30734:	af 92       	push	r10
   30736:	bf 92       	push	r11
   30738:	cf 92       	push	r12
   3073a:	df 92       	push	r13
   3073c:	ef 92       	push	r14
   3073e:	ff 92       	push	r15
   30740:	0f 93       	push	r16
   30742:	1f 93       	push	r17
   30744:	cf 93       	push	r28
   30746:	df 93       	push	r29
   30748:	ec 01       	movw	r28, r24
   3074a:	6b 01       	movw	r12, r22
   3074c:	49 01       	movw	r8, r18
   3074e:	5a 01       	movw	r10, r20
  uintptr_t i;
  uint8_t remainders = length % KEYLEN; /* Remaining bytes in the last non-full block */
   30750:	82 2f       	mov	r24, r18
   30752:	8f 70       	andi	r24, 0x0F	; 15
   30754:	78 2e       	mov	r7, r24
  
  BlockCopy(output, input);
   30756:	ce 01       	movw	r24, r28
   30758:	24 df       	rcall	.-440    	; 0x305a2 <BlockCopy>
  state = (state_t*)output;
   3075a:	c0 93 d4 23 	sts	0x23D4, r28	; 0x8023d4 <state>
   3075e:	d0 93 d5 23 	sts	0x23D5, r29	; 0x8023d5 <state+0x1>

  // Skip the key expansion if key is passed as 0
  if(0 != key)
   30762:	01 15       	cp	r16, r1
   30764:	11 05       	cpc	r17, r1
   30766:	29 f0       	breq	.+10     	; 0x30772 <AES128_CBC_decrypt_buffer+0x44>
  {
    Key = key;
   30768:	00 93 22 23 	sts	0x2322, r16	; 0x802322 <Key>
   3076c:	10 93 23 23 	sts	0x2323, r17	; 0x802323 <Key+0x1>
    KeyExpansion();
   30770:	33 df       	rcall	.-410    	; 0x305d8 <KeyExpansion>
  }

  // If iv is passed as 0, we continue to encrypt without re-setting the Iv
  if(iv != 0)
   30772:	e1 14       	cp	r14, r1
   30774:	f1 04       	cpc	r15, r1
   30776:	21 f0       	breq	.+8      	; 0x30780 <AES128_CBC_decrypt_buffer+0x52>
  {
    Iv = (uint8_t*)iv;
   30778:	e0 92 20 23 	sts	0x2320, r14	; 0x802320 <__data_end>
   3077c:	f0 92 21 23 	sts	0x2321, r15	; 0x802321 <__data_end+0x1>
  }

  for(i = 0; i < length; i += KEYLEN)
   30780:	81 14       	cp	r8, r1
   30782:	91 04       	cpc	r9, r1
   30784:	a1 04       	cpc	r10, r1
   30786:	b1 04       	cpc	r11, r1
   30788:	f1 f0       	breq	.+60     	; 0x307c6 <AES128_CBC_decrypt_buffer+0x98>
   3078a:	00 e0       	ldi	r16, 0x00	; 0
   3078c:	10 e0       	ldi	r17, 0x00	; 0
  {
    BlockCopy(output, input);
   3078e:	b6 01       	movw	r22, r12
   30790:	ce 01       	movw	r24, r28
   30792:	07 df       	rcall	.-498    	; 0x305a2 <BlockCopy>
    state = (state_t*)output;
   30794:	c0 93 d4 23 	sts	0x23D4, r28	; 0x8023d4 <state>
   30798:	d0 93 d5 23 	sts	0x23D5, r29	; 0x8023d5 <state+0x1>
    InvCipher();
   3079c:	64 de       	rcall	.-824    	; 0x30466 <InvCipher>
    XorWithIv(output);
   3079e:	ce 01       	movw	r24, r28
   307a0:	0b df       	rcall	.-490    	; 0x305b8 <XorWithIv>
   307a2:	c0 92 20 23 	sts	0x2320, r12	; 0x802320 <__data_end>
    Iv = input;
   307a6:	d0 92 21 23 	sts	0x2321, r13	; 0x802321 <__data_end+0x1>
   307aa:	80 e1       	ldi	r24, 0x10	; 16
    input += KEYLEN;
   307ac:	c8 0e       	add	r12, r24
   307ae:	d1 1c       	adc	r13, r1
   307b0:	60 96       	adiw	r28, 0x10	; 16
    output += KEYLEN;
   307b2:	00 5f       	subi	r16, 0xF0	; 240
  if(iv != 0)
  {
    Iv = (uint8_t*)iv;
  }

  for(i = 0; i < length; i += KEYLEN)
   307b4:	1f 4f       	sbci	r17, 0xFF	; 255
   307b6:	c8 01       	movw	r24, r16
   307b8:	a0 e0       	ldi	r26, 0x00	; 0
   307ba:	b0 e0       	ldi	r27, 0x00	; 0
   307bc:	88 15       	cp	r24, r8
   307be:	99 05       	cpc	r25, r9
   307c0:	aa 05       	cpc	r26, r10
   307c2:	bb 05       	cpc	r27, r11
   307c4:	20 f3       	brcs	.-56     	; 0x3078e <AES128_CBC_decrypt_buffer+0x60>
    Iv = input;
    input += KEYLEN;
    output += KEYLEN;
  }

  if(remainders)
   307c6:	77 20       	and	r7, r7
   307c8:	a1 f0       	breq	.+40     	; 0x307f2 <AES128_CBC_decrypt_buffer+0xc4>
  {
    BlockCopy(output, input);
   307ca:	b6 01       	movw	r22, r12
   307cc:	ce 01       	movw	r24, r28
   307ce:	e9 de       	rcall	.-558    	; 0x305a2 <BlockCopy>
   307d0:	87 2d       	mov	r24, r7
    memset(output+remainders, 0, KEYLEN - remainders); /* add 0-padding */
   307d2:	90 e0       	ldi	r25, 0x00	; 0
   307d4:	40 e1       	ldi	r20, 0x10	; 16
   307d6:	50 e0       	ldi	r21, 0x00	; 0
   307d8:	48 1b       	sub	r20, r24
   307da:	59 0b       	sbc	r21, r25
   307dc:	60 e0       	ldi	r22, 0x00	; 0
   307de:	70 e0       	ldi	r23, 0x00	; 0
   307e0:	8c 0f       	add	r24, r28
   307e2:	9d 1f       	adc	r25, r29
   307e4:	0f 94 08 8c 	call	0x31810	; 0x31810 <memset>
    state = (state_t*)output;
   307e8:	c0 93 d4 23 	sts	0x23D4, r28	; 0x8023d4 <state>
   307ec:	d0 93 d5 23 	sts	0x23D5, r29	; 0x8023d5 <state+0x1>
    InvCipher();
   307f0:	3a de       	rcall	.-908    	; 0x30466 <InvCipher>
   307f2:	df 91       	pop	r29
  }
}
   307f4:	cf 91       	pop	r28
   307f6:	1f 91       	pop	r17
   307f8:	0f 91       	pop	r16
   307fa:	ff 90       	pop	r15
   307fc:	ef 90       	pop	r14
   307fe:	df 90       	pop	r13
   30800:	cf 90       	pop	r12
   30802:	bf 90       	pop	r11
   30804:	af 90       	pop	r10
   30806:	9f 90       	pop	r9
   30808:	8f 90       	pop	r8
   3080a:	7f 90       	pop	r7
   3080c:	08 95       	ret

0003080e <mcp2515_readXXStatus_helper>:
   3080e:	0f 93       	push	r16
}

uint8_t mcp2515_RXStatus(void)
{
	return mcp2515_readXXStatus_helper(MCP_RX_STATUS);
}
   30810:	1f 93       	push	r17
   30812:	cf 93       	push	r28
   30814:	df 93       	push	r29
   30816:	00 e8       	ldi	r16, 0x80	; 128
   30818:	16 e0       	ldi	r17, 0x06	; 6
   3081a:	f8 01       	movw	r30, r16
   3081c:	90 81       	ld	r25, Z
   3081e:	98 60       	ori	r25, 0x08	; 8
   30820:	90 83       	st	Z, r25
   30822:	c4 e8       	ldi	r28, 0x84	; 132
   30824:	d6 e0       	ldi	r29, 0x06	; 6
   30826:	98 81       	ld	r25, Y
   30828:	97 7f       	andi	r25, 0xF7	; 247
   3082a:	98 83       	st	Y, r25
   3082c:	ef ea       	ldi	r30, 0xAF	; 175
   3082e:	f4 e0       	ldi	r31, 0x04	; 4
   30830:	31 97       	sbiw	r30, 0x01	; 1
   30832:	f1 f7       	brne	.-4      	; 0x30830 <mcp2515_readXXStatus_helper+0x22>
   30834:	00 c0       	rjmp	.+0      	; 0x30836 <mcp2515_readXXStatus_helper+0x28>
   30836:	00 00       	nop
   30838:	ba d7       	rcall	.+3956   	; 0x317ae <spi_transfer>
   3083a:	80 e0       	ldi	r24, 0x00	; 0
   3083c:	b8 d7       	rcall	.+3952   	; 0x317ae <spi_transfer>
   3083e:	f8 01       	movw	r30, r16
   30840:	90 81       	ld	r25, Z
   30842:	98 60       	ori	r25, 0x08	; 8
   30844:	90 83       	st	Z, r25
   30846:	98 81       	ld	r25, Y
   30848:	98 60       	ori	r25, 0x08	; 8
   3084a:	98 83       	st	Y, r25
   3084c:	ef ea       	ldi	r30, 0xAF	; 175
   3084e:	f4 e0       	ldi	r31, 0x04	; 4
   30850:	31 97       	sbiw	r30, 0x01	; 1
   30852:	f1 f7       	brne	.-4      	; 0x30850 <mcp2515_readXXStatus_helper+0x42>
   30854:	00 c0       	rjmp	.+0      	; 0x30856 <mcp2515_readXXStatus_helper+0x48>
   30856:	00 00       	nop
   30858:	df 91       	pop	r29
   3085a:	cf 91       	pop	r28
   3085c:	1f 91       	pop	r17
   3085e:	0f 91       	pop	r16
   30860:	08 95       	ret

00030862 <mcp2515_reset>:
   30862:	0f 93       	push	r16
   30864:	1f 93       	push	r17
   30866:	cf 93       	push	r28
   30868:	df 93       	push	r29
   3086a:	00 e8       	ldi	r16, 0x80	; 128
   3086c:	16 e0       	ldi	r17, 0x06	; 6
   3086e:	f8 01       	movw	r30, r16
   30870:	80 81       	ld	r24, Z
   30872:	88 60       	ori	r24, 0x08	; 8
   30874:	80 83       	st	Z, r24
   30876:	c4 e8       	ldi	r28, 0x84	; 132
   30878:	d6 e0       	ldi	r29, 0x06	; 6
   3087a:	88 81       	ld	r24, Y
   3087c:	87 7f       	andi	r24, 0xF7	; 247
   3087e:	88 83       	st	Y, r24
   30880:	8f ea       	ldi	r24, 0xAF	; 175
   30882:	94 e0       	ldi	r25, 0x04	; 4
   30884:	01 97       	sbiw	r24, 0x01	; 1
   30886:	f1 f7       	brne	.-4      	; 0x30884 <mcp2515_reset+0x22>
   30888:	00 c0       	rjmp	.+0      	; 0x3088a <mcp2515_reset+0x28>
   3088a:	00 00       	nop
   3088c:	80 ec       	ldi	r24, 0xC0	; 192
   3088e:	8f d7       	rcall	.+3870   	; 0x317ae <spi_transfer>
   30890:	f8 01       	movw	r30, r16
   30892:	80 81       	ld	r24, Z
   30894:	88 60       	ori	r24, 0x08	; 8
   30896:	80 83       	st	Z, r24
   30898:	88 81       	ld	r24, Y
   3089a:	88 60       	ori	r24, 0x08	; 8
   3089c:	88 83       	st	Y, r24
   3089e:	8f ea       	ldi	r24, 0xAF	; 175
   308a0:	94 e0       	ldi	r25, 0x04	; 4
   308a2:	01 97       	sbiw	r24, 0x01	; 1
   308a4:	f1 f7       	brne	.-4      	; 0x308a2 <mcp2515_reset+0x40>
   308a6:	00 c0       	rjmp	.+0      	; 0x308a8 <mcp2515_reset+0x46>
   308a8:	00 00       	nop
   308aa:	ef e5       	ldi	r30, 0x5F	; 95
   308ac:	fa ee       	ldi	r31, 0xEA	; 234
   308ae:	31 97       	sbiw	r30, 0x01	; 1
   308b0:	f1 f7       	brne	.-4      	; 0x308ae <mcp2515_reset+0x4c>
   308b2:	00 c0       	rjmp	.+0      	; 0x308b4 <mcp2515_reset+0x52>
   308b4:	00 00       	nop
   308b6:	df 91       	pop	r29
   308b8:	cf 91       	pop	r28
   308ba:	1f 91       	pop	r17
   308bc:	0f 91       	pop	r16
   308be:	08 95       	ret

000308c0 <mcp2515_readRegister>:
   308c0:	ff 92       	push	r15
   308c2:	0f 93       	push	r16
   308c4:	1f 93       	push	r17
   308c6:	cf 93       	push	r28
   308c8:	df 93       	push	r29
   308ca:	f8 2e       	mov	r15, r24
   308cc:	00 e8       	ldi	r16, 0x80	; 128
   308ce:	16 e0       	ldi	r17, 0x06	; 6
   308d0:	f8 01       	movw	r30, r16
   308d2:	80 81       	ld	r24, Z
   308d4:	88 60       	ori	r24, 0x08	; 8
   308d6:	80 83       	st	Z, r24
   308d8:	c4 e8       	ldi	r28, 0x84	; 132
   308da:	d6 e0       	ldi	r29, 0x06	; 6
   308dc:	88 81       	ld	r24, Y
   308de:	87 7f       	andi	r24, 0xF7	; 247
   308e0:	88 83       	st	Y, r24
   308e2:	8f ea       	ldi	r24, 0xAF	; 175
   308e4:	94 e0       	ldi	r25, 0x04	; 4
   308e6:	01 97       	sbiw	r24, 0x01	; 1
   308e8:	f1 f7       	brne	.-4      	; 0x308e6 <mcp2515_readRegister+0x26>
   308ea:	00 c0       	rjmp	.+0      	; 0x308ec <mcp2515_readRegister+0x2c>
   308ec:	00 00       	nop
   308ee:	83 e0       	ldi	r24, 0x03	; 3
   308f0:	5e d7       	rcall	.+3772   	; 0x317ae <spi_transfer>
   308f2:	8f 2d       	mov	r24, r15
   308f4:	5c d7       	rcall	.+3768   	; 0x317ae <spi_transfer>
   308f6:	80 e0       	ldi	r24, 0x00	; 0
   308f8:	5a d7       	rcall	.+3764   	; 0x317ae <spi_transfer>
   308fa:	f8 01       	movw	r30, r16
   308fc:	90 81       	ld	r25, Z
   308fe:	98 60       	ori	r25, 0x08	; 8
   30900:	90 83       	st	Z, r25
   30902:	98 81       	ld	r25, Y
   30904:	98 60       	ori	r25, 0x08	; 8
   30906:	98 83       	st	Y, r25
   30908:	ef ea       	ldi	r30, 0xAF	; 175
   3090a:	f4 e0       	ldi	r31, 0x04	; 4
   3090c:	31 97       	sbiw	r30, 0x01	; 1
   3090e:	f1 f7       	brne	.-4      	; 0x3090c <mcp2515_readRegister+0x4c>
   30910:	00 c0       	rjmp	.+0      	; 0x30912 <mcp2515_readRegister+0x52>
   30912:	00 00       	nop
   30914:	df 91       	pop	r29
   30916:	cf 91       	pop	r28
   30918:	1f 91       	pop	r17
   3091a:	0f 91       	pop	r16
   3091c:	ff 90       	pop	r15
   3091e:	08 95       	ret

00030920 <mcp2515_readRegisterS>:
   30920:	ef 92       	push	r14
   30922:	ff 92       	push	r15
   30924:	0f 93       	push	r16
   30926:	1f 93       	push	r17
   30928:	cf 93       	push	r28
   3092a:	df 93       	push	r29
   3092c:	c8 2f       	mov	r28, r24
   3092e:	7b 01       	movw	r14, r22
   30930:	14 2f       	mov	r17, r20
   30932:	e0 e8       	ldi	r30, 0x80	; 128
   30934:	f6 e0       	ldi	r31, 0x06	; 6
   30936:	80 81       	ld	r24, Z
   30938:	88 60       	ori	r24, 0x08	; 8
   3093a:	80 83       	st	Z, r24
   3093c:	e4 e8       	ldi	r30, 0x84	; 132
   3093e:	f6 e0       	ldi	r31, 0x06	; 6
   30940:	80 81       	ld	r24, Z
   30942:	87 7f       	andi	r24, 0xF7	; 247
   30944:	80 83       	st	Z, r24
   30946:	8f ea       	ldi	r24, 0xAF	; 175
   30948:	94 e0       	ldi	r25, 0x04	; 4
   3094a:	01 97       	sbiw	r24, 0x01	; 1
   3094c:	f1 f7       	brne	.-4      	; 0x3094a <mcp2515_readRegisterS+0x2a>
   3094e:	00 c0       	rjmp	.+0      	; 0x30950 <mcp2515_readRegisterS+0x30>
   30950:	00 00       	nop
   30952:	83 e0       	ldi	r24, 0x03	; 3
   30954:	2c d7       	rcall	.+3672   	; 0x317ae <spi_transfer>
   30956:	8c 2f       	mov	r24, r28
   30958:	2a d7       	rcall	.+3668   	; 0x317ae <spi_transfer>
   3095a:	11 23       	and	r17, r17
   3095c:	71 f0       	breq	.+28     	; 0x3097a <mcp2515_readRegisterS+0x5a>
   3095e:	e7 01       	movw	r28, r14
   30960:	11 50       	subi	r17, 0x01	; 1
   30962:	01 2f       	mov	r16, r17
   30964:	10 e0       	ldi	r17, 0x00	; 0
   30966:	0f 5f       	subi	r16, 0xFF	; 255
   30968:	1f 4f       	sbci	r17, 0xFF	; 255
   3096a:	0e 0d       	add	r16, r14
   3096c:	1f 1d       	adc	r17, r15
   3096e:	80 e0       	ldi	r24, 0x00	; 0
   30970:	1e d7       	rcall	.+3644   	; 0x317ae <spi_transfer>
   30972:	89 93       	st	Y+, r24
   30974:	c0 17       	cp	r28, r16
   30976:	d1 07       	cpc	r29, r17
   30978:	d1 f7       	brne	.-12     	; 0x3096e <mcp2515_readRegisterS+0x4e>
   3097a:	e0 e8       	ldi	r30, 0x80	; 128
   3097c:	f6 e0       	ldi	r31, 0x06	; 6
   3097e:	80 81       	ld	r24, Z
   30980:	88 60       	ori	r24, 0x08	; 8
   30982:	80 83       	st	Z, r24
   30984:	e4 e8       	ldi	r30, 0x84	; 132
   30986:	f6 e0       	ldi	r31, 0x06	; 6
   30988:	80 81       	ld	r24, Z
   3098a:	88 60       	ori	r24, 0x08	; 8
   3098c:	80 83       	st	Z, r24
   3098e:	8f ea       	ldi	r24, 0xAF	; 175
   30990:	94 e0       	ldi	r25, 0x04	; 4
   30992:	01 97       	sbiw	r24, 0x01	; 1
   30994:	f1 f7       	brne	.-4      	; 0x30992 <mcp2515_readRegisterS+0x72>
   30996:	00 c0       	rjmp	.+0      	; 0x30998 <mcp2515_readRegisterS+0x78>
   30998:	00 00       	nop
   3099a:	df 91       	pop	r29
   3099c:	cf 91       	pop	r28
   3099e:	1f 91       	pop	r17
   309a0:	0f 91       	pop	r16
   309a2:	ff 90       	pop	r15
   309a4:	ef 90       	pop	r14
   309a6:	08 95       	ret

000309a8 <mcp2515_setRegister>:
   309a8:	ef 92       	push	r14
   309aa:	ff 92       	push	r15
   309ac:	0f 93       	push	r16
   309ae:	1f 93       	push	r17
   309b0:	cf 93       	push	r28
   309b2:	df 93       	push	r29
   309b4:	e8 2e       	mov	r14, r24
   309b6:	f6 2e       	mov	r15, r22
   309b8:	00 e8       	ldi	r16, 0x80	; 128
   309ba:	16 e0       	ldi	r17, 0x06	; 6
   309bc:	f8 01       	movw	r30, r16
   309be:	80 81       	ld	r24, Z
   309c0:	88 60       	ori	r24, 0x08	; 8
   309c2:	80 83       	st	Z, r24
   309c4:	c4 e8       	ldi	r28, 0x84	; 132
   309c6:	d6 e0       	ldi	r29, 0x06	; 6
   309c8:	88 81       	ld	r24, Y
   309ca:	87 7f       	andi	r24, 0xF7	; 247
   309cc:	88 83       	st	Y, r24
   309ce:	8f ea       	ldi	r24, 0xAF	; 175
   309d0:	94 e0       	ldi	r25, 0x04	; 4
   309d2:	01 97       	sbiw	r24, 0x01	; 1
   309d4:	f1 f7       	brne	.-4      	; 0x309d2 <mcp2515_setRegister+0x2a>
   309d6:	00 c0       	rjmp	.+0      	; 0x309d8 <mcp2515_setRegister+0x30>
   309d8:	00 00       	nop
   309da:	82 e0       	ldi	r24, 0x02	; 2
   309dc:	e8 d6       	rcall	.+3536   	; 0x317ae <spi_transfer>
   309de:	8e 2d       	mov	r24, r14
   309e0:	e6 d6       	rcall	.+3532   	; 0x317ae <spi_transfer>
   309e2:	8f 2d       	mov	r24, r15
   309e4:	e4 d6       	rcall	.+3528   	; 0x317ae <spi_transfer>
   309e6:	f8 01       	movw	r30, r16
   309e8:	80 81       	ld	r24, Z
   309ea:	88 60       	ori	r24, 0x08	; 8
   309ec:	80 83       	st	Z, r24
   309ee:	88 81       	ld	r24, Y
   309f0:	88 60       	ori	r24, 0x08	; 8
   309f2:	88 83       	st	Y, r24
   309f4:	8f ea       	ldi	r24, 0xAF	; 175
   309f6:	94 e0       	ldi	r25, 0x04	; 4
   309f8:	01 97       	sbiw	r24, 0x01	; 1
   309fa:	f1 f7       	brne	.-4      	; 0x309f8 <mcp2515_setRegister+0x50>
   309fc:	00 c0       	rjmp	.+0      	; 0x309fe <mcp2515_setRegister+0x56>
   309fe:	00 00       	nop
   30a00:	df 91       	pop	r29
   30a02:	cf 91       	pop	r28
   30a04:	1f 91       	pop	r17
   30a06:	0f 91       	pop	r16
   30a08:	ff 90       	pop	r15
   30a0a:	ef 90       	pop	r14
   30a0c:	08 95       	ret

00030a0e <mcp2515_setRegisterS>:
   30a0e:	ef 92       	push	r14
   30a10:	ff 92       	push	r15
   30a12:	0f 93       	push	r16
   30a14:	1f 93       	push	r17
   30a16:	cf 93       	push	r28
   30a18:	df 93       	push	r29
   30a1a:	c8 2f       	mov	r28, r24
   30a1c:	7b 01       	movw	r14, r22
   30a1e:	14 2f       	mov	r17, r20
   30a20:	e0 e8       	ldi	r30, 0x80	; 128
   30a22:	f6 e0       	ldi	r31, 0x06	; 6
   30a24:	80 81       	ld	r24, Z
   30a26:	88 60       	ori	r24, 0x08	; 8
   30a28:	80 83       	st	Z, r24
   30a2a:	e4 e8       	ldi	r30, 0x84	; 132
   30a2c:	f6 e0       	ldi	r31, 0x06	; 6
   30a2e:	80 81       	ld	r24, Z
   30a30:	87 7f       	andi	r24, 0xF7	; 247
   30a32:	80 83       	st	Z, r24
   30a34:	8f ea       	ldi	r24, 0xAF	; 175
   30a36:	94 e0       	ldi	r25, 0x04	; 4
   30a38:	01 97       	sbiw	r24, 0x01	; 1
   30a3a:	f1 f7       	brne	.-4      	; 0x30a38 <mcp2515_setRegisterS+0x2a>
   30a3c:	00 c0       	rjmp	.+0      	; 0x30a3e <mcp2515_setRegisterS+0x30>
   30a3e:	00 00       	nop
   30a40:	82 e0       	ldi	r24, 0x02	; 2
   30a42:	b5 d6       	rcall	.+3434   	; 0x317ae <spi_transfer>
   30a44:	8c 2f       	mov	r24, r28
   30a46:	b3 d6       	rcall	.+3430   	; 0x317ae <spi_transfer>
   30a48:	11 23       	and	r17, r17
   30a4a:	69 f0       	breq	.+26     	; 0x30a66 <mcp2515_setRegisterS+0x58>
   30a4c:	e7 01       	movw	r28, r14
   30a4e:	11 50       	subi	r17, 0x01	; 1
   30a50:	01 2f       	mov	r16, r17
   30a52:	10 e0       	ldi	r17, 0x00	; 0
   30a54:	0f 5f       	subi	r16, 0xFF	; 255
   30a56:	1f 4f       	sbci	r17, 0xFF	; 255
   30a58:	0e 0d       	add	r16, r14
   30a5a:	1f 1d       	adc	r17, r15
   30a5c:	89 91       	ld	r24, Y+
   30a5e:	a7 d6       	rcall	.+3406   	; 0x317ae <spi_transfer>
   30a60:	c0 17       	cp	r28, r16
   30a62:	d1 07       	cpc	r29, r17
   30a64:	d9 f7       	brne	.-10     	; 0x30a5c <mcp2515_setRegisterS+0x4e>
   30a66:	e0 e8       	ldi	r30, 0x80	; 128
   30a68:	f6 e0       	ldi	r31, 0x06	; 6
   30a6a:	80 81       	ld	r24, Z
   30a6c:	88 60       	ori	r24, 0x08	; 8
   30a6e:	80 83       	st	Z, r24
   30a70:	e4 e8       	ldi	r30, 0x84	; 132
   30a72:	f6 e0       	ldi	r31, 0x06	; 6
   30a74:	80 81       	ld	r24, Z
   30a76:	88 60       	ori	r24, 0x08	; 8
   30a78:	80 83       	st	Z, r24
   30a7a:	8f ea       	ldi	r24, 0xAF	; 175
   30a7c:	94 e0       	ldi	r25, 0x04	; 4
   30a7e:	01 97       	sbiw	r24, 0x01	; 1
   30a80:	f1 f7       	brne	.-4      	; 0x30a7e <mcp2515_setRegisterS+0x70>
   30a82:	00 c0       	rjmp	.+0      	; 0x30a84 <mcp2515_setRegisterS+0x76>
   30a84:	00 00       	nop
   30a86:	df 91       	pop	r29
   30a88:	cf 91       	pop	r28
   30a8a:	1f 91       	pop	r17
   30a8c:	0f 91       	pop	r16
   30a8e:	ff 90       	pop	r15
   30a90:	ef 90       	pop	r14
   30a92:	08 95       	ret

00030a94 <mcp2515_modifyRegister>:
   30a94:	df 92       	push	r13
   30a96:	ef 92       	push	r14
   30a98:	ff 92       	push	r15
   30a9a:	0f 93       	push	r16
   30a9c:	1f 93       	push	r17
   30a9e:	cf 93       	push	r28
   30aa0:	df 93       	push	r29
   30aa2:	d8 2e       	mov	r13, r24
   30aa4:	e6 2e       	mov	r14, r22
   30aa6:	f4 2e       	mov	r15, r20
   30aa8:	00 e8       	ldi	r16, 0x80	; 128
   30aaa:	16 e0       	ldi	r17, 0x06	; 6
   30aac:	f8 01       	movw	r30, r16
   30aae:	80 81       	ld	r24, Z
   30ab0:	88 60       	ori	r24, 0x08	; 8
   30ab2:	80 83       	st	Z, r24
   30ab4:	c4 e8       	ldi	r28, 0x84	; 132
   30ab6:	d6 e0       	ldi	r29, 0x06	; 6
   30ab8:	88 81       	ld	r24, Y
   30aba:	87 7f       	andi	r24, 0xF7	; 247
   30abc:	88 83       	st	Y, r24
   30abe:	8f ea       	ldi	r24, 0xAF	; 175
   30ac0:	94 e0       	ldi	r25, 0x04	; 4
   30ac2:	01 97       	sbiw	r24, 0x01	; 1
   30ac4:	f1 f7       	brne	.-4      	; 0x30ac2 <mcp2515_modifyRegister+0x2e>
   30ac6:	00 c0       	rjmp	.+0      	; 0x30ac8 <mcp2515_modifyRegister+0x34>
   30ac8:	00 00       	nop
   30aca:	85 e0       	ldi	r24, 0x05	; 5
   30acc:	70 d6       	rcall	.+3296   	; 0x317ae <spi_transfer>
   30ace:	8d 2d       	mov	r24, r13
   30ad0:	6e d6       	rcall	.+3292   	; 0x317ae <spi_transfer>
   30ad2:	8e 2d       	mov	r24, r14
   30ad4:	6c d6       	rcall	.+3288   	; 0x317ae <spi_transfer>
   30ad6:	8f 2d       	mov	r24, r15
   30ad8:	6a d6       	rcall	.+3284   	; 0x317ae <spi_transfer>
   30ada:	f8 01       	movw	r30, r16
   30adc:	80 81       	ld	r24, Z
   30ade:	88 60       	ori	r24, 0x08	; 8
   30ae0:	80 83       	st	Z, r24
   30ae2:	88 81       	ld	r24, Y
   30ae4:	88 60       	ori	r24, 0x08	; 8
   30ae6:	88 83       	st	Y, r24
   30ae8:	8f ea       	ldi	r24, 0xAF	; 175
   30aea:	94 e0       	ldi	r25, 0x04	; 4
   30aec:	01 97       	sbiw	r24, 0x01	; 1
   30aee:	f1 f7       	brne	.-4      	; 0x30aec <mcp2515_modifyRegister+0x58>
   30af0:	00 c0       	rjmp	.+0      	; 0x30af2 <mcp2515_modifyRegister+0x5e>
   30af2:	00 00       	nop
   30af4:	df 91       	pop	r29
   30af6:	cf 91       	pop	r28
   30af8:	1f 91       	pop	r17
   30afa:	0f 91       	pop	r16
   30afc:	ff 90       	pop	r15
   30afe:	ef 90       	pop	r14
   30b00:	df 90       	pop	r13
   30b02:	08 95       	ret

00030b04 <mcp2515_readStatus>:
   30b04:	80 ea       	ldi	r24, 0xA0	; 160
   30b06:	83 ce       	rjmp	.-762    	; 0x3080e <mcp2515_readXXStatus_helper>
   30b08:	08 95       	ret

00030b0a <mcp2515_setCANCTRL_Mode>:

uint8_t mcp2515_setCANCTRL_Mode(const uint8_t newmode)
{
   30b0a:	cf 93       	push	r28
   30b0c:	c8 2f       	mov	r28, r24
	uint8_t i;
	
	// uart_write("Modifying register\r\n");
	mcp2515_modifyRegister(MCP_CANCTRL, MODE_MASK, newmode);
   30b0e:	48 2f       	mov	r20, r24
   30b10:	60 ee       	ldi	r22, 0xE0	; 224
   30b12:	8f e0       	ldi	r24, 0x0F	; 15
   30b14:	bf df       	rcall	.-130    	; 0x30a94 <mcp2515_modifyRegister>
	
	// return MCP2515_OK;
	
	// verify as advised in datasheet
	i = mcp2515_readRegister(MCP_CANCTRL);
   30b16:	8f e0       	ldi	r24, 0x0F	; 15
   30b18:	d3 de       	rcall	.-602    	; 0x308c0 <mcp2515_readRegister>
   30b1a:	98 2f       	mov	r25, r24
   30b1c:	90 7e       	andi	r25, 0xE0	; 224
   30b1e:	81 e0       	ldi	r24, 0x01	; 1
   30b20:	9c 13       	cpse	r25, r28
   30b22:	01 c0       	rjmp	.+2      	; 0x30b26 <mcp2515_setCANCTRL_Mode+0x1c>
   30b24:	80 e0       	ldi	r24, 0x00	; 0
		return MCP2515_OK; 
	}
	else {
		return MCP2515_FAIL;
	}
}
   30b26:	cf 91       	pop	r28
   30b28:	08 95       	ret

00030b2a <mcp2515_configRate>:


uint8_t mcp2515_configRate(const uint16_t canSpeed)
{
   30b2a:	cf 93       	push	r28
   30b2c:	df 93       	push	r29
	uint8_t set, cfg1, cfg2, cfg3;
	
	set = 1;
	switch (canSpeed)
   30b2e:	88 3c       	cpi	r24, 0xC8	; 200
   30b30:	91 05       	cpc	r25, r1
   30b32:	a1 f0       	breq	.+40     	; 0x30b5c <mcp2515_configRate+0x32>
   30b34:	38 f4       	brcc	.+14     	; 0x30b44 <mcp2515_configRate+0x1a>
   30b36:	8a 30       	cpi	r24, 0x0A	; 10
   30b38:	91 05       	cpc	r25, r1
   30b3a:	e1 f0       	breq	.+56     	; 0x30b74 <mcp2515_configRate+0x4a>
   30b3c:	8d 37       	cpi	r24, 0x7D	; 125
   30b3e:	91 05       	cpc	r25, r1
   30b40:	41 f1       	breq	.+80     	; 0x30b92 <mcp2515_configRate+0x68>
   30b42:	25 c0       	rjmp	.+74     	; 0x30b8e <mcp2515_configRate+0x64>
   30b44:	84 3f       	cpi	r24, 0xF4	; 244
   30b46:	21 e0       	ldi	r18, 0x01	; 1
   30b48:	92 07       	cpc	r25, r18
   30b4a:	61 f0       	breq	.+24     	; 0x30b64 <mcp2515_configRate+0x3a>
   30b4c:	88 3e       	cpi	r24, 0xE8	; 232
   30b4e:	23 e0       	ldi	r18, 0x03	; 3
   30b50:	92 07       	cpc	r25, r18
   30b52:	61 f0       	breq	.+24     	; 0x30b6c <mcp2515_configRate+0x42>
   30b54:	8a 3f       	cpi	r24, 0xFA	; 250
   30b56:	91 05       	cpc	r25, r1
   30b58:	d1 f4       	brne	.+52     	; 0x30b8e <mcp2515_configRate+0x64>
   30b5a:	1f c0       	rjmp	.+62     	; 0x30b9a <mcp2515_configRate+0x70>
		}
		case 200:
		{
			cfg1 = 0x01;
			cfg2 = 0xFA;
			cfg3 = 0x87;
   30b5c:	d7 e8       	ldi	r29, 0x87	; 135
			break;
		}
		case 200:
		{
			cfg1 = 0x01;
			cfg2 = 0xFA;
   30b5e:	ca ef       	ldi	r28, 0xFA	; 250
			cfg3 = 0x86;
			break;
		}
		case 200:
		{
			cfg1 = 0x01;
   30b60:	61 e0       	ldi	r22, 0x01	; 1
   30b62:	0b c0       	rjmp	.+22     	; 0x30b7a <mcp2515_configRate+0x50>
		}
		case 500:
		{
			cfg1 = 0x1;
			cfg2 = 0x90;
			cfg3 = 0x02;
   30b64:	d2 e0       	ldi	r29, 0x02	; 2
			break;
		}
		case 500:
		{
			cfg1 = 0x1;
			cfg2 = 0x90;
   30b66:	c0 e9       	ldi	r28, 0x90	; 144
			cfg3 = 0x85;
			break;
		}
		case 500:
		{
			cfg1 = 0x1;
   30b68:	61 e0       	ldi	r22, 0x01	; 1
			cfg2 = 0x90;
			cfg3 = 0x02;
			//cfg1 = 0x00;
			//cfg2 = 0xF0;
			//cfg3 = 0x86;
			break;
   30b6a:	07 c0       	rjmp	.+14     	; 0x30b7a <mcp2515_configRate+0x50>
		}
		case 1000:
		{
			cfg1 = 0x00;
			cfg2 = 0xD0;
			cfg3 = 0x82;
   30b6c:	d2 e8       	ldi	r29, 0x82	; 130
			break;
		}
		case 1000:
		{
			cfg1 = 0x00;
			cfg2 = 0xD0;
   30b6e:	c0 ed       	ldi	r28, 0xD0	; 208
			//cfg3 = 0x86;
			break;
		}
		case 1000:
		{
			cfg1 = 0x00;
   30b70:	60 e0       	ldi	r22, 0x00	; 0
			cfg2 = 0xD0;
			cfg3 = 0x82;
			break;
   30b72:	03 c0       	rjmp	.+6      	; 0x30b7a <mcp2515_configRate+0x50>
	{
		case 10:
		{
			cfg1 = 0x03;
			cfg2 = 0xFA;
			cfg3 = 0x87;
   30b74:	d7 e8       	ldi	r29, 0x87	; 135
	switch (canSpeed)
	{
		case 10:
		{
			cfg1 = 0x03;
			cfg2 = 0xFA;
   30b76:	ca ef       	ldi	r28, 0xFA	; 250
	set = 1;
	switch (canSpeed)
	{
		case 10:
		{
			cfg1 = 0x03;
   30b78:	63 e0       	ldi	r22, 0x03	; 3
			set = 0;
			break;
	}
	
	if (set) {
		mcp2515_setRegister(MCP_CNF1, cfg1);
   30b7a:	8a e2       	ldi	r24, 0x2A	; 42
   30b7c:	15 df       	rcall	.-470    	; 0x309a8 <mcp2515_setRegister>
		mcp2515_setRegister(MCP_CNF2, cfg2);
   30b7e:	6c 2f       	mov	r22, r28
   30b80:	89 e2       	ldi	r24, 0x29	; 41
   30b82:	12 df       	rcall	.-476    	; 0x309a8 <mcp2515_setRegister>
		mcp2515_setRegister(MCP_CNF3, cfg3);
   30b84:	6d 2f       	mov	r22, r29
   30b86:	88 e2       	ldi	r24, 0x28	; 40
   30b88:	0f df       	rcall	.-482    	; 0x309a8 <mcp2515_setRegister>
		return MCP2515_OK;
   30b8a:	80 e0       	ldi	r24, 0x00	; 0
   30b8c:	0a c0       	rjmp	.+20     	; 0x30ba2 <mcp2515_configRate+0x78>
	}
	else {
		return MCP2515_FAIL;
   30b8e:	81 e0       	ldi	r24, 0x01	; 1
   30b90:	08 c0       	rjmp	.+16     	; 0x30ba2 <mcp2515_configRate+0x78>
		}
		case 125:
		{
			cfg1 = 0x03;
			cfg2 = 0xF0;
			cfg3 = 0x86;
   30b92:	d6 e8       	ldi	r29, 0x86	; 134
			break;
		}
		case 125:
		{
			cfg1 = 0x03;
			cfg2 = 0xF0;
   30b94:	c0 ef       	ldi	r28, 0xF0	; 240
			cfg3 = 0x87;
			break;
		}
		case 125:
		{
			cfg1 = 0x03;
   30b96:	63 e0       	ldi	r22, 0x03	; 3
   30b98:	f0 cf       	rjmp	.-32     	; 0x30b7a <mcp2515_configRate+0x50>
		}
		case 250:
		{
			cfg1 = 0x41;
			cfg2 = 0xF1;
			cfg3 = 0x85;
   30b9a:	d5 e8       	ldi	r29, 0x85	; 133
			break;
		}
		case 250:
		{
			cfg1 = 0x41;
			cfg2 = 0xF1;
   30b9c:	c1 ef       	ldi	r28, 0xF1	; 241
			cfg3 = 0x87;
			break;
		}
		case 250:
		{
			cfg1 = 0x41;
   30b9e:	61 e4       	ldi	r22, 0x41	; 65
   30ba0:	ec cf       	rjmp	.-40     	; 0x30b7a <mcp2515_configRate+0x50>
		return MCP2515_OK;
	}
	else {
		return MCP2515_FAIL;
	}
} 
   30ba2:	df 91       	pop	r29
   30ba4:	cf 91       	pop	r28
   30ba6:	08 95       	ret

00030ba8 <mcp2515_read_can_id>:

// ---

void mcp2515_read_can_id( const uint8_t mcp_addr, 
	uint8_t* ext, uint32_t* can_id )
{
   30ba8:	ef 92       	push	r14
   30baa:	ff 92       	push	r15
   30bac:	0f 93       	push	r16
   30bae:	1f 93       	push	r17
   30bb0:	cf 93       	push	r28
   30bb2:	df 93       	push	r29
   30bb4:	00 d0       	rcall	.+0      	; 0x30bb6 <mcp2515_read_can_id+0xe>
   30bb6:	1f 92       	push	r1
   30bb8:	cd b7       	in	r28, 0x3d	; 61
   30bba:	de b7       	in	r29, 0x3e	; 62
   30bbc:	7b 01       	movw	r14, r22
   30bbe:	8a 01       	movw	r16, r20
    uint8_t tbufdata[4];
	
    *ext = 0;
   30bc0:	fb 01       	movw	r30, r22
   30bc2:	10 82       	st	Z, r1
    *can_id = 0;
   30bc4:	fa 01       	movw	r30, r20
   30bc6:	10 82       	st	Z, r1
   30bc8:	11 82       	std	Z+1, r1	; 0x01
   30bca:	12 82       	std	Z+2, r1	; 0x02
   30bcc:	13 82       	std	Z+3, r1	; 0x03
    
	mcp2515_readRegisterS( mcp_addr, tbufdata, 4 );
   30bce:	44 e0       	ldi	r20, 0x04	; 4
   30bd0:	be 01       	movw	r22, r28
   30bd2:	6f 5f       	subi	r22, 0xFF	; 255
   30bd4:	7f 4f       	sbci	r23, 0xFF	; 255
   30bd6:	a4 de       	rcall	.-696    	; 0x30920 <mcp2515_readRegisterS>
    
	*can_id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5);
   30bd8:	2a 81       	ldd	r18, Y+2	; 0x02
   30bda:	89 81       	ldd	r24, Y+1	; 0x01
   30bdc:	90 e0       	ldi	r25, 0x00	; 0
   30bde:	88 0f       	add	r24, r24
   30be0:	99 1f       	adc	r25, r25
   30be2:	88 0f       	add	r24, r24
   30be4:	99 1f       	adc	r25, r25
   30be6:	88 0f       	add	r24, r24
   30be8:	99 1f       	adc	r25, r25
   30bea:	32 2f       	mov	r19, r18
   30bec:	32 95       	swap	r19
   30bee:	36 95       	lsr	r19
   30bf0:	37 70       	andi	r19, 0x07	; 7
   30bf2:	83 0f       	add	r24, r19
   30bf4:	91 1d       	adc	r25, r1
   30bf6:	09 2e       	mov	r0, r25
   30bf8:	00 0c       	add	r0, r0
   30bfa:	aa 0b       	sbc	r26, r26
   30bfc:	bb 0b       	sbc	r27, r27
   30bfe:	f8 01       	movw	r30, r16
   30c00:	80 83       	st	Z, r24
   30c02:	91 83       	std	Z+1, r25	; 0x01
   30c04:	a2 83       	std	Z+2, r26	; 0x02
   30c06:	b3 83       	std	Z+3, r27	; 0x03
	
    if ( (tbufdata[MCP_SIDL] & MCP_TXB_EXIDE_M) ==  MCP_TXB_EXIDE_M ) {
   30c08:	23 ff       	sbrs	r18, 3
   30c0a:	28 c0       	rjmp	.+80     	; 0x30c5c <mcp2515_read_can_id+0xb4>
		// extended id
        *can_id = (*can_id<<2) + (tbufdata[MCP_SIDL] & 0x03);
        *can_id <<= 16;
        *can_id = *can_id +(tbufdata[MCP_EID8]<<8) + tbufdata[MCP_EID0];
   30c0c:	4b 81       	ldd	r20, Y+3	; 0x03
   30c0e:	50 e0       	ldi	r21, 0x00	; 0
   30c10:	54 2f       	mov	r21, r20
   30c12:	44 27       	eor	r20, r20
   30c14:	05 2e       	mov	r0, r21
   30c16:	00 0c       	add	r0, r0
   30c18:	66 0b       	sbc	r22, r22
   30c1a:	77 0b       	sbc	r23, r23
   30c1c:	3c 81       	ldd	r19, Y+4	; 0x04
   30c1e:	43 0f       	add	r20, r19
   30c20:	51 1d       	adc	r21, r1
   30c22:	61 1d       	adc	r22, r1
   30c24:	71 1d       	adc	r23, r1
   30c26:	88 0f       	add	r24, r24
   30c28:	99 1f       	adc	r25, r25
   30c2a:	aa 1f       	adc	r26, r26
   30c2c:	bb 1f       	adc	r27, r27
   30c2e:	88 0f       	add	r24, r24
   30c30:	99 1f       	adc	r25, r25
   30c32:	aa 1f       	adc	r26, r26
   30c34:	bb 1f       	adc	r27, r27
   30c36:	23 70       	andi	r18, 0x03	; 3
   30c38:	82 0f       	add	r24, r18
   30c3a:	91 1d       	adc	r25, r1
   30c3c:	a1 1d       	adc	r26, r1
   30c3e:	b1 1d       	adc	r27, r1
   30c40:	dc 01       	movw	r26, r24
   30c42:	99 27       	eor	r25, r25
   30c44:	88 27       	eor	r24, r24
   30c46:	84 0f       	add	r24, r20
   30c48:	95 1f       	adc	r25, r21
   30c4a:	a6 1f       	adc	r26, r22
   30c4c:	b7 1f       	adc	r27, r23
   30c4e:	80 83       	st	Z, r24
   30c50:	91 83       	std	Z+1, r25	; 0x01
   30c52:	a2 83       	std	Z+2, r26	; 0x02
   30c54:	b3 83       	std	Z+3, r27	; 0x03
        *ext = 1;
   30c56:	81 e0       	ldi	r24, 0x01	; 1
   30c58:	f7 01       	movw	r30, r14
   30c5a:	80 83       	st	Z, r24
    }
}
   30c5c:	24 96       	adiw	r28, 0x04	; 4
   30c5e:	cd bf       	out	0x3d, r28	; 61
   30c60:	de bf       	out	0x3e, r29	; 62
   30c62:	df 91       	pop	r29
   30c64:	cf 91       	pop	r28
   30c66:	1f 91       	pop	r17
   30c68:	0f 91       	pop	r16
   30c6a:	ff 90       	pop	r15
   30c6c:	ef 90       	pop	r14
   30c6e:	08 95       	ret

00030c70 <mcp2515_read_canMsg>:

// Buffer can be MCP_RXBUF_0 or MCP_RXBUF_1
void mcp2515_read_canMsg( const uint8_t buffer_sidh_addr,
	CanMessage* msg)
{
   30c70:	0f 93       	push	r16
   30c72:	1f 93       	push	r17
   30c74:	cf 93       	push	r28
   30c76:	df 93       	push	r29
   30c78:	18 2f       	mov	r17, r24
   30c7a:	eb 01       	movw	r28, r22

    uint8_t mcp_addr, ctrl;

	mcp_addr = buffer_sidh_addr;
	
    mcp2515_read_can_id( mcp_addr, &(msg->extended_identifier), 
   30c7c:	ab 01       	movw	r20, r22
   30c7e:	4f 5f       	subi	r20, 0xFF	; 255
   30c80:	5f 4f       	sbci	r21, 0xFF	; 255
   30c82:	92 df       	rcall	.-220    	; 0x30ba8 <mcp2515_read_can_id>
		&(msg->identifier) );
    
	ctrl = mcp2515_readRegister( mcp_addr-1 );
   30c84:	8f ef       	ldi	r24, 0xFF	; 255
   30c86:	81 0f       	add	r24, r17
   30c88:	1b de       	rcall	.-970    	; 0x308c0 <mcp2515_readRegister>
   30c8a:	08 2f       	mov	r16, r24
    msg->dlc = mcp2515_readRegister( mcp_addr+4 );
   30c8c:	84 e0       	ldi	r24, 0x04	; 4
   30c8e:	81 0f       	add	r24, r17
   30c90:	17 de       	rcall	.-978    	; 0x308c0 <mcp2515_readRegister>
   30c92:	8d 83       	std	Y+5, r24	; 0x05
    
	if (/*(*dlc & RTR_MASK) || */(ctrl & 0x08)) {
   30c94:	03 ff       	sbrs	r16, 3
   30c96:	03 c0       	rjmp	.+6      	; 0x30c9e <mcp2515_read_canMsg+0x2e>
        msg->rtr = 1;
   30c98:	91 e0       	ldi	r25, 0x01	; 1
   30c9a:	9e 87       	std	Y+14, r25	; 0x0e
   30c9c:	01 c0       	rjmp	.+2      	; 0x30ca0 <mcp2515_read_canMsg+0x30>
    } else {
        msg->rtr = 0;
   30c9e:	1e 86       	std	Y+14, r1	; 0x0e
    }
    
	msg->dlc &= MCP_DLC_MASK;
   30ca0:	48 2f       	mov	r20, r24
   30ca2:	4f 70       	andi	r20, 0x0F	; 15
   30ca4:	4d 83       	std	Y+5, r20	; 0x05
    mcp2515_readRegisterS( mcp_addr+5, &(msg->dta[0]), msg->dlc );
   30ca6:	be 01       	movw	r22, r28
   30ca8:	6a 5f       	subi	r22, 0xFA	; 250
   30caa:	7f 4f       	sbci	r23, 0xFF	; 255
   30cac:	85 e0       	ldi	r24, 0x05	; 5
   30cae:	81 0f       	add	r24, r17
   30cb0:	37 de       	rcall	.-914    	; 0x30920 <mcp2515_readRegisterS>
}
   30cb2:	df 91       	pop	r29
   30cb4:	cf 91       	pop	r28
   30cb6:	1f 91       	pop	r17
   30cb8:	0f 91       	pop	r16
   30cba:	08 95       	ret

00030cbc <mcp2515_write_can_id>:


void mcp2515_write_can_id( const uint8_t mcp_addr, 
	const uint8_t ext, const uint32_t can_id )
{
   30cbc:	0f 93       	push	r16
   30cbe:	1f 93       	push	r17
   30cc0:	cf 93       	push	r28
   30cc2:	df 93       	push	r29
   30cc4:	00 d0       	rcall	.+0      	; 0x30cc6 <mcp2515_write_can_id+0xa>
   30cc6:	1f 92       	push	r1
   30cc8:	cd b7       	in	r28, 0x3d	; 61
   30cca:	de b7       	in	r29, 0x3e	; 62
    uint16_t canid;
    uint8_t tbufdata[4];
	
    canid = (uint16_t)(can_id & 0x0FFFF);
    
	if ( ext == 1) {
   30ccc:	61 30       	cpi	r22, 0x01	; 1
   30cce:	d1 f4       	brne	.+52     	; 0x30d04 <mcp2515_write_can_id+0x48>
        tbufdata[MCP_EID0] = (uint8_t) (canid & 0xFF);
   30cd0:	2c 83       	std	Y+4, r18	; 0x04
        tbufdata[MCP_EID8] = (uint8_t) (canid / 256);
   30cd2:	3b 83       	std	Y+3, r19	; 0x03
        canid = (uint16_t)( can_id / 0x10000L );
   30cd4:	8a 01       	movw	r16, r20
   30cd6:	22 27       	eor	r18, r18
   30cd8:	33 27       	eor	r19, r19
        tbufdata[MCP_SIDL] = (uint8_t) (canid & 0x03);
        tbufdata[MCP_SIDL] += (uint8_t) ((canid & 0x1C )*8);
        tbufdata[MCP_SIDL] |= MCP_TXB_EXIDE_M;
   30cda:	90 2f       	mov	r25, r16
   30cdc:	9c 71       	andi	r25, 0x1C	; 28
   30cde:	99 0f       	add	r25, r25
   30ce0:	99 0f       	add	r25, r25
   30ce2:	99 0f       	add	r25, r25
   30ce4:	60 2f       	mov	r22, r16
   30ce6:	63 70       	andi	r22, 0x03	; 3
   30ce8:	96 0f       	add	r25, r22
   30cea:	98 60       	ori	r25, 0x08	; 8
   30cec:	9a 83       	std	Y+2, r25	; 0x02
        tbufdata[MCP_SIDH] = (uint8_t) (canid / 32 );
   30cee:	98 01       	movw	r18, r16
   30cf0:	36 95       	lsr	r19
   30cf2:	27 95       	ror	r18
   30cf4:	32 95       	swap	r19
   30cf6:	22 95       	swap	r18
   30cf8:	2f 70       	andi	r18, 0x0F	; 15
   30cfa:	23 27       	eor	r18, r19
   30cfc:	3f 70       	andi	r19, 0x0F	; 15
   30cfe:	23 27       	eor	r18, r19
   30d00:	29 83       	std	Y+1, r18	; 0x01
   30d02:	0e c0       	rjmp	.+28     	; 0x30d20 <mcp2515_write_can_id+0x64>
    }
    else {
        tbufdata[MCP_SIDH] = (uint8_t) (canid / 8 );
   30d04:	b9 01       	movw	r22, r18
   30d06:	76 95       	lsr	r23
   30d08:	67 95       	ror	r22
   30d0a:	76 95       	lsr	r23
   30d0c:	67 95       	ror	r22
   30d0e:	76 95       	lsr	r23
   30d10:	67 95       	ror	r22
   30d12:	69 83       	std	Y+1, r22	; 0x01
        tbufdata[MCP_SIDL] = (uint8_t) ((canid & 0x07 )*32);
   30d14:	22 95       	swap	r18
   30d16:	22 0f       	add	r18, r18
   30d18:	20 7e       	andi	r18, 0xE0	; 224
   30d1a:	2a 83       	std	Y+2, r18	; 0x02
        tbufdata[MCP_EID0] = 0;
   30d1c:	1c 82       	std	Y+4, r1	; 0x04
        tbufdata[MCP_EID8] = 0;
   30d1e:	1b 82       	std	Y+3, r1	; 0x03
    }
	mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
   30d20:	44 e0       	ldi	r20, 0x04	; 4
   30d22:	be 01       	movw	r22, r28
   30d24:	6f 5f       	subi	r22, 0xFF	; 255
   30d26:	7f 4f       	sbci	r23, 0xFF	; 255
   30d28:	72 de       	rcall	.-796    	; 0x30a0e <mcp2515_setRegisterS>
}
   30d2a:	24 96       	adiw	r28, 0x04	; 4
   30d2c:	cd bf       	out	0x3d, r28	; 61
   30d2e:	de bf       	out	0x3e, r29	; 62
   30d30:	df 91       	pop	r29
   30d32:	cf 91       	pop	r28
   30d34:	1f 91       	pop	r17
   30d36:	0f 91       	pop	r16
   30d38:	08 95       	ret

00030d3a <mcp2515_write_canMsg>:

// Buffer can be MCP_TXBUF_0 MCP_TXBUF_1 or MCP_TXBUF_2
void mcp2515_write_canMsg( const uint8_t buffer_sidh_addr, 
	const CanMessage* msg)
{
   30d3a:	0f 93       	push	r16
   30d3c:	1f 93       	push	r17
   30d3e:	cf 93       	push	r28
   30d40:	df 93       	push	r29
   30d42:	18 2f       	mov	r17, r24
   30d44:	eb 01       	movw	r28, r22
    uint8_t mcp_addr, dlc;

	mcp_addr = buffer_sidh_addr;
	dlc = msg->dlc;
   30d46:	0d 81       	ldd	r16, Y+5	; 0x05
	
    mcp2515_setRegisterS(mcp_addr+5, &(msg->dta[0]), dlc );  // write data bytes
   30d48:	6a 5f       	subi	r22, 0xFA	; 250
   30d4a:	7f 4f       	sbci	r23, 0xFF	; 255
   30d4c:	40 2f       	mov	r20, r16
   30d4e:	85 e0       	ldi	r24, 0x05	; 5
   30d50:	81 0f       	add	r24, r17
   30d52:	5d de       	rcall	.-838    	; 0x30a0e <mcp2515_setRegisterS>
    mcp2515_write_can_id( mcp_addr, msg->extended_identifier,
   30d54:	29 81       	ldd	r18, Y+1	; 0x01
   30d56:	3a 81       	ldd	r19, Y+2	; 0x02
   30d58:	4b 81       	ldd	r20, Y+3	; 0x03
   30d5a:	5c 81       	ldd	r21, Y+4	; 0x04
   30d5c:	68 81       	ld	r22, Y
   30d5e:	81 2f       	mov	r24, r17
   30d60:	ad df       	rcall	.-166    	; 0x30cbc <mcp2515_write_can_id>
		msg->identifier );  // write CAN id
    if ( msg->rtr == 1)  dlc |= MCP_RTR_MASK;  // if RTR set bit in byte
   30d62:	8e 85       	ldd	r24, Y+14	; 0x0e
   30d64:	81 30       	cpi	r24, 0x01	; 1
   30d66:	09 f4       	brne	.+2      	; 0x30d6a <mcp2515_write_canMsg+0x30>
   30d68:	00 64       	ori	r16, 0x40	; 64
    mcp2515_setRegister( (mcp_addr+4), dlc );  // write the RTR and DLC
   30d6a:	60 2f       	mov	r22, r16
   30d6c:	84 e0       	ldi	r24, 0x04	; 4
   30d6e:	81 0f       	add	r24, r17
   30d70:	1b de       	rcall	.-970    	; 0x309a8 <mcp2515_setRegister>
}
   30d72:	df 91       	pop	r29
   30d74:	cf 91       	pop	r28
   30d76:	1f 91       	pop	r17
   30d78:	0f 91       	pop	r16
   30d7a:	08 95       	ret

00030d7c <mcp2515_start_transmit>:
 */
// Buffer can be MCP_TXBUF_0 MCP_TXBUF_1 or MCP_TXBUF_2
void mcp2515_start_transmit(const uint8_t buffer_sidh_addr)
{
	// TXBnCTRL_addr = TXBnSIDH_addr - 1
    mcp2515_modifyRegister( buffer_sidh_addr-1 , MCP_TXB_TXREQ_M, 
   30d7c:	48 e0       	ldi	r20, 0x08	; 8
   30d7e:	68 e0       	ldi	r22, 0x08	; 8
   30d80:	81 50       	subi	r24, 0x01	; 1
   30d82:	88 ce       	rjmp	.-752    	; 0x30a94 <mcp2515_modifyRegister>
   30d84:	08 95       	ret

00030d86 <mcp2515_getNextFreeTXBuf>:
		MCP_TXB_TXREQ_M );
}

uint8_t mcp2515_getNextFreeTXBuf(uint8_t *txbuf_n)
{
   30d86:	af 92       	push	r10
   30d88:	bf 92       	push	r11
   30d8a:	cf 92       	push	r12
   30d8c:	df 92       	push	r13
   30d8e:	ff 92       	push	r15
   30d90:	0f 93       	push	r16
   30d92:	1f 93       	push	r17
   30d94:	cf 93       	push	r28
   30d96:	df 93       	push	r29
   30d98:	00 d0       	rcall	.+0      	; 0x30d9a <mcp2515_getNextFreeTXBuf+0x14>
   30d9a:	cd b7       	in	r28, 0x3d	; 61
   30d9c:	de b7       	in	r29, 0x3e	; 62
   30d9e:	5c 01       	movw	r10, r24
	uint8_t res, i, ctrlval;
	uint8_t ctrlregs[MCP_N_TXBUFFERS] = { MCP_TXB0CTRL, MCP_TXB1CTRL, MCP_TXB2CTRL };
   30da0:	80 e3       	ldi	r24, 0x30	; 48
   30da2:	89 83       	std	Y+1, r24	; 0x01
   30da4:	80 e4       	ldi	r24, 0x40	; 64
   30da6:	8a 83       	std	Y+2, r24	; 0x02
   30da8:	80 e5       	ldi	r24, 0x50	; 80
   30daa:	8b 83       	std	Y+3, r24	; 0x03
	
	res = MCP_ALLTXBUSY;
	*txbuf_n = 0x00;
   30dac:	f5 01       	movw	r30, r10
   30dae:	10 82       	st	Z, r1
   30db0:	8e 01       	movw	r16, r28
   30db2:	0f 5f       	subi	r16, 0xFF	; 255
   30db4:	1f 4f       	sbci	r17, 0xFF	; 255
   30db6:	6e 01       	movw	r12, r28
   30db8:	f4 e0       	ldi	r31, 0x04	; 4
   30dba:	cf 0e       	add	r12, r31
   30dbc:	d1 1c       	adc	r13, r1
	
	// check all 3 TX-Buffers
	for (i=0; i<MCP_N_TXBUFFERS; i++) {
		ctrlval = mcp2515_readRegister( ctrlregs[i] );
   30dbe:	f8 01       	movw	r30, r16
   30dc0:	f1 90       	ld	r15, Z+
   30dc2:	8f 01       	movw	r16, r30
   30dc4:	8f 2d       	mov	r24, r15
   30dc6:	7c dd       	rcall	.-1288   	; 0x308c0 <mcp2515_readRegister>
		if ( (ctrlval & MCP_TXB_TXREQ_M) == 0 ) {
   30dc8:	98 2f       	mov	r25, r24
   30dca:	98 70       	andi	r25, 0x08	; 8
   30dcc:	83 fd       	sbrc	r24, 3
   30dce:	04 c0       	rjmp	.+8      	; 0x30dd8 <mcp2515_getNextFreeTXBuf+0x52>
#if (MCPDEBUG_TXBUF)
			Debug_ByteToUart_P("Selected TX-Buffer", i+1);
#endif
			*txbuf_n = ctrlregs[i]+1; // return SIDH-address of Buffer
   30dd0:	f3 94       	inc	r15
   30dd2:	f5 01       	movw	r30, r10
   30dd4:	f0 82       	st	Z, r15
			res = MCP2515_OK;
			return res; /* ! function exit */
   30dd6:	04 c0       	rjmp	.+8      	; 0x30de0 <mcp2515_getNextFreeTXBuf+0x5a>
	
	res = MCP_ALLTXBUSY;
	*txbuf_n = 0x00;
	
	// check all 3 TX-Buffers
	for (i=0; i<MCP_N_TXBUFFERS; i++) {
   30dd8:	0c 15       	cp	r16, r12
   30dda:	1d 05       	cpc	r17, r13
   30ddc:	81 f7       	brne	.-32     	; 0x30dbe <mcp2515_getNextFreeTXBuf+0x38>
			res = MCP2515_OK;
			return res; /* ! function exit */
		}
	}
	
	return res;
   30dde:	92 e0       	ldi	r25, 0x02	; 2
}
   30de0:	89 2f       	mov	r24, r25
   30de2:	23 96       	adiw	r28, 0x03	; 3
   30de4:	cd bf       	out	0x3d, r28	; 61
   30de6:	de bf       	out	0x3e, r29	; 62
   30de8:	df 91       	pop	r29
   30dea:	cf 91       	pop	r28
   30dec:	1f 91       	pop	r17
   30dee:	0f 91       	pop	r16
   30df0:	ff 90       	pop	r15
   30df2:	df 90       	pop	r13
   30df4:	cf 90       	pop	r12
   30df6:	bf 90       	pop	r11
   30df8:	af 90       	pop	r10
   30dfa:	08 95       	ret

00030dfc <mcp2515_initCANBuffers>:

void mcp2515_initCANBuffers(void)
{
   30dfc:	cf 93       	push	r28
	uint8_t i, a1, a2, a3;
	
	// STD MASK
	mcp2515_write_can_id(MCP_RXM0SIDH, 0, 0);
   30dfe:	20 e0       	ldi	r18, 0x00	; 0
   30e00:	30 e0       	ldi	r19, 0x00	; 0
   30e02:	a9 01       	movw	r20, r18
   30e04:	60 e0       	ldi	r22, 0x00	; 0
   30e06:	80 e2       	ldi	r24, 0x20	; 32
   30e08:	59 df       	rcall	.-334    	; 0x30cbc <mcp2515_write_can_id>
	mcp2515_write_can_id(MCP_RXM1SIDH, 0, 0);
   30e0a:	20 e0       	ldi	r18, 0x00	; 0
   30e0c:	30 e0       	ldi	r19, 0x00	; 0
   30e0e:	a9 01       	movw	r20, r18
   30e10:	60 e0       	ldi	r22, 0x00	; 0
   30e12:	84 e2       	ldi	r24, 0x24	; 36
   30e14:	53 df       	rcall	.-346    	; 0x30cbc <mcp2515_write_can_id>
	
	// STD FILTER
	mcp2515_write_can_id(MCP_RXF0SIDH, 0, 0);
   30e16:	20 e0       	ldi	r18, 0x00	; 0
   30e18:	30 e0       	ldi	r19, 0x00	; 0
   30e1a:	a9 01       	movw	r20, r18
   30e1c:	60 e0       	ldi	r22, 0x00	; 0
   30e1e:	80 e0       	ldi	r24, 0x00	; 0
   30e20:	4d df       	rcall	.-358    	; 0x30cbc <mcp2515_write_can_id>
	mcp2515_write_can_id(MCP_RXF1SIDH, 0, 0);
   30e22:	20 e0       	ldi	r18, 0x00	; 0
   30e24:	30 e0       	ldi	r19, 0x00	; 0
   30e26:	a9 01       	movw	r20, r18
   30e28:	60 e0       	ldi	r22, 0x00	; 0
   30e2a:	84 e0       	ldi	r24, 0x04	; 4
   30e2c:	47 df       	rcall	.-370    	; 0x30cbc <mcp2515_write_can_id>
	mcp2515_write_can_id(MCP_RXF2SIDH, 0, 0);
   30e2e:	20 e0       	ldi	r18, 0x00	; 0
   30e30:	30 e0       	ldi	r19, 0x00	; 0
   30e32:	a9 01       	movw	r20, r18
   30e34:	60 e0       	ldi	r22, 0x00	; 0
   30e36:	88 e0       	ldi	r24, 0x08	; 8
   30e38:	41 df       	rcall	.-382    	; 0x30cbc <mcp2515_write_can_id>
	mcp2515_write_can_id(MCP_RXF3SIDH, 0, 0);
   30e3a:	20 e0       	ldi	r18, 0x00	; 0
   30e3c:	30 e0       	ldi	r19, 0x00	; 0
   30e3e:	a9 01       	movw	r20, r18
   30e40:	60 e0       	ldi	r22, 0x00	; 0
   30e42:	80 e1       	ldi	r24, 0x10	; 16
   30e44:	3b df       	rcall	.-394    	; 0x30cbc <mcp2515_write_can_id>
	mcp2515_write_can_id(MCP_RXF4SIDH, 0, 0);
   30e46:	20 e0       	ldi	r18, 0x00	; 0
   30e48:	30 e0       	ldi	r19, 0x00	; 0
   30e4a:	a9 01       	movw	r20, r18
   30e4c:	60 e0       	ldi	r22, 0x00	; 0
   30e4e:	84 e1       	ldi	r24, 0x14	; 20
   30e50:	35 df       	rcall	.-406    	; 0x30cbc <mcp2515_write_can_id>
	mcp2515_write_can_id(MCP_RXF5SIDH, 0, 0);
   30e52:	20 e0       	ldi	r18, 0x00	; 0
   30e54:	30 e0       	ldi	r19, 0x00	; 0
   30e56:	a9 01       	movw	r20, r18
   30e58:	60 e0       	ldi	r22, 0x00	; 0
   30e5a:	88 e1       	ldi	r24, 0x18	; 24
   30e5c:	2f df       	rcall	.-418    	; 0x30cbc <mcp2515_write_can_id>
	
	// Clear, deactivate the three transmit buffers
	// TXBnCTRL -> TXBnD7
    a1 = MCP_TXB0CTRL;
   30e5e:	c0 e3       	ldi	r28, 0x30	; 48
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
    for (i = 0; i < 14; i++) { // in-buffer loop
		mcp2515_setRegister(a1, 0);
   30e60:	60 e0       	ldi	r22, 0x00	; 0
   30e62:	8c 2f       	mov	r24, r28
   30e64:	a1 dd       	rcall	.-1214   	; 0x309a8 <mcp2515_setRegister>
		mcp2515_setRegister(a2, 0);
   30e66:	60 e0       	ldi	r22, 0x00	; 0
   30e68:	80 e1       	ldi	r24, 0x10	; 16
   30e6a:	8c 0f       	add	r24, r28
   30e6c:	9d dd       	rcall	.-1222   	; 0x309a8 <mcp2515_setRegister>
		mcp2515_setRegister(a3, 0);
   30e6e:	60 e0       	ldi	r22, 0x00	; 0
   30e70:	80 e2       	ldi	r24, 0x20	; 32
   30e72:	8c 0f       	add	r24, r28
   30e74:	99 dd       	rcall	.-1230   	; 0x309a8 <mcp2515_setRegister>
        a1++;
   30e76:	cf 5f       	subi	r28, 0xFF	; 255
	// Clear, deactivate the three transmit buffers
	// TXBnCTRL -> TXBnD7
    a1 = MCP_TXB0CTRL;
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
    for (i = 0; i < 14; i++) { // in-buffer loop
   30e78:	ce 33       	cpi	r28, 0x3E	; 62
   30e7a:	91 f7       	brne	.-28     	; 0x30e60 <mcp2515_initCANBuffers+0x64>
		a2++;
		a3++;
    }
	
    // and clear, deactivate the two receive buffers.
    mcp2515_setRegister(MCP_RXB0CTRL, 0);
   30e7c:	60 e0       	ldi	r22, 0x00	; 0
   30e7e:	80 e6       	ldi	r24, 0x60	; 96
   30e80:	93 dd       	rcall	.-1242   	; 0x309a8 <mcp2515_setRegister>
   30e82:	60 e0       	ldi	r22, 0x00	; 0
    mcp2515_setRegister(MCP_RXB1CTRL, 0);
   30e84:	80 e7       	ldi	r24, 0x70	; 112
   30e86:	90 dd       	rcall	.-1248   	; 0x309a8 <mcp2515_setRegister>
   30e88:	cf 91       	pop	r28
   30e8a:	08 95       	ret

00030e8c <mcp2515_init>:
}
   30e8c:	cf 93       	push	r28
   30e8e:	df 93       	push	r29


uint8_t mcp2515_init(const uint16_t canSpeed)
{
   30e90:	ec 01       	movw	r28, r24
	uint8_t res;
	
	MCP2515_UNSELECT();
   30e92:	e0 e8       	ldi	r30, 0x80	; 128
   30e94:	f6 e0       	ldi	r31, 0x06	; 6
   30e96:	80 81       	ld	r24, Z
   30e98:	88 60       	ori	r24, 0x08	; 8
   30e9a:	80 83       	st	Z, r24
   30e9c:	e4 e8       	ldi	r30, 0x84	; 132
   30e9e:	f6 e0       	ldi	r31, 0x06	; 6
   30ea0:	80 81       	ld	r24, Z
   30ea2:	88 60       	ori	r24, 0x08	; 8
   30ea4:	80 83       	st	Z, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
   30ea6:	8f ea       	ldi	r24, 0xAF	; 175
   30ea8:	94 e0       	ldi	r25, 0x04	; 4
   30eaa:	01 97       	sbiw	r24, 0x01	; 1
   30eac:	f1 f7       	brne	.-4      	; 0x30eaa <mcp2515_init+0x1e>
   30eae:	00 c0       	rjmp	.+0      	; 0x30eb0 <mcp2515_init+0x24>
   30eb0:	00 00       	nop
	
	mcp2515_reset();
   30eb2:	d7 dc       	rcall	.-1618   	; 0x30862 <mcp2515_reset>
	
	res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
   30eb4:	80 e8       	ldi	r24, 0x80	; 128
   30eb6:	29 de       	rcall	.-942    	; 0x30b0a <mcp2515_setCANCTRL_Mode>
	
	if ( res == MCP2515_FAIL ) return res;  /* function exit on error */
   30eb8:	81 30       	cpi	r24, 0x01	; 1
		
	res = mcp2515_configRate(canSpeed);
   30eba:	81 f0       	breq	.+32     	; 0x30edc <mcp2515_init+0x50>
   30ebc:	ce 01       	movw	r24, r28
   30ebe:	35 de       	rcall	.-918    	; 0x30b2a <mcp2515_configRate>
	
	if ( res == MCP2515_OK ) {
   30ec0:	c8 2f       	mov	r28, r24
   30ec2:	81 11       	cpse	r24, r1
		
		mcp2515_initCANBuffers();
   30ec4:	0d c0       	rjmp	.+26     	; 0x30ee0 <mcp2515_init+0x54>
		
		// enable both receive-buffers to receive messages
		// with std. and ext. identifiers
		// and enable rollover
		mcp2515_modifyRegister(MCP_RXB0CTRL, 
   30ec6:	9a df       	rcall	.-204    	; 0x30dfc <mcp2515_initCANBuffers>
   30ec8:	44 e0       	ldi	r20, 0x04	; 4
   30eca:	64 e6       	ldi	r22, 0x64	; 100
   30ecc:	80 e6       	ldi	r24, 0x60	; 96
			MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK, 
			MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
		mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK, 
   30ece:	e2 dd       	rcall	.-1084   	; 0x30a94 <mcp2515_modifyRegister>
   30ed0:	40 e0       	ldi	r20, 0x00	; 0
   30ed2:	60 e6       	ldi	r22, 0x60	; 96
   30ed4:	80 e7       	ldi	r24, 0x70	; 112
   30ed6:	de dd       	rcall	.-1092   	; 0x30a94 <mcp2515_modifyRegister>
			MCP_RXB_RX_STDEXT);

	}
	
	return res;
   30ed8:	8c 2f       	mov	r24, r28
   30eda:	02 c0       	rjmp	.+4      	; 0x30ee0 <mcp2515_init+0x54>
	
	mcp2515_reset();
	
	res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
	
	if ( res == MCP2515_FAIL ) return res;  /* function exit on error */
   30edc:	81 e0       	ldi	r24, 0x01	; 1
   30ede:	00 c0       	rjmp	.+0      	; 0x30ee0 <mcp2515_init+0x54>
			MCP_RXB_RX_STDEXT);

	}
	
	return res;
}
   30ee0:	df 91       	pop	r29
   30ee2:	cf 91       	pop	r28
   30ee4:	08 95       	ret

00030ee6 <can_send>:
#include "sp_driver.h"
#include "aes.h"
#include "config.h"

uint8_t can_send(CanMessage *msg)
{
   30ee6:	0f 93       	push	r16
   30ee8:	1f 93       	push	r17
   30eea:	cf 93       	push	r28
   30eec:	df 93       	push	r29
   30eee:	1f 92       	push	r1
   30ef0:	cd b7       	in	r28, 0x3d	; 61
   30ef2:	de b7       	in	r29, 0x3e	; 62
   30ef4:	8c 01       	movw	r16, r24
	uint8_t res, txbuf_n;
	res = mcp2515_getNextFreeTXBuf(&txbuf_n);
   30ef6:	ce 01       	movw	r24, r28
   30ef8:	01 96       	adiw	r24, 0x01	; 1
   30efa:	45 df       	rcall	.-374    	; 0x30d86 <mcp2515_getNextFreeTXBuf>
	if (res != MCP_ALLTXBUSY)
   30efc:	82 30       	cpi	r24, 0x02	; 2
   30efe:	39 f0       	breq	.+14     	; 0x30f0e <can_send+0x28>
	{
		mcp2515_write_canMsg(txbuf_n, msg);
   30f00:	b8 01       	movw	r22, r16
   30f02:	89 81       	ldd	r24, Y+1	; 0x01
   30f04:	1a df       	rcall	.-460    	; 0x30d3a <mcp2515_write_canMsg>
		mcp2515_start_transmit(txbuf_n);		
   30f06:	89 81       	ldd	r24, Y+1	; 0x01
   30f08:	39 df       	rcall	.-398    	; 0x30d7c <mcp2515_start_transmit>
   30f0a:	80 e0       	ldi	r24, 0x00	; 0
		return 0;
   30f0c:	01 c0       	rjmp	.+2      	; 0x30f10 <can_send+0x2a>
   30f0e:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
		return 1;
   30f10:	0f 90       	pop	r0
}
   30f12:	df 91       	pop	r29
   30f14:	cf 91       	pop	r28
   30f16:	1f 91       	pop	r17
   30f18:	0f 91       	pop	r16
   30f1a:	08 95       	ret

00030f1c <can_read>:
   30f1c:	cf 93       	push	r28
uint8_t can_read(CanMessage *msg)
{
   30f1e:	df 93       	push	r29
   30f20:	ec 01       	movw	r28, r24
	uint8_t res;
	res = mcp2515_readStatus();
   30f22:	f0 dd       	rcall	.-1056   	; 0x30b04 <mcp2515_readStatus>
   30f24:	98 2f       	mov	r25, r24
   30f26:	83 70       	andi	r24, 0x03	; 3
	if (res & MCP_STAT_RXIF_MASK )
   30f28:	d1 f0       	breq	.+52     	; 0x30f5e <can_read+0x42>
	{
		if (res & MCP_STAT_RX0IF)
   30f2a:	90 ff       	sbrs	r25, 0
   30f2c:	09 c0       	rjmp	.+18     	; 0x30f40 <can_read+0x24>
		{
			mcp2515_read_canMsg( MCP_RXBUF_0, msg);
   30f2e:	be 01       	movw	r22, r28
   30f30:	81 e6       	ldi	r24, 0x61	; 97
   30f32:	9e de       	rcall	.-708    	; 0x30c70 <mcp2515_read_canMsg>
			mcp2515_modifyRegister(MCP_CANINTF, MCP_RX0IF, 0);
   30f34:	40 e0       	ldi	r20, 0x00	; 0
   30f36:	61 e0       	ldi	r22, 0x01	; 1
   30f38:	8c e2       	ldi	r24, 0x2C	; 44
   30f3a:	ac dd       	rcall	.-1192   	; 0x30a94 <mcp2515_modifyRegister>
			res = 0;
   30f3c:	90 e0       	ldi	r25, 0x00	; 0
   30f3e:	0c c0       	rjmp	.+24     	; 0x30f58 <can_read+0x3c>
		}
		else if (res & MCP_STAT_RX1IF)
   30f40:	91 ff       	sbrs	r25, 1
		{
			mcp2515_read_canMsg( MCP_RXBUF_1, msg);
   30f42:	09 c0       	rjmp	.+18     	; 0x30f56 <can_read+0x3a>
   30f44:	be 01       	movw	r22, r28
   30f46:	81 e7       	ldi	r24, 0x71	; 113
			mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0);
   30f48:	93 de       	rcall	.-730    	; 0x30c70 <mcp2515_read_canMsg>
   30f4a:	40 e0       	ldi	r20, 0x00	; 0
   30f4c:	62 e0       	ldi	r22, 0x02	; 2
   30f4e:	8c e2       	ldi	r24, 0x2C	; 44
   30f50:	a1 dd       	rcall	.-1214   	; 0x30a94 <mcp2515_modifyRegister>
			res = 0;
   30f52:	90 e0       	ldi	r25, 0x00	; 0
   30f54:	01 c0       	rjmp	.+2      	; 0x30f58 <can_read+0x3c>
		}
		else
		{
			res = 1;
   30f56:	91 e0       	ldi	r25, 0x01	; 1
		}
		
		if (res == 0)
			return 1;
   30f58:	81 e0       	ldi	r24, 0x01	; 1
   30f5a:	91 11       	cpse	r25, r1
   30f5c:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	return 0;
}
   30f5e:	df 91       	pop	r29
   30f60:	cf 91       	pop	r28
   30f62:	08 95       	ret

00030f64 <firmware_read>:
uint8_t firmware_read(uint8_t *firmware)
{
   30f64:	cf 93       	push	r28
   30f66:	df 93       	push	r29
   30f68:	ec 01       	movw	r28, r24
	if (SP_ReadUserSignatureByte(0) == 0xF0 && SP_ReadUserSignatureByte(5) == 0x0F)
   30f6a:	80 e0       	ldi	r24, 0x00	; 0
   30f6c:	90 e0       	ldi	r25, 0x00	; 0
   30f6e:	76 d9       	rcall	.-3348   	; 0x3025c <SP_ReadUserSignatureByte>
   30f70:	80 3f       	cpi	r24, 0xF0	; 240
   30f72:	b9 f4       	brne	.+46     	; 0x30fa2 <firmware_read+0x3e>
   30f74:	85 e0       	ldi	r24, 0x05	; 5
   30f76:	90 e0       	ldi	r25, 0x00	; 0
   30f78:	71 d9       	rcall	.-3358   	; 0x3025c <SP_ReadUserSignatureByte>
   30f7a:	8f 30       	cpi	r24, 0x0F	; 15
   30f7c:	a1 f4       	brne	.+40     	; 0x30fa6 <firmware_read+0x42>
	{
		firmware[0] = SP_ReadUserSignatureByte(1);
   30f7e:	81 e0       	ldi	r24, 0x01	; 1
   30f80:	90 e0       	ldi	r25, 0x00	; 0
   30f82:	6c d9       	rcall	.-3368   	; 0x3025c <SP_ReadUserSignatureByte>
   30f84:	88 83       	st	Y, r24
		firmware[1] = SP_ReadUserSignatureByte(2);
   30f86:	82 e0       	ldi	r24, 0x02	; 2
   30f88:	90 e0       	ldi	r25, 0x00	; 0
   30f8a:	68 d9       	rcall	.-3376   	; 0x3025c <SP_ReadUserSignatureByte>
   30f8c:	89 83       	std	Y+1, r24	; 0x01
		firmware[2] = SP_ReadUserSignatureByte(3);
   30f8e:	83 e0       	ldi	r24, 0x03	; 3
   30f90:	90 e0       	ldi	r25, 0x00	; 0
   30f92:	64 d9       	rcall	.-3384   	; 0x3025c <SP_ReadUserSignatureByte>
   30f94:	8a 83       	std	Y+2, r24	; 0x02
		firmware[3] = SP_ReadUserSignatureByte(4);
   30f96:	84 e0       	ldi	r24, 0x04	; 4
   30f98:	90 e0       	ldi	r25, 0x00	; 0
   30f9a:	60 d9       	rcall	.-3392   	; 0x3025c <SP_ReadUserSignatureByte>
   30f9c:	8b 83       	std	Y+3, r24	; 0x03
   30f9e:	81 e0       	ldi	r24, 0x01	; 1
		
		return 1;
   30fa0:	03 c0       	rjmp	.+6      	; 0x30fa8 <firmware_read+0x44>
   30fa2:	80 e0       	ldi	r24, 0x00	; 0
	}
	else
		return 0;
   30fa4:	01 c0       	rjmp	.+2      	; 0x30fa8 <firmware_read+0x44>
   30fa6:	80 e0       	ldi	r24, 0x00	; 0
   30fa8:	df 91       	pop	r29
}
   30faa:	cf 91       	pop	r28
   30fac:	08 95       	ret

00030fae <__vector_14>:
   30fae:	1f 92       	push	r1
volatile uint8_t buffer[SPM_PAGESIZE];
volatile uint8_t buffer_decrypted[SPM_PAGESIZE];

// provide 100us ticks
ISR(TCC0_OVF_vect)
{
   30fb0:	0f 92       	push	r0
   30fb2:	0f b6       	in	r0, 0x3f	; 63
   30fb4:	0f 92       	push	r0
   30fb6:	11 24       	eor	r1, r1
   30fb8:	2f 93       	push	r18
   30fba:	3f 93       	push	r19
   30fbc:	4f 93       	push	r20
   30fbe:	5f 93       	push	r21
   30fc0:	6f 93       	push	r22
   30fc2:	7f 93       	push	r23
   30fc4:	8f 93       	push	r24
   30fc6:	9f 93       	push	r25
   30fc8:	af 93       	push	r26
	static uint8_t c = 0;
	++ticks_100us;
   30fca:	20 91 df 23 	lds	r18, 0x23DF	; 0x8023df <ticks_100us>
   30fce:	30 91 e0 23 	lds	r19, 0x23E0	; 0x8023e0 <ticks_100us+0x1>
   30fd2:	40 91 e1 23 	lds	r20, 0x23E1	; 0x8023e1 <ticks_100us+0x2>
   30fd6:	50 91 e2 23 	lds	r21, 0x23E2	; 0x8023e2 <ticks_100us+0x3>
   30fda:	60 91 e3 23 	lds	r22, 0x23E3	; 0x8023e3 <ticks_100us+0x4>
   30fde:	70 91 e4 23 	lds	r23, 0x23E4	; 0x8023e4 <ticks_100us+0x5>
   30fe2:	80 91 e5 23 	lds	r24, 0x23E5	; 0x8023e5 <ticks_100us+0x6>
   30fe6:	90 91 e6 23 	lds	r25, 0x23E6	; 0x8023e6 <ticks_100us+0x7>
   30fea:	a1 e0       	ldi	r26, 0x01	; 1
   30fec:	fc d3       	rcall	.+2040   	; 0x317e6 <__adddi3_s8>
   30fee:	20 93 df 23 	sts	0x23DF, r18	; 0x8023df <ticks_100us>
   30ff2:	30 93 e0 23 	sts	0x23E0, r19	; 0x8023e0 <ticks_100us+0x1>
   30ff6:	40 93 e1 23 	sts	0x23E1, r20	; 0x8023e1 <ticks_100us+0x2>
   30ffa:	50 93 e2 23 	sts	0x23E2, r21	; 0x8023e2 <ticks_100us+0x3>
   30ffe:	60 93 e3 23 	sts	0x23E3, r22	; 0x8023e3 <ticks_100us+0x4>
   31002:	70 93 e4 23 	sts	0x23E4, r23	; 0x8023e4 <ticks_100us+0x5>
   31006:	80 93 e5 23 	sts	0x23E5, r24	; 0x8023e5 <ticks_100us+0x6>
   3100a:	90 93 e6 23 	sts	0x23E6, r25	; 0x8023e6 <ticks_100us+0x7>
	++c;
   3100e:	80 91 d6 23 	lds	r24, 0x23D6	; 0x8023d6 <c.3722>
   31012:	8f 5f       	subi	r24, 0xFF	; 255
   31014:	80 93 d6 23 	sts	0x23D6, r24	; 0x8023d6 <c.3722>
	if (c == 10)
   31018:	8a 30       	cpi	r24, 0x0A	; 10
   3101a:	19 f5       	brne	.+70     	; 0x31062 <__vector_14+0xb4>
	{
		++ticks_1ms;
   3101c:	20 91 d7 23 	lds	r18, 0x23D7	; 0x8023d7 <ticks_1ms>
   31020:	30 91 d8 23 	lds	r19, 0x23D8	; 0x8023d8 <ticks_1ms+0x1>
   31024:	40 91 d9 23 	lds	r20, 0x23D9	; 0x8023d9 <ticks_1ms+0x2>
   31028:	50 91 da 23 	lds	r21, 0x23DA	; 0x8023da <ticks_1ms+0x3>
   3102c:	60 91 db 23 	lds	r22, 0x23DB	; 0x8023db <ticks_1ms+0x4>
   31030:	70 91 dc 23 	lds	r23, 0x23DC	; 0x8023dc <ticks_1ms+0x5>
   31034:	80 91 dd 23 	lds	r24, 0x23DD	; 0x8023dd <ticks_1ms+0x6>
   31038:	90 91 de 23 	lds	r25, 0x23DE	; 0x8023de <ticks_1ms+0x7>
   3103c:	d4 d3       	rcall	.+1960   	; 0x317e6 <__adddi3_s8>
   3103e:	20 93 d7 23 	sts	0x23D7, r18	; 0x8023d7 <ticks_1ms>
   31042:	30 93 d8 23 	sts	0x23D8, r19	; 0x8023d8 <ticks_1ms+0x1>
   31046:	40 93 d9 23 	sts	0x23D9, r20	; 0x8023d9 <ticks_1ms+0x2>
   3104a:	50 93 da 23 	sts	0x23DA, r21	; 0x8023da <ticks_1ms+0x3>
   3104e:	60 93 db 23 	sts	0x23DB, r22	; 0x8023db <ticks_1ms+0x4>
   31052:	70 93 dc 23 	sts	0x23DC, r23	; 0x8023dc <ticks_1ms+0x5>
   31056:	80 93 dd 23 	sts	0x23DD, r24	; 0x8023dd <ticks_1ms+0x6>
   3105a:	90 93 de 23 	sts	0x23DE, r25	; 0x8023de <ticks_1ms+0x7>
		c = 0;
   3105e:	10 92 d6 23 	sts	0x23D6, r1	; 0x8023d6 <c.3722>
	}
}
   31062:	af 91       	pop	r26
   31064:	9f 91       	pop	r25
   31066:	8f 91       	pop	r24
   31068:	7f 91       	pop	r23
   3106a:	6f 91       	pop	r22
   3106c:	5f 91       	pop	r21
   3106e:	4f 91       	pop	r20
   31070:	3f 91       	pop	r19
   31072:	2f 91       	pop	r18
   31074:	0f 90       	pop	r0
   31076:	0f be       	out	0x3f, r0	; 63
   31078:	0f 90       	pop	r0
   3107a:	1f 90       	pop	r1
   3107c:	18 95       	reti

0003107e <main>:

int main(void)
{		
   3107e:	2f 92       	push	r2
   31080:	3f 92       	push	r3
   31082:	4f 92       	push	r4
   31084:	5f 92       	push	r5
   31086:	6f 92       	push	r6
   31088:	7f 92       	push	r7
   3108a:	8f 92       	push	r8
   3108c:	9f 92       	push	r9
   3108e:	af 92       	push	r10
   31090:	bf 92       	push	r11
   31092:	cf 92       	push	r12
   31094:	df 92       	push	r13
   31096:	ef 92       	push	r14
   31098:	ff 92       	push	r15
   3109a:	0f 93       	push	r16
   3109c:	1f 93       	push	r17
   3109e:	cf 93       	push	r28
   310a0:	df 93       	push	r29
   310a2:	cd b7       	in	r28, 0x3d	; 61
   310a4:	de b7       	in	r29, 0x3e	; 62
   310a6:	a9 97       	sbiw	r28, 0x29	; 41
   310a8:	cd bf       	out	0x3d, r28	; 61
   310aa:	de bf       	out	0x3e, r29	; 62
	
	// Set 32 mhz clock
	CCP = CCP_IOREG_gc;
   310ac:	88 ed       	ldi	r24, 0xD8	; 216
   310ae:	84 bf       	out	0x34, r24	; 52
	OSC.CTRL = OSC_RC32MEN_bm;
   310b0:	82 e0       	ldi	r24, 0x02	; 2
   310b2:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
	while(!(OSC.STATUS & OSC_RC32MRDY_bm));
   310b6:	e0 e5       	ldi	r30, 0x50	; 80
   310b8:	f0 e0       	ldi	r31, 0x00	; 0
   310ba:	81 81       	ldd	r24, Z+1	; 0x01
   310bc:	81 ff       	sbrs	r24, 1
   310be:	fd cf       	rjmp	.-6      	; 0x310ba <main+0x3c>
	CCP = CCP_IOREG_gc;
   310c0:	88 ed       	ldi	r24, 0xD8	; 216
   310c2:	84 bf       	out	0x34, r24	; 52
	CLK.CTRL = CLK_SCLKSEL_RC32M_gc;	
   310c4:	91 e0       	ldi	r25, 0x01	; 1
   310c6:	90 93 40 00 	sts	0x0040, r25	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>

	// Setup timer that triggers overflow every 100us@32 Mhz
	TCC0.CTRLA = 0x05;
   310ca:	e0 e0       	ldi	r30, 0x00	; 0
   310cc:	f8 e0       	ldi	r31, 0x08	; 8
   310ce:	95 e0       	ldi	r25, 0x05	; 5
   310d0:	90 83       	st	Z, r25
	TCC0.PER = 0x32;
   310d2:	22 e3       	ldi	r18, 0x32	; 50
   310d4:	30 e0       	ldi	r19, 0x00	; 0
   310d6:	26 a3       	std	Z+38, r18	; 0x26
   310d8:	37 a3       	std	Z+39, r19	; 0x27
	TCC0.INTCTRLA = 0b11;
   310da:	93 e0       	ldi	r25, 0x03	; 3
   310dc:	96 83       	std	Z+6, r25	; 0x06
	CCP = CCP_IOREG_gc;
   310de:	84 bf       	out	0x34, r24	; 52
	PMIC.CTRL = PMIC_IVSEL_bm | PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;
   310e0:	87 e4       	ldi	r24, 0x47	; 71
   310e2:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
   310e6:	78 94       	sei
			
	uint8_t t;
				
	spi_init();
   310e8:	6c d3       	rcall	.+1752   	; 0x317c2 <spi_init>
	
	volatile uint8_t crc = 0;
   310ea:	19 82       	std	Y+1, r1	; 0x01
	volatile uint16_t page = 0;
   310ec:	1a 82       	std	Y+2, r1	; 0x02
   310ee:	1b 82       	std	Y+3, r1	; 0x03
	uint8_t data_sequence = 0;
	uint16_t buffer_index;
	volatile uint8_t res, stat;
	CanMessage msg;
	memset(&msg, 0, sizeof(CanMessage));
   310f0:	fe 01       	movw	r30, r28
   310f2:	35 96       	adiw	r30, 0x05	; 5
   310f4:	80 e1       	ldi	r24, 0x10	; 16
   310f6:	df 01       	movw	r26, r30
   310f8:	1d 92       	st	X+, r1
   310fa:	8a 95       	dec	r24
   310fc:	e9 f7       	brne	.-6      	; 0x310f8 <main+0x7a>
		
	unsigned long timeout_ticks = 50;
	
	unsigned int speed = 500;
	
	volatile uint16_t lastPage = -1;
   310fe:	8f ef       	ldi	r24, 0xFF	; 255
   31100:	9f ef       	ldi	r25, 0xFF	; 255
   31102:	89 8f       	std	Y+25, r24	; 0x19
   31104:	9a 8f       	std	Y+26, r25	; 0x1a
	
	res = mcp2515_init(500);
   31106:	84 ef       	ldi	r24, 0xF4	; 244
   31108:	91 e0       	ldi	r25, 0x01	; 1
   3110a:	c0 de       	rcall	.-640    	; 0x30e8c <mcp2515_init>
   3110c:	8c 83       	std	Y+4, r24	; 0x04
	if (res == MCP2515_OK) 
   3110e:	8c 81       	ldd	r24, Y+4	; 0x04
   31110:	81 11       	cpse	r24, r1
	{		
		// Set mask & filters to filter out any traffic that does not concern us
		mcp2515_setCANCTRL_Mode(MODE_CONFIG);
   31112:	28 c3       	rjmp	.+1616   	; 0x31764 <main+0x6e6>
   31114:	80 e8       	ldi	r24, 0x80	; 128
   31116:	f9 dc       	rcall	.-1550   	; 0x30b0a <mcp2515_setCANCTRL_Mode>
		mcp2515_write_can_id(MCP_RXM0SIDH, 0, 0x7FF);
   31118:	2f ef       	ldi	r18, 0xFF	; 255
   3111a:	37 e0       	ldi	r19, 0x07	; 7
   3111c:	40 e0       	ldi	r20, 0x00	; 0
   3111e:	50 e0       	ldi	r21, 0x00	; 0
   31120:	60 e0       	ldi	r22, 0x00	; 0
   31122:	80 e2       	ldi	r24, 0x20	; 32
   31124:	cb dd       	rcall	.-1130   	; 0x30cbc <mcp2515_write_can_id>
		mcp2515_write_can_id(MCP_RXM1SIDH, 0, 0x7FF);
   31126:	2f ef       	ldi	r18, 0xFF	; 255
   31128:	37 e0       	ldi	r19, 0x07	; 7
   3112a:	40 e0       	ldi	r20, 0x00	; 0
   3112c:	50 e0       	ldi	r21, 0x00	; 0
   3112e:	60 e0       	ldi	r22, 0x00	; 0
   31130:	84 e2       	ldi	r24, 0x24	; 36
   31132:	c4 dd       	rcall	.-1144   	; 0x30cbc <mcp2515_write_can_id>
		mcp2515_write_can_id(MCP_RXF0SIDH, 0, PC_AVR_CAN_ID);
   31134:	2f ee       	ldi	r18, 0xEF	; 239
   31136:	37 e0       	ldi	r19, 0x07	; 7
   31138:	40 e0       	ldi	r20, 0x00	; 0
   3113a:	50 e0       	ldi	r21, 0x00	; 0
   3113c:	60 e0       	ldi	r22, 0x00	; 0
   3113e:	80 e0       	ldi	r24, 0x00	; 0
		
		if (mcp2515_setCANCTRL_Mode(MODE_NORMAL) == MCP2515_OK)
   31140:	bd dd       	rcall	.-1158   	; 0x30cbc <mcp2515_write_can_id>
   31142:	80 e0       	ldi	r24, 0x00	; 0
   31144:	e2 dc       	rcall	.-1596   	; 0x30b0a <mcp2515_setCANCTRL_Mode>
   31146:	81 11       	cpse	r24, r1
   31148:	0d c3       	rjmp	.+1562   	; 0x31764 <main+0x6e6>
		{			
			ticks_1ms = 0;
   3114a:	10 92 d7 23 	sts	0x23D7, r1	; 0x8023d7 <ticks_1ms>
   3114e:	10 92 d8 23 	sts	0x23D8, r1	; 0x8023d8 <ticks_1ms+0x1>
   31152:	10 92 d9 23 	sts	0x23D9, r1	; 0x8023d9 <ticks_1ms+0x2>
   31156:	10 92 da 23 	sts	0x23DA, r1	; 0x8023da <ticks_1ms+0x3>
   3115a:	10 92 db 23 	sts	0x23DB, r1	; 0x8023db <ticks_1ms+0x4>
   3115e:	10 92 dc 23 	sts	0x23DC, r1	; 0x8023dc <ticks_1ms+0x5>
   31162:	10 92 dd 23 	sts	0x23DD, r1	; 0x8023dd <ticks_1ms+0x6>
   31166:	10 92 de 23 	sts	0x23DE, r1	; 0x8023de <ticks_1ms+0x7>
	
	uint8_t success;
		
	unsigned long timeout_ticks = 50;
	
	unsigned int speed = 500;
   3116a:	0f 2e       	mov	r0, r31
   3116c:	f4 ef       	ldi	r31, 0xF4	; 244
   3116e:	2f 2e       	mov	r2, r31
   31170:	33 24       	eor	r3, r3
   31172:	33 94       	inc	r3
   31174:	f0 2d       	mov	r31, r0
	
	uint8_t authorized = 0;
	
	uint8_t success;
		
	unsigned long timeout_ticks = 50;
   31176:	0f 2e       	mov	r0, r31
   31178:	f2 e3       	ldi	r31, 0x32	; 50
   3117a:	4f 2e       	mov	r4, r31
   3117c:	51 2c       	mov	r5, r1
   3117e:	61 2c       	mov	r6, r1
   31180:	71 2c       	mov	r7, r1
   31182:	f0 2d       	mov	r31, r0
	memset(&msg, 0, sizeof(CanMessage));
	
	uint8_t firmware[4];
	uint8_t firmware_valid = 0;
	
	uint8_t authorized = 0;
   31184:	91 2c       	mov	r9, r1
	volatile uint8_t res, stat;
	CanMessage msg;
	memset(&msg, 0, sizeof(CanMessage));
	
	uint8_t firmware[4];
	uint8_t firmware_valid = 0;
   31186:	19 a6       	std	Y+41, r1	; 0x29
				
	spi_init();
	
	volatile uint8_t crc = 0;
	volatile uint16_t page = 0;
	uint8_t data_sequence = 0;
   31188:	81 2c       	mov	r8, r1
   3118a:	05 c0       	rjmp	.+10     	; 0x31196 <main+0x118>
						switch(msg.dta[0])
						{
							case 0x99: // LOGIN <device_id> <code>, returns: 0x99 <authorized[1/0]> <device_id> <device_firmware_valid[1/0]> <device_firmware1> <device_firmware2> <device_firmware3> <device_firmware4>
								if (msg.dta[1] == DEVICE_ID && msg.dta[2] == DEVICE_CODE)
								{
									authorized = 1;								
   3118c:	99 24       	eor	r9, r9
   3118e:	93 94       	inc	r9
   31190:	02 c0       	rjmp	.+4      	; 0x31196 <main+0x118>
   31192:	2f a3       	std	Y+39, r18	; 0x27
   31194:	38 a7       	std	Y+40, r19	; 0x28
		{			
			ticks_1ms = 0;
			while(1)
			{
				// if device is not authorized within first 50ms, try different speed (100). Exit at 100ms.
				if (!authorized && ticks_1ms >= timeout_ticks)
   31196:	91 10       	cpse	r9, r1
   31198:	65 c0       	rjmp	.+202    	; 0x31264 <main+0x1e6>
   3119a:	a0 90 d7 23 	lds	r10, 0x23D7	; 0x8023d7 <ticks_1ms>
   3119e:	b0 90 d8 23 	lds	r11, 0x23D8	; 0x8023d8 <ticks_1ms+0x1>
   311a2:	c0 90 d9 23 	lds	r12, 0x23D9	; 0x8023d9 <ticks_1ms+0x2>
   311a6:	d0 90 da 23 	lds	r13, 0x23DA	; 0x8023da <ticks_1ms+0x3>
   311aa:	e0 90 db 23 	lds	r14, 0x23DB	; 0x8023db <ticks_1ms+0x4>
   311ae:	f0 90 dc 23 	lds	r15, 0x23DC	; 0x8023dc <ticks_1ms+0x5>
   311b2:	00 91 dd 23 	lds	r16, 0x23DD	; 0x8023dd <ticks_1ms+0x6>
   311b6:	10 91 de 23 	lds	r17, 0x23DE	; 0x8023de <ticks_1ms+0x7>
   311ba:	a3 01       	movw	r20, r6
   311bc:	92 01       	movw	r18, r4
   311be:	60 e0       	ldi	r22, 0x00	; 0
   311c0:	70 e0       	ldi	r23, 0x00	; 0
   311c2:	cb 01       	movw	r24, r22
   311c4:	4f 8e       	std	Y+31, r4	; 0x1f
   311c6:	38 a3       	std	Y+32, r19	; 0x20
   311c8:	49 a3       	std	Y+33, r20	; 0x21
   311ca:	5a a3       	std	Y+34, r21	; 0x22
   311cc:	6b a3       	std	Y+35, r22	; 0x23
   311ce:	7c a3       	std	Y+36, r23	; 0x24
   311d0:	8d a3       	std	Y+37, r24	; 0x25
   311d2:	9e a3       	std	Y+38, r25	; 0x26
   311d4:	60 e0       	ldi	r22, 0x00	; 0
   311d6:	70 e0       	ldi	r23, 0x00	; 0
   311d8:	80 e0       	ldi	r24, 0x00	; 0
   311da:	90 e0       	ldi	r25, 0x00	; 0
   311dc:	10 d3       	rcall	.+1568   	; 0x317fe <__cmpdi2>
   311de:	11 f0       	breq	.+4      	; 0x311e4 <main+0x166>
   311e0:	08 f0       	brcs	.+2      	; 0x311e4 <main+0x166>
   311e2:	40 c0       	rjmp	.+128    	; 0x31264 <main+0x1e6>
				{
					if (speed == 500)
   311e4:	34 ef       	ldi	r19, 0xF4	; 244
   311e6:	23 16       	cp	r2, r19
   311e8:	31 e0       	ldi	r19, 0x01	; 1
   311ea:	33 06       	cpc	r3, r19
					{
						speed = 1000;
						res = mcp2515_init(speed);
   311ec:	09 f0       	breq	.+2      	; 0x311f0 <main+0x172>
   311ee:	ba c2       	rjmp	.+1396   	; 0x31764 <main+0x6e6>
   311f0:	88 ee       	ldi	r24, 0xE8	; 232
   311f2:	93 e0       	ldi	r25, 0x03	; 3
						// Set mask & filters to filter out any traffic that does not concern us
						mcp2515_setCANCTRL_Mode(MODE_CONFIG);
   311f4:	4b de       	rcall	.-874    	; 0x30e8c <mcp2515_init>
   311f6:	8c 83       	std	Y+4, r24	; 0x04
   311f8:	80 e8       	ldi	r24, 0x80	; 128
						mcp2515_write_can_id(MCP_RXM0SIDH, 0, 0x7FF);
   311fa:	87 dc       	rcall	.-1778   	; 0x30b0a <mcp2515_setCANCTRL_Mode>
   311fc:	2f ef       	ldi	r18, 0xFF	; 255
   311fe:	37 e0       	ldi	r19, 0x07	; 7
   31200:	40 e0       	ldi	r20, 0x00	; 0
   31202:	50 e0       	ldi	r21, 0x00	; 0
   31204:	60 e0       	ldi	r22, 0x00	; 0
   31206:	80 e2       	ldi	r24, 0x20	; 32
						mcp2515_write_can_id(MCP_RXM1SIDH, 0, 0x7FF);
   31208:	59 dd       	rcall	.-1358   	; 0x30cbc <mcp2515_write_can_id>
   3120a:	2f ef       	ldi	r18, 0xFF	; 255
   3120c:	37 e0       	ldi	r19, 0x07	; 7
   3120e:	40 e0       	ldi	r20, 0x00	; 0
   31210:	50 e0       	ldi	r21, 0x00	; 0
   31212:	60 e0       	ldi	r22, 0x00	; 0
						mcp2515_write_can_id(MCP_RXF0SIDH, 0, PC_AVR_CAN_ID);
   31214:	84 e2       	ldi	r24, 0x24	; 36
   31216:	52 dd       	rcall	.-1372   	; 0x30cbc <mcp2515_write_can_id>
   31218:	2f ee       	ldi	r18, 0xEF	; 239
   3121a:	37 e0       	ldi	r19, 0x07	; 7
   3121c:	40 e0       	ldi	r20, 0x00	; 0
   3121e:	50 e0       	ldi	r21, 0x00	; 0
   31220:	60 e0       	ldi	r22, 0x00	; 0
   31222:	80 e0       	ldi	r24, 0x00	; 0
						mcp2515_setCANCTRL_Mode(MODE_NORMAL);
   31224:	4b dd       	rcall	.-1386   	; 0x30cbc <mcp2515_write_can_id>
   31226:	80 e0       	ldi	r24, 0x00	; 0
   31228:	70 dc       	rcall	.-1824   	; 0x30b0a <mcp2515_setCANCTRL_Mode>
						timeout_ticks = ticks_1ms + 50;
   3122a:	00 91 d7 23 	lds	r16, 0x23D7	; 0x8023d7 <ticks_1ms>
   3122e:	10 91 d8 23 	lds	r17, 0x23D8	; 0x8023d8 <ticks_1ms+0x1>
   31232:	20 91 d9 23 	lds	r18, 0x23D9	; 0x8023d9 <ticks_1ms+0x2>
   31236:	30 91 da 23 	lds	r19, 0x23DA	; 0x8023da <ticks_1ms+0x3>
   3123a:	40 91 db 23 	lds	r20, 0x23DB	; 0x8023db <ticks_1ms+0x4>
   3123e:	50 91 dc 23 	lds	r21, 0x23DC	; 0x8023dc <ticks_1ms+0x5>
   31242:	60 91 dd 23 	lds	r22, 0x23DD	; 0x8023dd <ticks_1ms+0x6>
   31246:	70 91 de 23 	lds	r23, 0x23DE	; 0x8023de <ticks_1ms+0x7>
   3124a:	28 01       	movw	r4, r16
   3124c:	39 01       	movw	r6, r18
   3124e:	82 e3       	ldi	r24, 0x32	; 50
   31250:	48 0e       	add	r4, r24
   31252:	51 1c       	adc	r5, r1
   31254:	61 1c       	adc	r6, r1
				// if device is not authorized within first 50ms, try different speed (100). Exit at 100ms.
				if (!authorized && ticks_1ms >= timeout_ticks)
				{
					if (speed == 500)
					{
						speed = 1000;
   31256:	71 1c       	adc	r7, r1
   31258:	0f 2e       	mov	r0, r31
   3125a:	f8 ee       	ldi	r31, 0xE8	; 232
   3125c:	2f 2e       	mov	r2, r31
   3125e:	f3 e0       	ldi	r31, 0x03	; 3
   31260:	3f 2e       	mov	r3, r31
					}
					else // all speeds tested
						break;
				}

				if (can_read(&msg))
   31262:	f0 2d       	mov	r31, r0
   31264:	ce 01       	movw	r24, r28
   31266:	05 96       	adiw	r24, 0x05	; 5
   31268:	59 de       	rcall	.-846    	; 0x30f1c <can_read>
   3126a:	88 23       	and	r24, r24
   3126c:	09 f4       	brne	.+2      	; 0x31270 <main+0x1f2>
   3126e:	93 cf       	rjmp	.-218    	; 0x31196 <main+0x118>
				{
					if (msg.identifier == PC_AVR_CAN_ID)
   31270:	8e 81       	ldd	r24, Y+6	; 0x06
   31272:	9f 81       	ldd	r25, Y+7	; 0x07
   31274:	a8 85       	ldd	r26, Y+8	; 0x08
   31276:	b9 85       	ldd	r27, Y+9	; 0x09
   31278:	8f 3e       	cpi	r24, 0xEF	; 239
   3127a:	97 40       	sbci	r25, 0x07	; 7
   3127c:	a1 05       	cpc	r26, r1
   3127e:	b1 05       	cpc	r27, r1
   31280:	09 f0       	breq	.+2      	; 0x31284 <main+0x206>
   31282:	89 cf       	rjmp	.-238    	; 0x31196 <main+0x118>
					{
						switch(msg.dta[0])
   31284:	8b 85       	ldd	r24, Y+11	; 0x0b
   31286:	84 30       	cpi	r24, 0x04	; 4
   31288:	09 f4       	brne	.+2      	; 0x3128c <main+0x20e>
   3128a:	5a c1       	rjmp	.+692    	; 0x31540 <main+0x4c2>
   3128c:	48 f4       	brcc	.+18     	; 0x312a0 <main+0x222>
   3128e:	82 30       	cpi	r24, 0x02	; 2
   31290:	09 f4       	brne	.+2      	; 0x31294 <main+0x216>
   31292:	5d c0       	rjmp	.+186    	; 0x3134e <main+0x2d0>
   31294:	08 f0       	brcs	.+2      	; 0x31298 <main+0x21a>
   31296:	89 c0       	rjmp	.+274    	; 0x313aa <main+0x32c>
   31298:	81 30       	cpi	r24, 0x01	; 1
   3129a:	09 f4       	brne	.+2      	; 0x3129e <main+0x220>
   3129c:	41 c0       	rjmp	.+130    	; 0x31320 <main+0x2a2>
   3129e:	7b cf       	rjmp	.-266    	; 0x31196 <main+0x118>
   312a0:	80 32       	cpi	r24, 0x20	; 32
   312a2:	09 f4       	brne	.+2      	; 0x312a6 <main+0x228>
   312a4:	43 c2       	rjmp	.+1158   	; 0x3172c <main+0x6ae>
   312a6:	20 f4       	brcc	.+8      	; 0x312b0 <main+0x232>
   312a8:	80 31       	cpi	r24, 0x10	; 16
   312aa:	09 f4       	brne	.+2      	; 0x312ae <main+0x230>
   312ac:	d3 c1       	rjmp	.+934    	; 0x31654 <main+0x5d6>
   312ae:	73 cf       	rjmp	.-282    	; 0x31196 <main+0x118>
   312b0:	83 33       	cpi	r24, 0x33	; 51
   312b2:	09 f4       	brne	.+2      	; 0x312b6 <main+0x238>
   312b4:	ec c0       	rjmp	.+472    	; 0x3148e <main+0x410>
   312b6:	89 39       	cpi	r24, 0x99	; 153
   312b8:	09 f0       	breq	.+2      	; 0x312bc <main+0x23e>
						{
							case 0x99: // LOGIN <device_id> <code>, returns: 0x99 <authorized[1/0]> <device_id> <device_firmware_valid[1/0]> <device_firmware1> <device_firmware2> <device_firmware3> <device_firmware4>
								if (msg.dta[1] == DEVICE_ID && msg.dta[2] == DEVICE_CODE)
   312ba:	6d cf       	rjmp	.-294    	; 0x31196 <main+0x118>
   312bc:	8c 85       	ldd	r24, Y+12	; 0x0c
   312be:	80 35       	cpi	r24, 0x50	; 80
   312c0:	09 f0       	breq	.+2      	; 0x312c4 <main+0x246>
   312c2:	69 cf       	rjmp	.-302    	; 0x31196 <main+0x118>
   312c4:	8d 85       	ldd	r24, Y+13	; 0x0d
   312c6:	83 32       	cpi	r24, 0x23	; 35
								{
									authorized = 1;								
									firmware_valid = firmware_read(&firmware);
   312c8:	51 f4       	brne	.+20     	; 0x312de <main+0x260>
   312ca:	ce 01       	movw	r24, r28
   312cc:	45 96       	adiw	r24, 0x15	; 21
   312ce:	4a de       	rcall	.-876    	; 0x30f64 <firmware_read>
   312d0:	89 a7       	std	Y+41, r24	; 0x29
								}
								
								if (msg.dta[1] == DEVICE_ID)
   312d2:	8c 85       	ldd	r24, Y+12	; 0x0c
   312d4:	80 35       	cpi	r24, 0x50	; 80
   312d6:	09 f0       	breq	.+2      	; 0x312da <main+0x25c>
   312d8:	59 cf       	rjmp	.-334    	; 0x3118c <main+0x10e>
						switch(msg.dta[0])
						{
							case 0x99: // LOGIN <device_id> <code>, returns: 0x99 <authorized[1/0]> <device_id> <device_firmware_valid[1/0]> <device_firmware1> <device_firmware2> <device_firmware3> <device_firmware4>
								if (msg.dta[1] == DEVICE_ID && msg.dta[2] == DEVICE_CODE)
								{
									authorized = 1;								
   312da:	99 24       	eor	r9, r9
   312dc:	93 94       	inc	r9
									firmware_valid = firmware_read(&firmware);
								}
								
								if (msg.dta[1] == DEVICE_ID)
								{
									msg.identifier = AVR_PC_CAN_ID;
   312de:	8f ef       	ldi	r24, 0xFF	; 255
   312e0:	97 e0       	ldi	r25, 0x07	; 7
   312e2:	a0 e0       	ldi	r26, 0x00	; 0
   312e4:	b0 e0       	ldi	r27, 0x00	; 0
   312e6:	8e 83       	std	Y+6, r24	; 0x06
   312e8:	9f 83       	std	Y+7, r25	; 0x07
   312ea:	a8 87       	std	Y+8, r26	; 0x08
   312ec:	b9 87       	std	Y+9, r27	; 0x09
									msg.dlc = 8;
   312ee:	f8 e0       	ldi	r31, 0x08	; 8
   312f0:	fa 87       	std	Y+10, r31	; 0x0a
									msg.dta[0] = 0x99;
   312f2:	29 e9       	ldi	r18, 0x99	; 153
   312f4:	2b 87       	std	Y+11, r18	; 0x0b
									msg.dta[1] = authorized ? 1: 0;
   312f6:	81 e0       	ldi	r24, 0x01	; 1
   312f8:	91 10       	cpse	r9, r1
   312fa:	01 c0       	rjmp	.+2      	; 0x312fe <main+0x280>
   312fc:	80 e0       	ldi	r24, 0x00	; 0
									msg.dta[2] = DEVICE_ID;
   312fe:	8c 87       	std	Y+12, r24	; 0x0c
   31300:	30 e5       	ldi	r19, 0x50	; 80
									msg.dta[3] = firmware_valid;
   31302:	3d 87       	std	Y+13, r19	; 0x0d
   31304:	49 a5       	ldd	r20, Y+41	; 0x29
									msg.dta[4] = firmware[0];
   31306:	4e 87       	std	Y+14, r20	; 0x0e
									msg.dta[5] = firmware[1];
   31308:	8d 89       	ldd	r24, Y+21	; 0x15
   3130a:	8f 87       	std	Y+15, r24	; 0x0f
									msg.dta[6] = firmware[2];
   3130c:	8e 89       	ldd	r24, Y+22	; 0x16
   3130e:	88 8b       	std	Y+16, r24	; 0x10
									msg.dta[7] = firmware[3];
   31310:	8f 89       	ldd	r24, Y+23	; 0x17
   31312:	89 8b       	std	Y+17, r24	; 0x11
									can_send(&msg);
   31314:	88 8d       	ldd	r24, Y+24	; 0x18
   31316:	8a 8b       	std	Y+18, r24	; 0x12
   31318:	ce 01       	movw	r24, r28
   3131a:	05 96       	adiw	r24, 0x05	; 5
   3131c:	e4 dd       	rcall	.-1080   	; 0x30ee6 <can_send>
								}
								break;
							
							case 0x1: // ERASE_FIRMWARE, returns 0x1 <success[1]>
								if (authorized)
   3131e:	3b cf       	rjmp	.-394    	; 0x31196 <main+0x118>
   31320:	99 20       	and	r9, r9
   31322:	09 f4       	brne	.+2      	; 0x31326 <main+0x2a8>
								{
									SP_EraseApplicationSection();
   31324:	38 cf       	rjmp	.-400    	; 0x31196 <main+0x118>
   31326:	0f 94 48 81 	call	0x30290	; 0x30290 <SP_EraseApplicationSection>
									SP_WaitForSPM();
							
									msg.identifier = AVR_PC_CAN_ID;
   3132a:	0c d8       	rcall	.-4072   	; 0x30344 <SP_WaitForSPM>
   3132c:	8f ef       	ldi	r24, 0xFF	; 255
   3132e:	97 e0       	ldi	r25, 0x07	; 7
   31330:	a0 e0       	ldi	r26, 0x00	; 0
   31332:	b0 e0       	ldi	r27, 0x00	; 0
   31334:	8e 83       	std	Y+6, r24	; 0x06
   31336:	9f 83       	std	Y+7, r25	; 0x07
   31338:	a8 87       	std	Y+8, r26	; 0x08
									msg.dlc = 2;
   3133a:	b9 87       	std	Y+9, r27	; 0x09
   3133c:	52 e0       	ldi	r21, 0x02	; 2
									msg.dta[0] = 1;
   3133e:	5a 87       	std	Y+10, r21	; 0x0a
   31340:	81 e0       	ldi	r24, 0x01	; 1
									msg.dta[1] = 1;
   31342:	8b 87       	std	Y+11, r24	; 0x0b
									can_send(&msg);
   31344:	8c 87       	std	Y+12, r24	; 0x0c
   31346:	ce 01       	movw	r24, r28
   31348:	05 96       	adiw	r24, 0x05	; 5
   3134a:	cd dd       	rcall	.-1126   	; 0x30ee6 <can_send>
   3134c:	24 cf       	rjmp	.-440    	; 0x31196 <main+0x118>
								}
								break;
							
							case 0x2: // SET_PAGE <pageH> <pageL> (first page = 0), returns 0x2 <success[1]> <pageH> <pageL>
								if (authorized)
   3134e:	99 20       	and	r9, r9
   31350:	09 f4       	brne	.+2      	; 0x31354 <main+0x2d6>
   31352:	21 cf       	rjmp	.-446    	; 0x31196 <main+0x118>
								{
									page = ((int)msg.dta[1] << 8) + msg.dta[2];
   31354:	8c 85       	ldd	r24, Y+12	; 0x0c
   31356:	90 e0       	ldi	r25, 0x00	; 0
   31358:	98 2f       	mov	r25, r24
   3135a:	88 27       	eor	r24, r24
   3135c:	2d 85       	ldd	r18, Y+13	; 0x0d
   3135e:	82 0f       	add	r24, r18
   31360:	91 1d       	adc	r25, r1
   31362:	8a 83       	std	Y+2, r24	; 0x02
   31364:	9b 83       	std	Y+3, r25	; 0x03
								
									data_sequence = 0;
									buffer_index = 0;
									memset(&buffer, 0, sizeof(buffer));
   31366:	a7 ee       	ldi	r26, 0xE7	; 231
   31368:	b3 e2       	ldi	r27, 0x23	; 35
   3136a:	e0 e0       	ldi	r30, 0x00	; 0
   3136c:	f2 e0       	ldi	r31, 0x02	; 2
   3136e:	1d 92       	st	X+, r1
   31370:	31 97       	sbiw	r30, 0x01	; 1
   31372:	e9 f7       	brne	.-6      	; 0x3136e <main+0x2f0>
									
									msg.identifier = AVR_PC_CAN_ID;
   31374:	8f ef       	ldi	r24, 0xFF	; 255
   31376:	97 e0       	ldi	r25, 0x07	; 7
   31378:	a0 e0       	ldi	r26, 0x00	; 0
   3137a:	b0 e0       	ldi	r27, 0x00	; 0
   3137c:	8e 83       	std	Y+6, r24	; 0x06
   3137e:	9f 83       	std	Y+7, r25	; 0x07
   31380:	a8 87       	std	Y+8, r26	; 0x08
									msg.dlc = 4;
   31382:	b9 87       	std	Y+9, r27	; 0x09
   31384:	f4 e0       	ldi	r31, 0x04	; 4
									msg.dta[0] = 0x2;
   31386:	fa 87       	std	Y+10, r31	; 0x0a
   31388:	22 e0       	ldi	r18, 0x02	; 2
									msg.dta[1] = 1;
   3138a:	2b 87       	std	Y+11, r18	; 0x0b
   3138c:	81 e0       	ldi	r24, 0x01	; 1
									msg.dta[2] = (page >> 8);
   3138e:	8c 87       	std	Y+12, r24	; 0x0c
   31390:	8a 81       	ldd	r24, Y+2	; 0x02
   31392:	9b 81       	ldd	r25, Y+3	; 0x03
									msg.dta[3] = page;
   31394:	9d 87       	std	Y+13, r25	; 0x0d
   31396:	8a 81       	ldd	r24, Y+2	; 0x02
   31398:	9b 81       	ldd	r25, Y+3	; 0x03
									can_send(&msg);
   3139a:	8e 87       	std	Y+14, r24	; 0x0e
   3139c:	ce 01       	movw	r24, r28
   3139e:	05 96       	adiw	r24, 0x05	; 5
   313a0:	a2 dd       	rcall	.-1212   	; 0x30ee6 <can_send>
								if (authorized)
								{
									page = ((int)msg.dta[1] << 8) + msg.dta[2];
								
									data_sequence = 0;
									buffer_index = 0;
   313a2:	1f a2       	std	Y+39, r1	; 0x27
   313a4:	18 a6       	std	Y+40, r1	; 0x28
							case 0x2: // SET_PAGE <pageH> <pageL> (first page = 0), returns 0x2 <success[1]> <pageH> <pageL>
								if (authorized)
								{
									page = ((int)msg.dta[1] << 8) + msg.dta[2];
								
									data_sequence = 0;
   313a6:	81 2c       	mov	r8, r1
   313a8:	f6 ce       	rjmp	.-532    	; 0x31196 <main+0x118>
									can_send(&msg);
								}
								break;
							
							case 0x3: // ADD_PAGE_DATA <sequence> <b1> [<b2>] [<b3>] [<b4>] [<b5>] [<b6>], return 0x3 <success[1/0]> <buf_indexH> <buf_indexL> <sequence + 1>
								if (authorized && msg.dlc >= 3)
   313aa:	99 20       	and	r9, r9
   313ac:	09 f4       	brne	.+2      	; 0x313b0 <main+0x332>
   313ae:	f3 ce       	rjmp	.-538    	; 0x31196 <main+0x118>
   313b0:	8a 85       	ldd	r24, Y+10	; 0x0a
   313b2:	83 30       	cpi	r24, 0x03	; 3
   313b4:	08 f4       	brcc	.+2      	; 0x313b8 <main+0x33a>
   313b6:	ef ce       	rjmp	.-546    	; 0x31196 <main+0x118>
								{
									uint8_t seq = msg.dta[1];
								
									success = 0;								
									if (seq == data_sequence && (buffer_index + msg.dlc - 2 <= sizeof(buffer)))
   313b8:	9c 85       	ldd	r25, Y+12	; 0x0c
   313ba:	89 12       	cpse	r8, r25
   313bc:	4b c0       	rjmp	.+150    	; 0x31454 <main+0x3d6>
   313be:	28 2f       	mov	r18, r24
   313c0:	30 e0       	ldi	r19, 0x00	; 0
   313c2:	22 50       	subi	r18, 0x02	; 2
   313c4:	31 09       	sbc	r19, r1
   313c6:	4f a1       	ldd	r20, Y+39	; 0x27
   313c8:	58 a5       	ldd	r21, Y+40	; 0x28
   313ca:	24 0f       	add	r18, r20
   313cc:	35 1f       	adc	r19, r21
   313ce:	21 30       	cpi	r18, 0x01	; 1
   313d0:	32 40       	sbci	r19, 0x02	; 2
   313d2:	08 f0       	brcs	.+2      	; 0x313d6 <main+0x358>
   313d4:	41 c0       	rjmp	.+130    	; 0x31458 <main+0x3da>
									{
										++data_sequence;
   313d6:	83 94       	inc	r8
									
										buffer[buffer_index++] = msg.dta[2];
   313d8:	2f a1       	ldd	r18, Y+39	; 0x27
   313da:	38 a5       	ldd	r19, Y+40	; 0x28
   313dc:	2f 5f       	subi	r18, 0xFF	; 255
   313de:	3f 4f       	sbci	r19, 0xFF	; 255
   313e0:	9d 85       	ldd	r25, Y+13	; 0x0d
   313e2:	ef a1       	ldd	r30, Y+39	; 0x27
   313e4:	f8 a5       	ldd	r31, Y+40	; 0x28
   313e6:	e9 51       	subi	r30, 0x19	; 25
   313e8:	fc 4d       	sbci	r31, 0xDC	; 220
   313ea:	90 83       	st	Z, r25
										if (msg.dlc >= 4) buffer[buffer_index++] = msg.dta[3];
   313ec:	84 30       	cpi	r24, 0x04	; 4
   313ee:	48 f0       	brcs	.+18     	; 0x31402 <main+0x384>
   313f0:	9e 85       	ldd	r25, Y+14	; 0x0e
   313f2:	f9 01       	movw	r30, r18
   313f4:	e9 51       	subi	r30, 0x19	; 25
   313f6:	fc 4d       	sbci	r31, 0xDC	; 220
   313f8:	90 83       	st	Z, r25
   313fa:	2f a1       	ldd	r18, Y+39	; 0x27
   313fc:	38 a5       	ldd	r19, Y+40	; 0x28
   313fe:	2e 5f       	subi	r18, 0xFE	; 254
   31400:	3f 4f       	sbci	r19, 0xFF	; 255
										if (msg.dlc >= 5) buffer[buffer_index++] = msg.dta[4];
   31402:	85 30       	cpi	r24, 0x05	; 5
   31404:	38 f0       	brcs	.+14     	; 0x31414 <main+0x396>
   31406:	9f 85       	ldd	r25, Y+15	; 0x0f
   31408:	f9 01       	movw	r30, r18
   3140a:	e9 51       	subi	r30, 0x19	; 25
   3140c:	fc 4d       	sbci	r31, 0xDC	; 220
   3140e:	90 83       	st	Z, r25
   31410:	2f 5f       	subi	r18, 0xFF	; 255
   31412:	3f 4f       	sbci	r19, 0xFF	; 255
										if (msg.dlc >= 6) buffer[buffer_index++] = msg.dta[5];
   31414:	86 30       	cpi	r24, 0x06	; 6
   31416:	38 f0       	brcs	.+14     	; 0x31426 <main+0x3a8>
   31418:	98 89       	ldd	r25, Y+16	; 0x10
   3141a:	f9 01       	movw	r30, r18
   3141c:	e9 51       	subi	r30, 0x19	; 25
   3141e:	fc 4d       	sbci	r31, 0xDC	; 220
   31420:	90 83       	st	Z, r25
   31422:	2f 5f       	subi	r18, 0xFF	; 255
   31424:	3f 4f       	sbci	r19, 0xFF	; 255
										if (msg.dlc >= 7) buffer[buffer_index++] = msg.dta[6];
   31426:	87 30       	cpi	r24, 0x07	; 7
   31428:	38 f0       	brcs	.+14     	; 0x31438 <main+0x3ba>
   3142a:	99 89       	ldd	r25, Y+17	; 0x11
   3142c:	f9 01       	movw	r30, r18
   3142e:	e9 51       	subi	r30, 0x19	; 25
   31430:	fc 4d       	sbci	r31, 0xDC	; 220
   31432:	90 83       	st	Z, r25
   31434:	2f 5f       	subi	r18, 0xFF	; 255
   31436:	3f 4f       	sbci	r19, 0xFF	; 255
										if (msg.dlc == 8) buffer[buffer_index++] = msg.dta[7];
   31438:	88 30       	cpi	r24, 0x08	; 8
   3143a:	81 f4       	brne	.+32     	; 0x3145c <main+0x3de>
   3143c:	b9 01       	movw	r22, r18
   3143e:	6f 5f       	subi	r22, 0xFF	; 255
   31440:	7f 4f       	sbci	r23, 0xFF	; 255
   31442:	6f a3       	std	Y+39, r22	; 0x27
   31444:	78 a7       	std	Y+40, r23	; 0x28
   31446:	8a 89       	ldd	r24, Y+18	; 0x12
   31448:	f9 01       	movw	r30, r18
   3144a:	e9 51       	subi	r30, 0x19	; 25
   3144c:	fc 4d       	sbci	r31, 0xDC	; 220
   3144e:	80 83       	st	Z, r24
									
										success = 1;
   31450:	81 e0       	ldi	r24, 0x01	; 1
   31452:	07 c0       	rjmp	.+14     	; 0x31462 <main+0x3e4>
							case 0x3: // ADD_PAGE_DATA <sequence> <b1> [<b2>] [<b3>] [<b4>] [<b5>] [<b6>], return 0x3 <success[1/0]> <buf_indexH> <buf_indexL> <sequence + 1>
								if (authorized && msg.dlc >= 3)
								{
									uint8_t seq = msg.dta[1];
								
									success = 0;								
   31454:	80 e0       	ldi	r24, 0x00	; 0
   31456:	05 c0       	rjmp	.+10     	; 0x31462 <main+0x3e4>
   31458:	80 e0       	ldi	r24, 0x00	; 0
   3145a:	03 c0       	rjmp	.+6      	; 0x31462 <main+0x3e4>
   3145c:	2f a3       	std	Y+39, r18	; 0x27
   3145e:	38 a7       	std	Y+40, r19	; 0x28
										if (msg.dlc >= 5) buffer[buffer_index++] = msg.dta[4];
										if (msg.dlc >= 6) buffer[buffer_index++] = msg.dta[5];
										if (msg.dlc >= 7) buffer[buffer_index++] = msg.dta[6];
										if (msg.dlc == 8) buffer[buffer_index++] = msg.dta[7];
									
										success = 1;
   31460:	81 e0       	ldi	r24, 0x01	; 1
									}
																
									msg.identifier = AVR_PC_CAN_ID;
   31462:	4f ef       	ldi	r20, 0xFF	; 255
   31464:	57 e0       	ldi	r21, 0x07	; 7
   31466:	60 e0       	ldi	r22, 0x00	; 0
   31468:	70 e0       	ldi	r23, 0x00	; 0
   3146a:	4e 83       	std	Y+6, r20	; 0x06
   3146c:	5f 83       	std	Y+7, r21	; 0x07
   3146e:	68 87       	std	Y+8, r22	; 0x08
									msg.dlc = 5;
   31470:	79 87       	std	Y+9, r23	; 0x09
   31472:	95 e0       	ldi	r25, 0x05	; 5
									msg.dta[0] = 0x3;
   31474:	9a 87       	std	Y+10, r25	; 0x0a
   31476:	93 e0       	ldi	r25, 0x03	; 3
									msg.dta[1] = success;
   31478:	9b 87       	std	Y+11, r25	; 0x0b
									msg.dta[2] = (buffer_index >> 8);
   3147a:	8c 87       	std	Y+12, r24	; 0x0c
   3147c:	78 a5       	ldd	r23, Y+40	; 0x28
									msg.dta[3] = buffer_index;
   3147e:	7d 87       	std	Y+13, r23	; 0x0d
   31480:	8f a1       	ldd	r24, Y+39	; 0x27
									msg.dta[4] = data_sequence;
   31482:	8e 87       	std	Y+14, r24	; 0x0e
									can_send(&msg);
   31484:	8f 86       	std	Y+15, r8	; 0x0f
   31486:	ce 01       	movw	r24, r28
   31488:	05 96       	adiw	r24, 0x05	; 5
   3148a:	2d dd       	rcall	.-1446   	; 0x30ee6 <can_send>
   3148c:	84 ce       	rjmp	.-760    	; 0x31196 <main+0x118>
								}
								break;
								
							case 0x33: // ADD_PAGE_DATA_BULK <b1> [<b2>] [<b3>] [<b4>] [<b5>] [<b6>] [b7], return nothing
								if (authorized && msg.dlc >= 2)
   3148e:	99 20       	and	r9, r9
   31490:	09 f4       	brne	.+2      	; 0x31494 <main+0x416>
   31492:	81 ce       	rjmp	.-766    	; 0x31196 <main+0x118>
   31494:	8a 85       	ldd	r24, Y+10	; 0x0a
   31496:	82 30       	cpi	r24, 0x02	; 2
   31498:	08 f4       	brcc	.+2      	; 0x3149c <main+0x41e>
   3149a:	7d ce       	rjmp	.-774    	; 0x31196 <main+0x118>
								{								
									if (buffer_index + msg.dlc - 2 <= sizeof(buffer))
   3149c:	28 2f       	mov	r18, r24
   3149e:	30 e0       	ldi	r19, 0x00	; 0
   314a0:	22 50       	subi	r18, 0x02	; 2
   314a2:	31 09       	sbc	r19, r1
   314a4:	af a1       	ldd	r26, Y+39	; 0x27
   314a6:	b8 a5       	ldd	r27, Y+40	; 0x28
   314a8:	2a 0f       	add	r18, r26
   314aa:	3b 1f       	adc	r19, r27
   314ac:	21 30       	cpi	r18, 0x01	; 1
   314ae:	32 40       	sbci	r19, 0x02	; 2
   314b0:	08 f0       	brcs	.+2      	; 0x314b4 <main+0x436>
   314b2:	71 ce       	rjmp	.-798    	; 0x31196 <main+0x118>
									{
										buffer[buffer_index++] = msg.dta[1];
   314b4:	2f a1       	ldd	r18, Y+39	; 0x27
   314b6:	38 a5       	ldd	r19, Y+40	; 0x28
   314b8:	2f 5f       	subi	r18, 0xFF	; 255
   314ba:	3f 4f       	sbci	r19, 0xFF	; 255
   314bc:	9c 85       	ldd	r25, Y+12	; 0x0c
   314be:	ef a1       	ldd	r30, Y+39	; 0x27
   314c0:	f8 a5       	ldd	r31, Y+40	; 0x28
   314c2:	e9 51       	subi	r30, 0x19	; 25
   314c4:	fc 4d       	sbci	r31, 0xDC	; 220
   314c6:	90 83       	st	Z, r25
										if (msg.dlc >= 3) buffer[buffer_index++] = msg.dta[2];
   314c8:	83 30       	cpi	r24, 0x03	; 3
   314ca:	48 f0       	brcs	.+18     	; 0x314de <main+0x460>
   314cc:	9d 85       	ldd	r25, Y+13	; 0x0d
   314ce:	f9 01       	movw	r30, r18
   314d0:	e9 51       	subi	r30, 0x19	; 25
   314d2:	fc 4d       	sbci	r31, 0xDC	; 220
   314d4:	90 83       	st	Z, r25
   314d6:	2f a1       	ldd	r18, Y+39	; 0x27
   314d8:	38 a5       	ldd	r19, Y+40	; 0x28
   314da:	2e 5f       	subi	r18, 0xFE	; 254
   314dc:	3f 4f       	sbci	r19, 0xFF	; 255
										if (msg.dlc >= 4) buffer[buffer_index++] = msg.dta[3];
   314de:	84 30       	cpi	r24, 0x04	; 4
   314e0:	38 f0       	brcs	.+14     	; 0x314f0 <main+0x472>
   314e2:	9e 85       	ldd	r25, Y+14	; 0x0e
   314e4:	f9 01       	movw	r30, r18
   314e6:	e9 51       	subi	r30, 0x19	; 25
   314e8:	fc 4d       	sbci	r31, 0xDC	; 220
   314ea:	90 83       	st	Z, r25
   314ec:	2f 5f       	subi	r18, 0xFF	; 255
   314ee:	3f 4f       	sbci	r19, 0xFF	; 255
										if (msg.dlc >= 5) buffer[buffer_index++] = msg.dta[4];
   314f0:	85 30       	cpi	r24, 0x05	; 5
   314f2:	38 f0       	brcs	.+14     	; 0x31502 <main+0x484>
   314f4:	9f 85       	ldd	r25, Y+15	; 0x0f
   314f6:	f9 01       	movw	r30, r18
   314f8:	e9 51       	subi	r30, 0x19	; 25
   314fa:	fc 4d       	sbci	r31, 0xDC	; 220
   314fc:	90 83       	st	Z, r25
   314fe:	2f 5f       	subi	r18, 0xFF	; 255
   31500:	3f 4f       	sbci	r19, 0xFF	; 255
										if (msg.dlc >= 6) buffer[buffer_index++] = msg.dta[5];
   31502:	86 30       	cpi	r24, 0x06	; 6
   31504:	38 f0       	brcs	.+14     	; 0x31514 <main+0x496>
   31506:	98 89       	ldd	r25, Y+16	; 0x10
   31508:	f9 01       	movw	r30, r18
   3150a:	e9 51       	subi	r30, 0x19	; 25
   3150c:	fc 4d       	sbci	r31, 0xDC	; 220
   3150e:	90 83       	st	Z, r25
   31510:	2f 5f       	subi	r18, 0xFF	; 255
   31512:	3f 4f       	sbci	r19, 0xFF	; 255
										if (msg.dlc >= 7) buffer[buffer_index++] = msg.dta[6];
   31514:	87 30       	cpi	r24, 0x07	; 7
   31516:	38 f0       	brcs	.+14     	; 0x31526 <main+0x4a8>
   31518:	99 89       	ldd	r25, Y+17	; 0x11
   3151a:	f9 01       	movw	r30, r18
   3151c:	e9 51       	subi	r30, 0x19	; 25
   3151e:	fc 4d       	sbci	r31, 0xDC	; 220
   31520:	90 83       	st	Z, r25
   31522:	2f 5f       	subi	r18, 0xFF	; 255
   31524:	3f 4f       	sbci	r19, 0xFF	; 255
										if (msg.dlc == 8) buffer[buffer_index++] = msg.dta[7];
   31526:	88 30       	cpi	r24, 0x08	; 8
   31528:	09 f0       	breq	.+2      	; 0x3152c <main+0x4ae>
   3152a:	33 ce       	rjmp	.-922    	; 0x31192 <main+0x114>
   3152c:	f9 01       	movw	r30, r18
   3152e:	31 96       	adiw	r30, 0x01	; 1
   31530:	ef a3       	std	Y+39, r30	; 0x27
   31532:	f8 a7       	std	Y+40, r31	; 0x28
   31534:	8a 89       	ldd	r24, Y+18	; 0x12
   31536:	f9 01       	movw	r30, r18
   31538:	e9 51       	subi	r30, 0x19	; 25
   3153a:	fc 4d       	sbci	r31, 0xDC	; 220
   3153c:	80 83       	st	Z, r24
   3153e:	2b ce       	rjmp	.-938    	; 0x31196 <main+0x118>
									}								
								}
								break;
							
							case 0x4: // FLASH_LOADED_PAGE <crc>, returns 0x4 <success[1/0]> <pageH> <pageL> 
								if (authorized)
   31540:	99 20       	and	r9, r9
   31542:	09 f4       	brne	.+2      	; 0x31546 <main+0x4c8>
   31544:	28 ce       	rjmp	.-944    	; 0x31196 <main+0x118>
								{
									crc = 0;
   31546:	19 82       	std	Y+1, r1	; 0x01
									for (uint16_t i=0; i < sizeof(buffer); ++i) crc += buffer[i];
   31548:	20 e0       	ldi	r18, 0x00	; 0
   3154a:	30 e0       	ldi	r19, 0x00	; 0
   3154c:	f9 01       	movw	r30, r18
   3154e:	e9 51       	subi	r30, 0x19	; 25
   31550:	fc 4d       	sbci	r31, 0xDC	; 220
   31552:	90 81       	ld	r25, Z
   31554:	89 81       	ldd	r24, Y+1	; 0x01
   31556:	89 0f       	add	r24, r25
   31558:	89 83       	std	Y+1, r24	; 0x01
   3155a:	2f 5f       	subi	r18, 0xFF	; 255
   3155c:	3f 4f       	sbci	r19, 0xFF	; 255
   3155e:	21 15       	cp	r18, r1
   31560:	f2 e0       	ldi	r31, 0x02	; 2
   31562:	3f 07       	cpc	r19, r31
   31564:	99 f7       	brne	.-26     	; 0x3154c <main+0x4ce>
									success = 0;
									
									uint32_t addr = (uint32_t)APP_SECTION_START + (uint32_t)((uint32_t)page * (uint32_t)SPM_PAGESIZE);
   31566:	8a 81       	ldd	r24, Y+2	; 0x02
   31568:	9b 81       	ldd	r25, Y+3	; 0x03
   3156a:	a0 e0       	ldi	r26, 0x00	; 0
   3156c:	b0 e0       	ldi	r27, 0x00	; 0
   3156e:	9c 01       	movw	r18, r24
   31570:	ad 01       	movw	r20, r26
   31572:	01 2e       	mov	r0, r17
   31574:	19 e0       	ldi	r17, 0x09	; 9
   31576:	22 0f       	add	r18, r18
   31578:	33 1f       	adc	r19, r19
   3157a:	44 1f       	adc	r20, r20
   3157c:	55 1f       	adc	r21, r21
   3157e:	1a 95       	dec	r17
   31580:	d1 f7       	brne	.-12     	; 0x31576 <main+0x4f8>
   31582:	10 2d       	mov	r17, r0
   31584:	2f 8f       	std	Y+31, r18	; 0x1f
   31586:	38 a3       	std	Y+32, r19	; 0x20
   31588:	49 a3       	std	Y+33, r20	; 0x21
   3158a:	5a a3       	std	Y+34, r21	; 0x22
									
									if (msg.dta[1] == crc)
   3158c:	89 81       	ldd	r24, Y+1	; 0x01
   3158e:	9c 85       	ldd	r25, Y+12	; 0x0c
   31590:	98 13       	cpse	r25, r24
   31592:	3d c0       	rjmp	.+122    	; 0x3160e <main+0x590>
									{				
										if (lastPage == page) // erase if re-sending the flash after timeout
   31594:	29 8d       	ldd	r18, Y+25	; 0x19
   31596:	3a 8d       	ldd	r19, Y+26	; 0x1a
   31598:	8a 81       	ldd	r24, Y+2	; 0x02
   3159a:	9b 81       	ldd	r25, Y+3	; 0x03
   3159c:	28 17       	cp	r18, r24
   3159e:	39 07       	cpc	r19, r25
   315a0:	41 f4       	brne	.+16     	; 0x315b2 <main+0x534>
										{
											SP_EraseApplicationPage(addr);
   315a2:	6f 8d       	ldd	r22, Y+31	; 0x1f
   315a4:	78 a1       	ldd	r23, Y+32	; 0x20
   315a6:	89 a1       	ldd	r24, Y+33	; 0x21
   315a8:	9a a1       	ldd	r25, Y+34	; 0x22
   315aa:	0f 94 4e 81 	call	0x3029c	; 0x3029c <SP_EraseApplicationPage>
											SP_WaitForSPM();
   315ae:	0f 94 a2 81 	call	0x30344	; 0x30344 <SP_WaitForSPM>
										}
											
										lastPage = page;
   315b2:	8a 81       	ldd	r24, Y+2	; 0x02
   315b4:	9b 81       	ldd	r25, Y+3	; 0x03
   315b6:	89 8f       	std	Y+25, r24	; 0x19
   315b8:	9a 8f       	std	Y+26, r25	; 0x1a
										
										// decrypt using AES
										for (int i=0; i < SPM_PAGESIZE; i+=16)
   315ba:	c1 2c       	mov	r12, r1
										{
											AES128_CBC_decrypt_buffer(&buffer_decrypted[i], &buffer[i], 16, (i==0) ? aes_key : 0, (i==0) ? aes_iv : 0);
   315bc:	d1 2c       	mov	r13, r1
   315be:	c1 14       	cp	r12, r1
   315c0:	d1 04       	cpc	r13, r1
   315c2:	09 f4       	brne	.+2      	; 0x315c6 <main+0x548>
   315c4:	b7 c0       	rjmp	.+366    	; 0x31734 <main+0x6b6>
   315c6:	b6 01       	movw	r22, r12
   315c8:	69 51       	subi	r22, 0x19	; 25
   315ca:	7c 4d       	sbci	r23, 0xDC	; 220
   315cc:	e1 2c       	mov	r14, r1
   315ce:	f1 2c       	mov	r15, r1
   315d0:	00 e0       	ldi	r16, 0x00	; 0
   315d2:	10 e0       	ldi	r17, 0x00	; 0
   315d4:	20 e1       	ldi	r18, 0x10	; 16
   315d6:	30 e0       	ldi	r19, 0x00	; 0
   315d8:	40 e0       	ldi	r20, 0x00	; 0
   315da:	50 e0       	ldi	r21, 0x00	; 0
   315dc:	c6 01       	movw	r24, r12
   315de:	89 51       	subi	r24, 0x19	; 25
   315e0:	9a 4d       	sbci	r25, 0xDA	; 218
   315e2:	a5 d8       	rcall	.-3766   	; 0x3072e <AES128_CBC_decrypt_buffer>
										}
											
										lastPage = page;
										
										// decrypt using AES
										for (int i=0; i < SPM_PAGESIZE; i+=16)
   315e4:	30 e1       	ldi	r19, 0x10	; 16
   315e6:	c3 0e       	add	r12, r19
   315e8:	d1 1c       	adc	r13, r1
   315ea:	c1 14       	cp	r12, r1
   315ec:	42 e0       	ldi	r20, 0x02	; 2
   315ee:	d4 06       	cpc	r13, r20
   315f0:	31 f7       	brne	.-52     	; 0x315be <main+0x540>
										{
											AES128_CBC_decrypt_buffer(&buffer_decrypted[i], &buffer[i], 16, (i==0) ? aes_key : 0, (i==0) ? aes_iv : 0);
										}
										
										SP_LoadFlashPage(&buffer_decrypted);
   315f2:	87 ee       	ldi	r24, 0xE7	; 231
   315f4:	95 e2       	ldi	r25, 0x25	; 37
   315f6:	0f 94 57 81 	call	0x302ae	; 0x302ae <SP_LoadFlashPage>
										
										SP_WriteApplicationPage(addr);
   315fa:	6f 8d       	ldd	r22, Y+31	; 0x1f
   315fc:	78 a1       	ldd	r23, Y+32	; 0x20
   315fe:	89 a1       	ldd	r24, Y+33	; 0x21
   31600:	9a a1       	ldd	r25, Y+34	; 0x22
   31602:	0f 94 7b 81 	call	0x302f6	; 0x302f6 <SP_WriteApplicationPage>
										SP_WaitForSPM();
   31606:	0f 94 a2 81 	call	0x30344	; 0x30344 <SP_WaitForSPM>
									
										success = 1;
   3160a:	91 e0       	ldi	r25, 0x01	; 1
   3160c:	01 c0       	rjmp	.+2      	; 0x31610 <main+0x592>
							case 0x4: // FLASH_LOADED_PAGE <crc>, returns 0x4 <success[1/0]> <pageH> <pageL> 
								if (authorized)
								{
									crc = 0;
									for (uint16_t i=0; i < sizeof(buffer); ++i) crc += buffer[i];
									success = 0;
   3160e:	90 e0       	ldi	r25, 0x00	; 0
										SP_WaitForSPM();
									
										success = 1;
									}
							
									msg.identifier = AVR_PC_CAN_ID;
   31610:	4f ef       	ldi	r20, 0xFF	; 255
   31612:	57 e0       	ldi	r21, 0x07	; 7
   31614:	60 e0       	ldi	r22, 0x00	; 0
   31616:	70 e0       	ldi	r23, 0x00	; 0
   31618:	4e 83       	std	Y+6, r20	; 0x06
   3161a:	5f 83       	std	Y+7, r21	; 0x07
   3161c:	68 87       	std	Y+8, r22	; 0x08
   3161e:	79 87       	std	Y+9, r23	; 0x09
									msg.dlc = 8;
   31620:	58 e0       	ldi	r21, 0x08	; 8
   31622:	5a 87       	std	Y+10, r21	; 0x0a
									msg.dta[0] = 0x4;
   31624:	64 e0       	ldi	r22, 0x04	; 4
									msg.dta[1] = success ? 1 : 0;
   31626:	6b 87       	std	Y+11, r22	; 0x0b
   31628:	81 e0       	ldi	r24, 0x01	; 1
   3162a:	91 11       	cpse	r25, r1
   3162c:	01 c0       	rjmp	.+2      	; 0x31630 <main+0x5b2>
   3162e:	80 e0       	ldi	r24, 0x00	; 0
									msg.dta[2] = (page >> 8);
   31630:	8c 87       	std	Y+12, r24	; 0x0c
   31632:	8a 81       	ldd	r24, Y+2	; 0x02
   31634:	9b 81       	ldd	r25, Y+3	; 0x03
									msg.dta[3] = page;
   31636:	9d 87       	std	Y+13, r25	; 0x0d
   31638:	8a 81       	ldd	r24, Y+2	; 0x02
   3163a:	9b 81       	ldd	r25, Y+3	; 0x03
									msg.dta[4] = addr >> 24;
   3163c:	8e 87       	std	Y+14, r24	; 0x0e
   3163e:	7a a1       	ldd	r23, Y+34	; 0x22
									msg.dta[5] = addr >> 16;
   31640:	7f 87       	std	Y+15, r23	; 0x0f
   31642:	89 a1       	ldd	r24, Y+33	; 0x21
									msg.dta[6] = addr >> 8;
   31644:	88 8b       	std	Y+16, r24	; 0x10
   31646:	98 a1       	ldd	r25, Y+32	; 0x20
									msg.dta[7] = addr;
   31648:	99 8b       	std	Y+17, r25	; 0x11
									can_send(&msg);
   3164a:	1a 8a       	std	Y+18, r1	; 0x12
   3164c:	ce 01       	movw	r24, r28
   3164e:	05 96       	adiw	r24, 0x05	; 5
   31650:	4a dc       	rcall	.-1900   	; 0x30ee6 <can_send>
   31652:	a1 cd       	rjmp	.-1214   	; 0x31196 <main+0x118>
								}
								break;
							
							case 0x10: // NEW_FIRMWARE_VERSION <firmware1> <firmware2> <firmware3> <firmware4>, RETURNS 0x10 <success[0/1]> <firmware1> <firmware2> <firmware3> <firmware4>
								if (authorized && msg.dlc == 5)
   31654:	99 20       	and	r9, r9
   31656:	09 f4       	brne	.+2      	; 0x3165a <main+0x5dc>
   31658:	9e cd       	rjmp	.-1220   	; 0x31196 <main+0x118>
   3165a:	8a 85       	ldd	r24, Y+10	; 0x0a
   3165c:	85 30       	cpi	r24, 0x05	; 5
   3165e:	09 f0       	breq	.+2      	; 0x31662 <main+0x5e4>
   31660:	9a cd       	rjmp	.-1228   	; 0x31196 <main+0x118>
								{
									memset(&buffer, 0, sizeof(buffer));
   31662:	a7 ee       	ldi	r26, 0xE7	; 231
   31664:	b3 e2       	ldi	r27, 0x23	; 35
   31666:	e0 e0       	ldi	r30, 0x00	; 0
   31668:	f2 e0       	ldi	r31, 0x02	; 2
   3166a:	1d 92       	st	X+, r1
   3166c:	31 97       	sbiw	r30, 0x01	; 1
   3166e:	e9 f7       	brne	.-6      	; 0x3166a <main+0x5ec>
									SP_EraseUserSignatureRow(); SP_WaitForSPM();
   31670:	0f 94 42 81 	call	0x30284	; 0x30284 <SP_EraseUserSignatureRow>
   31674:	0f 94 a2 81 	call	0x30344	; 0x30344 <SP_WaitForSPM>
							
									firmware[0] = msg.dta[1];
   31678:	3c 85       	ldd	r19, Y+12	; 0x0c
   3167a:	3d 8b       	std	Y+21, r19	; 0x15
									firmware[1] = msg.dta[2];
   3167c:	2d 85       	ldd	r18, Y+13	; 0x0d
   3167e:	2e 8b       	std	Y+22, r18	; 0x16
									firmware[2] = msg.dta[3];
   31680:	9e 85       	ldd	r25, Y+14	; 0x0e
   31682:	9f 8b       	std	Y+23, r25	; 0x17
									firmware[3] = msg.dta[4];
   31684:	8f 85       	ldd	r24, Y+15	; 0x0f
   31686:	88 8f       	std	Y+24, r24	; 0x18
							
									// save new version into user signature area with start (0xF0) and end (0x0F) bytes so we can check if data is valid.
									buffer[0] = 0xF0;
   31688:	e0 ef       	ldi	r30, 0xF0	; 240
   3168a:	a7 ee       	ldi	r26, 0xE7	; 231
   3168c:	b3 e2       	ldi	r27, 0x23	; 35
									buffer[1] = firmware[0];
   3168e:	ec 93       	st	X, r30
   31690:	30 93 e8 23 	sts	0x23E8, r19	; 0x8023e8 <buffer+0x1>
									buffer[2] = firmware[1];
   31694:	20 93 e9 23 	sts	0x23E9, r18	; 0x8023e9 <buffer+0x2>
									buffer[3] = firmware[2];
   31698:	90 93 ea 23 	sts	0x23EA, r25	; 0x8023ea <buffer+0x3>
									buffer[4] = firmware[3];
   3169c:	80 93 eb 23 	sts	0x23EB, r24	; 0x8023eb <buffer+0x4>
									buffer[5] = 0x0F;
   316a0:	ff e0       	ldi	r31, 0x0F	; 15
   316a2:	f0 93 ec 23 	sts	0x23EC, r31	; 0x8023ec <buffer+0x5>
									SP_LoadFlashPage(&buffer);
   316a6:	cd 01       	movw	r24, r26
   316a8:	0f 94 57 81 	call	0x302ae	; 0x302ae <SP_LoadFlashPage>
									SP_WriteUserSignatureRow();
   316ac:	0f 94 45 81 	call	0x3028a	; 0x3028a <SP_WriteUserSignatureRow>
									SP_WaitForSPM();
   316b0:	0f 94 a2 81 	call	0x30344	; 0x30344 <SP_WaitForSPM>
								
									// read the signature back to verify write was successful
									uint8_t f[4];
								
									success = 0;
									if (firmware_read(&f))
   316b4:	ce 01       	movw	r24, r28
   316b6:	4b 96       	adiw	r24, 0x1b	; 27
   316b8:	55 dc       	rcall	.-1878   	; 0x30f64 <firmware_read>
   316ba:	88 23       	and	r24, r24
   316bc:	99 f0       	breq	.+38     	; 0x316e4 <main+0x666>
									{
										if (f[0] == firmware[0] && f[1] == firmware[1] && f[2] == firmware[2] &&  f[3] == firmware[3])
   316be:	9b 8d       	ldd	r25, Y+27	; 0x1b
   316c0:	8d 89       	ldd	r24, Y+21	; 0x15
   316c2:	98 13       	cpse	r25, r24
   316c4:	11 c0       	rjmp	.+34     	; 0x316e8 <main+0x66a>
   316c6:	9c 8d       	ldd	r25, Y+28	; 0x1c
   316c8:	8e 89       	ldd	r24, Y+22	; 0x16
   316ca:	98 13       	cpse	r25, r24
   316cc:	0f c0       	rjmp	.+30     	; 0x316ec <main+0x66e>
   316ce:	9d 8d       	ldd	r25, Y+29	; 0x1d
   316d0:	8f 89       	ldd	r24, Y+23	; 0x17
   316d2:	98 13       	cpse	r25, r24
   316d4:	0d c0       	rjmp	.+26     	; 0x316f0 <main+0x672>
									SP_WaitForSPM();
								
									// read the signature back to verify write was successful
									uint8_t f[4];
								
									success = 0;
   316d6:	81 e0       	ldi	r24, 0x01	; 1
   316d8:	2e 8d       	ldd	r18, Y+30	; 0x1e
   316da:	98 8d       	ldd	r25, Y+24	; 0x18
   316dc:	29 17       	cp	r18, r25
   316de:	49 f0       	breq	.+18     	; 0x316f2 <main+0x674>
   316e0:	80 e0       	ldi	r24, 0x00	; 0
   316e2:	07 c0       	rjmp	.+14     	; 0x316f2 <main+0x674>
									{
										if (f[0] == firmware[0] && f[1] == firmware[1] && f[2] == firmware[2] &&  f[3] == firmware[3])
											success = 1;
									}
									else
										success = 0;
   316e4:	80 e0       	ldi	r24, 0x00	; 0
   316e6:	05 c0       	rjmp	.+10     	; 0x316f2 <main+0x674>
									SP_WaitForSPM();
								
									// read the signature back to verify write was successful
									uint8_t f[4];
								
									success = 0;
   316e8:	80 e0       	ldi	r24, 0x00	; 0
   316ea:	03 c0       	rjmp	.+6      	; 0x316f2 <main+0x674>
   316ec:	80 e0       	ldi	r24, 0x00	; 0
   316ee:	01 c0       	rjmp	.+2      	; 0x316f2 <main+0x674>
   316f0:	80 e0       	ldi	r24, 0x00	; 0
									}
									else
										success = 0;
									
							
									msg.identifier = AVR_PC_CAN_ID;
   316f2:	4f ef       	ldi	r20, 0xFF	; 255
   316f4:	57 e0       	ldi	r21, 0x07	; 7
   316f6:	60 e0       	ldi	r22, 0x00	; 0
   316f8:	70 e0       	ldi	r23, 0x00	; 0
   316fa:	4e 83       	std	Y+6, r20	; 0x06
   316fc:	5f 83       	std	Y+7, r21	; 0x07
   316fe:	68 87       	std	Y+8, r22	; 0x08
									msg.dlc = 4;
   31700:	79 87       	std	Y+9, r23	; 0x09
   31702:	24 e0       	ldi	r18, 0x04	; 4
									msg.dta[0] = 0x10;
   31704:	2a 87       	std	Y+10, r18	; 0x0a
   31706:	30 e1       	ldi	r19, 0x10	; 16
									msg.dta[1] = success ? 1 : 0;
   31708:	3b 87       	std	Y+11, r19	; 0x0b
   3170a:	91 e0       	ldi	r25, 0x01	; 1
   3170c:	81 11       	cpse	r24, r1
   3170e:	01 c0       	rjmp	.+2      	; 0x31712 <main+0x694>
   31710:	90 e0       	ldi	r25, 0x00	; 0
									msg.dta[2] = firmware[0];
   31712:	9c 87       	std	Y+12, r25	; 0x0c
   31714:	8d 89       	ldd	r24, Y+21	; 0x15
									msg.dta[3] = firmware[1];
   31716:	8d 87       	std	Y+13, r24	; 0x0d
   31718:	8e 89       	ldd	r24, Y+22	; 0x16
									msg.dta[4] = firmware[2];
   3171a:	8e 87       	std	Y+14, r24	; 0x0e
   3171c:	8f 89       	ldd	r24, Y+23	; 0x17
									msg.dta[5] = firmware[3];
   3171e:	8f 87       	std	Y+15, r24	; 0x0f
   31720:	88 8d       	ldd	r24, Y+24	; 0x18
									can_send(&msg);
   31722:	88 8b       	std	Y+16, r24	; 0x10
   31724:	ce 01       	movw	r24, r28
   31726:	05 96       	adiw	r24, 0x05	; 5
   31728:	de db       	rcall	.-2116   	; 0x30ee6 <can_send>
   3172a:	35 cd       	rjmp	.-1430   	; 0x31196 <main+0x118>
								}
								break;
							
							case 0x20:	// RUN_APPLICATION 
								if (authorized)
   3172c:	99 20       	and	r9, r9
   3172e:	09 f4       	brne	.+2      	; 0x31732 <main+0x6b4>
   31730:	32 cd       	rjmp	.-1436   	; 0x31196 <main+0x118>
   31732:	18 c0       	rjmp	.+48     	; 0x31764 <main+0x6e6>
										lastPage = page;
										
										// decrypt using AES
										for (int i=0; i < SPM_PAGESIZE; i+=16)
										{
											AES128_CBC_decrypt_buffer(&buffer_decrypted[i], &buffer[i], 16, (i==0) ? aes_key : 0, (i==0) ? aes_iv : 0);
   31734:	b6 01       	movw	r22, r12
   31736:	69 51       	subi	r22, 0x19	; 25
   31738:	7c 4d       	sbci	r23, 0xDC	; 220
   3173a:	0f 2e       	mov	r0, r31
   3173c:	f0 e0       	ldi	r31, 0x00	; 0
   3173e:	ef 2e       	mov	r14, r31
   31740:	f0 e2       	ldi	r31, 0x20	; 32
   31742:	ff 2e       	mov	r15, r31
   31744:	f0 2d       	mov	r31, r0
   31746:	00 e1       	ldi	r16, 0x10	; 16
   31748:	10 e2       	ldi	r17, 0x20	; 32
   3174a:	20 e1       	ldi	r18, 0x10	; 16
   3174c:	30 e0       	ldi	r19, 0x00	; 0
   3174e:	40 e0       	ldi	r20, 0x00	; 0
   31750:	50 e0       	ldi	r21, 0x00	; 0
   31752:	c6 01       	movw	r24, r12
   31754:	89 51       	subi	r24, 0x19	; 25
   31756:	9a 4d       	sbci	r25, 0xDA	; 218
   31758:	0f 94 97 83 	call	0x3072e	; 0x3072e <AES128_CBC_decrypt_buffer>
										}
											
										lastPage = page;
										
										// decrypt using AES
										for (int i=0; i < SPM_PAGESIZE; i+=16)
   3175c:	40 e1       	ldi	r20, 0x10	; 16
   3175e:	c4 0e       	add	r12, r20
   31760:	d1 1c       	adc	r13, r1
   31762:	2d cf       	rjmp	.-422    	; 0x315be <main+0x540>
			}
		}
	}
	
run_app:
	cli();
   31764:	f8 94       	cli
	CCP = CCP_IOREG_gc;
   31766:	88 ed       	ldi	r24, 0xD8	; 216
   31768:	84 bf       	out	0x34, r24	; 52
	RST.STATUS = 0;
   3176a:	10 92 78 00 	sts	0x0078, r1	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	CCP = CCP_IOREG_gc;
   3176e:	84 bf       	out	0x34, r24	; 52
	PMIC.CTRL = 0;
   31770:	10 92 a2 00 	sts	0x00A2, r1	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	CCP = CCP_IOREG_gc;	
   31774:	84 bf       	out	0x34, r24	; 52
	SP_LockSPM();
   31776:	0f 94 9b 81 	call	0x30336	; 0x30336 <SP_LockSPM>
	asm("jmp 0x0");
   3177a:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
   3177e:	80 e0       	ldi	r24, 0x00	; 0
   31780:	90 e0       	ldi	r25, 0x00	; 0
   31782:	a9 96       	adiw	r28, 0x29	; 41
   31784:	cd bf       	out	0x3d, r28	; 61
   31786:	de bf       	out	0x3e, r29	; 62
   31788:	df 91       	pop	r29
   3178a:	cf 91       	pop	r28
   3178c:	1f 91       	pop	r17
   3178e:	0f 91       	pop	r16
   31790:	ff 90       	pop	r15
   31792:	ef 90       	pop	r14
   31794:	df 90       	pop	r13
   31796:	cf 90       	pop	r12
   31798:	bf 90       	pop	r11
   3179a:	af 90       	pop	r10
   3179c:	9f 90       	pop	r9
   3179e:	8f 90       	pop	r8
   317a0:	7f 90       	pop	r7
   317a2:	6f 90       	pop	r6
   317a4:	5f 90       	pop	r5
   317a6:	4f 90       	pop	r4
   317a8:	3f 90       	pop	r3
   317aa:	2f 90       	pop	r2
   317ac:	08 95       	ret

000317ae <spi_transfer>:
	return SPIC.DATA;
}

void spi_mode(unsigned char mode, unsigned char prescaler)
{
	SPIC.CTRL = SPI_ENABLE_bm | SPI_MASTER_bm | mode | prescaler;	
   317ae:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
   317b2:	e0 ec       	ldi	r30, 0xC0	; 192
   317b4:	f8 e0       	ldi	r31, 0x08	; 8
   317b6:	82 81       	ldd	r24, Z+2	; 0x02
   317b8:	88 23       	and	r24, r24
   317ba:	ec f7       	brge	.-6      	; 0x317b6 <spi_transfer+0x8>
   317bc:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
   317c0:	08 95       	ret

000317c2 <spi_init>:
}

void spi_init()
{
	/* SPI */
	sbi(PORTC_DIR, 4); // SS - OUTPUT
   317c2:	e0 e4       	ldi	r30, 0x40	; 64
   317c4:	f6 e0       	ldi	r31, 0x06	; 6
   317c6:	80 81       	ld	r24, Z
   317c8:	80 61       	ori	r24, 0x10	; 16
   317ca:	80 83       	st	Z, r24
	sbi(PORTC_DIR, 5); // MOSI - OUTPUT
   317cc:	80 81       	ld	r24, Z
   317ce:	80 62       	ori	r24, 0x20	; 32
   317d0:	80 83       	st	Z, r24
	cbi(PORTC_DIR, 6); // MISO - INPUT
   317d2:	80 81       	ld	r24, Z
   317d4:	8f 7b       	andi	r24, 0xBF	; 191
   317d6:	80 83       	st	Z, r24
	sbi(PORTC_DIR, 7); // SCK - OUTPUT	
   317d8:	80 81       	ld	r24, Z
   317da:	80 68       	ori	r24, 0x80	; 128
   317dc:	80 83       	st	Z, r24
	return SPIC.DATA;
}

void spi_mode(unsigned char mode, unsigned char prescaler)
{
	SPIC.CTRL = SPI_ENABLE_bm | SPI_MASTER_bm | mode | prescaler;	
   317de:	80 e5       	ldi	r24, 0x50	; 80
   317e0:	80 93 c0 08 	sts	0x08C0, r24	; 0x8008c0 <__TEXT_REGION_LENGTH__+0x7008c0>
   317e4:	08 95       	ret

000317e6 <__adddi3_s8>:
   317e6:	00 24       	eor	r0, r0
   317e8:	a7 fd       	sbrc	r26, 7
   317ea:	00 94       	com	r0
   317ec:	2a 0f       	add	r18, r26
   317ee:	30 1d       	adc	r19, r0
   317f0:	40 1d       	adc	r20, r0
   317f2:	50 1d       	adc	r21, r0
   317f4:	60 1d       	adc	r22, r0
   317f6:	70 1d       	adc	r23, r0
   317f8:	80 1d       	adc	r24, r0
   317fa:	90 1d       	adc	r25, r0
   317fc:	08 95       	ret

000317fe <__cmpdi2>:
   317fe:	2a 15       	cp	r18, r10
   31800:	3b 05       	cpc	r19, r11
   31802:	4c 05       	cpc	r20, r12
   31804:	5d 05       	cpc	r21, r13
   31806:	6e 05       	cpc	r22, r14
   31808:	7f 05       	cpc	r23, r15
   3180a:	80 07       	cpc	r24, r16
   3180c:	91 07       	cpc	r25, r17
   3180e:	08 95       	ret

00031810 <memset>:
   31810:	dc 01       	movw	r26, r24
   31812:	01 c0       	rjmp	.+2      	; 0x31816 <memset+0x6>
   31814:	6d 93       	st	X+, r22
   31816:	41 50       	subi	r20, 0x01	; 1
   31818:	50 40       	sbci	r21, 0x00	; 0
   3181a:	e0 f7       	brcc	.-8      	; 0x31814 <memset+0x4>
   3181c:	08 95       	ret

0003181e <_exit>:
   3181e:	f8 94       	cli

00031820 <__stop_program>:
   31820:	ff cf       	rjmp	.-2      	; 0x31820 <__stop_program>
