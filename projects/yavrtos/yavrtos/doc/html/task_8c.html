<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>YAVRTOS: task.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1>task.c File Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#7a659118f2c006c2570742f06614eace">semaphore_triggered</a>(current, required)&nbsp;&nbsp;&nbsp;((current) - (required) &gt;= 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Has a semaphore been triggered?  <a href="#7a659118f2c006c2570742f06614eace"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__taskstategroup.html#g434ebb7bd09016853228960c1c91fe22">TASK_STATE_STARTING</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starting.  <a href="group__taskstategroup.html#g434ebb7bd09016853228960c1c91fe22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__taskstategroup.html#gf986aeb5acf04c1377115c3c58d6066d">TASK_STATE_RUNNING</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Running.  <a href="group__taskstategroup.html#gf986aeb5acf04c1377115c3c58d6066d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__taskstategroup.html#g99d0b31c3a0e5525ffff0334a9cf48f5">TASK_STATE_WAITING_TO_STOP</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waiting for the task to release all of its mutexes before stopping.  <a href="group__taskstategroup.html#g99d0b31c3a0e5525ffff0334a9cf48f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__taskstategroup.html#g3a4b299f206860e7484eba9176fef9be">TASK_STATE_STOPPING</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stopping.  <a href="group__taskstategroup.html#g3a4b299f206860e7484eba9176fef9be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__taskstategroup.html#g6b6ae39d5fc55cb15af274fdb8f77466">TASK_STATE_CLEANING_UP</a>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cleaning up.  <a href="group__taskstategroup.html#g6b6ae39d5fc55cb15af274fdb8f77466"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__taskstategroup.html#g73fed596e3e9e61b17ada47b4e476bcc">TASK_STATE_STOPPED</a>&nbsp;&nbsp;&nbsp;6</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stopped.  <a href="group__taskstategroup.html#g73fed596e3e9e61b17ada47b4e476bcc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#ec2cb6acfd1cbdf565d79d8e46366142">set_task_state</a>(taskptr, req_state)&nbsp;&nbsp;&nbsp;(taskptr)-&gt;status = (req_state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Set the state of a task - this macro makes it easier to put other information into task.status </p>
 <a href="#ec2cb6acfd1cbdf565d79d8e46366142"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#73254a06adc660dd59b1770c9b9f3520">get_task_state</a>(taskptr)&nbsp;&nbsp;&nbsp;((taskptr)-&gt;status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Get the state of a task - this macro makes it easier to put other information into task.status </p>
 <a href="#73254a06adc660dd59b1770c9b9f3520"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#95d8d92f8a304e063ce50c912412181c">executing_isr</a>()&nbsp;&nbsp;&nbsp;(system.interrupted_task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Are we currently executing an ISR? </p>
 <a href="#95d8d92f8a304e063ce50c912412181c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#87b5d6c508a0039ac89b09c3c71f6717">rtos_started</a>()&nbsp;&nbsp;&nbsp;(<a class="el" href="group__task.html#g4743b3673a8794b8e7bd0b6c91a63cd5">current_task</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Has the RTOS been started? </p>
 <a href="#87b5d6c508a0039ac89b09c3c71f6717"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#c85c4cc0394680fc16ce32fcc987e62e">task_starter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
The entry point for all tasks </p>
 <a href="#c85c4cc0394680fc16ce32fcc987e62e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#b1c4cc247bd379e340e25bd86911919d">task_stopper</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
The entry point for all tasks that are stopping </p>
 <a href="#b1c4cc247bd379e340e25bd86911919d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ge1337adc1d63d7cd874a376d6513c04a">stop_task</a> (<a class="el" href="structtask__t.html">task_t</a> *t, uint8_t wait_for_mutexes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop a task.  <a href="group__task.html#ge1337adc1d63d7cd874a376d6513c04a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g934155282a1d689b554e90b5138e5135">reserve_task</a> (uint16_t stacklen, uint8_t pri, <a class="el" href="structmutex__t.html">mutex_t</a> *memory_mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tasks are kept in a linked list in memory - this function reserves an "empty" task on that list, ready to be subsequently utilised by a call to <a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task()</a>.  <a href="group__task.html#g934155282a1d689b554e90b5138e5135"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3">create_task</a> (void(*proc)(void *), void(*cleanup)(), void *init_data, uint16_t stacklen, uint8_t pri, <a class="el" href="structmutex__t.html">mutex_t</a> *memory_mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a task, ready to be run.  <a href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gdff77e0b451c30c07d2990e669f937c5">lock_on</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock on a mutex.  <a href="group__mutex.html#gdff77e0b451c30c07d2990e669f937c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#g327f419711064b7407f6f47011221cc4">lock_off</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a mutex.  <a href="group__mutex.html#g327f419711064b7407f6f47011221cc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#g3c18e0f867a2f36f1510aebf5ad4c0e2">get_semaphore_value</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current value of a semaphore.  <a href="group__semaphore.html#g3c18e0f867a2f36f1510aebf5ad4c0e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#g45243d3de7a253445deeb57ee4c8cc96">wait_for_min_value</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *p, int16_t value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a semaphore to reach at least a particular value.  <a href="group__semaphore.html#g45243d3de7a253445deeb57ee4c8cc96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#g291edcd883e2d0bc17f85419e21069ff">wait_for_increment_of</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *p, uint16_t amount)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a semaphore to increment its value by a certain amount.  <a href="group__semaphore.html#g291edcd883e2d0bc17f85419e21069ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#aa4ee75536398ba2bd21466b13bdcd57">switch_task</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Perform a task switch </p>
 <a href="#aa4ee75536398ba2bd21466b13bdcd57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#g3cd218588dccb32b5b9072c7a75fb008">increment_semaphore_by</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *s, uint16_t amount)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment the value of a semaphore by the given amount.  <a href="group__semaphore.html#g3cd218588dccb32b5b9072c7a75fb008"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g9b7e62ecd1a61eda8cfa1229df0728ef">get_current_mbox_version</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current version of a mailbox.  <a href="group__mailbox.html#g9b7e62ecd1a61eda8cfa1229df0728ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g86030bb5345670ca374ddd20ef8e4ff6">read_mbox</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *m, int16_t *version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a mailbox.  <a href="group__mailbox.html#g86030bb5345670ca374ddd20ef8e4ff6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g5dbb6937f6f93f6a1c14dec5b1c197c3">read_mbox_min_version</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *m, int16_t *version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a mailbox to reach at least a certain version, and then start reading from it.  <a href="group__mailbox.html#g5dbb6937f6f93f6a1c14dec5b1c197c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structmailbox__t.html">mailbox_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g31b8ee5f4cd547c128143d99ea1c4a96">release_mbox_read</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to call when finished reading from a mailbox.  <a href="group__mailbox.html#g31b8ee5f4cd547c128143d99ea1c4a96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#gd4cde27abfbedc7c8e854e76d71612dd">initialise_mbox</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *m, void *data, const int16_t version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise a mailbox - this <b>must</b> be called on every mailbox before it is used.  <a href="group__mailbox.html#gd4cde27abfbedc7c8e854e76d71612dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#9963b4ea6e571f04447db7fa4a826d81">mbox_is_empty</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find out if a mailbox is "empty" (i.e. if there is no-one waiting to read it).  <a href="#9963b4ea6e571f04447db7fa4a826d81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#gc75646248d03b1413198765b07ba54ad">write_mbox</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *m, void *data, uint8_t wait_for_receivers, uint8_t wait_for_empty_nullify)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to a mailbox.  <a href="group__mailbox.html#gc75646248d03b1413198765b07ba54ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g87f02ab5b46654ae26b06851b2390132">write_mbox_now</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *m, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to write to a mailbox.  <a href="group__mailbox.html#g87f02ab5b46654ae26b06851b2390132"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#gf670250659f0942849aa85f0f94af9f0">wait_for_receiver</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a task to be suspended while trying to read from a mailbox.  <a href="group__mailbox.html#gf670250659f0942849aa85f0f94af9f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">interrupt_store_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g6984a5336b36a4ca99682a2cf5ae044f">disable_interrupts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable interrupts system-wide.  <a href="group__task.html#g6984a5336b36a4ca99682a2cf5ae044f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#gecf8a8e43c2afae89e46503ff1c887bf">restore_interrupts</a> (interrupt_store_t interrupts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restore the state of the system-wide interrupts.  <a href="group__task.html#gecf8a8e43c2afae89e46503ff1c887bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g1a2a5bbefa85516b8c1d0e0361a834db">yield</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop executing the current task and try and execute a higher-priority task or another task of the same priority.  <a href="group__task.html#g1a2a5bbefa85516b8c1d0e0361a834db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g1398c4d9f97349ea3fa7d91349298521">task_switcher_start</a> (void(*idle)(void *), void *idle_data, uint16_t idle_stacklen, uint16_t system_stacklen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the whole process running.  <a href="group__task.html#g1398c4d9f97349ea3fa7d91349298521"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#032a246385c40a7254d11dd557140401">first_task</a> = 0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Pointer to the first task in our linked list </p>
 <a href="#032a246385c40a7254d11dd557140401"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g4743b3673a8794b8e7bd0b6c91a63cd5">current_task</a> = 0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current task.  <a href="group__task.html#g4743b3673a8794b8e7bd0b6c91a63cd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsemaphore__t.html">semaphore_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#add86cc9d9d60a1e9e90466dd09f3d3f">task_stopping_semaphore</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
A semaphore we use to not return from <a class="el" href="group__task.html#ge1337adc1d63d7cd874a376d6513c04a" title="Stop a task.">stop_task()</a> until the task in question has actually stopped </p>
 <a href="#add86cc9d9d60a1e9e90466dd09f3d3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structsystem__struct.html">system_struct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#8e20fafa56301aad5b476cbd2c9e5b48">system</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
The system stack, and a flag indicating whether the CPU is currently processing an interrupt </p>
 <a href="#8e20fafa56301aad5b476cbd2c9e5b48"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="95d8d92f8a304e063ce50c912412181c"></a><!-- doxytag: member="task.c::executing_isr" ref="95d8d92f8a304e063ce50c912412181c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define executing_isr          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(system.interrupted_task)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
Are we currently executing an ISR? </p>

<p>

</div>
</div><p>
<a class="anchor" name="73254a06adc660dd59b1770c9b9f3520"></a><!-- doxytag: member="task.c::get_task_state" ref="73254a06adc660dd59b1770c9b9f3520" args="(taskptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define get_task_state          </td>
          <td>(</td>
          <td class="paramtype">taskptr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((taskptr)-&gt;status)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
Get the state of a task - this macro makes it easier to put other information into task.status </p>

<p>

</div>
</div><p>
<a class="anchor" name="87b5d6c508a0039ac89b09c3c71f6717"></a><!-- doxytag: member="task.c::rtos_started" ref="87b5d6c508a0039ac89b09c3c71f6717" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtos_started          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(<a class="el" href="group__task.html#g4743b3673a8794b8e7bd0b6c91a63cd5">current_task</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
Has the RTOS been started? </p>

<p>

</div>
</div><p>
<a class="anchor" name="7a659118f2c006c2570742f06614eace"></a><!-- doxytag: member="task.c::semaphore_triggered" ref="7a659118f2c006c2570742f06614eace" args="(current, required)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define semaphore_triggered          </td>
          <td>(</td>
          <td class="paramtype">current,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">required&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((current) - (required) &gt;= 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Has a semaphore been triggered? 
<p>
It is quite critical that this algorithm be correct, even when the semaphore values roll over 
</div>
</div><p>
<a class="anchor" name="ec2cb6acfd1cbdf565d79d8e46366142"></a><!-- doxytag: member="task.c::set_task_state" ref="ec2cb6acfd1cbdf565d79d8e46366142" args="(taskptr, req_state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define set_task_state          </td>
          <td>(</td>
          <td class="paramtype">taskptr,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">req_state&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(taskptr)-&gt;status = (req_state)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
Set the state of a task - this macro makes it easier to put other information into task.status </p>

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="9963b4ea6e571f04447db7fa4a826d81"></a><!-- doxytag: member="task.c::mbox_is_empty" ref="9963b4ea6e571f04447db7fa4a826d81" args="(mailbox_t *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t mbox_is_empty           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmailbox__t.html">mailbox_t</a> *&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find out if a mailbox is "empty" (i.e. if there is no-one waiting to read it). 
<p>
<p><b>For internal use only.</b></p>
<p>
Note that interrupts must be disabled before we enter </p>

</div>
</div><p>
<a class="anchor" name="aa4ee75536398ba2bd21466b13bdcd57"></a><!-- doxytag: member="task.c::switch_task" ref="aa4ee75536398ba2bd21466b13bdcd57" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void switch_task           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
Perform a task switch </p>

<p>
Note that interrupts must be disabled before we enter, and the stack pointer should be set up to use the system stack. 
</div>
</div><p>
<a class="anchor" name="c85c4cc0394680fc16ce32fcc987e62e"></a><!-- doxytag: member="task.c::task_starter" ref="c85c4cc0394680fc16ce32fcc987e62e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_starter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
The entry point for all tasks </p>

<p>
First, interrupts are enabled, so that the tick interrupt can happen. Then, the task procedure is executed. When the task procedure exits, if the task priority is zero, it is re-executed. If the task priority isn't zero, the task is shut down. 
</div>
</div><p>
<a class="anchor" name="b1c4cc247bd379e340e25bd86911919d"></a><!-- doxytag: member="task.c::task_stopper" ref="b1c4cc247bd379e340e25bd86911919d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_stopper           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
The entry point for all tasks that are stopping </p>

<p>
If this task is being stopped by a call to <a class="el" href="group__task.html#ge1337adc1d63d7cd874a376d6513c04a" title="Stop a task.">stop_task()</a> with the <code>wait_for_mutexes</code> parameter set, then the task will continue to run as normal until the last mutex is released. When that happens, then this task stopper will start running on the task.<p>
First, interrupts are enabled, then any mailbox being read is released<p>
If the task has a cleanup procedure defined (the <code>cleanup</code> argument to <a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task()</a>), it is called<p>
Then, the task state is set to stopped, all mutexes and mailboxes are released, the (internal) task stopping semaphore is signalled, and a task switch is executed. 
</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="032a246385c40a7254d11dd557140401"></a><!-- doxytag: member="task.c::first_task" ref="032a246385c40a7254d11dd557140401" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtask__t.html">task_t</a>* <a class="el" href="task_8c.html#032a246385c40a7254d11dd557140401">first_task</a> = 0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
Pointer to the first task in our linked list </p>

<p>

</div>
</div><p>
<a class="anchor" name="8e20fafa56301aad5b476cbd2c9e5b48"></a><!-- doxytag: member="task.c::system" ref="8e20fafa56301aad5b476cbd2c9e5b48" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsystem__struct.html">system_struct</a> <a class="el" href="task_8h.html#8e20fafa56301aad5b476cbd2c9e5b48">system</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
The system stack, and a flag indicating whether the CPU is currently processing an interrupt </p>

<p>
<p><b>For internal use only.</b></p>
<p>
The <a class="el" href="structsystem__struct.html" title="Structure used by the system to hold the system stack, and a flag indicating whether...">system_struct</a> used to hold the system stack and a flag indicating whether an ISR is currently being executed </p>

</div>
</div><p>
<a class="anchor" name="add86cc9d9d60a1e9e90466dd09f3d3f"></a><!-- doxytag: member="task.c::task_stopping_semaphore" ref="add86cc9d9d60a1e9e90466dd09f3d3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsemaphore__t.html">semaphore_t</a> <a class="el" href="task_8c.html#add86cc9d9d60a1e9e90466dd09f3d3f">task_stopping_semaphore</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
A semaphore we use to not return from <a class="el" href="group__task.html#ge1337adc1d63d7cd874a376d6513c04a" title="Stop a task.">stop_task()</a> until the task in question has actually stopped </p>

<p>

</div>
</div><p>
<hr>
<p align="center"><font size="-1">YAVRTOS and YAVRTOS documentation Copyright &copy; 2007-2008 Chris O'Byrne. Email - chris &lt;at&gt; obyrne &lt;dot&gt; com</font></p>
</body></html>
