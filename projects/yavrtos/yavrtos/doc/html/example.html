<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>YAVRTOS: </title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
In this example, we will flash two LEDs connected to port A at different rates.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="code" href="task_8h.html">task.h</a>"</span>

<span class="preprocessor">#include &lt;stdint.h&gt;</span>
<span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
<span class="preprocessor">#include &lt;avr/io.h&gt;</span>
<span class="preprocessor">#include &lt;avr/sleep.h&gt;</span>

<span class="comment">// A semaphore that we will increment at every tick</span>
<span class="keyword">static</span> <a class="code" href="structsemaphore__t.html" title="Structure describing a semaphore.">semaphore_t</a> tick;
<span class="comment">// We will also create a mutex for port A, as both tasks will be using it potentially "simultaneously"</span>
<span class="keyword">static</span> <a class="code" href="structmutex__t.html" title="A structure describing a mutex.">mutex_t</a> porta_mutex;

<span class="comment">// This is our first task - blinking port A bit 0 once every 200 ticks</span>
<span class="keywordtype">void</span> blink1(<span class="keywordtype">void</span> *p) {
        <span class="keywordflow">while</span> (1) {
                <span class="comment">// Obtain a lock on the port A mutex</span>
                <a class="code" href="group__mutex.html#gdff77e0b451c30c07d2990e669f937c5" title="Lock on a mutex.">lock_on</a>(&amp;porta_mutex);
                <span class="comment">// OK - port A is now all ours, so blink the LED</span>
                PORTA ^= 0x01;
                <span class="comment">// Release our hold on the port A mutex</span>
                <a class="code" href="group__mutex.html#g327f419711064b7407f6f47011221cc4" title="Unlock a mutex.">lock_off</a>(&amp;porta_mutex);
                <span class="comment">// Now, suspend this task for another 200 ticks</span>
                <a class="code" href="group__semaphore.html#g291edcd883e2d0bc17f85419e21069ff" title="Wait for a semaphore to increment its value by a certain amount.">wait_for_increment_of</a>(&amp;tick, 200);
        }
}

<span class="comment">// This is our second task - blinking port A bit 1 once every 280 ticks</span>
<span class="keywordtype">void</span> blink2(<span class="keywordtype">void</span> *p) {
        <span class="keywordflow">while</span> (1) {
                <span class="comment">// Obtain a lock on the port A mutex</span>
                <a class="code" href="group__mutex.html#gdff77e0b451c30c07d2990e669f937c5" title="Lock on a mutex.">lock_on</a>(&amp;porta_mutex);
                <span class="comment">// OK - port A is now all ours, so blink the LED</span>
                PORTA ^= 0x02;
                <span class="comment">// Release our hold on the port A mutex</span>
                <a class="code" href="group__mutex.html#g327f419711064b7407f6f47011221cc4" title="Unlock a mutex.">lock_off</a>(&amp;porta_mutex);
                <span class="comment">// Now, suspend this task for another 280 ticks</span>
                <a class="code" href="group__semaphore.html#g291edcd883e2d0bc17f85419e21069ff" title="Wait for a semaphore to increment its value by a certain amount.">wait_for_increment_of</a>(&amp;tick, 280);
        }
}

<span class="comment">// This is our idle task - the task that runs when all others are suspended.</span>
<span class="comment">// We sleep the CPU - the CPU will automatically awake when the tick interrupt occurs</span>
<span class="keywordtype">void</span> idle_task(<span class="keywordtype">void</span> *p) {
        sleep_enable();
        sei();
        sleep_cpu();
        <span class="comment">// This task cannot be stopped, so it is automatically re-started whenever it tries to exit</span>
}

<span class="comment">// This is a function that runs every tick interrupt - we use it to increment the tick semaphore value by one</span>
uint8_t tick_interrupt() {
        <a class="code" href="group__semaphore.html#g3cd218588dccb32b5b9072c7a75fb008" title="Increment the value of a semaphore by the given amount.">increment_semaphore_by</a>(&amp;tick,1);
        <span class="comment">// We want a task switch to ALWAYS occur - it is part of the definition of the tick interrupt!</span>
        <span class="keywordflow">return</span> 1;
}

<span class="comment">// Setup the TIMER1_COMPA interrupt - it will be our tick interrupt</span>
<a class="code" href="group__isr.html#g3d04938242a5060aac8a64b72c055eb0" title="The macro for ISRs.">TASK_ISR</a>(TIMER1_COMPA_vect, tick_interrupt())

<span class="comment">// Our entry point</span>
int main(<span class="keywordtype">void</span>) {
        <span class="comment">// Interrupts should remain disabled - they will be enabled as soon as the first task starts executing</span>
        cli();
        <span class="comment">// Set up port A for output</span>
        DDRA = 0xFF;
        <span class="comment">// Our idle task sleeps the CPU - set the sleep mode to IDLE, as we need the sleep to be</span>
        <span class="comment">// interruptable by the tick interrupt</span>
        set_sleep_mode(SLEEP_MODE_IDLE);
        <span class="comment">// Create our two tasks</span>
        <a class="code" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task</a>(blink1, 0, 0, 55, 100, 0);
        <a class="code" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task</a>(blink2, 0, 0, 55, 100, 0);
        <span class="comment">// Set up our TIMER1_COMPA interrupt to tick every 80,000 clock cycles</span>
        TCCR1B = 0x0A;
        OCR1A = 9999;
        TIFR = _BV(OCF1A);
        TIMSK |= _BV(OCIE1A);
        <span class="comment">// Start the RTOS - note that this function will never return</span>
        <a class="code" href="group__task.html#g1398c4d9f97349ea3fa7d91349298521" title="Start the whole process running.">task_switcher_start</a>(idle_task, 0, 55, 55);
        <span class="keywordflow">return</span> 0;
}
</pre></div> <hr>
<p align="center"><font size="-1">YAVRTOS and YAVRTOS documentation Copyright &copy; 2007-2008 Chris O'Byrne. Email - chris &lt;at&gt; obyrne &lt;dot&gt; com</font></p>
</body></html>
