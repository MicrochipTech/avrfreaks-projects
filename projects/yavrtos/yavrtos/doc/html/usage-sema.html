<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>YAVRTOS: Using semaphores</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="usage.html">Using YAVRTOS</a></div>
<h1><a class="anchor" name="usage-sema">Using semaphores </a></h1>Semaphores are used to send signals between tasks, or between tasks and ISRs.<h2><a class="anchor" name="usage-sema-1">
Example 1 - signalling between tasks</a></h2>
<div class="fragment"><pre class="fragment"><a class="code" href="structsemaphore__t.html" title="Structure describing a semaphore.">semaphore_t</a> sema;

<span class="keywordtype">void</span> semaphore_receiving_task(<span class="keywordtype">void</span> *p) {
        <span class="keywordflow">while</span> (1) {
                <a class="code" href="group__semaphore.html#g291edcd883e2d0bc17f85419e21069ff" title="Wait for a semaphore to increment its value by a certain amount.">wait_for_increment_of</a>(&amp;sema, 1);
                do_stuff();
        }
}

<span class="keywordtype">void</span> semaphore_writing_task(<span class="keywordtype">void</span> *p) {
        <span class="keywordflow">while</span> (1) {
                wait_for_conditions_to_be_right();
                <a class="code" href="group__semaphore.html#g3cd218588dccb32b5b9072c7a75fb008" title="Increment the value of a semaphore by the given amount.">increment_semaphore_by</a>(&amp;sema, 1); <span class="comment">// This makes the "wait_for_increment_of()" function in the receiving task return</span>
        }
}
</pre></div> In the above example, if the <code>semaphore_receiving_task</code> is of higher priority than the <code>semaphore_writing_task</code>, then as soon as the <a class="el" href="group__semaphore.html#g3cd218588dccb32b5b9072c7a75fb008" title="Increment the value of a semaphore by the given amount.">increment_semaphore_by()</a> call is made, the <code>semaphore_receiving_task</code> will start executing.<h2><a class="anchor" name="usage-sema-2">
Example 2 - signalling tasks from an ISR</a></h2>
The classic use of semaphores is to provide tasks with an easy means of implementing a delay. This is done by having a semaphore increment during the tick - then tasks can use that semaphore's value to suspend themselves for a known period of time. <div class="fragment"><pre class="fragment"><a class="code" href="structsemaphore__t.html" title="Structure describing a semaphore.">semaphore_t</a> tick;

<span class="comment">// This is a function that runs every tick - we use it to increment the tick semaphore value by one</span>
uint8_t tick_interrupt() {
        <a class="code" href="group__semaphore.html#g3cd218588dccb32b5b9072c7a75fb008" title="Increment the value of a semaphore by the given amount.">increment_semaphore_by</a>(&amp;tick, 1);
        <span class="keywordflow">return</span> 1;
}

<span class="comment">// e.g. the TIMER1_COMPA interrupt is our tick interrupt</span>
<a class="code" href="group__isr.html#g3d04938242a5060aac8a64b72c055eb0" title="The macro for ISRs.">TASK_ISR</a>(TIMER1_COMPA_vect, tick_interrupt())

<span class="comment">// This task needs to periodically delay by 100 ticks</span>
void periodical_task(<span class="keywordtype">void</span> *p) {
        <span class="keywordflow">while</span> (1) {
                ...
                <a class="code" href="group__semaphore.html#g291edcd883e2d0bc17f85419e21069ff" title="Wait for a semaphore to increment its value by a certain amount.">wait_for_increment_of</a>(&amp;tick, 100); <span class="comment">// This function call won't return until 100 ticks have elapsed</span>
                ...
        }
}
</pre></div> <hr>
<p align="center"><font size="-1">YAVRTOS and YAVRTOS documentation Copyright &copy; 2007-2008 Chris O'Byrne. Email - chris &lt;at&gt; obyrne &lt;dot&gt; com</font></p>
</body></html>
