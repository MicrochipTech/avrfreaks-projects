<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>YAVRTOS: Tasks</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1>Tasks</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g42c4528688cb31827aa5efb696995642">interrupt_store_t</a>&nbsp;&nbsp;&nbsp;uint8_t</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A flag indicating whether interrupts were enabled - used by <a class="el" href="group__task.html#g6984a5336b36a4ca99682a2cf5ae044f" title="Disable interrupts system-wide.">disable_interrupts()</a> and <a class="el" href="group__task.html#gecf8a8e43c2afae89e46503ff1c887bf" title="Restore the state of the system-wide interrupts.">restore_interrupts()</a>.  <a href="#g42c4528688cb31827aa5efb696995642"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g934155282a1d689b554e90b5138e5135">reserve_task</a> (uint16_t stacklen, uint8_t pri, <a class="el" href="structmutex__t.html">mutex_t</a> *memory_mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tasks are kept in a linked list in memory - this function reserves an "empty" task on that list, ready to be subsequently utilised by a call to <a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task()</a>.  <a href="#g934155282a1d689b554e90b5138e5135"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3">create_task</a> (void(*proc)(void *), void(*cleanup)(), void *init_data, uint16_t stacklen, uint8_t pri, <a class="el" href="structmutex__t.html">mutex_t</a> *memory_mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a task, ready to be run.  <a href="#g9b849c9a0e0b29417cf47da99226dcc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ge1337adc1d63d7cd874a376d6513c04a">stop_task</a> (<a class="el" href="structtask__t.html">task_t</a> *t, uint8_t wait_for_mutexes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop a task.  <a href="#ge1337adc1d63d7cd874a376d6513c04a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g1a2a5bbefa85516b8c1d0e0361a834db">yield</a> () __attribute__((naked))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop executing the current task and try and execute a higher-priority task or another task of the same priority.  <a href="#g1a2a5bbefa85516b8c1d0e0361a834db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g1398c4d9f97349ea3fa7d91349298521">task_switcher_start</a> (void(*idle)(void *), void *idle_data, uint16_t idle_stacklen, uint16_t system_stacklen) __attribute__((naked))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the whole process running.  <a href="#g1398c4d9f97349ea3fa7d91349298521"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">interrupt_store_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g6984a5336b36a4ca99682a2cf5ae044f">disable_interrupts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable interrupts system-wide.  <a href="#g6984a5336b36a4ca99682a2cf5ae044f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#gecf8a8e43c2afae89e46503ff1c887bf">restore_interrupts</a> (interrupt_store_t interrupts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restore the state of the system-wide interrupts.  <a href="#gecf8a8e43c2afae89e46503ff1c887bf"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g4743b3673a8794b8e7bd0b6c91a63cd5">current_task</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current task.  <a href="#g4743b3673a8794b8e7bd0b6c91a63cd5"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A task performs a function in the application, and an application can have a number of tasks running "simultaneously". Tasks are a function with the signature <code>void task_func(void *init)</code>, and optionally a "cleanup" function <code>void task_cleanup()</code> that is called when the task is exiting. The value of the <code>init</code> argument to the task function is specified when the task is created.<p>
Tasks are created by <a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task()</a>, and can be stopped by <a class="el" href="group__task.html#ge1337adc1d63d7cd874a376d6513c04a" title="Stop a task.">stop_task()</a>. Tasks are held in memory in a linked list - spaces may be reserved on that list for future tasks using <a class="el" href="group__task.html#g934155282a1d689b554e90b5138e5135" title="Tasks are kept in a linked list in memory - this function reserves an &quot;empty&quot;...">reserve_task()</a>.<p>
Tasks can suspend themselves when they are unable to do any work (e.g. a task that reads a microcontroller peripheral could suspend itself when the peripheral has no data available), hence allowing other tasks that can do work to run, and hence the application as a whole can get the maximum use of the CPU's processing power. The ways a task can suspend itself are <ul>
<li>by calling <a class="el" href="group__mutex.html#gdff77e0b451c30c07d2990e669f937c5" title="Lock on a mutex.">lock_on()</a> on a <a class="el" href="group__mutex.html">mutex</a> that another task has already locked on to. Note that <a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task()</a> and <a class="el" href="group__task.html#g934155282a1d689b554e90b5138e5135" title="Tasks are kept in a linked list in memory - this function reserves an &quot;empty&quot;...">reserve_task()</a> can decide to lock on to a supplied "memory mutex" - see <a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task()</a>, <a class="el" href="group__task.html#g934155282a1d689b554e90b5138e5135" title="Tasks are kept in a linked list in memory - this function reserves an &quot;empty&quot;...">reserve_task()</a> and <a class="el" href="howdoi.html#malloc">How do I use malloc() and free() safely?</a> </li>
<li>by calling <a class="el" href="group__semaphore.html#g45243d3de7a253445deeb57ee4c8cc96" title="Wait for a semaphore to reach at least a particular value.">wait_for_min_value()</a> on a <a class="el" href="group__semaphore.html">semaphore</a> that hasn't yet reached the specified value </li>
<li>by calling <a class="el" href="group__semaphore.html#g291edcd883e2d0bc17f85419e21069ff" title="Wait for a semaphore to increment its value by a certain amount.">wait_for_increment_of()</a> on a <a class="el" href="group__semaphore.html">semaphore</a> </li>
<li>by calling <a class="el" href="group__mailbox.html#g5dbb6937f6f93f6a1c14dec5b1c197c3" title="Wait for a mailbox to reach at least a certain version, and then start reading from...">read_mbox_min_version()</a> on a <a class="el" href="group__mailbox.html">mailbox</a> that hasn't yet reached the specified version </li>
<li>by calling <a class="el" href="group__mailbox.html#gc75646248d03b1413198765b07ba54ad" title="Write to a mailbox.">write_mbox()</a> - see <a class="el" href="group__mailbox.html#gc75646248d03b1413198765b07ba54ad" title="Write to a mailbox.">write_mbox()</a> for the conditions under which a task will be suspended </li>
<li>by calling <a class="el" href="group__mailbox.html#gf670250659f0942849aa85f0f94af9f0" title="Wait for a task to be suspended while trying to read from a mailbox.">wait_for_receiver()</a> on a <a class="el" href="group__mailbox.html">mailbox</a> that no-one is waiting to read from </li>
<li>a temporary suspension can be caused by calling <a class="el" href="group__task.html#g1a2a5bbefa85516b8c1d0e0361a834db" title="Stop executing the current task and try and execute a higher-priority task or another...">yield()</a> - if there are other schedulable tasks, they will run, but the calling task will eventually be re-scheduled to run </li>
<li>by waiting for another task to stop - see <a class="el" href="group__task.html#ge1337adc1d63d7cd874a376d6513c04a" title="Stop a task.">stop_task()</a> for more information</li>
</ul>
Every task has a priority. The rule is that the RTOS will not allow the lowest-priority tasks to run until all higher-priority tasks have suspended themselves. If there are more than one highest-priority not-suspended tasks, then the RTOS will switch between them once every tick interrupt (and/or whenever one of the tasks calls <a class="el" href="group__task.html#g1a2a5bbefa85516b8c1d0e0361a834db" title="Stop executing the current task and try and execute a higher-priority task or another...">yield()</a>).<p>
A priority of zero indicates an "idle" task - a task that is run when there are no other tasks that can run. There must always be at least one idle task, and idle tasks can neither be stopped nor can they do anything to suspend themselves (e.g. they cannot wait for a mutex to be released), as the microcontroller needs at least one task to be always available for scheduling. Usually there is just one idle task that just sleeps the CPU. A recommended idle task is <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> idle_task(<span class="keywordtype">void</span> *p) {
  set_sleep_mode(SLEEP_MODE_IDLE);
  sleep_enable();
  sei();
  sleep_cpu();
}
</pre></div><p>
A task switch can occur <ul>
<li>whenever anything happens to a mutex, semaphore or mailbox that may cancel the suspension of a higher priority task (e.g. when a semaphore has its value increased) </li>
<li>when a task calls <a class="el" href="group__task.html#g1a2a5bbefa85516b8c1d0e0361a834db" title="Stop executing the current task and try and execute a higher-priority task or another...">yield()</a> </li>
<li>when the system tick interrupt happens - see <a class="el" href="group__isr.html">Interrupt Service Routines</a> for more information about the tick interrupt.</li>
</ul>
From the point of view of the RTOS, the microcontroller can be doing one of three things <ul>
<li>executing code before the RTOS has been started with a call to <a class="el" href="group__task.html#g1398c4d9f97349ea3fa7d91349298521" title="Start the whole process running.">task_switcher_start()</a>. When the microcontroller is in this state, the RTOS is obviously unable to "suspend" what the microcontroller is doing, and hence none of the API calls that could cause such a suspension may be used </li>
<li>executing a task, which can be an "idle" task of zero priority, or a "non-idle" task of non-zero priority. When executing an idle task, a task suspension is disallowed (as there must always be something that the microcontroller can do when it is otherwise unable to do anything). </li>
<li>executing an ISR, including the tick interrupt ISR. Again, the RTOS is unable to suspend the ISR.</li>
</ul>
Therefore there are restrictions on when certain API calls may be made - these restrictions are summarised on the <a class="el" href="api-usage-restrictions.html">api usage restrictions</a> page.<p>
See the <a class="el" href="example.html">example application</a> for an example of how to start and run some simple tasks.<p>
Tasks can be stopped by other tasks or by ISRs - see <a class="el" href="group__task.html#ge1337adc1d63d7cd874a376d6513c04a" title="Stop a task.">stop_task()</a>. When a task is stopped, mutexes and mailboxes are released - see <a class="el" href="task_8c.html#b1c4cc247bd379e340e25bd86911919d" title="The entry point for all tasks that are stopping">task_stopper()</a> <hr><h2>Define Documentation</h2>
<a class="anchor" name="g42c4528688cb31827aa5efb696995642"></a><!-- doxytag: member="task.h::interrupt_store_t" ref="g42c4528688cb31827aa5efb696995642" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define interrupt_store_t&nbsp;&nbsp;&nbsp;uint8_t          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A flag indicating whether interrupts were enabled - used by <a class="el" href="group__task.html#g6984a5336b36a4ca99682a2cf5ae044f" title="Disable interrupts system-wide.">disable_interrupts()</a> and <a class="el" href="group__task.html#gecf8a8e43c2afae89e46503ff1c887bf" title="Restore the state of the system-wide interrupts.">restore_interrupts()</a>. 
<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g9b849c9a0e0b29417cf47da99226dcc3"></a><!-- doxytag: member="task.h::create_task" ref="g9b849c9a0e0b29417cf47da99226dcc3" args="(void(*proc)(void *), void(*cleanup)(), void *init_data, uint16_t stacklen, uint8_t pri, mutex_t *memory_mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtask__t.html">task_t</a>* create_task           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&nbsp;</td>
          <td class="paramname"> <em>cleanup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>init_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>stacklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>pri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&nbsp;</td>
          <td class="paramname"> <em>memory_mutex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a task, ready to be run. 
<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd><a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task()</a> can call malloc(), and disables interrupts during any call to malloc(). Therefore, depending on the amount of time your malloc() algorithm takes, and depending on what your time margin for the launch of ISRs is, <a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task()</a> could disable interrupts for "too long". See the description of the <code>memory_mutex</code> argument, and <a class="el" href="howdoi.html#malloc">How do I use malloc() and free() safely?</a></dd></dl>
The arguments are <ul>
<li>
<code>proc</code> - this is the task function. Upon entry, interrupts will be enabled, and the value of the argument will be that of <code>init_data</code>. This function does not need to contain an infinite loop - if it returns (and if the priority is greater than zero), a stop will be performed on the task. </li>
<li>
<code>cleanup</code> - this is the task cleanup function, which will be called as the task is dying. May be null if the task doesn't need to clean up after itself. See <a class="el" href="task_8c.html#b1c4cc247bd379e340e25bd86911919d" title="The entry point for all tasks that are stopping">task_stopper()</a> </li>
<li>
<code>init_data</code> - this is the value that will be given in the argument to <code>proc</code> when it starts </li>
<li>
<code>stacklen</code> - the number of bytes to reserve for the task stack. Note that it must be long enough to hold a copy of the value of all 32 registers when a task switch occurs, and it needs a couple of extra bytes to handle interrupts, function calls etc. </li>
<li>
<code>pri</code> - the priority of the task. The highest-priority available task will "hog" the CPU. If the task has a priority of zero (an "idle" task), then it may not suspend itself on a mutex, semaphore or mailbox, and it may not be stopped. </li>
<li>
<code>memory_mutex</code> - if not null, and if called from within a non-idle task, this mutex will be locked on to during the call to malloc(), otherwise interrupts will be disabled during the call to malloc() - see <a class="el" href="howdoi.html#malloc">How do I use malloc() and free() safely?</a> </li>
</ul>
<p>
This function will scan through the task list in memory, looking for one that is not being used with a matching pri and a stacklen that is at least as large as that required. If it cannot find such a task, it will create a brand new one. See <a class="el" href="group__task.html#g934155282a1d689b554e90b5138e5135" title="Tasks are kept in a linked list in memory - this function reserves an &quot;empty&quot;...">reserve_task()</a> 
</div>
</div><p>
<a class="anchor" name="g6984a5336b36a4ca99682a2cf5ae044f"></a><!-- doxytag: member="task.h::disable_interrupts" ref="g6984a5336b36a4ca99682a2cf5ae044f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">interrupt_store_t disable_interrupts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable interrupts system-wide. 
<p>
Returns a value which is non-zero if interrupts were enabled. Can be called from anywhere. 
</div>
</div><p>
<a class="anchor" name="g934155282a1d689b554e90b5138e5135"></a><!-- doxytag: member="task.h::reserve_task" ref="g934155282a1d689b554e90b5138e5135" args="(uint16_t stacklen, uint8_t pri, mutex_t *memory_mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtask__t.html">task_t</a>* reserve_task           </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>stacklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>pri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&nbsp;</td>
          <td class="paramname"> <em>memory_mutex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tasks are kept in a linked list in memory - this function reserves an "empty" task on that list, ready to be subsequently utilised by a call to <a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task()</a>. 
<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd><a class="el" href="group__task.html#g934155282a1d689b554e90b5138e5135" title="Tasks are kept in a linked list in memory - this function reserves an &quot;empty&quot;...">reserve_task()</a> calls malloc(), and disables interrupts during the call to malloc(). Therefore, depending on the amount of time your malloc() algorithm takes, and depending on what your time margin for the launch of ISRs is, <a class="el" href="group__task.html#g934155282a1d689b554e90b5138e5135" title="Tasks are kept in a linked list in memory - this function reserves an &quot;empty&quot;...">reserve_task()</a> could disable interrupts for "too long". See the description of the <code>memory_mutex</code> argument, and <a class="el" href="howdoi.html#malloc">How do I use malloc() and free() safely?</a></dd></dl>
The arguments are <ul>
<li><code>stacklen</code> - the number of bytes to reserve for the task stack. Note that it must be long enough to hold a copy of the value of all 32 registers when a task switch occurs, and it needs a couple of extra bytes to handle interrupts, function calls etc. </li>
<li><code>pri</code> - the priority of the task. The highest-priority available task will "hog" the CPU. If the task has a priority of zero (an "idle" task), then it may not suspend itself on a mutex, semaphore or mailbox. </li>
<li><code>memory_mutex</code> - if not null, and if called from within a non-idle task, this mutex will be locked on to during the call to malloc(), otherwise interrupts will be disabled during the call to malloc() - see <a class="el" href="howdoi.html#malloc">How do I use malloc() and free() safely?</a>. </li>
</ul>

</div>
</div><p>
<a class="anchor" name="gecf8a8e43c2afae89e46503ff1c887bf"></a><!-- doxytag: member="task.h::restore_interrupts" ref="gecf8a8e43c2afae89e46503ff1c887bf" args="(interrupt_store_t interrupts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void restore_interrupts           </td>
          <td>(</td>
          <td class="paramtype">interrupt_store_t&nbsp;</td>
          <td class="paramname"> <em>interrupts</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restore the state of the system-wide interrupts. 
<p>
A non-zero argument enables interrupts. Can be called from anywhere. 
</div>
</div><p>
<a class="anchor" name="ge1337adc1d63d7cd874a376d6513c04a"></a><!-- doxytag: member="task.h::stop_task" ref="ge1337adc1d63d7cd874a376d6513c04a" args="(task_t *t, uint8_t wait_for_mutexes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t stop_task           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>wait_for_mutexes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stop a task. 
<p>
The arguments are <ul>
<li><code>t</code> the task to stop </li>
<li><code>wait_for_mutexes</code> - if not zero, the task will not be stopped until it has released all of its mutexes. If zero, then the tasks will stop immediately. Note that if you are using a memory mutex, you <b>must</b> set <code>wait_for_mutexes</code> when stopping any task that uses the memory mutex - see <a class="el" href="howdoi.html#malloc">How do I use malloc() and free() safely?</a></li>
</ul>
This function can be called by the current task (stop_task(current_task, ...)), or by a higher-priority task, or by an ISR, and may be called on any non-zero-priority task.<p>
If this function is called by the current task, and <code>wait_for_mutexes</code> isn't set, then the "cleaning up" of the task (<a class="el" href="task_8c.html#b1c4cc247bd379e340e25bd86911919d" title="The entry point for all tasks that are stopping">task_stopper()</a>) will start executing immediately - i.e. the stop_task(current_task, 0) call won't "return". If <code>wait_for_mutexes</code> is set, then the <a class="el" href="group__mutex.html#g327f419711064b7407f6f47011221cc4" title="Unlock a mutex.">lock_off()</a> that releases the tasks' last mutex won't return - the <a class="el" href="task_8c.html#b1c4cc247bd379e340e25bd86911919d" title="The entry point for all tasks that are stopping">task_stopper()</a> will run instead.<p>
If this function is called by a higher priority task, then it will not return until the task in question has completely stopped executing.<p>
If this function is called from within an ISR, it will return immediately.<p>
A return value of -1 means that the calling task doesn't have the required permission. A return value of -2 means that an attempt was made to stop a zero-priority task. A return value of zero indicates success, and a return value of 1 means that the task was already stopped.<p>
See <a class="el" href="task_8c.html#b1c4cc247bd379e340e25bd86911919d" title="The entry point for all tasks that are stopping">task_stopper()</a> for a description of what happens to the task that is being stopped. 
</div>
</div><p>
<a class="anchor" name="g1398c4d9f97349ea3fa7d91349298521"></a><!-- doxytag: member="task.h::task_switcher_start" ref="g1398c4d9f97349ea3fa7d91349298521" args="(void(*idle)(void *), void *idle_data, uint16_t idle_stacklen, uint16_t system_stacklen) __attribute__((naked))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_switcher_start           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>idle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>idle_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>idle_stacklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>system_stacklen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start the whole process running. 
<p>
Note that this method will never return. The arguments are <ul>
<li><code>idle</code> - the "idle" function (the function to execute when we have nothing else to do) </li>
<li><code>idle_data</code> - the value of the argument to <code>idle</code> when it starts </li>
<li><code>idle_stacklen</code> - the length of the stack for the "idle" function - see <a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task()</a> </li>
<li><code>system_stacklen</code> - the length of the system stack - this is the stack that will be in use during all ISRs</li>
</ul>
A recommended idle task is - <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> idle_task() {
   set_sleep_mode(SLEEP_MODE_IDLE);
   sleep_enable();
   sei();
   sleep_cpu();
 }
</pre></div><p>
See <a class="el" href="example.html">the example application</a> for an example of how to start the task switcher.<p>
Note that, if you are using the <a class="el" href="group__isr.html#g3d04938242a5060aac8a64b72c055eb0" title="The macro for ISRs.">TASK_ISR()</a> macro to give your ISRs access to the system stack (and you should!), then all interrupts must remain disabled right up until this function is called. Interrupts will be enabled as soon as the first task switch starts. 
</div>
</div><p>
<a class="anchor" name="g1a2a5bbefa85516b8c1d0e0361a834db"></a><!-- doxytag: member="task.h::yield" ref="g1a2a5bbefa85516b8c1d0e0361a834db" args="() __attribute__((naked))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yield           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stop executing the current task and try and execute a higher-priority task or another task of the same priority. 
<p>
Note that all API calls that could theoretically cause a higher-priority task to be re-enabled will call <a class="el" href="group__task.html#g1a2a5bbefa85516b8c1d0e0361a834db" title="Stop executing the current task and try and execute a higher-priority task or another...">yield()</a>, which will cause an automatic and immediate task switch to that higher-priority task. (This also means that if there is another task of the same priority that hasn't been disabled, all such API calls will cause a task switch to that task).<p>
Obviously this function can only be called by tasks, and it will "return" the next time it is the turn of the current task to execute. 
</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="g4743b3673a8794b8e7bd0b6c91a63cd5"></a><!-- doxytag: member="task.h::current_task" ref="g4743b3673a8794b8e7bd0b6c91a63cd5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtask__t.html">task_t</a>* <a class="el" href="group__task.html#g4743b3673a8794b8e7bd0b6c91a63cd5">current_task</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The current task. 
<p>
This value may be used in <a class="el" href="group__task.html#ge1337adc1d63d7cd874a376d6513c04a" title="Stop a task.">stop_task()</a> to stop the current task 
</div>
</div><p>
<hr>
<p align="center"><font size="-1">YAVRTOS and YAVRTOS documentation Copyright &copy; 2007-2008 Chris O'Byrne. Email - chris &lt;at&gt; obyrne &lt;dot&gt; com</font></p>
</body></html>
