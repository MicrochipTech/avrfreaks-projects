<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>YAVRTOS: task.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1>task.h File Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsemaphore__t.html">semaphore_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure describing a semaphore.  <a href="structsemaphore__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmailbox__t.html">mailbox_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure describing mailboxes.  <a href="structmailbox__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtask__t.html">task_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure describing a task.  <a href="structtask__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutex__t.html">mutex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A structure describing a mutex.  <a href="structmutex__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsystem__struct.html">system_struct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Structure used by the system to hold the system stack, and a flag indicating whether an ISR is currently being executed. </p>
 <a href="structsystem__struct.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g42c4528688cb31827aa5efb696995642">interrupt_store_t</a>&nbsp;&nbsp;&nbsp;uint8_t</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A flag indicating whether interrupts were enabled - used by <a class="el" href="group__task.html#g6984a5336b36a4ca99682a2cf5ae044f" title="Disable interrupts system-wide.">disable_interrupts()</a> and <a class="el" href="group__task.html#gecf8a8e43c2afae89e46503ff1c887bf" title="Restore the state of the system-wide interrupts.">restore_interrupts()</a>.  <a href="group__task.html#g42c4528688cb31827aa5efb696995642"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8h.html#bedcaab91615f58a55ed4135438618e8">save_cpu_context</a>()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Save the CPU context to the stack, and disable interrupts </p>
 <a href="#bedcaab91615f58a55ed4135438618e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8h.html#7e11bac5a51572c5db72502c47cf90d3">restore_cpu_context</a>()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Restore the CPU context from the stack, possibly re-enabling interrupts </p>
 <a href="#7e11bac5a51572c5db72502c47cf90d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr.html#g3d04938242a5060aac8a64b72c055eb0">TASK_ISR</a>(vector, do_task_switch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The macro for ISRs.  <a href="group__isr.html#g3d04938242a5060aac8a64b72c055eb0"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g934155282a1d689b554e90b5138e5135">reserve_task</a> (uint16_t stacklen, uint8_t pri, <a class="el" href="structmutex__t.html">mutex_t</a> *memory_mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tasks are kept in a linked list in memory - this function reserves an "empty" task on that list, ready to be subsequently utilised by a call to <a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task()</a>.  <a href="group__task.html#g934155282a1d689b554e90b5138e5135"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3">create_task</a> (void(*proc)(void *), void(*cleanup)(), void *init_data, uint16_t stacklen, uint8_t pri, <a class="el" href="structmutex__t.html">mutex_t</a> *memory_mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a task, ready to be run.  <a href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ge1337adc1d63d7cd874a376d6513c04a">stop_task</a> (<a class="el" href="structtask__t.html">task_t</a> *t, uint8_t wait_for_mutexes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop a task.  <a href="group__task.html#ge1337adc1d63d7cd874a376d6513c04a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g1a2a5bbefa85516b8c1d0e0361a834db">yield</a> () __attribute__((naked))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop executing the current task and try and execute a higher-priority task or another task of the same priority.  <a href="group__task.html#g1a2a5bbefa85516b8c1d0e0361a834db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gdff77e0b451c30c07d2990e669f937c5">lock_on</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock on a mutex.  <a href="group__mutex.html#gdff77e0b451c30c07d2990e669f937c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#g327f419711064b7407f6f47011221cc4">lock_off</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a mutex.  <a href="group__mutex.html#g327f419711064b7407f6f47011221cc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g9b7e62ecd1a61eda8cfa1229df0728ef">get_current_mbox_version</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *mbox)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current version of a mailbox.  <a href="group__mailbox.html#g9b7e62ecd1a61eda8cfa1229df0728ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g5dbb6937f6f93f6a1c14dec5b1c197c3">read_mbox_min_version</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *mbox, int16_t *version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a mailbox to reach at least a certain version, and then start reading from it.  <a href="group__mailbox.html#g5dbb6937f6f93f6a1c14dec5b1c197c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g86030bb5345670ca374ddd20ef8e4ff6">read_mbox</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *mbox, int16_t *version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a mailbox.  <a href="group__mailbox.html#g86030bb5345670ca374ddd20ef8e4ff6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structmailbox__t.html">mailbox_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g31b8ee5f4cd547c128143d99ea1c4a96">release_mbox_read</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to call when finished reading from a mailbox.  <a href="group__mailbox.html#g31b8ee5f4cd547c128143d99ea1c4a96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#gd4cde27abfbedc7c8e854e76d71612dd">initialise_mbox</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *mbox, void *data, const int16_t version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise a mailbox - this <b>must</b> be called on every mailbox before it is used.  <a href="group__mailbox.html#gd4cde27abfbedc7c8e854e76d71612dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#gc75646248d03b1413198765b07ba54ad">write_mbox</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *mbox, void *data, uint8_t wait_for_receivers, uint8_t wait_for_empty_nullify)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to a mailbox.  <a href="group__mailbox.html#gc75646248d03b1413198765b07ba54ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g87f02ab5b46654ae26b06851b2390132">write_mbox_now</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *mbox, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to write to a mailbox.  <a href="group__mailbox.html#g87f02ab5b46654ae26b06851b2390132"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#gf670250659f0942849aa85f0f94af9f0">wait_for_receiver</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *mbox)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a task to be suspended while trying to read from a mailbox.  <a href="group__mailbox.html#gf670250659f0942849aa85f0f94af9f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#g45243d3de7a253445deeb57ee4c8cc96">wait_for_min_value</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *s, int16_t value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a semaphore to reach at least a particular value.  <a href="group__semaphore.html#g45243d3de7a253445deeb57ee4c8cc96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#g291edcd883e2d0bc17f85419e21069ff">wait_for_increment_of</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *p, uint16_t amount)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a semaphore to increment its value by a certain amount.  <a href="group__semaphore.html#g291edcd883e2d0bc17f85419e21069ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#g3c18e0f867a2f36f1510aebf5ad4c0e2">get_semaphore_value</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current value of a semaphore.  <a href="group__semaphore.html#g3c18e0f867a2f36f1510aebf5ad4c0e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#g3cd218588dccb32b5b9072c7a75fb008">increment_semaphore_by</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *s, uint16_t amount)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment the value of a semaphore by the given amount.  <a href="group__semaphore.html#g3cd218588dccb32b5b9072c7a75fb008"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g1398c4d9f97349ea3fa7d91349298521">task_switcher_start</a> (void(*idle)(void *), void *idle_data, uint16_t idle_stacklen, uint16_t system_stacklen) __attribute__((naked))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the whole process running.  <a href="group__task.html#g1398c4d9f97349ea3fa7d91349298521"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">interrupt_store_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g6984a5336b36a4ca99682a2cf5ae044f">disable_interrupts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable interrupts system-wide.  <a href="group__task.html#g6984a5336b36a4ca99682a2cf5ae044f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#gecf8a8e43c2afae89e46503ff1c887bf">restore_interrupts</a> (interrupt_store_t interrupts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restore the state of the system-wide interrupts.  <a href="group__task.html#gecf8a8e43c2afae89e46503ff1c887bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8h.html#6587681a992e6e80317747df4d29b46b">switch_task</a> () __attribute__((naked))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Perform a task switch </p>
 <a href="#6587681a992e6e80317747df4d29b46b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g4743b3673a8794b8e7bd0b6c91a63cd5">current_task</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current task.  <a href="group__task.html#g4743b3673a8794b8e7bd0b6c91a63cd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structsystem__struct.html">system_struct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8h.html#8e20fafa56301aad5b476cbd2c9e5b48">system</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
The <a class="el" href="structsystem__struct.html" title="Structure used by the system to hold the system stack, and a flag indicating whether...">system_struct</a> used to hold the system stack and a flag indicating whether an ISR is currently being executed </p>
 <a href="#8e20fafa56301aad5b476cbd2c9e5b48"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="7e11bac5a51572c5db72502c47cf90d3"></a><!-- doxytag: member="task.h::restore_cpu_context" ref="7e11bac5a51572c5db72502c47cf90d3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define restore_cpu_context          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">__asm__ <span class="keyword">volatile</span> ( \
                <span class="stringliteral">"pop r0\n"</span> \
                <span class="stringliteral">"pop r31\n pop r30\n pop r29\n pop r28\n pop r27\n pop r26\n pop r25\n pop r24\n"</span> \
                <span class="stringliteral">"pop r23\n pop r22\n pop r21\n pop r20\n pop r19\n pop r18\n pop r17\n pop r16\n"</span> \
                <span class="stringliteral">"pop r15\n pop r14\n pop r13\n pop r12\n pop r11\n pop r10\n pop  r9\n pop  r8\n"</span> \
                <span class="stringliteral">"pop  r7\n pop  r6\n pop  r5\n pop  r4\n pop  r3\n pop  r2\n pop  r1\n out 0x3f, r0\n pop  r0\n"</span> ::)
</pre></div><p><b>For internal use only.</b></p>
<p>
Restore the CPU context from the stack, possibly re-enabling interrupts </p>

<p>

</div>
</div><p>
<a class="anchor" name="bedcaab91615f58a55ed4135438618e8"></a><!-- doxytag: member="task.h::save_cpu_context" ref="bedcaab91615f58a55ed4135438618e8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define save_cpu_context          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">__asm__ <span class="keyword">volatile</span>( \
                <span class="stringliteral">"push  r0\n in r0, 0x3f\n cli\n"</span> \
                <span class="stringliteral">"push  r1\n push  r2\n push  r3\n push  r4\n push  r5\n push  r6\n push  r7\n"</span> \
                <span class="stringliteral">"push  r8\n push  r9\n push r10\n push r11\n push r12\n push r13\n push r14\n push r15\n"</span> \
                <span class="stringliteral">"push r16\n push r17\n push r18\n push r19\n push r20\n push r21\n push r22\n push r23\n"</span> \
                <span class="stringliteral">"push r24\n push r25\n push r26\n push r27\n push r28\n push r29\n push r30\n push r31\n"</span> \
                <span class="stringliteral">"push  r0\n"</span> ::)
</pre></div><p><b>For internal use only.</b></p>
<p>
Save the CPU context to the stack, and disable interrupts </p>

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="6587681a992e6e80317747df4d29b46b"></a><!-- doxytag: member="task.h::switch_task" ref="6587681a992e6e80317747df4d29b46b" args="() __attribute__((naked))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void switch_task           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
Perform a task switch </p>

<p>
Note that interrupts must be disabled before we enter, and the stack pointer should be set up to use the system stack. 
</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="8e20fafa56301aad5b476cbd2c9e5b48"></a><!-- doxytag: member="task.h::system" ref="8e20fafa56301aad5b476cbd2c9e5b48" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsystem__struct.html">system_struct</a> <a class="el" href="task_8h.html#8e20fafa56301aad5b476cbd2c9e5b48">system</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
The <a class="el" href="structsystem__struct.html" title="Structure used by the system to hold the system stack, and a flag indicating whether...">system_struct</a> used to hold the system stack and a flag indicating whether an ISR is currently being executed </p>

<p>

</div>
</div><p>
<hr>
<p align="center"><font size="-1">YAVRTOS and YAVRTOS documentation Copyright &copy; 2007-2008 Chris O'Byrne. Email - chris &lt;at&gt; obyrne &lt;dot&gt; com</font></p>
</body></html>
