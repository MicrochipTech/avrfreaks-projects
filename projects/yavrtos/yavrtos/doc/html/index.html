<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>YAVRTOS: YAVRTOS</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1>YAVRTOS</h1>
<p>
<h3 align="center">v1.6b2(2008-Jan-25) </h3> 
<h2><a class="anchor" name="History">
History</a></h2>
YAVRTOS was my Christmas 2007-2008 project. I decided to do it <ul>
<li>because I wanted a good RTOS for other projects </li>
<li>to see if I could write an RTOS </li>
<li>because I didn't fully understand the other RTOSes out there</li>
</ul>
Since understanding is one of my aims, I have documented YAVRTOS in the hope that it will help others who were in the same situation as me.<h2><a class="anchor" name="naming">
What's in a name?</a></h2>
YAVRTOS stands for Yet Another Atmel&reg; AVR&reg; Real-Time Operating System<h2><a class="anchor" name="TandC">
Terms and Conditions</a></h2>
YAVROTS is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.<p>
YAVROTS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the <a class="el" href="lgpl.html">GNU Lesser General Public License</a> for more details.<h2><a class="anchor" name="prereq">
Pre-requisites</a></h2>
I've developed this using the WinAVR&trade; compiler (<a href="http://winavr.sourceforge.net/">http://winavr.sourceforge.net/</a>), and the AVR&reg; Studio debugger (available from <a href="http://www.atmel.com/">http://www.atmel.com/</a>). I've only tested it against an ATmega32 so far.<h2><a class="anchor" name="Status">
Status</a></h2>
At present, this project has not been rigorously tested. I've run many tests against the AVR&reg; Studio debugger running an ATmega32, and everything seems to work. I've started to use it on another project, and I've met with success. This other project uses mailboxes (which in turn use semaphores) fairly extensively, and it also bit-bang receives serial data at 4800 baud on an 8MHz ATmega32.<p>
Apart from testing, there are some other things I want to do with this project<ul>
<li>more documentation</li><li>at present, malloc() can be used by <a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task()</a> and <a class="el" href="group__task.html#g934155282a1d689b554e90b5138e5135" title="Tasks are kept in a linked list in memory - this function reserves an &quot;empty&quot;...">reserve_task()</a>, and interrupts are disabled during the calls to malloc(). The solution I have - a mutex for the microcontrollers' memory - isn't that bad, I think. A more interesting solution would be to write a thread-safe malloc()...</li></ul>
<p>
What all this means is that you should check back  
<a href="http://www.chris.obyrne.com/yavrtos/">here</a>
 often for updates, and you should check that YAVRTOS works as expected in your application. If you find a bug, please email me (my email address is at the bottom of the page) - as you can see from <a class="el" href="rev.html">the revision history</a>, YAVRTOS is in active development in December 2007 / January 2008.<h2><a class="anchor" name="What">
What is a real-time operating system?</a></h2>
Processors are only actually only able to do one thing at a time, whereas we need them to do more than one thing at a time (e.g. update the display while checking for keypresses while reading the serial port). A real-time operating system (RTOS) provides facilities for achieving that.<h2><a class="anchor" name="what-task">
What is a task?</a></h2>
A task does one of the things (e.g. update the display, check for keypresses, read the serial port) that the application needs done. The real-time operating system allows tasks to execute concurrently, while providing facilities for e.g. tasks to communicate with each other. See the <a class="el" href="group__task.html">task</a> page for more information.<h2><a class="anchor" name="what-tick">
What is a tick?</a></h2>
The RTOS needs to be able to switch betwen tasks - they way it does this is by using a regular processor interrupt (e.g. one of the timer interrupts). Every such interrupt is called a "tick". These interrupts must be set up before the RTOS is started. See <a class="el" href="group__isr.html">Interrupt Service Routines</a> for more information.<h2><a class="anchor" name="what-scheduler">
What is the task scheduler?</a></h2>
The task scheduler (or "task switcher") is the central component of the RTOS. It is responsible for ensuring that the tasks are run according to the rules of priority. It runs every tick, and it also runs when anything happens that may change the list of runnable tasks (e.g. a mutex being released, or a semaphore changing value).<p>
When the task scheduler runs, it effectively generates a list of the highest-priority runnable tasks. If one of those tasks has just had control of the processor, it runs the next task in the list, otherwise it runs the first task in the list.<h2><a class="anchor" name="what-stack">
What is the stack?</a></h2>
The stack is the standard stack that the processor implements with its stack pointer. However, when more than one task can be executing at a time, the stack becomes more complicated. In particular, every task must have its own stack, and the size of this stack is specified when the task is created. And, each stack must be large enough to accommodate all the uses the task puts the stack to.<p>
As well as a stack for each task, there is another "system" stack - this stack is used by ISRs, and must also be large enough to accommodate the requirements of the ISRs. If it is possible for more than one ISR to be running concurrently, then the system stack must be large enough to accommodate the requirements of all the ISRs that could be running concurrently.<h2><a class="anchor" name="what-stack-uses">
What are the uses the stack is put to?</a></h2>
The stack is used -<p>
<ul>
<li>To hold the value of local variables. For instance, <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> proc() {
        <span class="keywordtype">char</span> c;
</pre></div> The variable "c" will use up one byte of the stack. </li>
<li>To hold the return address of function calls. <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> proc() {
        proc2();
</pre></div> The call to proc2() will use up two bytes of the stack. </li>
<li>To hold the CPU context on task switch - there must be at least 35 bytes on the stack to handle task switching </li>
<li>To hold the return address, and some other information, on interrupt - this takes maybe another 10 bytes of stack </li>
<li>As a system scratchpad - maybe another half-dozen bytes of stack.</li>
</ul>
So a minimum stack size would be about 55 bytes.<h2><a class="anchor" name="what-small-stack">
What happens if the stack isn't big enough?</a></h2>
Memory corruption, and hence a probable spectacular (and untraceable) crash.<h2><a class="anchor" name="seealso">
Further reading</a></h2>
<ul>
<li><a class="el" href="group__task.html">Tasks</a> </li>
<li><a class="el" href="group__semaphore.html">Semaphores</a> </li>
<li><a class="el" href="group__mutex.html">Mutexes</a> </li>
<li><a class="el" href="group__mailbox.html">Mailboxes</a> </li>
<li><a class="el" href="example.html">Example</a> </li>
<li><a class="el" href="usage.html">Using YAVRTOS</a> </li>
<li><a class="el" href="howdoi.html">How do I?</a> </li>
<li><a class="el" href="qanda.html">Questions and Answers</a> </li>
<li><a class="el" href="group__isr.html">Interrupt Service Routines</a> </li>
<li><a class="el" href="api-usage-restrictions.html">API Usage Restrictions</a> </li>
<li><a class="el" href="rev.html">Revision History</a> </li>
</ul>
<hr>
<p align="center"><font size="-1">YAVRTOS and YAVRTOS documentation Copyright &copy; 2007-2008 Chris O'Byrne. Email - chris &lt;at&gt; obyrne &lt;dot&gt; com</font></p>
</body></html>
