<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>U(S)ART Library: Library for AVR(TM) U(S)ART</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>Library for AVR(TM) U(S)ART</h1>
<p>
<h3 align="center">3.00 </h3><dl compact><dt><b>Author:</b></dt><dd>Artur Lipowski &lt;<a href="mailto:LAL@pro.onet.pl">LAL@pro.onet.pl</a>&gt; </dd></dl>
<dl compact><dt><b>Version:</b></dt><dd>3.0 </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>May 27 2006</dd></dl>
Copyright 2003-2006 Artur Lipowski<br>
 No guarantees, warrantees, or promises, implied or otherwise. May be used for hobby or commercial purposes provided copyright notice remains intact.<h2><a class="anchor" name="intro">
Introduction</a></h2>
This is library for using U(S)ART in Atmel AVR microcontrollers.<br>
 Its main part is written in assembler and its core size is only about 380 bytes (receiver 192 and transmitter 190).<br>
 You don't need take care about any U(S)ART interrupts handling.<br>
 Input and output are buffered in ring buffers (separate for TX and RX and for each USART). Buffers length can be changed at compilation time separately for TX and RX side (it speeds up and simplify runtime code) to any value between 2 and 255 (default is 8). Of course it can be used only with microcontrollers with SRAM on board.<br>
 It is true library (from linker point of view) and only used code will be included in the final FLASH image (eg. only transmitting or receiving part).<br>
 There are also provides a "glue" functions which allows to use UART as input and/or output stream for the standard IO functions like fprintf, puts, fgets etc. See: <a class="el" href="index.html#example_io">Example of standard IO &amp; U(S)ART</a><br>
 Look into <a class="el" href="index.html#example_echo">The simplest usage</a>, <a class="el" href="index.html#example_simple">A simple example</a> and <a class="el" href="index.html#example_makefile">Makefile for example projects</a> sections to see how simple you can start using U(S)ART library in your projects.<br>
 This library is build using avr-binutils, avr-gcc and avr-libc packages. Starting from version 3.0 the only supported versions of the avr-libc are 1.4.x and up. I will not perform regression tests with older avr-libc versions.<br>
 <br>
 Some numbers:<ul>
<li>RAM usage (in bytes): TX buffer(s) size + RX buffer(s) size + 3 * number of all buffers + 1 (if UART_get is used)</li><li>stack usage: 4 bytes RX ISR, 5 bytes TX ISR</li><li>worst case of delay beetwen data is ready and data is received is 9 + interrupt start (4) clocks</li><li>whole (worst case) RX ISR is about 52 + interrupt start (4) clocks</li><li>whole (worst case) TX ISR is about 49 + interrupt start (4) clocks</li></ul>
<h2><a class="anchor" name="support">
Supported Devices</a></h2>
With two USARTs:<ul>
<li>m128, m161, m162, m164, m324, m640, m1280, m1281, m64</li></ul>
<p>
With one U(S)ART:<ul>
<li>m32, m323, m325, m3250, m644, m645, m6450, m16, m169, m8, m48, m88, m165, m168, AT90PWM2, AT90PWM3, m8515, m8535, m103, 43USB320, 8535, 8515, 4434, 4414, 2313</li></ul>
<p>
Note: as you can see there are missing ones eg. m163 - this is due to the madness 8-) with names used for U(S)ART registers and bits, if somebody want to add a support for these devices I will very appreciate this.<h2><a class="anchor" name="install">
Installation</a></h2>
Mainly for size efficiency, all tunable parameters are fixed at compile time. It means that if you want to change buffer(s) size, number of USART or device type you have to compile another version of U(S)ART library. But don't afraid compilation even on very slow machine takes only a couple of seconds.<br>
<p>
Installation steps:<ol type=1>
<li>Unzip archive.<br>
</li><li>Into newly created <code>uart</code> directory edit <code>Makefile</code> (see <a class="el" href="index.html#lib_makefile">Library Makefile</a>). You can (should) change following variables and defines:<ul>
<li><code>MCU_TARGET</code> - this is a compiler switch for choosing what AVR device will be used, eg. at90s8515</li><li><code>USE_UART0</code> and/or <code>USE_UART1</code> to enable/disable given U(S)ART device, these defines have to be set also when user code is compiled (see <a class="el" href="index.html#example_makefile">Makefile for example projects</a>)</li><li><code>UART0_TX_BUFSIZE</code> <code>UART0_RX_BUFSIZE</code> <code>UART1_TX_BUFSIZE</code> <code>UART1_RX_BUFSIZE</code> to define the length of the appopriate buffer</li><li><code>SKIP_DEVNO_CHECK</code> if defined and there is only one used U(S)ART then <code>device</code> parameter value will be not checked and thus smaller code will be generated</li><li><code>OPTIMIZE</code> practically no effect because main part is written in assembler</li></ul>
</li><li>Next issue <code>make</code> command.<br>
 This should produce (among others) <code>libuart_yourmcu.a</code> file.<br>
</li><li>Use this file and <code><a class="el" href="uart_8h.html">uart.h</a></code> and optionally <code><a class="el" href="uart__util_8h.html">uart_util.h</a></code> in your projects (look into <a class="el" href="index.html#example_simple">A simple example</a> and <a class="el" href="index.html#example_io">Example of standard IO &amp; U(S)ART</a> below).<br>
</li></ol>
<p>
Don't afraid about the library size (the *.a file), it contains a full debug info and in the final bin or hex files all of that will be removed automatically.<h2><a class="anchor" name="lib_makefile">
Library Makefile</a></h2>
A few first lines from the library Makefile which shows "tunable" parameters.<p>
 <div class="fragment"><pre class="fragment">MCU_TARGET      =       your_avr_here

DEFS            =       -DUSE_UART0
<span class="preprocessor">#DEFS           +=      -DUSE_UART1</span>
<span class="preprocessor"></span>DEFS            +=      -DUART0_TX_BUFSIZE=8 -DUART0_RX_BUFSIZE=8
<span class="preprocessor">#DEFS           +=      -DUART1_TX_BUFSIZE=8 -DUART1_RX_BUFSIZE=8</span>
<span class="preprocessor"></span><span class="preprocessor">#DEFS           +=      -DSKIP_DEVNO_CHECK</span>
<span class="preprocessor"></span>
OPTIMIZE        =       -Os
</pre></div><h2><a class="anchor" name="example_echo">
The simplest usage</a></h2>
This example shows the simplest usage of the U(S)ART library. It just echoes received bytes.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>

<span class="preprocessor">#include &lt;<a class="code" href="uart__util_8h.html">uart_util.h</a>&gt;</span>

<span class="keyword">const</span> <span class="keywordtype">char</span> str_READY[] PROGMEM = <span class="stringliteral">"\r\n\nAVR U(S)ART library \"echo\" example.\r\nReady yo go!\r\n\n"</span>;

<span class="comment">/* In case when AVR without external clock is used we should calibrate</span>
<span class="comment"> * the internal oscillator to obtain accurate transmission speed.</span>
<span class="comment"> * You should put here values from the AVR chip you will use for </span>
<span class="comment"> * executing this program. */</span>
<span class="preprocessor">#ifdef USE_USART</span>
<span class="preprocessor"></span><span class="keyword">const</span> uint8_t osc_callibration[] PROGMEM = { 0xA6, 0xA8, 0x9F, 0xA0 };
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">/* in case of AVR with 2 USARTs define which one you want to use */</span>
<span class="preprocessor">#define UART_DEV 0</span>
<span class="preprocessor"></span>
<span class="comment">/*******************************************************************************/</span>
<span class="keywordtype">void</span> ioinit(<span class="keywordtype">void</span>)
{
    <span class="comment">/* set callibration value for 4MHz */</span>
<span class="preprocessor">#ifdef USE_USART</span>
<span class="preprocessor"></span>        OSCCAL = pgm_read_byte(&amp;osc_callibration[2]);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>                        
        <span class="comment">/* set 19200 baud rate for 4Mhz CPU clock */</span>
        <a class="code" href="uart_8h.html#f6abdc6eb873ba436f98fc2247a049a4">UART_set_speed</a>(UART_DEV, 12U);

    <span class="comment">/* setup 8N1 asynchronous mode for U(S)ART */</span>
<span class="preprocessor">#ifdef USE_USART</span>
<span class="preprocessor"></span>        UCSRB = 0;
        UCSRC = _BV(URSEL) | _BV(UCSZ1) | _BV(UCSZ0);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        UCR = 0;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    <span class="comment">/* Initialize U(S)ART library */</span>
    <a class="code" href="uart_8h.html#b623f41db1c39f7c9fc60c17ea10a4db">UART_init_RX</a>(UART_DEV);
        <a class="code" href="uart_8h.html#8a908344b767d6c55e37b442787cec7b">UART_init_TX</a>(UART_DEV);
        
    <span class="comment">/* enable interrupts to allow the U(S)ART library processing </span>
<span class="comment">     * incoming and outgoing transmission */</span>    
        sei();
}

<span class="comment">/*******************************************************************************/</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
    uint8_t ch;

    <span class="comment">/* setup USART */</span>
    ioinit();

    <span class="comment">/* output welcome message */</span>
    <a class="code" href="uart__util_8h.html#ce02753336844a2a0c96300fb5c5e542">UART_puts_P</a>(UART_DEV, str_READY);

    <span class="comment">/* Just echo received bytes */</span>
    <span class="keywordflow">while</span> (1)
    {
        <span class="comment">/* wait for a character */</span>
        <span class="keywordflow">while</span> (0 == <a class="code" href="uart_8h.html#a1467e635689d761d1902298882fc0b6">UART_getchar</a>(UART_DEV, &amp;ch))
            ;

        <span class="comment">/* send back received character */</span>
        <a class="code" href="uart_8h.html#a7c76e793d83a3ac3c0ee74ed635cd53">UART_putchar</a>(UART_DEV, ch);
        
        <span class="comment">/* if end of line (Enter) detected then output also a CR character */</span>
        <span class="keywordflow">if</span> (<span class="charliteral">'\r'</span> == ch)
        {
            <a class="code" href="uart_8h.html#a7c76e793d83a3ac3c0ee74ed635cd53">UART_putchar</a>(UART_DEV, <span class="charliteral">'\n'</span>);
        }
    }

    <span class="keywordflow">return</span> (0);
}

</pre></div><h2><a class="anchor" name="example_simple">
A simple example</a></h2>
This example shows various functions from the U(S)ART library used for transmitting characters trough serial line. It does not use a standard IO stuff.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>

<span class="preprocessor">#include &lt;<a class="code" href="uart__util_8h.html">uart_util.h</a>&gt;</span>

<span class="keyword">const</span> <span class="keywordtype">char</span> str_OK[] PROGMEM = <span class="stringliteral">"\r\nOK\r\n"</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> str_READY[] PROGMEM = <span class="stringliteral">"\r\n\nAVR U(S)ART library example.\r\nReady yo go!\r\n\n"</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> str_ENTER[] PROGMEM = <span class="stringliteral">"\r\nEnter string"</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> str_ENDL[] PROGMEM = <span class="stringliteral">" and press Enter\r\n"</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> str_LENGTH[] PROGMEM = <span class="stringliteral">" up to 20 characters long\r\n"</span>;

<span class="keyword">const</span> <span class="keywordtype">char</span> str_TEST1[] PROGMEM = <span class="stringliteral">"\r\nTest 1: UART_getchar and UART_putchar"</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> str_TEST2[] PROGMEM = <span class="stringliteral">"\r\nTest 2: UART_gets_delim and UART_puts"</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> str_TEST3[] PROGMEM = <span class="stringliteral">"\r\nTest 3: UART_gets and UART_puts"</span>;

<span class="comment">/* In case when AVR without external clock is used we should calibrate</span>
<span class="comment"> * the internal oscillator to obtain accurate transmission speed.</span>
<span class="comment"> * You should put here values from the AVR chip you will use for </span>
<span class="comment"> * executing this program. */</span>
<span class="preprocessor">#ifdef USE_USART</span>
<span class="preprocessor"></span><span class="keyword">const</span> uint8_t osc_callibration[] PROGMEM = { 0xA6, 0xA8, 0x9F, 0xA0 };
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">/* in case of AVR with 2 USARTs define which one you want to use */</span>
<span class="preprocessor">#define UART_DEV 0</span>
<span class="preprocessor"></span>
<span class="comment">/*******************************************************************************/</span>
<span class="keywordtype">void</span> ioinit(<span class="keywordtype">void</span>)
{
    <span class="comment">/* set callibration value for 4MHz */</span>
<span class="preprocessor">#ifdef USE_USART</span>
<span class="preprocessor"></span>        OSCCAL = pgm_read_byte(&amp;osc_callibration[2]);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>                        
        <span class="comment">/* set 19200 baud rate for 4Mhz CPU clock */</span>
        <a class="code" href="uart_8h.html#f6abdc6eb873ba436f98fc2247a049a4">UART_set_speed</a>(UART_DEV, 12U);

    <span class="comment">/* setup 8N1 asynchronous mode for U(S)ART */</span>
<span class="preprocessor">#ifdef USE_USART</span>
<span class="preprocessor"></span>        UCSRB = 0;
        UCSRC = _BV(URSEL) | _BV(UCSZ1) | _BV(UCSZ0);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        UCR = 0;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    <span class="comment">/* Initialize U(S)ART library */</span>
    <a class="code" href="uart_8h.html#b623f41db1c39f7c9fc60c17ea10a4db">UART_init_RX</a>(UART_DEV);
        <a class="code" href="uart_8h.html#8a908344b767d6c55e37b442787cec7b">UART_init_TX</a>(UART_DEV);
        
    <span class="comment">/* enable interrupts to allow the U(S)ART library processing </span>
<span class="comment">     * incoming and outgoing transmission */</span>    
        sei();
}

<span class="comment">/*******************************************************************************/</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
    uint8_t i;
    uint8_t charbuf[21];

    <span class="comment">/* setup USART */</span>
    ioinit();

    <span class="comment">/* output welcome message */</span>
    <a class="code" href="uart__util_8h.html#ce02753336844a2a0c96300fb5c5e542">UART_puts_P</a>(UART_DEV, str_READY);

    <span class="keywordflow">while</span> (1)
    {
        <a class="code" href="uart__util_8h.html#ce02753336844a2a0c96300fb5c5e542">UART_puts_P</a>(UART_DEV, str_TEST1);
        <a class="code" href="uart__util_8h.html#ce02753336844a2a0c96300fb5c5e542">UART_puts_P</a>(UART_DEV, str_ENTER);
        <a class="code" href="uart__util_8h.html#ce02753336844a2a0c96300fb5c5e542">UART_puts_P</a>(UART_DEV, str_ENDL);

        <a class="code" href="uart_8h.html#575e4474bf05ce81a140f45b3eda1b34">UART_clear_RX_buf</a>(UART_DEV);

        <span class="comment">/* read characters from UART untill charbuf is full or end of line (Enter) */</span>
        <span class="keywordflow">for</span> (i=0; i &lt; <span class="keyword">sizeof</span>(charbuf); i++)
        {
            <span class="keywordflow">while</span> (0 == <a class="code" href="uart_8h.html#1a0a3f8ce16d791c1de73e0932f030a9">UART_get_RX_len</a>(UART_DEV))
                ;
            <span class="keywordflow">if</span> (<a class="code" href="uart_8h.html#a1467e635689d761d1902298882fc0b6">UART_getchar</a>(UART_DEV, &amp;charbuf[i]))
            {
                <span class="keywordflow">if</span> ( charbuf[i] == <span class="charliteral">'\r'</span> )
                    <span class="keywordflow">break</span>;
                <a class="code" href="uart_8h.html#a7c76e793d83a3ac3c0ee74ed635cd53">UART_putchar</a>(UART_DEV, charbuf[i]);
            }
        }
        <span class="comment">/* send back received string */</span>
        <a class="code" href="uart__util_8h.html#ce02753336844a2a0c96300fb5c5e542">UART_puts_P</a>(UART_DEV, str_OK);

        <a class="code" href="uart__util_8h.html#ce02753336844a2a0c96300fb5c5e542">UART_puts_P</a>(UART_DEV, str_TEST2);
        <a class="code" href="uart__util_8h.html#ce02753336844a2a0c96300fb5c5e542">UART_puts_P</a>(UART_DEV, str_ENTER);
        <a class="code" href="uart__util_8h.html#ce02753336844a2a0c96300fb5c5e542">UART_puts_P</a>(UART_DEV, str_ENDL);

        <a class="code" href="uart_8h.html#575e4474bf05ce81a140f45b3eda1b34">UART_clear_RX_buf</a>(UART_DEV);

        <span class="comment">/* the same functionality like above but using the library function */</span>
        i = <a class="code" href="uart__util_8h.html#6fbb241755c826b805e2ff574a4859e4">UART_gets_delim</a>(UART_DEV, charbuf, <span class="charliteral">'\r'</span>, <span class="keyword">sizeof</span>(charbuf)-1);
        charbuf[i] = <span class="charliteral">'\0'</span>;
        <a class="code" href="uart__util_8h.html#703793312a7ee42c492b9f6bf4a00396">UART_puts</a>(UART_DEV, charbuf);
        <a class="code" href="uart__util_8h.html#ce02753336844a2a0c96300fb5c5e542">UART_puts_P</a>(UART_DEV, str_OK);

        <a class="code" href="uart__util_8h.html#ce02753336844a2a0c96300fb5c5e542">UART_puts_P</a>(UART_DEV, str_TEST3);
        <a class="code" href="uart__util_8h.html#ce02753336844a2a0c96300fb5c5e542">UART_puts_P</a>(UART_DEV, str_ENTER);
        <a class="code" href="uart__util_8h.html#ce02753336844a2a0c96300fb5c5e542">UART_puts_P</a>(UART_DEV, str_LENGTH);

        <a class="code" href="uart_8h.html#575e4474bf05ce81a140f45b3eda1b34">UART_clear_RX_buf</a>(UART_DEV);

        <span class="comment">/* fill the charbuf array using characters received through UART */</span>
        <a class="code" href="uart__util_8h.html#efb0ea998c0dd9befc356b030fce20e4">UART_gets</a>(UART_DEV, charbuf, <span class="keyword">sizeof</span>(charbuf)-1);
        charbuf[<span class="keyword">sizeof</span>(charbuf)-1] = <span class="charliteral">'\0'</span>;
        <a class="code" href="uart__util_8h.html#703793312a7ee42c492b9f6bf4a00396">UART_puts</a>(UART_DEV, charbuf);
        <a class="code" href="uart__util_8h.html#ce02753336844a2a0c96300fb5c5e542">UART_puts_P</a>(UART_DEV ,str_OK);
    }

    <span class="keywordflow">return</span> (0);
}

</pre></div><h2><a class="anchor" name="example_io">
Example of standard IO &amp; U(S)ART</a></h2>
This example shows how to use the U(S)ART library with standard IO from avr-libc.<br>
 Note: using standard IO facilities costs some resources - mainly FLASH and SRAM space. If you plan to use it only for simple functionality (like puts, gets etc.) you should consider using "plain" U(S)ART functions. An example presented in the <a class="el" href="index.html#example_simple">A simple example</a> section uses much more function calls but resulting code is smaller.<br>
 Functionality of the example is very simple:<ol type=1>
<li>Output welcome message</li><li>Output "prompt" string</li><li>Wait for input (up to 20 characters or Enter)</li><li>Output just read string</li><li>Wait until above transmission is ended</li><li>Go to 2</li></ol>
<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
<span class="preprocessor">#include &lt;avr/sleep.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>

<span class="preprocessor">#include &lt;<a class="code" href="uart__util_8h.html">uart_util.h</a>&gt;</span>

<span class="keyword">const</span> <span class="keywordtype">char</span> str_READY[] PROGMEM = 
    <span class="stringliteral">"\r\n\nAVR U(S)ART library &amp; standard IO example.\r\nReady yo go!\r\n\n"</span>;

<span class="keyword">const</span> <span class="keywordtype">char</span> str_ENTER[] PROGMEM =
    <span class="stringliteral">"\r\nEnter string (max 10 characters) and press Enter:\r"</span>;

<span class="keyword">const</span> <span class="keywordtype">char</span> printf_fmt[] PROGMEM = <span class="stringliteral">"\r\n\nReceived %d bytes\n\r%s\n\r"</span>;

<span class="comment">/* In case when AVR without external clock is used we should calibrate</span>
<span class="comment"> * the internal oscillator to obtain accurate transmission speed.</span>
<span class="comment"> * You should put here values from the AVR chip you will use for </span>
<span class="comment"> * executing this program. */</span>
<span class="preprocessor">#ifdef USE_USART</span>
<span class="preprocessor"></span><span class="keyword">const</span> uint8_t osc_callibration[] PROGMEM = { 0xA6, 0xA8, 0x9F, 0xA0 };
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">/* in case of AVR with 2 USARTs define which one you want to use */</span>
<span class="preprocessor">#define UART_DEV 0</span>
<span class="preprocessor"></span>
<span class="comment">/*******************************************************************************</span>
<span class="comment"> * Below two functions are needed for compatibility with standard IO facilities</span>
<span class="comment"> *******************************************************************************/</span>

<span class="keyword">static</span> uint8_t stdio_device;

<span class="comment">/* this function will wait (block) until there is space in output buffer */</span>
<span class="keyword">static</span> <span class="keywordtype">int</span> u_put(<span class="keywordtype">char</span> a_char, FILE *stream)
{
        <span class="keywordflow">while</span> (0 == <a class="code" href="uart_8h.html#a7c76e793d83a3ac3c0ee74ed635cd53">UART_putchar</a>(*(uint8_t*) fdev_get_udata(stream), a_char))
        ;
    <span class="keywordflow">return</span> 0;
}

<span class="keyword">static</span> <span class="keywordtype">int</span> u_get(FILE *stream)
{
    <a class="code" href="uart__util_8h.html#d5dfe7e7bdccee0ccc8c5f60a5140154">UART_sleep_RX</a>(*(uint8_t*) fdev_get_udata(stream));
        <span class="keywordflow">return</span> <a class="code" href="uart_8h.html#4dab4dd9f475d9562d08f5c215600c12">UART_get</a>(*(uint8_t*) fdev_get_udata(stream));
}

<span class="keyword">static</span> FILE instream = FDEV_SETUP_STREAM(NULL, u_get, _FDEV_SETUP_READ);
<span class="keyword">static</span> FILE outstream = FDEV_SETUP_STREAM(u_put, NULL, _FDEV_SETUP_WRITE);
<span class="keyword">static</span> FILE errstream = FDEV_SETUP_STREAM(u_put, NULL, _FDEV_SETUP_WRITE);

<span class="comment">/*******************************************************************************/</span>
<span class="keywordtype">void</span> ioinit(<span class="keywordtype">void</span>)
{
    <span class="comment">/* set callibration value for 4MHz */</span>
<span class="preprocessor">#ifdef USE_USART</span>
<span class="preprocessor"></span>        OSCCAL = pgm_read_byte(&amp;osc_callibration[2]);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>                        
        <span class="comment">/* set 19200 baud rate for 4Mhz CPU clock */</span>
        <a class="code" href="uart_8h.html#f6abdc6eb873ba436f98fc2247a049a4">UART_set_speed</a>(UART_DEV, 12U);

    <span class="comment">/* setup 8N1 serual asynchronous mode for U(S)ART */</span>
<span class="preprocessor">#ifdef USE_USART</span>
<span class="preprocessor"></span>        UCSRB = 0;
        UCSRC = _BV(URSEL) | _BV(UCSZ1) | _BV(UCSZ0);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        UCR = 0;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    <span class="comment">/* Initialize U(S)ART library */</span>
    <a class="code" href="uart_8h.html#b623f41db1c39f7c9fc60c17ea10a4db">UART_init_RX</a>(UART_DEV);
        <a class="code" href="uart_8h.html#8a908344b767d6c55e37b442787cec7b">UART_init_TX</a>(UART_DEV);

    <span class="comment">/* enable interrupts to allow the U(S)ART library processing </span>
<span class="comment">     * incoming and outgoing transmission */</span>    
        sei();
}

<span class="comment">/*******************************************************************************/</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
    <span class="keywordtype">int</span> ch;
    uint8_t i;
    uint8_t charbuf[11];

    <span class="comment">/* setup USART */</span>
    ioinit();

    <span class="comment">/* prepare standard IO facilities */</span>
    stdio_device = UART_DEV;
    stdin = &amp;instream;
    stdout = &amp;outstream;
    stderr = &amp;errstream;
    fdev_set_udata(stdin, &amp;stdio_device);
    fdev_set_udata(stdout, &amp;stdio_device);
    fdev_set_udata(stderr, &amp;stdio_device);

    set_sleep_mode(SLEEP_MODE_IDLE);

    <span class="comment">/* output welcome message */</span>
    puts_P(str_READY);

    <span class="keywordflow">while</span> (1)
    {
        <span class="comment">/* output prompt */</span>
        puts_P(str_ENTER);
        
        <span class="comment">/* read a line form the standard input into the charbuf array </span>
<span class="comment">         * this is a similar to standard gets function but with protection against</span>
<span class="comment">         * buffer overflow */</span>
        <span class="keywordflow">for</span> (i=0; i &lt; (<span class="keyword">sizeof</span>(charbuf)-1); i++)
        {
            <span class="comment">/* read a byte from standard input */</span>
            <span class="keywordflow">do</span> {
                ch = getchar();
            } <span class="keywordflow">while</span> (EOF == ch);

            <span class="comment">/* if end of line found then stop reading */</span>
            <span class="keywordflow">if</span> ((uint8_t) ch == <span class="charliteral">'\r'</span>)
            {
                <span class="keywordflow">break</span>;
            }

            <span class="comment">/* echo received character */</span>
            putchar(ch);
            
            <span class="comment">/* store just received byte into array */</span>
            charbuf[i] = ch;
        }

        <span class="comment">/* end received string with NULL byte to allow use it in </span>
<span class="comment">         * the strlen and printf functions */</span>
        charbuf[i] = <span class="charliteral">'\0'</span>;
        
        <span class="comment">/* output the whole received line with some information */</span>
        printf_P(printf_fmt, strlen((<span class="keywordtype">char</span>*) charbuf), charbuf);

        <span class="comment">/* wait until output buffer is empty - transmission is finished */</span>
        <span class="comment">//UART_sleep_TX_empty(UART_DEV);</span>
        <a class="code" href="uart__util_8h.html#60c85eee849cd3a72beaa17af2f7910b">UART_wait_TX_empty</a>(UART_DEV);
    }

    <span class="keywordflow">return</span> (0);
}

</pre></div><h2><a class="anchor" name="example_makefile">
Makefile for example projects</a></h2>
<div class="fragment"><pre class="fragment">MCU_TARGET              = atmega8
<span class="preprocessor">#MCU_TARGET             = at90s8515</span>
<span class="preprocessor"></span>AVRDUDE_DEV             = m8
<span class="preprocessor">#AVRDUDE_DEV    = 8515</span>
<span class="preprocessor"></span>AVRDUDE_PROG    = stk200
OPTIMIZE                = -Os

DEFS                    =  -DUSE_UART0
<span class="preprocessor">#DEFS                   +=  -DUSE_UART1</span>
<span class="preprocessor"></span>
UART_LIB_DIR    = ..

BINFORMAT               = hex

DEFS                    += -DF_CPU=4000000

<span class="preprocessor">####</span>
<span class="preprocessor"></span><span class="preprocessor"># You should not have to change anything below here.</span>
<span class="preprocessor"></span>
UART_LIB                = libuart_$(MCU_TARGET).a

EX_SIMPLE_PRG   = example_simple
EX_IO_PRG               = example_io
EX_ECHO_PRG             = example_echo
LOOP_PRG                = loop

PROGS                   = $(EX_SIMPLE_PRG) $(EX_IO_PRG) $(EX_ECHO_PRG) $(LOOP_PRG)

CC              = avr-gcc
CPP             = avr-cpp
OBJCOPY         = avr-objcopy
OBJDUMP         = avr-objdump
STRIP           = avr-strip

CFLAGS          = -std=gnu99 -pedantic -Wall $(OPTIMIZE) -gdwarf-2 -mmcu=$(MCU_TARGET) $(DEFS) -I$(UART_LIB_DIR)
LDFLAGS         = $(UART_LIB_DIR)/$(UART_LIB)
CPPFLAGS    = -std=gnu99 $(OPTIMIZE) -mmcu=$(MCU_TARGET) $(DEFS) -I$(UART_LIB_DIR)


.PHONY: all text lst clean $(PROGS)

all: $(PROGS) text lst

$(EX_SIMPLE_PRG) : $(UART_LIB_DIR)/$(UART_LIB) $(EX_SIMPLE_PRG).elf

$(EX_IO_PRG) : $(UART_LIB_DIR)/$(UART_LIB) $(EX_IO_PRG).elf

$(LOOP_PRG) : $(UART_LIB_DIR)/$(UART_LIB) $(LOOP_PRG).elf


%.d: %.c
        @set -e; $(CPP) -MM $(CPPFLAGS) $&lt; \
        | sed 's/\($*\)\.o[ :]*/\1.o $@ : /g' &gt; $@; \
        [ -s $@ ] || rm -f $@

%.elf: %.o
        $(CC) -Wl,-Map,$(@:.elf=.map),-u,vfprintf -lprintf_min -o $@ $^ $(LDFLAGS)

clean:
        -@rm -f *.o *.elf *~
        -@rm -f *.lst *.map *.bin *.srec *.hex

prog_ex_echo: $(EX_ECHO_PRG)
        avrdude -p $(AVRDUDE_DEV) -c $(AVRDUDE_PROG) -U flash:w:$(EX_ECHO_PRG).$(BINFORMAT)  -y

prog_ex_simple: $(EX_SIMPLE_PRG)
        avrdude -p $(AVRDUDE_DEV) -c $(AVRDUDE_PROG) -U flash:w:$(EX_SIMPLE_PRG).$(BINFORMAT)  -y

prog_ex_io: $(EX_IO_PRG)
        avrdude -p $(AVRDUDE_DEV) -c $(AVRDUDE_PROG) -U flash:w:$(EX_IO_PRG).$(BINFORMAT)  -y

prog_loop: $(LOOP_PRG)
        avrdude -p $(AVRDUDE_DEV) -c $(AVRDUDE_PROG) -U flash:w:$(LOOP_PRG).$(BINFORMAT) -y


lst:  $(addsuffix .lst,$(PROGS))


%.lst: %.elf
        $(OBJDUMP) -h -S -D $&lt; &gt; $@


# Rules <span class="keywordflow">for</span> building the .text FLASH images

text: $(BINFORMAT)

hex:  $(addsuffix .hex,$(PROGS))
bin:  $(addsuffix .bin,$(PROGS))
srec: $(addsuffix .srec,$(PROGS))

%.hex: %.elf
        $(OBJCOPY) -j .text -j .data -O ihex $&lt; $@

%.srec: %.elf
        $(OBJCOPY) -j .text -j .data -O srec $&lt; $@

%.bin: %.elf
        $(OBJCOPY) -j .text -j .data -O binary $&lt; $@


DSOURCES = $(addsuffix .d,$(PROGS))
include $(DSOURCES)
</pre></div><h2><a class="anchor" name="loopback_test">
Loopback test</a></h2>
This is a simple test for testing compiled library binaries. It can be also used as some kind of benchmark.<br>
 Before running test you need to connect RX and TX pins of the U(S)ART and attach a multimeter or LED to the "indicator" pin (you can easly redefine it). If tests passed without problems then it will be 0V on the indicator pin. Otherwise you should notice short (about 0.5s) voltage pulses. The number of pulses shows at which stage test failed. You could easly change test parameters just by changeing defines at the begin of the <code>loop.c</code> file. <hr size="1"><address style="align: right;"><small>Generated on Mon May 29 22:03:39 2006 for U(S)ART Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
