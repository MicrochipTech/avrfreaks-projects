
AASB168.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000582  00003800  00003800  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .debug_aranges 00000028  00000000  00000000  000005d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  2 .debug_pubnames 0000002a  00000000  00000000  000005fe  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_info   0000042d  00000000  00000000  00000628  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_abbrev 00000166  00000000  00000000  00000a55  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_line   00000671  00000000  00000000  00000bbb  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_frame  00000030  00000000  00000000  0000122c  2**2
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_str    00000177  00000000  00000000  0000125c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00000888  00000000  00000000  000013d3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 000000b0  00000000  00000000  00001c5b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00003800 <__jumpMain>:
* to reduce the code size, we need to provide our own initialization
*/
void __jumpMain     (void) __attribute__ ((naked)) __attribute__ ((section (".init9")));

void __jumpMain(void)
{    
    3800:	8f ef       	ldi	r24, 0xFF	; 255
  asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
  
  /* init stack here, bug WinAVR 20071221 does not init stack based on __stack */  
  asm volatile ("ldi r24,%0":: "M" (RAMEND & 0xFF));          
  asm volatile ("ldi r25,%0":: "M" (RAMEND >> 8));
    3802:	94 e0       	ldi	r25, 0x04	; 4
  asm volatile ("out __SP_H__,r25" ::);
    3804:	9e bf       	out	0x3e, r25	; 62
  asm volatile ("out __SP_L__,r24" ::);
    3806:	8d bf       	out	0x3d, r24	; 61
  
  asm volatile ( "clr __zero_reg__" );                       // GCC depends on register r1 set to 0
    3808:	11 24       	eor	r1, r1
  asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );  // set SREG to 0
    380a:	1f be       	out	0x3f, r1	; 63
#ifndef REMOVE_PROG_PIN_PULLUP	 
  PROG_PORT |= (1<<PROG_PIN);		                           // Enable internal pullup
    380c:	2c 9a       	sbi	0x05, 4	; 5
#endif    
  asm volatile ( "rjmp main");                               // jump to main()
    380e:	00 c0       	rjmp	.+0      	; 0x3810 <main>

00003810 <main>:
}


int main(void) __attribute__ ((OS_main));
int main(void)
{
    3810:	cd b7       	in	r28, 0x3d	; 61
    3812:	de b7       	in	r29, 0x3e	; 62
    3814:	c4 52       	subi	r28, 0x24	; 36
    3816:	d1 40       	sbci	r29, 0x01	; 1
    3818:	de bf       	out	0x3e, r29	; 62
    381a:	cd bf       	out	0x3d, r28	; 61
  unsigned char   isLeave = 0;
  
  /*
  * Branch to bootloader or application code ?
  */	
  if(!(PROG_IN & (1<<PROG_PIN)))  
    381c:	1c 99       	sbic	0x03, 4	; 3
    381e:	a7 c2       	rjmp	.+1358   	; 0x3d6e <main+0x55e>
  { 	    
#ifndef REMOVE_BOOTLOADER_LED
    /* PROG_PIN set high, indicate with LED that bootloader is active */
    PROGLED_DDR  |= (1<<PROGLED_PIN);
    3820:	25 9a       	sbi	0x04, 5	; 4
    PROGLED_PORT |= (1<<PROGLED_PIN);
    3822:	2d 9a       	sbi	0x05, 5	; 5
    /*
    * Init UART
    * set baudrate and enable USART receiver and transmiter without interrupts 
    */     
#if UART_BAUDRATE_DOUBLE_SPEED
    UART_STATUS_REG   |=  (1 <<UART_DOUBLE_SPEED);
    3824:	80 91 c0 00 	lds	r24, 0x00C0
    3828:	82 60       	ori	r24, 0x02	; 2
    382a:	80 93 c0 00 	sts	0x00C0, r24
#endif
    
#ifdef UART_BAUD_RATE_HIGH    
    UART_BAUD_RATE_HIGH = 0;     
    382e:	10 92 c5 00 	sts	0x00C5, r1
#endif       
    UART_BAUD_RATE_LOW = UART_BAUD_SELECT(BAUDRATE,F_CPU);
    3832:	80 e1       	ldi	r24, 0x10	; 16
    3834:	80 93 c4 00 	sts	0x00C4, r24
    UART_CONTROL_REG   = (1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER); 
    3838:	88 e1       	ldi	r24, 0x18	; 24
    383a:	80 93 c1 00 	sts	0x00C1, r24
    383e:	20 e0       	ldi	r18, 0x00	; 0
    3840:	e0 e0       	ldi	r30, 0x00	; 0
    3842:	60 e0       	ldi	r22, 0x00	; 0
    3844:	70 e0       	ldi	r23, 0x00	; 0
    3846:	40 e0       	ldi	r20, 0x00	; 0
    3848:	50 e0       	ldi	r21, 0x00	; 0
    384a:	80 e0       	ldi	r24, 0x00	; 0
    384c:	90 e0       	ldi	r25, 0x00	; 0
              size -= 2;			// Reduce number of bytes to write by two    
            } while(size);			// Loop until all bytes written
            
            boot_page_write(tempaddress);
            boot_spm_busy_wait();	
            boot_rww_enable();				// Re-enable the RWW section                    
    384e:	1c e0       	ldi	r17, 0x0C	; 12
    3850:	e1 2e       	mov	r14, r17
    3852:	f1 2c       	mov	r15, r1
    3854:	ec 0e       	add	r14, r28
    3856:	fd 1e       	adc	r15, r29
            else
              fuseBits = boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );                            
          }
          else 
          {
            fuseBits = boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
    3858:	39 e0       	ldi	r19, 0x09	; 9
#endif
              *p++ = (unsigned char)data;         //LSB
              *p++ = (unsigned char)(data >> 8);	//MSB  
              address    += 2;  	 // Select next word in memory
              size -= 2;
            }while (size);
    385a:	02 e0       	ldi	r16, 0x02	; 2
    385c:	10 e0       	ldi	r17, 0x00	; 0
    385e:	0c 0f       	add	r16, r28
    3860:	1d 1f       	adc	r17, r29
    3862:	0e 5f       	subi	r16, 0xFE	; 254
    3864:	1f 4f       	sbci	r17, 0xFF	; 255
    UART_BAUD_RATE_LOW = UART_BAUD_SELECT(BAUDRATE,F_CPU);
    UART_CONTROL_REG   = (1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER); 
    
    
    /* main loop */
    while(!isLeave)                             
    3866:	7e c2       	rjmp	.+1276   	; 0x3d64 <main+0x554>
/*
* Read single byte from USART, block if no data available
*/
static unsigned char recchar(void)
{
  while(!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)));  // wait for data
    3868:	80 91 c0 00 	lds	r24, 0x00C0
    386c:	87 ff       	sbrs	r24, 7
    386e:	fc cf       	rjmp	.-8      	; 0x3868 <main+0x58>
  return UART_DATA_REG;
    3870:	90 91 c6 00 	lds	r25, 0x00C6
      */            
      msgParseState = ST_START;
      while ( msgParseState != ST_PROCESS )
      {
        c = recchar();
        switch (msgParseState)
    3874:	f3 30       	cpi	r31, 0x03	; 3
    3876:	01 f1       	breq	.+64     	; 0x38b8 <main+0xa8>
    3878:	f4 30       	cpi	r31, 0x04	; 4
    387a:	28 f4       	brcc	.+10     	; 0x3886 <main+0x76>
    387c:	f1 30       	cpi	r31, 0x01	; 1
    387e:	79 f0       	breq	.+30     	; 0x389e <main+0x8e>
    3880:	f2 30       	cpi	r31, 0x02	; 2
    3882:	a8 f4       	brcc	.+42     	; 0x38ae <main+0x9e>
    3884:	07 c0       	rjmp	.+14     	; 0x3894 <main+0x84>
    3886:	f5 30       	cpi	r31, 0x05	; 5
    3888:	29 f1       	breq	.+74     	; 0x38d4 <main+0xc4>
    388a:	f5 30       	cpi	r31, 0x05	; 5
    388c:	e0 f0       	brcs	.+56     	; 0x38c6 <main+0xb6>
    388e:	f6 30       	cpi	r31, 0x06	; 6
    3890:	59 f7       	brne	.-42     	; 0x3868 <main+0x58>
    3892:	32 c0       	rjmp	.+100    	; 0x38f8 <main+0xe8>
        {
        case ST_START:
          if( c == MESSAGE_START )
    3894:	9b 31       	cpi	r25, 0x1B	; 27
    3896:	a1 f5       	brne	.+104    	; 0x3900 <main+0xf0>
    3898:	eb e1       	ldi	r30, 0x1B	; 27
    389a:	f1 e0       	ldi	r31, 0x01	; 1
    389c:	e5 cf       	rjmp	.-54     	; 0x3868 <main+0x58>
            checksum = MESSAGE_START^0;
          }
          break;
          
        case ST_GET_SEQ_NUM:
          if ( (c == 1) || (c == seqNum) )
    389e:	91 30       	cpi	r25, 0x01	; 1
    38a0:	11 f0       	breq	.+4      	; 0x38a6 <main+0x96>
    38a2:	92 17       	cp	r25, r18
    38a4:	59 f5       	brne	.+86     	; 0x38fc <main+0xec>
          {
            seqNum = c;
            msgParseState = ST_MSG_SIZE_1;
            checksum ^= c;
    38a6:	e9 27       	eor	r30, r25
    38a8:	29 2f       	mov	r18, r25
    38aa:	f2 e0       	ldi	r31, 0x02	; 2
            checksum = MESSAGE_START^0;
          }
          break;
          
        case ST_GET_SEQ_NUM:
          if ( (c == 1) || (c == seqNum) )
    38ac:	dd cf       	rjmp	.-70     	; 0x3868 <main+0x58>
            msgParseState = ST_START;
          }
          break;
          
        case ST_MSG_SIZE_1:			    
          msgLength = (unsigned int)c<<8;
    38ae:	79 2e       	mov	r7, r25
    38b0:	66 24       	eor	r6, r6
          msgParseState = ST_MSG_SIZE_2;
          checksum ^= c;
    38b2:	e9 27       	eor	r30, r25
    38b4:	f3 e0       	ldi	r31, 0x03	; 3
          break;
    38b6:	d8 cf       	rjmp	.-80     	; 0x3868 <main+0x58>
          
        case ST_MSG_SIZE_2:			
          msgLength |= c;
    38b8:	89 2e       	mov	r8, r25
    38ba:	99 24       	eor	r9, r9
    38bc:	68 28       	or	r6, r8
    38be:	79 28       	or	r7, r9
          msgParseState = ST_GET_TOKEN;
          checksum ^= c;
    38c0:	e9 27       	eor	r30, r25
    38c2:	f4 e0       	ldi	r31, 0x04	; 4
          break;
    38c4:	d1 cf       	rjmp	.-94     	; 0x3868 <main+0x58>
          
        case ST_GET_TOKEN:
          if ( c == TOKEN )
    38c6:	9e 30       	cpi	r25, 0x0E	; 14
    38c8:	c9 f4       	brne	.+50     	; 0x38fc <main+0xec>
          {
            msgParseState = ST_GET_DATA;
            checksum ^= c;
    38ca:	e9 27       	eor	r30, r25
    38cc:	60 e0       	ldi	r22, 0x00	; 0
    38ce:	70 e0       	ldi	r23, 0x00	; 0
    38d0:	f5 e0       	ldi	r31, 0x05	; 5
    38d2:	ca cf       	rjmp	.-108    	; 0x3868 <main+0x58>
            msgParseState = ST_START;
          }
          break;
          
        case ST_GET_DATA:			        
          msgBuffer[i++] = c;
    38d4:	b2 e0       	ldi	r27, 0x02	; 2
    38d6:	8b 2e       	mov	r8, r27
    38d8:	91 2c       	mov	r9, r1
    38da:	8c 0e       	add	r8, r28
    38dc:	9d 1e       	adc	r9, r29
    38de:	86 0e       	add	r8, r22
    38e0:	97 1e       	adc	r9, r23
    38e2:	d4 01       	movw	r26, r8
    38e4:	9c 93       	st	X, r25
    38e6:	6f 5f       	subi	r22, 0xFF	; 255
    38e8:	7f 4f       	sbci	r23, 0xFF	; 255
          checksum ^= c;
    38ea:	e9 27       	eor	r30, r25
          if ( i == msgLength )
    38ec:	66 15       	cp	r22, r6
    38ee:	77 05       	cpc	r23, r7
    38f0:	09 f0       	breq	.+2      	; 0x38f4 <main+0xe4>
    38f2:	ba cf       	rjmp	.-140    	; 0x3868 <main+0x58>
    38f4:	f6 e0       	ldi	r31, 0x06	; 6
    38f6:	b8 cf       	rjmp	.-144    	; 0x3868 <main+0x58>
            msgParseState = ST_GET_CHECK;
          }
          break;
          
        case ST_GET_CHECK:
          if( c == checksum )
    38f8:	9e 17       	cp	r25, r30
    38fa:	29 f0       	breq	.+10     	; 0x3906 <main+0xf6>
    38fc:	f0 e0       	ldi	r31, 0x00	; 0
    38fe:	b4 cf       	rjmp	.-152    	; 0x3868 <main+0x58>
    {   
      /*
      * Collect received bytes to a complete message
      */            
      msgParseState = ST_START;
      while ( msgParseState != ST_PROCESS )
    3900:	f7 30       	cpi	r31, 0x07	; 7
    3902:	09 f0       	breq	.+2      	; 0x3906 <main+0xf6>
    3904:	b1 cf       	rjmp	.-158    	; 0x3868 <main+0x58>
    3906:	c2 01       	movw	r24, r4
      
      /*
      * Now process the STK500 commands, see Atmel Appnote AVR068
      */
      
      switch (msgBuffer[0])
    3908:	8a 80       	ldd	r8, Y+2	; 0x02
    390a:	b3 e1       	ldi	r27, 0x13	; 19
    390c:	8b 16       	cp	r8, r27
    390e:	09 f4       	brne	.+2      	; 0x3912 <main+0x102>
    3910:	d4 c0       	rjmp	.+424    	; 0x3aba <main+0x2aa>
    3912:	b8 15       	cp	r27, r8
    3914:	e0 f0       	brcs	.+56     	; 0x394e <main+0x13e>
    3916:	e6 e0       	ldi	r30, 0x06	; 6
    3918:	8e 16       	cp	r8, r30
    391a:	09 f4       	brne	.+2      	; 0x391e <main+0x10e>
    391c:	b5 c0       	rjmp	.+362    	; 0x3a88 <main+0x278>
    391e:	e8 15       	cp	r30, r8
    3920:	68 f0       	brcs	.+26     	; 0x393c <main+0x12c>
    3922:	f2 e0       	ldi	r31, 0x02	; 2
    3924:	8f 16       	cp	r8, r31
    3926:	09 f4       	brne	.+2      	; 0x392a <main+0x11a>
    3928:	c6 c0       	rjmp	.+396    	; 0x3ab6 <main+0x2a6>
    392a:	a3 e0       	ldi	r26, 0x03	; 3
    392c:	8a 16       	cp	r8, r26
    392e:	09 f4       	brne	.+2      	; 0x3932 <main+0x122>
    3930:	43 c0       	rjmp	.+134    	; 0x39b8 <main+0x1a8>
    3932:	b1 e0       	ldi	r27, 0x01	; 1
    3934:	8b 16       	cp	r8, r27
    3936:	09 f0       	breq	.+2      	; 0x393a <main+0x12a>
    3938:	92 c1       	rjmp	.+804    	; 0x3c5e <main+0x44e>
    393a:	27 c0       	rjmp	.+78     	; 0x398a <main+0x17a>
    393c:	e0 e1       	ldi	r30, 0x10	; 16
    393e:	8e 16       	cp	r8, r30
    3940:	08 f4       	brcc	.+2      	; 0x3944 <main+0x134>
    3942:	8d c1       	rjmp	.+794    	; 0x3c5e <main+0x44e>
    3944:	f1 e1       	ldi	r31, 0x11	; 17
    3946:	f8 15       	cp	r31, r8
    3948:	08 f0       	brcs	.+2      	; 0x394c <main+0x13c>
    394a:	b5 c0       	rjmp	.+362    	; 0x3ab6 <main+0x2a6>
    394c:	96 c0       	rjmp	.+300    	; 0x3a7a <main+0x26a>
    394e:	a8 e1       	ldi	r26, 0x18	; 24
    3950:	8a 16       	cp	r8, r26
    3952:	09 f4       	brne	.+2      	; 0x3956 <main+0x146>
    3954:	67 c0       	rjmp	.+206    	; 0x3a24 <main+0x214>
    3956:	a8 15       	cp	r26, r8
    3958:	60 f0       	brcs	.+24     	; 0x3972 <main+0x162>
    395a:	b5 e1       	ldi	r27, 0x15	; 21
    395c:	8b 16       	cp	r8, r27
    395e:	09 f4       	brne	.+2      	; 0x3962 <main+0x152>
    3960:	ac c0       	rjmp	.+344    	; 0x3aba <main+0x2aa>
    3962:	8b 16       	cp	r8, r27
    3964:	08 f4       	brcc	.+2      	; 0x3968 <main+0x158>
    3966:	42 c1       	rjmp	.+644    	; 0x3bec <main+0x3dc>
    3968:	e6 e1       	ldi	r30, 0x16	; 22
    396a:	8e 16       	cp	r8, r30
    396c:	09 f0       	breq	.+2      	; 0x3970 <main+0x160>
    396e:	77 c1       	rjmp	.+750    	; 0x3c5e <main+0x44e>
    3970:	3d c1       	rjmp	.+634    	; 0x3bec <main+0x3dc>
    3972:	fa e1       	ldi	r31, 0x1A	; 26
    3974:	8f 16       	cp	r8, r31
    3976:	09 f4       	brne	.+2      	; 0x397a <main+0x16a>
    3978:	49 c0       	rjmp	.+146    	; 0x3a0c <main+0x1fc>
    397a:	8f 16       	cp	r8, r31
    397c:	08 f4       	brcc	.+2      	; 0x3980 <main+0x170>
    397e:	6b c0       	rjmp	.+214    	; 0x3a56 <main+0x246>
    3980:	ab e1       	ldi	r26, 0x1B	; 27
    3982:	8a 16       	cp	r8, r26
    3984:	09 f0       	breq	.+2      	; 0x3988 <main+0x178>
    3986:	6b c1       	rjmp	.+726    	; 0x3c5e <main+0x44e>
    3988:	34 c0       	rjmp	.+104    	; 0x39f2 <main+0x1e2>
        }
        break;
#endif
      case CMD_SIGN_ON:
        msgLength = 11;		        
        msgBuffer[1]  = STATUS_CMD_OK;
    398a:	1b 82       	std	Y+3, r1	; 0x03
        msgBuffer[2]  = 8;
    398c:	e8 e0       	ldi	r30, 0x08	; 8
    398e:	ec 83       	std	Y+4, r30	; 0x04
        msgBuffer[3]  = 'A';
    3990:	e1 e4       	ldi	r30, 0x41	; 65
    3992:	ed 83       	std	Y+5, r30	; 0x05
        msgBuffer[4]  = 'V';
    3994:	e6 e5       	ldi	r30, 0x56	; 86
    3996:	ee 83       	std	Y+6, r30	; 0x06
        msgBuffer[5]  = 'R';
    3998:	e2 e5       	ldi	r30, 0x52	; 82
    399a:	ef 83       	std	Y+7, r30	; 0x07
        msgBuffer[6]  = 'I';
    399c:	e9 e4       	ldi	r30, 0x49	; 73
    399e:	e8 87       	std	Y+8, r30	; 0x08
        msgBuffer[7]  = 'S';
    39a0:	e3 e5       	ldi	r30, 0x53	; 83
    39a2:	e9 87       	std	Y+9, r30	; 0x09
        msgBuffer[8]  = 'P';
    39a4:	e0 e5       	ldi	r30, 0x50	; 80
    39a6:	ea 87       	std	Y+10, r30	; 0x0a
        msgBuffer[9]  = '_';
    39a8:	ef e5       	ldi	r30, 0x5F	; 95
    39aa:	eb 87       	std	Y+11, r30	; 0x0b
        msgBuffer[10] = '2';
    39ac:	e2 e3       	ldi	r30, 0x32	; 50
    39ae:	ec 87       	std	Y+12, r30	; 0x0c
    39b0:	ab e0       	ldi	r26, 0x0B	; 11
    39b2:	8a 2e       	mov	r8, r26
    39b4:	91 2c       	mov	r9, r1
        break;
    39b6:	58 c1       	rjmp	.+688    	; 0x3c68 <main+0x458>
        
      case CMD_GET_PARAMETER:
        {
          volatile unsigned char value;
          
          switch(msgBuffer[1])
    39b8:	eb 81       	ldd	r30, Y+3	; 0x03
    39ba:	e0 39       	cpi	r30, 0x90	; 144
    39bc:	49 f0       	breq	.+18     	; 0x39d0 <main+0x1c0>
    39be:	e1 39       	cpi	r30, 0x91	; 145
    39c0:	98 f0       	brcs	.+38     	; 0x39e8 <main+0x1d8>
    39c2:	e2 39       	cpi	r30, 0x92	; 146
    39c4:	59 f0       	breq	.+22     	; 0x39dc <main+0x1cc>
    39c6:	e2 39       	cpi	r30, 0x92	; 146
    39c8:	30 f0       	brcs	.+12     	; 0x39d6 <main+0x1c6>
    39ca:	ea 39       	cpi	r30, 0x9A	; 154
    39cc:	69 f4       	brne	.+26     	; 0x39e8 <main+0x1d8>
    39ce:	09 c0       	rjmp	.+18     	; 0x39e2 <main+0x1d2>
            break;
          case PARAM_BUILD_NUMBER_HIGH:
            value = CONFIG_PARAM_BUILD_NUMBER_HIGH;
            break;
          case PARAM_HW_VER:
            value = CONFIG_PARAM_HW_VER;
    39d0:	bf e0       	ldi	r27, 0x0F	; 15
    39d2:	b9 83       	std	Y+1, r27	; 0x01
            break;
    39d4:	0a c0       	rjmp	.+20     	; 0x39ea <main+0x1da>
          case PARAM_SW_MAJOR:
            value = CONFIG_PARAM_SW_MAJOR;
    39d6:	e2 e0       	ldi	r30, 0x02	; 2
    39d8:	e9 83       	std	Y+1, r30	; 0x01
            break;
    39da:	07 c0       	rjmp	.+14     	; 0x39ea <main+0x1da>
          case PARAM_SW_MINOR:
            value = CONFIG_PARAM_SW_MINOR;
    39dc:	fa e0       	ldi	r31, 0x0A	; 10
    39de:	f9 83       	std	Y+1, r31	; 0x01
            break;
    39e0:	04 c0       	rjmp	.+8      	; 0x39ea <main+0x1da>
          case PARAM_TOPCARD_DETECT:
            value = CONFIG_PARAM_TOPCARD_DETECT;
    39e2:	af ef       	ldi	r26, 0xFF	; 255
    39e4:	a9 83       	std	Y+1, r26	; 0x01
            break;
    39e6:	01 c0       	rjmp	.+2      	; 0x39ea <main+0x1da>
          default:
            value = 0;
    39e8:	19 82       	std	Y+1, r1	; 0x01
            break;
          }
          msgLength = 3;		        
          msgBuffer[1] = STATUS_CMD_OK;
    39ea:	1b 82       	std	Y+3, r1	; 0x03
          msgBuffer[2] = value;
    39ec:	e9 81       	ldd	r30, Y+1	; 0x01
    39ee:	ec 83       	std	Y+4, r30	; 0x04
    39f0:	40 c0       	rjmp	.+128    	; 0x3a72 <main+0x262>
        msgBuffer[1] = STATUS_CMD_OK;
        break;
        
      case CMD_READ_SIGNATURE_ISP:
        {
          unsigned char signatureIndex = msgBuffer[4];
    39f2:	ee 81       	ldd	r30, Y+6	; 0x06
          unsigned char signature;
          
          if ( signatureIndex == 0 )
    39f4:	ee 23       	and	r30, r30
    39f6:	11 f4       	brne	.+4      	; 0x39fc <main+0x1ec>
    39f8:	ee e1       	ldi	r30, 0x1E	; 30
    39fa:	05 c0       	rjmp	.+10     	; 0x3a06 <main+0x1f6>
            signature = SIGNATURE_0;
          else if ( signatureIndex == 1 )
    39fc:	e1 30       	cpi	r30, 0x01	; 1
    39fe:	11 f0       	breq	.+4      	; 0x3a04 <main+0x1f4>
    3a00:	e6 e0       	ldi	r30, 0x06	; 6
    3a02:	01 c0       	rjmp	.+2      	; 0x3a06 <main+0x1f6>
    3a04:	e4 e9       	ldi	r30, 0x94	; 148
            signature = SIGNATURE_1;
          else
            signature = SIGNATURE_2;
          
          msgLength = 4;
          msgBuffer[1] = STATUS_CMD_OK;
    3a06:	1b 82       	std	Y+3, r1	; 0x03
          msgBuffer[2] = signature;
    3a08:	ec 83       	std	Y+4, r30	; 0x04
    3a0a:	07 c0       	rjmp	.+14     	; 0x3a1a <main+0x20a>
        }
        break;
        
      case CMD_READ_LOCK_ISP:            
        msgLength = 4;
        msgBuffer[1] = STATUS_CMD_OK;
    3a0c:	1b 82       	std	Y+3, r1	; 0x03
        msgBuffer[2] = boot_lock_fuse_bits_get( GET_LOCK_BITS );
    3a0e:	e1 e0       	ldi	r30, 0x01	; 1
    3a10:	f0 e0       	ldi	r31, 0x00	; 0
    3a12:	30 93 57 00 	sts	0x0057, r19
    3a16:	a4 91       	lpm	r26, Z+
    3a18:	ac 83       	std	Y+4, r26	; 0x04
        msgBuffer[3] = STATUS_CMD_OK;	                                                
    3a1a:	1d 82       	std	Y+5, r1	; 0x05
    3a1c:	f4 e0       	ldi	r31, 0x04	; 4
    3a1e:	8f 2e       	mov	r8, r31
    3a20:	91 2c       	mov	r9, r1
        break;
    3a22:	22 c1       	rjmp	.+580    	; 0x3c68 <main+0x458>
        
      case CMD_READ_FUSE_ISP:
        {                    
          unsigned char fuseBits;                    
          
          if ( msgBuffer[2] == 0x50 )
    3a24:	ec 81       	ldd	r30, Y+4	; 0x04
    3a26:	e0 35       	cpi	r30, 0x50	; 80
    3a28:	79 f4       	brne	.+30     	; 0x3a48 <main+0x238>
          {
            if ( msgBuffer[3] == 0x08 )
    3a2a:	ed 81       	ldd	r30, Y+5	; 0x05
    3a2c:	e8 30       	cpi	r30, 0x08	; 8
    3a2e:	31 f4       	brne	.+12     	; 0x3a3c <main+0x22c>
              fuseBits = boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );                            
    3a30:	e2 e0       	ldi	r30, 0x02	; 2
    3a32:	f0 e0       	ldi	r31, 0x00	; 0
    3a34:	30 93 57 00 	sts	0x0057, r19
    3a38:	a4 91       	lpm	r26, Z+
    3a3a:	0b c0       	rjmp	.+22     	; 0x3a52 <main+0x242>
            else
              fuseBits = boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );                            
    3a3c:	e0 e0       	ldi	r30, 0x00	; 0
    3a3e:	f0 e0       	ldi	r31, 0x00	; 0
    3a40:	30 93 57 00 	sts	0x0057, r19
    3a44:	a4 91       	lpm	r26, Z+
    3a46:	05 c0       	rjmp	.+10     	; 0x3a52 <main+0x242>
          }
          else 
          {
            fuseBits = boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
    3a48:	e3 e0       	ldi	r30, 0x03	; 3
    3a4a:	f0 e0       	ldi	r31, 0x00	; 0
    3a4c:	30 93 57 00 	sts	0x0057, r19
    3a50:	a4 91       	lpm	r26, Z+
          }                    
          msgLength = 4;    
          msgBuffer[1] = STATUS_CMD_OK;
    3a52:	1b 82       	std	Y+3, r1	; 0x03
    3a54:	e1 cf       	rjmp	.-62     	; 0x3a18 <main+0x208>
#ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
      case CMD_PROGRAM_LOCK_ISP:
        {
          unsigned char lockBits = msgBuffer[4];
          
          lockBits = (~lockBits) & 0x3C;  // mask BLBxx bits
    3a56:	8e 80       	ldd	r8, Y+6	; 0x06
          boot_lock_bits_set(lockBits);	// and program it
    3a58:	f3 ec       	ldi	r31, 0xC3	; 195
    3a5a:	8f 2a       	or	r8, r31
    3a5c:	e1 e0       	ldi	r30, 0x01	; 1
    3a5e:	f0 e0       	ldi	r31, 0x00	; 0
    3a60:	08 2c       	mov	r0, r8
    3a62:	30 93 57 00 	sts	0x0057, r19
    3a66:	e8 95       	spm
          boot_spm_busy_wait();
    3a68:	07 b6       	in	r0, 0x37	; 55
    3a6a:	00 fc       	sbrc	r0, 0
    3a6c:	fd cf       	rjmp	.-6      	; 0x3a68 <main+0x258>
          
          msgLength = 3;
          msgBuffer[1] = STATUS_CMD_OK;	                
    3a6e:	1b 82       	std	Y+3, r1	; 0x03
          msgBuffer[2] = STATUS_CMD_OK;	                                                        
    3a70:	1c 82       	std	Y+4, r1	; 0x04
    3a72:	e3 e0       	ldi	r30, 0x03	; 3
    3a74:	8e 2e       	mov	r8, r30
    3a76:	91 2c       	mov	r9, r1
        }
        break;
    3a78:	f7 c0       	rjmp	.+494    	; 0x3c68 <main+0x458>
#endif
      case CMD_CHIP_ERASE_ISP:
        eraseAddress = 0;
        msgLength = 2;
        msgBuffer[1] = STATUS_CMD_OK;
    3a7a:	1b 82       	std	Y+3, r1	; 0x03
    3a7c:	42 e0       	ldi	r20, 0x02	; 2
    3a7e:	84 2e       	mov	r8, r20
    3a80:	91 2c       	mov	r9, r1
    3a82:	40 e0       	ldi	r20, 0x00	; 0
    3a84:	50 e0       	ldi	r21, 0x00	; 0
        break;
    3a86:	f0 c0       	rjmp	.+480    	; 0x3c68 <main+0x458>
        
      case CMD_LOAD_ADDRESS:
#if defined(RAMPZ)
        address = ( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;
#else
        address = ( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;  //convert word to byte address
    3a88:	8d 81       	ldd	r24, Y+5	; 0x05
    3a8a:	c0 5e       	subi	r28, 0xE0	; 224
    3a8c:	de 4f       	sbci	r29, 0xFE	; 254
    3a8e:	88 83       	st	Y, r24
    3a90:	c0 52       	subi	r28, 0x20	; 32
    3a92:	d1 40       	sbci	r29, 0x01	; 1
    3a94:	c1 5e       	subi	r28, 0xE1	; 225
    3a96:	de 4f       	sbci	r29, 0xFE	; 254
    3a98:	18 82       	st	Y, r1
    3a9a:	cf 51       	subi	r28, 0x1F	; 31
    3a9c:	d1 40       	sbci	r29, 0x01	; 1
    3a9e:	8e 81       	ldd	r24, Y+6	; 0x06
    3aa0:	90 e0       	ldi	r25, 0x00	; 0
    3aa2:	c1 5e       	subi	r28, 0xE1	; 225
    3aa4:	de 4f       	sbci	r29, 0xFE	; 254
    3aa6:	a8 81       	ld	r26, Y
    3aa8:	b9 81       	ldd	r27, Y+1	; 0x01
    3aaa:	cf 51       	subi	r28, 0x1F	; 31
    3aac:	d1 40       	sbci	r29, 0x01	; 1
    3aae:	8a 2b       	or	r24, r26
    3ab0:	9b 2b       	or	r25, r27
    3ab2:	88 0f       	add	r24, r24
    3ab4:	99 1f       	adc	r25, r25
#endif
        msgLength = 2;
        msgBuffer[1] = STATUS_CMD_OK;
    3ab6:	1b 82       	std	Y+3, r1	; 0x03
    3ab8:	d4 c0       	rjmp	.+424    	; 0x3c62 <main+0x452>
        break;
        
      case CMD_PROGRAM_FLASH_ISP:
      case CMD_PROGRAM_EEPROM_ISP:                
        {
          unsigned int  size = (((unsigned int)msgBuffer[1])<<8) | msgBuffer[2];
    3aba:	bb 81       	ldd	r27, Y+3	; 0x03
    3abc:	ce 5d       	subi	r28, 0xDE	; 222
    3abe:	de 4f       	sbci	r29, 0xFE	; 254
    3ac0:	b8 83       	st	Y, r27
    3ac2:	c2 52       	subi	r28, 0x22	; 34
    3ac4:	d1 40       	sbci	r29, 0x01	; 1
    3ac6:	cf 5d       	subi	r28, 0xDF	; 223
    3ac8:	de 4f       	sbci	r29, 0xFE	; 254
    3aca:	18 82       	st	Y, r1
    3acc:	c1 52       	subi	r28, 0x21	; 33
    3ace:	d1 40       	sbci	r29, 0x01	; 1
    3ad0:	ec 81       	ldd	r30, Y+4	; 0x04
    3ad2:	ae 2f       	mov	r26, r30
    3ad4:	b0 e0       	ldi	r27, 0x00	; 0
    3ad6:	cf 5d       	subi	r28, 0xDF	; 223
    3ad8:	de 4f       	sbci	r29, 0xFE	; 254
    3ada:	e8 81       	ld	r30, Y
    3adc:	f9 81       	ldd	r31, Y+1	; 0x01
    3ade:	c1 52       	subi	r28, 0x21	; 33
    3ae0:	d1 40       	sbci	r29, 0x01	; 1
    3ae2:	ae 2b       	or	r26, r30
    3ae4:	bf 2b       	or	r27, r31
    3ae6:	cd 5d       	subi	r28, 0xDD	; 221
    3ae8:	de 4f       	sbci	r29, 0xFE	; 254
    3aea:	b9 83       	std	Y+1, r27	; 0x01
    3aec:	a8 83       	st	Y, r26
    3aee:	c3 52       	subi	r28, 0x23	; 35
    3af0:	d1 40       	sbci	r29, 0x01	; 1
          unsigned int  data;
          unsigned char highByte, lowByte;                    
          address_t     tempaddress = address;
          
          
          if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
    3af2:	f3 e1       	ldi	r31, 0x13	; 19
    3af4:	8f 16       	cp	r8, r31
    3af6:	09 f0       	breq	.+2      	; 0x3afa <main+0x2ea>
    3af8:	56 c0       	rjmp	.+172    	; 0x3ba6 <main+0x396>
          {
            // erase only main section (bootloader protection)
            if  (  eraseAddress < APP_END )
    3afa:	a8 e3       	ldi	r26, 0x38	; 56
    3afc:	40 30       	cpi	r20, 0x00	; 0
    3afe:	5a 07       	cpc	r21, r26
    3b00:	b0 f4       	brcc	.+44     	; 0x3b2e <main+0x31e>
            {
              boot_page_erase(eraseAddress);	// Perform page erase
    3b02:	a3 e0       	ldi	r26, 0x03	; 3
    3b04:	fa 01       	movw	r30, r20
    3b06:	a0 93 57 00 	sts	0x0057, r26
    3b0a:	e8 95       	spm
    3b0c:	cd 5d       	subi	r28, 0xDD	; 221
    3b0e:	de 4f       	sbci	r29, 0xFE	; 254
    3b10:	e8 81       	ld	r30, Y
    3b12:	f9 81       	ldd	r31, Y+1	; 0x01
    3b14:	c3 52       	subi	r28, 0x23	; 35
    3b16:	d1 40       	sbci	r29, 0x01	; 1
              boot_spm_busy_wait();		// Wait until the memory is erased.
    3b18:	07 b6       	in	r0, 0x37	; 55
    3b1a:	00 fc       	sbrc	r0, 0
    3b1c:	fd cf       	rjmp	.-6      	; 0x3b18 <main+0x308>
    3b1e:	cd 5d       	subi	r28, 0xDD	; 221
    3b20:	de 4f       	sbci	r29, 0xFE	; 254
    3b22:	f9 83       	std	Y+1, r31	; 0x01
    3b24:	e8 83       	st	Y, r30
    3b26:	c3 52       	subi	r28, 0x23	; 35
    3b28:	d1 40       	sbci	r29, 0x01	; 1
              eraseAddress += SPM_PAGESIZE;    // point to next page to be erase
    3b2a:	40 58       	subi	r20, 0x80	; 128
    3b2c:	5f 4f       	sbci	r21, 0xFF	; 255
    3b2e:	4c 01       	movw	r8, r24
    3b30:	2c 01       	movw	r4, r24
    3b32:	cd 5d       	subi	r28, 0xDD	; 221
    3b34:	de 4f       	sbci	r29, 0xFE	; 254
    3b36:	88 81       	ld	r24, Y
    3b38:	99 81       	ldd	r25, Y+1	; 0x01
    3b3a:	c3 52       	subi	r28, 0x23	; 35
    3b3c:	d1 40       	sbci	r29, 0x01	; 1
    3b3e:	cd 5d       	subi	r28, 0xDD	; 221
    3b40:	de 4f       	sbci	r29, 0xFE	; 254
    3b42:	f9 82       	std	Y+1, r15	; 0x01
    3b44:	e8 82       	st	Y, r14
    3b46:	c3 52       	subi	r28, 0x23	; 35
    3b48:	d1 40       	sbci	r29, 0x01	; 1
            }
            
            /* Write FLASH */
            do {
              lowByte   = *p++;
    3b4a:	cd 5d       	subi	r28, 0xDD	; 221
    3b4c:	de 4f       	sbci	r29, 0xFE	; 254
    3b4e:	e8 81       	ld	r30, Y
    3b50:	f9 81       	ldd	r31, Y+1	; 0x01
    3b52:	c3 52       	subi	r28, 0x23	; 35
    3b54:	d1 40       	sbci	r29, 0x01	; 1
    3b56:	60 80       	ld	r6, Z
              highByte  = *p++;
    3b58:	21 80       	ldd	r2, Z+1	; 0x01
  return UART_DATA_REG;
}


int main(void) __attribute__ ((OS_main));
int main(void)
    3b5a:	32 96       	adiw	r30, 0x02	; 2
    3b5c:	cd 5d       	subi	r28, 0xDD	; 221
    3b5e:	de 4f       	sbci	r29, 0xFE	; 254
    3b60:	f9 83       	std	Y+1, r31	; 0x01
    3b62:	e8 83       	st	Y, r30
    3b64:	c3 52       	subi	r28, 0x23	; 35
    3b66:	d1 40       	sbci	r29, 0x01	; 1
            do {
              lowByte   = *p++;
              highByte  = *p++;
              
              data =  (highByte << 8) | lowByte;
              boot_page_fill(address,data);
    3b68:	d2 2c       	mov	r13, r2
    3b6a:	cc 24       	eor	r12, r12
    3b6c:	77 24       	eor	r7, r7
    3b6e:	6c 28       	or	r6, r12
    3b70:	7d 28       	or	r7, r13
    3b72:	a1 e0       	ldi	r26, 0x01	; 1
    3b74:	f4 01       	movw	r30, r8
    3b76:	03 01       	movw	r0, r6
    3b78:	a0 93 57 00 	sts	0x0057, r26
    3b7c:	e8 95       	spm
    3b7e:	11 24       	eor	r1, r1
              
              address = address + 2;  	// Select next word in memory
    3b80:	e2 e0       	ldi	r30, 0x02	; 2
    3b82:	f0 e0       	ldi	r31, 0x00	; 0
    3b84:	8e 0e       	add	r8, r30
    3b86:	9f 1e       	adc	r9, r31
              size -= 2;			// Reduce number of bytes to write by two    
    3b88:	02 97       	sbiw	r24, 0x02	; 2
            } while(size);			// Loop until all bytes written
    3b8a:	f9 f6       	brne	.-66     	; 0x3b4a <main+0x33a>
            
            boot_page_write(tempaddress);
    3b8c:	a5 e0       	ldi	r26, 0x05	; 5
    3b8e:	f2 01       	movw	r30, r4
    3b90:	a0 93 57 00 	sts	0x0057, r26
    3b94:	e8 95       	spm
            boot_spm_busy_wait();	
    3b96:	07 b6       	in	r0, 0x37	; 55
    3b98:	00 fc       	sbrc	r0, 0
    3b9a:	fd cf       	rjmp	.-6      	; 0x3b96 <main+0x386>
            boot_rww_enable();				// Re-enable the RWW section                    
    3b9c:	b1 e1       	ldi	r27, 0x11	; 17
    3b9e:	b0 93 57 00 	sts	0x0057, r27
    3ba2:	e8 95       	spm
    3ba4:	20 c0       	rjmp	.+64     	; 0x3be6 <main+0x3d6>
    3ba6:	4c 01       	movw	r8, r24
    3ba8:	cd 5d       	subi	r28, 0xDD	; 221
    3baa:	de 4f       	sbci	r29, 0xFE	; 254
    3bac:	68 80       	ld	r6, Y
    3bae:	79 80       	ldd	r7, Y+1	; 0x01
    3bb0:	c3 52       	subi	r28, 0x23	; 35
    3bb2:	d1 40       	sbci	r29, 0x01	; 1
    3bb4:	27 01       	movw	r4, r14
    3bb6:	1c 01       	movw	r2, r24
    3bb8:	f3 01       	movw	r30, r6
          }
          else
          {
            /* write EEPROM */
            do {
              EEARL = address;			// Setup EEPROM address
    3bba:	81 bc       	out	0x21, r8	; 33
              EEARH = (address >> 8);
    3bbc:	92 bc       	out	0x22, r9	; 34
              address++;					// Select next EEPROM byte
    3bbe:	08 94       	sec
    3bc0:	81 1c       	adc	r8, r1
    3bc2:	91 1c       	adc	r9, r1
              
              EEDR= *p++;				    // get byte from buffer
    3bc4:	d2 01       	movw	r26, r4
    3bc6:	9d 91       	ld	r25, X+
    3bc8:	2d 01       	movw	r4, r26
    3bca:	90 bd       	out	0x20, r25	; 32
              EECR |= (1<<EEMWE);			// Write data into EEPROM
    3bcc:	fa 9a       	sbi	0x1f, 2	; 31
              EECR |= (1<<EEWE);
    3bce:	f9 9a       	sbi	0x1f, 1	; 31
              
              while (EECR & (1<<EEWE));	// Wait for write operation to finish
    3bd0:	f9 99       	sbic	0x1f, 1	; 31
    3bd2:	fe cf       	rjmp	.-4      	; 0x3bd0 <main+0x3c0>
              size--;						// Decrease number of bytes to write
    3bd4:	08 94       	sec
    3bd6:	61 08       	sbc	r6, r1
    3bd8:	71 08       	sbc	r7, r1
            } while(size);					// Loop until all bytes written    		            
    3bda:	61 14       	cp	r6, r1
    3bdc:	71 04       	cpc	r7, r1
    3bde:	69 f7       	brne	.-38     	; 0x3bba <main+0x3aa>
    3be0:	4f 01       	movw	r8, r30
    3be2:	82 0c       	add	r8, r2
    3be4:	93 1c       	adc	r9, r3
          }
          msgLength = 2;
          msgBuffer[1] = STATUS_CMD_OK;    		        
    3be6:	1b 82       	std	Y+3, r1	; 0x03
    3be8:	c4 01       	movw	r24, r8
    3bea:	3b c0       	rjmp	.+118    	; 0x3c62 <main+0x452>
        break;
        
      case CMD_READ_FLASH_ISP:
      case CMD_READ_EEPROM_ISP:                                                
        {
          unsigned int  size = (((unsigned int)msgBuffer[1])<<8) | msgBuffer[2];
    3bec:	bb 80       	ldd	r11, Y+3	; 0x03
    3bee:	aa 24       	eor	r10, r10
    3bf0:	8c 80       	ldd	r8, Y+4	; 0x04
    3bf2:	99 24       	eor	r9, r9
    3bf4:	8a 28       	or	r8, r10
    3bf6:	9b 28       	or	r9, r11
          unsigned char *p = msgBuffer+1;
          msgLength = size+3;
          
          *p++ = STATUS_CMD_OK;                    
    3bf8:	1b 82       	std	Y+3, r1	; 0x03
          if (msgBuffer[0] == CMD_READ_FLASH_ISP )
    3bfa:	ea 81       	ldd	r30, Y+2	; 0x02
    3bfc:	e4 31       	cpi	r30, 0x14	; 20
    3bfe:	a1 f4       	brne	.+40     	; 0x3c28 <main+0x418>
    3c00:	34 01       	movw	r6, r8
    3c02:	d8 01       	movw	r26, r16
            // Read FLASH
            do {                            
#if defined(RAMPZ)
              data = pgm_read_word_far(address);
#else
              data = pgm_read_word_near(address);
    3c04:	fc 01       	movw	r30, r24
    3c06:	25 90       	lpm	r2, Z+
    3c08:	34 90       	lpm	r3, Z+
#endif
              *p++ = (unsigned char)data;         //LSB
    3c0a:	2c 92       	st	X, r2
              *p++ = (unsigned char)(data >> 8);	//MSB  
    3c0c:	11 96       	adiw	r26, 0x01	; 1
    3c0e:	3c 92       	st	X, r3
    3c10:	11 97       	sbiw	r26, 0x01	; 1
  return UART_DATA_REG;
}


int main(void) __attribute__ ((OS_main));
int main(void)
    3c12:	12 96       	adiw	r26, 0x02	; 2
#else
              data = pgm_read_word_near(address);
#endif
              *p++ = (unsigned char)data;         //LSB
              *p++ = (unsigned char)(data >> 8);	//MSB  
              address    += 2;  	 // Select next word in memory
    3c14:	02 96       	adiw	r24, 0x02	; 2
              size -= 2;
    3c16:	ee ef       	ldi	r30, 0xFE	; 254
    3c18:	ff ef       	ldi	r31, 0xFF	; 255
    3c1a:	6e 0e       	add	r6, r30
    3c1c:	7f 1e       	adc	r7, r31
            }while (size);
    3c1e:	61 14       	cp	r6, r1
    3c20:	71 04       	cpc	r7, r1
    3c22:	81 f7       	brne	.-32     	; 0x3c04 <main+0x3f4>
    3c24:	fd 01       	movw	r30, r26
    3c26:	15 c0       	rjmp	.+42     	; 0x3c52 <main+0x442>
    3c28:	3c 01       	movw	r6, r24
    3c2a:	24 01       	movw	r4, r8
    3c2c:	f8 01       	movw	r30, r16
    3c2e:	1c 01       	movw	r2, r24
          }
          else
          {
            /* Read EEPROM */
            do {
              EEARL = address;			// Setup EEPROM address
    3c30:	61 bc       	out	0x21, r6	; 33
              EEARH = ((address >> 8));
    3c32:	72 bc       	out	0x22, r7	; 34
              address++;					// Select next EEPROM byte
    3c34:	08 94       	sec
    3c36:	61 1c       	adc	r6, r1
    3c38:	71 1c       	adc	r7, r1
              EECR |= (1<<EERE);			// Read EEPROM
    3c3a:	f8 9a       	sbi	0x1f, 0	; 31
              *p++ = EEDR;				// Send EEPROM data
    3c3c:	90 b5       	in	r25, 0x20	; 32
    3c3e:	91 93       	st	Z+, r25
              size--;    			        
    3c40:	08 94       	sec
    3c42:	41 08       	sbc	r4, r1
    3c44:	51 08       	sbc	r5, r1
            }while(size);
    3c46:	41 14       	cp	r4, r1
    3c48:	51 04       	cpc	r5, r1
    3c4a:	91 f7       	brne	.-28     	; 0x3c30 <main+0x420>
    3c4c:	c1 01       	movw	r24, r2
    3c4e:	88 0d       	add	r24, r8
    3c50:	99 1d       	adc	r25, r9
      case CMD_READ_FLASH_ISP:
      case CMD_READ_EEPROM_ISP:                                                
        {
          unsigned int  size = (((unsigned int)msgBuffer[1])<<8) | msgBuffer[2];
          unsigned char *p = msgBuffer+1;
          msgLength = size+3;
    3c52:	a3 e0       	ldi	r26, 0x03	; 3
    3c54:	b0 e0       	ldi	r27, 0x00	; 0
    3c56:	8a 0e       	add	r8, r26
    3c58:	9b 1e       	adc	r9, r27
              EECR |= (1<<EERE);			// Read EEPROM
              *p++ = EEDR;				// Send EEPROM data
              size--;    			        
            }while(size);
          }
          *p++ = STATUS_CMD_OK;
    3c5a:	10 82       	st	Z, r1
        }
        break;
    3c5c:	05 c0       	rjmp	.+10     	; 0x3c68 <main+0x458>
        
      default:
        msgLength = 2;   
        msgBuffer[1] = STATUS_CMD_FAILED;
    3c5e:	b0 ec       	ldi	r27, 0xC0	; 192
    3c60:	bb 83       	std	Y+3, r27	; 0x03
    3c62:	a2 e0       	ldi	r26, 0x02	; 2
    3c64:	8a 2e       	mov	r8, r26
    3c66:	91 2c       	mov	r9, r1
/*
* send single byte to USART, wait until transmission is completed
*/
static void sendchar(char c)
{
  UART_DATA_REG = c;                                         // prepare transmission
    3c68:	eb e1       	ldi	r30, 0x1B	; 27
    3c6a:	e0 93 c6 00 	sts	0x00C6, r30
    3c6e:	fc 01       	movw	r30, r24
  while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));// wait until byte sent
    3c70:	90 91 c0 00 	lds	r25, 0x00C0
    3c74:	96 ff       	sbrs	r25, 6
    3c76:	fc cf       	rjmp	.-8      	; 0x3c70 <main+0x460>
    3c78:	cf 01       	movw	r24, r30
  UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);          // delete TXCflag
    3c7a:	e0 91 c0 00 	lds	r30, 0x00C0
    3c7e:	e0 64       	ori	r30, 0x40	; 64
    3c80:	e0 93 c0 00 	sts	0x00C0, r30
/*
* send single byte to USART, wait until transmission is completed
*/
static void sendchar(char c)
{
  UART_DATA_REG = c;                                         // prepare transmission
    3c84:	20 93 c6 00 	sts	0x00C6, r18
    3c88:	fc 01       	movw	r30, r24
  while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));// wait until byte sent
    3c8a:	90 91 c0 00 	lds	r25, 0x00C0
    3c8e:	96 ff       	sbrs	r25, 6
    3c90:	fc cf       	rjmp	.-8      	; 0x3c8a <main+0x47a>
    3c92:	cf 01       	movw	r24, r30
  UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);          // delete TXCflag
    3c94:	e0 91 c0 00 	lds	r30, 0x00C0
    3c98:	e0 64       	ori	r30, 0x40	; 64
    3c9a:	e0 93 c0 00 	sts	0x00C0, r30
/*
* send single byte to USART, wait until transmission is completed
*/
static void sendchar(char c)
{
  UART_DATA_REG = c;                                         // prepare transmission
    3c9e:	90 92 c6 00 	sts	0x00C6, r9
    3ca2:	fc 01       	movw	r30, r24
    3ca4:	89 2d       	mov	r24, r9
  while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));// wait until byte sent
    3ca6:	90 91 c0 00 	lds	r25, 0x00C0
    3caa:	96 ff       	sbrs	r25, 6
    3cac:	fc cf       	rjmp	.-8      	; 0x3ca6 <main+0x496>
    3cae:	68 2e       	mov	r6, r24
    3cb0:	cf 01       	movw	r24, r30
    3cb2:	f6 2d       	mov	r31, r6
  UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);          // delete TXCflag
    3cb4:	e0 91 c0 00 	lds	r30, 0x00C0
    3cb8:	e0 64       	ori	r30, 0x40	; 64
    3cba:	e0 93 c0 00 	sts	0x00C0, r30
      
      c = ((msgLength>>8)&0xFF);
      sendchar(c);
      checksum ^= c;
      
      c = msgLength&0x00FF;
    3cbe:	68 2c       	mov	r6, r8
/*
* send single byte to USART, wait until transmission is completed
*/
static void sendchar(char c)
{
  UART_DATA_REG = c;                                         // prepare transmission
    3cc0:	80 92 c6 00 	sts	0x00C6, r8
    3cc4:	4f 2e       	mov	r4, r31
    3cc6:	fc 01       	movw	r30, r24
    3cc8:	84 2d       	mov	r24, r4
  while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));// wait until byte sent
    3cca:	90 91 c0 00 	lds	r25, 0x00C0
    3cce:	96 ff       	sbrs	r25, 6
    3cd0:	fc cf       	rjmp	.-8      	; 0x3cca <main+0x4ba>
    3cd2:	48 2e       	mov	r4, r24
    3cd4:	cf 01       	movw	r24, r30
  UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);          // delete TXCflag
    3cd6:	e0 91 c0 00 	lds	r30, 0x00C0
    3cda:	e0 64       	ori	r30, 0x40	; 64
    3cdc:	e0 93 c0 00 	sts	0x00C0, r30
/*
* send single byte to USART, wait until transmission is completed
*/
static void sendchar(char c)
{
  UART_DATA_REG = c;                                         // prepare transmission
    3ce0:	ee e0       	ldi	r30, 0x0E	; 14
    3ce2:	e0 93 c6 00 	sts	0x00C6, r30
    3ce6:	fc 01       	movw	r30, r24
    3ce8:	84 2d       	mov	r24, r4
  while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));// wait until byte sent
    3cea:	90 91 c0 00 	lds	r25, 0x00C0
    3cee:	96 ff       	sbrs	r25, 6
    3cf0:	fc cf       	rjmp	.-8      	; 0x3cea <main+0x4da>
    3cf2:	48 2e       	mov	r4, r24
    3cf4:	cf 01       	movw	r24, r30
  UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);          // delete TXCflag
    3cf6:	e0 91 c0 00 	lds	r30, 0x00C0
    3cfa:	e0 64       	ori	r30, 0x40	; 64
    3cfc:	e0 93 c0 00 	sts	0x00C0, r30
      sendchar(seqNum);
      checksum ^= seqNum;
      
      c = ((msgLength>>8)&0xFF);
      sendchar(c);
      checksum ^= c;
    3d00:	e5 e1       	ldi	r30, 0x15	; 21
    3d02:	e2 27       	eor	r30, r18
      
      c = msgLength&0x00FF;
      sendchar(c);
      checksum ^= c;
    3d04:	e6 25       	eor	r30, r6
      
      sendchar(TOKEN);
      checksum ^= TOKEN;
    3d06:	e4 25       	eor	r30, r4
    3d08:	f2 e0       	ldi	r31, 0x02	; 2
    3d0a:	6f 2e       	mov	r6, r31
    3d0c:	71 2c       	mov	r7, r1
    3d0e:	6c 0e       	add	r6, r28
    3d10:	7d 1e       	adc	r7, r29
    3d12:	2c 01       	movw	r4, r24
    3d14:	1a 01       	movw	r2, r20
      
      p = msgBuffer;
      while ( msgLength )
    3d16:	14 c0       	rjmp	.+40     	; 0x3d40 <main+0x530>
      {                
        c = *p++;
    3d18:	d3 01       	movw	r26, r6
    3d1a:	5c 91       	ld	r21, X
/*
* send single byte to USART, wait until transmission is completed
*/
static void sendchar(char c)
{
  UART_DATA_REG = c;                                         // prepare transmission
    3d1c:	50 93 c6 00 	sts	0x00C6, r21
  while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));// wait until byte sent
    3d20:	80 91 c0 00 	lds	r24, 0x00C0
    3d24:	86 ff       	sbrs	r24, 6
    3d26:	fc cf       	rjmp	.-8      	; 0x3d20 <main+0x510>
      checksum ^= TOKEN;
      
      p = msgBuffer;
      while ( msgLength )
      {                
        c = *p++;
    3d28:	08 94       	sec
    3d2a:	61 1c       	adc	r6, r1
    3d2c:	71 1c       	adc	r7, r1
*/
static void sendchar(char c)
{
  UART_DATA_REG = c;                                         // prepare transmission
  while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));// wait until byte sent
  UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);          // delete TXCflag
    3d2e:	90 91 c0 00 	lds	r25, 0x00C0
    3d32:	90 64       	ori	r25, 0x40	; 64
    3d34:	90 93 c0 00 	sts	0x00C0, r25
      p = msgBuffer;
      while ( msgLength )
      {                
        c = *p++;
        sendchar(c);
        checksum ^=c;
    3d38:	e5 27       	eor	r30, r21
        msgLength--;               
    3d3a:	08 94       	sec
    3d3c:	81 08       	sbc	r8, r1
    3d3e:	91 08       	sbc	r9, r1
      
      sendchar(TOKEN);
      checksum ^= TOKEN;
      
      p = msgBuffer;
      while ( msgLength )
    3d40:	81 14       	cp	r8, r1
    3d42:	91 04       	cpc	r9, r1
    3d44:	49 f7       	brne	.-46     	; 0x3d18 <main+0x508>
    3d46:	a1 01       	movw	r20, r2
/*
* send single byte to USART, wait until transmission is completed
*/
static void sendchar(char c)
{
  UART_DATA_REG = c;                                         // prepare transmission
    3d48:	e0 93 c6 00 	sts	0x00C6, r30
    3d4c:	42 01       	movw	r8, r4
  while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));// wait until byte sent
    3d4e:	90 91 c0 00 	lds	r25, 0x00C0
    3d52:	96 ff       	sbrs	r25, 6
    3d54:	fc cf       	rjmp	.-8      	; 0x3d4e <main+0x53e>
    3d56:	c4 01       	movw	r24, r8
  UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);          // delete TXCflag
    3d58:	f0 91 c0 00 	lds	r31, 0x00C0
    3d5c:	f0 64       	ori	r31, 0x40	; 64
    3d5e:	f0 93 c0 00 	sts	0x00C0, r31
        sendchar(c);
        checksum ^=c;
        msgLength--;               
      }                   
      sendchar(checksum);	        
      seqNum++;
    3d62:	2f 5f       	subi	r18, 0xFF	; 255
    3d64:	f0 e0       	ldi	r31, 0x00	; 0
    3d66:	66 24       	eor	r6, r6
    3d68:	77 24       	eor	r7, r7
    3d6a:	2c 01       	movw	r4, r24
    3d6c:	7d cd       	rjmp	.-1286   	; 0x3868 <main+0x58>
  
  /*
  * Now leave bootloader
  */
#ifndef REMOVE_PROG_PIN_PULLUP	
  PROG_PORT &= ~(1<<PROG_PIN);    // set to default
    3d6e:	2c 98       	cbi	0x05, 4	; 5
#ifdef ENABLE_LEAVE_BOOTLOADER	
  UART_STATUS_REG = 0;
  UART_BAUD_RATE_LOW = 0;
  UART_CONTROL_REG = 0;
#endif	
  boot_rww_enable();              // enable application section
    3d70:	81 e1       	ldi	r24, 0x11	; 17
    3d72:	80 93 57 00 	sts	0x0057, r24
    3d76:	e8 95       	spm
  
  // Jump to Reset vector in Application Section
  // (clear register, push this register to the stack twice = adress 0x0000/words, and return to this address) 
  asm volatile ( 
    3d78:	11 24       	eor	r1, r1
    3d7a:	1f 92       	push	r1
    3d7c:	1f 92       	push	r1
    3d7e:	08 95       	ret
    3d80:	ff cf       	rjmp	.-2      	; 0x3d80 <main+0x570>
