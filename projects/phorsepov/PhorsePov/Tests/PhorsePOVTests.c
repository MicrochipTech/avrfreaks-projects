/**
 * POVMsgTest
 **/
#include <stdio.h>
#include <string.h>

#define EEMEM
#define PROGMEM
#define GetPgmByte(lval) (lval)

typedef unsigned char byte;
typedef unsigned short ushort;
typedef byte tBool;
#define kTrue 1
#define kFalse 0

// Simulation environment
byte PORTB=0,DDRB=0;

#define kRows 3
#define kRowReps 2
byte gRow=0,gRowReps=0;
byte gRowPortSetting[][4][2] PROGMEM = {
 	{{7,0}, {3,1}, {6,4}, {7,5}}, // {000,001,100,101}, Segments a,d da.
 	{{7,0}, {3,2}, {5,4}, {7,6}}, // {000,010,100,110}, Segments b,e eb
 	{{7,0}, {6,2}, {5,1}, {7,3}},	//{000,010,010,011}  Segments c,f fc
};
 
 /**
  * DoPovScan handles a single pov scan column, returning kTrue when the 
  * scan is complete.
  * INPUT: byte scan: the scan code.
  * OUTPUT: tBool kTrue if pov scan is complete, kFalse otherwise.
  * USES gRow, gRowReps.
  **/
tBool DoPovScan(byte scan)
{
 	byte bitPair,temp;
 	byte *setting;
 	tBool doneScan=kFalse;
 	bitPair=(scan>>(gRow<<1))&3;
 	PORTB&=~5;	// set the outer ports to 0 to remove potential pull-ups.
 	setting=gRowPortSetting[gRow][bitPair];
 	temp=(DDRB&0xf8) | GetPgmByte(*setting++);
 	DDRB=temp;	// update DDRS.
 	temp= (PORTB&0xf8)|GetPgmByte(*setting);
 	PORTB=temp;
 	if(++gRow>=kRows) {
 		gRow=0;
 		if(++gRowReps>=kRowReps) {
 			gRowReps=0;
 			doneScan=kTrue;
 		}
 	}
 	return doneScan;
}

#define kPovBuffSize 32
//char gPovBuff[kPovBuffSize+1] EEMEM= "0123456789ABCDEFGHIJKLMNOPQRSTUV";
char gPovBuff[kPovBuffSize+1] EEMEM= "PHORSEPOV (C)NICHEMACHINES 2010\377";
#define E2PromRdCh(addr) (*(addr))

#define kPovColsPerChar 6
#define kCharSetSize 64*kPovColsPerChar
#define kPovImgWidth 6


byte kCharBitMap[6*64] PROGMEM = {
	 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1d, 0x0, 0x0, 0x0,
	 0x0, 0x5, 0x0, 0x5, 0x0, 0x0, 0x6, 0x1f, 0x6, 0x1f, 0x6, 0x0,
	 0x8, 0x18, 0x3f, 0x6, 0x4, 0x0, 0xd, 0x7, 0x10, 0xe, 0xb, 0x0,
	 0x6, 0x19, 0xe, 0x2, 0x18, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0,
	 0x0, 0x0, 0x16, 0x9, 0x0, 0x0, 0x0, 0x0, 0x9, 0x16, 0x0, 0x0,
	 0xc, 0x12, 0x1e, 0x12, 0xc, 0x0, 0x10, 0x10, 0x1f, 0x10, 0x10,
	 0x0, 0x0, 0x0, 0x20, 0x8, 0x0, 0x0, 0x10, 0x10, 0x10, 0x10, 0x10,
	 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x8, 0x2, 0x10, 0x4, 0x1, 0x0,
	 0x16, 0xb, 0x19, 0xd, 0x16, 0x0, 0x0, 0xc, 0x1f, 0x8, 0x0, 0x0,
	 0xb, 0x19, 0x19, 0x19, 0xc, 0x0, 0x9, 0x19, 0x19, 0x19, 0x6, 0x0,
	 0x12, 0x6, 0x3, 0x1f, 0x2, 0x0, 0x1d, 0x19, 0x19, 0x19, 0x3, 0x0,
	 0x12, 0x1c, 0x19, 0x19, 0x3, 0x0, 0x1, 0x1, 0xb, 0x11, 0x5, 0x0,
	 0x6, 0x19, 0x19, 0x19, 0x6, 0x0, 0x4, 0x19, 0x19, 0x13, 0x14, 0x0,
	 0x0, 0x0, 0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x18, 0x0, 0x0,
	 0x0, 0x10, 0x6, 0x9, 0x0, 0x0, 0x6, 0x6, 0x6, 0x6, 0x6, 0x0,
	 0x0, 0x9, 0x6, 0x10, 0x0, 0x0, 0x4, 0x1, 0x19, 0x11, 0x4, 0x0,
	 0x16, 0x9, 0x1d, 0x19, 0x1c, 0x0, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x0,
	 0x1f, 0x19, 0x19, 0x19, 0x6, 0x0, 0x16, 0x9, 0x9, 0x9, 0x9, 0x0,
	 0x1f, 0x9, 0x9, 0x6, 0x10, 0x0, 0x1f, 0x19, 0x19, 0x19, 0x9, 0x0,
	 0x1f, 0x11, 0x11, 0x11, 0x1, 0x0, 0x16, 0x9, 0x19, 0x19, 0x1b, 0x0,
	 0x1f, 0x10, 0x10, 0x10, 0x1f, 0x0, 0x0, 0x9, 0x1f, 0x9, 0x0, 0x0,
	 0x0, 0x8, 0x9, 0x17, 0x1, 0x0, 0x0, 0x1f, 0x10, 0x6, 0x9, 0x0,
	 0x0, 0x1f, 0x8, 0x8, 0x8, 0x0, 0x1f, 0x4, 0x10, 0x4, 0x1f, 0x0,
	 0x1f, 0x4, 0x10, 0x2, 0x1f, 0x0, 0x16, 0x9, 0x9, 0x9, 0x16, 0x0,
	 0x1f, 0x11, 0x11, 0x11, 0x4, 0x0, 0x16, 0x9, 0x19, 0xb, 0x1e, 0x0,
	 0x1e, 0x11, 0x13, 0x19, 0xc, 0x0, 0x4, 0x19, 0x19, 0x19, 0x2, 0x0,
	 0x1, 0x1, 0x1f, 0x1, 0x1, 0x0, 0x17, 0x8, 0x8, 0x8, 0x17, 0x0,
	 0x15, 0x2, 0x8, 0x2, 0x15, 0x0, 0x17, 0x8, 0x12, 0x8, 0x17, 0x0,
	 0x9, 0x6, 0x10, 0x6, 0x9, 0x0, 0x1, 0x4, 0x1a, 0x4, 0x1, 0x0,
	 0x9, 0xb, 0x19, 0xd, 0x9, 0x0, 0x0, 0x0, 0x1f, 0x9, 0x0, 0x0,
	 0x16, 0x9, 0x19, 0x1f, 0x16, 0x0, 0x0, 0x0, 0x9, 0x1f, 0x0, 0x0,
	 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
};

byte *gBitPos;
byte gPovCol=5,gPovPos=kPovBuffSize;  // 0..5, char pos in display.
byte gPovImgPos=0xff;	// just before the beginning.
byte gPovLen;  // Length generated by Add method.
char gPovDir=1;  // was backwards.
#define EndRowMarker (kCharBitMap[6*62])

/**
 * Here
 * gPovCol counts the column within the character.
 * gPovImgPos counts the 
 **/

byte PovMsgOld(void)
{
 	byte scan;
     gPovCol+=gPovDir;
     if(gPovCol>=kPovColsPerChar) {  // new char.
       byte pos;
       gPovCol=(gPovDir>0)? 0:5;
       gPovImgPos+=gPovDir;
       if(gPovImgPos>kPovImgWidth) {
         gPovDir=-gPovDir;
         if(gPovPos<gPovLen)
           gPovPos++;  // next char on reverse.
         else
           gPovPos=0;  // finished text, restart.
         gPovImgPos=0;
       }
       pos=gPovPos+((gPovDir>0)? kPovImgWidth-(gPovImgPos*kPovColsPerChar):
       												gPovImgPos);
       if(gPovImgPos==kPovImgWidth)
         gBitPos=&EndRowMarker;  // last row is '|' as a marker.
       else if(gPovPos+pos>=gPovLen)  // end of text.
         gBitPos=&kCharBitMap[0];  // space.
       else
         gBitPos=&kCharBitMap[(byte)(E2PromRdCh(&gPovBuff[pos])-' ')];	//
     }
     scan=GetPgmByte(*gBitPos);
     gBitPos++;
     return scan;
}

/**
 * Maybe it's better to conceive of the PovMsg as a conventional
 * video scan. There's a margin (6), then 240 columns, then another margin (6).
 * So, we have 252 pixels in total. The key thing then is to think about
 * what's displayed at any one point. There's a character position
 * (in the text)
 **/
#define kLHMargin 6
#define kPovImgCols kPovImgWidth*kPovColsPerChar
//#define kRHMargin (kLHMargin+kPovImgCols)
// For unidirectional
#define kRHMargin (kLHMargin+kPovImgCols)

#define kFullScanPeriod ((kRHMargin+kLHMargin)*2)
#define kPovSyncCol (kLHMargin+kPovImgCols/2)
#define kPovScroll 1	/* scroll forwards 1 pixel */

byte gScroll=-kPovScroll,gScrollCh=0;
byte gCharPos=0;
byte gSyncScan=0;
/*
byte PovMsg(void)
{
	byte scan=0;
	if(gPovImgPos>=kFullScanPeriod) {
		gPovImgPos=0;	// reset position ready for next scan.
		scan=0x3f;	// full bar at the beginning of the scan.
	}
	if(gPovImgPos==kLHMargin) {	// at exactly the margin we reset the info.
		//if((gPovDir=-gPovDir)>=0) {		// reverse direction.
		if(gPovDir>=0) {	// forward only for the moment.
			gCharPos=0;			// this is the relative character position
								// in the display.
			gPovCol=0;			// this is the column within the char pos in
								// the display.
		}
		else {
			gCharPos=kPovImgWidth-1;
			gPovCol=kPovColsPerChar-1;	// scanning from the end.
		}
		gScroll+=kPovScroll;	// this is the initial scroll offset.
		while(gScroll>=kPovColsPerChar) {
			gScrollCh++;
			if(gScrollCh>=gPovLen)
				gScrollCh=0;
			gScroll-=kPovScroll;
		}
	}
	if(gPovImgPos>=kLHMargin && gPovImgPos<kRHMargin) { // displayable.
		byte buffPos=0,col=gScroll+gPovCol;
		if(col>=kPovColsPerChar) {
			buffPos++;	// increment if on the next char.
			col-=kPovColsPerChar;
		}
		buffPos+=gCharPos+gScrollCh;
		if(buffPos>=gPovLen) {	// wrap to start of msg?
			buffPos-=gPovLen;
#if 0
			if(buffPos>=gPovLen)	// msg is shorter than display.
				gBitPos=&kCharBitMap[0];	// display a space.
#endif
		}
		else {
			gBitPos=&kCharBitMap[kPovColsPerChar*(E2PromRdCh(
										&gPovBuff[buffPos])-' ')+col];
		}
		gPovCol+=gPovDir;
		if(gPovCol>=kPovColsPerChar) {
			gPovCol=(gPovDir>0)? 0:(kPovColsPerChar-1);
			gCharPos+=gPovDir;	// increment to next char.
		}
		scan=GetPgmByte(*gBitPos);
	}
	gPovImgPos++; // next scanning position.
	return scan;
}
*/

byte PovMsg(void)
{
	byte scan=0;
	if(gPovImgPos>=kFullScanPeriod) {
		gPovImgPos=0;	// reset position ready for next scan.
		gSyncScan++;
		gScroll+=kPovScroll;	// The new scroll offset.
		while(gScroll>=kPovColsPerChar) {
			gScrollCh++;
			if(gScrollCh>=gPovLen)
				gScrollCh=0;
			gScroll-=kPovColsPerChar;
		}
	}
	if(gPovImgPos==kLHMargin) {	// at exactly the margin we reset the info.
		gCharPos=gScrollCh;			// Start at this character in the msg.
		gPovCol=gScroll;			// and this column.
		if(gPovDir<0) {
			gCharPos+=kPovImgWidth-1;
			gPovCol+=kPovColsPerChar-1;	// scanning from the end.
		}
	}
	if(gPovImgPos>=kLHMargin && gPovImgPos<kRHMargin) { // displayable.
		if(gPovCol>=kPovColsPerChar) {
			gPovCol+=(gPovDir>0)? (-kPovColsPerChar):kPovColsPerChar;
			gCharPos+=gPovDir;	// increment to next char.
			if(gCharPos>=gPovLen)	// wrap to start of msg?
				gCharPos-=gPovLen;	// reset the char pos.
		}
		if(gPovLen>0) {
			scan|=GetPgmByte(kCharBitMap[kPovColsPerChar*(E2PromRdCh(&gPovBuff[
													gCharPos])-' ')+gPovCol]);
		}

		gPovCol+=gPovDir;
	}
	if((gPovImgPos==kPovSyncCol || gPovImgPos==0) && (gSyncScan&1))
		scan|=0x20;	// segment 'f' is on bit 5 too.
	gPovImgPos++; // next scanning position.
	return scan;
}


/**
 *
 **/
char gLeds[7]="      ";
int gLedMap[] = {
	0,0,5,
	1,0,2,
	4,3,0
};

char *ShowLeds(byte port,byte ddr)
{
	int anode,cathode;
	strcpy(gLeds,"......");
	for(anode=0;anode<3;anode++) {
		for(cathode=0;cathode<3;cathode++) {
			if(anode!=cathode && (ddr&(1<<cathode))!=0 &&
					((port>>anode)&1)>((port>>cathode)&1)) {
				gLeds[gLedMap[anode*3+cathode]]='*';
			}
		}
	}
	return gLeds;
}

// converts a scan code back to Leds. da, eb, fc.
char *CombLeds(byte scan)
{
	int ix;
	strcpy(gLeds,"......");
	for(ix=0;ix<3;ix++) {
		if(scan&1)
			gLeds[5-ix]='*';
		if(scan&2)
			gLeds[2-ix]='*';
		scan>>=2;
	}
	return gLeds;
}

int main(int argc, char* argv[])
{
	int ix,scan,res;
	byte povImg,newKey=0,key;
	// PovMsg test.
	printf("kPovSyncCol=%d\n",kPovSyncCol);
	printf("ix\tgPovCol\tgPovDir\tImgPos\tgBitPos\tScan\n");
	gPovLen=strlen(gPovBuff)-1;
	for(ix=0;ix<1000;ix++) {
		scan=PovMsg();
		printf("%d\t%d\t\t%d\t\t%d\t\t%d\t\t%d",ix,gPovCol,gPovDir,gPovImgPos,
				gBitPos-&kCharBitMap[0],scan);	// now convert to scans.
		printf("\t\t%s\n",CombLeds(scan));
	}
	
	// PovScan test.
	printf("Key\timg\tPORTB\tDDRB\tLEDs\n");
	while(newKey<64) {
		key=newKey;
		byte ix;
		povImg=0;
		for(ix=0;ix<3;ix++) {
			povImg<<=2;
			if(key&4)
				povImg++;
			if(key&0x20)
				povImg+=2;
			key<<=1;
		}	// calc pattern into povImg.
		do{
			res=DoPovScan(povImg);
			printf("%d\t%x\t%x\t\t%x\t\t%s\n",newKey,povImg,PORTB,DDRB,ShowLeds(PORTB,DDRB));
		}while(res!=kTrue);
		newKey++;
	}
	return 0;
}