
butt_menu.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  000007a2  00000836  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000007a2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000029  00800102  00800102  00000838  2**0
                  ALLOC
  3 .stab         00000378  00000000  00000000  00000838  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000071  00000000  00000000  00000bb0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000020  00000000  00000000  00000c21  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001d1  00000000  00000000  00000c41  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00000870  00000000  00000000  00000e12  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000025f  00000000  00000000  00001682  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000694  00000000  00000000  000018e1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000150  00000000  00000000  00001f78  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000379  00000000  00000000  000020c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000291  00000000  00000000  00002441  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000018  00000000  00000000  000026d2  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__ctors_end>
   4:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
   8:	0c 94 ab 01 	jmp	0x356	; 0x356 <__vector_2>
   c:	0c 94 87 01 	jmp	0x30e	; 0x30e <__vector_3>
  10:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  14:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  18:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  1c:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  20:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  24:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  28:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  2c:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  30:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  34:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  38:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  3c:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  40:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  44:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  48:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  4c:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  50:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  54:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
  58:	0c 94 cf 01 	jmp	0x39e	; 0x39e <__vector_22>

0000005c <Func_1_str>:
  5c:	4f 70 74 69 6f 6e 73 00                             Options.

00000064 <Func_2_str>:
  64:	53 74 61 72 74 00                                   Start.

0000006a <Func_3_str>:
  6a:	46 75 6e 63 20 33 00                                Func 3.

00000071 <MainFunctionNames>:
  71:	5c 00 64 00 6a 00                                   \.d.j.

00000077 <MainFunctionPtrs>:
  77:	3f 03 36 03 2d 03                                   ?.6.-.

0000007d <Message1>:
  7d:	2a 4f 70 74 69 6f 6e 73 20 6d 65 6e 75 2a 00        *Options menu*.

0000008c <Message2>:
  8c:	2a 52 75 6e 6e 69 6e 67 2a 00                       *Running*.

00000096 <Message3>:
  96:	45 78 65 63 20 33 00                                Exec 3.

0000009d <AboutText>:
  9d:	56 65 72 73 69 6f 6e 20 31 2c 30 00                 Version 1,0.

000000a9 <LCD_SegTable>:
  a9:	a8 ea 80 2a 00 40 00 0a 51 0a 08 40 59 55 18 01     ...*.@..Q..@YU..
  b9:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
  c9:	00 00 00 00 08 80 00 1a 20 40 00 00 00 00 51 0f     ........ @....Q.
  d9:	91 39 41 14 91 31 41 1e 41 0e 41 1d 50 0f 80 20     .9A..1A.A.A.P.. 
  e9:	10 15 48 86 40 14 78 05 70 85 51 15 51 0e 51 95     ..H.@.x.p.Q.Q.Q.
  f9:	51 8e 21 90 81 20 50 15 48 44 50 c5 28 c0 28 20     Q.!.. P.HDP.(.( 
 109:	09 50 41 14 20 80 11 11 00 00 00 10 00              .PA. ........

00000116 <__ctors_end>:
 116:	11 24       	eor	r1, r1
 118:	1f be       	out	0x3f, r1	; 63
 11a:	cf ef       	ldi	r28, 0xFF	; 255
 11c:	d4 e0       	ldi	r29, 0x04	; 4
 11e:	de bf       	out	0x3e, r29	; 62
 120:	cd bf       	out	0x3d, r28	; 61

00000122 <__do_copy_data>:
 122:	11 e0       	ldi	r17, 0x01	; 1
 124:	a0 e0       	ldi	r26, 0x00	; 0
 126:	b1 e0       	ldi	r27, 0x01	; 1
 128:	e2 ea       	ldi	r30, 0xA2	; 162
 12a:	f7 e0       	ldi	r31, 0x07	; 7
 12c:	02 c0       	rjmp	.+4      	; 0x132 <.do_copy_data_start>

0000012e <.do_copy_data_loop>:
 12e:	05 90       	lpm	r0, Z+
 130:	0d 92       	st	X+, r0

00000132 <.do_copy_data_start>:
 132:	a2 30       	cpi	r26, 0x02	; 2
 134:	b1 07       	cpc	r27, r17
 136:	d9 f7       	brne	.-10     	; 0x12e <.do_copy_data_loop>

00000138 <__do_clear_bss>:
 138:	11 e0       	ldi	r17, 0x01	; 1
 13a:	a2 e0       	ldi	r26, 0x02	; 2
 13c:	b1 e0       	ldi	r27, 0x01	; 1
 13e:	01 c0       	rjmp	.+2      	; 0x142 <.do_clear_bss_start>

00000140 <.do_clear_bss_loop>:
 140:	1d 92       	st	X+, r1

00000142 <.do_clear_bss_start>:
 142:	ab 32       	cpi	r26, 0x2B	; 43
 144:	b1 07       	cpc	r27, r17
 146:	e1 f7       	brne	.-8      	; 0x140 <.do_clear_bss_loop>
 148:	0e 94 51 03 	call	0x6a2	; 0x6a2 <main>
 14c:	0c 94 d0 03 	jmp	0x7a0	; 0x7a0 <_exit>

00000150 <__bad_interrupt>:
 150:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000154 <LCD_Init>:
 ARGUMENTS: | None
 RETURNS:   | None
*/
void LCD_Init(void)
{
 154:	8f e0       	ldi	r24, 0x0F	; 15
 156:	80 93 e7 00 	sts	0x00E7, r24
   // Set the initial contrast level to maximum:
   LCD_CONTRAST_LEVEL(0x0F);

    // Select asynchronous clock source, enable all COM pins and enable all segment pins:
    LCDCRB  = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
 15a:	87 eb       	ldi	r24, 0xB7	; 183
 15c:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 64Hz:
    LCDFRR  = (0<<LCDPS0) | (3<<LCDCD0);   
 160:	83 e0       	ldi	r24, 0x03	; 3
 162:	80 93 e6 00 	sts	0x00E6, r24

   // Enable LCD and set low power waveform, enable start of frame interrupt:
    LCDCRA  = (1<<LCDEN) | (1<<LCDAB) | (1<<LCDIE);
 166:	88 ec       	ldi	r24, 0xC8	; 200
 168:	80 93 e4 00 	sts	0x00E4, r24
 16c:	08 95       	ret

0000016e <LCD_puts>:
}

/*
 NAME:      | LCD_puts
 PURPOSE:   | Displays a string from flash onto the Butterfly's LCD
 ARGUMENTS: | Pointer to the start of the flash string
 RETURNS:   | None
*/
void LCD_puts_f(const char *FlashData)
{
   /* Rather than create a new buffer here (wasting RAM), the TextBuffer global
      is re-used as a temp buffer. Once the ASCII data is loaded in to TextBuffer,
      LCD_puts is called with it to post-process it into the correct format for the
      LCD interrupt.                                                                */

   strcpy_P((char*)&TextBuffer[0], FlashData);
   LCD_puts((char*)&TextBuffer[0]);
}

/*
 NAME:      | LCD_puts
 PURPOSE:   | Displays a string from SRAM onto the Butterfly's LCD
 ARGUMENTS: | Pointer to the start of the SRAM string
 RETURNS:   | None
*/
void LCD_puts(const char *Data)
{
 16e:	dc 01       	movw	r26, r24
 170:	20 e0       	ldi	r18, 0x00	; 0
 172:	3f ef       	ldi	r19, 0xFF	; 255
   uint8_t Nulls,LoadB = 0;
   uint8_t CurrByte;

   do
   {
      CurrByte = *(Data++);
 174:	9d 91       	ld	r25, X+
      
      switch (CurrByte)
 176:	9b 37       	cpi	r25, 0x7B	; 123
 178:	90 f4       	brcc	.+36     	; 0x19e <LCD_puts+0x30>
 17a:	91 36       	cpi	r25, 0x61	; 97
 17c:	38 f4       	brcc	.+14     	; 0x18c <LCD_puts+0x1e>
 17e:	99 23       	and	r25, r25
 180:	a1 f0       	breq	.+40     	; 0x1aa <LCD_puts+0x3c>
 182:	89 2f       	mov	r24, r25
 184:	8a 52       	subi	r24, 0x2A	; 42
 186:	86 33       	cpi	r24, 0x36	; 54
 188:	50 f4       	brcc	.+20     	; 0x19e <LCD_puts+0x30>
 18a:	01 c0       	rjmp	.+2      	; 0x18e <LCD_puts+0x20>
      {
         case 'a'...'z':
            CurrByte &= ~(1 << 5);                   // Translate to upper-case character
 18c:	9f 7d       	andi	r25, 0xDF	; 223
         case '*'...'_':                                // Valid character, load it into the array
            TextBuffer[LoadB++] = (CurrByte - '*');
 18e:	e2 2f       	mov	r30, r18
 190:	ff 27       	eor	r31, r31
 192:	9a 52       	subi	r25, 0x2A	; 42
 194:	e2 5f       	subi	r30, 0xF2	; 242
 196:	fe 4f       	sbci	r31, 0xFE	; 254
 198:	90 83       	st	Z, r25
 19a:	96 5d       	subi	r25, 0xD6	; 214
 19c:	05 c0       	rjmp	.+10     	; 0x1a8 <LCD_puts+0x3a>
            break;
         case 0x00:                                   // Null termination of the string - ignore for now so the nulls can be appended below
            break;
         default:                                     // Space or invalid character, use 0xFF to display a blank
            TextBuffer[LoadB++] = LCD_SPACE_OR_INVALID_CHAR;
 19e:	e2 2f       	mov	r30, r18
 1a0:	ff 27       	eor	r31, r31
 1a2:	e2 5f       	subi	r30, 0xF2	; 242
 1a4:	fe 4f       	sbci	r31, 0xFE	; 254
 1a6:	30 83       	st	Z, r19
 1a8:	2f 5f       	subi	r18, 0xFF	; 255
      }
   }
   while (CurrByte && (LoadB < LCD_TEXTBUFFER_SIZE));
 1aa:	99 23       	and	r25, r25
 1ac:	11 f0       	breq	.+4      	; 0x1b2 <LCD_puts+0x44>
 1ae:	24 31       	cpi	r18, 0x14	; 20
 1b0:	08 f3       	brcs	.-62     	; 0x174 <LCD_puts+0x6>

   ScrollFlags = ((LoadB > LCD_DISPLAY_SIZE)? LCD_FLAG_SCROLL : 0x00);
 1b2:	80 e0       	ldi	r24, 0x00	; 0
 1b4:	27 30       	cpi	r18, 0x07	; 7
 1b6:	08 f0       	brcs	.+2      	; 0x1ba <LCD_puts+0x4c>
 1b8:	81 e0       	ldi	r24, 0x01	; 1
 1ba:	80 93 02 01 	sts	0x0102, r24
 1be:	82 2f       	mov	r24, r18
 1c0:	90 e0       	ldi	r25, 0x00	; 0
 1c2:	3f ef       	ldi	r19, 0xFF	; 255

   for (Nulls = 0; Nulls < LCD_DISPLAY_SIZE; Nulls++)   // was: Nulls < 7, should be 6 anyway.
     TextBuffer[LoadB++] = LCD_SPACE_OR_INVALID_CHAR;  // Load in nulls to ensure that when scrolling, the display clears before wrapping
 1c4:	e8 2f       	mov	r30, r24
 1c6:	ff 27       	eor	r31, r31
 1c8:	e2 5f       	subi	r30, 0xF2	; 242
 1ca:	fe 4f       	sbci	r31, 0xFE	; 254
 1cc:	30 83       	st	Z, r19
 1ce:	8f 5f       	subi	r24, 0xFF	; 255
 1d0:	9f 5f       	subi	r25, 0xFF	; 255
 1d2:	96 30       	cpi	r25, 0x06	; 6
 1d4:	b9 f7       	brne	.-18     	; 0x1c4 <LCD_puts+0x56>
 1d6:	82 2f       	mov	r24, r18
 1d8:	8a 5f       	subi	r24, 0xFA	; 250
   
   TextBuffer[LoadB] = 0x00;                           // Null-terminate string
 1da:	e8 2f       	mov	r30, r24
 1dc:	ff 27       	eor	r31, r31
 1de:	e2 5f       	subi	r30, 0xF2	; 242
 1e0:	fe 4f       	sbci	r31, 0xFE	; 254
 1e2:	10 82       	st	Z, r1
   
   StrStart      = 0;
 1e4:	10 92 29 01 	sts	0x0129, r1
   StrEnd        = LoadB;
 1e8:	80 93 2a 01 	sts	0x012A, r24
   ScrollCount   = LCD_SCROLLCOUNT_DEFAULT + LCD_DELAYCOUNT_DEFAULT;
 1ec:	8a e1       	ldi	r24, 0x1A	; 26
 1ee:	80 93 0b 01 	sts	0x010B, r24
   UpdateDisplay = true;
 1f2:	81 e0       	ldi	r24, 0x01	; 1
 1f4:	80 93 0a 01 	sts	0x010A, r24
   if (LCD_Flash) FlashTimer=FLASH_TIMER_SEED;      //start frame counter for flashing digits
 1f8:	80 91 0c 01 	lds	r24, 0x010C
 1fc:	88 23       	and	r24, r24
 1fe:	19 f0       	breq	.+6      	; 0x206 <LCD_puts+0x98>
 200:	80 e1       	ldi	r24, 0x10	; 16
 202:	80 93 0d 01 	sts	0x010D, r24
 206:	08 95       	ret

00000208 <LCD_WriteChar>:

}

/*
 NAME:      | LCD_vect (ISR, blocking)
 PURPOSE:   | ISR to handle the display and scrolling of the current display string onto the LCD
 ARGUMENTS: | None
 RETURNS:   | None
*/

ISR(LCD_vect)
{
uint8_t Character;

//**** begin Joystick stuff

// Debounce timeout and key validity check for the joystick

    if(DebounceTimeout>0) 
      {
      DebounceTimeout--;
      if (DebounceTimeout==0) //completed timeout for key debounce
         {   
         if (KEY==ReadButtons())    //same key still down?
         KEY_VALID=true;  //yes, tell the world
         }
      }

// Autorepeat timeout for joystick data entry.

    if(AutoRepeatTimeout>0)
   { 
   AutoRepeatTimeout--;   
   if (AutoRepeatTimeout == 0) //got here so AutoRepeatTimeout must have been set previously
      {
      if (KEY==ReadButtons()) KEY_VALID=true;   //if button still pressed, send last virtual key again
      if (KeyAutoRepeat) AutoRepeatTimeout=AutoRepeatPeriod;   //reload counter only if autorepeat flag on
      }
   }


//**** end Joystick

//**** begin Tone generation

	if(ToneDuration>0)
	{
	ToneDuration--;					// tone generator is on so count down for timeout
	if (ToneDuration == 0) 			// done?
		{ TCCR1A = 0;TCCR1B = 0;}	// if so, shut it off
	}

//**** end Tone generation code

   if (ScrollFlags & LCD_FLAG_SCROLL)
   {
      if (!(ScrollCount--))
      {
         UpdateDisplay = true;
         ScrollCount   = LCD_SCROLLCOUNT_DEFAULT;
      }
   }

   if (LCD_Flash)   //Are any digits blinking? DOES NOT WORK WITH SCROLLING DISPLAY
   {
      if (FlashTimer == FLASH_TIMER_SEED)       //(8 frames on, 8 off)
       {
        for (Character = 0; Character < LCD_DISPLAY_SIZE; Character++)
         {
            LCD_WriteChar(TextBuffer[Character], Character);
         }
      }

      if ( FlashTimer == (FLASH_TIMER_SEED>>1) )   //(8 frames on, 8 off)
      {
         for (Character = 0; Character < LCD_DISPLAY_SIZE; Character++)
            {
              if( LCD_Flash&(1<<Character) )  //check that character position
            LCD_WriteChar(LCD_SPACE_OR_INVALID_CHAR, Character);
         }
      }

      if (LCD_Flash && ((FlashTimer--) == 0)) FlashTimer=FLASH_TIMER_SEED;   //Reset blanking timer (16 frame cycle)
   }

   if (UpdateDisplay)
   {
      for (Character = 0; Character < LCD_DISPLAY_SIZE; Character++)
      {
         uint8_t Byte = (StrStart + Character);

      if (Byte >= StrEnd) 
          Byte -= StrEnd;

      LCD_WriteChar(TextBuffer[Byte], Character);
      }

      if ((StrStart + LCD_DISPLAY_SIZE) == StrEnd)    // Done scrolling message on LCD once
        ScrollFlags |= LCD_FLAG_SCROLL_DONE;
      
      if (StrStart++ == StrEnd)
        StrStart     = 1;

       if (ShowColons)
            *((uint8_t*)(LCD_LCDREGS_START + 8)) = 0x01;
        else
            *((uint8_t*)(LCD_LCDREGS_START + 8)) = 0x00;

      UpdateDisplay  = false;                         // Clear LCD management flags, LCD update is complete
   }
}

/*
 NAME:      | LCD_WriteChar (static, inline)
 PURPOSE:   | Routine to write a character to the correct LCD registers for display
 ARGUMENTS: | Character to display, LCD character number to display character on
 RETURNS:   | None
*/
static inline void LCD_WriteChar(const uint8_t Byte, const uint8_t Digit)
{
 208:	8f 3f       	cpi	r24, 0xFF	; 255
 20a:	19 f4       	brne	.+6      	; 0x212 <LCD_WriteChar+0xa>
    uint8_t BNib;
   uint8_t* BuffPtr = (uint8_t*)(LCD_LCDREGS_START + (Digit >> 1));
   uint16_t SegData = 0x0000;

   if (Byte != LCD_SPACE_OR_INVALID_CHAR)              // Null indicates invalid character or space
 20c:	40 e0       	ldi	r20, 0x00	; 0
 20e:	50 e0       	ldi	r21, 0x00	; 0
 210:	08 c0       	rjmp	.+16     	; 0x222 <LCD_WriteChar+0x1a>
     SegData = pgm_read_word(&LCD_SegTable[Byte]);   
 212:	e8 2f       	mov	r30, r24
 214:	ff 27       	eor	r31, r31
 216:	ee 0f       	add	r30, r30
 218:	ff 1f       	adc	r31, r31
 21a:	e7 55       	subi	r30, 0x57	; 87
 21c:	ff 4f       	sbci	r31, 0xFF	; 255
 21e:	45 91       	lpm	r20, Z+
 220:	54 91       	lpm	r21, Z
 222:	86 2f       	mov	r24, r22
 224:	86 95       	lsr	r24
 226:	e8 2f       	mov	r30, r24
 228:	ff 27       	eor	r31, r31
 22a:	e4 51       	subi	r30, 0x14	; 20
 22c:	ff 4f       	sbci	r31, 0xFF	; 255
 22e:	80 e0       	ldi	r24, 0x00	; 0
 230:	77 27       	eor	r23, r23
 232:	61 70       	andi	r22, 0x01	; 1
 234:	70 70       	andi	r23, 0x00	; 0

   for (BNib = 0; BNib < 4; BNib++)
   {
      uint8_t MaskedSegData = (SegData & 0x0000F);
 236:	24 2f       	mov	r18, r20
 238:	2f 70       	andi	r18, 0x0F	; 15
 23a:	90 81       	ld	r25, Z

      if (Digit & 0x01)
 23c:	61 15       	cp	r22, r1
 23e:	71 05       	cpc	r23, r1
 240:	31 f0       	breq	.+12     	; 0x24e <LCD_WriteChar+0x46>
        *BuffPtr = ((*BuffPtr & 0x0F) | (MaskedSegData << 4));
 242:	9f 70       	andi	r25, 0x0F	; 15
 244:	22 95       	swap	r18
 246:	20 7f       	andi	r18, 0xF0	; 240
 248:	29 2b       	or	r18, r25
 24a:	20 83       	st	Z, r18
 24c:	03 c0       	rjmp	.+6      	; 0x254 <LCD_WriteChar+0x4c>
      else
        *BuffPtr = ((*BuffPtr & 0xF0) | MaskedSegData);
 24e:	90 7f       	andi	r25, 0xF0	; 240
 250:	92 2b       	or	r25, r18
 252:	90 83       	st	Z, r25
 254:	8f 5f       	subi	r24, 0xFF	; 255
 256:	84 30       	cpi	r24, 0x04	; 4
 258:	39 f0       	breq	.+14     	; 0x268 <LCD_WriteChar+0x60>

      BuffPtr += 5;
 25a:	35 96       	adiw	r30, 0x05	; 5
      SegData >>= 4;
 25c:	94 e0       	ldi	r25, 0x04	; 4
 25e:	56 95       	lsr	r21
 260:	47 95       	ror	r20
 262:	9a 95       	dec	r25
 264:	e1 f7       	brne	.-8      	; 0x25e <LCD_WriteChar+0x56>
 266:	e7 cf       	rjmp	.-50     	; 0x236 <LCD_WriteChar+0x2e>
 268:	08 95       	ret

0000026a <LCD_ShowColons>:
   }   
}

/*
 NAME:      | LCD_ShowColons
 PURPOSE:   | Routine to turn on or off the LCD's colons
 ARGUMENTS: | Boolean - true to turn on colons
 RETURNS:   | None
*/
void LCD_ShowColons(const uint8_t ColonsOn)
{
 26a:	80 93 09 01 	sts	0x0109, r24
   ShowColons    = ColonsOn;
   UpdateDisplay = true;
 26e:	81 e0       	ldi	r24, 0x01	; 1
 270:	80 93 0a 01 	sts	0x010A, r24
 274:	08 95       	ret

00000276 <Joystick_Init>:
}

/*
** Joystick driver, derived mostly from original code by Atmel. 
** Some processing removed from interrupt routine
** Jim Remington (sjames_remington@yahoo.com)
*/

#define BUTTON_A    6   // UP (PLUS)
#define BUTTON_B    7   // DOWN (MINUS)
#define BUTTON_C    2   // LEFT (PREV)
#define BUTTON_D    3   // RIGHT (NEXT)
#define BUTTON_O    4   // PUSH (ENTER)

#define PINB_MASK ((1<<PINB4)|(1<<PINB6)|(1<<PINB7))
#define PINE_MASK ((1<<PINE2)|(1<<PINE3))

void Joystick_Init(void)
{
 276:	84 b1       	in	r24, 0x04	; 4
 278:	8f 72       	andi	r24, 0x2F	; 47
 27a:	84 b9       	out	0x04, r24	; 4
    // Init button port pins
   DDRB &= ~(PINB_MASK);
   PORTB |= PINB_MASK;  //pullups on
 27c:	85 b1       	in	r24, 0x05	; 5
 27e:	80 6d       	ori	r24, 0xD0	; 208
 280:	85 b9       	out	0x05, r24	; 5
   DDRE &= ~(PINE_MASK);
 282:	8d b1       	in	r24, 0x0d	; 13
 284:	83 7f       	andi	r24, 0xF3	; 243
 286:	8d b9       	out	0x0d, r24	; 13
   PORTE |= PINE_MASK;   // pullups on
 288:	8e b1       	in	r24, 0x0e	; 14
 28a:	8c 60       	ori	r24, 0x0C	; 12
 28c:	8e b9       	out	0x0e, r24	; 14

    // Enable pin change interrupt on PORTB and PORTE
   PCMSK0 |= PINE_MASK;
 28e:	eb e6       	ldi	r30, 0x6B	; 107
 290:	f0 e0       	ldi	r31, 0x00	; 0
 292:	80 81       	ld	r24, Z
 294:	8c 60       	ori	r24, 0x0C	; 12
 296:	80 83       	st	Z, r24
   PCMSK1 |= PINB_MASK;
 298:	ec e6       	ldi	r30, 0x6C	; 108
 29a:	f0 e0       	ldi	r31, 0x00	; 0
 29c:	80 81       	ld	r24, Z
 29e:	80 6d       	ori	r24, 0xD0	; 208
 2a0:	80 83       	st	Z, r24
   EIFR |= (1<<PCIF0)|(1<<PCIF1);
 2a2:	8c b3       	in	r24, 0x1c	; 28
 2a4:	80 6c       	ori	r24, 0xC0	; 192
 2a6:	8c bb       	out	0x1c, r24	; 28
   EIMSK |= (1<<PCIE0)|(1<<PCIE1);
 2a8:	8d b3       	in	r24, 0x1d	; 29
 2aa:	80 6c       	ori	r24, 0xC0	; 192
 2ac:	8d bb       	out	0x1d, r24	; 29
 2ae:	08 95       	ret

000002b0 <ReadButtons>:
}

/*
** Interrupt Service Routines
*/

ISR (PCINT0_vect)
{
   PinChangeInterrupt();
}

ISR (PCINT1_vect)
{
   PinChangeInterrupt();    
}

/*
** Process pin change interrupt. Set up LCD_Driver.c to process key debounce.
*/

void PinChangeInterrupt(void)
{
   KEY_VALID=false;   //set global valid flag false as not debounced yet.
   KEY=ReadButtons();   //put current key value in global KEY
   DebounceTimeout=3;   //start debounce timer (count LCD frames). After timeout, key debounce completed in LCD_Driver.c
}
/*
    Read the joystick buttons:

    Bit             7   6   5   4   3   2   1   0
    ---------------------------------------------
    PORTB           B   A       O
    PORTE                           D   C
    ---------------------------------------------
    PORTB | PORTE   B   A       O   D   C
    =============================================

   Returns: Virtual Key pressed.

*/

char ReadButtons(void)
{
 2b0:	23 b1       	in	r18, 0x03	; 3
    char buttons;
    char key;

    buttons  = (~PINB) & PINB_MASK;
    buttons |= (~PINE) & PINE_MASK;
 2b2:	8c b1       	in	r24, 0x0c	; 12
 2b4:	20 95       	com	r18
 2b6:	20 7d       	andi	r18, 0xD0	; 208
 2b8:	80 95       	com	r24
 2ba:	8c 70       	andi	r24, 0x0C	; 12
 2bc:	28 2b       	or	r18, r24

    // Output virtual keys
    if (buttons & (1<<BUTTON_A))
 2be:	82 2f       	mov	r24, r18
 2c0:	99 27       	eor	r25, r25
 2c2:	86 ff       	sbrs	r24, 6
 2c4:	02 c0       	rjmp	.+4      	; 0x2ca <ReadButtons+0x1a>
 2c6:	94 e0       	ldi	r25, 0x04	; 4
 2c8:	13 c0       	rjmp	.+38     	; 0x2f0 <ReadButtons+0x40>
        key = KEY_PLUS;
    else if (buttons & (1<<BUTTON_B))
 2ca:	27 ff       	sbrs	r18, 7
 2cc:	02 c0       	rjmp	.+4      	; 0x2d2 <ReadButtons+0x22>
 2ce:	95 e0       	ldi	r25, 0x05	; 5
 2d0:	0f c0       	rjmp	.+30     	; 0x2f0 <ReadButtons+0x40>
        key = KEY_MINUS;
    else if (buttons & (1<<BUTTON_C))
 2d2:	82 ff       	sbrs	r24, 2
 2d4:	02 c0       	rjmp	.+4      	; 0x2da <ReadButtons+0x2a>
 2d6:	93 e0       	ldi	r25, 0x03	; 3
 2d8:	0b c0       	rjmp	.+22     	; 0x2f0 <ReadButtons+0x40>
        key = KEY_PREV;
    else if (buttons & (1<<BUTTON_D))
 2da:	83 ff       	sbrs	r24, 3
 2dc:	02 c0       	rjmp	.+4      	; 0x2e2 <ReadButtons+0x32>
 2de:	92 e0       	ldi	r25, 0x02	; 2
 2e0:	07 c0       	rjmp	.+14     	; 0x2f0 <ReadButtons+0x40>
 2e2:	34 e0       	ldi	r19, 0x04	; 4
 2e4:	96 95       	lsr	r25
 2e6:	87 95       	ror	r24
 2e8:	3a 95       	dec	r19
 2ea:	e1 f7       	brne	.-8      	; 0x2e4 <ReadButtons+0x34>
 2ec:	98 2f       	mov	r25, r24
 2ee:	91 70       	andi	r25, 0x01	; 1
        key = KEY_NEXT;
    else if (buttons & (1<<BUTTON_O))
        key = KEY_ENTER;
    else
        key = KEY_NULL;         //invalid combination

    EIFR = (1<<PCIF1) | (1<<PCIF0);     // Reset pin change interrupt flags
 2f0:	80 ec       	ldi	r24, 0xC0	; 192
 2f2:	8c bb       	out	0x1c, r24	; 28
   return key;                     // return key currently pressed
}
 2f4:	89 2f       	mov	r24, r25
 2f6:	99 27       	eor	r25, r25
 2f8:	08 95       	ret

000002fa <PinChangeInterrupt>:
 2fa:	10 92 04 01 	sts	0x0104, r1
 2fe:	0e 94 58 01 	call	0x2b0	; 0x2b0 <ReadButtons>
 302:	80 93 05 01 	sts	0x0105, r24
 306:	83 e0       	ldi	r24, 0x03	; 3
 308:	80 93 08 01 	sts	0x0108, r24
 30c:	08 95       	ret

0000030e <__vector_3>:
 30e:	1f 92       	push	r1
 310:	0f 92       	push	r0
 312:	0f b6       	in	r0, 0x3f	; 63
 314:	0f 92       	push	r0
 316:	11 24       	eor	r1, r1
 318:	2f 93       	push	r18
 31a:	3f 93       	push	r19
 31c:	4f 93       	push	r20
 31e:	5f 93       	push	r21
 320:	6f 93       	push	r22
 322:	7f 93       	push	r23
 324:	8f 93       	push	r24
 326:	9f 93       	push	r25
 328:	af 93       	push	r26
 32a:	bf 93       	push	r27
 32c:	ef 93       	push	r30
 32e:	ff 93       	push	r31
 330:	0e 94 7d 01 	call	0x2fa	; 0x2fa <PinChangeInterrupt>
 334:	ff 91       	pop	r31
 336:	ef 91       	pop	r30
 338:	bf 91       	pop	r27
 33a:	af 91       	pop	r26
 33c:	9f 91       	pop	r25
 33e:	8f 91       	pop	r24
 340:	7f 91       	pop	r23
 342:	6f 91       	pop	r22
 344:	5f 91       	pop	r21
 346:	4f 91       	pop	r20
 348:	3f 91       	pop	r19
 34a:	2f 91       	pop	r18
 34c:	0f 90       	pop	r0
 34e:	0f be       	out	0x3f, r0	; 63
 350:	0f 90       	pop	r0
 352:	1f 90       	pop	r1
 354:	18 95       	reti

00000356 <__vector_2>:
 356:	1f 92       	push	r1
 358:	0f 92       	push	r0
 35a:	0f b6       	in	r0, 0x3f	; 63
 35c:	0f 92       	push	r0
 35e:	11 24       	eor	r1, r1
 360:	2f 93       	push	r18
 362:	3f 93       	push	r19
 364:	4f 93       	push	r20
 366:	5f 93       	push	r21
 368:	6f 93       	push	r22
 36a:	7f 93       	push	r23
 36c:	8f 93       	push	r24
 36e:	9f 93       	push	r25
 370:	af 93       	push	r26
 372:	bf 93       	push	r27
 374:	ef 93       	push	r30
 376:	ff 93       	push	r31
 378:	0e 94 7d 01 	call	0x2fa	; 0x2fa <PinChangeInterrupt>
 37c:	ff 91       	pop	r31
 37e:	ef 91       	pop	r30
 380:	bf 91       	pop	r27
 382:	af 91       	pop	r26
 384:	9f 91       	pop	r25
 386:	8f 91       	pop	r24
 388:	7f 91       	pop	r23
 38a:	6f 91       	pop	r22
 38c:	5f 91       	pop	r21
 38e:	4f 91       	pop	r20
 390:	3f 91       	pop	r19
 392:	2f 91       	pop	r18
 394:	0f 90       	pop	r0
 396:	0f be       	out	0x3f, r0	; 63
 398:	0f 90       	pop	r0
 39a:	1f 90       	pop	r1
 39c:	18 95       	reti

0000039e <__vector_22>:
 39e:	1f 92       	push	r1
 3a0:	0f 92       	push	r0
 3a2:	0f b6       	in	r0, 0x3f	; 63
 3a4:	0f 92       	push	r0
 3a6:	11 24       	eor	r1, r1
 3a8:	0f 93       	push	r16
 3aa:	1f 93       	push	r17
 3ac:	2f 93       	push	r18
 3ae:	3f 93       	push	r19
 3b0:	4f 93       	push	r20
 3b2:	5f 93       	push	r21
 3b4:	6f 93       	push	r22
 3b6:	7f 93       	push	r23
 3b8:	8f 93       	push	r24
 3ba:	9f 93       	push	r25
 3bc:	af 93       	push	r26
 3be:	bf 93       	push	r27
 3c0:	cf 93       	push	r28
 3c2:	df 93       	push	r29
 3c4:	ef 93       	push	r30
 3c6:	ff 93       	push	r31
 3c8:	80 91 08 01 	lds	r24, 0x0108
 3cc:	88 23       	and	r24, r24
 3ce:	91 f0       	breq	.+36     	; 0x3f4 <__vector_22+0x56>
 3d0:	80 91 08 01 	lds	r24, 0x0108
 3d4:	81 50       	subi	r24, 0x01	; 1
 3d6:	80 93 08 01 	sts	0x0108, r24
 3da:	80 91 08 01 	lds	r24, 0x0108
 3de:	88 23       	and	r24, r24
 3e0:	49 f4       	brne	.+18     	; 0x3f4 <__vector_22+0x56>
 3e2:	10 91 05 01 	lds	r17, 0x0105
 3e6:	0e 94 58 01 	call	0x2b0	; 0x2b0 <ReadButtons>
 3ea:	18 17       	cp	r17, r24
 3ec:	19 f4       	brne	.+6      	; 0x3f4 <__vector_22+0x56>
 3ee:	81 e0       	ldi	r24, 0x01	; 1
 3f0:	80 93 04 01 	sts	0x0104, r24
 3f4:	80 91 07 01 	lds	r24, 0x0107
 3f8:	88 23       	and	r24, r24
 3fa:	c9 f0       	breq	.+50     	; 0x42e <__vector_22+0x90>
 3fc:	80 91 07 01 	lds	r24, 0x0107
 400:	81 50       	subi	r24, 0x01	; 1
 402:	80 93 07 01 	sts	0x0107, r24
 406:	80 91 07 01 	lds	r24, 0x0107
 40a:	88 23       	and	r24, r24
 40c:	81 f4       	brne	.+32     	; 0x42e <__vector_22+0x90>
 40e:	10 91 05 01 	lds	r17, 0x0105
 412:	0e 94 58 01 	call	0x2b0	; 0x2b0 <ReadButtons>
 416:	18 17       	cp	r17, r24
 418:	19 f4       	brne	.+6      	; 0x420 <__vector_22+0x82>
 41a:	81 e0       	ldi	r24, 0x01	; 1
 41c:	80 93 04 01 	sts	0x0104, r24
 420:	80 91 06 01 	lds	r24, 0x0106
 424:	88 23       	and	r24, r24
 426:	19 f0       	breq	.+6      	; 0x42e <__vector_22+0x90>
 428:	80 e2       	ldi	r24, 0x20	; 32
 42a:	80 93 07 01 	sts	0x0107, r24
 42e:	80 91 03 01 	lds	r24, 0x0103
 432:	88 23       	and	r24, r24
 434:	69 f0       	breq	.+26     	; 0x450 <__vector_22+0xb2>
 436:	80 91 03 01 	lds	r24, 0x0103
 43a:	81 50       	subi	r24, 0x01	; 1
 43c:	80 93 03 01 	sts	0x0103, r24
 440:	80 91 03 01 	lds	r24, 0x0103
 444:	88 23       	and	r24, r24
 446:	21 f4       	brne	.+8      	; 0x450 <__vector_22+0xb2>
 448:	10 92 80 00 	sts	0x0080, r1
 44c:	10 92 81 00 	sts	0x0081, r1
 450:	80 91 02 01 	lds	r24, 0x0102
 454:	80 ff       	sbrs	r24, 0
 456:	0f c0       	rjmp	.+30     	; 0x476 <__vector_22+0xd8>
 458:	80 91 0b 01 	lds	r24, 0x010B
 45c:	81 50       	subi	r24, 0x01	; 1
 45e:	80 93 0b 01 	sts	0x010B, r24
 462:	80 91 0b 01 	lds	r24, 0x010B
 466:	8f 3f       	cpi	r24, 0xFF	; 255
 468:	31 f4       	brne	.+12     	; 0x476 <__vector_22+0xd8>
 46a:	81 e0       	ldi	r24, 0x01	; 1
 46c:	80 93 0a 01 	sts	0x010A, r24
 470:	86 e0       	ldi	r24, 0x06	; 6
 472:	80 93 0b 01 	sts	0x010B, r24
 476:	80 91 0c 01 	lds	r24, 0x010C
 47a:	88 23       	and	r24, r24
 47c:	d9 f1       	breq	.+118    	; 0x4f4 <__vector_22+0x156>
 47e:	80 91 0d 01 	lds	r24, 0x010D
 482:	80 31       	cpi	r24, 0x10	; 16
 484:	71 f4       	brne	.+28     	; 0x4a2 <__vector_22+0x104>
 486:	c0 e0       	ldi	r28, 0x00	; 0
 488:	d0 e0       	ldi	r29, 0x00	; 0
 48a:	0e e0       	ldi	r16, 0x0E	; 14
 48c:	11 e0       	ldi	r17, 0x01	; 1
 48e:	f8 01       	movw	r30, r16
 490:	81 91       	ld	r24, Z+
 492:	8f 01       	movw	r16, r30
 494:	6c 2f       	mov	r22, r28
 496:	0e 94 04 01 	call	0x208	; 0x208 <LCD_WriteChar>
 49a:	21 96       	adiw	r28, 0x01	; 1
 49c:	c6 30       	cpi	r28, 0x06	; 6
 49e:	d1 05       	cpc	r29, r1
 4a0:	b1 f7       	brne	.-20     	; 0x48e <__vector_22+0xf0>
 4a2:	80 91 0d 01 	lds	r24, 0x010D
 4a6:	88 30       	cpi	r24, 0x08	; 8
 4a8:	a9 f4       	brne	.+42     	; 0x4d4 <__vector_22+0x136>
 4aa:	c0 e0       	ldi	r28, 0x00	; 0
 4ac:	d0 e0       	ldi	r29, 0x00	; 0
 4ae:	80 91 0c 01 	lds	r24, 0x010C
 4b2:	99 27       	eor	r25, r25
 4b4:	0c 2e       	mov	r0, r28
 4b6:	02 c0       	rjmp	.+4      	; 0x4bc <__vector_22+0x11e>
 4b8:	95 95       	asr	r25
 4ba:	87 95       	ror	r24
 4bc:	0a 94       	dec	r0
 4be:	e2 f7       	brpl	.-8      	; 0x4b8 <__vector_22+0x11a>
 4c0:	80 ff       	sbrs	r24, 0
 4c2:	04 c0       	rjmp	.+8      	; 0x4cc <__vector_22+0x12e>
 4c4:	6c 2f       	mov	r22, r28
 4c6:	8f ef       	ldi	r24, 0xFF	; 255
 4c8:	0e 94 04 01 	call	0x208	; 0x208 <LCD_WriteChar>
 4cc:	21 96       	adiw	r28, 0x01	; 1
 4ce:	c6 30       	cpi	r28, 0x06	; 6
 4d0:	d1 05       	cpc	r29, r1
 4d2:	69 f7       	brne	.-38     	; 0x4ae <__vector_22+0x110>
 4d4:	80 91 0c 01 	lds	r24, 0x010C
 4d8:	88 23       	and	r24, r24
 4da:	61 f0       	breq	.+24     	; 0x4f4 <__vector_22+0x156>
 4dc:	80 91 0d 01 	lds	r24, 0x010D
 4e0:	81 50       	subi	r24, 0x01	; 1
 4e2:	80 93 0d 01 	sts	0x010D, r24
 4e6:	80 91 0d 01 	lds	r24, 0x010D
 4ea:	8f 3f       	cpi	r24, 0xFF	; 255
 4ec:	19 f4       	brne	.+6      	; 0x4f4 <__vector_22+0x156>
 4ee:	80 e1       	ldi	r24, 0x10	; 16
 4f0:	80 93 0d 01 	sts	0x010D, r24
 4f4:	80 91 0a 01 	lds	r24, 0x010A
 4f8:	88 23       	and	r24, r24
 4fa:	09 f4       	brne	.+2      	; 0x4fe <__vector_22+0x160>
 4fc:	3f c0       	rjmp	.+126    	; 0x57c <__stack+0x7d>
 4fe:	c0 e0       	ldi	r28, 0x00	; 0
 500:	d0 e0       	ldi	r29, 0x00	; 0
 502:	e0 91 29 01 	lds	r30, 0x0129
 506:	ec 0f       	add	r30, r28
 508:	80 91 2a 01 	lds	r24, 0x012A
 50c:	e8 17       	cp	r30, r24
 50e:	18 f0       	brcs	.+6      	; 0x516 <__stack+0x17>
 510:	80 91 2a 01 	lds	r24, 0x012A
 514:	e8 1b       	sub	r30, r24
 516:	ff 27       	eor	r31, r31
 518:	e2 5f       	subi	r30, 0xF2	; 242
 51a:	fe 4f       	sbci	r31, 0xFE	; 254
 51c:	80 81       	ld	r24, Z
 51e:	6c 2f       	mov	r22, r28
 520:	0e 94 04 01 	call	0x208	; 0x208 <LCD_WriteChar>
 524:	21 96       	adiw	r28, 0x01	; 1
 526:	c6 30       	cpi	r28, 0x06	; 6
 528:	d1 05       	cpc	r29, r1
 52a:	59 f7       	brne	.-42     	; 0x502 <__stack+0x3>
 52c:	80 91 29 01 	lds	r24, 0x0129
 530:	20 91 2a 01 	lds	r18, 0x012A
 534:	99 27       	eor	r25, r25
 536:	06 96       	adiw	r24, 0x06	; 6
 538:	33 27       	eor	r19, r19
 53a:	82 17       	cp	r24, r18
 53c:	93 07       	cpc	r25, r19
 53e:	29 f4       	brne	.+10     	; 0x54a <__stack+0x4b>
 540:	80 91 02 01 	lds	r24, 0x0102
 544:	82 60       	ori	r24, 0x02	; 2
 546:	80 93 02 01 	sts	0x0102, r24
 54a:	80 91 29 01 	lds	r24, 0x0129
 54e:	90 91 2a 01 	lds	r25, 0x012A
 552:	8f 5f       	subi	r24, 0xFF	; 255
 554:	80 93 29 01 	sts	0x0129, r24
 558:	81 50       	subi	r24, 0x01	; 1
 55a:	89 17       	cp	r24, r25
 55c:	19 f4       	brne	.+6      	; 0x564 <__stack+0x65>
 55e:	81 e0       	ldi	r24, 0x01	; 1
 560:	80 93 29 01 	sts	0x0129, r24
 564:	80 91 09 01 	lds	r24, 0x0109
 568:	88 23       	and	r24, r24
 56a:	21 f0       	breq	.+8      	; 0x574 <__stack+0x75>
 56c:	81 e0       	ldi	r24, 0x01	; 1
 56e:	80 93 f4 00 	sts	0x00F4, r24
 572:	02 c0       	rjmp	.+4      	; 0x578 <__stack+0x79>
 574:	10 92 f4 00 	sts	0x00F4, r1
 578:	10 92 0a 01 	sts	0x010A, r1
 57c:	ff 91       	pop	r31
 57e:	ef 91       	pop	r30
 580:	df 91       	pop	r29
 582:	cf 91       	pop	r28
 584:	bf 91       	pop	r27
 586:	af 91       	pop	r26
 588:	9f 91       	pop	r25
 58a:	8f 91       	pop	r24
 58c:	7f 91       	pop	r23
 58e:	6f 91       	pop	r22
 590:	5f 91       	pop	r21
 592:	4f 91       	pop	r20
 594:	3f 91       	pop	r19
 596:	2f 91       	pop	r18
 598:	1f 91       	pop	r17
 59a:	0f 91       	pop	r16
 59c:	0f 90       	pop	r0
 59e:	0f be       	out	0x3f, r0	; 63
 5a0:	0f 90       	pop	r0
 5a2:	1f 90       	pop	r1
 5a4:	18 95       	reti

000005a6 <getkey>:

// get key from 1-character key buffer.
// returns KEY_NULL (=0) if none

char getkey(void)
{
 5a6:	f8 94       	cli
    char k;

    cli();          // disable interrupts so 'KEY' won't change while in use
    if (KEY_VALID)   // Check for unread key in buffer
 5a8:	80 91 04 01 	lds	r24, 0x0104
 5ac:	88 23       	and	r24, r24
 5ae:	11 f4       	brne	.+4      	; 0x5b4 <getkey+0xe>
 5b0:	90 e0       	ldi	r25, 0x00	; 0
 5b2:	0b c0       	rjmp	.+22     	; 0x5ca <getkey+0x24>
    {
        k = KEY;
 5b4:	90 91 05 01 	lds	r25, 0x0105
        KEY_VALID = false;      //got that key!
 5b8:	10 92 04 01 	sts	0x0104, r1
   if (KeyAutoRepeat) AutoRepeatTimeout=AutoRepeatPeriod;   //load counter for key repeat if autorepeat flag set
 5bc:	80 91 06 01 	lds	r24, 0x0106
 5c0:	88 23       	and	r24, r24
 5c2:	19 f0       	breq	.+6      	; 0x5ca <getkey+0x24>
 5c4:	80 e2       	ldi	r24, 0x20	; 32
 5c6:	80 93 07 01 	sts	0x0107, r24
    }
    else
        k = KEY_NULL; // No key stroke available
    sei(); // enable interrupts
 5ca:	78 94       	sei

    return k;
}
 5cc:	89 2f       	mov	r24, r25
 5ce:	99 27       	eor	r25, r25
 5d0:	08 95       	ret

000005d2 <PlayTone>:
          | -- defined in LCD_Joystick.c 
 RETURNS:   | None
*/
void PlayTone(const uint8_t tone, uint8_t duration)
{
 5d2:	60 93 03 01 	sts	0x0103, r22

   ToneDuration=duration;                  // Set global countdown in 64ths of a second
   OCR1A  = ToneVol;                     // Set the tone volume  (default 80, lower is louder)
 5d6:	20 91 00 01 	lds	r18, 0x0100
 5da:	33 27       	eor	r19, r19
 5dc:	30 93 89 00 	sts	0x0089, r19
 5e0:	20 93 88 00 	sts	0x0088, r18
   TCCR1A = (1 << COM1A1);                  // OC1A set when counting up, cleared when counting down
 5e4:	90 e8       	ldi	r25, 0x80	; 128
 5e6:	90 93 80 00 	sts	0x0080, r25
   TCCR1B = ((1 << WGM13) | (1 << CS10));      // Phase/Freq correct PWM mode, turn on with prescale of 1
 5ea:	91 e1       	ldi	r25, 0x11	; 17
 5ec:	90 93 81 00 	sts	0x0081, r25
   
   TCNT1 = 0;                           // reset counter
 5f0:	10 92 85 00 	sts	0x0085, r1
 5f4:	10 92 84 00 	sts	0x0084, r1
   ICR1  = ((uint16_t)tone << 5);               // Set the ICR register - play the tone. Timing done in LCD interrupt
 5f8:	99 27       	eor	r25, r25
 5fa:	45 e0       	ldi	r20, 0x05	; 5
 5fc:	88 0f       	add	r24, r24
 5fe:	99 1f       	adc	r25, r25
 600:	4a 95       	dec	r20
 602:	e1 f7       	brne	.-8      	; 0x5fc <PlayTone+0x2a>
 604:	90 93 87 00 	sts	0x0087, r25
 608:	80 93 86 00 	sts	0x0086, r24
 60c:	08 95       	ret

0000060e <Delay10ms>:

}

/*
 NAME:      | Delay10ms
 PURPOSE:   | Delays for specified blocks of 10 milliseconds
 ARGUMENTS: | Number of blocks of 10ms to delay
 RETURNS:   | None
*/
void Delay10ms(int loops)
{
 60e:	9c 01       	movw	r18, r24
 610:	e0 e2       	ldi	r30, 0x20	; 32
 612:	fe e4       	ldi	r31, 0x4E	; 78
 614:	03 c0       	rjmp	.+6      	; 0x61c <Delay10ms+0xe>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 616:	cf 01       	movw	r24, r30
 618:	01 97       	sbiw	r24, 0x01	; 1
 61a:	f1 f7       	brne	.-4      	; 0x618 <Delay10ms+0xa>
  /* Prevents the use of floating point libraries. Delaying in groups of
     10ms increases accuracy by reducing the time overhead for each loop
     interation of the while.                                            */

   while (loops--)
 61c:	21 50       	subi	r18, 0x01	; 1
 61e:	30 40       	sbci	r19, 0x00	; 0
 620:	8f ef       	ldi	r24, 0xFF	; 255
 622:	2f 3f       	cpi	r18, 0xFF	; 255
 624:	38 07       	cpc	r19, r24
 626:	b9 f7       	brne	.-18     	; 0x616 <Delay10ms+0x8>
 628:	08 95       	ret

0000062a <Delay1ms>:
     _delay_ms(10);
}

/*
 NAME:      | Delay1ms
 PURPOSE:   | Delays for specified blocks of 1 milliseconds
 ARGUMENTS: | Number of blocks of 1ms to delay
 RETURNS:   | None
*/
void Delay1ms(uint8_t loops)
{
 62a:	28 2f       	mov	r18, r24
 62c:	e0 ed       	ldi	r30, 0xD0	; 208
 62e:	f7 e0       	ldi	r31, 0x07	; 7
 630:	03 c0       	rjmp	.+6      	; 0x638 <Delay1ms+0xe>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 632:	cf 01       	movw	r24, r30
 634:	01 97       	sbiw	r24, 0x01	; 1
 636:	f1 f7       	brne	.-4      	; 0x634 <Delay1ms+0xa>
  /* Prevents the use of floating point libraries. Less accurate than the
     Delay10MS routine, but nessesary for many commands. The overhead required
     to call the routine is substantially less than the overhead required to
     calculate the float at compile time, so this actually saves execution time. */

   while (loops--)
 638:	21 50       	subi	r18, 0x01	; 1
 63a:	d8 f7       	brcc	.-10     	; 0x632 <Delay1ms+0x8>
 63c:	08 95       	ret

0000063e <LCD_puts_f>:
 63e:	0f 93       	push	r16
 640:	1f 93       	push	r17
 642:	0e e0       	ldi	r16, 0x0E	; 14
 644:	11 e0       	ldi	r17, 0x01	; 1
 646:	bc 01       	movw	r22, r24
 648:	c8 01       	movw	r24, r16
 64a:	0e 94 c9 03 	call	0x792	; 0x792 <strcpy_P>
 64e:	c8 01       	movw	r24, r16
 650:	0e 94 b7 00 	call	0x16e	; 0x16e <LCD_puts>
 654:	1f 91       	pop	r17
 656:	0f 91       	pop	r16
 658:	08 95       	ret

0000065a <MAIN_3>:
     _delay_ms(1);
}
/*
 NAME:      | MAIN_TopMenu
 PURPOSE:   | Top of menu indicator. Shows string AboutText
 ARGUMENTS: | None
 RETURNS:   | None
*/
void MAIN_TopMenu(void)
{
   LCD_puts_f(AboutText);
   Delay10ms(300); //show for 3 seconds
}

/*
 NAME:      | MAIN_1
 PURPOSE:   |
 ARGUMENTS: | None
 RETURNS:   | None
*/

void MAIN_1(void)
{
   LCD_puts_f(Message1);
   Delay10ms(300);   //show for 3 seconds
}

/*
 NAME:      | MAIN_2
 PURPOSE:   | 
 ARGUMENTS: | None
 RETURNS:   | None
*/
void MAIN_2(void)
{
    LCD_puts_f(Message2);
   Delay10ms(300); //show for 3 seconds
}

/*
 NAME:      | MAIN_3
 PURPOSE:   | 
 ARGUMENTS: | None
 RETURNS:   | None
*/
void MAIN_3(void)
{
 65a:	86 e9       	ldi	r24, 0x96	; 150
 65c:	90 e0       	ldi	r25, 0x00	; 0
 65e:	0e 94 1f 03 	call	0x63e	; 0x63e <LCD_puts_f>
    LCD_puts_f(Message3);
   Delay10ms(300); //show for 3 seconds
 662:	8c e2       	ldi	r24, 0x2C	; 44
 664:	91 e0       	ldi	r25, 0x01	; 1
 666:	0e 94 07 03 	call	0x60e	; 0x60e <Delay10ms>
 66a:	08 95       	ret

0000066c <MAIN_2>:
 66c:	8c e8       	ldi	r24, 0x8C	; 140
 66e:	90 e0       	ldi	r25, 0x00	; 0
 670:	0e 94 1f 03 	call	0x63e	; 0x63e <LCD_puts_f>
 674:	8c e2       	ldi	r24, 0x2C	; 44
 676:	91 e0       	ldi	r25, 0x01	; 1
 678:	0e 94 07 03 	call	0x60e	; 0x60e <Delay10ms>
 67c:	08 95       	ret

0000067e <MAIN_1>:
 67e:	8d e7       	ldi	r24, 0x7D	; 125
 680:	90 e0       	ldi	r25, 0x00	; 0
 682:	0e 94 1f 03 	call	0x63e	; 0x63e <LCD_puts_f>
 686:	8c e2       	ldi	r24, 0x2C	; 44
 688:	91 e0       	ldi	r25, 0x01	; 1
 68a:	0e 94 07 03 	call	0x60e	; 0x60e <Delay10ms>
 68e:	08 95       	ret

00000690 <MAIN_TopMenu>:
 690:	8d e9       	ldi	r24, 0x9D	; 157
 692:	90 e0       	ldi	r25, 0x00	; 0
 694:	0e 94 1f 03 	call	0x63e	; 0x63e <LCD_puts_f>
 698:	8c e2       	ldi	r24, 0x2C	; 44
 69a:	91 e0       	ldi	r25, 0x01	; 1
 69c:	0e 94 07 03 	call	0x60e	; 0x60e <Delay10ms>
 6a0:	08 95       	ret

000006a2 <main>:
 6a2:	0f 93       	push	r16
 6a4:	1f 93       	push	r17
 6a6:	cf 93       	push	r28
 6a8:	df 93       	push	r29
 6aa:	80 e8       	ldi	r24, 0x80	; 128
 6ac:	80 bf       	out	0x30, r24	; 48
 6ae:	87 e0       	ldi	r24, 0x07	; 7
 6b0:	80 93 64 00 	sts	0x0064, r24
 6b4:	6e 98       	cbi	0x0d, 6	; 13
 6b6:	76 9a       	sbi	0x0e, 6	; 14
 6b8:	25 9a       	sbi	0x04, 5	; 4
 6ba:	0e 94 3b 01 	call	0x276	; 0x276 <Joystick_Init>
 6be:	78 94       	sei
 6c0:	8f e0       	ldi	r24, 0x0F	; 15
 6c2:	80 93 e7 00 	sts	0x00E7, r24
 6c6:	87 eb       	ldi	r24, 0xB7	; 183
 6c8:	80 93 e5 00 	sts	0x00E5, r24
 6cc:	83 e0       	ldi	r24, 0x03	; 3
 6ce:	80 93 e6 00 	sts	0x00E6, r24
 6d2:	18 ec       	ldi	r17, 0xC8	; 200
 6d4:	10 93 e4 00 	sts	0x00E4, r17
 6d8:	8d e9       	ldi	r24, 0x9D	; 157
 6da:	90 e0       	ldi	r25, 0x00	; 0
 6dc:	0e 94 1f 03 	call	0x63e	; 0x63e <LCD_puts_f>
 6e0:	88 ec       	ldi	r24, 0xC8	; 200
 6e2:	90 e0       	ldi	r25, 0x00	; 0
 6e4:	0e 94 07 03 	call	0x60e	; 0x60e <Delay10ms>
 6e8:	e1 e7       	ldi	r30, 0x71	; 113
 6ea:	f0 e0       	ldi	r31, 0x00	; 0
 6ec:	85 91       	lpm	r24, Z+
 6ee:	94 91       	lpm	r25, Z
 6f0:	0e 94 1f 03 	call	0x63e	; 0x63e <LCD_puts_f>
 6f4:	10 93 00 01 	sts	0x0100, r17
 6f8:	84 e1       	ldi	r24, 0x14	; 20
 6fa:	80 93 03 01 	sts	0x0103, r24
 6fe:	c0 e0       	ldi	r28, 0x00	; 0
 700:	d0 e0       	ldi	r29, 0x00	; 0
 702:	60 91 03 01 	lds	r22, 0x0103
 706:	9e 01       	movw	r18, r28
 708:	22 0f       	add	r18, r18
 70a:	22 0f       	add	r18, r18
 70c:	22 0f       	add	r18, r18
 70e:	82 2f       	mov	r24, r18
 710:	8c 59       	subi	r24, 0x9C	; 156
 712:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <PlayTone>
 716:	8a e0       	ldi	r24, 0x0A	; 10
 718:	90 e0       	ldi	r25, 0x00	; 0
 71a:	0e 94 07 03 	call	0x60e	; 0x60e <Delay10ms>
 71e:	21 96       	adiw	r28, 0x01	; 1
 720:	c5 30       	cpi	r28, 0x05	; 5
 722:	d1 05       	cpc	r29, r1
 724:	71 f7       	brne	.-36     	; 0x702 <main+0x60>
 726:	00 e0       	ldi	r16, 0x00	; 0
 728:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <getkey>
 72c:	18 2f       	mov	r17, r24
 72e:	88 23       	and	r24, r24
 730:	d9 f3       	breq	.-10     	; 0x728 <main+0x86>
 732:	66 e0       	ldi	r22, 0x06	; 6
 734:	84 e6       	ldi	r24, 0x64	; 100
 736:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <PlayTone>
 73a:	14 30       	cpi	r17, 0x04	; 4
 73c:	31 f4       	brne	.+12     	; 0x74a <main+0xa8>
 73e:	00 23       	and	r16, r16
 740:	11 f4       	brne	.+4      	; 0x746 <main+0xa4>
 742:	02 e0       	ldi	r16, 0x02	; 2
 744:	1b c0       	rjmp	.+54     	; 0x77c <main+0xda>
 746:	01 50       	subi	r16, 0x01	; 1
 748:	19 c0       	rjmp	.+50     	; 0x77c <main+0xda>
 74a:	15 30       	cpi	r17, 0x05	; 5
 74c:	31 f4       	brne	.+12     	; 0x75a <main+0xb8>
 74e:	02 30       	cpi	r16, 0x02	; 2
 750:	11 f4       	brne	.+4      	; 0x756 <main+0xb4>
 752:	00 e0       	ldi	r16, 0x00	; 0
 754:	13 c0       	rjmp	.+38     	; 0x77c <main+0xda>
 756:	0f 5f       	subi	r16, 0xFF	; 255
 758:	11 c0       	rjmp	.+34     	; 0x77c <main+0xda>
 75a:	11 30       	cpi	r17, 0x01	; 1
 75c:	59 f4       	brne	.+22     	; 0x774 <main+0xd2>
 75e:	e0 2f       	mov	r30, r16
 760:	ff 27       	eor	r31, r31
 762:	ee 0f       	add	r30, r30
 764:	ff 1f       	adc	r31, r31
 766:	e9 58       	subi	r30, 0x89	; 137
 768:	ff 4f       	sbci	r31, 0xFF	; 255
 76a:	85 91       	lpm	r24, Z+
 76c:	94 91       	lpm	r25, Z
 76e:	fc 01       	movw	r30, r24
 770:	09 95       	icall
 772:	04 c0       	rjmp	.+8      	; 0x77c <main+0xda>
 774:	13 30       	cpi	r17, 0x03	; 3
 776:	11 f4       	brne	.+4      	; 0x77c <main+0xda>
 778:	0e 94 48 03 	call	0x690	; 0x690 <MAIN_TopMenu>
 77c:	e0 2f       	mov	r30, r16
 77e:	ff 27       	eor	r31, r31
 780:	ee 0f       	add	r30, r30
 782:	ff 1f       	adc	r31, r31
 784:	ef 58       	subi	r30, 0x8F	; 143
 786:	ff 4f       	sbci	r31, 0xFF	; 255
 788:	85 91       	lpm	r24, Z+
 78a:	94 91       	lpm	r25, Z
 78c:	0e 94 1f 03 	call	0x63e	; 0x63e <LCD_puts_f>
 790:	cb cf       	rjmp	.-106    	; 0x728 <main+0x86>

00000792 <strcpy_P>:
 792:	fb 01       	movw	r30, r22
 794:	dc 01       	movw	r26, r24
 796:	05 90       	lpm	r0, Z+
 798:	0d 92       	st	X+, r0
 79a:	00 20       	and	r0, r0
 79c:	e1 f7       	brne	.-8      	; 0x796 <strcpy_P+0x4>
 79e:	08 95       	ret

000007a0 <_exit>:
 7a0:	ff cf       	rjmp	.-2      	; 0x7a0 <_exit>
