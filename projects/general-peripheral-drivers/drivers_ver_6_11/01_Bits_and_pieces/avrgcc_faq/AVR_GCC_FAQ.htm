<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0078)http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html -->
<HTML><HEAD><TITLE>Frequently Asked Questions</TITLE>
<META http-equiv=Content-Type content=text/html;charset=iso-8859-1><LINK 
href="AVR_GCC_FAQ_files/dox.css" type=text/css rel=stylesheet>
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY><!-- Generated by Doxygen 1.2.18 -->
<H1><A name=FAQ>Frequently Asked Questions</A> </H1>
<P><B>
<H3><A name=faq_index>FAQ Index</A> </H3></B>
<P>
<OL>
  <LI><A 
  href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_volatile">My 
  program doesn't recognize a variable updated within an interrupt routine</A>
  <LI><A 
  href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_libm">I 
  get "undefined reference to..." for functions like "sin()"</A>
  <LI><A 
  href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_regbind">How 
  to permanently bind a variable to a register?</A>
  <LI><A 
  href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_startup">How 
  to modify MCUCR or WDTCR early?</A>
  <LI><A 
  href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_use_bv">What 
  is all this _BV() stuff about?</A>
  <LI><A 
  href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_cplusplus">Can 
  I use C++ on the AVR?</A>
  <LI><A 
  href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_varinit">Shouldn't 
  I initialize all my variables?</A>
  <LI><A 
  href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_16bitio">Why 
  do some 16-bit timer registers sometimes get trashed?</A>
  <LI><A 
  href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_asmconst">How 
  do I use a #define'd constant in an asm statement?</A>
  <LI><A 
  href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_gdboptimize">Why 
  does the PC randomly jump around when single-stepping through my program in 
  avr-gdb?</A>
  <LI><A 
  href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_asmstabs">How 
  do I trace an assembler file in avr-gdb?</A>
  <LI><A 
  href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_port_pass">How 
  do I pass an IO port as a parameter to a function?</A>
  <LI><A 
  href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_reg_usage">What 
  registers are used by the C compiler?</A></LI></OL><B>
<H3><A name=faq_volatile>My program doesn't recognize a variable updated within 
an interrupt routine</A> </H3></B>
<P>When using the optimizer, in a loop like the following one: 
<P>
<DIV class=fragment><PRE>uint8_t flag;
...

        <SPAN class=keywordflow>while</SPAN> (flag == 0) {
                ...
        }
</PRE></DIV>
<P>the compiler will typically optimize the access to <CODE>flag</CODE> 
completely away, since its code path analysis shows that nothing inside the loop 
could change the value of <CODE>flag</CODE> anyway. To tell the compiler that 
this variable could be changed outside the scope of its code path analysis (e. 
g. from within an interrupt routine), the variable needs to be declared like: 
<P>
<DIV class=fragment><PRE><SPAN class=keyword>volatile</SPAN> uint8_t flag;
</PRE></DIV>
<P><SMALL>Back to <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_index">FAQ 
Index</A>. </SMALL>
<P><B>
<H3><A name=faq_libm>I get "undefined reference to..." for functions like 
"sin()"</A> </H3></B>
<P>In order to access the mathematical functions that are declared in 
<CODE>&lt;math.h&gt;</CODE>, the linker needs to be told to also link the 
mathematical library, <CODE>libm.a</CODE>. 
<P>Typically, system libraries like <CODE>libm.a</CODE> are given to the final C 
compiler command line that performs the linking step by adding a flag 
<CODE>-lm</CODE> at the end. (That is, the initial <EM>lib</EM> and the filename 
suffix from the library are written immediately after a <EM>-l</EM> flag. So for 
a <CODE>libfoo.a</CODE> library, <CODE>-lfoo</CODE> needs to be provided.) This 
will make the linker search the library in a path known to the system. 
<P>An alternative would be to specify the full path to the <CODE>libm.a</CODE> 
file at the same place on the command line, i. e. <EM>after</EM> all the object 
files (<CODE>*.o</CODE>). However, since this requires knowledge of where the 
build system will exactly find those library files, this is deprecated for 
system libraries. 
<P><SMALL>Back to <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_index">FAQ 
Index</A>. </SMALL>
<P><B>
<H3><A name=faq_regbind>How to permanently bind a variable to a register?</A> 
</H3></B>
<P>This can be done with 
<P>
<DIV class=fragment><PRE><SPAN class=keyword>register</SPAN> <SPAN class=keywordtype>unsigned</SPAN> <SPAN class=keywordtype>char</SPAN> counter <SPAN class=keyword>asm</SPAN>(<SPAN class=stringliteral>"r3"</SPAN>);
</PRE></DIV>
<P>See <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/inline_asm.html#c_names_in_asm">C 
Names Used in Assembler Code</A> for more details. 
<P><SMALL>Back to <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_index">FAQ 
Index</A>. </SMALL>
<P><B>
<H3><A name=faq_startup>How to modify MCUCR or WDTCR early?</A> </H3></B>
<P>The method of early initialization (<CODE>MCUCR</CODE>, <CODE>WDTCR</CODE> or 
anything else) is different (and more flexible) in the current version. 
Basically, write a small assembler file which looks like this: 
<P>
<DIV class=fragment><PRE>;; begin xram.S

<SPAN class=preprocessor>#include &lt;avr/io.h&gt;</SPAN>

        .section .init1,<SPAN class=stringliteral>"ax"</SPAN>,@progbits

        ldi r16,<A class=code href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/group__avr__sfr.html#a0">_BV</A>(SRE) | <A class=code href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/group__avr__sfr.html#a0">_BV</A>(SRW)
        out _SFR_IO_ADDR(MCUCR),r16

;; end xram.S
</PRE></DIV>
<P>Assemble it, link the resulting <CODE>xram.o</CODE> with other files in your 
program, and this piece of code will be inserted in initialization code, which 
is run right after reset. See the linker script for comments about the new 
<CODE>.init</CODE><EM>N</EM> sections (which one to use, etc.). 
<P>The advantage of this method is that you can insert any initialization code 
you want (just remember that this is very early startup -- no stack and no 
<CODE>__zero_reg__</CODE> yet), and no program memory space is wasted if this 
feature is not used. 
<P>There should be no need to modify linker scripts anymore, except for some 
very special cases. It is best to leave <CODE>__stack</CODE> at its default 
value (end of internal SRAM -- faster, and required on some devices like 
ATmega161 because of errata), and add <CODE>-Wl,-Tdata,0x801100</CODE> to start 
the data section above the stack. 
<P>For more information on using sections, including how to use them from C 
code, see <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/mem_sections.html#mem_sections">Memory 
Sections</A>. 
<P><SMALL>Back to <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_index">FAQ 
Index</A>. </SMALL>
<P><B>
<H3><A name=faq_use_bv>What is all this _BV() stuff about?</A> </H3></B>
<P>When performing low-level output work, which is a very central point in 
microcontroller programming, it is quite common that a particular bit needs to 
be set or cleared in some IO register. While the device documentation provides 
mnemonic names for the various bits in the IO registers, and the <A class=el 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/group__avr__io.html">AVR 
device-specific IO definitions</A> reflect these names in definitions for 
numerical constants, a way is needed to convert a bit number (usually within a 
byte register) into a byte value that can be assigned directly to the register. 
However, sometimes the direct bit numbers are needed as well (e. g. in an 
<CODE><A class=el 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/group__avr__sfr.html#a6">sbi()</A></CODE> 
call), so the definitions cannot usefully be made as byte values in the first 
place. 
<P>So in order to access a particular bit number as a byte value, use the 
<CODE><A class=el 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/group__avr__sfr.html#a0">_BV()</A></CODE> 
macro. Of course, the implementation of this macro is just the usual bit shift 
(which is done by the compiler anyway, thus doesn't impose any run-time 
penalty), so the following applies: 
<P>
<DIV class=fragment><PRE><A class=code href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/group__avr__sfr.html#a0">_BV</A>(3) =&gt; 1 &lt;&lt; 3 =&gt; 0x08
</PRE></DIV>
<P>However, using the macro often makes the program better readable. 
<P>"BV" stands for "bit value", in case someone might ask you. :-) 
<P><B>Example:</B> clock timer 2 with full IO clock (<CODE>CS2</CODE><EM>x</EM> 
= 0b001), toggle OC2 output on compare match (<CODE>COM2</CODE><EM>x</EM> = 
0b01), and clear timer on compare match (<CODE>CTC2</CODE> = 1). Make OC2 
(<CODE>PD7</CODE>) an output. 
<P>
<DIV class=fragment><PRE>        TCCR2 = <A class=code href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/group__avr__sfr.html#a0">_BV</A>(COM20)|<A class=code href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/group__avr__sfr.html#a0">_BV</A>(CTC2)|<A class=code href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/group__avr__sfr.html#a0">_BV</A>(CS20);
        DDRD = <A class=code href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/group__avr__sfr.html#a0">_BV</A>(PD7);
</PRE></DIV>
<P><SMALL>Back to <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_index">FAQ 
Index</A>. </SMALL>
<P><B>
<H3><A name=faq_cplusplus>Can I use C++ on the AVR?</A> </H3></B>
<P>Basically yes, C++ is supported (assuming your compiler has been configured 
and compiled to support it, of course). Source files ending in .<CODE>cc</CODE>, 
.<CODE>cpp</CODE> or .<CODE>C</CODE> will automatically cause the compiler 
frontend to invoke the C++ compiler. Alternatively, the C++ compiler could be 
explicitly called by the name <CODE>avr-c++</CODE>. 
<P>However, there's currently no support for <CODE>libstdc++</CODE>, the 
standard support library needed for a complete C++ implementation. This imposes 
a number of restrictions on the C++ programs that can be compiled. Among them 
are: 
<P>
<UL>
  <LI>Obviously, none of the C++ related standard functions, classes, and 
  template classes are available.</LI></UL>
<UL>
  <LI>The operators <CODE>new</CODE> and <CODE>delete</CODE> are not 
  implemented, attempting to use them will cause the linker to complain about 
  undefined external references. (This could perhaps be fixed.)</LI></UL>
<UL>
  <LI>Some of the supplied include files are not C++ safe, i. e. they need to be 
  wrapped into 
  <DIV class=fragment><PRE><SPAN class=keyword>extern</SPAN> <SPAN class=stringliteral>"C"</SPAN> { . . . } 
</PRE></DIV>(This could certainly be fixed, too.)</LI></UL>
<UL>
  <LI>Exceptions are not supported. Since exceptions are enabled by default in 
  the C++ frontend, they explicitly need to be turned off using 
  <CODE>-fno-exceptions</CODE> in the compiler options. Failing this, the linker 
  will complain about an undefined external reference to 
  <CODE>__gxx_personality_sj0</CODE>.</LI></UL>Constructors and destructors 
<EM>are</EM> supported though, including global ones. 
<P>When programming C++ in space- and runtime-sensitive environments like 
microcontrollers, extra care should be taken to avoid unwanted side effects of 
the C++ calling conventions like implied copy constructors that could be called 
upon function invocation etc. These things could easily add up into a 
considerable amount of time and program memory wasted. Thus, casual inspection 
of the generated assembler code (using the <CODE>-S</CODE> compiler option) 
seems to be warranted. 
<P><SMALL>Back to <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_index">FAQ 
Index</A>. </SMALL>
<P><B>
<H3><A name=faq_varinit>Shouldn't I initialize all my variables?</A> </H3></B>
<P>Global and static variables are guaranteed to be initialized to 0 by the C 
standard. <CODE>avr-gcc</CODE> does this by placing the appropriate code into 
section .<CODE>init4</CODE> (see <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/mem_sections.html#sec_dot_init">The 
.initN Sections</A>). With respect to the standard, this sentence is somewhat 
simplified (because the standard allows for machines where the actual bit 
pattern used differs from all bits being 0), but for the AVR target, in general, 
all integer-type variables are set to 0, all pointers to a NULL pointer, and all 
floating-point variables to 0.0. 
<P>As long as these variables are not initialized (i. e. they don't have an 
equal sign and an initialization expression to the right within the definition 
of the variable), they go into the <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/mem_sections.html#sec_dot_bss">.bss</A> 
section of the file. This section simply records the size of the variable, but 
otherwise doesn't consume space, neither within the object file nor within flash 
memory. (Of course, being a variable, it will consume space in the target's 
SRAM.) 
<P>In contrast, global and static variables that have an initializer go into the 
<A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/mem_sections.html#sec_dot_data">.data</A> 
section of the file. This will cause them to consume space in the object file 
(in order to record the initializing value), <EM>and</EM> in the flash ROM of 
the target device. The latter is needed since the flash ROM is the only way that 
the compiler can tell the target device the value this variable is going to be 
initialized to. 
<P>Now if some programmer "wants to make doubly sure" their variables really get 
a 0 at program startup, and adds an initializer just containing 0 on the 
right-hand side, they waste space. While this waste of space applies to 
virtually any platform C is implemented on, it's usually not noticeable on 
larger machines like PCs, while the waste of flash ROM storage can be very 
painful on a small microcontroller like the AVR. 
<P>So in general, variables should only be explicitly initialized if the initial 
value is non-zero. 
<P><SMALL>Back to <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_index">FAQ 
Index</A>. </SMALL>
<P><B>
<H3><A name=faq_16bitio>Why do some 16-bit timer registers sometimes get 
trashed?</A> </H3></B>
<P>Some of the timer-related 16-bit IO registers use a temporary register 
(called TEMP in the Atmel datasheet) to guarantee an atomic access to the 
register despite the fact that two separate 8-bit IO transfers are required to 
actually move the data. Typically, this includes access to the current 
timer/counter value register (<CODE>TCNT</CODE><EM>n</EM>), the input capture 
register (<CODE>ICR</CODE><EM>n</EM>), and write access to the output compare 
registers (<CODE>OCR</CODE><EM>nM</EM>). Refer to the actual datasheet for each 
device's set of registers that involves the TEMP register. 
<P>When accessing one of the registers that use TEMP from the main application, 
and possibly any other one from within an interrupt routine, care must be taken 
that no access from within an interrupt context could clobber the TEMP register 
data of an in-progress transaction that has just started elsewhere. 
<P>To protect interrupt routines against other interrupt routines, it's usually 
best to use the <A class=el 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/group__avr__interrupts.html#a4">SIGNAL()</A> 
macro when declaring the interrupt function, and to ensure that interrupts are 
still disabled when accessing those 16-bit timer registers. 
<P>Within the main program, access to those registers could be encapsulated in 
calls to the <A class=el 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/group__avr__interrupts.html#a3">cli()</A> 
and <A class=el 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/group__avr__interrupts.html#a2">sei()</A> 
macros. If the status of the global interrupt flag before accessing one of those 
registers is uncertain, something like the following example code can be used. 
<P>
<DIV class=fragment><PRE>uint16_t
read_timer1(<SPAN class=keywordtype>void</SPAN>)
{
        uint8_t sreg;
        uint16_t val;

        sreg = SREG;
        <A class=code href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/group__avr__interrupts.html#a3">cli</A>();
        val = TCNT1;
        SREG = sreg;

        <SPAN class=keywordflow>return</SPAN> val;
}
</PRE></DIV>
<P><SMALL>Back to <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_index">FAQ 
Index</A>. </SMALL>
<P><B>
<H3><A name=faq_asmconst>How do I use a #define'd constant in an asm 
statement?</A> </H3></B>
<P>So you tried this: 
<P>
<DIV class=fragment><PRE><SPAN class=keyword>asm</SPAN> <SPAN class=keyword>volatile</SPAN>(<SPAN class=stringliteral>"sbi 0x18,0x07;"</SPAN>);
</PRE></DIV>
<P>Which works. When you do the same thing but replace the address of the port 
by its macro name, like this: 
<P>
<DIV class=fragment><PRE><SPAN class=keyword>asm</SPAN> <SPAN class=keyword>volatile</SPAN>(<SPAN class=stringliteral>"sbi PORTB,0x07;"</SPAN>);
</PRE></DIV>
<P>you get a compilation error: <CODE>"Error: constant value required"</CODE>. 
<P><CODE>PORTB</CODE> is a precompiler definition included in the processor 
specific file included in <CODE>avr/io.h</CODE>. As you may know, the 
precompiler will not touch strings and <CODE>PORTB</CODE>, instead of 
<CODE>0x18</CODE>, gets passed to the assembler. One way to avoid this problem 
is: 
<P>
<DIV class=fragment><PRE><SPAN class=keyword>asm</SPAN> <SPAN class=keyword>volatile</SPAN>(<SPAN class=stringliteral>"sbi %0, 0x07"</SPAN> : <SPAN class=stringliteral>"I"</SPAN> (PORTB):);
</PRE></DIV>
<P>
<DL compact>
  <DT><B>Note: </B>
  <DD><CODE>avr/io.h</CODE> already provides a <A class=el 
  href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/group__avr__sfr.html#a6">sbi()</A> 
  macro definition, which can be used in C programs.</DD></DL><SMALL>Back to <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_index">FAQ 
Index</A>. </SMALL>
<P><B>
<H3><A name=faq_gdboptimize>Why does the PC randomly jump around when 
single-stepping through my program in avr-gdb?</A> </H3></B>
<P>When compiling a program with both optimization (<CODE>-O)</CODE> and debug 
information (<CODE>-g)</CODE> which is fortunately possible in 
<CODE>avr-gcc</CODE>, the code watched in the debugger is optimized code. While 
it is not guaranteed, very often this code runs with the exact same 
optimizations as it would run without the <CODE>-g</CODE> switch. 
<P>This can have unwanted side effects. Since the compiler is free to reorder 
code execution as long as the semantics do not change, code is often rearranged 
in order to make it possible to use a single branch instruction for conditional 
operations. Branch instructions can only cover a short range for the target PC 
(-63 through +64 words from the current PC). If a branch instruction cannot be 
used directly, the compiler needs to work around it by combining a skip 
instruction together with a relative jump (<CODE>rjmp)</CODE> instruction, which 
will need one additional word of ROM. 
<P>Another side effect of optimzation is that variable usage is restricted to 
the area of code where it is actually used. So if a variable was placed in a 
register at the beginning of some function, this same register can be re-used 
later on if the compiler notices that the first variable is no longer used 
inside that function, even though the variable is still in lexical scope. When 
trying to examine the variable in <CODE>avr-gdb</CODE>, the displayed result 
will then look garbled. 
<P>So in order to avoid these side effects, optimization can be turned off while 
debugging. However, some of these optimizations might also have the side effect 
of uncovering bugs that would otherwise not be obvious, so it must be noted that 
turning off optimization can easily change the bug pattern. In most cases, you 
are better off leaving optimizations enabled while debugging. 
<P><SMALL>Back to <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_index">FAQ 
Index</A>. </SMALL>
<P><B>
<H3><A name=faq_asmstabs>How do I trace an assembler file in avr-gdb?</A> 
</H3></B>
<P>When using the <CODE>-g</CODE> compiler option, <CODE>avr-gcc</CODE> only 
generates line number and other debug information for C (and C++) files that 
pass the compiler. Functions that don't have line number information will be 
completely skipped by a single <CODE>step</CODE> command in <CODE>gdb</CODE>. 
This includes functions linked from a standard library, but by default also 
functions defined in an assembler source file, since the <CODE>-g</CODE> 
compiler switch does not apply to the assembler. 
<P>So in order to debug an assembler input file (possibly one that has to be 
passed through the C preprocessor), it's the assembler that needs to be told to 
include line-number information into the output file. (Other debug information 
like data types and variable allocation cannot be generated, since unlike a 
compiler, the assembler basically doesn't know about this.) This is done using 
the (GNU) assembler option <CODE>--gstabs</CODE>. 
<P>Example: 
<P>
<DIV class=fragment><PRE>  $ avr-as -mmcu=atmega128 --gstabs -o foo.o foo.s
</PRE></DIV>
<P>When the assembler is not called directly but through the C compiler frontend 
(either implicitly by passing a source file ending in .<CODE>S</CODE>, or 
explicitly using <CODE>-x assembler-with-cpp</CODE>), the compiler frontend 
needs to be told to pass the <CODE>--gstabs</CODE> option down to the assembler. 
This is done using <CODE>-Wa,--gstabs</CODE>. Please take care to <EM>only</EM> 
pass this option when compiling an assembler input file. Otherwise, the 
assembler code that results from the C compilation stage will also get line 
number information, which confuses the debugger. 
<P>
<DL compact>
  <DT><B>Note: </B>
  <DD>You can also use <CODE>-Wa,-gstabs</CODE> since the compiler will add the 
  extra '<CODE>-</CODE>' for you.</DD></DL>Example: 
<P>
<DIV class=fragment><PRE>  $ EXTRA_OPTS="-Wall -mmcu=atmega128 -x assembler-with-cpp"
  $ avr-gcc -Wa,--gstabs ${EXTRA_OPTS} -c -o foo.o foo.S
</PRE></DIV>
<P>Also note that the debugger might get confused when entering a piece of code 
that has a non-local label before, since it then takes this label as the name of 
a new function that appears to have been entered. Thus, the best practice to 
avoid this confusion is to only use non-local labels when declaring a new 
function, and restrict anything else to local labels. Local labels consist just 
of a number only. References to these labels consist of the number, followed by 
the letter <B>b</B> for a backward reference, or <B>f</B> for a forward 
reference. These local labels may be re-used within the source file, references 
will pick the closest label with the same number and given direction. 
<P>Example: 
<P>
<DIV class=fragment><PRE>myfunc: push    r16
        push    r17
        push    r18
        push    YL
        push    YH
        ...
        eor     r16, r16        ; start loop
        ldi     YL, lo8(sometable)
        ldi     YH, hi8(sometable)
        rjmp    2f              ; jump to loop test at end
1:      ld      r17, Y+         ; loop continues here
        ...
        breq    1f              ; <SPAN class=keywordflow>return</SPAN> from myfunc prematurely
        ...
        inc     r16
2:      cmp     r16, r18
        brlo    1b              ; jump back to top of loop

1:      pop     YH
        pop     YL
        pop     r18
        pop     r17
        pop     r16
        ret
</PRE></DIV>
<P><SMALL>Back to <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_index">FAQ 
Index</A>. </SMALL>
<P>
<H3><A name=faq_port_pass>How do I pass an IO port as a parameter to a 
function?</A> </H3>Consider this example code: 
<P>
<DIV class=fragment><PRE><SPAN class=preprocessor>#include &lt;inttypes.h&gt;</SPAN>
<SPAN class=preprocessor>#include &lt;avr/io.h&gt;</SPAN>

<SPAN class=keywordtype>void</SPAN>
set_bits_func_wrong (<SPAN class=keyword>volatile</SPAN> uint8_t port, uint8_t mask)
{
    port |= mask;
}

<SPAN class=keywordtype>void</SPAN>
set_bits_func_correct (<SPAN class=keyword>volatile</SPAN> uint8_t *port, uint8_t mask)
{
    *port |= mask;
}

<SPAN class=preprocessor>#define set_bits_macro(port,mask) ((port) |= (mask))</SPAN>
<SPAN class=preprocessor></SPAN>
<SPAN class=keywordtype>int</SPAN> main (<SPAN class=keywordtype>void</SPAN>)
{
    set_bits_func_wrong (PORTB, 0xaa);
    set_bits_func_correct (&amp;PORTB, 0x55);
    set_bits_macro (PORTB, 0xf0);

    <SPAN class=keywordflow>return</SPAN> (0);
}
</PRE></DIV>
<P>The first function will generate object code which is not even close to what 
is intended. The major problem arises when the function is called. When the 
compiler sees this call, it will actually pass the value in the the 
<CODE>PORTB</CODE> register (using an <CODE>IN</CODE> instruction), instead of 
passing the address of <CODE>PORTB</CODE> (e.g. memory mapped io addr of 
<CODE>0x38</CODE>, io port <CODE>0x18</CODE> for the mega128). This is seen 
clearly when looking at the disassembly of the call: 
<P>
<DIV class=fragment><PRE>    set_bits_func_wrong (PORTB, 0xaa);
 10a:   6a ea           ldi     r22, 0xAA       ; 170
 10c:   88 b3           in      r24, 0x18       ; 24
 10e:   0e 94 65 00     call    0xca
</PRE></DIV>
<P>So, the function, once called, only sees the value of the port register and 
knows nothing about which port it came from. At this point, whatever object code 
is generated for the function by the compiler is irrelevant. The interested 
reader can examine the full disassembly to see the the function's body is 
completely fubar. 
<P>The second function shows how to pass (by reference) the memory mapped 
address of the io port to the function so that you can read and write to it in 
the function. Here's the object code generated for the function call: 
<P>
<DIV class=fragment><PRE>    set_bits_func_correct (&amp;PORTB, 0x55);
 112:   65 e5           ldi     r22, 0x55       ; 85
 114:   88 e3           ldi     r24, 0x38       ; 56
 116:   90 e0           ldi     r25, 0x00       ; 0
 118:   0e 94 7c 00     call    0xf8
</PRE></DIV>
<P>You can clearly see that <CODE>0x0038</CODE> is correctly passed for the 
address of the io port. Looking at the disassembled object code for the body of 
the function, we can see that the function is indeed performing the operation we 
intended: 
<P>
<DIV class=fragment><PRE>void
set_bits_func_correct (volatile uint8_t *port, uint8_t mask)
{
  f8:   fc 01           movw    r30, r24
    *port |= mask;
  fa:   80 81           ld      r24, Z
  fc:   86 2b           or      r24, r22
  fe:   80 83           st      Z, r24
}
 100:   08 95           ret 
</PRE></DIV>
<P>Notice that we are accessing the io port via the <CODE>LD</CODE> and 
<CODE>ST</CODE> instructions. 
<P>The <CODE>port</CODE> parameter must be volatile to avoid a compiler warning. 

<P>
<DL compact>
  <DT><B>Note: </B>
  <DD>Because of the nature of the <CODE>IN</CODE> and <CODE>OUT</CODE> assembly 
  instructions, they can not be used inside the function when passing the port 
  in this way. Readers interested in the details should consult the 
  <EM>Instruction Set</EM> data sheet.</DD></DL>Finally we come to the macro 
version of the operation. In this contrived example, the macro is the most 
efficient method with respect to both execution speed and code size: 
<P>
<DIV class=fragment><PRE>    set_bits_macro (PORTB, 0xf0);
 11c:   88 b3           in      r24, 0x18       ; 24
 11e:   80 6f           ori     r24, 0xF0       ; 240
 120:   88 bb           out     0x18, r24       ; 24
</PRE></DIV>
<P>Of course, in a real application, you might be doing a lot more in your 
function which uses a passed by reference io port address and thus the use of a 
function over a macro could save you some code space, but still at a cost of 
execution speed. 
<P><SMALL>Back to <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_index">FAQ 
Index</A>.</SMALL> 
<P>
<H3><A name=faq_reg_usage>What registers are used by the C compiler?</A> </H3>
<P>
<UL>
  <LI><B>Data types:</B><BR><CODE>char</CODE> is 8 bits, <CODE>int</CODE> is 16 
  bits, <CODE>long</CODE> is 32 bits, <CODE>long</CODE> long is 64 bits, 
  <CODE>float</CODE> and <CODE>double</CODE> are 32 bits (this is the only 
  supported floating point format), pointers are 16 bits (function pointers are 
  word addresses, to allow addressing the whole 128K program memory space on the 
  ATmega devices with &gt; 64 KB of flash ROM). There is a <CODE>-mint8</CODE> 
  option (see <A 
  href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/using_tools.html#using_avr_gcc">Options 
  for the C compiler avr-gcc</A>) to make <CODE>int</CODE> 8 bits, but that is 
  not supported by avr-libc and violates C standards (<CODE>int</CODE> 
  <EM>must</EM> be at least 16 bits). It may be removed in a future 
release.</LI></UL>
<UL>
  <LI><B>Call-used registers (r18-r27, r30-r31):</B><BR>May be allocated by gcc 
  for local data. You <EM>may</EM> use them freely in assembler subroutines. 
  Calling C subroutines can clobber any of them - the caller is responsible for 
  saving and restoring.</LI></UL>
<UL>
  <LI><B>Call-saved registers (r2-r17, r28-r29):</B><BR>May be allocated by gcc 
  for local data. Calling C subroutines leaves them unchanged. Assembler 
  subroutines are responsible for saving and restoring these registers, if 
  changed. r29:r28 (Y pointer) is used as a frame pointer (points to local data 
  on stack) if necessary.</LI></UL>
<UL>
  <LI><B>Fixed registers (r0, r1):</B><BR>Never allocated by gcc for local data, 
  but often used for fixed purposes: 
  <P>r0 - temporary register, can be clobbered by any C code (except interrupt 
  handlers which save it), <EM>may</EM> be used to remember something for a 
  while within one piece of assembler code 
  <P>r1 - assumed to be always zero in any C code, <EM>may</EM> be used to 
  remember something for a while within one piece of assembler code, but 
  <EM>must</EM> then be cleared after use (<CODE>clr r1</CODE>). This includes 
  any use of the <CODE>[f]mul[s[u]]</CODE> instructions, which return their 
  result in r1:r0. Interrupt handlers save and clear r1 on entry, and restore r1 
  on exit (in case it was non-zero). </P></LI></UL>
<UL>
  <LI><B>Function call conventions:</B><BR>Arguments - allocated left to right, 
  r25 to r8. All arguments are aligned to start in even-numbered registers 
  (odd-sized arguments, including <CODE>char</CODE>, have one free register 
  above them). This allows making better use of the <CODE>movw</CODE> 
  instruction on the enhanced core. 
  <P>If too many, those that don't fit are passed on the stack. 
  <P>Return values: 8-bit in r24 (not r25!), 16-bit in r25:r24, up to 32 bits in 
  r22-r25, up to 64 bits in r18-r25. 8-bit return values are zero/sign-extended 
  to 16 bits by the caller (<CODE>unsigned char</CODE> is more efficient than 
  <CODE>signed char</CODE> - just <CODE>clr r25</CODE>). Arguments to functions 
  with variable argument lists (printf etc.) are all passed on stack, and 
  <CODE>char</CODE> is extended to <CODE>int</CODE>. </P></LI></UL>
<DL compact>
  <DT><B>Warning: </B>
  <DD>There was no such alignment before 2000-07-01, including the old patches 
  for gcc-2.95.2. Check your old assembler subroutines, and adjust them 
  accordingly.</DD></DL><SMALL>Back to <A 
href="http://savannah.nongnu.org/download/avr-libc/doc/avr-libc-user-manual/FAQ.html#faq_index">FAQ 
Index</A>.</SMALL> 
<P>
<HR width="80%">

<P>
<CENTER>Automatically generated by Doxygen 1.2.18 on 12 Nov 2002.</CENTER>
<P></P></BODY></HTML>
