<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
  <title>@DOC_TITLE@</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>

<table width="100%" height="10%" bgcolor="#FFFFFF">
  <tr>
    <td colspan="2"><p><A href=http://www.atmel.com ><img src="atmel.jpg"/ border=0></A></p><br /></td>
    <td colspan="2"> <strong><font face="Helvetica" color="#000000" size="+3">Xmega Application Note</font></strong></td>
    <td colspan="2"><p><A href=http://www.atmel.com/products/AVR><img src="AVR_logo_blue.gif"/ border=0></A></p><br /></td>
  </tr>
  <tr>
    <td colspan="6" height="1" background="blue.gif"></td>
  </tr>
</table>
<!-- Generated by Doxygen 1.5.5 -->
<div class="contents">
<h1>eeprom_driver.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
XMEGA EEPROM driver source file. 
<p>
This file contains the function implementations for the XMEGA EEPROM driver.<p>
The driver is not intended for size and/or speed critical code, since most functions are just a few lines of code, and the function call overhead would decrease code performance. The driver is intended for rapid prototyping and documentation purposes for getting started with the XMEGA EEPROM module.<p>
For size and/or speed critical code, it is recommended to copy the function contents directly into your application instead of making a function call.<p>
<dl class="user" compact><dt><b>Application note:</b></dt><dd>AVR1315: Accessing the XMEGA EEPROM</dd></dl>
<dl class="user" compact><dt><b>Documentation</b></dt><dd>For comprehensive code documentation, supported compilers, compiler settings and supported devices see readme.html</dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Atmel Corporation: <a href="http://www.atmel.com">http://www.atmel.com</a> <br>
 Support email: <a href="mailto:avr@atmel.com">avr@atmel.com</a></dd></dl>
<dl class="rcs" compact><dt><b>Revision</b></dt><dd>1569 </dd></dl>
<dl class="rcs" compact><dt><b>Date</b></dt><dd>2008-04-22 13:03:43 +0200 (ti, 22 apr 2008) </dd></dl>
<br>
<p>
Copyright (c) 2008, Atmel Corporation All rights reserved.<p>
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
3. The name of ATMEL may not be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
<p>Definition in file <a class="el" href="eeprom__driver_8c-source.html">eeprom_driver.c</a>.</p>

<p>
<code>#include &quot;<a class="el" href="eeprom__driver_8h-source.html">eeprom_driver.h</a>&quot;</code><br>

<p>
<div class="dynheader">
Include dependency graph for eeprom_driver.c:</div>
<div class="dynsection">
<p><center><img src="eeprom__driver_8c__incl.png" border="0" usemap="#eeprom_driver.c_map" alt=""></center>
<map name="eeprom_driver.c_map">
<area shape="rect" href="eeprom__driver_8h.html" title="XMEGA EEPROM driver header file." alt="" coords="72,80,189,107"><area shape="rect" href="avr__compiler_8h.html" title="This file implements some macros that makes the IAR C&#45;compiler and avr&#45;gcc work with..." alt="" coords="76,155,185,181"></map>
</div>

<p>
<a href="eeprom__driver_8c-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#a95a711f0db0a957c7b0200d7a3da48b">EEPROM_AtomicWritePage</a> (uint8_t pageAddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write already loaded page into EEPROM.  <a href="#a95a711f0db0a957c7b0200d7a3da48b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#ce2c264aeffb8214c1cbf0269b8243e2">EEPROM_EraseAll</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase entire EEPROM memory.  <a href="#ce2c264aeffb8214c1cbf0269b8243e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#37cfa01aaf0f3951a5d65fc9c8f786ba">EEPROM_ErasePage</a> (uint8_t pageAddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase EEPROM page.  <a href="#37cfa01aaf0f3951a5d65fc9c8f786ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#11d41712860898672912ae4960a4cde7">EEPROM_FlushBuffer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush temporary EEPROM page buffer.  <a href="#11d41712860898672912ae4960a4cde7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#6417f17aaa15ca28b68b81f6751ee7ea">EEPROM_LoadByte</a> (uint8_t byteAddr, uint8_t value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load single byte into temporary page buffer.  <a href="#6417f17aaa15ca28b68b81f6751ee7ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#15832acf632fb92cc92c2ab14eb5d57a">EEPROM_LoadPage</a> (const uint8_t *values)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load entire page into temporary EEPROM page buffer.  <a href="#15832acf632fb92cc92c2ab14eb5d57a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#f728405f1c2399ed3ba4ab6d935ddae4">EEPROM_ReadByte</a> (uint8_t pageAddr, uint8_t byteAddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read one byte from EEPROM using IO mapping.  <a href="#f728405f1c2399ed3ba4ab6d935ddae4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#40ea1d62748d71221765b0b0cafd2f56">EEPROM_SplitWritePage</a> (uint8_t pageAddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write (without erasing) EEPROM page.  <a href="#40ea1d62748d71221765b0b0cafd2f56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5">EEPROM_WaitForNVM</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for any NVM access to finish, including EEPROM.  <a href="#5af1fa68cc2ab8d1e339ba2042fecbe5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#40b837a691492c4e56751386efeeac44">EEPROM_WriteByte</a> (uint8_t pageAddr, uint8_t byteAddr, uint8_t value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write one byte to EEPROM using IO mapping.  <a href="#40b837a691492c4e56751386efeeac44"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a95a711f0db0a957c7b0200d7a3da48b"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_AtomicWritePage" ref="a95a711f0db0a957c7b0200d7a3da48b" args="(uint8_t pageAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_AtomicWritePage           </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>pageAddr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write already loaded page into EEPROM. 
<p>
This function writes the contents of an already loaded EEPROM page buffer into EEPROM memory.<p>
As this is an atomic write, the page in EEPROM will be erased automatically before writing. Note that only the page buffer locations that have been loaded will be used when writing to EEPROM. Page buffer locations that have not been loaded will be left untouched in EEPROM.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pageAddr</em>&nbsp;</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="eeprom__driver_8c-source.html#l00245">245</a> of file <a class="el" href="eeprom__driver_8c-source.html">eeprom_driver.c</a>.</p>

<p>References <a class="el" href="eeprom__driver_8h-source.html#l00065">EEPROM_PAGESIZE</a>, <a class="el" href="eeprom__driver_8c-source.html#l00139">EEPROM_WaitForNVM()</a>, and <a class="el" href="eeprom__driver_8h-source.html#l00114">NVM_EXEC</a>.</p>

<p>Referenced by <a class="el" href="eeprom__example_8c-source.html#l00074">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00246"></a>00246 {
<a name="l00247"></a>00247         <span class="comment">/* Wait until NVM is not busy. */</span>
<a name="l00248"></a>00248         <a class="code" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM.">EEPROM_WaitForNVM</a>();
<a name="l00249"></a>00249 
<a name="l00250"></a>00250         <span class="comment">/* Calculate page address */</span>
<a name="l00251"></a>00251         uint16_t address = (uint16_t)(pageAddr*<a class="code" href="eeprom__driver_8h.html#31abeea8d51612a6d84704a0eeba9ace">EEPROM_PAGESIZE</a>);
<a name="l00252"></a>00252 
<a name="l00253"></a>00253         <span class="comment">/* Set address. */</span>
<a name="l00254"></a>00254         NVM.ADDR0 = address &amp; 0xFF;
<a name="l00255"></a>00255         NVM.ADDR1 = (address &gt;&gt; 8) &amp; 0x1F;
<a name="l00256"></a>00256         NVM.ADDR2 = 0x00;
<a name="l00257"></a>00257 
<a name="l00258"></a>00258         <span class="comment">/* Issue EEPROM Atomic Write (Erase&amp;Write) command. */</span>
<a name="l00259"></a>00259         NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
<a name="l00260"></a>00260         <a class="code" href="eeprom__driver_8h.html#01b4e293fa536307d215f8b9e9125537" title="Non-Volatile Memory Execute Command.">NVM_EXEC</a>();
<a name="l00261"></a>00261 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="eeprom__driver_8c_a95a711f0db0a957c7b0200d7a3da48b_cgraph.png" border="0" usemap="#eeprom__driver_8c_a95a711f0db0a957c7b0200d7a3da48b_cgraph_map" alt=""></center>
<map name="eeprom__driver_8c_a95a711f0db0a957c7b0200d7a3da48b_cgraph_map">
<area shape="rect" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM." alt="" coords="247,5,409,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="ce2c264aeffb8214c1cbf0269b8243e2"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_EraseAll" ref="ce2c264aeffb8214c1cbf0269b8243e2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_EraseAll           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase entire EEPROM memory. 
<p>
This function erases the entire EEPROM memory block to 0xFF. 
<p>Definition at line <a class="el" href="eeprom__driver_8c-source.html#l00321">321</a> of file <a class="el" href="eeprom__driver_8c-source.html">eeprom_driver.c</a>.</p>

<p>References <a class="el" href="eeprom__driver_8c-source.html#l00139">EEPROM_WaitForNVM()</a>, and <a class="el" href="eeprom__driver_8h-source.html#l00114">NVM_EXEC</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00322"></a>00322 {
<a name="l00323"></a>00323         <span class="comment">/* Wait until NVM is not busy. */</span>
<a name="l00324"></a>00324         <a class="code" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM.">EEPROM_WaitForNVM</a>();
<a name="l00325"></a>00325 
<a name="l00326"></a>00326         <span class="comment">/* Issue EEPROM Erase All command. */</span>
<a name="l00327"></a>00327         NVM.CMD = NVM_CMD_ERASE_EEPROM_gc;
<a name="l00328"></a>00328         <a class="code" href="eeprom__driver_8h.html#01b4e293fa536307d215f8b9e9125537" title="Non-Volatile Memory Execute Command.">NVM_EXEC</a>();
<a name="l00329"></a>00329 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="eeprom__driver_8c_ce2c264aeffb8214c1cbf0269b8243e2_cgraph.png" border="0" usemap="#eeprom__driver_8c_ce2c264aeffb8214c1cbf0269b8243e2_cgraph_map" alt=""></center>
<map name="eeprom__driver_8c_ce2c264aeffb8214c1cbf0269b8243e2_cgraph_map">
<area shape="rect" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM." alt="" coords="193,5,356,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="37cfa01aaf0f3951a5d65fc9c8f786ba"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_ErasePage" ref="37cfa01aaf0f3951a5d65fc9c8f786ba" args="(uint8_t pageAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_ErasePage           </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>pageAddr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase EEPROM page. 
<p>
This function erases one EEPROM page, so that every location reads 0xFF.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pageAddr</em>&nbsp;</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="eeprom__driver_8c-source.html#l00270">270</a> of file <a class="el" href="eeprom__driver_8c-source.html">eeprom_driver.c</a>.</p>

<p>References <a class="el" href="eeprom__driver_8h-source.html#l00065">EEPROM_PAGESIZE</a>, <a class="el" href="eeprom__driver_8c-source.html#l00139">EEPROM_WaitForNVM()</a>, and <a class="el" href="eeprom__driver_8h-source.html#l00114">NVM_EXEC</a>.</p>

<p>Referenced by <a class="el" href="eeprom__example_8c-source.html#l00074">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00271"></a>00271 {
<a name="l00272"></a>00272         <span class="comment">/* Wait until NVM is not busy. */</span>
<a name="l00273"></a>00273         <a class="code" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM.">EEPROM_WaitForNVM</a>();
<a name="l00274"></a>00274 
<a name="l00275"></a>00275         <span class="comment">/* Calculate page address */</span>
<a name="l00276"></a>00276         uint16_t address = (uint16_t)(pageAddr*<a class="code" href="eeprom__driver_8h.html#31abeea8d51612a6d84704a0eeba9ace">EEPROM_PAGESIZE</a>);
<a name="l00277"></a>00277 
<a name="l00278"></a>00278         <span class="comment">/* Set address. */</span>
<a name="l00279"></a>00279         NVM.ADDR0 = address &amp; 0xFF;
<a name="l00280"></a>00280         NVM.ADDR1 = (address &gt;&gt; 8) &amp; 0x1F;
<a name="l00281"></a>00281         NVM.ADDR2 = 0x00;
<a name="l00282"></a>00282 
<a name="l00283"></a>00283         <span class="comment">/* Issue EEPROM Erase command. */</span>
<a name="l00284"></a>00284         NVM.CMD = NVM_CMD_ERASE_EEPROM_PAGE_gc;
<a name="l00285"></a>00285         <a class="code" href="eeprom__driver_8h.html#01b4e293fa536307d215f8b9e9125537" title="Non-Volatile Memory Execute Command.">NVM_EXEC</a>();
<a name="l00286"></a>00286 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="eeprom__driver_8c_37cfa01aaf0f3951a5d65fc9c8f786ba_cgraph.png" border="0" usemap="#eeprom__driver_8c_37cfa01aaf0f3951a5d65fc9c8f786ba_cgraph_map" alt=""></center>
<map name="eeprom__driver_8c_37cfa01aaf0f3951a5d65fc9c8f786ba_cgraph_map">
<area shape="rect" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM." alt="" coords="209,5,372,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="11d41712860898672912ae4960a4cde7"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_FlushBuffer" ref="11d41712860898672912ae4960a4cde7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_FlushBuffer           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flush temporary EEPROM page buffer. 
<p>
This function flushes the EEPROM page buffers. This function will cancel any ongoing EEPROM page buffer loading operations, if any. This function also works for memory mapped EEPROM access.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The EEPROM write operations will automatically flush the buffer for you. </dd></dl>

<p>Definition at line <a class="el" href="eeprom__driver_8c-source.html#l00155">155</a> of file <a class="el" href="eeprom__driver_8c-source.html">eeprom_driver.c</a>.</p>

<p>References <a class="el" href="eeprom__driver_8c-source.html#l00139">EEPROM_WaitForNVM()</a>, and <a class="el" href="eeprom__driver_8h-source.html#l00114">NVM_EXEC</a>.</p>

<p>Referenced by <a class="el" href="eeprom__driver_8c-source.html#l00072">EEPROM_WriteByte()</a>, and <a class="el" href="eeprom__example_8c-source.html#l00074">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00156"></a>00156 {
<a name="l00157"></a>00157         <span class="comment">/* Wait until NVM is not busy. */</span>
<a name="l00158"></a>00158         <a class="code" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM.">EEPROM_WaitForNVM</a>();
<a name="l00159"></a>00159 
<a name="l00160"></a>00160         <span class="comment">/* Flush EEPROM page buffer if necessary. */</span>
<a name="l00161"></a>00161         <span class="keywordflow">if</span> ((NVM.STATUS &amp; NVM_EELOAD_bm) != 0) {
<a name="l00162"></a>00162                 NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
<a name="l00163"></a>00163                 <a class="code" href="eeprom__driver_8h.html#01b4e293fa536307d215f8b9e9125537" title="Non-Volatile Memory Execute Command.">NVM_EXEC</a>();
<a name="l00164"></a>00164         }
<a name="l00165"></a>00165 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="eeprom__driver_8c_11d41712860898672912ae4960a4cde7_cgraph.png" border="0" usemap="#eeprom__driver_8c_11d41712860898672912ae4960a4cde7_cgraph_map" alt=""></center>
<map name="eeprom__driver_8c_11d41712860898672912ae4960a4cde7_cgraph_map">
<area shape="rect" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM." alt="" coords="212,5,375,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="6417f17aaa15ca28b68b81f6751ee7ea"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_LoadByte" ref="6417f17aaa15ca28b68b81f6751ee7ea" args="(uint8_t byteAddr, uint8_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_LoadByte           </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>byteAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load single byte into temporary page buffer. 
<p>
This function loads one byte into the temporary EEPROM page buffers. If memory mapped EEPROM is enabled, this function will not work. Make sure that the buffer is flushed before starting to load bytes. Also, if multiple bytes are loaded into the same location, they will be ANDed together, thus 0x55 and 0xAA will result in 0x00 in the buffer.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Only one page buffer exist, thus only one page can be loaded with data and programmed into one page. If data needs to be written to different pages, the loading and writing needs to be repeated.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>byteAddr</em>&nbsp;</td><td>EEPROM Byte address, between 0 and EEPROM_PAGESIZE. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Byte value to write to buffer. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="eeprom__driver_8c-source.html#l00183">183</a> of file <a class="el" href="eeprom__driver_8c-source.html">eeprom_driver.c</a>.</p>

<p>References <a class="el" href="eeprom__driver_8c-source.html#l00139">EEPROM_WaitForNVM()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00184"></a>00184 {
<a name="l00185"></a>00185         <span class="comment">/* Wait until NVM is not busy and prepare NVM command.*/</span>
<a name="l00186"></a>00186         <a class="code" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM.">EEPROM_WaitForNVM</a>();
<a name="l00187"></a>00187         NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189         <span class="comment">/* Set address. */</span>
<a name="l00190"></a>00190         NVM.ADDR0 = byteAddr &amp; 0xFF;
<a name="l00191"></a>00191         NVM.ADDR1 = 0x00;
<a name="l00192"></a>00192         NVM.ADDR2 = 0x00;
<a name="l00193"></a>00193 
<a name="l00194"></a>00194         <span class="comment">/* Set data, which triggers loading of EEPROM page buffer. */</span>
<a name="l00195"></a>00195         NVM.DATA0 = value;
<a name="l00196"></a>00196 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="eeprom__driver_8c_6417f17aaa15ca28b68b81f6751ee7ea_cgraph.png" border="0" usemap="#eeprom__driver_8c_6417f17aaa15ca28b68b81f6751ee7ea_cgraph_map" alt=""></center>
<map name="eeprom__driver_8c_6417f17aaa15ca28b68b81f6751ee7ea_cgraph_map">
<area shape="rect" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM." alt="" coords="199,5,361,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="15832acf632fb92cc92c2ab14eb5d57a"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_LoadPage" ref="15832acf632fb92cc92c2ab14eb5d57a" args="(const uint8_t *values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_LoadPage           </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>values</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load entire page into temporary EEPROM page buffer. 
<p>
This function loads an entire EEPROM page from an SRAM buffer to the EEPROM page buffers. If memory mapped EEPROM is enabled, this function will not work. Make sure that the buffer is flushed before starting to load bytes.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Only the lower part of the address is used to address the buffer. Therefore, no address parameter is needed. In the end, the data is written to the EEPROM page given by the address parameter to the EEPROM write page operation.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>Pointer to SRAM buffer containing an entire page. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="eeprom__driver_8c-source.html#l00213">213</a> of file <a class="el" href="eeprom__driver_8c-source.html">eeprom_driver.c</a>.</p>

<p>References <a class="el" href="eeprom__driver_8h-source.html#l00065">EEPROM_PAGESIZE</a>, and <a class="el" href="eeprom__driver_8c-source.html#l00139">EEPROM_WaitForNVM()</a>.</p>

<p>Referenced by <a class="el" href="eeprom__example_8c-source.html#l00074">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00214"></a>00214 {
<a name="l00215"></a>00215         <span class="comment">/* Wait until NVM is not busy. */</span>
<a name="l00216"></a>00216         <a class="code" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM.">EEPROM_WaitForNVM</a>();
<a name="l00217"></a>00217         NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219         <span class="comment">/*  Set address to zero, as only the lower bits matters. ADDR0 is</span>
<a name="l00220"></a>00220 <span class="comment">         *  maintained inside the loop below.</span>
<a name="l00221"></a>00221 <span class="comment">         */</span>
<a name="l00222"></a>00222         NVM.ADDR1 = 0x00;
<a name="l00223"></a>00223         NVM.ADDR2 = 0x00;
<a name="l00224"></a>00224 
<a name="l00225"></a>00225         <span class="comment">/* Load multible bytes into page buffer. */</span>
<a name="l00226"></a>00226         <span class="keywordflow">for</span> (uint8_t i = 0; i &lt; <a class="code" href="eeprom__driver_8h.html#31abeea8d51612a6d84704a0eeba9ace">EEPROM_PAGESIZE</a>; ++i) {
<a name="l00227"></a>00227                 NVM.ADDR0 = i;
<a name="l00228"></a>00228                 NVM.DATA0 = *values;
<a name="l00229"></a>00229                 ++values;
<a name="l00230"></a>00230         }
<a name="l00231"></a>00231 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="eeprom__driver_8c_15832acf632fb92cc92c2ab14eb5d57a_cgraph.png" border="0" usemap="#eeprom__driver_8c_15832acf632fb92cc92c2ab14eb5d57a_cgraph_map" alt=""></center>
<map name="eeprom__driver_8c_15832acf632fb92cc92c2ab14eb5d57a_cgraph_map">
<area shape="rect" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM." alt="" coords="204,5,367,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="f728405f1c2399ed3ba4ab6d935ddae4"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_ReadByte" ref="f728405f1c2399ed3ba4ab6d935ddae4" args="(uint8_t pageAddr, uint8_t byteAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t EEPROM_ReadByte           </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>pageAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>byteAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read one byte from EEPROM using IO mapping. 
<p>
This function reads one byte from EEPROM using IO-mapped access. If memory mapped EEPROM is enabled, this function will not work.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pageAddr</em>&nbsp;</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteAddr</em>&nbsp;</td><td>EEPROM Byte address, between 0 and EEPROM_PAGESIZE.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Byte value read from EEPROM. </dd></dl>

<p>Definition at line <a class="el" href="eeprom__driver_8c-source.html#l00110">110</a> of file <a class="el" href="eeprom__driver_8c-source.html">eeprom_driver.c</a>.</p>

<p>References <a class="el" href="eeprom__driver_8h-source.html#l00065">EEPROM_PAGESIZE</a>, <a class="el" href="eeprom__driver_8c-source.html#l00139">EEPROM_WaitForNVM()</a>, and <a class="el" href="eeprom__driver_8h-source.html#l00114">NVM_EXEC</a>.</p>

<p>Referenced by <a class="el" href="eeprom__example_8c-source.html#l00074">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00111"></a>00111 {
<a name="l00112"></a>00112         <span class="comment">/* Wait until NVM is not busy. */</span>
<a name="l00113"></a>00113         <a class="code" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM.">EEPROM_WaitForNVM</a>();
<a name="l00114"></a>00114 
<a name="l00115"></a>00115         <span class="comment">/* Calculate address */</span>
<a name="l00116"></a>00116         uint16_t address = (uint16_t)(pageAddr*<a class="code" href="eeprom__driver_8h.html#31abeea8d51612a6d84704a0eeba9ace">EEPROM_PAGESIZE</a>)
<a name="l00117"></a>00117                                     |(byteAddr &amp; (EEPROM_PAGESIZE-1));
<a name="l00118"></a>00118 
<a name="l00119"></a>00119         <span class="comment">/* Set address to read from. */</span>
<a name="l00120"></a>00120         NVM.ADDR0 = address &amp; 0xFF;
<a name="l00121"></a>00121         NVM.ADDR1 = (address &gt;&gt; 8) &amp; 0x1F;
<a name="l00122"></a>00122         NVM.ADDR2 = 0x00;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124         <span class="comment">/* Issue EEPROM Read command. */</span>
<a name="l00125"></a>00125         NVM.CMD = NVM_CMD_READ_EEPROM_gc;
<a name="l00126"></a>00126         <a class="code" href="eeprom__driver_8h.html#01b4e293fa536307d215f8b9e9125537" title="Non-Volatile Memory Execute Command.">NVM_EXEC</a>();
<a name="l00127"></a>00127 
<a name="l00128"></a>00128         <span class="keywordflow">return</span> NVM.DATA0;
<a name="l00129"></a>00129 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="eeprom__driver_8c_f728405f1c2399ed3ba4ab6d935ddae4_cgraph.png" border="0" usemap="#eeprom__driver_8c_f728405f1c2399ed3ba4ab6d935ddae4_cgraph_map" alt=""></center>
<map name="eeprom__driver_8c_f728405f1c2399ed3ba4ab6d935ddae4_cgraph_map">
<area shape="rect" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM." alt="" coords="201,5,364,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="40ea1d62748d71221765b0b0cafd2f56"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_SplitWritePage" ref="40ea1d62748d71221765b0b0cafd2f56" args="(uint8_t pageAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_SplitWritePage           </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>pageAddr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write (without erasing) EEPROM page. 
<p>
This function writes the contents of an already loaded EEPROM page buffer into EEPROM memory.<p>
As this is a split write, the page in EEPROM will _not_ be erased before writing.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pageAddr</em>&nbsp;</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="eeprom__driver_8c-source.html#l00299">299</a> of file <a class="el" href="eeprom__driver_8c-source.html">eeprom_driver.c</a>.</p>

<p>References <a class="el" href="eeprom__driver_8h-source.html#l00065">EEPROM_PAGESIZE</a>, <a class="el" href="eeprom__driver_8c-source.html#l00139">EEPROM_WaitForNVM()</a>, and <a class="el" href="eeprom__driver_8h-source.html#l00114">NVM_EXEC</a>.</p>

<p>Referenced by <a class="el" href="eeprom__example_8c-source.html#l00074">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00300"></a>00300 {
<a name="l00301"></a>00301         <span class="comment">/* Wait until NVM is not busy. */</span>
<a name="l00302"></a>00302         <a class="code" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM.">EEPROM_WaitForNVM</a>();
<a name="l00303"></a>00303 
<a name="l00304"></a>00304         <span class="comment">/* Calculate page address */</span>
<a name="l00305"></a>00305         uint16_t address = (uint16_t)(pageAddr*<a class="code" href="eeprom__driver_8h.html#31abeea8d51612a6d84704a0eeba9ace">EEPROM_PAGESIZE</a>);
<a name="l00306"></a>00306 
<a name="l00307"></a>00307         <span class="comment">/* Set address. */</span>
<a name="l00308"></a>00308         NVM.ADDR0 = address &amp; 0xFF;
<a name="l00309"></a>00309         NVM.ADDR1 = (address &gt;&gt; 8) &amp; 0x1F;
<a name="l00310"></a>00310         NVM.ADDR2 = 0x00;
<a name="l00311"></a>00311 
<a name="l00312"></a>00312         <span class="comment">/* Issue EEPROM Split Write command. */</span>
<a name="l00313"></a>00313         NVM.CMD = NVM_CMD_WRITE_EEPROM_PAGE_gc;
<a name="l00314"></a>00314         <a class="code" href="eeprom__driver_8h.html#01b4e293fa536307d215f8b9e9125537" title="Non-Volatile Memory Execute Command.">NVM_EXEC</a>();
<a name="l00315"></a>00315 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="eeprom__driver_8c_40ea1d62748d71221765b0b0cafd2f56_cgraph.png" border="0" usemap="#eeprom__driver_8c_40ea1d62748d71221765b0b0cafd2f56_cgraph_map" alt=""></center>
<map name="eeprom__driver_8c_40ea1d62748d71221765b0b0cafd2f56_cgraph_map">
<area shape="rect" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM." alt="" coords="231,5,393,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="5af1fa68cc2ab8d1e339ba2042fecbe5"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_WaitForNVM" ref="5af1fa68cc2ab8d1e339ba2042fecbe5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_WaitForNVM           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for any NVM access to finish, including EEPROM. 
<p>
This function is blcoking and waits for any NVM access to finish, including EEPROM. Use this function before any EEPROM accesses, if you are not certain that any previous operations are finished yet, like an EEPROM write. 
<p>Definition at line <a class="el" href="eeprom__driver_8c-source.html#l00139">139</a> of file <a class="el" href="eeprom__driver_8c-source.html">eeprom_driver.c</a>.</p>

<p>Referenced by <a class="el" href="eeprom__driver_8c-source.html#l00245">EEPROM_AtomicWritePage()</a>, <a class="el" href="eeprom__driver_8c-source.html#l00321">EEPROM_EraseAll()</a>, <a class="el" href="eeprom__driver_8c-source.html#l00270">EEPROM_ErasePage()</a>, <a class="el" href="eeprom__driver_8c-source.html#l00155">EEPROM_FlushBuffer()</a>, <a class="el" href="eeprom__driver_8c-source.html#l00183">EEPROM_LoadByte()</a>, <a class="el" href="eeprom__driver_8c-source.html#l00213">EEPROM_LoadPage()</a>, <a class="el" href="eeprom__driver_8c-source.html#l00110">EEPROM_ReadByte()</a>, <a class="el" href="eeprom__driver_8c-source.html#l00299">EEPROM_SplitWritePage()</a>, and <a class="el" href="eeprom__example_8c-source.html#l00074">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00140"></a>00140 {
<a name="l00141"></a>00141         <span class="keywordflow">do</span> {
<a name="l00142"></a>00142                 <span class="comment">/* Block execution while waiting for the NVM to be ready. */</span>
<a name="l00143"></a>00143         } <span class="keywordflow">while</span> ((NVM.STATUS &amp; NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
<a name="l00144"></a>00144 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="40b837a691492c4e56751386efeeac44"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_WriteByte" ref="40b837a691492c4e56751386efeeac44" args="(uint8_t pageAddr, uint8_t byteAddr, uint8_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_WriteByte           </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>pageAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>byteAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write one byte to EEPROM using IO mapping. 
<p>
This function writes one byte to EEPROM using IO-mapped access. If memory mapped EEPROM is enabled, this function will not work. This functiom will cancel all ongoing EEPROM page buffer loading operations, if any.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pageAddr</em>&nbsp;</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteAddr</em>&nbsp;</td><td>EEPROM Byte address, between 0 and EEPROM_PAGESIZE. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Byte value to write to EEPROM. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="eeprom__driver_8c-source.html#l00072">72</a> of file <a class="el" href="eeprom__driver_8c-source.html">eeprom_driver.c</a>.</p>

<p>References <a class="el" href="eeprom__driver_8c-source.html#l00155">EEPROM_FlushBuffer()</a>, <a class="el" href="eeprom__driver_8h-source.html#l00065">EEPROM_PAGESIZE</a>, and <a class="el" href="eeprom__driver_8h-source.html#l00114">NVM_EXEC</a>.</p>

<p>Referenced by <a class="el" href="eeprom__example_8c-source.html#l00074">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00073"></a>00073 {
<a name="l00074"></a>00074         <span class="comment">/*  Flush buffer to make sure no unintetional data is written and load</span>
<a name="l00075"></a>00075 <span class="comment">         *  the "Page Load" command into the command register.</span>
<a name="l00076"></a>00076 <span class="comment">         */</span>
<a name="l00077"></a>00077         <a class="code" href="eeprom__driver_8c.html#11d41712860898672912ae4960a4cde7" title="Flush temporary EEPROM page buffer.">EEPROM_FlushBuffer</a>();
<a name="l00078"></a>00078         NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080         <span class="comment">/* Calculate address */</span>
<a name="l00081"></a>00081         uint16_t address = (uint16_t)(pageAddr*<a class="code" href="eeprom__driver_8h.html#31abeea8d51612a6d84704a0eeba9ace">EEPROM_PAGESIZE</a>)
<a name="l00082"></a>00082                                     |(byteAddr &amp; (EEPROM_PAGESIZE-1));
<a name="l00083"></a>00083 
<a name="l00084"></a>00084         <span class="comment">/* Set address to write to. */</span>
<a name="l00085"></a>00085         NVM.ADDR0 = address &amp; 0xFF;
<a name="l00086"></a>00086         NVM.ADDR1 = (address &gt;&gt; 8) &amp; 0x1F;
<a name="l00087"></a>00087         NVM.ADDR2 = 0x00;
<a name="l00088"></a>00088 
<a name="l00089"></a>00089         <span class="comment">/* Load data to write, which triggers the loading of EEPROM page buffer. */</span>
<a name="l00090"></a>00090         NVM.DATA0 = value;
<a name="l00091"></a>00091 
<a name="l00092"></a>00092         <span class="comment">/*  Issue EEPROM Atomic Write (Erase&amp;Write) command. Load command, write</span>
<a name="l00093"></a>00093 <span class="comment">         *  the protection signature and execute command.</span>
<a name="l00094"></a>00094 <span class="comment">         */</span>
<a name="l00095"></a>00095         NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
<a name="l00096"></a>00096         <a class="code" href="eeprom__driver_8h.html#01b4e293fa536307d215f8b9e9125537" title="Non-Volatile Memory Execute Command.">NVM_EXEC</a>();
<a name="l00097"></a>00097 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="eeprom__driver_8c_40b837a691492c4e56751386efeeac44_cgraph.png" border="0" usemap="#eeprom__driver_8c_40b837a691492c4e56751386efeeac44_cgraph_map" alt=""></center>
<map name="eeprom__driver_8c_40b837a691492c4e56751386efeeac44_cgraph_map">
<area shape="rect" href="eeprom__driver_8c.html#11d41712860898672912ae4960a4cde7" title="Flush temporary EEPROM page buffer." alt="" coords="201,5,356,32"><area shape="rect" href="eeprom__driver_8c.html#5af1fa68cc2ab8d1e339ba2042fecbe5" title="Wait for any NVM access to finish, including EEPROM." alt="" coords="407,5,569,32"></map>
</div>

</div>
</div><p>
</div>
<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
  <title>@DOC_TITLE@</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>

<table width="100%" height="10%" bgcolor="#FFFFFF">
  <tr>
    <td colspan="6" height="1" background="blue.gif"></td>
  </tr>

  <tr>
    <td colspan="6">
    <address style="align: right;"><small>
Generated on Wed Apr 23 08:27:39 2008 for AVR1315 Accessing the XMEGA EEPROM by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.5.5</small></address>
    </td>
  </tr>

</table>
