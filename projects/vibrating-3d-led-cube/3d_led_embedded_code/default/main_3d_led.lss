
main_3d_led.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000672  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  00000672  000006e6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000007  00800062  00000674  000006e8  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  000006e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000241  00000000  00000000  00000708  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000007df  00000000  00000000  00000949  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000169  00000000  00000000  00001128  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000457  00000000  00000000  00001291  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000060  00000000  00000000  000016e8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000002e6  00000000  00000000  00001748  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000354  00000000  00000000  00001a2e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000090  00000000  00000000  00001d82  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 18 01 	jmp	0x230	; 0x230 <__ctors_end>
   4:	0c 94 6c 01 	jmp	0x2d8	; 0x2d8 <__vector_1>
   8:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
   c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  10:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  14:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  18:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  1c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  20:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  24:	0c 94 4f 01 	jmp	0x29e	; 0x29e <__vector_9>
  28:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  2c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  30:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  34:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  38:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  3c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  40:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  44:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  48:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  4c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  50:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
  54:	a2 01       	movw	r20, r4
  56:	af 01       	movw	r20, r30
  58:	bc 01       	movw	r22, r24
  5a:	c9 01       	movw	r24, r18
  5c:	d6 01       	movw	r26, r12
  5e:	e3 01       	movw	r28, r6
  60:	f0 01       	movw	r30, r0
  62:	fd 01       	movw	r30, r26
  64:	0a 02       	muls	r16, r26
  66:	17 02       	muls	r17, r23
  68:	24 02       	muls	r18, r20
  6a:	31 02       	muls	r19, r17
  6c:	a6 02       	muls	r26, r22
  6e:	a6 02       	muls	r26, r22
  70:	a6 02       	muls	r26, r22
  72:	a6 02       	muls	r26, r22
  74:	a6 02       	muls	r26, r22
  76:	a6 02       	muls	r26, r22
  78:	a6 02       	muls	r26, r22
  7a:	a6 02       	muls	r26, r22
  7c:	3e 02       	muls	r19, r30
  7e:	4b 02       	muls	r20, r27
  80:	58 02       	muls	r21, r24
  82:	65 02       	muls	r22, r21
  84:	72 02       	muls	r23, r18
  86:	7f 02       	muls	r23, r31
  88:	8c 02       	muls	r24, r28
  8a:	99 02       	muls	r25, r25

0000008c <strWireFrameCube>:
  8c:	c0 9c 07 fe ee ff ef fe ee ff ef fe ee ff ef fe     ................
  9c:	c0 9c 07 fe                                         ....

000000a0 <strSingleWave1>:
  a0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
  b0:	00 00 00 00                                         ....

000000b4 <strSingleWave2>:
  b4:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff 0f fe     ................
  c4:	00 00 f0 ff                                         ....

000000c8 <strSingleWave3>:
  c8:	ff ff ff ff ff ff ff ff ff ff 0f fe ff fe f0 ff     ................
  d8:	00 01 ff ff                                         ....

000000dc <strSingleWave4>:
  dc:	ff ff ff ff ff ff 0f fe ff fe f0 ff ff c1 ff ff     ................
  ec:	00 3f ff ff                                         .?..

000000f0 <strSingleWave5>:
  f0:	ff ff 0f fe ff fe f0 ff ff c1 ff ff 1f 3f ff ff     .............?..
 100:	e0 ff ff ff                                         ....

00000104 <strSingleWave6>:
 104:	ff fe f0 ff ff c1 0f fe 1f 3f ff ff e0 ff ff ff     .........?......
 114:	ff ff ff ff                                         ....

00000118 <strSingleWave7>:
 118:	ff c1 ff ff 1f 3e f0 ff e0 ff 0f fe ff ff ff ff     .....>..........
 128:	ff ff ff ff                                         ....

0000012c <strSingleWave8>:
 12c:	1f 3f ff ff e0 c1 ff ff ff fe f0 ff ff ff 0f fe     .?..............
 13c:	ff ff ff ff                                         ....

00000140 <strSingleWave9>:
 140:	e0 ff ff ff 1f 3f ff ff ff c1 ff ff ff fe f0 ff     .....?..........
 150:	ff ff 0f fe                                         ....

00000154 <strSingleWave10>:
 154:	ff ff ff ff e0 ff ff ff 1f 3f ff ff ff c1 ff ff     .........?......
 164:	ff fe 00 fe                                         ....

00000168 <strSingleWave11>:
 168:	ff ff ff ff ff ff ff ff e0 ff ff ff 1f 3f ff ff     .............?..
 178:	ff c0 00 fe                                         ....

0000017c <strSingleWave12>:
 17c:	ff ff ff ff ff ff ff ff ff ff ff ff e0 ff ff ff     ................
 18c:	1f 00 00 fe                                         ....

00000190 <strHelix1>:
 190:	ff c1 ff ff ff a2 ff ff ef 77 ee ff 77 f7 dd ff     .........w..w...
 1a0:	7b f7 bd ff                                         {...

000001a4 <strHelix2>:
 1a4:	ff a2 ff ff ef 77 ee ff 77 f7 dd ff 7b f7 bd ff     .....w..w...{...
 1b4:	7d f7 7d ff                                         }.}.

000001b8 <strHelix3>:
 1b8:	ef 77 ee ff 77 f7 dd ff 7b f7 bd ff 7d f7 7d ff     .w..w...{...}.}.
 1c8:	be f7 fb fe                                         ....

000001cc <strHelix4>:
 1cc:	77 f7 dd ff 7b f7 bd ff 7d f7 7d ff be f7 fb fe     w...{...}.}.....
 1dc:	9f f7 f3 ff                                         ....

000001e0 <strHelix5>:
 1e0:	7b f7 bd ff 7d f7 7d ff be f7 fb fe 9f f7 f3 ff     {...}.}.........
 1f0:	ff c1 ff ff                                         ....

000001f4 <strHelix6>:
 1f4:	7d f7 7d ff be f7 fb fe 9f f7 f3 ff ff c1 ff ff     }.}.............
 204:	ff a2 ff ff                                         ....

00000208 <strHelix7>:
 208:	be f7 fb fe 9f f7 f3 ff ff c1 ff ff ff a2 ff ff     ................
 218:	ef 77 ee ff                                         .w..

0000021c <strHelix8>:
 21c:	9f f7 f3 ff ff c1 ff ff ff a2 ff ff ef 77 ee ff     .............w..
 22c:	77 f7 dd ff                                         w...

00000230 <__ctors_end>:
 230:	11 24       	eor	r1, r1
 232:	1f be       	out	0x3f, r1	; 63
 234:	cf e5       	ldi	r28, 0x5F	; 95
 236:	d4 e0       	ldi	r29, 0x04	; 4
 238:	de bf       	out	0x3e, r29	; 62
 23a:	cd bf       	out	0x3d, r28	; 61

0000023c <__do_copy_data>:
 23c:	10 e0       	ldi	r17, 0x00	; 0
 23e:	a0 e6       	ldi	r26, 0x60	; 96
 240:	b0 e0       	ldi	r27, 0x00	; 0
 242:	e2 e7       	ldi	r30, 0x72	; 114
 244:	f6 e0       	ldi	r31, 0x06	; 6
 246:	02 c0       	rjmp	.+4      	; 0x24c <.do_copy_data_start>

00000248 <.do_copy_data_loop>:
 248:	05 90       	lpm	r0, Z+
 24a:	0d 92       	st	X+, r0

0000024c <.do_copy_data_start>:
 24c:	a2 36       	cpi	r26, 0x62	; 98
 24e:	b1 07       	cpc	r27, r17
 250:	d9 f7       	brne	.-10     	; 0x248 <.do_copy_data_loop>

00000252 <__do_clear_bss>:
 252:	10 e0       	ldi	r17, 0x00	; 0
 254:	a2 e6       	ldi	r26, 0x62	; 98
 256:	b0 e0       	ldi	r27, 0x00	; 0
 258:	01 c0       	rjmp	.+2      	; 0x25c <.do_clear_bss_start>

0000025a <.do_clear_bss_loop>:
 25a:	1d 92       	st	X+, r1

0000025c <.do_clear_bss_start>:
 25c:	a9 36       	cpi	r26, 0x69	; 105
 25e:	b1 07       	cpc	r27, r17
 260:	e1 f7       	brne	.-8      	; 0x25a <.do_clear_bss_loop>
 262:	0e 94 2f 03 	call	0x65e	; 0x65e <main>
 266:	0c 94 37 03 	jmp	0x66e	; 0x66e <_exit>

0000026a <__bad_interrupt>:
 26a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000026e <uCinit>:

//! ----------------------------------------------------------------------------
//! Initialize the I/O lines, timers, interrupts, etc. of the microcontroller
//! ----------------------------------------------------------------------------
void uCinit(void)
{
 26e:	1b ba       	out	0x1b, r1	; 27
	//! port initialization
	PORTA=0b00000000;		//! pullups, 0=no pullup, 1=pullup on
	DDRA=0b11111111;     	//! input/output, 0=input, 1=output
 270:	9f ef       	ldi	r25, 0xFF	; 255
 272:	9a bb       	out	0x1a, r25	; 26
	PORTB=0b00000000;		//! pullups, 0=no pullup, 1=pullup on
 274:	18 ba       	out	0x18, r1	; 24
	DDRB=0b11111111; 		//! input/output, 0=input, 1=output
 276:	97 bb       	out	0x17, r25	; 23
	PORTC=0b00000000;		//! pullups, 0=no pullup, 1=pullup on
 278:	15 ba       	out	0x15, r1	; 21
	DDRC=0b11111111;     	//! input/output, 0=input, 1=output
 27a:	94 bb       	out	0x14, r25	; 20
	PORTD=0b00000100;		//! pullups, 0=no pullup, 1=pullup on
 27c:	84 e0       	ldi	r24, 0x04	; 4
 27e:	82 bb       	out	0x12, r24	; 18
	DDRD=0b11111011; 		//! input/output, 0=input, 1=output
 280:	8b ef       	ldi	r24, 0xFB	; 251
 282:	81 bb       	out	0x11, r24	; 17

	//! external interrupt 0
	MCUCR=(1<<ISC01)|(1<<ISC00);	//! the rising edge generates the external interrupt
 284:	83 e0       	ldi	r24, 0x03	; 3
 286:	85 bf       	out	0x35, r24	; 53
	GICR=(1<<INT0);		//! enable external interrupt 0
 288:	80 e4       	ldi	r24, 0x40	; 64
 28a:	8b bf       	out	0x3b, r24	; 59

	//! 8 bit timer initialization (timer 0)
	TIMSK=(1<<TOIE0);   //! Enable TCNT0 overflow
 28c:	81 e0       	ldi	r24, 0x01	; 1
 28e:	89 bf       	out	0x39, r24	; 57
	TCNT0=0;         	//!  reset TCNT0
 290:	12 be       	out	0x32, r1	; 50
	TCCR0=1;
 292:	83 bf       	out	0x33, r24	; 51

	PORTA = 0xFF;	//! turn off all of the LED's in the 5x5 matrix
 294:	9b bb       	out	0x1b, r25	; 27
	PORTC = 0xFF;
 296:	95 bb       	out	0x15, r25	; 21
	PORTB = 0xFF;
 298:	98 bb       	out	0x18, r25	; 24
	PORTD = 0xFF;
 29a:	92 bb       	out	0x12, r25	; 18
}
 29c:	08 95       	ret

0000029e <__vector_9>:

//! ----------------------------------------------------------------------------
//! Timer 0 overflow interrupt happens every 64.39 microseconds
//! ----------------------------------------------------------------------------
ISR (SIG_OVERFLOW0)
{
 29e:	1f 92       	push	r1
 2a0:	0f 92       	push	r0
 2a2:	0f b6       	in	r0, 0x3f	; 63
 2a4:	0f 92       	push	r0
 2a6:	11 24       	eor	r1, r1
 2a8:	8f 93       	push	r24
 2aa:	9f 93       	push	r25
	if(intTock>0)	
 2ac:	80 91 60 00 	lds	r24, 0x0060
 2b0:	90 91 61 00 	lds	r25, 0x0061
 2b4:	89 2b       	or	r24, r25
 2b6:	49 f0       	breq	.+18     	; 0x2ca <__vector_9+0x2c>
	{	
		intTock--;	//! counts down to a 20mS tock used in the main loop
 2b8:	80 91 60 00 	lds	r24, 0x0060
 2bc:	90 91 61 00 	lds	r25, 0x0061
 2c0:	01 97       	sbiw	r24, 0x01	; 1
 2c2:	90 93 61 00 	sts	0x0061, r25
 2c6:	80 93 60 00 	sts	0x0060, r24
	}
}
 2ca:	9f 91       	pop	r25
 2cc:	8f 91       	pop	r24
 2ce:	0f 90       	pop	r0
 2d0:	0f be       	out	0x3f, r0	; 63
 2d2:	0f 90       	pop	r0
 2d4:	1f 90       	pop	r1
 2d6:	18 95       	reti

000002d8 <__vector_1>:

//! ----------------------------------------------------------------------------
//! Interrupt for the external interrupt 0.  This routine runs when the photo interrupter fires
//! ----------------------------------------------------------------------------
ISR (SIG_INTERRUPT0)
{
 2d8:	1f 92       	push	r1
 2da:	0f 92       	push	r0
 2dc:	0f b6       	in	r0, 0x3f	; 63
 2de:	0f 92       	push	r0
 2e0:	11 24       	eor	r1, r1
 2e2:	0f 93       	push	r16
 2e4:	1f 93       	push	r17
 2e6:	2f 93       	push	r18
 2e8:	3f 93       	push	r19
 2ea:	4f 93       	push	r20
 2ec:	5f 93       	push	r21
 2ee:	6f 93       	push	r22
 2f0:	7f 93       	push	r23
 2f2:	8f 93       	push	r24
 2f4:	9f 93       	push	r25
 2f6:	af 93       	push	r26
 2f8:	bf 93       	push	r27
 2fa:	ef 93       	push	r30
 2fc:	ff 93       	push	r31
 2fe:	df 93       	push	r29
 300:	cf 93       	push	r28
 302:	00 d0       	rcall	.+0      	; 0x304 <__vector_1+0x2c>
 304:	00 d0       	rcall	.+0      	; 0x306 <__vector_1+0x2e>
 306:	cd b7       	in	r28, 0x3d	; 61
 308:	de b7       	in	r29, 0x3e	; 62
	u08 u08IsrTemp;	//! used to step through the four bytes in each image
	u08 u08FlashValue[4];	//! used to hold the flash image bytes in RAM

	u08TmrFlick=15;
 30a:	8f e0       	ldi	r24, 0x0F	; 15
 30c:	80 93 62 00 	sts	0x0062, r24

	for(u08CurrentFrame=0;u08CurrentFrame<5;u08CurrentFrame++)	//! step through the frames
 310:	10 92 63 00 	sts	0x0063, r1
 314:	8e 01       	movw	r16, r28
 316:	0f 5f       	subi	r16, 0xFF	; 255
 318:	1f 4f       	sbci	r17, 0xFF	; 255
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 31a:	50 ea       	ldi	r21, 0xA0	; 160
		PORTA = u08FlashValue[0];	//! load the image into the ports for the LED's
		PORTC = u08FlashValue[1];	//! load the image into the ports for the LED's
		PORTB = u08FlashValue[2];	//! load the image into the ports for the LED's
		PORTD = u08FlashValue[3];	//! load the image into the ports for the LED's
		_delay_us(30);	//! an inline delay between frames (30uS) Makes the LED's look like they are on instantaneously
		PORTA = 0xFF;	//! turn off all of the LED's
 31c:	4f ef       	ldi	r20, 0xFF	; 255
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 31e:	60 e0       	ldi	r22, 0x00	; 0
 320:	7d e7       	ldi	r23, 0x7D	; 125
 322:	32 c1       	rjmp	.+612    	; 0x588 <__stack+0x129>

	for(u08CurrentFrame=0;u08CurrentFrame<5;u08CurrentFrame++)	//! step through the frames
	{
		for(u08IsrTemp=0;u08IsrTemp<=3;u08IsrTemp++)		//! step through the flash bytes
		{
			switch(u08ShownFrame)
 324:	80 91 65 00 	lds	r24, 0x0065
 328:	e8 2f       	mov	r30, r24
 32a:	f0 e0       	ldi	r31, 0x00	; 0
 32c:	ec 31       	cpi	r30, 0x1C	; 28
 32e:	f1 05       	cpc	r31, r1
 330:	08 f0       	brcs	.+2      	; 0x334 <__vector_1+0x5c>
 332:	0c c1       	rjmp	.+536    	; 0x54c <__stack+0xed>
 334:	e6 5d       	subi	r30, 0xD6	; 214
 336:	ff 4f       	sbci	r31, 0xFF	; 255
 338:	ee 0f       	add	r30, r30
 33a:	ff 1f       	adc	r31, r31
 33c:	05 90       	lpm	r0, Z+
 33e:	f4 91       	lpm	r31, Z+
 340:	e0 2d       	mov	r30, r0
 342:	09 94       	ijmp
			{
				//! start of single wave
				case 0:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strSingleWave1[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 344:	e0 91 63 00 	lds	r30, 0x0063
 348:	f0 e0       	ldi	r31, 0x00	; 0
 34a:	ee 0f       	add	r30, r30
 34c:	ff 1f       	adc	r31, r31
 34e:	ee 0f       	add	r30, r30
 350:	ff 1f       	adc	r31, r31
 352:	e2 0f       	add	r30, r18
 354:	f3 1f       	adc	r31, r19
 356:	e0 56       	subi	r30, 0x60	; 96
 358:	ff 4f       	sbci	r31, 0xFF	; 255
 35a:	e4 91       	lpm	r30, Z+
 35c:	f6 c0       	rjmp	.+492    	; 0x54a <__stack+0xeb>
				break;
				case 1:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strSingleWave2[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 35e:	e0 91 63 00 	lds	r30, 0x0063
 362:	f0 e0       	ldi	r31, 0x00	; 0
 364:	ee 0f       	add	r30, r30
 366:	ff 1f       	adc	r31, r31
 368:	ee 0f       	add	r30, r30
 36a:	ff 1f       	adc	r31, r31
 36c:	e2 0f       	add	r30, r18
 36e:	f3 1f       	adc	r31, r19
 370:	ec 54       	subi	r30, 0x4C	; 76
 372:	ff 4f       	sbci	r31, 0xFF	; 255
 374:	e4 91       	lpm	r30, Z+
 376:	e9 c0       	rjmp	.+466    	; 0x54a <__stack+0xeb>
				break;
				case 2:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strSingleWave3[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 378:	e0 91 63 00 	lds	r30, 0x0063
 37c:	f0 e0       	ldi	r31, 0x00	; 0
 37e:	ee 0f       	add	r30, r30
 380:	ff 1f       	adc	r31, r31
 382:	ee 0f       	add	r30, r30
 384:	ff 1f       	adc	r31, r31
 386:	e2 0f       	add	r30, r18
 388:	f3 1f       	adc	r31, r19
 38a:	e8 53       	subi	r30, 0x38	; 56
 38c:	ff 4f       	sbci	r31, 0xFF	; 255
 38e:	e4 91       	lpm	r30, Z+
 390:	dc c0       	rjmp	.+440    	; 0x54a <__stack+0xeb>
				break;
				case 3:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strSingleWave4[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 392:	e0 91 63 00 	lds	r30, 0x0063
 396:	f0 e0       	ldi	r31, 0x00	; 0
 398:	ee 0f       	add	r30, r30
 39a:	ff 1f       	adc	r31, r31
 39c:	ee 0f       	add	r30, r30
 39e:	ff 1f       	adc	r31, r31
 3a0:	e2 0f       	add	r30, r18
 3a2:	f3 1f       	adc	r31, r19
 3a4:	e4 52       	subi	r30, 0x24	; 36
 3a6:	ff 4f       	sbci	r31, 0xFF	; 255
 3a8:	e4 91       	lpm	r30, Z+
 3aa:	cf c0       	rjmp	.+414    	; 0x54a <__stack+0xeb>
				break;
				case 4:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strSingleWave5[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 3ac:	e0 91 63 00 	lds	r30, 0x0063
 3b0:	f0 e0       	ldi	r31, 0x00	; 0
 3b2:	ee 0f       	add	r30, r30
 3b4:	ff 1f       	adc	r31, r31
 3b6:	ee 0f       	add	r30, r30
 3b8:	ff 1f       	adc	r31, r31
 3ba:	e2 0f       	add	r30, r18
 3bc:	f3 1f       	adc	r31, r19
 3be:	e0 51       	subi	r30, 0x10	; 16
 3c0:	ff 4f       	sbci	r31, 0xFF	; 255
 3c2:	e4 91       	lpm	r30, Z+
 3c4:	c2 c0       	rjmp	.+388    	; 0x54a <__stack+0xeb>
				break;
				case 5:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strSingleWave6[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 3c6:	e0 91 63 00 	lds	r30, 0x0063
 3ca:	f0 e0       	ldi	r31, 0x00	; 0
 3cc:	ee 0f       	add	r30, r30
 3ce:	ff 1f       	adc	r31, r31
 3d0:	ee 0f       	add	r30, r30
 3d2:	ff 1f       	adc	r31, r31
 3d4:	e2 0f       	add	r30, r18
 3d6:	f3 1f       	adc	r31, r19
 3d8:	ec 5f       	subi	r30, 0xFC	; 252
 3da:	fe 4f       	sbci	r31, 0xFE	; 254
 3dc:	e4 91       	lpm	r30, Z+
 3de:	b5 c0       	rjmp	.+362    	; 0x54a <__stack+0xeb>
				break;
				case 6:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strSingleWave7[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 3e0:	e0 91 63 00 	lds	r30, 0x0063
 3e4:	f0 e0       	ldi	r31, 0x00	; 0
 3e6:	ee 0f       	add	r30, r30
 3e8:	ff 1f       	adc	r31, r31
 3ea:	ee 0f       	add	r30, r30
 3ec:	ff 1f       	adc	r31, r31
 3ee:	e2 0f       	add	r30, r18
 3f0:	f3 1f       	adc	r31, r19
 3f2:	e8 5e       	subi	r30, 0xE8	; 232
 3f4:	fe 4f       	sbci	r31, 0xFE	; 254
 3f6:	e4 91       	lpm	r30, Z+
 3f8:	a8 c0       	rjmp	.+336    	; 0x54a <__stack+0xeb>
				break;
				case 7:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strSingleWave8[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 3fa:	e0 91 63 00 	lds	r30, 0x0063
 3fe:	f0 e0       	ldi	r31, 0x00	; 0
 400:	ee 0f       	add	r30, r30
 402:	ff 1f       	adc	r31, r31
 404:	ee 0f       	add	r30, r30
 406:	ff 1f       	adc	r31, r31
 408:	e2 0f       	add	r30, r18
 40a:	f3 1f       	adc	r31, r19
 40c:	e4 5d       	subi	r30, 0xD4	; 212
 40e:	fe 4f       	sbci	r31, 0xFE	; 254
 410:	e4 91       	lpm	r30, Z+
 412:	9b c0       	rjmp	.+310    	; 0x54a <__stack+0xeb>
				break;
				case 8:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strSingleWave9[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 414:	e0 91 63 00 	lds	r30, 0x0063
 418:	f0 e0       	ldi	r31, 0x00	; 0
 41a:	ee 0f       	add	r30, r30
 41c:	ff 1f       	adc	r31, r31
 41e:	ee 0f       	add	r30, r30
 420:	ff 1f       	adc	r31, r31
 422:	e2 0f       	add	r30, r18
 424:	f3 1f       	adc	r31, r19
 426:	e0 5c       	subi	r30, 0xC0	; 192
 428:	fe 4f       	sbci	r31, 0xFE	; 254
 42a:	e4 91       	lpm	r30, Z+
 42c:	8e c0       	rjmp	.+284    	; 0x54a <__stack+0xeb>
				break;
				case 9:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strSingleWave10[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 42e:	e0 91 63 00 	lds	r30, 0x0063
 432:	f0 e0       	ldi	r31, 0x00	; 0
 434:	ee 0f       	add	r30, r30
 436:	ff 1f       	adc	r31, r31
 438:	ee 0f       	add	r30, r30
 43a:	ff 1f       	adc	r31, r31
 43c:	e2 0f       	add	r30, r18
 43e:	f3 1f       	adc	r31, r19
 440:	ec 5a       	subi	r30, 0xAC	; 172
 442:	fe 4f       	sbci	r31, 0xFE	; 254
 444:	e4 91       	lpm	r30, Z+
 446:	81 c0       	rjmp	.+258    	; 0x54a <__stack+0xeb>
				break;
				case 10:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strSingleWave11[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 448:	e0 91 63 00 	lds	r30, 0x0063
 44c:	f0 e0       	ldi	r31, 0x00	; 0
 44e:	ee 0f       	add	r30, r30
 450:	ff 1f       	adc	r31, r31
 452:	ee 0f       	add	r30, r30
 454:	ff 1f       	adc	r31, r31
 456:	e2 0f       	add	r30, r18
 458:	f3 1f       	adc	r31, r19
 45a:	e8 59       	subi	r30, 0x98	; 152
 45c:	fe 4f       	sbci	r31, 0xFE	; 254
 45e:	e4 91       	lpm	r30, Z+
 460:	74 c0       	rjmp	.+232    	; 0x54a <__stack+0xeb>
				break;
				case 11:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strSingleWave12[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 462:	e0 91 63 00 	lds	r30, 0x0063
 466:	f0 e0       	ldi	r31, 0x00	; 0
 468:	ee 0f       	add	r30, r30
 46a:	ff 1f       	adc	r31, r31
 46c:	ee 0f       	add	r30, r30
 46e:	ff 1f       	adc	r31, r31
 470:	e2 0f       	add	r30, r18
 472:	f3 1f       	adc	r31, r19
 474:	e4 58       	subi	r30, 0x84	; 132
 476:	fe 4f       	sbci	r31, 0xFE	; 254
 478:	e4 91       	lpm	r30, Z+
 47a:	67 c0       	rjmp	.+206    	; 0x54a <__stack+0xeb>
				break;
				//! end of single wave

				case 20:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strHelix1[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 47c:	e0 91 63 00 	lds	r30, 0x0063
 480:	f0 e0       	ldi	r31, 0x00	; 0
 482:	ee 0f       	add	r30, r30
 484:	ff 1f       	adc	r31, r31
 486:	ee 0f       	add	r30, r30
 488:	ff 1f       	adc	r31, r31
 48a:	e2 0f       	add	r30, r18
 48c:	f3 1f       	adc	r31, r19
 48e:	e0 57       	subi	r30, 0x70	; 112
 490:	fe 4f       	sbci	r31, 0xFE	; 254
 492:	e4 91       	lpm	r30, Z+
 494:	5a c0       	rjmp	.+180    	; 0x54a <__stack+0xeb>
				break;
				case 21:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strHelix2[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 496:	e0 91 63 00 	lds	r30, 0x0063
 49a:	f0 e0       	ldi	r31, 0x00	; 0
 49c:	ee 0f       	add	r30, r30
 49e:	ff 1f       	adc	r31, r31
 4a0:	ee 0f       	add	r30, r30
 4a2:	ff 1f       	adc	r31, r31
 4a4:	e2 0f       	add	r30, r18
 4a6:	f3 1f       	adc	r31, r19
 4a8:	ec 55       	subi	r30, 0x5C	; 92
 4aa:	fe 4f       	sbci	r31, 0xFE	; 254
 4ac:	e4 91       	lpm	r30, Z+
 4ae:	4d c0       	rjmp	.+154    	; 0x54a <__stack+0xeb>
				break;
				case 22:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strHelix3[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 4b0:	e0 91 63 00 	lds	r30, 0x0063
 4b4:	f0 e0       	ldi	r31, 0x00	; 0
 4b6:	ee 0f       	add	r30, r30
 4b8:	ff 1f       	adc	r31, r31
 4ba:	ee 0f       	add	r30, r30
 4bc:	ff 1f       	adc	r31, r31
 4be:	e2 0f       	add	r30, r18
 4c0:	f3 1f       	adc	r31, r19
 4c2:	e8 54       	subi	r30, 0x48	; 72
 4c4:	fe 4f       	sbci	r31, 0xFE	; 254
 4c6:	e4 91       	lpm	r30, Z+
 4c8:	40 c0       	rjmp	.+128    	; 0x54a <__stack+0xeb>
				break;
				case 23:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strHelix4[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 4ca:	e0 91 63 00 	lds	r30, 0x0063
 4ce:	f0 e0       	ldi	r31, 0x00	; 0
 4d0:	ee 0f       	add	r30, r30
 4d2:	ff 1f       	adc	r31, r31
 4d4:	ee 0f       	add	r30, r30
 4d6:	ff 1f       	adc	r31, r31
 4d8:	e2 0f       	add	r30, r18
 4da:	f3 1f       	adc	r31, r19
 4dc:	e4 53       	subi	r30, 0x34	; 52
 4de:	fe 4f       	sbci	r31, 0xFE	; 254
 4e0:	e4 91       	lpm	r30, Z+
 4e2:	33 c0       	rjmp	.+102    	; 0x54a <__stack+0xeb>
				break;
				case 24:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strHelix5[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 4e4:	e0 91 63 00 	lds	r30, 0x0063
 4e8:	f0 e0       	ldi	r31, 0x00	; 0
 4ea:	ee 0f       	add	r30, r30
 4ec:	ff 1f       	adc	r31, r31
 4ee:	ee 0f       	add	r30, r30
 4f0:	ff 1f       	adc	r31, r31
 4f2:	e2 0f       	add	r30, r18
 4f4:	f3 1f       	adc	r31, r19
 4f6:	e0 52       	subi	r30, 0x20	; 32
 4f8:	fe 4f       	sbci	r31, 0xFE	; 254
 4fa:	e4 91       	lpm	r30, Z+
 4fc:	26 c0       	rjmp	.+76     	; 0x54a <__stack+0xeb>
				break;
				case 25:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strHelix6[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 4fe:	e0 91 63 00 	lds	r30, 0x0063
 502:	f0 e0       	ldi	r31, 0x00	; 0
 504:	ee 0f       	add	r30, r30
 506:	ff 1f       	adc	r31, r31
 508:	ee 0f       	add	r30, r30
 50a:	ff 1f       	adc	r31, r31
 50c:	e2 0f       	add	r30, r18
 50e:	f3 1f       	adc	r31, r19
 510:	ec 50       	subi	r30, 0x0C	; 12
 512:	fe 4f       	sbci	r31, 0xFE	; 254
 514:	e4 91       	lpm	r30, Z+
 516:	19 c0       	rjmp	.+50     	; 0x54a <__stack+0xeb>
				break;
				case 26:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strHelix7[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 518:	e0 91 63 00 	lds	r30, 0x0063
 51c:	f0 e0       	ldi	r31, 0x00	; 0
 51e:	ee 0f       	add	r30, r30
 520:	ff 1f       	adc	r31, r31
 522:	ee 0f       	add	r30, r30
 524:	ff 1f       	adc	r31, r31
 526:	e2 0f       	add	r30, r18
 528:	f3 1f       	adc	r31, r19
 52a:	e8 5f       	subi	r30, 0xF8	; 248
 52c:	fd 4f       	sbci	r31, 0xFD	; 253
 52e:	e4 91       	lpm	r30, Z+
 530:	0c c0       	rjmp	.+24     	; 0x54a <__stack+0xeb>
				break;
				case 27:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strHelix8[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
 532:	e0 91 63 00 	lds	r30, 0x0063
 536:	f0 e0       	ldi	r31, 0x00	; 0
 538:	ee 0f       	add	r30, r30
 53a:	ff 1f       	adc	r31, r31
 53c:	ee 0f       	add	r30, r30
 53e:	ff 1f       	adc	r31, r31
 540:	e2 0f       	add	r30, r18
 542:	f3 1f       	adc	r31, r19
 544:	e4 5e       	subi	r30, 0xE4	; 228
 546:	fd 4f       	sbci	r31, 0xFD	; 253
 548:	e4 91       	lpm	r30, Z+
 54a:	ec 93       	st	X, r30
 54c:	2f 5f       	subi	r18, 0xFF	; 255
 54e:	3f 4f       	sbci	r19, 0xFF	; 255
 550:	11 96       	adiw	r26, 0x01	; 1

	u08TmrFlick=15;

	for(u08CurrentFrame=0;u08CurrentFrame<5;u08CurrentFrame++)	//! step through the frames
	{
		for(u08IsrTemp=0;u08IsrTemp<=3;u08IsrTemp++)		//! step through the flash bytes
 552:	24 30       	cpi	r18, 0x04	; 4
 554:	31 05       	cpc	r19, r1
 556:	09 f0       	breq	.+2      	; 0x55a <__stack+0xfb>
 558:	e5 ce       	rjmp	.-566    	; 0x324 <__vector_1+0x4c>
				case 27:
					u08FlashValue[u08IsrTemp]=pgm_read_byte(&strHelix8[u08IsrTemp+(u08CurrentFrame*4)]);	//! load the flash bytes of the image arrray into ram
				break;
			}
		}
		PORTA = u08FlashValue[0];	//! load the image into the ports for the LED's
 55a:	89 81       	ldd	r24, Y+1	; 0x01
 55c:	8b bb       	out	0x1b, r24	; 27
		PORTC = u08FlashValue[1];	//! load the image into the ports for the LED's
 55e:	8a 81       	ldd	r24, Y+2	; 0x02
 560:	85 bb       	out	0x15, r24	; 21
		PORTB = u08FlashValue[2];	//! load the image into the ports for the LED's
 562:	8b 81       	ldd	r24, Y+3	; 0x03
 564:	88 bb       	out	0x18, r24	; 24
		PORTD = u08FlashValue[3];	//! load the image into the ports for the LED's
 566:	8c 81       	ldd	r24, Y+4	; 0x04
 568:	82 bb       	out	0x12, r24	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 56a:	85 2f       	mov	r24, r21
 56c:	8a 95       	dec	r24
 56e:	f1 f7       	brne	.-4      	; 0x56c <__stack+0x10d>
		_delay_us(30);	//! an inline delay between frames (30uS) Makes the LED's look like they are on instantaneously
		PORTA = 0xFF;	//! turn off all of the LED's
 570:	4b bb       	out	0x1b, r20	; 27
		PORTC = 0xFF;	//! turn off all of the LED's
 572:	45 bb       	out	0x15, r20	; 21
		PORTB = 0xFF;	//! turn off all of the LED's
 574:	48 bb       	out	0x18, r20	; 24
		PORTD = 0xFF;	//! turn off all of the LED's
 576:	42 bb       	out	0x12, r20	; 18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 578:	cb 01       	movw	r24, r22
 57a:	01 97       	sbiw	r24, 0x01	; 1
 57c:	f1 f7       	brne	.-4      	; 0x57a <__stack+0x11b>
	u08 u08IsrTemp;	//! used to step through the four bytes in each image
	u08 u08FlashValue[4];	//! used to hold the flash image bytes in RAM

	u08TmrFlick=15;

	for(u08CurrentFrame=0;u08CurrentFrame<5;u08CurrentFrame++)	//! step through the frames
 57e:	80 91 63 00 	lds	r24, 0x0063
 582:	8f 5f       	subi	r24, 0xFF	; 255
 584:	80 93 63 00 	sts	0x0063, r24
 588:	80 91 63 00 	lds	r24, 0x0063
 58c:	85 30       	cpi	r24, 0x05	; 5
 58e:	20 f4       	brcc	.+8      	; 0x598 <__stack+0x139>
 590:	d8 01       	movw	r26, r16
 592:	20 e0       	ldi	r18, 0x00	; 0
 594:	30 e0       	ldi	r19, 0x00	; 0
 596:	c6 ce       	rjmp	.-628    	; 0x324 <__vector_1+0x4c>
		PORTC = 0xFF;	//! turn off all of the LED's
		PORTB = 0xFF;	//! turn off all of the LED's
		PORTD = 0xFF;	//! turn off all of the LED's
		_delay_ms(8);	//! an inline delay between frames (was 8mS)
	}
	PORTA = 0xFF;	//! turn off all of the LED's (we are done with the current frame)
 598:	8f ef       	ldi	r24, 0xFF	; 255
 59a:	8b bb       	out	0x1b, r24	; 27
	PORTC = 0xFF;	//! turn off all of the LED's (we are done with the current frame)
 59c:	85 bb       	out	0x15, r24	; 21
	PORTB = 0xFF;	//! turn off all of the LED's (we are done with the current frame)
 59e:	88 bb       	out	0x18, r24	; 24
	PORTD = 0xFF;	//! turn off all of the LED's (we are done with the current frame)
 5a0:	82 bb       	out	0x12, r24	; 18
	if(u08FrameDelay>1)	//! This is the number of times each 3D image repeats
 5a2:	80 91 64 00 	lds	r24, 0x0064
 5a6:	82 30       	cpi	r24, 0x02	; 2
 5a8:	38 f0       	brcs	.+14     	; 0x5b8 <__stack+0x159>
	{
		u08FrameDelay=0;	//! reset the counter for the next image
 5aa:	10 92 64 00 	sts	0x0064, r1
		u08ShownFrame++;			//! we are ready for the next image
 5ae:	80 91 65 00 	lds	r24, 0x0065
 5b2:	8f 5f       	subi	r24, 0xFF	; 255
 5b4:	80 93 65 00 	sts	0x0065, r24
	}
	u08FrameDelay++;	//! advance the frame delay counter
 5b8:	80 91 64 00 	lds	r24, 0x0064
 5bc:	8f 5f       	subi	r24, 0xFF	; 255
 5be:	80 93 64 00 	sts	0x0064, r24
	if(u08ShownFrame>11)	//! have we reached the end of the frames?  (11 for LtoRwave, 27 for helix
 5c2:	80 91 65 00 	lds	r24, 0x0065
 5c6:	8c 30       	cpi	r24, 0x0C	; 12
 5c8:	10 f0       	brcs	.+4      	; 0x5ce <__stack+0x16f>
	{
		u08ShownFrame=0;	//! we are ready to start over again with the animation (0 for LtoRwave, 20 for helix)
 5ca:	10 92 65 00 	sts	0x0065, r1
	}
}
 5ce:	0f 90       	pop	r0
 5d0:	0f 90       	pop	r0
 5d2:	0f 90       	pop	r0
 5d4:	0f 90       	pop	r0
 5d6:	cf 91       	pop	r28
 5d8:	df 91       	pop	r29
 5da:	ff 91       	pop	r31
 5dc:	ef 91       	pop	r30
 5de:	bf 91       	pop	r27
 5e0:	af 91       	pop	r26
 5e2:	9f 91       	pop	r25
 5e4:	8f 91       	pop	r24
 5e6:	7f 91       	pop	r23
 5e8:	6f 91       	pop	r22
 5ea:	5f 91       	pop	r21
 5ec:	4f 91       	pop	r20
 5ee:	3f 91       	pop	r19
 5f0:	2f 91       	pop	r18
 5f2:	1f 91       	pop	r17
 5f4:	0f 91       	pop	r16
 5f6:	0f 90       	pop	r0
 5f8:	0f be       	out	0x3f, r0	; 63
 5fa:	0f 90       	pop	r0
 5fc:	1f 90       	pop	r1
 5fe:	18 95       	reti

00000600 <SrvTock>:

//! ----------------------------------------------------------------------------
//! Execute the tock every 20mS from the main loop.
//! ----------------------------------------------------------------------------
void SrvTock(void)
{
 600:	80 91 60 00 	lds	r24, 0x0060
 604:	90 91 61 00 	lds	r25, 0x0061
 608:	89 2b       	or	r24, r25
 60a:	41 f5       	brne	.+80     	; 0x65c <SrvTock+0x5c>
	if (intTock==0)
	{
		intTock=defTock;		//! reload 311 for a 20mS tock at 4MHz
 60c:	87 e3       	ldi	r24, 0x37	; 55
 60e:	91 e0       	ldi	r25, 0x01	; 1
 610:	90 93 61 00 	sts	0x0061, r25
 614:	80 93 60 00 	sts	0x0060, r24
		switch (u08State)	//! controls the very small state machine
 618:	80 91 66 00 	lds	r24, 0x0066
 61c:	88 23       	and	r24, r24
 61e:	19 f0       	breq	.+6      	; 0x626 <SrvTock+0x26>
 620:	81 30       	cpi	r24, 0x01	; 1
 622:	e1 f4       	brne	.+56     	; 0x65c <SrvTock+0x5c>
 624:	0c c0       	rjmp	.+24     	; 0x63e <SrvTock+0x3e>
		{
			case 0:  //! are we showing the first animation sequence?
				if(u08TmrFlick==0)	//! is it time to change the animation sequence?
 626:	80 91 62 00 	lds	r24, 0x0062
 62a:	88 23       	and	r24, r24
 62c:	21 f4       	brne	.+8      	; 0x636 <SrvTock+0x36>
				{
					u08State=1;		//go to the next animation sequence
 62e:	81 e0       	ldi	r24, 0x01	; 1
 630:	80 93 66 00 	sts	0x0066, r24
 634:	0a c0       	rjmp	.+20     	; 0x64a <SrvTock+0x4a>
					u08TmrFlick=0xFF;	//! start the delay off at the maximum for sequence
				}
				else
				{
					u08TmrFlick--;
 636:	80 91 62 00 	lds	r24, 0x0062
 63a:	81 50       	subi	r24, 0x01	; 1
 63c:	07 c0       	rjmp	.+14     	; 0x64c <SrvTock+0x4c>
				}

			break;

			case 1:  //! are we showing the first animation sequence?
				if(u08TmrFlick==0)	//! is it time to change the animation sequence?
 63e:	80 91 62 00 	lds	r24, 0x0062
 642:	88 23       	and	r24, r24
 644:	31 f4       	brne	.+12     	; 0x652 <SrvTock+0x52>
				{
					u08State=0;		//go to the next animation sequence
 646:	10 92 66 00 	sts	0x0066, r1
					u08TmrFlick=0xFF;	//! start the delay off at the maximum for sequence
 64a:	8f ef       	ldi	r24, 0xFF	; 255
 64c:	80 93 62 00 	sts	0x0062, r24
 650:	08 95       	ret
				}
				else
				{
					u08TmrFlick--;
 652:	80 91 62 00 	lds	r24, 0x0062
 656:	81 50       	subi	r24, 0x01	; 1
 658:	80 93 62 00 	sts	0x0062, r24
 65c:	08 95       	ret

0000065e <main>:

//! ----------------------------------------------------------------------------
//! This is where to program will exicute until an interrupt happens or someone yanks the power plug.
//! ----------------------------------------------------------------------------
int main( void )
{
 65e:	f8 94       	cli
	cli();			//! disable interrupts
	uCinit();		//! go through the initialization process for the microcontroller
 660:	0e 94 37 01 	call	0x26e	; 0x26e <uCinit>
	sei();			//! enable interrupts
 664:	78 94       	sei
	
	while(1)		//!  go into an infinite loop here
	{
		wdt_reset();	//! reset the watchdog
 666:	a8 95       	wdr
		SrvTock();		//! go to the tock every 20ms
 668:	0e 94 00 03 	call	0x600	; 0x600 <SrvTock>
 66c:	fc cf       	rjmp	.-8      	; 0x666 <main+0x8>

0000066e <_exit>:
 66e:	f8 94       	cli

00000670 <__stop_program>:
 670:	ff cf       	rjmp	.-2      	; 0x670 <__stop_program>
