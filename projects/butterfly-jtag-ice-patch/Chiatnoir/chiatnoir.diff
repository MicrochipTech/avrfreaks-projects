3c3
< ; at 2006/03/25 - 23:03:02
---
> ; at 2006/04/08 - 15:10:00
6,13d5
< ; ""
< ; "Unccomment to select which"
< ; "system to assemble for:"
< .include "m169def.inc"   ; BUTTERFLY/ATMEGA169 DEFS
< ;
< ;.include "m163def.inc"    ; ATMEGA163 DEFS
< ;
< ;---------------------------------------
46d37
< ;
84d74
< .equ	k28	= 0x28	; '('
156d145
< .equ	k91	= 0x91	;
165d153
< .equ	kA1	= 0xA1	; '¡'
172d159
< .equ	kB1	= 0xB1	; '±'
176d162
< .equ	kC1	= 0xC1	; 'Á'
183d168
< .equ	kE2	= 0xE2	; 'â'
187d171
< .equ	kF1	= 0xF1	; 'ñ'
199a184,217
> ; io register addresses:
> ;
> .equ	ADCL	= 0x04
> .equ	ADCH	= 0x05
> .equ	ADCSR	= 0x06
> .equ	ADMUX	= 0x07
> .equ	UBBR	= 0x09
> .equ	UCSRA	= 0x0A
> .equ	UCSRB	= 0x0B
> .equ	UDR	= 0x0C
> .equ	PIND	= 0x10
> .equ	DDRD	= 0x11
> .equ	PORTD	= 0x12
> .equ	PINC	= 0x13
> .equ	DDRC	= 0x14
> .equ	PORTC	= 0x15
> .equ	PINB	= 0x16
> .equ	DDRB	= 0x17
> .equ	PORTB	= 0x18
> .equ	DDRA	= 0x1A
> .equ	PORTA	= 0x1B
> .equ	EECR	= 0x1C
> .equ	EEDR	= 0x1D
> .equ	EEARL	= 0x1E
> .equ	EEARH	= 0x1F
> .equ	UBRRHI	= 0x20
> .equ	TCCR0	= 0x33
> .equ	SPMCR	= 0x37
> .equ	TIMSK	= 0x39
> .equ	GIMSK	= 0x3B
> .equ	SPL	= 0x3D
> .equ	SPH	= 0x3E
> .equ	SREG	= 0x3F
> ;
219d236
< .equ	o11	= 0x11
223,224d239
< .equ	o27	= 0x27
< .equ	o31	= 0x31
237,365d251
< 
< ; macro redefs
< #ifdef _M163DEF_INC_
< ; define these registers with changed names
< .equ kBaud115200	= k03
< .equ kBaud57600	= k07
< .equ kBaud38400	= k0B			
< .equ kBaud19200 = 23
< .equ kBaud14400	= k1F			
< .equ kBaud9600	= k2F
< 
< .equ iMSK		= GIMSK
< .equ RAMPZ		= GIMSK	; this will make the code compile
< 						; the same as the reference code
< .equ JTAGPORT	= PORTB
< .equ JTAGDDR	= DDRB
< .equ JTAGPIN	= PINB
< .equ RESETPORT	= PORTB
< .equ RESETDDR	= DDRB
< .equ LEDPORT	= PORTB
< .equ HWREVPORT	= PORTC
< .equ HWREVDDR	= DDRC
< .equ HWREVPIN	= PINC
< .equ VTARGPORT	= PORTD
< .equ VTARGDDR	= DDRD
< .equ VTARGPIN	= PIND
< 
< .equ TCK		= PINB7
< .equ TD0		= PINB6
< .equ TDI		= PINB5
< .equ TMS		= PINB1
< 
< ; 1<<TCK =  1 << b7 = k80 
< ; 1<<TD0 =  1 << b6 = k40
< ; 1<<TDI =  1 << b5 = k20
< ; 1<<TMS =	1 << b1 = k02
< 
< .equ nSRST		= PINB4
< .equ LEDA		= PINB3
< .equ RFU2		= PINB2
< .equ RFU0		= PINB0
< 
< .equ JTAGDDRMSK	 = 1<<TCK | 1<<TDI | 1<<LEDA | 1<<TMS 
< .equ  VTARGDDRMSK= 0xB0
< .equ VTargMUX	= MUX2
< 
< .equ HWREVDDRMSK = 0xF0
< .equ HWREVPINMSK = 0x0F
< 
< .equ TGP_ON 	= PIND3
< 
< .equ BootStart = THIRDBOOTSTART
< 
< #endif
< #ifdef _M169DEF_INC_
< ; define these registers with changed names
< .equ kBaud115200	= 25; 3 ; -8.5% not recommended
< .equ kBaud57600	= 8		; -3.5% not recommended
< .equ kBaud38400	= 12			
< .equ kBaud19200 = 25
< .equ kBaud14400	= 34			
< .equ kBaud9600	= 51
< 
< .equ iMSK  		= EIMSK
< .equ RAMPZ 		= GPIOR0	; stow the page address somewhere
< 
< #if 0
< .equ JTAGPORT	= PORTB		; PORTF
< .equ JTAGDDR	= DDRB		; DDRF
< .equ JTAGPIN	= PINB
< #endif
< 
< #if 1
< .equ JTAGPORT	= PORTF		; PORTF
< .equ JTAGDDR	= DDRF		; DDRF
< .equ JTAGPIN	= PINF
< #endif
< 
< 
< .equ RESETPORT	= PORTE		; PORTB
< .equ RESETDDR	= DDRE
< 
< .equ LEDPORT	= PORTE		; PORTB
< 
< .equ HWREVPORT	= PORTC		; PORTB
< .equ HWREVDDR	= DDRC
< .equ HWREVPIN	= PINC
< 
< .equ VTARGPORT	= PORTE
< .equ VTARGDDR	= DDRE
< .equ VTARGPIN	= PINE
< 
< #if 0
< ; for testing use port B
< .equ TCK		= PINB7
< .equ TD0		= PINB6
< .equ TDI		= PINB2	;PINB5
< .equ TMS		= PINB1
< #endif
< 
< ; for release use port F
< #if 1
< .equ TCK		= PINF4
< .equ TMS		= PINF5
< .equ TD0		= PINF6
< .equ TDI		= PINF7
< #endif
< 
< .equ JTAGDDRMSK	 = 1<<TCK | 1<<TDI | 1<<TMS ; 
< ; E0 TXD
< ; E1 RXD
< ; E2 joystick
< ; E3
< .equ nSRST		= PINE4
< .equ LEDA		= PINE5	
< .equ TGP_ON 	= PINE6
< ; reset flash = PINE7
< 
< .equ VTARGDDRMSK = 1<<LEDA	; port E mux TGP_ON LEDA nsRST
< .equ VTargMUX	= MUX1		; the Vref of the ICE LDR
< .equ LDRMUX		= MUX2
< 
< .equ HWREVDDRMSK = 0xF0
< .equ HWREVPINMSK = 0x0F
< 
< 
< #endif
< 
< 
368,371c254
< ;******************************************************************************
< ; 								Interrupt vectors
< ;******************************************************************************
< 
---
> L0000:
373,385d255
< 
< .org INT0addr	; External Interrupt 0
< 	reti
< 	reti
< 	
< .ifdef INT1addr
< .org INT1addr	; External Interrupt 1
< 	reti
< 	reti
< .endif
< 
< .ifdef PCI0addr
< .org PCI0addr
386a257,258
> ; pc=0x3(0x6)
> ;
388,391c260,261
< .endif
< 
< .ifdef PCI1addr
< .org PCI1addr
---
> ; pc=0x4(0x8)
> ;
392a263,264
> ; pc=0x5(0xA)
> ;
394,396c266,267
< .endif
< 
< .org OC2addr
---
> ; pc=0x6(0xC)
> ;
397a269,270
> ; pc=0x7(0xE)
> ;
399,400c272,273
< 	
< .org OVF2addr
---
> ; pc=0x8(0x10)
> ;
401a275,276
> ; pc=0x9(0x12)
> ;
403,404c278,279
< 
< .org ICP1addr	; Timer/Counter Capture Event
---
> ; pc=0xA(0x14)
> ;
405a281,282
> ; pc=0xB(0x16)
> ;
407,408c284,285
< 	
< .org OC1Aaddr	; Timer/Counter1 Compare Match
---
> ; pc=0xC(0x18)
> ;
409a287,288
> ; pc=0xD(0x1A)
> ;
411,413c290,291
< 
< .org OC1Baddr	; Timer/Counter1 Compare Match
< 	reti		; 
---
> ; pc=0xE(0x1C)
> ;
415,417c293,294
< 	
< .org OVF1addr	; Timer/Counter1 Overflow
< 	reti		; 
---
> ; pc=0xF(0x1E)
> ;
419,421c296,297
< 
< .ifdef OC0addr	
< .org OC0addr
---
> ; pc=0x10(0x20)
> ;
422a299,300
> ; pc=0x11(0x22)
> ;
424,429c302,304
< .endif
< 	
< .org OVF0addr	; Timer/Counter0 Overflow
< 	jmp L00F0
< 	
< .org SPIaddr	; Serial Transfer Complete
---
> ; pc=0x12(0x24)
> ;
> 	jmp	L00F0
430a306,307
> ; pc=0x15(0x2A)
> ;
432,434c309,310
< 
< 
< .org URXCaddr	; UART, Rx Complete
---
> ; pc=0x16(0x2C)
> ;
436,443d311
< 
< ;.ifdef UDRE0addr
< ;.org UDRE0addr
< ;	reti
< ;	reti
< ;.endif
< 
< .org UDREaddr	; UART Data Register Empty
445,458d312
< 
< .org UTXCaddr
< 	reti
< 	reti
< 
< ;.ifdef UTXC0addr	
< ;.org UTXC0addr	; UART, Tx Complete
< ;	reti
< ;	reti
< ;.endif
< 
< .ifdef USI_STARTaddr
< .org USI_STARTaddr
< 	reti
460,469c314,315
< .endif
< 
< .ifdef USI_OVFaddr
< .org USI_OVFaddr
< 	reti
< 	reti
< .endif
< 	
< .org ACIaddr	; Analog Comparator
< 	reti		; 
---
> ; pc=0x1B(0x36)
> ;
471,472c317,318
< 
< .org ADCCaddr	; ADC Conversion Complete
---
> ; pc=0x1C(0x38)
> ;
474,480d319
< 
< .org ERDYaddr	; EEPROM Ready
< 	reti
< 	reti
< 
< .ifdef SPMRaddr
< .org SPMRaddr
481a321,322
> ; pc=0x1F(0x3E)
> ;
483,486c324,325
< .endif
< 
< .ifdef LCDSFaddr	
< .org LCDSFaddr
---
> ; pc=0x20(0x40)
> ;
487a327,328
> ; pc=0x21(0x42)
> ;
489,492c330,331
< .endif
< 
< .ifdef TWIaddr
< .org TWIaddr
---
> ; pc=0x22(0x44)
> ;
493a333,334
> ; pc=0x23(0x46)
> ;
495,497d335
< .endif
< 
< .org INT_VECTORS_SIZE
499,541c337,392
< L0024: .db "AVRNOCD",0 ;4156 524E 4F43 4400 ; AVRNOCD.
< ;; Constants? 56
< L0028: ;0050
< ; function jump table 1 n by 5. We format to 10 to keep line even
< ;			   bst	jmpADDR                 jmpADDR
< ;    r21  r20  r01  r02  ERR     r03  PARM
< .db 0x00,0x20,0x01,byte1(J01F3),byte2(J01F3),byte1(J01DC),byte2(J01DC),0x11,byte1(J01D8),byte2(J01D8)
< .db 0x01,byte1(J01D2),byte2(J01D2),0x01,byte1(J01D4),byte2(J01D4),0x0F,byte1(J01CC),byte2(J01CC),0x04
< .db byte1(J01D6),byte2(J01D6),0x01,byte1(J01D0),byte2(J01D0),0x0B,byte1(J01C6),byte2(J01C6),0x01,byte1(J01CA)
< .db byte2(J01CA),0x04,byte1(J01C8),byte2(J01C8),0x0B,byte1(L01BB),byte2(L01BB),0x01,byte1(L01BB),byte2(L01BB)
< .db 0x01,byte1(J01DF),byte2(J01DF),0x0D,byte1(J01CE),byte2(J01CE),0x07,byte1(J01DA),byte2(J01DA),0x28
< .db byte1(J01E1),byte2(J01E1),0x01,byte1(J01E3),byte2(J01E3),0x01,byte1(J01E5),byte2(J01E5),0x01,byte1(J01E9)
< .db byte2(J01E9),0x01,byte1(J01E7),byte2(J01E7),0x01,byte1(J01EB),byte2(J01EB),0x1B,byte1(J01ED),byte2(J01ED)
< .db 0x01,byte1(J01EF),byte2(J01EF),0x01,byte1(J01F1),byte2(J01F1),0xFB,0x00
< L004F: ;009E set parms jump table
< .db 0x62,0x01,byte1(J05CF),byte2(J05CF),byte1(J0545),byte2(J0545),0x1F,byte1(J05A2),byte2(J05A2),0x01,byte1(J05A7),byte2(J05A7)
< .db 0x04,byte1(J059A),byte2(J059A),0x02,byte1(J05A9),byte2(J05A9),0x01,byte1(J05AB),byte2(J05AB),0x01,byte1(J05AD),byte2(J05AD)
< .db 0x01,byte1(J05C8),byte2(J05C8),0x15,byte1(J0555),byte2(J0555),0x01,byte1(J0563),byte2(J0563),0x01,byte1(J0580),byte2(J0580)
< .db 0x01,byte1(J0583),byte2(J0583),0x01,byte1(J0588),byte2(J0588),0x01,byte1(J058B),byte2(J058B),0x01,byte1(J058E),byte2(J058E)
< .db 0x05,byte1(J05B0),byte2(J05B0),0x01,byte1(J05B3),byte2(J05B3),0x01,byte1(J05B6),byte2(J05B6),0x01,byte1(J05B9),byte2(J05B9)
< .db 0x01,byte1(J056C),byte2(J056C),0x01,byte1(J0566),byte2(J0566),0x01,byte1(J0579),byte2(J0579),0x01,byte1(J0576),byte2(J0576)
< .db 0x02,byte1(J05BC),byte2(J05BC),0x01,byte1(J05BF),byte2(J05BF),0x01,byte1(J055A),byte2(J055A),0x01,byte1(J05C2),byte2(J05C2)
< .db 0x01,byte1(J05C5),byte2(J05C5),0xFB
< 
< P007B: ;00F6  read params jump table
< ;    r20  r01  r02  r03
< .db 0x62,0x01,byte1(J0606),byte2(J0606),byte1(J05DB),byte2(J05DB),0x18,byte1(J05E2)
< .db byte2(J05E2),0x01,byte1(J05E5),byte2(J05E5),0x06,byte1(J05FB),byte2(J05FB),0x01,byte1(J05FF),byte2(J05FF),0x02,byte1(J05E7)
< .db byte2(J05E7),0x02,byte1(J05EA),byte2(J05EA),0x01,byte1(J0601),byte2(J0601),0x20,byte1(J05EE),byte2(J05E7),0x01,byte1(J05F1)
< .db byte2(J05F1),0x01,byte1(J05F4),byte2(J05F4),0x01,byte1(J05F8),byte2(J05F8),0x09,byte1(J0603),byte2(J0603),0xFB,0x00
< 
< L0091: ;122
< .db 0x14,0x03						; this many bytes
< .db low(d0069),high(d0069)
< .db 0x00,0x00
< .db 0x00,0x09 						; this many bytes
< .db 0x00,low(SRAM_START)  			; at this address
< .db high(SRAM_START),low(P2D8E*2)	; 0x8E
< .db high(P2D8E*2),0x00 				; 0x2D from this address
< 
<  
< ; pc=0x0097(0x012E)
< ; something to do with the Analog input
---
> ;
> ; begin of const block at 0x0024(0x0048)
> ; OCD ID
> C0048:
> 	.db	0x41,0x56,0x52,0x4E,0x4F,0x43,0x44,0x00	; "AVRNOCD."
> ; end of const block at 0x0027(0x004F)
> ;
> ; begin of const block at 0x0028(0x0050)
> ; commands
> C0050:
> 	.db	0x00,0x20,0x01,0xF3,0x01,0xDC,0x01,0x11	; ". ......"
> 	.db	0xD8,0x01,0x01,0xD2,0x01,0x01,0xD4,0x01	; "........"
> 	.db	0x0F,0xCC,0x01,0x04,0xD6,0x01,0x01,0xD0	; "........"
> 	.db	0x01,0x0B,0xC6,0x01,0x01,0xCA,0x01,0x04	; "........"
> 	.db	0xC8,0x01,0x0B,0xBB,0x01,0x01,0xBB,0x01	; "........"
> 	.db	0x01,0xDF,0x01,0x0D,0xCE,0x01,0x07,0xDA	; "........"
> 	.db	0x01,0x28,0xE1,0x01,0x01,0xE3,0x01,0x01	; ".(......"
> 	.db	0xE5,0x01,0x01,0xE9,0x01,0x01,0xE7,0x01	; "........"
> 	.db	0x01,0xEB,0x01,0x1B,0xED,0x01,0x01,0xEF	; "........"
> 	.db	0x01,0x01,0xF1,0x01,0xFB,0x00	; "......"
> ; end of const block at 0x004E(0x009D)
> ;
> ; begin of const block at 0x004F(0x009E)
> ; write functions
> C009E:
> 	.db	0x62,0x01,0xCF,0x05,0x45,0x05,0x1F,0xA2	; "b...E..."
> 	.db	0x05,0x01,0xA7,0x05,0x04,0x9A,0x05,0x02	; "........"
> 	.db	0xA9,0x05,0x01,0xAB,0x05,0x01,0xAD,0x05	; "........"
> 	.db	0x01,0xC8,0x05,0x15,0x55,0x05,0x01,0x63	; "....U..c"
> 	.db	0x05,0x01,0x80,0x05,0x01,0x83,0x05,0x01	; "........"
> 	.db	0x88,0x05,0x01,0x8B,0x05,0x01,0x8E,0x05	; "........"
> 	.db	0x05,0xB0,0x05,0x01,0xB3,0x05,0x01,0xB6	; "........"
> 	.db	0x05,0x01,0xB9,0x05,0x01,0x6C,0x05,0x01	; ".....l.."
> 	.db	0x66,0x05,0x01,0x79,0x05,0x01,0x76,0x05	; "f..y..v."
> 	.db	0x02,0xBC,0x05,0x01,0xBF,0x05,0x01,0x5A	; ".......Z"
> 	.db	0x05,0x01,0xC2,0x05,0x01,0xC5,0x05,0xFB	; "........"
> ; end of const block at 0x007A(0x00F5)
> ;
> ; begin of const block at 0x007B(0x00F6)
> ; Read functions
> C00F6:
> 	.db	0x62,0x01,0x06,0x06,0xDB,0x05,0x18,0xE2	; "b......."
> 	.db	0x05,0x01,0xE5,0x05,0x06,0xFB,0x05,0x01	; "........"
> 	.db	0xFF,0x05,0x02,0xE7,0x05,0x02,0xEA,0x05	; "........"
> 	.db	0x01,0x01,0x06,0x20,0xEE,0x05,0x01,0xF1	; "... ...."
> 	.db	0x05,0x01,0xF4,0x05,0x01,0xF8,0x05,0x09	; "........"
> 	.db	0x03,0x06	; ".."
> ; end of const block at 0x008F(0x011F)
> ;
> ; begin of const block at 0x0090(0x0120)
> ; Init addresses
> C0120:
> 	.db	0xFB,0x00,0x14,0x03,0x69,0x00,0x00,0x00	; "....i..."
> 	.db	0x00,0x09,0x00,0x60,0x00,0x8E,0x2D,0x00	; "...`..-."
> ; end of const block at 0x0097(0x012F)
> ;
543,552c394,398
< 	; Enable 32 divide clock
< 	ldi	r16,1 << ADEN | 1<< ADIE | 1<< ADPS2 | 1<<ADPS0	; k8D
< #ifdef _M163DEF_INC_
< 	out	ADCSRA,r16		; 0b10001101
< 
< 	ldi	r16,VTargMUX
< 	rcall	L00A2		; channel 2 start conversion
< 				
< 						; timer setup 
< 	ldi	r16,1 << CS02	;k04 /256 clock
---
> 	ldi	r16,k8D
> 	out	ADCSR,r16
> 	ldi	r16,k02
> 	rcall	L00A2
> 	ldi	r16,k04
555c401
< 	ori	r16,1<<TOIE0	; k01
---
> 	ori	r16,k01
557,572d402
< #endif
< #ifdef _M169DEF_INC_
< 	sts	ADCSRA,r16		; Turn on the ADC
< 
< 	; This is the largest change to the code becouse the
< 	; butterfly hardware connects the LDR between VCP and
< 	; PF3 with PF3 driving the AREF
< 	ldi r16,VTargMUX	; channel 1 
< 	rcall	L00A2		; start conversion
< 	
< 	ldi	r16,1 << CS02	;k04 /256 clock
< 	out	TCCR0A,r16
< 	lds  r16,TIMSK0
< 	ori	r16,1<<TOIE0	; k01
< 	sts TIMSK0,r16
< #endif
577,590c407,408
< #ifdef _M163DEF_INC_
< 	out	ADMUX,r16		
< 	sbi	ADCSR,ADSC		; Start conversion
< #endif
< #ifdef _M169DEF_INC_
< 	; turn on PF3
< 	sbi PORTF,PORTF3
< 
< 	sts	ADMUX,r16		; PF1 (PF2 is LDR)
< 	
< 	lds r16,ADCSRA
< 	sbr r16,1<<ADSC
< 	sts	ADCSRA,r16		; Start conversion
< #endif
---
> 	out	ADMUX,r16
> 	sbi	ADCSR,b6
592d409
< 
595,597c412,413
< L00A5:					; check power and return saved conversion
< 						; results
< 	sbis	VTARGPIN,TGP_ON	; TGP_ON
---
> L00A5:
> 	sbis	PIND,b3
601d416
< 
605,606c420,421
< 	ldi	ZL,low(D006B)	; D006B
< 	ldi	ZH,high(D006B)
---
> 	ldi	r30,k6B
> 	ldi	r31,k00
609,610c424
< #ifdef _M163DEF_INC_
< 	lsr	r17				; shift two bits for normalise
---
> 	lsr	r17
614,629d427
< #endif
< #ifdef _M169DEF_INC_
< 	; the LDR affects the VREF reading so we need to read the LDR
< 	; and use a table (see butterfly code) to get the correct voltage
< 	; ref.
< ; 	cli
< 
< ;	lsr	r17				; shift two bits for normalise
< ;	ror	r16
< ;	lsr	r17
< ;	ror	r16
< ;	lsr	r17
< ;	ror	r16
< 
< 
< #endif
633,643c431,439
< 
< L00B2:					; ADC handler
< 	st	-Y,ZH			; protect registers
< 	st	-Y,ZL
< 	rcall	L00E0		; save stack frame
< 	in	r21,SREG		; save status state
< 	in	r22,iMSK
< 	ldi	r16,k00
< 	out	iMSK,r16		; disallow external ints
< #ifdef _M163DEF_INC_
< 	in	r16,ADCL		; capture the sample
---
> L00B2:
> 	st	-Y,r31
> 	st	-Y,r30
> 	rcall	L00E0
> 	in	r21,SREG
> 	in	r22,GIMSK
> 	ldi	r16,k00
> 	out	GIMSK,r16
> 	in	r16,ADCL
645,651c441,442
< #endif
< #ifdef _M169DEF_INC_
< 	lds	r16,ADCL		; capture the sample
< 	lds	r17,ADCH
< #endif
< 	ldi	ZL,low(d0069)	; conversion sum defined at L0091
< 	ldi	ZH,high(d0069)
---
> 	ldi	r30,k69
> 	ldi	r31,k00
657,660c448,450
< 	std	Z+o01,r19		; sum conversion result
< 
< 	ldi	ZL,low(d006D)	; conversion index counter
< 	ldi	ZH,high(d006D)
---
> 	std	Z+o01,r19
> 	ldi	r30,k6D
> 	ldi	r31,k00
664,708c454,456
< 
< 	cpi	r16,k08	
< #ifdef _M163DEF_INC_
< 	brne L00DA			; collect 8 samples
< 
< 	mov	r16,r18			; conversion sum
< 	mov	r17,r19
< 	ldi	r20,k03			; 
< 	call	L146D		; average 8 samples
< 	
< 	ldi	ZL,low(D006B)	; D006B
< 	ldi	ZH,high(D006B)
< 	std	Z+o00,r16
< 	std	Z+o01,r17
< 
< #endif	
< #ifdef _M169DEF_INC_
< 	brne	JADC8		; collect 8 samples
< 
< 	mov	r16,r18			; conversion sum
< 	mov	r17,r19
< 	ldi	r20,k03			; 
< 	call	L146D		; average 8 samples
< 
< 	ldi	ZL,low(M041D)	; hold for later conversion
< 	ldi	ZH,high(M041D)	; target power
< 	std	Z+o00,r16
< 	std	Z+o01,r17
< 
< 	ldi	r16,k00			; clear index
< ;	sts	D006D,r16		; let index count to 16
< 	
< 	ldi	ZL,low(d0069)	; the structure
< 	ldi	ZH,high(d0069)	; clear sample sum
< 	std	Z+o00,r16
< 	std	Z+o01,r16
< 
< 	rjmp L00DA
< 
< JADC8:
< 	cpi	r16,16
< 	breq PC+2
< 	rjmp L00DA			; collect 8 samples of LDR VREF
< 
< 	mov	r16,r18			; conversion sum
---
> 	cpi	r16,k08
> 	brne	L00DA
> 	mov	r16,r18
710,915c458,461
< 	ldi	r20,k03			; 
< 	call	L146D		; average 8 samples
< 
< 	ldi r19,0			; for compare
< 	mov r18,r19
< 
< ; 	search the 22 word table for LDR vref value
< 	ldi r20,0x35		;0x35, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E001			; positive
< 	inc r18
< 	ldi r20,0x2B	;0x35, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E001			; positive
< 	inc r18
< 	ldi r20,0x20	;0x60, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E001			; positive
< 	inc r18
< 	ldi r20,0x30	;0x80, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E001			; positive
< 	inc r18
< 	ldi r20,0x6D	;0x0B0, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E001			; positive
< 	inc r18
< 	ldi r20,0x20	;0x11D, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E001			; positive
< 	inc r18
< 	ldi r20,0x1D	;0x13D, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E001			; positive
< 	inc r18
< 	ldi r20,0x20	;0x15A, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E001			; positive
< 	inc r18
< 	ldi r20,0x1D	;0x17A, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E001			; positive
< 	rjmp E010
< E001:
< 	rjmp E000
< E010:
< 	inc r18
< 	ldi r20,0x22	;0x197, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E000			; positive
< 	inc r18
< 	ldi r20,0x21	;0x1B9, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E000			; positive
< 	inc r18
< 	ldi r20,0x1F	;0x1DA, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E000			; positive
< 	inc r18
< 	ldi r20,0x1D    ;0x1F9, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E000			; positive
< 	inc r18
< 	ldi r20,0x2A	;0x216, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E000			; positive
< 	inc r18
< 	ldi r20,0x2D	;0x240,	
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E000			; positive
< 	inc r18
< 	ldi r20,0x15	;0x26D,	
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E000			; positive
< 	inc r18
< 	ldi r20,0x20	;0x282,	
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E000			; positive
< 	inc r18
< 	ldi r20,0x4D	;0x2A2, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E000			; positive
< 	inc r18
< 	ldi r20,0x43	;0x2EF, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E000			; positive
< 	inc r18
< 	ldi r20,0x7E	;0x332, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E000			; positive
< 	inc r18
< 	ldi r20,0x42	;0x3B0, 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E000			; positive
< 	inc r18
< 	ldi r20,0x0D	;0x3F2 
< 	sub r16,r20	
< 	sbc r17,r19
< 	brcs E000			; positive
< 	inc r18
< E000: 
< 	st	-Y,r0
< 	st	-Y,r1
<  	; r18 contains voltage table
<  
< ;	get the Vref fixed point from table
< 	ldi	ZL,low(VTABL*2)		; sampled voltage
< 	ldi	ZH,high(VTABL*2)	; target power
< 
< 	lsl r18
< 	rol r19
< 
< 	add ZL,r18
< 	adc ZH,r19
< 	lpm
< 	mov r16,r0
< 	adiw ZL,1
< 	lpm
< 	mov r17,r0				; r16pair is Vref adjust from the table
< 	; 2.815
< 	;x847   0x848 0x84B
<     ;2.818,2.820,2.824,2.827,2.832,2.835,2.839,2.841,2.843,2.847,2.850,
<     ;2.853,2.857,2.863,2.867,2.870,2.874,2.882,2.893,2.917,2.939
< ; 0x8A2
< 	; 2942
< ;	multiply the voltage by the Vref table entry
< 	ldi	ZL,low(M041D)	; sampled voltage
< 	ldi	ZH,high(M041D)	; target power
< 	ldd	r20,Z+o00
< 	ldd	r19,Z+o01
< 
< 	clr r18
< 
< 	; 16 bit mpy
< 	mul r16,r20		; l x l
< 	mov ZL,r0		; temp reg
< 	mov ZH,r1
< 	mul r17,r20		; h x l
< 	add ZH,r0
< 	adc r18,r1
< 	mul r16,r19		; l x h
< 	add ZH,r0
< 	adc r18,r1
< 	mul r17,r19		; h x h
< 	add r18,r0
< ;	ldi ZL,0		; >> 8
< ;	adc ZL
< 
< 	swap ZH			; >> 4
< 	andi ZH,0x0F
< 	swap r18
< 	mov ZL,r18
< 	andi r18,0xF0
< 	or r18,ZH		; r18 is >> 4
< 	andi ZL,0x0F	;
< 
< 	lsr ZL
< 	ror r18
< 	lsr ZL
< 	ror r18			; ZL is voltage ZH is fracton
< 
< 	; r18 needs correction for fixed point
< 	ldi ZL,6
< 	mul r18,ZL
< 	
< 	; r0 = fraction r1,voltage
< 
< 	mov r16,r1 ; voltage
< 	mov r17,r0 ; fraction
< 
< 	ldi r19,42
< 	mul r16,r19
< 	mov r16,r0	; voltage base
< 
< 	mul r17,r19	; fraction
< 	
< 	lsr r1		; fraction / 1024
< 	lsr r1
< 
< 	add r16,r1  ; corrected voltage return
< 
< 	clr r17
< 
< 	ldi	ZL,low(D006B)	; D006B
< 	ldi	ZH,high(D006B)
---
> 	ldi	r20,k03
> 	call	L146D
> 	ldi	r30,k6B
> 	ldi	r31,k00
918,938c464,467
< 
< 
< ;	back divide it by 1024
< 
< 
< ;	restore by 6
< ;	voltage is in bcd format
< 
< 	ld	r1,Y+
< 	ld	r0,Y+
< 
< 
< 		
< 	cbi PORTF,PORTF3	; turn off PF3
< #endif
< 
< 	ldi	r16,k00			; clear index
< 	sts	D006D,r16		
< 	
< 	ldi	ZL,low(d0069)	; the structure
< 	ldi	ZH,high(d0069)	; clear sample sum
---
> 	ldi	r16,k00
> 	sts	D006D,r16
> 	ldi	r30,k69
> 	ldi	r31,k00
941d469
< 
943,944c471,472
< 	out	iMSK,r22		; note bit change
< 	out	SREG, r21
---
> 	out	GIMSK,r22
> 	out	SREG,r21
946,947c474,475
< 	ld	ZL,Y+
< 	ld	ZH,Y+
---
> 	ld	r30,Y+
> 	ld	r31,Y+
949d476
< 
952c479
< L00E0:					; ADC Cstack frameworks
---
> L00E0:
974,975c501
< 
< L00F0:					; timer 0 overflow?
---
> L00F0:
985c511
< 	rcall	L00E0		; frame store
---
> 	rcall	L00E0
987c513
< 	in	r25,iMSK
---
> 	in	r25,GIMSK
989c515
< 	out	iMSK,r16		; disable masked ints
---
> 	out	GIMSK,r16
993,994c519,520
< 	ldi	ZL,low(D006E)	; k6E
< 	ldi	ZH,high(D006E)	; k00
---
> 	ldi	r30,k6E
> 	ldi	r31,k00
998,1012c524,526
< #ifdef _M163DEF_INC_
< 	ldi	r16,VTargMUX
< #endif
< #ifdef _M169DEF_INC_
< 	lds r16,d006D		; get the counter
< 	sbrs r16,b3
< 	rjmp XVTGC
< 	ldi	r16,LDRMUX		; read the LDR when counter > 7
< 	rjmp XVTGE
< XVTGC:
< 	ldi	r16,VTargMUX	; read the target mux
< XVTGE:
< #endif
< 	rcall	L00A2		; kick the ADC MUX
< 	out	iMSK,r25
---
> 	ldi	r16,k02
> 	rcall	L00A2
> 	out	GIMSK,r25
1014c528
< 	rcall	L00E8		; restore framework
---
> 	rcall	L00E8
1025d538
< 
1028c541
< L0115:					; set wait timer
---
> L0115:
1033d545
< 
1035c547
< ;						; Write EE memory
---
> ;
1037,1044c549,556
< 	sbic EECR,EEWE
< 	rjmp L011A
< 	ldi	 r19,k00
< 	out	 EEARH,r19
< 	out	 EEARL,r16
< 	out	 EEDR,r17
< 	sbi	 EECR,EEMWE
< 	sbi	 EECR,EEWE
---
> 	sbic	EECR,b1
> 	rjmp	L011A
> 	ldi	r19,k00
> 	out	EEARH,r19
> 	out	EEARL,r16
> 	out	EEDR,r17
> 	sbi	EECR,b2
> 	sbi	EECR,b1
1046d557
< 
1048c559
< ;						; Read EE memory
---
> ;
1050,1056c561,567
< 	sbic EECR,EEWE		; wait for write 
< 	rjmp L0123			; to clear
< 	ldi	 r17,k00
< 	out	 EEARH,r17		; low page
< 	out	 EEARL,r16		; parameter address
< 	sbi	 EECR,EERE		; read enable
< 	in	 r16,EEDR
---
> 	sbic	EECR,b1
> 	rjmp	L0123
> 	ldi	r17,k00
> 	out	EEARH,r17
> 	out	EEARL,r16
> 	sbi	EECR,b0
> 	in	r16,EEDR
1058d568
< 
1062,1068c572,576
< 	ldi	r16,kBaud19200	; kBaud19200 23		
< 	call	L13DC		; init uart
< 
< 	ldi	r16,kF9			; 0b11111001
< 						; PA1 and PA2
< 	out	DDRA,r16		; setup port io directions
< 	ldi	r16,k00			; and pin state
---
> 	ldi	r16,k17
> 	call	L13DC
> 	ldi	r16,kF9
> 	out	DDRA,r16
> 	ldi	r16,k00
1070,1093c578,590
< 
< 	; port B setup -> JTAG Header 
< 	; TCK> | !TDO< | TDI> | !nsRST |
< 	; LED  | NC    | TMS> | NC	
< 
< 	ldi	r16,JTAGDDRMSK 
< 	out	JTAGDDR,r16 
< 	cbi	RESETPORT,nSRST	;b4	
< 	sbi	RESETPORT,nSRST
< 	
< 
< #ifdef _M163DEF_INC_
< 	ldi	r16,HWREVDDRMSK	; low nybble of c is pulled down
< 	out	HWREVDDR,r16
< 	ldi	r16,k00
< 	out	HWREVPORT,r16
< #endif
< 	
< 	ldi	r16,VTARGDDRMSK	; 0b1011000
< 	out	VTARGDDR,r16	; OC2|OC1A|OC1B
< 	ldi	r16,k00
< 	out	VTARGPORT,r16
< 
< 	call	L0098		; init ADC
---
> 	ldi	r16,kAA
> 	out	DDRB,r16
> 	cbi	PORTB,b4
> 	sbi	PORTB,b4
> 	ldi	r16,kF0
> 	out	DDRC,r16
> 	ldi	r16,k00
> 	out	PORTC,r16
> 	ldi	r16,kB0
> 	out	DDRD,r16
> 	ldi	r16,k00
> 	out	PORTD,r16
> 	call	L0098
1098d594
< 
1101,1106c597,601
< L0144:					; init signon
< 	;called from L145F
< 	rcall L0206    		; push C word framework	
< 	rcall L04E4			; init sign on message
< 	ldi	  r16,k0A		; Wait timer
< 	call  L0115			; set wait timer
---
> L0144:
> 	rcall	L0206
> 	rcall	L04E4
> 	ldi	r16,k0A
> 	call	L0115
1108,1117c603,609
< 	rcall	L0209		; test wait timer		; test timer
< 	brne	L0149		; delay loop
< 	
< 	ldi	r16,k00
< 	call	L0123		; read address 0 of EEPROM
< 	call	L0A79		; negate and save at D018A
< 	call	L0841		; TAP Init
< 
< ; this looks like the struct needs to be aligned onto a byte boundry
< 	ldi	r24,k00			; init MCU_mode
---
> 	rcall	L0209
> 	brne	L0149
> 	ldi	r16,k00
> 	call	L0123
> 	call	L0A79
> 	call	L0841
> 	ldi	r24,k00
1120,1134c612,622
< 	rcall	L020D		; get byte from array at D0080
< ; fails here this is the top of table
< 	cpi	r25,k01 ;high(D0080+0x100)	;k01			
< 	brcs	L0154		; hold til r25 clear
< 
< 
< L0157:					; top of polling loop
< 	lds	 r17,D0074
< 	in	 r16,VTARGPIN
< 	andi r16,1 << TGP_ON; k08	 
< 	eor	 r16,r17
< 	breq L0170
< 
< 	ldi	 r16,k18		; delay value, sample ADC
< 	call L0115			; set wait timer
---
> 	rcall	L020D
> 	cpi	r25,k01
> 	brcs	L0154
> L0157:
> 	lds	r17,D0074
> 	in	r16,PIND
> 	andi	r16,k08
> 	eor	r16,r17
> 	breq	L0170
> 	ldi	r16,k18
> 	call	L0115
1136,1155c624,639
< 	rcall L0209			; test wait timer			; test timer
< 	brne  L0160
< 
< 	sbic  VTARGPIN, TGP_ON
< 	rjmp  L0170			; No target power
< 	; have target power
< 
< 	ldi	  r17,k00		
< 	ldi	  r16,k08		; 
< 	call  L07D1         ; JTAG Command			
< 	call  L0841			; bang JTAG
< 	ldi	  r16,k01
< 	sts	  D0076,r16		; save target power state
< 	rcall L0214			; test D02AC is this the JTAG reply flag?
< 	breq  L0170
< 	rcall L01F5			; may be main TAP communications routine
< 
< L0170:					; no state change
< 	in	 r16,VTARGPIN
< 	andi r16,1 << TGP_ON;k08
---
> 	rcall	L0209
> 	brne	L0160
> 	sbic	PIND,b3
> 	rjmp	L0170
> 	ldi	r17,k00
> 	ldi	r16,k08
> 	call	L07D1
> 	call	L0841
> 	ldi	r16,k01
> 	sts	D0076,r16
> 	rcall	L0214
> 	breq	L0170
> 	rcall	L01F5
> L0170:
> 	in	r16,PIND
> 	andi	r16,k08
1157,1173c641
< 	
< ; main poll for power pin state change
< #ifdef _M169DEF_INC_
< 	; r16 and flags still contain power state will be
< 	; zero if power is off
< 	brne X0174
< 	lds r16,LCDDR0
< 	ori r16,1<<LCD_AN3	; set the target power annuciator
< 	sts LCDDR0,r16
< 	rjmp X0174A
< X0174:
< 	lds r16,LCDDR0
< 	cbr r16,1<<LCD_AN3	; clear the target power annuciator
< 	sts LCDDR0,r16
< X0174A:
< #endif
< 	lds	r16,D0080		; MCU Mode  & a large array
---
> 	lds	r16,D0080
1176,1177c644
< 	rjmp	L01BB		; Wait next byte
< 
---
> 	rjmp	L01BB
1179,1180c646,647
< 	rcall	L0218		; single step
< 	sbrs	r16,b0	
---
> 	rcall	L0218
> 	sbrs	r16,b0
1186,1187c653
< 
< L017F:					; print sleep
---
> L017F:
1190,1191c656
< 	breq	L018B		; to print power
< 	; will print sleep
---
> 	breq	L018B
1193,1194c658,659
< 	ldi	r16,k48			; sleep
< 	rcall	putchar1    ; L01FC
---
> 	ldi	r16,k48
> 	rcall	L01FC
1196,1200c661,664
< 	rcall	putchar1    ; L01FC
< 	rcall	L01FB		;transmit ACK
< 
< L018B:					; print power
< 	rcall	L0226		; deref r16 = *D007F
---
> 	rcall	L01FC
> 	rcall	L01FB
> L018B:
> 	rcall	L0226
1204c668
< 	rjmp	L0191		
---
> 	rjmp	L0191
1207,1208c671
< 
< L0191:					
---
> L0191:
1211,1212c674
< 	breq	L019D		; to print IDR
< 	; will print power
---
> 	breq	L019D
1214,1215c676,677
< 	ldi	r16,k49			; Power
< 	rcall	putchar1    ; L01FC
---
> 	ldi	r16,k49
> 	rcall	L01FC
1217,1221c679,682
< 	rcall	putchar1    ; L01FC
< 	rcall	L01FB		;transmit ACK
< 
< L019D:					; print IRD
< 	rcall	L0226		; deref r16 = *D007F
---
> 	rcall	L01FC
> 	rcall	L01FB
> L019D:
> 	rcall	L0226
1223,1231c684,689
< 	rjmp	L01A6		; to print Break
< 
< 	; will print IDR
< 	ldi	r16,k47			; Info
< 	rcall	putchar1	; L01FC
< 	call	L1023		; IDR dirty
< 	rcall	putchar1    ; L01FC
< 	rcall	L01FB		; transmit ACK
< 
---
> 	rjmp	L01A6
> 	ldi	r16,k47
> 	rcall	L01FC
> 	call	L1023
> 	rcall	L01FC
> 	rcall	L01FB
1236,1238c694
< 	brne	L01B6		; to exit
< 
< 	; will print Break
---
> 	brne	L01B6
1242,1244c698,700
< 	ldi	r16,k42			; Break
< 	rcall	putchar1    ; L01FC
< 	rcall	L022A		; Resp_Break H
---
> 	ldi	r16,k42
> 	rcall	L01FC
> 	rcall	L022A
1246,1249c702,704
< 	rcall	putchar1    ; L01FC
< 	rcall	L022A		; Resp_Break L
< 	rcall	putchar1    ; L01FC
< 
---
> 	rcall	L01FC
> 	rcall	L022A
> 	rcall	L01FC
1252c707
< 	call	L0115		; set wait timer
---
> 	call	L0115
1254c709
< 	rcall	L0209		; test wait timer
---
> 	rcall	L0209
1256,1257d710
< 
< 
1259c712
< 	call	L144D		; is ring empty?
---
> 	call	L144D
1261,1271c714,720
< 	brne	L01C0		; no
< 	rjmp	L0157		; loop back to main event loop
< 
< 
< L01C0:					; there is data in the ring
< 	call	_getchar    ;  L142A
< 	ldi	ZL,low(L0028*2)	; k50 table 1 L0028
< 	ldi	ZH,high(L0028*2)
< 	jmp	L14E8			; derefrence from table and ijmp
< 
< J01C6:					; Read Memory
---
> 	brne	L01C0
> 	rjmp	L0157
> L01C0:
> 	call	L142A
> 	ldi	r30,k50
> 	ldi	r31,k00
> 	jmp	L14E8
1273,1274c722
< 	rjmp	L01BB		
< J01C8:					; Write Memory
---
> 	rjmp	L01BB
1277d724
< J01CA:					; Get Sign on	
1280d726
< J01CC:					; Set_Parameter
1283,1284c729
< J01CE:					; 0x71 Get Parameter
< 	rcall	L05D3		; parse input
---
> 	rcall	L05D3
1286d730
< J01D0:					; Go
1289d732
< J01D2:					; Read_PC
1292d734
< J01D4:					; Write_PC
1295d736
< J01D6:					; Forced Stop	
1298d738
< J01D8:					; Single_Step	
1301d740
< J01DA:					; Reset
1304,1305c743
< J01DC:					; GET_Sync
< 	ldi	r16,k41			; Resp_OK
---
> 	ldi	r16,k41
1307c745
< 	rcall	putchar1    ;  L01FC		; putchar
---
> 	rcall	L01FC
1309d746
< J01DF:					; Get Debug info
1312d748
< J01E1:					; Set Device Descriptor
1315d750
< J01E3:					; Erase Page SPM
1318d752
< J01E5:					; Firmware Upgrade
1321d754
< J01E7:					; Leave Program Mode
1324d756
< J01E9:					; Enter Program Mode
1327d758
< J01EB:					; Chip Erase
1330d760
< J01ED:					; undoc 0xC0
1333d762
< J01EF:					; undoc 0xC1
1336d764
< J01F1:					; undoc 0xC2
1339,1344c767,768
< J01F3:
< 	ldi	r16,k45			; Sync_Err
< 	rjmp	L01DD		; exit via putchar
< 
< 
< 
---
> 	ldi	r16,k45
> 	rjmp	L01DD
1346,1347c770,771
< 	call	L0D8E		; 3 arguments
< 	ldi	r16,k01			; part of read mem write mem
---
> 	call	L0D8E
> 	ldi	r16,k01
1352,1360c776,780
< ; from L0796
< 
< L01FB:					; issue an ACK
< 	ldi	r16,'A'			; Resp_OK
< putchar1:      			; L01FC  GP xmit putchar() 
< 	ldi	r17,k00
< 	jmp	_putchar        ; L143C	 transmit byte from ring
< 
< 
---
> L01FB:
> 	ldi	r16,k41
> L01FC:
> 	ldi	r17,k00
> 	jmp	L143C
1364c784
< 	rcall	L022D		; get word
---
> 	rcall	L022D
1366c786
< 	rcall	L0796		; get sync eop
---
> 	rcall	L0796
1369d788
< 
1372c791
< L0206:    ;  push C word framework:
---
> L0206:
1376d794
< 
1379,1380c797,798
< L0209:					; test wait timer
< 	lds	r16,D006E		; timer
---
> L0209:
> 	lds	r16,D006E
1383d800
< 
1386,1392c803,809
< L020D:					; ser D0080 array instance
< 	ldi	  r16,kFF
< 	mov	  ZL,r24
< 	mov	  ZH,r25
< 	rcall L0234			; get D0080 SRAM address
< 	std	  Z+o00,r16
< 	adiw  r24,k01
---
> L020D:
> 	ldi	r16,kFF
> 	mov	r30,r24
> 	mov	r31,r25
> 	rcall	L0234
> 	std	Z+o00,r16
> 	adiw	r24,k01
1394d810
< 
1401d816
< 
1405c820
< 	call	L0D62		; check Vtarget and stuff
---
> 	call	L0D62
1414d828
< 
1418,1421c832,834
< 
< L0226:		; deref r16 = *D007F:		; deref r16 = *D007F
< 	ldi	ZL,low(D007F)	; P007F
< 	ldi	ZH,high(D007F)
---
> L0226:
> 	ldi	r30,k7F
> 	ldi	r31,k00
1429d841
< 
1431,1432c843
< 	call	_getchar        ;  L142A
< L022F:
---
> 	call	L142A
1434,1435c845
< 	jmp	_getchar        ;  L142A
< 
---
> 	jmp	L142A
1437,1439c847,848
< 	mov	ZL,r6
< 	mov	ZH,r7
< 
---
> 	mov	r30,r6
> 	mov	r31,r7
1441,1442c850,851
< 	subi ZL,low(0xFFFF-D0080)	;k7F
< 	sbci ZH,high(0xFFFF-D0080)	;kFF
---
> 	subi	r30,k7F
> 	sbci	r31,kFF
1444d852
< 
1447,1449c855,857
< L0237:					; Read Memory
< 	call	L1538		; c frame
< 	rcall	L032A		; Z = P02A9	= flash page size
---
> L0237:
> 	call	L1538
> 	rcall	L032A
1454,1455c862,863
< 	rcall	L032D		; add -1
< 	rcall	L0331		; test D018D
---
> 	rcall	L032D
> 	rcall	L0331
1457c865
< 	rcall	L0335		; test D0075
---
> 	rcall	L0335
1459c867
< 	rcall	L01F5		; beleived to init TAP
---
> 	rcall	L01F5
1462c870
< 	call	_getchar    ; L142A	Memory type
---
> 	call	L142A
1464c872
< 	call	_getchar    ; L142A	word count-1
---
> 	call	L142A
1466,1468c874,876
< 	call	_getchar    ; L142A	Start address
< 	call	_getchar    ; L142A
< 	rcall	L0322		; last byte of address and Sync/EOP
---
> 	call	L142A
> 	call	L142A
> 	rcall	L0322
1470c878
< 	rjmp	L030B		; dud command
---
> 	rjmp	L030B
1472,1473c880,881
< 	rcall	L0218		; TAP access 
< 	rcall	L0339		; r24:27 = r8:9 clears X
---
> 	rcall	L0218
> 	rcall	L0339
1475,1476c883
< 
< L0255:					; loop from OSCCAL_JTAG
---
> L0255:
1478c885
< 	call	L13D3		; very complex
---
> 	call	L13D3
1481d887
< 
1484,1486c890,891
< 	rcall	putchar1    ; L01FC
< 	rcall	L0342		; ; dword at r24 throuh XL +1
< 
---
> 	rcall	L01FC
> 	rcall	L0342
1488,1489c893,894
< 	mov	r16,r11			; wordcount -1
< 	rcall	L0318		; r16:18 += page size compared to dword @ r24:28 (XH) 
---
> 	mov	r16,r11
> 	rcall	L0318
1492d896
< 
1494c898
< 	rcall	L031E		; test MCU Mode
---
> 	rcall	L031E
1496c900
< 	rcall	L0226		; deref r16 = *D007F
---
> 	rcall	L0226
1499,1500c903
< 
< 	andi	r16,k06		; r16 still has the *D007F flags
---
> 	andi	r16,k06
1502,1503c905
< 
< L0267:					; top of mem model loop
---
> L0267:
1505c907
< 	cp	r10,r16			; Flash JTAG
---
> 	cp	r10,r16
1507,1508c909,910
< 	ldi	r16,kA0			
< 	cp	r10,r16			; PML
---
> 	ldi	r16,kA0
> 	cp	r10,r16
1511c913
< 	rcall	putchar1    ;  L01FC
---
> 	rcall	L01FC
1518d919
< 
1520,1521c921,922
< 	mov	r16,r10			; Mem parameter
< 	subi	r16,k90		; Break Reg
---
> 	mov	r16,r10
> 	subi	r16,k90
1523,1524c924
< 	rjmp	L02BE		; read break reg
< 
---
> 	rjmp	L02BE
1526,1529c926,928
< 	subi	r16,k10		; A0 == PML
< 	breq	L02B2		; autostep soft  function caller ?
< 	
< 	subi	r16,k10		; B0 == FLASH_JTAG
---
> 	subi	r16,k10
> 	breq	L02B2
> 	subi	r16,k10
1532d930
< 
1534c932
< 	dec	r16				; B1 == EEPROM_JTAG
---
> 	dec	r16
1537d934
< 
1539c936
< 	dec	r16				; B2 == FUSE_JTAG
---
> 	dec	r16
1542,1544c939,940
< 
< L0283:					
< 	dec	r16				; B3 == LOCK_JTAG
---
> L0283:
> 	dec	r16
1547d942
< 
1549c944
< 	dec	r16				; B4 == SIGN_JTAG
---
> 	dec	r16
1552d946
< 
1554c948
< 	dec	r16				; B5 == OSCCAL_JTAG
---
> 	dec	r16
1556,1557c950
< 
< 	subi	r16,k6B		; 20 == SRAM
---
> 	subi	r16,k6B
1559,1560c952
< 
< 	subi	r16,k02		; 22 = Eeprom
---
> 	subi	r16,k02
1562,1563c954
< 
< 	subi	r16,k0E		; 30 = IO Shadow
---
> 	subi	r16,k0E
1565,1568c956,957
< 
< 	rjmp	L0259		; into loop
< 
< L0292:					; read SRAM
---
> 	rjmp	L0259
> L0292:
1582d970
< 
1586c974
< 	rcall	L0313		; c compare func
---
> 	rcall	L0313
1592c980
< 	rcall	L033F       ;  r16:17 = r24:25
---
> 	rcall	L033F
1595,1597c983,984
< 
< L02AB:					; Read Eeprom
< 	rcall	L033F       ; r16:17 = r24:25
---
> L02AB:
> 	rcall	L033F
1600,1601c987
< 						
< L02AF:					; Read IO Shadow
---
> L02AF:
1605,1609c991,994
< 
< L02B2:					; Read PML soft function caller
< 	rcall	L033F       ;  r16:17 = r24:25
< 	ldi	ZL,low(P0063)	; P0063
< 	ldi	ZH,high(P0063)	; something to do with autostep maybe
---
> L02B2:
> 	rcall	L033F
> 	ldi	r30,k63
> 	ldi	r31,k00
1615d999
< 
1621c1005
< 	rcall	putchar1    ; L01FC
---
> 	rcall	L01FC
1623,1624c1007
< 
< L02BE:					; Read Break Reg
---
> L02BE:
1628,1633c1011,1015
< 
< L02C2:					; Read FLASH_JTAG
< 	rcall	L033F       ;  r16:17 = r24:25 = 0
< 	mov	r18,XL			; X is 0x80 (flash page size)
< 	mov	r19,XH
< 	rcall	L034C		; X >> 1 into r20
---
> L02C2:
> 	rcall	L033F
> 	mov	r18,r26
> 	mov	r19,r27
> 	rcall	L034C
1636c1018
< 	call	L14AE		; 30 bit shifts
---
> 	call	L14AE
1641,1646c1023,1026
< 
< 	rcall	L033E		; inc r18
< 	call	L1292		; fails inside this routine
< 	rcall	L0353		; device ID pointer at P006F
< 
< 	rcall	L0356		; read dword at Y
---
> 	rcall	L033E
> 	call	L1292
> 	rcall	L0353
> 	rcall	L0356
1679c1059
< 	rcall	putchar1    ; L01FC
---
> 	rcall	L01FC
1685,1687c1065,1066
< 
< L02F4:					; Read EEPROM_JTAG
< 	rcall	L033F       ; r16:17 = r24:25
---
> L02F4:
> 	rcall	L033F
1690,1691c1069
< 
< L02F8:					; Read FUSE_JTAG
---
> L02F8:
1697,1698c1075
< 
< L02FD:					; Read LOCK_JTAG
---
> L02FD:
1702,1703c1079
< 
< L0300:					; Read SIGN_JTAG
---
> L0300:
1707,1708c1083
< 
< L0304:					; Exit read loop
---
> L0304:
1717c1092
< 	rcall	putchar1    ;  L01FC
---
> 	rcall	L01FC
1721d1095
< 
1728,1729c1102
< 	rjmp	putchar1    ;  L01FC
< 
---
> 	rjmp	L01FC
1736d1108
< 
1738c1110
< 	rcall	L035C		; r16:17 += r8:9 r18 = 0
---
> 	rcall	L035C
1754c1126
< 	call	_getchar        ;  L142A
---
> 	call	L142A
1757c1129
< 	rcall	L0796			; get sync EOP
---
> 	rcall	L0796
1763,1764c1135,1136
< 	ldi	ZL,low(P02A9)	; P02A9
< 	ldi	ZH,high(P02A9)
---
> 	ldi	r30,kA9
> 	ldi	r31,k02
1798c1170
< L033F:      ;  r16:17 = r24:25:
---
> L033F:
1830,1832c1202,1203
< L0351:					; get the JTAGID Bytes
< 	call	L0D4C		; called to access Byte 0 and bang JTAG
< 						; 
---
> L0351:
> 	call	L0D4C
1834,1835c1205,1206
< 	ldi	ZL,low(P006F)	; k6F P006F
< 	ldi	ZH,high(P006F)
---
> 	ldi	r30,k6F
> 	ldi	r31,k00
1849d1219
< 
1859,1860c1229,1230
< 	ldi	r18,low(D0080+1)	; k81
< 	ldi	r19,high(D0080+1)	; k00
---
> 	ldi	r18,k81
> 	ldi	r19,k00
1864,1869c1234,1239
< L0364:					; Write Memory
< 	call	L1538		; C frame
< 	lds	r12,D02AB		; Get EEPAGE size
< 	rcall	L0487		; init r6:r7
< 	rcall	L032A		; get pointer to flash page size
< 	ldd	r4,Z+o00		; de reference it
---
> L0364:
> 	call	L1538
> 	lds	r12,D02AB
> 	rcall	L0487
> 	rcall	L032A
> 	ldd	r4,Z+o00
1871c1241
< 	rcall	L0331		; test D018D
---
> 	rcall	L0331
1875c1245
< 	rcall	L01F5		; belived to init TAP
---
> 	rcall	L01F5
1877c1247
< 	call	_getchar    ;  L142A memory type
---
> 	call	L142A
1879c1249
< 	call	_getchar    ;  L142A word count
---
> 	call	L142A
1881,1883c1251,1253
< 	call	_getchar    ;  L142A start address HB
< 	call	_getchar    ;  L142A start address MB
< 	rcall	L0322		; last part of mem and Sync/EOP
---
> 	call	L142A
> 	call	L142A
> 	rcall	L0322
1887,1888c1257,1258
< 	call	_getchar    ; L142A CMD_Data
< 	rcall	L0339		; r24:27 = r8:9 clears X
---
> 	call	L142A
> 	rcall	L0339
1890,1893c1260,1261
< 
< L0382:					; top of loop
< 	call	_getchar    ;  L142A
< 
---
> L0382:
> 	call	L142A
1895,1896c1263
< 	rcall	L0342		; dword at r24 throuh XL +1
< 
---
> 	rcall	L0342
1898,1899c1265,1266
< 	mov	r16,r10			; word count
< 	rcall	L0318		; loop inc and compare
---
> 	mov	r16,r10
> 	rcall	L0318
1901,1902c1268
< 	rjmp	L0457		; exit handler
< 
---
> 	rjmp	L0457
1904,1908c1270,1273
< 	rcall	L031E		; test flag in D0080
< 	breq	L0382		; jump to top of loop
< 
< 	mov	r16,r14			; memory type
< 	subi	r16,kA0		; A0 = PML
---
> 	rcall	L031E
> 	breq	L0382
> 	mov	r16,r14
> 	subi	r16,kA0
1911d1275
< 
1913c1277
< 	subi	r16,k10		; B0 = FLASH_JTAG
---
> 	subi	r16,k10
1915,1916c1279
< 
< 	dec	r16				; B1 = EEPROM_JTAG
---
> 	dec	r16
1919d1281
< 
1921c1283
< 	dec	r16				; B2 = FUSE_JTAG
---
> 	dec	r16
1924d1285
< 
1926c1287
< 	dec	r16				; B3 = LOCK_JTAG
---
> 	dec	r16
1929d1289
< 
1931c1291
< 	subi	r16,k6D		; 20 = SRAM
---
> 	subi	r16,k6D
1933,1934c1293
< 
< 	subi	r16,k02		; 22 = EEPROM
---
> 	subi	r16,k02
1936,1937c1295
< 
< 	subi	r16,k0E		; 30 = IO/Shadow
---
> 	subi	r16,k0E
1939,1940c1297
< 
< 	subi	r16,k30		; 60 = EventL
---
> 	subi	r16,k30
1942,1944c1299
< 
< 	rjmp	L041E		; will get back to the loop head
< 
---
> 	rjmp	L041E
1947,1948c1302
< 
< L03A4:					; write SRAM
---
> L03A4:
1974,1975c1328
< 
< L03BD:					; Write EEPROM
---
> L03BD:
1979,1980c1332
< 
< L03C1:					; Write IO/Shadow
---
> L03C1:
1984,1986c1336,1337
< 
< L03C4:					; Write FLASH_JTAG
< 	lds	r16,D0079		; Units before
---
> L03C4:
> 	lds	r16,D0079
1989,1994c1340,1344
< 
< 	rcall	L0466		; will get char
< 	rcall	L0494		; Z = r16:17
< 	rcall	L0466		; will get char
< 	rcall	L04A1		; r16:17 -= 1
< 	rcall	L048A		; mark for search
---
> 	rcall	L0466
> 	rcall	L0494
> 	rcall	L0466
> 	rcall	L04A1
> 	rcall	L048A
1997d1346
< 
1999,2004c1348,1352
< 	rcall	L0361		; r18:19 load P0081
< 	rcall	L0499		; com r16:17 
< 	rcall	L04A4		; and r16:17 r24:25
< 	call	L11B3		; looks like c frame 
< 	rcall	L0487		; clear r6:7
< 
---
> 	rcall	L0361
> 	rcall	L0499
> 	rcall	L04A4
> 	call	L11B3
> 	rcall	L0487
2010d1357
< 
2013c1360
< 	rcall	L045C		; will store Z
---
> 	rcall	L045C
2015,2017c1362,1363
< 
< L03DC:					; not units before
< 	rcall	L045A		; get byte and store Z
---
> L03DC:
> 	rcall	L045A
2020c1366
< 	rcall	L035C		; add copy reg
---
> 	rcall	L035C
2027d1372
< 
2029c1374
< 	rcall	L04A7		; Z = r4:r5 >> 1
---
> 	rcall	L04A7
2056,2057c1401
< 
< L03FE:					; PML
---
> L03FE:
2066d1409
< 
2093,2094c1436
< 
< L041E:						; write EventL
---
> L041E:
2098,2100c1440,1441
< 
< L0422:						; write EEPROM_JTAG
< 	call	_getchar        ;  L142A
---
> L0422:
> 	call	L142A
2138c1479
< 	rcall	L033F      ;  r16:17 = r24:25
---
> 	rcall	L033F
2141,2143c1482,1483
< 
< L044C:					; FUSE_JTAG
< 	call	_getchar    ; L142A
---
> L044C:
> 	call	L142A
2147,2149c1487,1488
< 
< L0452:					; LOCK_JTAG
< 	call	_getchar    ; L142A
---
> L0452:
> 	call	L142A
2152d1490
< 
2156d1493
< 
2158c1495
< 	call	_getchar        ;  L142A
---
> 	call	L142A
2172,2177c1509,1513
< 	rjmp	L04A1		; r16:17 -= 1
< 
< L0466:						; called from write flash
< 	call	_getchar        ; L142A
< 	mov	r18,r16				; save byte to store
< 	mov	r16,r4				; Where are these from?
---
> 	rjmp	L04A1
> L0466:
> 	call	L142A
> 	mov	r18,r16
> 	mov	r16,r4
2179,2180c1515,1516
< 	rcall	L04A1		; r16:17 -= 1
< 	rcall	L04A7		; Z = r4:r5 >> 1
---
> 	rcall	L04A1
> 	rcall	L04A7
2191c1527
< 	call	_getchar        ;  L142A
---
> 	call	L142A
2201c1537
< 	call	_getchar        ;  L142A
---
> 	call	L142A
2209c1545
< 	call	_getchar        ;  L142A
---
> 	call	L142A
2221c1557
< L048A:						; mark for search
---
> L048A:
2228c1564
< 	rcall	L04A7		; Z = r4:r5 >> 1
---
> 	rcall	L04A7
2235,2236c1571,1572
< 	mov	ZL,r16				; from main write loop
< 	mov	ZH,r17
---
> 	mov	r30,r16
> 	mov	r31,r17
2254d1589
< 
2267,2272c1602,1607
< L04A7:		; Z = r4:r5 >> 1
< 	mov	ZL,r4
< 	mov	ZH,r5
< 	lsr	ZH
< 	ror	ZL
< 	sbiw ZL,k01
---
> L04A7:
> 	mov	r30,r4
> 	mov	r31,r5
> 	lsr	r31
> 	ror	r30
> 	sbiw	r30,k01
2276,2277c1611,1612
< L04AD:					; Enter Program Mode
< 	rcall	SYNCEOP   	; L04C0
---
> L04AD:
> 	rcall	L04C0
2279,2280c1614,1615
< 	rcall	L0351		; get JTAGID pointer
< 	rcall	L04C3		; Deref the 32bit dWord
---
> 	rcall	L0351
> 	rcall	L04C3
2283c1618
< 	cpi	r16,k3E			; signature class
---
> 	cpi	r16,k3E
2286c1621
< 	ldi	r16,k46			; failed
---
> 	ldi	r16,k46
2289c1624
< 	ldi	r16,k41			; Resp_OK
---
> 	ldi	r16,k41
2291c1626
< 	rcall	putchar1    ; L01FC
---
> 	rcall	L01FC
2299,2301c1634,1636
< SYNCEOP:   ; L04C0 from L04E4
< 	rcall	L0796		; wait next event
< 	tst	r16				; test r16 z is pointer
---
> L04C0:
> 	rcall	L0796
> 	tst	r16
2313,2315c1648,1650
< L04C8:					; Leave Program Mode
< 	rcall	SYNCEOP   	; L04C0	
< 	breq	L04D0		; bad Command
---
> L04C8:
> 	rcall	L04C0
> 	breq	L04D0
2319c1654
< 	rcall	L01FB		;transmit ACK
---
> 	rcall	L01FB
2322d1656
< 
2325,2330c1659,1664
< L04D1:					; Chip Erase
< 	rcall	L0206		; push C word framework
< 	rcall	SYNCEOP		; L04C0
< 	breq	L04E1		; bad command
< 	call	L1186		; exec a command
< 	ldi	r24,k00			; clear the cword 
---
> L04D1:
> 	rcall	L0206
> 	rcall	L04C0
> 	breq	L04E1
> 	call	L1186
> 	ldi	r24,k00
2333d1666
< 
2335,2336c1668
< 	rcall	L020D		; ser array element from C word
< 
---
> 	rcall	L020D
2338c1670
< 	rcall	L032A		; get flash page size pointer P02A9
---
> 	rcall	L032A
2343,2344c1675,1676
< 	brcs	L04D9		; loop until done
< 	rcall	L01FB		; transmit ACK
---
> 	brcs	L04D9
> 	rcall	L01FB
2349d1680
< 
2352,2360c1683,1690
< ; reply sign on message
< L04E4:					; Get Sign on from L0144
< 	rcall SYNCEOP   	; L04C0	
< 	breq  L04EC			; error
< 	ldi	  r16,low(L0024*2)	; k48 responce message
< 	ldi	  r17,high(L0024*2)
< 	ldi	  r18,k00
< 	call  L1562			; init responder
< 	rcall L01FB			; transmit ACK
---
> L04E4:
> 	rcall	L04C0
> 	breq	L04EC
> 	ldi	r16,k48
> 	ldi	r17,k00
> 	ldi	r18,k00
> 	call	L1562
> 	rcall	L01FB
2363d1692
< 
2366c1695
< L04ED:					; Firmware Upgrade
---
> L04ED:
2368c1697
< 	cpi	r24,'J'
---
> 	cpi	r24,k4A
2370c1699
< 	call _getchar       ;  L142A
---
> 	call	L142A
2375c1704
< 	rcall	putchar1    ;  L01FC
---
> 	rcall	L01FC
2377c1706
< 	cpi	r24,'T'
---
> 	cpi	r24,k54
2379c1708
< 	call	_getchar    ;  L142A
---
> 	call	L142A
2384c1713
< 	rcall	putchar1    ;  L01FC
---
> 	rcall	L01FC
2386c1715
< 	cpi	r24,'A'
---
> 	cpi	r24,k41
2388c1717
< 	call	_getchar    ;  L142A
---
> 	call	L142A
2393c1722
< 	rcall	putchar1    ;  L01FC
---
> 	rcall	L01FC
2395c1724
< 	cpi	r24,'G'
---
> 	cpi	r24,k47
2397c1726
< 	call	_getchar    ;  L142A
---
> 	call	L142A
2402c1731
< 	rcall	putchar1    ;  L01FC
---
> 	rcall	L01FC
2404c1733
< 	cpi	r24,'u'
---
> 	cpi	r24,k75
2406c1735
< 	call	_getchar    ;  L142A
---
> 	call	L142A
2411c1740
< 	rcall	putchar1    ;  L01FC
---
> 	rcall	L01FC
2413c1742
< 	cpi	r24,'p'
---
> 	cpi	r24,k70
2415c1744
< 	call	_getchar    ;  L142A
---
> 	call	L142A
2420c1749
< 	rcall	putchar1    ; L01FC
---
> 	rcall	L01FC
2422c1751
< 	cpi	r24,'g'
---
> 	cpi	r24,k67
2424c1753
< 	call	_getchar    ; L142A
---
> 	call	L142A
2429c1758
< 	rcall	putchar1    ; L01FC
---
> 	rcall	L01FC
2431,2433c1760,1762
< 	cpi	r24,'r'
< 	brne	L0536		; command no good
< 	rcall	SYNCEOP   	; L04C0
---
> 	cpi	r24,k72
> 	brne	L0536
> 	rcall	L04C0
2435c1764
< 	rcall	L01FB		; transmit ACK
---
> 	rcall	L01FB
2437c1766
< 	call	L0115		; set wait timer		; delay
---
> 	call	L0115
2439c1768
< 	rcall	L0209		; test wait timer		; loop
---
> 	rcall	L0209
2442,2445c1771,1773
< 	jmp	BootStart		; L1E00
< 	rjmp	L0536		; destruct frame (cant get here)
< 
< L0534:					; function failed
---
> 	jmp	L1E00
> 	rjmp	L0536
> L0534:
2447c1775
< 	rcall	putchar1    ;  L01FC
---
> 	rcall	L01FC
2455c1783
< 	call	_getchar    ;  L142A
---
> 	call	L142A
2460c1788
< L053D:					; Set_Parameter
---
> L053D:
2464d1791
< 
2467,2476c1794,1800
< 
< 	ldi	ZL,low(L004F*2)	;k9E table 2
< 	ldi	ZH,high(L004F*2)
< 	jmp	L14E4			; will get to a jmp table
< 
< J0545:					; Set baud rate
< 	sts	D0061,r24		; baud rate param
< 	rcall	L01FB		; transmit ACK
< 	ldi	ZL,kA0
< 	ldi	ZH,k0F
---
> 	ldi	r30,k9E
> 	ldi	r31,k00
> 	jmp	L14E4
> 	sts	D0061,r24
> 	rcall	L01FB
> 	ldi	r30,kA0
> 	ldi	r31,k0F
2478,2480c1802,1804
< 	sbiw	ZL,k01
< 	mov	r16,ZL
< 	or	r16,ZH
---
> 	sbiw	r30,k01
> 	mov	r16,r30
> 	or	r16,r31
2482,2484c1806,1808
< 	lds	r16,D0061		; baud rate param 
< 	call	L10FF		; baud rate look up table
< 	call	L13DC		; init UART
---
> 	lds	r16,D0061
> 	call	L10FF
> 	call	L13DC
2486,2487d1809
< 
< J0555:					; set timers run
2490c1812
< L0558:					
---
> L0558:
2493,2494d1814
< 
< J055A:					; undoc 0xB6	Set autostep perhaps?
2496,2499c1816,1819
< 	ldi	r16,low(J0CEC) ;kEC
< 	ldi	r17,High(J0CEC);k0C
< 	ldi	ZL,low(P0063)	; P0063
< 	ldi	ZH,high(P0063)
---
> 	ldi	r16,kEC
> 	ldi	r17,k0C
> 	ldi	r30,k63
> 	ldi	r31,k00
2504,2505d1823
< 
< J0563:					; Set Change of flow
2508,2511c1826,1828
< J0566:					; Set PSB0H	
< 	ldi	ZL,low(P0186)	; P0186
< 	ldi	ZH,high(P0186)
< L0568:					; Set flash page Size
---
> 	ldi	r30,k86
> 	ldi	r31,k01
> L0568:
2516,2518c1833,1834
< J056C:					; Set PSB0L
< 	ldi	ZL,low(P0186)	; P0186
< 	ldi	ZH,high(P0186)
---
> 	ldi	r30,k86
> 	ldi	r31,k01
2527,2529c1843,1844
< J0576:					; Set PSB1H	
< 	ldi	ZL,low(P0188)	; P0188
< 	ldi	ZH,high(P0188)
---
> 	ldi	r30,k88
> 	ldi	r31,k01
2531,2533c1846,1847
< J0579:					; Set PSB1L
< 	ldi	ZL,low(P0188)	; P0188
< 	ldi	ZH,high(P0188)
---
> 	ldi	r30,k88
> 	ldi	r31,k01
2539,2541c1853,1854
< J0580:					; Set Break Addr 1H
< 	ldi	ZL,low(P0182)	; P0182
< 	ldi	ZH,high(P0182)
---
> 	ldi	r30,k82
> 	ldi	r31,k01
2543,2547c1856,1859
< J0583:					; Set Break Addr 1L
< 	ldi	ZL,low(P0182)	; P0182
< 	ldi	ZH,high(P0182)
< L0585:					; Set Flash page size
< 	ldd	r17,Z+o01		; P0184
---
> 	ldi	r30,k82
> 	ldi	r31,k01
> L0585:
> 	ldd	r17,Z+o01
2550,2552c1862,1863
< J0588:					; Set Break Addr 2H
< 	ldi	ZL,low(P0184)	; P0184
< 	ldi	ZH,high(P0184)
---
> 	ldi	r30,k84
> 	ldi	r31,k01
2554,2556c1865,1866
< J058B:					; Set Break Addr 2L
< 	ldi	ZL,low(P0184)	; P0184
< 	ldi	ZH,high(P0184)
---
> 	ldi	r30,k84
> 	ldi	r31,k01
2558d1867
< J058E:					; Set Comb Break control
2560,2561c1869,1870
< 	ldi	ZL,low(P0184)	; P0184
< 	ldi	ZH,high(P0184)
---
> 	ldi	r30,k84
> 	ldi	r31,k01
2564,2565c1873,1874
< 	ldi	ZL,low(P0182)	; P0182
< 	ldi	ZH,high(P0182)
---
> 	ldi	r30,k82
> 	ldi	r31,k01
2570d1878
< J059A:					; Set OCD JTAG clock
2573c1881
< 	call	L011A		; yes it writes EEProm
---
> 	call	L011A
2577d1884
< J05A2:					; Set IregH
2583d1889
< J05A7:					; Set IregL
2586d1891
< J05A9:					; Set Flash PG Size L
2589d1893
< J05AB:					; Set Flash PG Size H
2592d1895
< J05AD:					; Set EEPROM PG Size
2595d1897
< J05B0:					; Set Units Before
2598d1899
< J05B3:					; Set Units After
2601d1901
< J05B6:					; Set Bit Before
2604d1903
< J05B9:					; Set Bit After
2607d1905
< J05BC:					; undoc 0xB4
2610d1907
< J05BF:					; undoc 0xB5
2613d1909
< J05C2:					; undoc 0xB7
2616d1911
< J05C5:					; undoc 0xB8
2619d1913
< J05C8:					; External Reset
2622,2623c1916,1917
< 	sbi	RESETDDR,nSRST	; b4
< 	cbi	RESETPORT,nSRST	; b4
---
> 	sbi	DDRB,b4
> 	cbi	PORTB,b4
2626c1920
< 	cbi	RESETDDR,nSRST
---
> 	cbi	DDRB,b4
2628,2630c1922
< 
< J05CF:					; Error bad command handler
< 	ldi	r16,k46			;
---
> 	ldi	r16,k46
2632c1924
< 	rcall	putchar1    ; L01FC
---
> 	rcall	L01FC
2638,2641c1930,1933
< L05D3:					; 0x71 Get Parameter
< 	rcall	L0538		; get value
< 	rcall	SYNCEOP   ; L04C0		; get Sync_CRC/EOP
< 	breq	L060A		; bad command error
---
> L05D3:
> 	rcall	L0538
> 	rcall	L04C0
> 	breq	L060A
2643,2650c1935,1939
< 
< 	ldi	ZL,low(P007B*2)	; kF6
< 	ldi	ZH,high(P007B*2)
< 	jmp	L14E4			; will get to a jmp table
< 
< J05DB:
< 	lds	r16,D0061		; baud rate param
< L05DD:					; Exit ACK
---
> 	ldi	r30,kF6
> 	ldi	r31,k00
> 	jmp	L14E4
> 	lds	r16,D0061
> L05DD:
2653c1942
< 	call	_putchar    ;  L143C transmit byte from ring
---
> 	call	L143C
2655,2656c1944
< 	rjmp	L0609		; transmit ACK
< J05E2:					; get Hardware version
---
> 	rjmp	L0609
2658,2659c1946
< 	rjmp	L05DD		; Exit ACK
< J05E5:					; Software version
---
> 	rjmp	L05DD
2661,2665c1948,1950
< 	rjmp	L05DD		; Exit ACK
< J05E7:					; OCD Vtarget
< 	call	L00A5		; check target power on, read and mul ADC
< 	rjmp	L05DD		; Exit ACK
< J05EA:					; OCD JTAG clock
---
> 	rjmp	L05DD
> 	call	L00A5
> 	rjmp	L05DD
2667c1952
< 	call	L0123		; EE read
---
> 	call	L0123
2669,2671c1954,1955
< J05EE:					; JTAGID Byte 0
< 	rcall	L0351		; prep and get sram pointer
< 	rcall	L04C3		; deref dword 32 bits
---
> 	rcall	L0351
> 	rcall	L04C3
2673,2674c1957
< J05F1:					; JTAGID BYTE 1
< 	rcall	L0353		; get sram pointer P006F
---
> 	rcall	L0353
2677,2678c1960
< J05F4:					; JTAGID BYTE 2
< 	rcall	L0353		; get sram pointer
---
> 	rcall	L0353
2680,2682c1962,1963
< 	ldd	r17,Z+o03		; looks like word out (probably a bug
< 	rjmp	L05DE		; in the c code where the value is declared wrong
< J05F8:					; JTAGID BYTE 3
---
> 	ldd	r17,Z+o03
> 	rjmp	L05DE
2686d1966
< J05FB:					; IREG HI
2691d1970
< J05FF:					; IREG LOW
2694d1972
< J0601:					; OCD Break Cause
2697d1974
< J0603:					; MCU Mode
2700d1976
< J0606:					; Failed Command
2702c1978
< 	rcall	putchar1    ;  L01FC
---
> 	rcall	L01FC
2705c1981
< 	rcall	putchar1    ;  L01FC
---
> 	rcall	L01FC
2711,2713c1987,1989
< L060C:					; Read_PC
< 	rcall	L0206		; push C word framework
< 	rcall	SYNCEOP   	; L04C0
---
> L060C:
> 	rcall	L0206
> 	rcall	L04C0
2719c1995
< 	rcall	putchar1    ;  L01FC
---
> 	rcall	L01FC
2727c2003
< 	rcall	putchar1      ;  L01FC
---
> 	rcall	L01FC
2729c2005
< 	rcall	putchar1      ;  L01FC
---
> 	rcall	L01FC
2732c2008
< 	rcall	putchar1      ;  L01FC
---
> 	rcall	L01FC
2738c2014
< 	jmp	_putchar        ;  L143C				; transmit byte from ring
---
> 	jmp	L143C
2747c2023
< L0629:					; Write_PC
---
> L0629:
2755,2756c2031,2032
< 	call	_getchar    ; L142A
< 	call	_getchar    ; L142A
---
> 	call	L142A
> 	call	L142A
2764c2040
< 	rcall	SYNCEOP   	; L04C0
---
> 	rcall	L04C0
2766c2042
< 	rcall	L033F      ;  r16:17 = r24:25
---
> 	rcall	L033F
2770c2046
< 	rcall	L01FB		; transmit ACK
---
> 	rcall	L01FB
2778c2054
< 	call	_getchar        ;  L142A
---
> 	call	L142A
2785,2786c2061,2062
< L064F:					; Forced Stop
< 	rcall	L0206    	; push C word framework
---
> L064F:
> 	rcall	L0206
2788c2064
< 	rcall	SYNCEOP   	; L04C0
---
> 	rcall	L04C0
2799c2075
< 	rcall	putchar1    ;  L01FC
---
> 	rcall	L01FC
2802,2803c2078,2079
< 	call	_putchar    ;  L143C
< 	rcall	L01FB		; transmit ACK
---
> 	call	L143C
> 	rcall	L01FB
2809c2085
< L0663:					; Single_Step
---
> L0663:
2811,2812c2087
< 	rcall	SYNCEOP   	; L04C0
< J0665:
---
> 	rcall	L04C0
2826,2828c2101,2102
< 	lds	r16,D007F	; 3 4
< 	andi	r16,k06 ; 5
< J0676:
---
> 	lds	r16,D007F
> 	andi	r16,k06
2830d2103
< 
2833c2106
< 	rcall	L01FB	;transmit ACK
---
> 	rcall	L01FB
2844,2845c2117,2118
< L067F:					; Get Debug info
< 	rcall	SYNCEOP   	; L04C0
---
> L067F:
> 	rcall	L04C0
2847,2848c2120,2121
< 	rcall	L0311		; return 0
< 	rcall	L01FB		; transmit ACK
---
> 	rcall	L0311
> 	rcall	L01FB
2853c2126
< L0684:					; Go
---
> L0684:
2855c2128
< 	rcall	SYNCEOP     ; L04C0
---
> 	rcall	L04C0
2858c2131
< 	rcall	L0226		; deref r16 = *D007F
---
> 	rcall	L0226
2869c2142
< L0691:					; Reset
---
> L0691:
2871c2144
< 	rcall	SYNCEOP   	; L04C0
---
> 	rcall	L04C0
2888c2161
< 	rcall	L01FB	;transmit ACK
---
> 	rcall	L01FB
2893,2895c2166,2168
< L06A6:					; part of device descriptor
< 	rcall	L0206    	;  push C word framework
< 	call	_getchar    ;  L142A
---
> L06A6:
> 	rcall	L0206
> 	call	L142A
2897c2170
< 	call	_getchar    ;  L142A
---
> 	call	L142A
2900,2901c2173,2174
< 	rcall	L033F       ;  r16:17 = r24:25
< 	rcall	L04E1		; restore frame 
---
> 	rcall	L033F
> 	rcall	L04E1
2903d2175
< 
2906,2907c2178,2179
< L06B1:					; core of device descriptor
< 	call	L1543		; push frame for two variables
---
> L06B1:
> 	call	L1543
2913d2184
< 
2915c2186
< 	call	_getchar    ;  L142A
---
> 	call	L142A
2917,2923c2188,2193
< 	mov	ZL,r26			; low sram addr
< 	mov	ZH,r27			; high sram addr
< 	add	ZL,r24			; param 2	
< 	adc	ZH,r17
< 	std	Z+o00,r16		; will write to sram here
< 	inc	r24				; index
< 
---
> 	mov	r30,r26
> 	mov	r31,r27
> 	add	r30,r24
> 	adc	r31,r17
> 	std	Z+o00,r16
> 	inc	r24
2925,2929c2195,2198
< 	cp	 r24,r25		; for while loop terminator
< 	brcs L06B8
< 	ldi	 r30,k04		; Frame restor count
< 	jmp	 L1554			; return and affect frame here
< 
---
> 	cp	r24,r25
> 	brcs	L06B8
> 	ldi	r30,k04
> 	jmp	L1554
2932c2201
< 	call	_getchar    ;  L142A
---
> 	call	L142A
2939c2208
< 	call	_getchar    ;  L142A
---
> 	call	L142A
2942c2211
< 	call	_getchar        ;  L142A
---
> 	call	L142A
2944c2213
< 	rcall	L033F      ;  r16:17 = r24:25
---
> 	rcall	L033F
2948,2954c2217,2222
< 	jmp	L1554				; return something
< 
< L06DD:					; Set Device Descriptor 123 bytes of data
< 	ldi	r18,k08			; p0232
< 	ldi	r16,low(P0232)
< 	ldi	r17,high(P0232)
< 	rcall	L06B1		; store 8 bytes	count 8
---
> 	jmp	L1554
> L06DD:
> 	ldi	r18,k08
> 	ldi	r16,k32
> 	ldi	r17,k02
> 	rcall	L06B1
2956,2957c2224,2225
< 	ldi	r16,low(P0232+8)	; k3A
< 	ldi	r17,high(P0232+8)	; k02	count 16
---
> 	ldi	r16,k3A
> 	ldi	r17,k02
2960,2961c2228,2229
< 	ldi	r16,low(P0232+16)	; k42
< 	ldi	r17,high(P0232+16)	; k02	count 24 
---
> 	ldi	r16,k42
> 	ldi	r17,k02
2964,2965c2232,2233
< 	ldi	r16,low(P0232+24)	; k4A
< 	ldi	r17,high(P0232+24)	; k02	count 32
---
> 	ldi	r16,k4A
> 	ldi	r17,k02
2968,2969c2236,2237
< 	ldi	r16,low(P0232+32)	; k52
< 	ldi	r17,high(P0232+32)	; k02	count 52
---
> 	ldi	r16,k52
> 	ldi	r17,k02
2972,2973c2240,2241
< 	ldi	r16,low(P0232+52)	; k66
< 	ldi	r17,high(P0232+52)	; k02	count 72
---
> 	ldi	r16,k66
> 	ldi	r17,k02
2976,2977c2244,2245
< 	ldi	r16,low(P0232+72)	; k7A
< 	ldi	r17,high(P0232+72)  ; k02	count 92
---
> 	ldi	r16,k7A
> 	ldi	r17,k02
2980,2981c2248,2249
< 	ldi	r16,low(P0232+92)	; k8E
< 	ldi	r17,high(P0232+92)	; k02	count 112
---
> 	ldi	r16,k8E
> 	ldi	r17,k02
2983c2251
< 	call	_getchar        ;  L142A count 113
---
> 	call	L142A
2985c2253
< 	call	_getchar        ;  L142A count 114
---
> 	call	L142A
2987c2255
< 	call	_getchar        ;  L142A count 115
---
> 	call	L142A
2989,2990c2257,2258
< 	rcall	L06A6			; get two params count 117
< 	rcall	L032A			; set flash page size
---
> 	rcall	L06A6
> 	rcall	L032A
2993c2261
< 	call	_getchar        ;  L142A count 118
---
> 	call	L142A
2995,2997c2263,2265
< 	rcall	L06C6			; three parameters count 121
< 	ldi	ZL,low(P02A4)		; P02A4
< 	ldi	ZH,high(P02A4)
---
> 	rcall	L06C6
> 	ldi	r30,kA4
> 	ldi	r31,k02
2999c2267
< 	call	_getchar        ;  L142A count 122
---
> 	call	L142A
3001c2269
< 	rcall	SYNCEOP   		; L04C0
---
> 	rcall	L04C0
3009,3013c2277,2280
< 	jmp	_putchar        ;  L143C			; transmit byte from ring
< 
< L0721:					; Erase Page SPM
< 	rcall	L0206    	; push C word framework
< 	call	_getchar    ; L142A
---
> 	jmp	L143C
> L0721:
> 	rcall	L0206
> 	call	L142A
3017,3019c2284,2286
< 	rcall	SYNCEOP   	; L04C0
< 	breq	L072D		; bad command
< 	rcall	L033F      ;  r16:17 = r24:25
---
> 	rcall	L04C0
> 	breq	L072D
> 	rcall	L033F
3021c2288
< 	rcall	L01FB		; transmit ACK
---
> 	rcall	L01FB
3025d2291
< 
3028,3030c2294,2296
< L072F:						; undocumented command 0xC0
< 	rcall	L01FF			; get parameters (word)
< 	breq	L0736			; bad command
---
> L072F:
> 	rcall	L01FF
> 	breq	L0736
3033,3034c2299,2300
< 	call	L07D1           ; JTAG Command
< 	rcall	L01FB	;transmit ACK			; transmit ACK
---
> 	call	L07D1
> 	rcall	L01FB
3036c2302
< 	rcall	L04E1			; cleanup frame
---
> 	rcall	L04E1
3038d2303
< 
3041,3044c2306,2309
< L0738:						; undocumented command 0xC1
< 	call	L1541			; get param
< 	sbiw	YL,k0C			
< 	call	_getchar        ;  L142A
---
> L0738:
> 	call	L1541
> 	sbiw	r28,k0C
> 	call	L142A
3046c2311
< 	call	_getchar        ;  L142A
---
> 	call	L142A
3054c2319
< 	call	_getchar        ;  L142A
---
> 	call	L142A
3060,3062c2325,2327
< 	call	_getchar        ;  L142A
< 	mov	r30,YL
< 	mov	r31,YH
---
> 	call	L142A
> 	mov	r30,r28
> 	mov	r31,r29
3070c2335
< 	rcall	SYNCEOP   ; L04C0
---
> 	rcall	L04C0
3075c2340
< 	rcall	SYNCEOP   ; L04C0
---
> 	rcall	L04C0
3081c2346
< 	rcall	putchar1      ;  L01FC
---
> 	rcall	L01FC
3086,3087c2351,2352
< 	mov	r30,YL
< 	mov	r31,YH
---
> 	mov	r30,r28
> 	mov	r31,r29
3093c2358
< 	rcall	putchar1      ;  L01FC
---
> 	rcall	L01FC
3097c2362
< 	rcall	L01FB	;transmit ACK
---
> 	rcall	L01FB
3099c2364
< 	adiw	YL,k0C
---
> 	adiw	r28,k0C
3119,3120c2384,2385
< 	mov	r18,YL
< 	mov	r19,YH
---
> 	mov	r18,r28
> 	mov	r19,r29
3123,3124c2388,2389
< 	mov	r16,YL
< 	mov	r17,YH
---
> 	mov	r16,r28
> 	mov	r17,r29
3128,3130c2393,2394
< 
< L0789:						; undocumented command 0xC2
< 	rcall	SYNCEOP   ; L04C0
---
> L0789:
> 	rcall	L04C0
3137c2401
< 	jmp	_putchar        ;  L143C ACK
---
> 	jmp	L143C
3140c2404
< 	rcall	putchar1      ;  L01FC NACK
---
> 	rcall	L01FC
3145d2408
< 
3147,3156c2410,2417
< 	; appears to be main wait for Sync_CRC/EOP
< 	; command
< 	call  _getchar        ;  L142A			; wait for byte 1
< 	call  _getchar        ;  L142A			; wait for byte 2
< 	cpi	  r16,k20		; compare to Sync_CRC
< 	sbci  r17,k00
< 	breq  L07A1			; Sync_CRC
< 	ldi	  r16,'E'		; Sync_ERR
< 	rcall putchar1      ;  L01FC			; transmit reply
< 	ldi	  r16,k00
---
> 	call	L142A
> 	call	L142A
> 	cpi	r16,k20
> 	sbci	r17,k00
> 	breq	L07A1
> 	ldi	r16,k45
> 	rcall	L01FC
> 	ldi	r16,k00
3158d2418
< 
3162c2422
< 	rcall	L01FB	;transmit ACK	;transmit ACK
---
> 	rcall	L01FB
3165d2424
< 
3168c2427
< L07A4:					; undoc C2 command?
---
> L07A4:
3175,3179c2434,2438
< 	ldi	 r16,kFF
< 	ldi	 r17,kFF
< 	in   r18,JTAGPIN
< 	andi r18,1<<TD0
< 	ldi	 r21,k04
---
> 	ldi	r16,kFF
> 	ldi	r17,kFF
> 	in	r18,PINB
> 	andi	r18,k40
> 	ldi	r21,k04
3181,3195c2440,2454
< 	ldi	 r19,k00
< 	cp	 r16,r19
< 	cpc	 r17,r19
< 	breq L07C6
< 	ldi	 r20,1<<TDI
< 	in	 r19,JTAGPORT
< 	eor	 r19,r20
< 	out	 JTAGPORT,r19
< 	in   r19,JTAGPIN
< 	andi r19,1<<TD0
< 	cp	 r18,r19
< 	mov	 r18,r19
< 	breq L07BE
< 	dec	 r21
< 	breq L07C8
---
> 	ldi	r19,k00
> 	cp	r16,r19
> 	cpc	r17,r19
> 	breq	L07C6
> 	ldi	r20,k20
> 	in	r19,PORTB
> 	eor	r19,r20
> 	out	PORTB,r19
> 	in	r19,PINB
> 	andi	r19,k40
> 	cp	r18,r19
> 	mov	r18,r19
> 	breq	L07BE
> 	dec	r21
> 	breq	L07C8
3197,3198c2456,2457
< 	ldi	 r19,k00
< 	dec	 r16
---
> 	ldi	r19,k00
> 	dec	r16
3200c2459
< 	dec	 r17
---
> 	dec	r17
3202c2461
< 	ldi	 r19,k1F
---
> 	ldi	r19,k1F
3204,3206c2463,2465
< 	dec	 r19
< 	brne L07C3
< 	rjmp L07AF
---
> 	dec	r19
> 	brne	L07C3
> 	rjmp	L07AF
3208,3209c2467,2468
< 	ldi	 r16,k00
< 	rjmp L07CA
---
> 	ldi	r16,k00
> 	rjmp	L07CA
3211,3212c2470,2471
< 	ldi	 r16,k01
< 	rjmp L07CA
---
> 	ldi	r16,k01
> 	rjmp	L07CA
3221d2479
< 
3224,3226c2482,2484
< L07D1:        			; JTAG Command  from L1174
< 	call	L1540		; save frame
< 	mov	r22,r16			; init C funtion params
---
> L07D1:
> 	call	L1540
> 	mov	r22,r16
3239,3240d2496
< 
< 
3250d2505
< 
3260c2515
< 	call	L14A6	; shift mpy
---
> 	call	L14A6
3270,3271c2525
< 	rjmp	L0801	; bang JTAG
< 
---
> 	rjmp	L0801
3280,3286c2534
< #ifdef _M163DEF_INC_ 		; JTAG mark 1
< 	cbi	LEDPORT,LEDA
< #endif
< #ifdef _M169DEF_INC_ 
< 	ldi r16,0x11 | 1<<LCD_AN1
< 	sts	LCDDR1,r16
< #endif
---
> 	cbi	PORTB,b3
3293c2541
< 	cbi	JTAGPORT,TDI
---
> 	cbi	PORTB,b5
3309c2557
< 	sbi	JTAGPORT,TDI
---
> 	sbi	PORTB,b5
3314c2562
< 	sbi	JTAGPORT,TDI
---
> 	sbi	PORTB,b5
3317c2565
< 	cbi	JTAGPORT,TDI
---
> 	cbi	PORTB,b5
3325c2573
< 	sbi	JTAGPORT,TMS
---
> 	sbi	PORTB,b1
3331,3337c2579
< #ifdef _M163DEF_INC_ 
< 	sbi	LEDPORT,LEDA
< #endif
< #ifdef _M169DEF_INC_ 
< 	ldi r30,0x11 | 0<<LCD_AN1
< 	sts	LCDDR1,r30
< #endif
---
> 	sbi	PORTB,b3
3362d2603
< 
3365,3366d2605
< ;	Looks like this is the TAP init
< ;
3368,3370c2607,2608
< 	cbi	JTAGPORT,TMS	; TMS>
< 	rjmp	L0A5F		; clock JTAG
< 
---
> 	cbi	PORTB,b1
> 	rjmp	L0A5F
3372,3374c2610,2611
< 	sbi	JTAGPORT,TMS	; TMS>
< 	rjmp	L0A5F		; clock JTAG
< 
---
> 	sbi	PORTB,b1
> 	rjmp	L0A5F
3376,3384c2613,2615
< 	sbi	JTAGPORT,TMS	; TMS>
< #ifdef _M163DEF_INC_ 
< 	cbi	LEDPORT,LEDA	; activity LED on
< #endif
< #ifdef _M169DEF_INC_ 
< 	ldi r16,0x11 | 1<<LCD_AN1	; JTAG mark 2
< 	sts	LCDDR1,r16
< #endif		
< 	rcall	L0A5F		; clocks
---
> 	sbi	PORTB,b1
> 	cbi	PORTB,b3
> 	rcall	L0A5F
3389,3397c2620,2622
< 	rcall	L083D		; back to head
< 	rcall	L083F		; TMS and back
< #ifdef _M163DEF_INC_ 
< 	sbi	LEDPORT,LEDA
< #endif
< #ifdef _M169DEF_INC_ 
< 	ldi r16,0x11 | 0<<LCD_AN1
< 	sts	LCDDR1,r16		; & pray r16 is not needed
< #endif
---
> 	rcall	L083D
> 	rcall	L083F
> 	sbi	PORTB,b3
3401c2626
< L084C:					; is this the read we are looking for?
---
> L084C:
3412,3418c2637
< #ifdef _M163DEF_INC_ 
< 	cbi	LEDPORT,LEDA
< #endif
< #ifdef _M169DEF_INC_ 
< 	ldi r16,0x11 | 1<<LCD_AN1	; JTAG mark 3
< 	sts	LCDDR1,r16
< #endif
---
> 	cbi	PORTB,b3
3454c2673
< 	cbi	JTAGPORT,TDI
---
> 	cbi	PORTB,b5
3490c2709
< 	sbis	JTAGPIN,TD0
---
> 	sbis	PINB,b6
3500c2719
< 	sbis	JTAGPIN,TD0
---
> 	sbis	PINB,b6
3503c2722
< 	sbi	JTAGPORT,TDI
---
> 	sbi	PORTB,b5
3510c2729
< 	sbis	JTAGPIN,TD0
---
> 	sbis	PINB,b6
3522c2741
< 	sbis	JTAGPIN,TD0
---
> 	sbis	PINB,b6
3525c2744
< 	sbi	JTAGPORT,TDI
---
> 	sbi	PORTB,b5
3531c2750
< 	cbi	JTAGPORT,TDI
---
> 	cbi	PORTB,b5
3552c2771
< 	sbi	JTAGPORT,TMS
---
> 	sbi	PORTB,b1
3555,3562c2774,2775
< #ifdef _M163DEF_INC_ 
< 	sbi	LEDPORT,LEDA
< #endif
< #ifdef _M169DEF_INC_ 
< 	ldi r30,0x11 | 0<<LCD_AN1
< 	sts	LCDDR1,r30
< #endif
< 	ldi	ZL,k11
---
> 	sbi	PORTB,b3
> 	ldi	r30,k11
3657,3663c2870
< #ifdef _M163DEF_INC_ 
< 	cbi	LEDPORT,LEDA
< #endif
< #ifdef _M169DEF_INC_ 
< 	ldi r16,0x11 | 1<<LCD_AN1		; jtag mark 4
< 	sts	LCDDR1,r16
< #endif
---
> 	cbi	PORTB,b3
3710c2917
< 	cbi	JTAGPORT,TDI
---
> 	cbi	PORTB,b5
3751c2958
< 	sbis	JTAGPIN,TD0
---
> 	sbis	PINB,b6
3763c2970
< 	sbi	JTAGPORT,TDI
---
> 	sbi	PORTB,b5
3767c2974
< 	sbis	JTAGPIN,TD0
---
> 	sbis	PINB,b6
3782c2989
< 	sbi	JTAGPORT,TDI
---
> 	sbi	PORTB,b5
3785c2992
< 	cbi	JTAGPORT,TDI
---
> 	cbi	PORTB,b5
3787c2994
< 	sbi	JTAGPORT,TMS
---
> 	sbi	PORTB,b1
3801c3008
< 	sbi	JTAGPORT,TMS
---
> 	sbi	PORTB,b1
3804,3810c3011
< #ifdef _M163DEF_INC_ 
< 	sbi	LEDPORT,LEDA
< #endif
< #ifdef _M169DEF_INC_ 
< 	ldi r30,0x11 | 0<<LCD_AN1
< 	sts	LCDDR1,r30
< #endif
---
> 	sbi	PORTB,b3
3826c3027
< 	cbi	JTAGPORT,TMS
---
> 	cbi	PORTB,b1
3903c3104
< 	sbis	JTAGPIN,TD0
---
> 	sbis	PINB,b6
3910c3111
< 	sbis	JTAGPIN,TD0
---
> 	sbis	PINB,b6
3921c3122
< 	sbi	JTAGPORT,TMS
---
> 	sbi	PORTB,b1
3931c3132
< 	sbi	JTAGPORT,TMS
---
> 	sbi	PORTB,b1
3939c3140
< 	cbi	JTAGPORT,TMS
---
> 	cbi	PORTB,b1
3949c3150
< 	call	L153D		; C frame
---
> 	call	L153D
3956,3962c3157
< #ifdef _M163DEF_INC_ 
< 	cbi	LEDPORT,LEDA
< #endif
< #ifdef _M169DEF_INC_ 
< 	ldi r16,0x11 | 1<<LCD_AN1	; jtag mark 5
< 	sts	LCDDR1,r16
< #endif
---
> 	cbi	PORTB,b3
4004c3199
< 	cbi	JTAGPORT,TDI
---
> 	cbi	PORTB,b5
4037c3232
< 	sbi	JTAGPORT,TDI
---
> 	sbi	PORTB,b5
4043c3238
< 	sbi	JTAGPORT,TDI
---
> 	sbi	PORTB,b5
4046c3241
< 	cbi	JTAGPORT,TDI
---
> 	cbi	PORTB,b5
4048c3243
< 	sbi	JTAGPORT,TMS
---
> 	sbi	PORTB,b1
4058c3253
< 	sbi	JTAGPORT,TMS
---
> 	sbi	PORTB,b1
4061,4067c3256
< #ifdef _M163DEF_INC_ 
< 	sbi	LEDPORT,LEDA
< #endif
< #ifdef _M169DEF_INC_ 
< 	ldi r16,0x11 | 0<<LCD_AN1
< 	sts	LCDDR1,r16
< #endif
---
> 	sbi	PORTB,b3
4070c3259
< 	ldi	r30,k0A			; could be an array offset
---
> 	ldi	r30,k0A
4072,4075c3261,3262
< 
< 
< L0A5F:					; TAP
< 	lds	r16,D018A		; comes from EEPROM
---
> L0A5F:
> 	lds	r16,D018A
4077,4079c3264,3266
< 	sbi	JTAGPORT,TCK	; TCK>
< 	brne	L0A66		; programable delay
< 	cbi	JTAGPORT,TCK	; TCK>
---
> 	sbi	PORTB,b7
> 	brne	L0A66
> 	cbi	PORTB,b7
4084c3271
< 	ldi	r16,k01			; init delay loop
---
> 	ldi	r16,k01
4087c3274
< 	inc	r16				; head delay loop
---
> 	inc	r16
4091,4092c3278,3279
< 	brcs	L0A68		; tail delay loop
< 	cbi	JTAGPORT,TCK	; clock JTAG
---
> 	brcs	L0A68
> 	cbi	PORTB,b7
4095d3281
< 
4097c3283
< 	inc	r16				; head delay pause
---
> 	inc	r16
4101c3287
< 	brcs	L0A70		; tail delay pause
---
> 	brcs	L0A70
4103d3288
< 
4107,4108c3292,3293
< 	sbi	JTAGPORT,TCK
< 	cbi	JTAGPORT,TCK
---
> 	sbi	PORTB,b7
> 	cbi	PORTB,b7
4110d3294
< 
4125d3308
< 
4146c3329
< 	jmp	L0115		; set wait timer
---
> 	jmp	L0115
4150c3333
< 	jmp	L07D1        ;  JTAG Command
---
> 	jmp	L07D1
4158c3341
< 	jmp	L07D1        ;  JTAG Command
---
> 	jmp	L07D1
4165c3348
< 	sbiw	YL,k06
---
> 	sbiw	r28,k06
4218c3401
< 	adiw	YL,k06
---
> 	adiw	r28,k06
4302c3485
< 	jmp	L07D1        ;  JTAG Command
---
> 	jmp	L07D1
4306c3489
< 	jmp	L07D1        ;  JTAG Command
---
> 	jmp	L07D1
4334c3517
< 	jmp	L0115		; set wait timer
---
> 	jmp	L0115
4371c3554
< 	call	L07D1        ;  JTAG Command
---
> 	call	L07D1
4385,4386c3568,3569
< 	mov	r18,YL
< 	mov	r19,YH
---
> 	mov	r18,r28
> 	mov	r19,r29
4389c3572
< 	mov	r16,YL
---
> 	mov	r16,r28
4397,4398c3580,3581
< 	mov	r18,YL
< 	mov	r19,YH
---
> 	mov	r18,r28
> 	mov	r19,r29
4403c3586
< 	mov	r16,YL
---
> 	mov	r16,r28
4405c3588
< 	mov	r17,YH
---
> 	mov	r17,r29
4416,4417c3599,3600
< 	mov	r18,YL
< 	mov	r19,YH
---
> 	mov	r18,r28
> 	mov	r19,r29
4425c3608
< 	sbiw	YL,k06
---
> 	sbiw	r28,k06
4430c3613
< 	sbiw	YL,k06
---
> 	sbiw	r28,k06
4477c3660
< 	adiw	YL,k06
---
> 	adiw	r28,k06
4532,4533c3715,3716
< 	subi	r30,low(0xFFFF-D018E)	; k71
< 	sbci	r31,High(0XFFFF-D018E)
---
> 	subi	r30,k71
> 	sbci	r31,kFE
4576c3759
< 	ldi	r31,k00				; P0026 not in sram
---
> 	ldi	r31,k00
4583,4584c3766,3767
< 	subi	r30,low(0xFFFF-D01AE) ;k51
< 	sbci	r31,high(0xFFFF-D01AE) ;kFE
---
> 	subi	r30,k51
> 	sbci	r31,kFE
4620,4621c3803,3804
< 	subi	r30,low(0xFFFF-D02AC) ;k53
< 	sbci	r31,high(0xFFFF-D02AC) ;kFD
---
> 	subi	r30,k53
> 	sbci	r31,kFD
4643c3826
< 	ldi	r31,high(P0065)	;k00 & pray all calls are with P0065
---
> 	ldi	r31,k00
4667,4668c3850,3851
< 	ldi	ZL,low(P02A4)	; k6F P02A4
< 	ldi	ZH,high(P02A4)
---
> 	ldi	r30,kA4
> 	ldi	r31,k02
4684,4685c3867,3868
< 	ldi	ZL,low(P0065)	; k6F P0065
< 	ldi	ZH,high(P0065)
---
> 	ldi	r30,k65
> 	ldi	r31,k00
4695,4696c3878,3879
< 	ldi	ZL,low(P006F)	; k6F P006F
< 	ldi	ZH,high(P006F)
---
> 	ldi	r30,k6F
> 	ldi	r31,k00
4708,4709c3891,3892
< 	ldi	ZL,low(P02A4)	; P02A4
< 	ldi	ZH,high(P02A4)
---
> 	ldi	r30,kA4
> 	ldi	r31,k02
4907,4908d4089
< 
< J0CCB:					; this is the default PML (Perhaps)
4926c4107
< 	adiw	YL,k08
---
> 	adiw	r28,k08
4937c4118
< 	jmp	L07D1        ;  JTAG Command
---
> 	jmp	L07D1
4941c4122
< 	sbiw	YL,k08
---
> 	sbiw	r28,k08
4951,4952d4131
< 
< J0CEC:
4979c4158
< 	call	L07D1        ;  JTAG Command
---
> 	call	L07D1
5007,5008c4186,4187
< 	mov	r16,YL
< 	mov	r17,YH
---
> 	mov	r16,r28
> 	mov	r17,r29
5014c4193
< 	sbiw	YL,k06
---
> 	sbiw	r28,k06
5039c4218
< 	adiw	YL,k06
---
> 	adiw	r28,k06
5043c4222
< 	sbiw	YL,k06
---
> 	sbiw	r28,k06
5055c4234
< 	adiw	YL,k06
---
> 	adiw	r28,k06
5065d4243
< 
5068,5070c4246,4248
< L0D4C:					; get the JTAGID dWord
< 	sbiw	YL,k08
< 	call	L0841		; TAP Init
---
> L0D4C:
> 	sbiw	r28,k08
> 	call	L0841
5073c4251
< 	call	L07D1       ;  JTAG Command
---
> 	call	L07D1
5075,5078c4253,4256
< 	rcall	L0B1E		; push 2 onto stack
< 	rcall	L0B60		; k20 and Y
< 	rcall	L0D61		; stack stuff
< 	subi	r16,kFA		; -5
---
> 	rcall	L0B1E
> 	rcall	L0B60
> 	rcall	L0D61
> 	subi	r16,kFA
5080c4258
< 	call	L084C		; looks like the read we are looking for
---
> 	call	L084C
5085c4263
< 	adiw	YL,k08
---
> 	adiw	r28,k08
5091d4268
< 
5094,5095c4271,4272
< 	sbiw	YL,k04
< 	in	r24,VTARGPIN
---
> 	sbiw	r28,k04
> 	in	r24,PIND
5102c4279
< 	in	r16,VTARGPIN
---
> 	in	r16,PIND
5113c4290
< 	adiw	YL,k04
---
> 	adiw	r28,k04
5120c4297
< 	sbiw	YL,k0A
---
> 	sbiw	r28,k0A
5137c4314
< 	adiw	YL,k0A
---
> 	adiw	r28,k0A
5147d4323
< 
5151,5156c4327,4330
< 	call	L1541		; c frame 3 arguments
< 	sbiw	YL,k0A
< 
< 	sbic	VTARGPIN,TGP_ON
< 	rjmp	L0E4A		; exit no target power
< 
---
> 	call	L1541
> 	sbiw	r28,k0A
> 	sbic	PIND,b3
> 	rjmp	L0E4A
5307c4481
< 	subi	r30,k60		; suspect ram address
---
> 	subi	r30,k60
5335,5336c4509,4510
< 	subi	r30,low(0xFFFF-P02EA) ;k15
< 	sbci	r31,high(0xFFFF-P02EA) ;kFD		;2EA
---
> 	subi	r30,k15
> 	sbci	r31,kFD
5362d4535
< 
5364c4537
< 	adiw	YL,k0A
---
> 	adiw	r28,k0A
5381,5382c4554,4555
< 	subi	r30,low(0xFFFF-D01AE) ;k51
< 	sbci	r31,high(0xFFFF-D01AE) ;kFE
---
> 	subi	r30,k51
> 	sbci	r31,kFE
5449,5450c4622,4623
< 	subi	r30,low(0xFFFF-P0230-1) ;kCE
< 	sbci	r31,high(0xFFFF-P0230-1) ;kFD
---
> 	subi	r30,kCE
> 	sbci	r31,kFD
5456,5457c4629,4630
< 	sbiw	YL,k0A
< 	sbic	VTARGPIN,TGP_ON
---
> 	sbiw	r28,k0A
> 	sbic	PIND,b3
5462c4635
< 	subi	r16,kF9		; high suspect -6
---
> 	subi	r16,kF9
5479c4652
< 	adiw	YL,k0A
---
> 	adiw	r28,k0A
5521,5522c4694,4695
< 	sbiw	YL,k06
< 	sbic	VTARGPIN,TGP_ON
---
> 	sbiw	r28,k06
> 	sbic	PIND,b3
5570,5571c4743,4744
< 	subi	r30,low(0xFFFF-P0279) ;k86
< 	sbci	r31,high(0xFFFF-P0279) ;kFD	
---
> 	subi	r30,k86
> 	sbci	r31,kFD
5636,5637c4809,4810
< 	subi	r30,low(0xFFFF-P028D) ;k72
< 	sbci	r31,high(0xFFFF-P028D) ;kFD
---
> 	subi	r30,k72
> 	sbci	r31,kFD
5644,5645c4817,4818
< 	subi	r30,low(0xFFFF-P02EA) ;k15
< 	sbci	r31,high(0xFFFF-P02EA) ;kFD		;2EA
---
> 	subi	r30,k15
> 	sbci	r31,kFD
5683,5684c4856
< 
< 	ldi	r30,low(P0065)	;k65
---
> 	ldi	r30,k65
5686d4857
< 
5718,5719c4889,4890
< 	ldi	r30,low(P0065)	; k65
< 	rcall	L0BFB		; & pray it is always called in page 1
---
> 	ldi	r30,k65
> 	rcall	L0BFB
5736c4907
< 	adiw	YL,k06
---
> 	adiw	r28,k06
5743c4914
< 	sbiw	YL,k04
---
> 	sbiw	r28,k04
5775c4946
< 	adiw	YL,k04
---
> 	adiw	r28,k04
5781c4952
< 	sbiw	YL,k04
---
> 	sbiw	r28,k04
5793c4964
< 	adiw	YL,k04
---
> 	adiw	r28,k04
5808c4979
< 	sbiw	YL,k04
---
> 	sbiw	r28,k04
5829c5000
< 	sbiw	YL,k04
---
> 	sbiw	r28,k04
5841c5012
< 	ldi	r16,k81			; physical or emotional?
---
> 	ldi	r16,k81
5881c5052
< 	sbiw	YL,k04
---
> 	sbiw	r28,k04
5889c5060
< 	sbiw	YL,k04
---
> 	sbiw	r28,k04
5897c5068
< 	sbiw	YL,k04
---
> 	sbiw	r28,k04
5919c5090
< 	call	L0115		; set wait timer
---
> 	call	L0115
5929,5930c5100,5101
< 	ldi	ZL,low(P02A4)	; P02A4
< 	ldi	ZH,high(P02A4)
---
> 	ldi	r30,kA4
> 	ldi	r31,k02
5933c5104
< 	adiw	YL,k04
---
> 	adiw	r28,k04
5940c5111
< 	sbiw	YL,k04
---
> 	sbiw	r28,k04
5948c5119
< 	adiw	YL,k04
---
> 	adiw	r28,k04
5982c5153
< 	sbiw	YL,k06
---
> 	sbiw	r28,k06
5993c5164
< 	sbiw	YL,k06
---
> 	sbiw	r28,k06
6031c5202
< 	adiw	YL,k06
---
> 	adiw	r28,k06
6034d5204
< 
6053,6061c5223,5226
< L1088:					; read HW version via portC pullups
< #ifdef _M163DEF_INC_
< 	in	 r16,HWREVPIN
< 	andi r16,HWREVPINMSK
< 	ori	 r16,kC0
< #endif
< #ifdef _M169DEF_INC_
< 	ldi r16,0xBF		; BF for butterfly
< #endif
---
> L1088:
> 	in	r16,PINC
> 	andi	r16,k0F
> 	ori	r16,kC0
6068,6069c5233,5234
< 	ldi	ZL,low(P02A9)	; P02A9
< 	ldi	ZH,high(P02A9)
---
> 	ldi	r30,kA9
> 	ldi	r31,k02
6112,6113c5277,5278
< 	ldi	ZL,low(P02A9)	; P02A9
< 	ldi	ZH,high(P02A9)
---
> 	ldi	r30,kA9
> 	ldi	r31,k02
6165c5330
< L10E8:					; Set IReg
---
> L10E8:
6167,6168c5332,5333
< 	ldi	ZL,low(P0230)	; k30 P0230
< 	ldi	ZH,high(P0230)
---
> 	ldi	r30,k30
> 	ldi	r31,k02
6182d5346
< 
6185,6190c5349,5354
< L10F7:					; Read IReg
< 	tst  r16
< 	ldi	ZL,low(P0230)	; k30 P0230
< 	ldi	ZH,high(P0230)
< 	breq L10FD
< 	ldd	 r16,Z+o01		; High byte
---
> L10F7:
> 	tst	r16
> 	ldi	r30,k30
> 	ldi	r31,k02
> 	breq	L10FD
> 	ldd	r16,Z+o01
6194,6195c5358,5359
< L10FD:					; read IReg
< 	ldd	r16,Z+o00		; Low byte
---
> L10FD:
> 	ldd	r16,Z+o00
6199,6200c5363,5364
< L10FF:					; used to set baud rate
< 	subi	r16,kF4		; kBaud9600
---
> L10FF:
> 	subi	r16,kF4
6212c5376
< 	ldi	r17,kBaud115200	; k03
---
> 	ldi	r17,k03
6215c5379
< 	ldi	r17,kBaud57600	; k07
---
> 	ldi	r17,k07
6218c5382
< 	ldi	r17,kBaud38400	; k0B			
---
> 	ldi	r17,k0B
6221c5385
< 	ldi	r17,kBaud19200	; default baud rate
---
> 	ldi	r17,k17
6224c5388
< 	ldi	r17,kBaud14400	; k1F			
---
> 	ldi	r17,k1F
6227c5391
< 	ldi	r17,kBaud9600	; k2F
---
> 	ldi	r17,k2F
6234c5398
< 	sbiw	YL,k02
---
> 	sbiw	r28,k02
6237c5401
< 	call	L07D1        ;  JTAG Command
---
> 	call	L07D1
6243c5407
< 	call	L0115		; set wait timer
---
> 	call	L0115
6249c5413
< 	call	L07D1        ;  JTAG Command
---
> 	call	L07D1
6256c5420
< 	adiw	YL,k02
---
> 	adiw	r28,k02
6273c5437
< 	mov	r16,YL
---
> 	mov	r16,r28
6281d5444
< 
6302c5465
< 	mov	r16,YL
---
> 	mov	r16,r28
6304c5467
< 	mov	r17,YH
---
> 	mov	r17,r29
6318,6319c5481,5482
< 	mov	r16,YL
< 	mov	r17,YH
---
> 	mov	r16,r28
> 	mov	r17,r29
6323,6324c5486,5487
< L115A:					; from L04C8
< 	sbiw	YL,k03
---
> L115A:
> 	sbiw	r28,k03
6340c5503
< 	adiw	YL,k03
---
> 	adiw	r28,k03
6349,6350c5512,5513
< 	ldi	ZL,low(P02A9)	; P02A9
< 	ldi	ZH,high(P02A9)
---
> 	ldi	r30,kA9
> 	ldi	r31,k02
6353,6354c5516
< 
< L1174:				; from L115A
---
> L1174:
6357c5519
< 	call	L07D1        ;  JTAG Command
---
> 	call	L07D1
6364c5526
< 	call	L07D1        ;  JTAG Command
---
> 	call	L07D1
6378,6381c5540,5542
< 
< L1186:					; process chip erase
< 	sbiw	YL,k04
< 	rcall	L1174		; send TAP command 0x105
---
> L1186:
> 	sbiw	r28,k04
> 	rcall	L1174
6383c5544
< 	rcall	L1137		; push onto C stack
---
> 	rcall	L1137
6385c5546
< 	rcall	L1199		; push onto C stack frame
---
> 	rcall	L1199
6387,6389c5548,5549
< 	rcall	L1199		; push onto C stack frame
< 	rcall	L119E		; will bang the JTAG TAP Access
< 
---
> 	rcall	L1199
> 	rcall	L119E
6392c5552
< 	rcall	L11A6		; c compare func
---
> 	rcall	L11A6
6395,6396c5555,5556
< 	rjmp	L1196		; return
< 	rcall	L1140		; D006E	test timer
---
> 	rjmp	L1196
> 	rcall	L1140
6398d5557
< 
6400c5559
< 	adiw	YL,k04
---
> 	adiw	r28,k04
6410,6412c5569,5570
< 	rcall	L1154		; cleanup frame
< 	jmp	L09F7			; will get to a TAP access
< 
---
> 	rcall	L1154
> 	jmp	L09F7
6415,6416c5573,5574
< 	rcall	L1154		; cleanup frame
< 	call	L09F7		; will get to a JTAG TAP access
---
> 	rcall	L1154
> 	call	L09F7
6418,6419c5576
< 	jmp	L0115		; set wait timer
< 
---
> 	jmp	L0115
6425,6426d5581
< 
< 
6431,6432c5586,5587
< 	mov	r18,YL
< 	mov	r19,YH
---
> 	mov	r18,r28
> 	mov	r19,r29
6435,6436c5590,5591
< 	mov	r16,YL
< 	mov	r17,YH
---
> 	mov	r16,r28
> 	mov	r17,r29
6442c5597
< 	sbiw	YL,k04
---
> 	sbiw	r28,k04
6467d5621
< L11CA:
6472c5626
< 	subi	r24,k81		; phyisical or emotional
---
> 	subi	r24,k81
6513c5667
< 	adiw	YL,k04
---
> 	adiw	r28,k04
6516d5669
< 
6518,6520c5671,5673
< 	call	L07D1       ; JTAG Command
< 	ldi	ZL,low(P006F)	; k6F P006F
< 	ldi	ZH,high(P006F)
---
> 	call	L07D1
> 	ldi	r30,k6F
> 	ldi	r31,k00
6522d5674
< 
6556c5708
< 	jmp	L07D1        ;  JTAG Command
---
> 	jmp	L07D1
6580d5731
< 
6594d5744
< 
6614d5763
< 
6630,6631c5779,5780
< 	ldi	ZL,low(P02A9)	; P02A9
< 	ldi	ZH,high(P02A9)
---
> 	ldi	r30,kA9
> 	ldi	r31,k02
6677c5826
< 	adiw	YL,k04
---
> 	adiw	r28,k04
6703c5852
< 	sbiw	YL,k04
---
> 	sbiw	r28,k04
6711,6716c5860,5864
< 	jmp	L0115		; set wait timer
< 
< L1292:				; Read Flash memory handler
< 	call	L1541	; C frame (r4:5) XH,XL,r25,r24
< 	sbiw	YL,k02	;
< 	rcall	L116C	; XL:H = *P02A9		get flash page size
---
> 	jmp	L0115
> L1292:
> 	call	L1541
> 	sbiw	r28,k02
> 	rcall	L116C
6718,6722c5866,5870
< 	rcall	L120B	; does something with flags nothing with X or r24:25
< 	rcall	L121A	; put '3' onto C stack
< 	cpi	XL,k81		; if this is the compare then how does r24:25 get
< 	ldi	r16,k00		; into X? Or how is X in
< 	cpc	XH,r16
---
> 	rcall	L120B
> 	rcall	L121A
> 	cpi	r26,k81
> 	ldi	r16,k00
> 	cpc	r27,r16
6724c5872
< 	ldi	r16,k80		; more suspect constants or is this a mask
---
> 	ldi	r16,k80
6729c5877
< 	and	r4,r16		; and the mask suspect
---
> 	and	r4,r16
6731,6733c5879
< 
< 	rcall	L1138	; big tap access does not change r24
< 
---
> 	rcall	L1138
6736c5882
< 	rcall	L11F5	; Gets JTAGID = 0x3F50409 via L1227
---
> 	rcall	L11F5
6738d5883
< 
6743,6745c5888,5889
< L12AA:				; r18 is one or zero
< 
< 	rcall	L121D	; gets JTAGID = 0x3F107809 into register set r20:23
---
> L12AA:
> 	rcall	L121D
6747d5890
< 
6752,6753c5895
< L12AF:				; r16 is one or zero
< 
---
> L12AF:
6757,6758c5899
< 
< 	rcall	L1227	; Gets JTAGID = 0x3F50409 into r16
---
> 	rcall	L1227
6760,6761c5901
< 					
< 	subi	r24,k80	; this constant seems to be part of 0xFF80
---
> 	subi	r24,k80
6764c5904
< 	rcall	L1231	; gets JTAGID = 0x3F107809 into register set r16
---
> 	rcall	L1231
6768c5908
< 	sbci	r25,kFF ; effects an add to get to the end of the table
---
> 	sbci	r25,kFF
6772,6782c5912,5919
< 
< L12BC:				; top of read loop
< 	cp	r4,XL
< 	cpc	r5,XH
< 	brcc	L12CA	; X points to NULL?
< 
< 	rcall	L1215	; r16 is pointer to memory?
< 	call	L0995	; fails inside here
< 	rcall	L11FA	; bump pointers in r4:5
< 	rjmp	L12BC	; and loop
< 
---
> L12BC:
> 	cp	r4,r26
> 	cpc	r5,r27
> 	brcc	L12CA
> 	rcall	L1215
> 	call	L0995
> 	rcall	L11FA
> 	rjmp	L12BC
6785c5922
< 	subi	r16,kF8	; add or subtract 8
---
> 	subi	r16,kF8
6789d5925
< 
6791,6792c5927,5928
< 	rcall	L1211	; TAP 0005?
< 	adiw	YL,k02
---
> 	rcall	L1211
> 	adiw	r28,k02
6794,6797c5930
< 	jmp	L1552		; restore frame
< 
< J12CF:
< ; how do we get here?
---
> 	jmp	L1552
6812d5944
< 
6814c5946
< 	adiw	YL,k04
---
> 	adiw	r28,k04
6818d5949
< 
6826d5956
< 
6838c5968
< 	sbiw	YL,k04
---
> 	sbiw	r28,k04
6867c5997
< 	adiw	YL,k04
---
> 	adiw	r28,k04
6931,6932c6061
< 
< L1342:				; part of read EEPROM_JTAG
---
> L1342:
6949d6077
< 
6953c6081
< 	sbiw	YL,k04
---
> 	sbiw	r28,k04
6978d6105
< 
6997d6123
< 
7018d6143
< 
7021,7022c6146
< 	jmp	L0115		; set wait timer
< 
---
> 	jmp	L0115
7044c6168
< 	adiw	YL,k04
---
> 	adiw	r28,k04
7051c6175
< 	sbiw	YL,k04
---
> 	sbiw	r28,k04
7085c6209
< 	adiw	YL,k04
---
> 	adiw	r28,k04
7107d6230
< 
7109,7111c6232,6234
< 	rcall	L12EC	; C frame
< 	rcall	L1174	; send TAP command 0x105
< 	rcall	L1136	; starts with a push 8 onot data
---
> 	rcall	L12EC
> 	rcall	L1174
> 	rcall	L1136
7113c6236
< 	rcall	L130C	; more frame store
---
> 	rcall	L130C
7115c6238
< 	rcall	L1206	; frame complexity will TAP
---
> 	rcall	L1206
7117,7118c6240
< 	rjmp	L13D0	; very complex
< 
---
> 	rjmp	L13D0
7120,7124c6242
< 	; Init or change the baud rate
< 
< 	ldi	r17,k00			; HI not used?
< 
< #ifdef _M163DEF_INC_
---
> 	ldi	r17,k00
7126,7150c6244,6250
< 	out	UBRR,r16
< 	;					 set the interrupt handler flags
< 	ldi	r16,1<<RXCIE | 1<<RXEN | 1<<TXEN ; k98	
< 	out	UCSRB,r16		; 10011000
< #endif
< 
< #ifdef _M169DEF_INC_
< 	sts	UBRR0H,r17		; set the Baud divisor
< 	sts	UBRR0L,r16
< 		
< ;	ldi	r16,1<<U2X		; Double speed
< ;	sts	UCSR0A,r16		
< 	
< 	ldi	r16,1<<UCSZ1 | 1<<UCSZ0 ; 8N1
< 	sts	UCSR0C,r16
< 
< 	;					 set the interrupt handler flags
< 	ldi	r16,1<<RXCIE | 1<<RXEN | 1<<TXEN
< 	sts	UCSR0B,r16		
< #endif
< 
< 	sts	D036A,r17		; in ring in
< 	sts	D0369,r17		; in ring out
< 	sts	D037C,r17		; out ring in
< 	sts	D037B,r17		; out ring out
---
> 	out	UBBR,r16
> 	ldi	r16,k98
> 	out	UCSRA,r16
> 	sts	D036A,r17
> 	sts	D0369,r17
> 	sts	D037C,r17
> 	sts	D037B,r17
7154,7158c6254,6256
< 
< 
< L13EA:					; Recieve RX handler
< 	st	-Y,ZH			; Save C frame
< 	st	-Y,ZL
---
> L13EA:
> 	st	-Y,r31
> 	st	-Y,r30
7160c6258
< 	st	-Y,r18			; mark for dead register optimization
---
> 	st	-Y,r18
7163,7174c6261,6263
< 	in	r19,SREG		; protect status
< #ifdef _M163DEF_INC_
< 	in	r17,UDR			; get byte
< #endif
< #ifdef _M169DEF_INC_
< 	lds r17,UDR0
< ; set LCD_AN2 to indicate I/O
< 	lds r16,LCDDR0
< 	sbr r16,1<<LCD_AN2	; set the io annuciator
< 	sts LCDDR0,r16
< #endif
< 	lds	r16,D0369		; increment ring counter
---
> 	in	r19,SREG
> 	in	r17,UDR
> 	lds	r16,D0369
7176,7182c6265,6271
< 	andi	r16,k3F		; mask ring to size
< 	sts	D0369,r16		; save input ring counter
< 	lds	r18,D036A		; touch output ring counter
< 	rcall	L1404		; Z = r16 -FCD7 = inRing[r16]
< 	std	Z+o00,r17		; save input byte into ring
< 	out	SREG,r19		; restore state
< 	ld	r16,Y+			; restore C frame
---
> 	andi	r16,k3F
> 	sts	D0369,r16
> 	lds	r18,D036A
> 	rcall	L1404
> 	std	Z+o00,r17
> 	out	SREG,r19
> 	ld	r16,Y+
7184c6273
< 	ld	r18,Y+			; output ring counter NOT returned
---
> 	ld	r18,Y+
7186,7187c6275,6276
< 	ld	ZL,Y+
< 	ld	ZH,Y+
---
> 	ld	r30,Y+
> 	ld	r31,Y+
7192,7195c6281,6284
< 	mov	 ZL,r16
< 	ldi	 ZH,k00
< 	subi ZL,low(0xFFFF-P0328) ;kD7	; 329 is the real start
< 	sbci ZH,high(0xFFFF-P0328);kFC
---
> 	mov	r30,r16
> 	ldi	r31,k00
> 	subi	r30,kD7
> 	sbci	r31,kFC
7199,7203c6288,6290
< 
< L1409:					; TX complete handler
< 						; data register empty routine
< 	st	-Y,ZH			; Save C frame
< 	st	-Y,ZL	
---
> L1409:
> 	st	-Y,r31
> 	st	-Y,r30
7207,7232c6294,6309
< 	in	 r18,SREG		; save status state
< 	lds	 r16,D037B		; output ring counters
< 	lds	 r17,D037C
< 	cp	 r16,r17		; when counters equal
< 	breq L1422			; ring is empty
< 	lds	 r16,D037C		; output ring out counter
< 	inc	 r16
< 	andi r16,k0F		; cycle the ring
< 	sts	 D037C,r16		; save the ring pointer
< 	mov	 ZL,r16			; de reference the array index
< 	ldi	 ZH,k00
< 	subi ZL,low(0xFFFF-D036A) ; k95 +36B is the real start 
< 	sbci ZH,high(0xFFFF-D036A); kFC
< 	ldd	 r16,Z+o00		; get data from ring
< #ifdef _M163DEF_INC_	; transmit it
< 	out	 UDR,r16
< 	rjmp L1423
< L1422:
< 	cbi	UCSRB,UDRIE
< #endif
< 
< #ifdef _M169DEF_INC_
< 	sts UDR0,r16
< ;set LCD_AN2
< 
< 	rjmp L1423
---
> 	in	r18,SREG
> 	lds	r16,D037B
> 	lds	r17,D037C
> 	cp	r16,r17
> 	breq	L1422
> 	lds	r16,D037C
> 	inc	r16
> 	andi	r16,k0F
> 	sts	D037C,r16
> 	mov	r30,r16
> 	ldi	r31,k00
> 	subi	r30,k95
> 	sbci	r31,kFC
> 	ldd	r16,Z+o00
> 	out	UDR,r16
> 	rjmp	L1423
7234,7239c6311
< ; Clear LCD_AN2
< 	lds r16,UCSR0B
< 	cbr	r16,1<<UDRIE	
< 	sts	UCSR0B,r16
< #endif
< 
---
> 	cbi	UCSRA,b5
7241,7242c6313,6314
< 	out	SREG,r18		; restore status state
< 	ld	r16,Y+			; restore C stack frame
---
> 	out	SREG,r18
> 	ld	r16,Y+
7245,7246c6317,6318
< 	ld	ZL,Y+
< 	ld	ZH,Y+
---
> 	ld	r30,Y+
> 	ld	r31,Y+
7250,7274c6322,6331
< ;*************************************
< ; access input ring
< ;*************************************
< ;
< _getchar:        ;  L142A:					; from L0796
< 	rcall L1436			; Test ring empty
< 	breq  _getchar      ;  L142A Ring is empty
< 
< ; clear the LCD IO state
< #ifdef _M169DEF_INC_
< 	;rcall L1436
< 	;brne X1435	
< 	lds r16,LCDDR0
< 	cbr r16,1<<LCD_AN2	; clear the io annuciator
< 	sts LCDDR0,r16
< ;X1435:
< #endif
< 
< 	lds   r16,D036A		; ring index
< 	inc	  r16			; ++	
< 	andi  r16,k3F
< 	sts	  D036A,r16		; ring out pointer bumped
< 	ldi	  r17,k00		; derefernce ring array
< 	rcall L1404			; Z = r16 - FCD7
< 	ldd	  r16,Z+o00		; r16 = inRing[r16]
---
> L142A:
> 	rcall	L1436
> 	breq	L142A
> 	lds	r16,D036A
> 	inc	r16
> 	andi	r16,k3F
> 	sts	D036A,r16
> 	ldi	r17,k00
> 	rcall	L1404
> 	ldd	r16,Z+o00
7276d6332
< 
7279,7280c6335,6336
< L1436:					; compare command
< 	lds	r16,D0369		; ring empty?
---
> L1436:
> 	lds	r16,D0369
7284,7285d6339
< 
< 
7288,7291c6342,6345
< _putchar:				; L143C  transmit byte
< 	lds  r18,D037B		; outRing in index
< 	inc	 r18
< 	andi r18,k0F
---
> L143C:
> 	lds	r18,D037B
> 	inc	r18
> 	andi	r18,k0F
7293,7314c6347,6356
< 	lds	 r19,D037C		; outRing output index
< 	cp	 r18,r19		; test outRing empty
< 	breq L1440			; ring empty
< 	mov	 ZL,r18			; deref outRing[r18++]
< 	ldi	 ZH,k00
< 	subi ZL,low(0xFFFF-D036A)	; k95 +36A 
< 	sbci ZH,high(0xFFFF-D036A); kFC
< 	std	 Z+o00,r16		; save byte into ring
< 	sts	 D037B,r18
< #ifdef _M163DEF_INC_
< 	sbi	 UCSRB,UDRIE	; b5 enable transmit interrupt
< #endif
< 
< #ifdef _M169DEF_INC_
< 	lds r16,UCSR0B		; slight difference this touches r16
< 	sbr	r16,1<<UDRIE	; which will be voided on return
< 	sts	UCSR0B,r16
< 
< 	; Set the LCD_AN2 to indicate IO in progress
< 
< #endif
< 
---
> 	lds	r19,D037C
> 	cp	r18,r19
> 	breq	L1440
> 	mov	r30,r18
> 	ldi	r31,k00
> 	subi	r30,k95
> 	sbci	r31,kFC
> 	std	Z+o00,r16
> 	sts	D037B,r18
> 	sbi	UCSRA,b5
7316,7317d6357
< 
< 
7320c6360
< L144D:					; test inRing empty
---
> L144D:
7332,7335d6371
< 
< ;*************************************
< ; MEP mph MLH Main reset entry point
< ;*************************************
7338c6374
< 	ldi	r16,low(RAMEND - 195) ;0x9C	; setup stack
---
> 	ldi	r16,k9C
7340c6376
< 	ldi	r16,high(RAMEND -195) ;0x03
---
> 	ldi	r16,k03
7342,7352c6378,6383
< 
< 	ldi	YL,low(RAMEND - 66)	; k1D interupt stack frame?
< 	ldi	YH,high(RAMEND - 66); k04
< 
< 	call	L012B	; init uart,
< 					; ports, and adc
< 
< 	tst	r16			; init returns 1
< 	breq	L145F	
< 	call	L1588	; uses table at L0091
< 
---
> 	ldi	r28,k1D
> 	ldi	r29,k04
> 	call	L012B
> 	tst	r16
> 	breq	L145F
> 	call	L1588
7354,7364c6385,6389
< 	ldi	 r16,k00	; note bit position change
< 	out	 iMSK,r16	; we have no external interrupts
< 
< 	call L0144		; calls init sign on
< 					; wait for 2 sync bytes then init the system
< 
< 	call L15BA		; go to sleep it is the 
< 	jmp	 L15BA		; end of the world.
< 
< 
< 
---
> 	ldi	r16,k00
> 	out	GIMSK,r16
> 	call	L0144
> 	call	L15BA
> 	jmp	L15BA
7373d6397
< 
7512c6536
< 	rcall	PEEKPP        ;  L1534
---
> 	rcall	L1534
7514c6538
< 	rcall	PEEKPP        ;  L1534
---
> 	rcall	L1534
7517c6541
< 	rcall	PEEKPP        ;  L1534	; read 5 from program memory
---
> 	rcall	L1534
7519,7521c6543,6544
< 
< L14DA:				; read 4 from prgm mem
< 	rcall	PEEKPP        ;  L1534	; read prog mem, increment
---
> L14DA:
> 	rcall	L1534
7523c6546
< 	rcall	PEEKPP        ;  L1534	; read prog mem, increment
---
> 	rcall	L1534
7525,7528c6548,6551
< 	bst	r0,b1		; update T flag
< 	rcall	PEEKPP        ;  L1534	; read prog mem, increment
< 	mov	r2,r0		
< 	rcall	PEEKPP        ;  L1534	; read prog mem, increment
---
> 	bst	r0,b1
> 	rcall	L1534
> 	mov	r2,r0
> 	rcall	L1534
7530c6553
< 	ret				; r2:r3 contains address for ijmp
---
> 	ret
7534c6557
< 	rcall	L14DA	; read 4 from prgm mem
---
> 	rcall	L14DA
7538,7542c6561,6563
< 
< 
< L14E8:				; jump table func
< 	rcall	L14D8	; read 5 from prog memory
< 	sub	r16,r20		; r16 is the command byte
---
> L14E8:
> 	rcall	L14D8
> 	sub	r16,r20
7548d6568
< 
7554d6573
< 
7556,7558c6575,6576
< 	brcs	L1510	; will perform the ijmp in r2:r3
< 
< 	sbrc	r1,b0	; r1 contains jmp flags
---
> 	brcs	L1510
> 	sbrc	r1,b0
7560,7561c6578
< 
< 	rcall	PEEKPP  ;  L1534
---
> 	rcall	L1534
7563c6580
< 	rcall	PEEKPP  ;  L1534
---
> 	rcall	L1534
7585,7586c6602,6603
< 	add	ZL,r16
< 	adc	ZH,r17
---
> 	add	r30,r16
> 	adc	r31,r17
7588c6605
< 	rcall	PEEKPP        ;  L1534
---
> 	rcall	L1534
7590c6607
< 	rcall	PEEKPP        ;  L1534
---
> 	rcall	L1534
7592d6608
< 
7594,7597c6610,6612
< 	mov	ZL,r2		; this will effect the
< 	mov	ZH,r3		; program control transfer
< 	ijmp			; to the function.
< 
---
> 	mov	r30,r2
> 	mov	r31,r3
> 	ijmp
7603c6618
< 	brtc	L150C		; deref and jump
---
> 	brtc	L150C
7605,7607c6620,6621
< 
< L1516:					; case (jump) table calculator
< 	adiw	ZL,k01
---
> L1516:
> 	adiw	r30,k01
7609c6623
< 	adiw	ZL,k01		; skip over function address
---
> 	adiw	r30,k01
7614c6628
< 	rcall	PEEKPP      ;  L1534
---
> 	rcall	L1534
7618c6632
< 	breq	L1510		; jump now
---
> 	breq	L1510
7623c6637
< 	rcall	PEEKPP      ;  L1534
---
> 	rcall	L1534
7625c6639
< 	rcall	PEEKPP      ;  L1534
---
> 	rcall	L1534
7628c6642
< 	rcall	PEEKPP      ;  L1534
---
> 	rcall	L1534
7631c6645
< 	rcall	PEEKPP      ;  L1534
---
> 	rcall	L1534
7638,7639c6652,6653
< 	breq	L1514		; deref and jump
< 	brcs	L1510		; jump now
---
> 	breq	L1514
> 	brcs	L1510
7641,7642c6655
< 
< PEEKPP:        			; L1534 peek at program memory
---
> L1534:
7644c6657
< 	adiw	ZL,k01
---
> 	adiw	r30,k01
7704,7705c6717,6718
< 	add	YL,r30
< 	adc	YH,r31
---
> 	add	r28,r30
> 	adc	r29,r31
7710,7711d6722
< 
< J155F:
7713,7714c6724
< 	jmp	_putchar        	;  L143C transmit byte from ring
< 
---
> 	jmp	L143C
7716,7726c6726,6735
< 	sbiw YL,k02				; from L04E4
< 	mov	 r20,YL				; 1 word (2byte)
< 	mov	 r21,YH				; onto the stack	
< 	subi r20,kFE			; frame
< 	sbci r21,kFF
< 	
< 	std	 Y+o00,r20			; save stack ref
< 	std	 Y+o01,r21
< 	mov	 r20,YL				; store stack
< 	mov	 r21,YH				; ref onto
< 	st	-Y,r21				; parameter stack
---
> 	sbiw	r28,k02
> 	mov	r20,r28
> 	mov	r21,r29
> 	subi	r20,kFE
> 	sbci	r21,kFF
> 	std	Y+o00,r20
> 	std	Y+o01,r21
> 	mov	r20,r28
> 	mov	r21,r29
> 	st	-Y,r21
7728,7733c6737,6742
< 	ldi	 r22,k00	
< 	ldi	 r23,k00
< 	ldi	 r20,low(J155F)  	; enable transmitter k5F
< 	ldi	 r21,high(J155F) 	; 					 k15
< 	call L15BD
< 	adiw YL,k02
---
> 	ldi	r22,k00
> 	ldi	r23,k00
> 	ldi	r20,k5F
> 	ldi	r21,k15
> 	call	L15BD
> 	adiw	r28,k02
7737,7738c6746,6747
< L1575:						; clear a variable
< 	ldi	r18,k00				; pointed to by X
---
> L1575:
> 	ldi	r18,k00
7745c6754
< L157A:						; rangecheck
---
> L157A:
7751d6759
< 
7754,7756d6761
< ; this seems to be an incompatable var init function
< ; given that the values to epm are out of range for
< ; the 163 or the mega16.
7758,7763c6763,6768
< 	out	RAMPZ,r19	; for this to work
< 	lpm				; elpm would be
< 	subi ZL,kFF		; defined on a large
< 	sbci ZH,kFF		; processor, which
< 	sbci r19,kFF	; does not seem to apply
< 	st	 X+,r0		; to the m163
---
> 	out	GIMSK,r19
> 	.dw	0x95D8	; i-o-m ; pc=0x1580(0x2B00)
> 	subi	r30,kFF
> 	sbci	r31,kFF
> 	sbci	r19,kFF
> 	st	X+,r0
7770,7771c6775,6776
< 	ldi	r16,low(L0091*2) ;k22 ; L0091 
< 	ldi	r17,high(L0091*2)
---
> 	ldi	r16,k22
> 	ldi	r17,k01
7774d6778
< 
7776,7805c6780,6805
< 	mov	ZL,r4
< 	mov	ZH,r5
< 
< 	ldi	r19,k00		; extended memory address
< 	out	RAMPZ,r19	; may be rampz
< 	lpm				; for elpm
< 	mov	r16,r0		; 14
< 	rcall	L15B7	; Z+1 lpm
< 	mov	r17,r0		; 03
< 
< 	mov	 ZL,r4		; 122
< 	mov	 ZH,r5
< 	adiw ZL,k02
< 	lpm				; @124
< 	mov	XL,r0		; low(0069)
< 	rcall	L15B7	; Z+1 lpm
< 	mov	 XH,r0		; high 0069 X now contains the address 
< 					; to clear			
< 	mov	 ZL,r4		; 122
< 	mov	 ZH,r5
< 	adiw ZL,k04		; 126
< 	lpm
< 	mov	r20,r0		; byte 1 0
< 	rcall	L15B7	; Z+1 lpm
< 	mov	r21,r0		; byte 2 0
< 	rcall	L15B7	; Z+1 lpm
< 	mov	ZL,r20
< 	mov	ZH,r21
< 	mov	r19,r0		; 0 is this rampz ?
< 	
---
> 	mov	r30,r4
> 	mov	r31,r5
> 	ldi	r19,k00
> 	out	GIMSK,r19
> 	.dw	0x95D8	; i-o-m ; pc=0x1590(0x2B20)
> 	mov	r16,r0
> 	rcall	L15B7
> 	mov	r17,r0
> 	mov	r30,r4
> 	mov	r31,r5
> 	adiw	r30,k02
> 	.dw	0x95D8	; i-o-m ; pc=0x1597(0x2B2E)
> 	mov	r26,r0
> 	rcall	L15B7
> 	mov	r27,r0
> 	mov	r30,r4
> 	mov	r31,r5
> 	adiw	r30,k04
> 	.dw	0x95D8	; i-o-m ; pc=0x159E(0x2B3C)
> 	mov	r20,r0
> 	rcall	L15B7
> 	mov	r21,r0
> 	rcall	L15B7
> 	mov	r30,r20
> 	mov	r31,r21
> 	mov	r19,r0
7810,7811c6810,6811
< 	rcall	L157F	; init constants
< 	rjmp	L15AD	; table is out of range
---
> 	rcall	L157F
> 	rjmp	L15AD
7813,7816c6813
< 	rcall	L1575	; clears n bytes
< 					; defined at address
< 					; L0091 L0092 is
< 					; the starting address
---
> 	rcall	L1575
7818c6815
< 	ldi	r16,k07		; add 7 to address
---
> 	ldi	r16,k07
7824,7827c6821,6823
< 
< 	cpi	 r20,low(L0098*2) 	; k30		; L0098
< 	sbci r21,high(L0098*2)	; k01
< 	brcs L158C				; the loop
---
> 	cpi	r20,k30
> 	sbci	r21,k01
> 	brcs	L158C
7832,7833c6828,6829
< 	adiw	ZL,k01
< 	lpm
---
> 	adiw	r30,k01
> 	.dw	0x95D8	; i-o-m ; pc=0x15B8(0x2B70)
7835d6830
< 
7843d6837
< 
7845,7848c6839,6842
< 	call	L1537		; push stack frame
< 	sbiw	YL,k07
< 	std	Y+o04,r16		; 7 params on stack
< 	std	Y+o05,r17		; gives us 2 meta params
---
> 	call	L1537
> 	sbiw	r28,k07
> 	std	Y+o04,r16
> 	std	Y+o05,r17
7850d6843
< 
7855d6847
< 
7861d6852
< 
7863,7864c6854
< 	rcall	L1689		; gets to an icall
< 						; that transmits data
---
> 	rcall	L1689
7866,7880c6856,6866
< 	; transmits a string pointed to by
< 	; Z
< 	rcall L168D			; load *Z+ from Y+4
< 	ldi	 r16,k25
< 	cp	 r0,r16			; test for 0x25
< 	breq L15D9
< 	tst	 r0
< 	brne L15CC			; look up ^^^^^^
< 	mov	 r16,r12		;   for loop
< 	mov	 r17,r13
< 	adiw YL,k07
< 	ldi	 ZL,k12
< 	jmp	 L1548			; restore stack frame
< 						; and return
< 
---
> 	rcall	L168D
> 	ldi	r16,k25
> 	cp	r0,r16
> 	breq	L15D9
> 	tst	r0
> 	brne	L15CC
> 	mov	r16,r12
> 	mov	r17,r13
> 	adiw	r28,k07
> 	ldi	r30,k12
> 	jmp	L1548
7882,7889c6868,6875
< 	ldi	 r21,k00
< 	ldi	 r20,k00
< 	lpm  ;elpm
< 	mov	 r16,r0
< 	subi r16,k68
< 	breq L15E3
< 	subi r16,k04
< 	brne L15EA
---
> 	ldi	r21,k00
> 	ldi	r20,k00
> 	.dw	0x95D8	; i-o-m ; pc=0x15DB(0x2BB6)
> 	mov	r16,r0
> 	subi	r16,k68
> 	breq	L15E3
> 	subi	r16,k04
> 	brne	L15EA
7891,7892c6877
< 	rjmp L15E4
< 
---
> 	rjmp	L15E4
8085d7069
< 
8091d7074
< 
8093,8101c7076,7084
< 	ldd	 ZL,Y+o04
< 	ldd	 ZH,Y+o05
< 	ldd	 r19,Y+o06
< 	out	 RAMPZ,r19
< 	lpm
< 	mov	 r10,r0
< 	adiw ZL,k01
< 	std	 Y+o04,ZL
< 	std	 Y+o05,ZH
---
> 	ldd	r30,Y+o04
> 	ldd	r31,Y+o05
> 	ldd	r19,Y+o06
> 	out	GIMSK,r19
> 	.dw	0x95D8	; i-o-m ; pc=0x1691(0x2D22)
> 	mov	r10,r0
> 	adiw	r30,k01
> 	std	Y+o04,r30
> 	std	Y+o05,r31
8137d7119
< 
8141,8142c7123,7124
< 	ldd	ZL,Y+o00
< 	ldd	ZH,Y+o01
---
> 	ldd	r30,Y+o00
> 	ldd	r31,Y+o01
8146d7127
< 
8172,9286c7153,9559
< P2D8E:
< 	.db 0x01,0x17,0x01,low(J0CCB),high(J0CCB),0x01,0x00,0x00,0x00,0xFF
< ;	    1	 2	  3	   4    5    6    7    8    9	
< ;            Baud
< #ifdef _M169DEF_INC_
< VTABL:
< 	.dw 2815,2818,2820,2824,2827,2832,2835,2839,2841,2843,2847,2850
<     .dw 2853,2857,2863,2867,2870,2874,2882,2893,2917,2939,2942
< 
< 
< ;---------------------------------------
< ;<eof>
< ;===============================================================================
< ; 
< ; //////////////////////////////////////////////////////////////////////////////
< ; //                                                                          //
< ; //   File Name:     ButterflyBoot2.asm                                      //
< ; //   Target MCU:    ATmega169                                               //
< ; //   Compiler:      AVRStudio v4.12, Assembler v2                           //
< ; //   Description:   An enhanced bootloader for the ATMEL Butterfly unit     //
< ; //   Copyright (C) 2006 George Kolovos   <gkolovos AT hotmail DOT com>      //
< ; //                                                                          //
< ; // This program is free software; you can redistribute it and/or modify     //
< ; // it under the terms of the GNU General Public License as published by     //
< ; // the Free Software Foundation; either version 2 of the License, or        //
< ; // (at your option) any later version.                                      //
< ; //                                                                          //
< ; // This program is distributed in the hope that it will be useful,          //
< ; // but WITHOUT ANY WARRANTY; without even the implied warranty of           //
< ; // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
< ; // GNU General Public License for more details.                             //
< ; //                                                                          //
< ; // You should have received a copy of the GNU General Public License (*)    //
< ; // along with this program; if not, write to the Free Software              //
< ; // Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA //
< ; //                                                                          //
< ; // (*) This Licence can be viewed at http://www.fsf.org/licenses/gpl.txt    //
< ; //                                                                          //
< ; //////////////////////////////////////////////////////////////////////////////
< ; 
< ; 
< ; 
< ; 	Revision History:
< ; 
< ;  v1.0 (Mar 24 2006): Code rearrangements, in order to support all the programming modes!
< ; 			Supported: Word/Block mode, FLASH/EEPROM read/write and LOCK/FUSE read access
< ;  v0.9 (Mar 19 2006): [Internal, beta release] Minor bugfixes and code optimizations
< ; 			Based on my own "ButterflyBoot.asm", Copyright(C) 2006 George Kolovos
< ; 			Added:    Power-Management routines
< ; 			Improved: The Programming Engine
< ; 			Improved: The Oscillator-Calibration function accuracy
< ; 			Removed:  The FLASH Word-mode access routines
< ; 			Removed:  The Lock-Bits writing function
< ; 
< ; 
< ; This is is a new Butterfly bootloader, based on my own LGPL "ButterflyBoot.asm"
< ; 
< ; Major enhancements of ButterflyBoot2:
< ;  * The addition of Power Management routines, to maximize the battery life
< ;  * Fragents of the Programming Engine have been rewritten and optimized
< ;  * The code still fits into the 512W bootloader!
< ;  * Improved Oscillator-Calibration accuracy.
< ; 
< ; 
< ; 
< ; 
< ; 
< ; 
< ;========================  AVRStudio assembler reports: ========================
< ; 
< ;   ButterflyBoot.asm assembled file:
< ; ATmega169 memory use summary [bytes]:
< ; Segment   Begin    End      Code   Data   Used    Size   Use%
< ; ---------------------------------------------------------------
< ; [.cseg] 0x003c00 0x003fe8    928      8    936   16384   5.7%
< ; [.dseg] 0x000100 0x000180      0    128    128    1024  12.5%
< ; [.eseg] 0x000000 0x000000      0      0      0     512   0.0%
< ; 
< ; 
< ;   The original "butterfly_boot_rev03.hex" file:
< ; ATmega169 memory use summary [bytes]:
< ; Segment   Begin    End      Code   Data   Used    Size   Use%
< ; ---------------------------------------------------------------
< ; [.cseg] 0x003800 0x003df6   1518      8   1526   16384   9.3%
< ; [.dseg] 0x000100 0x000100      0      0      0    1024   0.0%
< ; [.eseg] 0x000000 0x000000      0      0      0     512   0.0%
< ; 
< ; 
< ; 
< ; 
< ;===============================================================================
< ;			System parameters
< ;===============================================================================
< 
< ; 
< ;		#####	CPU specific parameters:
< ;		---------------------------------
< ;  Uncomment the following entries, to be reported as an ATmega16_Boot
< ;.equ	PartCode   = 0x75	; m16boot  AVRprog.exe v1.40 Part Code
< ;.equ	PartSign   = 0x1E9403	; m16 Part Signature
< ;  Uncomment the following entries, to be reported as an ATmega169_Boot
< .equ	PartCode   = 0x79	; m169boot AVRprog.exe v1.40 Part Code
< .equ	PartSign   = 0x1E9405	; m169 Part Signature
< ; 
< .equ	Block_Size = PAGESIZE*2	; Block size, in Bytes
< ; 
< ;.equ	BootStart  = SMALLBOOTSTART	; Smallest boot block:    128W (@ 0x1F80)
< ;.equ	BootStart  = SECONDBOOTSTART	; Second boot block size: 256W (@ 0x1F00)
< ;.equ	BootStart  = THIRDBOOTSTART	; Third boot block size:  512W (@ 0x1E00)
< .equ	BootStart  = LARGEBOOTSTART	; Largest boot block:      1KW (@ 0x1C00)
< ; 
< .equ	BootLoaderRevH	= 'R'	; Bootloader software revision -Major
< .equ	BootLoaderRevL	= '2'	; Bootloader software revision -Minor
< ; 
< ;.equ	UBRR_Value =        12	; 19200 bps at CPU_Freq = 2 MHz, Double Speed, Error +0.2%
< ;.equ	Upper_Limmit =   15724	; = 15600 ± 124 TC1 count
< ;.equ	Lower_Limmit =   15476
< ; 
< ; 
< ; 	
< ;		#####	Register definitions:
< ;		---------------------------------
< ;.def		= r0	; temp for SPM & LPM
< ;.def		= r1	; temp for SPM
< .def	FLStpL	= r2	; TOP Programable-FLASH Address in Bytes
< .def	FLStpH	= r3	; 
< .def	RAMbsL	= r4	; RAM Buffer Block_Size = Page_Size in Bytes
< .def	RAMbsH	= r5	; 
< .def	PGMbsL	= r6	; Programmer Block_Size request in Bytes
< .def	PGMbsH	= r7	; 
< .def	SlpIdl	= r8	; Idle sleep mode value
< .def	SlpPsv	= r9	; Power-save sleep mode value
< ;.def		= r10	; 
< ;.def		= r11	; 
< ;.def		= r12	; 
< ;.def		= r13	; 
< .def	UDRrx	= r14	; USART input buffer
< .def	Zero	= r15	; Ct. = 0x00
< .def	tmp1	= r16	; Temporary #1
< .def	SPM_act	= r17	; SPM action register
< ;.def		= r18	; 
< ;.def		= r19	; 
< ;.def		= r20	; 
< ;.def		= r21	; 
< ;.def		= r22	; 
< ;.def		= r23	; 
< .def	AddrL	= r24	; 16-bit Address register-set
< .def	AddrH	= r25	;  AddrH:AddrL
< ;.def	XL	= r26	; 16-bit Pointer X; Used as a 16-bit temp register
< ;.def	XH	= r27	; 
< ;.def	YL	= YL	; 16-bit RAM Buffer Block Pointer
< ;.def	YH	= YH	; 
< ;.def	ZL	= r30	; 16-bit FLASH Pointer
< ;.def	ZH	= r31	; 
< 	
< ; GPIOR0 flags register: [Err,-,-,-,wSp,wEr,wTx,wRx]
< .equ	wRx	= 0 ; Wait USART reception to finish
< .equ	wTx	= 1 ; Wait USART transmission to finish
< .equ	wEr	= 2 ; Wait EEWE to clear
< ;.equ	wSp	= 3 ; Wait SPMEN to clear
< ;.equ		= 4 ; 
< ;.equ		= 5 ; 
< ;.equ		= 6 ; 
< ;.equ	Err	= 7 ; Universal error
< 	
< 	
< 	
< ;===============================================================================
< ;.dseg		; SRAM Segment
< ;===============================================================================
< ;RAM_Block:	.byte Block_Size	; Block buffer in RAM (32/64/128/256 Bytes)
< .equ RAM_Block 	= SRAM_START
< 	
< 	
< ;===============================================================================
< .cseg		; Boot Sector: Interrupt Vectors & Interrupts
< ;===============================================================================
< .org	BootStart+0x00	rjmp	RESET		; Reset Handler
< ;.org	BootStart+0x02	rjmp	EXT_INT0	; IRQ0 Handler
< ;.org	BootStart+0x04	rjmp	PCINT0		; PCINT0 Handler
< .org	BootStart+0x06;	rjmp	PCINT1		; PCINT1 Handler
< 			reti
< ;.org	BootStart+0x08	rjmp	TIM2_COMP	; TC2 Compare Handler
< ;.org	BootStart+0x0A	rjmp	TIM2_OVF	; TC2 Overflow Handler
< ;.org	BootStart+0x0C	rjmp	TIM1_CAPT	; TC1 Capture Handler
< ;.org	BootStart+0x0E	rjmp	TIM1_COMPA	; TC1 CompareA Handler
< ;.org	BootStart+0x10	rjmp	TIM1_COMPB	; TC1 CompareB Handler
< ;.org	BootStart+0x12	rjmp	TIM1_OVF	; TC1 Overflow Handler
< ;.org	BootStart+0x14	rjmp	TIM0_COMP	; TC0 Compare Handler
< ;.org	BootStart+0x16	rjmp	TIM0_OVF	; TC0 Overflow Handler
< ;.org	BootStart+0x18	rjmp	SPI_STC		; SPI Transfer Complete Handler
< .org	BootStart+0x1A;	rjmp	USART_RXC	; USART RX Complete Handler
< 			lds	UDRrx,UDR0	; Get the Input byte
< 			 cbi	GPIOR0,wRx	; Ready!
< 			 reti
< ;.org	BootStart+0x1C	rjmp	USART_DRE	; USART,UDR Empty Handler
< .org	BootStart+0x1E;	rjmp	USART_TXC	; USART TX Complete Handler
< 			cbi	GPIOR0,wTx	; Ready!
< 			 reti
< ;.org	BootStart+0x20	rjmp	USI_STRT	; USI Start Condition Handler
< ;.org	BootStart+0x22	rjmp	USI_OVFL	; USI Overflow Handler
< ;.org	BootStart+0x24	rjmp	ANA_COMP	; Analog Comparator Handler
< ;.org	BootStart+0x26	rjmp	ADCC		; ADC Conversion Complete Handler
< .org	BootStart+0x28;	rjmp	EE_RDY		; EEPROM Ready Handler
< 			cbi	GPIOR0,wEr	; Ready!
< 			 reti
< .org	BootStart+0x2A;	rjmp	SPM_RDY		; SPM Ready Handler
< 			out	SPMCSR,Zero	; [SPMIE,RWWSB,,RWWSRE,BLBSET,PGWRT,PGERS,SPMEN]
< 			 reti
< ;.org	BootStart+0x2C	rjmp	LCD_SOF		; LCD Start of Frame Handler
< 	
< 	
< 	
< 	
< 	
< ;===============================================================================
< RESET:
< ;===============================================================================
< ; Stack setup
< 	ldi	tmp1,Byte1(RAMEND)
< 	out	SPL,tmp1
< 	ldi	tmp1,Byte2(RAMEND)
< 	out	SPH,tmp1
< 		
< 	; Setup the registers/modules
< 	clr	Zero
< 	rcall	OSC_Calibration
< 
< 	; Analog comparator
< 	ldi	tmp1,1<<ACD		; Disable the Analog Comparator
< 	out	ACSR,tmp1		; ACSR = [ACD,ACBG,ACO,ACI,ACIE,ACIC,ACIS1,ACIS0]
< 	
< ;	rjmp THIRDBOOTSTART	; Pre init the Butterfly LCD to show application name
< 
< RealBOOT:
< 
< 	; I/O PORTS
< 	ser	tmp1			; Set the Pull-Ups to all the PORTs
< 	out	PORTA,tmp1
< 	out	PORTB,tmp1
< 	out	PORTC,tmp1
< 	out	PORTD,tmp1
< 	out	PORTE,tmp1
< 	out	PORTG,tmp1
< 	
< 
< 	; Disable the digital input buffers on the AIN1/0
< 	ldi	tmp1,1<<AIN1D|1<<AIN0D 
< 	sts	DIDR1,tmp1		; [-,-,-,-,-,-,AIN1D,AIN0D]
< 		
< 	; Power Reduction Register
< 	ldi	tmp1,1<<PRLCD|1<<PRTIM1|1<<PRSPI|1<<PRADC
< 	sts	PRR,tmp1		; [-,-,-,PRLCD,PRTIM1,PRSPI,PRUSART0,PRADC]
< 		
< 	; USART
< 	ldi	tmp1,Byte1(UBRR_Value) ; 19200 bps (= 2*9600,at 2MHz)
< 	sts	UBRR0L,tmp1
< 	sts	UBRR0H,Zero
< 		
< ;	ldi	tmp1,1<<U2X		; Double speed
< ;	sts	UCSR0A,tmp1		; [RXC,TXC,UDRE,FE,DOR,UPE,U2X,MPCM]
< 	
< 	ldi	tmp1,1<<UCSZ1|1<<UCSZ0 ; 8N1
< 	sts	UCSR0C,tmp1		; [URSEL,UMSEL,UPM1,UPM0,USBS,UCSZ1,UCSZ0,UCPOL]
< 	ldi	tmp1,1<<RXCIE|1<<TXCIE|1<<RXEN|1<<TXEN
< 	sts	UCSR0B,tmp1		; [RXCIE,TXCIE,UDRIE,RXEN,TXEN,UCSZ2,RXB8,TXB8]
< 		
< 	; Pin Change Interrupts
< 	ldi	tmp1,0x50	; Enable the PCINT14 and PCINT12
< 	sts	PCMSK1,tmp1
< 	ldi	tmp1,1<<PCIF1	; Enable the Pin Change Interrupt 1 (PCINT15...08)
< 	out	EIFR,tmp1		; [PCIF1,PCIF0,-,-,-,-,-,INTF0]
< 	out	EIMSK,tmp1		; [PCIE1,PCIE0-,-,-,-,-,INT0]
< 	
< 	; Interrupt Vectors setup
< 	ldi	tmp1,1<<IVCE	; unlock for change
< 	out	MCUCR,tmp1		
< 	ldi	tmp1,1<<IVSEL	; Place the Interrupt Vectors, at the Boot section
< 	out	MCUCR,tmp1
< 		
< 	; Register setup: Programming constants
< 	ldi	 XL,Byte1(Block_Size) ; RAM Buffer Block-Size (Bytes)
< 	ldi	 XH,Byte2(Block_Size)
< 	movw RAMbsL,XL
< 	ldi	 XL,Byte1(2*BootStart) ; TOP Address of Programable-FLASH (Bytes)
< 	ldi	 XH,Byte2(2*BootStart)
< 	movw FLStpL,XL
< 	
< 	; Register setup: Sleep modes setup
< 	ldi	 XL,1<<SE		; Value to enable the Idle sleep mode
< 	ldi	 XH,1<<SM1|1<<SM0|1<<SE ; Value to enable the Power-save sleep mode
< 	movw SlpIdl,XL
< 	
< 	; Hardware is ready!
< 	sei
< 		
< 		
< 	; What to do now?
< Boot_Check_1:	
<  	sbic PINB,6			; PB6: Joystick Button 'UP'
< 	rjmp Boot_Check_2
< 		
< ; Jump to the Application section
< Boot_Quit:
< 	sts	UCSR0B,Zero		; Disable the USART
< 	sts	PRR,Zero		; [-,-,-,PRLCD,PRTIM1,PRSPI,PRUSART0,PRADC]
< 	out	SMCR,Zero		; [-,-,-,-,SM2,SM1,SM0,SE]
< 	cli
< 	ldi	tmp1,1<<IVCE	; Move the Interrupt Vectors at 0x0000
< 	out	MCUCR,tmp1		; [JTD,-,-,PUD,-,-,IVSEL,IVCE]
< 	out	MCUCR,Zero
< 	jmp	THIRDBOOTSTART	; Go to the Application section
< 		
< 	; Enter the Bootloader?
< Boot_Check_2:
<  	out	SMCR,SlpIdl		; Enable the Idle sleep mode
< 	sbi	GPIOR0,wRx		; Preset the RxC wait flag
< 	
< 	; Test the inputs
< Boot_Enter1:
< 	sbic  PINB,4		; PB4: Joystick Button 'ENTER'
< 	rjmp  Boot_Sleep	; NO, fall asleep. Else:
< 	sbis  GPIOR0,wRx	; Received anything?
< 	rjmp  Boot_Enter2	; YES, get the USART input. Else:
< 	sleep				; Wait for a wake event...
< 	rjmp  Boot_Enter1	; What was it?
< 		
< 	; Something has been received
<  Boot_Enter2:
<  	mov	 tmp1,UDRrx		; Get the USART input
< 	sbi	 GPIOR0,wRx		; Preset the RxC-wait flag
< 	cpi	 tmp1,0x1B		; Has an <ESC> character been received?
< 	breq Boot_Prepare	;  YES, Enter the bootloader. ELSE:
< 		
< 	; It is not an <ESC> char. Reply "Error"
< 	ldi	tmp1,0x3F		; Reply: "?"
< 	rcall COM_Tx
< 	sleep				; Wait for something to happen
< 	rjmp  Boot_Enter1	; Check again.
< 		
< 	; Enter the Power-save sleep mode
<  Boot_Sleep:
<  	out	  SMCR,SlpPsv	; Enable the Power-save sleep mode
< 	sleep				; Wait for a wake event...
< 	rjmp  Boot_Check_1	; What was it?
< 		
< 		
< 	; Enter the BootLoader
<  Boot_Prepare:
<  	out	EIMSK,Zero		; Disable the Pin Change and External Interrupts		
< 		
< 		
< ;===============================================================================
< Wait_CMD:		; BootLoader: Wait for a command
< ;===============================================================================
< 	rcall COM_Rx		; Get the USART input to <tmp1>
< 
< ;-------------------------------------------------------------------------------
< CMD_01:			; <ESC> for synchronization with the Programmer
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,0x1B	; <ESC> for synchronization
< 		 breq	Wait_CMD	; back for command
< 		
< 		
< ;-------------------------------------------------------------------------------
< CMD_02:			; Set the Address
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'A'	; Set address
< 		 brne	CMD_03
< 		; Get the Address, in Words
< 		rcall	COM_Rx		; Get the Address MSB,
< 		 mov	AddrH,tmp1
< 		 rcall	COM_Rx		;  and the LSB.
< 		 mov	AddrL,tmp1
< 		; Finished
< 		rjmp	Reply_ACK	; Acknowledge (Tx <CR>)
< 		
< ;-------------------------------------------------------------------------------
< CMD_03:			; Chip erase
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'e'	; Chip erase
< 		 brne	CMD_04
< 		; Address = 0
< 		ldi	ZL,Byte1(0x0000) ; Point Z to the first FLASH byte
< 		 ldi	ZH,Byte2(0x0000)
< 		; Loop: Erase ONE FLASH Page
<  PageErase0:	rcall	SPMEN_PgEr	; Page Erase
< 		add	ZL,RAMbsL	; Addr += Block_Size
< 		 adc	ZH,RAMbsH
< 		;  Loop control: DO NOT erase the BootLoader...
< 		cp	ZL,FLStpL	; cp Addr,BOOT_Start (in Bytes)
< 		 cpc	ZH,FLStpH
< 		 brlo	PageErase0	; brlo Erase_One_More_Page
< 		; Finished
< 		rcall	SPMEN_ReEn	; Re-enable the RRW section
< 		 rjmp	Reply_ACK	; Acknowledge (Tx <CR>)
< 		
< ;-------------------------------------------------------------------------------
< CMD_04:			; Start Block Load
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'B'	; Start block load?
< 		 brne	CMD_05
< 		rcall	Get_Block_Param	; Get the Block size and type
< 		; FLASH Block Load
< 		cpi	tmp1,'F'	; FLASH Block Load?
< 		 brne	PC+2
< 		 rjmp	BlockLoad_FL
< 		; EEPROM Block Load
< 		cpi	tmp1,'E'	; EEPROM Block Load?
< 		 brne	PC+2
< 		 rjmp	BlockLoad_EE
< 		; ERROR
< 		rjmp	Reply_ERR	; ERROR: Neither of the above
< 		
< ;-------------------------------------------------------------------------------
< CMD_05:			; Start Block Read
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'g'	; Start Block Read?
< 		 brne	CMD_06
< 		rcall	Get_Block_Param	; Get the Block size and type
< 		; FLASH Block Read
< 		cpi	tmp1,'F'	; FLASH Block Read?
< 		 brne	PC+2
< 		 rjmp	BlockRead_FL
< 		; EEPROM Block Read
< 		cpi	tmp1,'E'	; EEPROM Block Read?
< 		 brne	PC+2
< 		 rjmp	BlockRead_EE
< 		; ERROR
< 		rjmp	Reply_ERR	; ERROR: Neither of the above
< 		
< ;-------------------------------------------------------------------------------
< CMD_06:			; Read the FLASH
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'R'	; Read program memory
< 		 brne	CMD_07
< 		rcall	SPMEN_Wait	; Wait for the FLASH to be ready
< 		; Get the FLASH Address
< 		movw	ZL,AddrL	; Z = Addr
< 		lsl	ZL		; Convert the Address to Bytes
< 		 rol	ZH
< 		lpm	r0,Z+		; r0 = LSB
< 		 lpm	r1,Z+		; r1 = MSB
< 		adiw	AddrL,1		; Update the FLASH Word-Address
< 		; Finished: Send the FLASH Word
< 		mov	tmp1,r1		; Send the MSB first
< 		 rcall	COM_Tx
< 		 mov	tmp1,r0		; Send the LSB
< 		 rjmp	Reply_tmp1	; Reply, and wait for new command
< 		
< ;-------------------------------------------------------------------------------
< CMD_07:			; Load the FLASH LSB
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'c'	; Load program memory, low byte
< 		 brne	CMD_08
< 		; Get the LSB
< 		rcall	COM_Rx		; Get the USART input to <tmp1>
< 		 mov	r0,tmp1		; Copy LSB to r0
< 		; Finished
< 		rjmp	Reply_ACK	; Acknowledge (Tx <CR>)
< 		
< ;-------------------------------------------------------------------------------
< CMD_08:			; Load the FLASH MSB
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'C'	; Load program memory, high byte
< 		 brne	CMD_09
< 		; Get the MSB
< 		rcall	COM_Rx		; Get the USART input to <tmp1>
< 		 mov	r1,tmp1		; Copy MSB to r1
< 		; Prepare the page-buffer Address
< 		movw	ZL,AddrL	; Z = Addr in Words
< 		lsl	ZL		; Convert Address to Bytes
< 		 rol	ZH
< 		 rcall	SPMEN_Fill	; Fill the internal SPM buffer: Load r1:r0
< 		; Update FLASH_Addr & exit
< 		adiw	AddrL,1		; inc Addr
< 		rjmp	Reply_ACK	; Acknowledge (Tx <CR>)
< 		
< ;-------------------------------------------------------------------------------
< CMD_09:			; Write the FLASH page
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'m'	; Write page
< 		 brne	CMD_10
< 		; Load Z the Address
< 		movw	ZL,AddrL	; Z = Addr in Words
< 		lsl	ZL		; Convert the Address to Bytes
< 		 rol	ZH
< 		; Write the page and return
< 		rcall	SPMEN_PgWr	; Page Write
< 		 rcall	SPMEN_ReEn	; Re-enable the RRW section
< 		 rjmp	Reply_ACK	; Acknowledge (Tx <CR>)
< 		
< ;-------------------------------------------------------------------------------
< CMD_10:			; Write the EEPROM memory
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'D'	; Write EEPROM memory
< 		 brne	CMD_11
< 		rcall	SPMEN_Wait	; Wait for the FLASH to be ready
< 		; Write to EEPROM and return
< 		rcall	COM_Rx		; Get the EEPROM Data byte
< 		 rcall	EEPROM_Write	; Write EEPROM the <tmp1> Data byte
< 		 rjmp	Reply_ACK	; Acknowledge (Tx <CR>)
< 		
< ;-------------------------------------------------------------------------------
< CMD_11:			; Read the EEPROM memory
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'d'	; Read EEPROM memory
< 		 brne	CMD_12
< 		rcall	EEPROM_Read	; Read the EEPROM Data byte to <tmp1>
< 		 rjmp	Reply_tmp1	; Reply, and wait for new command
< 		
< ;-------------------------------------------------------------------------------
< CMD_12:			; Read the Low Fuse Bits
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'F'	; Read Fuse Bits
< 		 brne	CMD_13
< 		ldi	ZL,Byte1(0x0000) ; Set the Z pointer
< 		 ldi	ZH,Byte2(0x0000)
< 		 rjmp	Read_Fs_Lc	; Go to the Read_Fuse_Lock common section
< 		
< ;-------------------------------------------------------------------------------
< CMD_13:			; Read the High Fuse Bits
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'N'	; Read High Fuse Bits
< 		 brne	CMD_14
< 		ldi	ZL,Byte1(0x0003) ; Set the Z pointer
< 		 ldi	ZH,Byte2(0x0003)
< 		 rjmp	Read_Fs_Lc	; Go to the Read_Fuse_Lock common section
< 		
< ;-------------------------------------------------------------------------------
< CMD_14:			; Read the Extended Fuse Bits
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'Q'	; Read Extended Fuse Bits
< 		 brne	CMD_15
< 		ldi	ZL,Byte1(0x0002) ; Set the Z pointer
< 		 ldi	ZH,Byte2(0x0002)
< 		 rjmp	Read_Fs_Lc	; Go to the Read_Fuse_Lock common section
< 		
< ;-------------------------------------------------------------------------------
< CMD_15:			; Read the Lock Bits
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'r'	; Read Lock Bits
< 		 brne	CMD_16
< 		ldi	ZL,Byte1(0x0001) ; Set the Z pointer
< 		 ldi	ZH,Byte2(0x0001)
< 		; Read_Fuse_Lock common section
<  Read_Fs_Lc:	ldi	SPM_act,1<<SPMIE|1<<BLBSET|1<<SPMEN
< 		 rcall	SPMEN_Wait	; Wait for the FLASH to be ready
< 		cli			; SPMEN timed sequence
< 		 out	SPMCSR,SPM_act	; [SPMIE,RWWSB,,RWWSRE,BLBSET,PGWRT,PGERS,SPMEN]
< 		 lpm	tmp1,Z		; Read the Lock/Fuse data
< 		 sei
< 		rjmp	Reply_tmp1	; Reply, and wait for new command
< 		
< ;-------------------------------------------------------------------------------
< CMD_16:			; Write the Boot Block Lock Bits
< ;-------------------------------------------------------------------------------
< ;		cpi	tmp1,'l'	; Write Lock Bits
< ;		 brne	CMD_17
< ;		; Get the data
< ;		rcall	COM_Rx		; Get the Lock Bits
< ;		 mov	r0,tmp1		; [1,1,BLB12,BLB11,BLB02,BLB01,1,1]
< ;		ldi	ZL,Byte1(0x0001) ; Set the Z pointer
< ;		 ldi	ZH,Byte2(0x0001)
< ;		rcall	SPMEN_WrBL	; Write the Boot Lock Bits (in r0)
< ;		; Finished
< ;		rjmp	Reply_ACK	; Acknowledge (Tx <CR>)
< 		
< ;-------------------------------------------------------------------------------
< CMD_17:			; Quit the BootLoader
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'E'	; Exit BootLoader
< 		 brne	CMD_18
< 		; Set the Watchdog to reset the chip asap
< 		ldi	tmp1,1<<WDE	; Set the Watchdog for 16K cycles (16.3ms)
< 		 sts	WDTCR,tmp1	; [,,,WDTOE,WDE,WDP2,WDP1,WDP0]
< 		 rjmp	Reply_ACK	; Acknowledge (Tx <CR>)
< 		
< ;-------------------------------------------------------------------------------
< CMD_18:			; Check autoincrement status
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'a'	; Support autoincrement?
< 		 brne	CMD_19
< 		; Reply <"Y">
< 		ldi	tmp1,'Y'	; Reply "Y" (YES)
< 		 rjmp	Reply_tmp1	; Reply, and wait for a command
< 		
< ;-------------------------------------------------------------------------------
< CMD_19:			; Check Block-Load support
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'b'	; Support Block-Load?
< 		 brne	CMD_20
< 		; Reply <"Y":MSB:LSB>
< 		ldi	tmp1,'Y'	; Reply "Y" (YES)
< 		 rcall	COM_Tx
< 		ldi	tmp1,Byte2(Block_Size) ; Report the Block Size in Bytes
< 		 rcall	COM_Tx
< 		 ldi	tmp1,Byte1(Block_Size)
< 		 rjmp	Reply_tmp1	; Reply, and wait for a command
< 		
< ;-------------------------------------------------------------------------------
< CMD_20:			; Get the Programmer type
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'p'	; Get the Programmer type
< 		 brne	CMD_21
< 		; Reply <"S">
< 		ldi	tmp1,'S'	; Reply "S" (Serial)
< 		 rjmp	Reply_tmp1	; Reply, and wait for a command
< 		
< ;-------------------------------------------------------------------------------
< CMD_21:			; Return the signature bytes
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'s'	; Return signature bytes
< 		 brne	CMD_22
< 		; Reply <sL:sM:sH>
< 		ldi	tmp1,Byte1(PartSign) ; Reply <LSB:NSB:MSB>
< 		 rcall	COM_Tx
< 		 ldi	tmp1,Byte2(PartSign)
< 		 rcall	COM_Tx
< 		 ldi	tmp1,Byte3(PartSign)
< 		 rjmp	Reply_tmp1	; Reply, and wait for a command
< 		
< ;-------------------------------------------------------------------------------
< CMD_22:			; Return the supported device codes
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'t'	; Return the supported device codes
< 		 brne	CMD_23
< 		; Reply <PartCode,0x00>
< 		ldi	tmp1,PartCode	; m169_BOOT <PartCode>
< 		 rcall	COM_Tx
< 		ldi	tmp1,0x00	; "End of supported devices"
< 		 rjmp	Reply_tmp1	; Reply, and wait for a command
< 		
< ;-------------------------------------------------------------------------------
< CMD_23:			; Return the firmware version
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'V'	; Return software version
< 		 brne	CMD_24
< 		; Reply <"vH":"vL">
< 		ldi	tmp1,BootLoaderRevH ; Send the MSB first
< 		 rcall	COM_Tx
< 		 ldi	tmp1,BootLoaderRevL ; Send the LSB
< 		 rjmp	Reply_tmp1	; Reply, and wait for a command
< 		
< ;-------------------------------------------------------------------------------
< CMD_24:			; Return the programmer identifier
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'S'	; Return programmer identifier
< 		 brne	CMD_25
< 		; Reply <"AVRBOOT">
< 		ldi	ZL,Byte1(2*PGM_ID)
< 		 ldi	ZH,Byte2(2*PGM_ID)
< 		;  LPM/REPLY loop
<  PGM_ID_Loop:	lpm	tmp1,Z+
< 		 cpi	tmp1,0		; Finished?
< 		 breq	Reply_ret	;  YES, return. Else:
< 		rcall	COM_Tx		; Continue sending data.
< 		 rjmp	PGM_ID_Loop
<  PGM_ID:	.db	"AVRBOOT",0	; Data string
< 		
< ;-------------------------------------------------------------------------------
< CMD_25:			; Ignored commands
< ;-------------------------------------------------------------------------------
< 		cpi	tmp1,'P'	; Enter programming mode
< 		 breq	Ignore1
< 		cpi	tmp1,'L'	; Leave programming mode
< 		 breq	Ignore1
< 		cpi	tmp1,'x'	; Set LED
< 		 breq	Ignore0
< 		cpi	tmp1,'y'	; Clear LED
< 		 breq	Ignore0
< 		cpi	tmp1,'l'	; Write Lock Bits
< 		 breq	Ignore0
< 		cpi	tmp1,'T'	; Set the Device type
< 		 brne	Reply_ERR	; End of the recognied commands.
< 		; Finished
<  Ignore0:	rcall	COM_Rx		; Get the parameter & ignore the command
<  Ignore1:	;rjmp	Reply_ACK	; Acknowledge (== <CR>)
< 		
< ;-------------------------------------------------------------------------------
< Reply_ACK:		; Acknowledge (== <CR>)
< ;-------------------------------------------------------------------------------
< 		ldi	tmp1,0x0D	; Acknowledge (Tx: <CR>)
< 		 rjmp	Reply_tmp1	; Reply, and wait for a command
< ;-------------------------------------------------------------------------------
< Reply_ERR:		; ERROR (== "?")
< ;-------------------------------------------------------------------------------
< 		ldi	tmp1,0x3F	; ERROR (Tx: "?")
< ;-------------------------------------------------------------------------------
< Reply_tmp1:		; Reply <tmp1>, and wait for new command
< ;-------------------------------------------------------------------------------
< 		rcall	COM_Tx		; Send <tmp1>, and
< Reply_ret:	 rjmp	Wait_CMD	;  back for CMD...
< 		
< 		
< ;-------------------------------------------------------------------------------
< BlockRead_FL:		; FLASH Block Read
< ;-------------------------------------------------------------------------------
< 		movw	ZL,AddrL	; Load Z the FLASH Address in Words
< 		lsl	ZL		; Convert the Address to Bytes
< 		 rol	ZH
< 		movw	XL,PGMbsL	; PGMbs bytes to transfer
< 		; Loop: Read the LSB and the MSB; Send the MSB and the LSB
<  BlRdFL1:	lpm	tmp1,Z+		; Read the FLASH-Word LSB
< 		 rcall	COM_Tx		;  and sent it
< 		 lpm	tmp1,Z+		; Read the FLASH-Word MSB
< 		 rcall	COM_Tx		;  and sent it
< 		sbiw	XL,2		; Loop control
< 		 brne	BlRdFL1		;  Not finished yet. ELSE:
< 		; Finished. Update the Address and return
< 		lsr	ZH		; Convert FLASH Address back to Words
< 		 ror	ZL
< 		 movw	AddrL,ZL	; Update the AddrH:AddrL
< 		rjmp	Wait_CMD	;  and back for commands
< 		
< ;-------------------------------------------------------------------------------
< BlockLoad_FL:		; FLASH Block Load
< ;-------------------------------------------------------------------------------
< 		movw	ZL,AddrL	; Load Z the FLASH Address in Words
< 		lsl	ZL		; Convert the Address to Bytes
< 		 rol	ZH
< 		movw	XL,PGMbsL	; PGMbs bytes to transfer
< 		; Loop: Get the LSB and the MSB; Fill the SPM buffer
<  BlLdFL1:	rcall	COM_Rx		; Get the LSB, 
< 		 mov	r0,tmp1
< 		 rcall	COM_Rx		;  and the MSB
< 		 mov	r1,tmp1
< 		rcall	SPMEN_Fill	; Fill the internal SPM buffer
< 		 adiw	ZL,2		; Next FLASH Word Address
< 		sbiw	XL,2		; Loop control
< 		 brne	BlLdFL1		;  Not finished yet. ELSE:
< 		; The internal SPM buffer is filled. Issue a Page Write
< 		sub	ZL,PGMbsL	; Restore the Z pointer for Page writting
< 		 sbc	ZH,PGMbsH
< 		rcall	SPMEN_PgWr	; Page Write
< 		 rcall	SPMEN_ReEn	; Re-enable the RRW section
< 		; Finished. Update the Address and return
< 		lsr	PGMbsH		; Convert the offset to Words
< 		 ror	PGMbsL
< 		 add	AddrL,PGMbsL	; Update the FLASH Address
< 		 adc	AddrH,PGMbsH
< 		rjmp	Reply_ACK	; Acknowledge (Tx <CR>)
< 		
< ;-------------------------------------------------------------------------------
< BlockRead_EE:		; EEPROM Block Read
< ;-------------------------------------------------------------------------------
< 		movw	XL,PGMbsL	; PGMbs bytes to transfer
< 		; Loop: Read an EEPROM data byte & send it through USART
<  BlRdEE1:	rcall	EEPROM_Read	; Read the EEPROM Data byte to <tmp1>
< 		 rcall	COM_Tx		; Send the data
< 		sbiw	XL,1		; Loop control
< 		 brne	BlRdEE1		;  Not finished yet. ELSE:
< 		rjmp	Wait_CMD	; Back, for a new command
< 		
< ;-------------------------------------------------------------------------------
< BlockLoad_EE:		; EEPROM Block Load
< ;-------------------------------------------------------------------------------
< 		ldi	YL,Byte1(RAM_Block) ; Point Y at the RAM-Block beginning
< 		 ldi	YH,Byte2(RAM_Block)
< 		movw	XL,PGMbsL	; PGMbs bytes to transfer
< 		; Rx_Loop: Receive & save to RAM an EEPROM Block
<  BlLdEE1:	rcall	COM_Rx		; Get an EEPROM data byte
< 		 st	Y+,tmp1		;  and save it to RAM-Block
< 		sbiw	XL,1		; Finished?
< 		 brne	BlLdEE1		;  Not yet
< 		; RAM-Block is filled; Prepare to write it to EEPROM
< 		ldi	YL,Byte1(RAM_Block) ; Point Y at the RAM-Block beginning
< 		 ldi	YH,Byte2(RAM_Block)
< 		movw	XL,PGMbsL	; PGMbs bytes to transfer
< 		rcall	SPMEN_Wait	; Wait for the FLASH to be ready
< 		; Write Loop: Read a Byte from RAM & write it to EEPROM
<  BlLdEE2:	ld	tmp1,Y+		; Read an EEPROM data Byte from the RAM-Block
< 		 rcall	EEPROM_Write	; Write EEPROM the <tmp1> Data byte
< 		sbiw	XL,1		; Loop control
< 		 brne	BlLdEE2		;  Non finished yet. ELSE:
< 		rjmp	Reply_ACK	; Acknowledge (Tx <CR>)
< 		
< 		
< 		
< 		
< 		
< ;===============================================================================
< ; 				Subroutine Section
< ;===============================================================================
< ;		rcall	COM_Rx		; Get the USART input to <tmp1>
< ;		rcall	COM_Tx		; Sent <tmp1> to the USART line
< ;		rcall	
< ;		rcall	EEPROM_Read	; Read the EEPROM Data byte to <tmp1>
< ;		rcall	EEPROM_Write	; Write EEPROM the <tmp1> Data byte
< ;		rcall	
< ;		rcall	Get_Block_Param	; Get the Block size and type
< ;		rcall	
< ;		rcall	OSC_Calibration	; RC oscillator auto calibration
< ;		rcall	
< ;		rcall	SPMEN_Wait	; Wait for the FLASH to be ready
< ;		rcall	SPMEN_PgEr	; Page Erase
< ;		rcall	SPMEN_PgWr	; Page Write
< ;		rcall	SPMEN_ReEn	; Re-enable the RRW section
< ;;		rcall	SPMEN_WrBL	; Write the Boot Lock Bits
< ;		rcall	SPMEN_Fill	; Fill the internal SPM buffer
< ;		rcall	_Do_SPM		; Do the SPM timed sequence
< ;-------------------------------------------------------------------------------
< COM_Rx:			; Get the USART input to <tmp1>
< ;-------------------------------------------------------------------------------
< 		sbis	GPIOR0,wRx	; Received anything?
< 		 rjmp	COM_Rx_Get	;  YES, get the USART input. Else:
< 		sleep			; Wait for a wake event...
< 		 rjmp	COM_Rx		; Check the USART receiver
< 		; Get the USART input
<  COM_Rx_Get:	mov	tmp1,UDRrx
< 		 sbi	GPIOR0,wRx	; Preset the RxC-wait flag
< 		ret
< 		
< ;-------------------------------------------------------------------------------
< COM_Tx:			; Sent <tmp1> to the USART line
< ;-------------------------------------------------------------------------------
< 		sts	UDR0,tmp1	; Start the USART transmission
< 		 sbi	GPIOR0,wTx	; Preset the TxC-wait flag
< 		; Wait for the transmission to finish
<  COM_Tx_Slp:	;sleep			; Wait for an interrupt
< 		 sbic	GPIOR0,wTx	; Ready?
< 		 rjmp	COM_Tx_Slp	;  Not yet. Else:
< 		ret
< 		
< 		
< ;-------------------------------------------------------------------------------
< EEPROM_Read:		; Read the EEPROM Data byte to <tmp1>
< ;-------------------------------------------------------------------------------
< 		out	EEARH,AddrH	; Load the Address to EEPROM
< 		 out	EEARL,AddrL
< 		sbi	EECR,EERE	; [,,,,EERIE,EEMWE,EEWE,EERE]
< 		 in	tmp1,EEDR	; Read a data Byte from EEPROM
< 		; Update the EEPROM Address & exit
< 		adiw	AddrL,1		; Next EEPROM Address
< 		ret
< 		
< ;-------------------------------------------------------------------------------
< EEPROM_Write:		; Write EEPROM the <tmp1> Data byte
< ;-------------------------------------------------------------------------------
< 		out	EEARH,AddrH	; Load EEPROM the Address
< 		 out	EEARL,AddrL
< 		 out	EEDR,tmp1	; Load EEPROM the Data byte
< 		; Write the EEPROM byte
< 		cli
< 		sbi	EECR,EEMWE	; Enable EEPROM writting; Write the data.
< 		 sbi	EECR,EEWE	; [,,,,EERIE,EEMWE,EEWE,EERE]
< 		 sei
< 		sbi	EECR,EERIE	; Enable the EERPOM-ready interrupt
< 		 sbi	GPIOR0,wEr	; Preset the EEPROM Ready wait flag
< 		; Wait for the EEPROM to be ready
< 		sleep			; Wait for the EEPROM
< 		 sbic	GPIOR0,wEr	; Ready?
< 		 rjmp	PC-2		;  Not yet. Else:
< 		cbi	EECR,EERIE	; Disable the EERPOM-ready interrupt
< 		; Update the EEPROM Address & exit
< 		adiw	AddrL,1		; Next EEPROM Address
< 		ret
< 		
< 		
< ;-------------------------------------------------------------------------------
< Get_Block_Param:	; Get the Block size and type
< ;-------------------------------------------------------------------------------
< 		rcall	COM_Rx		; Get the Block_Size MSB
< 		 mov	PGMbsH,tmp1
< 		 rcall	COM_Rx		; Get the Block_Size LSB
< 		 mov	PGMbsL,tmp1
< 		rcall	COM_Rx		; Get the Mem_Type: "F" or "E"
< 		ret
< 		
< 		
< ;-------------------------------------------------------------------------------
< OSC_Calibration:	; Internal Oscillator auto calibration
< ;-------------------------------------------------------------------------------
< #if 0
< .equ	UBRR_Value =	12	; For: [19200bps, 2 MHz, Double Speed, Error +0.2%]
< .equ	Baud_Rate  =	19200	; [bps] 19200
< .equ	Base_Clk   =	32768	; [Hz] Base_Clk: 32KHz watch crystal
< .equ	CPU_Clk    = 	Baud_Rate*8*(UBRR_Value+1)	; [Hz] CPU_Clk, for: [19200bps, Double Speed]
< .equ 	SecDelay   =	31;
< #endif
< #if 1
< .equ	UBRR_Value =	25	; For: [19200bps, 8 MHz, Single Speed, Error +0.2%]
< .equ	Baud_Rate  =	19200	; [bps] 19200
< .equ	Base_Clk   =	32768	; [Hz] Base_Clk: 32KHz watch crystal
< .equ	CPU_Clk    = 	Baud_Rate*16*(UBRR_Value+1)	; [Hz] CPU_Clk, for: [19200bps, Single Speed]
< .equ	SecDelay   =	123;
< #endif
< .equ	Accuracy   =	8	; [Per Thousand] Desired CPU_Clk accuracy
< .equ	Cycles     =	256	; TC2 counting cycles
< .equ	Best_Fit   = 	Cycles * CPU_Clk/Base_Clk	; [TCNT1] Ideal CPU cycles to be counted
< .equ	Limmit     = 	Best_Fit * Accuracy/1000	; [TCNT1] Max allowed CPU cycles deviation
< .equ	Upper_Limmit =	Best_Fit + Limmit	; TCNT1 Upper Limmit
< .equ	Lower_Limmit =	Best_Fit - Limmit	; TCNT1 Lower Limmit
< 		
< #if 0
< ; Set the CPU Frequency to 2MHz
< 	ldi	tmp1,1<<CLKPCE	; Set CPU_CLK to 2MHz (= CLK/4)
< 	sts	CLKPR,tmp1
< 	ldi	tmp1,1<<CLKPS1	; Set the Clock Prescaler to 4 (CLKPS3:0 = 0b0010)
< 	sts	CLKPR,tmp1	; [CLKPCE,-,-,-,CLKPS3,CLKPS2,CLKPS1,CLKPS0]
< #endif		
< 	; Setup the module
< 	ldi	tmp1,1<<AS2	; Set the 32KHz osc as the TC2 clock source
< 	sts	ASSR,tmp1	; ASSR = [-,-,-,EXCLK,AS2,TCN2UB,OCR2UB,TCR2UB]
< 	sts	TIMSK1,Zero	; [,,ICIE1,,,OCIE1B,OCIE1A,TOIE1]
< 	sts	TIMSK2,Zero	; [,,,,,,OCIE2A,TOIE2]
< 	ldi	tmp1,1		; Start TC1 at 1MHz (1us)
< 	sts	TCCR1B,tmp1	; [ICNC1,ICES1,,WGM13,WGM12,CS12,CS11,CS10]
< 	;ldi	tmp1,1		; Start TC2 at 32768Hz (30.51757813us) 
< 	sts	TCCR2A,tmp1	; [FOC2A,WGM20,COM2A1,COM2A0,WGM21,CS22,CS21,CS20]
< 		
< 	; Set TC2 to Asynchronous mode
< 	lds	 tmp1,ASSR		; ASSR = [-,-,-,EXCLK,AS2,TCN2UB,OCR2UB,TCR2UB]
< 	andi tmp1,1<<TCR2UB	; Ready?
< 	brne PC-3			;  Not yet. Else:
< 	
< 	; Wait 1 sec for the 32KHz oscillator stabilization
< 	ldi	tmp1,SecDelay	; Load <1016ms (= 31 * 32.77ms) delay
<  
<  OSC_Wait:
<  	sbi  TIFR1,TOV1		; Clear the TOV1 flag
< 						; 32.77ms (= 2^16 / 2MHz) ?
< 	sbis TIFR1,TOV1		; 8.192ms (= 2^16 / 8MHz) ?
< 	rjmp PC-1			;  Not yet. Else:
< 		 				; 1016ms (= 31 * 32.77ms) ?
< 	dec	 tmp1			; 1008ms (= 123 * 8.192ms) ?
< 	brne OSC_Wait		;  Not yet. Else:
< 
< 	sts	 TCNT2,Zero		; Reset TCNT2 only; TC1 has just overflowed
< 	lds	 r0,OSCCAL		; r0 == OSCCAL
< 		
< 	; Test the internal oscillator speed
<  OSC_Test:
<  	sts	OSCCAL,r0		; Update the OSCCAL
< 	ser	tmp1			; Reset any TC1 and TC2 flags
< 	out	TIFR1,tmp1		; [,-,ICF1,,,OCF1B,OCF1A,TOV1]
< 	out	TIFR2,tmp1		; [-,-,-,-,-,-,OCF2A,TOV2]
< 	
< 	; Wait for the TC2 compare-match
< 	sbis TIFR2,TOV2		; 256 *	1/32768	= 7812.5us
< 	rjmp PC-1
< 		
< 	lds  XL,TCNT1L		; X = TCNT1
< 	lds  XH,TCNT1H
< 	sts  TCNT1H,Zero	; Reset TCNT1 only; TC2 has just overflowed
< 	sts  TCNT1L,Zero
< 
< 	;  Is the oscillator too fast?
< 	sbic TIFR1,TOV1		; TC1 overflowed?
< 	rjmp OSC_Too_Fast
< 
< 	;  Is the oscillator fast?
< 	cpi  XL,Byte1(Upper_Limmit) 	; cpi TCNT1,Upper_Limmit
< 	ldi  tmp1,Byte2(Upper_Limmit)
< 	cpc  XH,tmp1
< 	brsh OSC_Too_Fast
< 		
< 	;  Is the oscillator slow?
< 	cpi  XL,Byte1(Lower_Limmit) 	; cpi TCNT1,Lower_Limmit
< 	ldi  tmp1,Byte2(Lower_Limmit)
< 	cpc  XH,tmp1
< 	brlo OSC_Too_Slow
< 
< 	; The oscillator frequency is within the acceptable limmits
<  OSC_Done:
<  	sts	 TCCR1B,Zero	; [ICNC1,ICES1,,WGM13,WGM12,CS12,CS11,CS10]
< 	sts	 TCCR2A,Zero	; [FOC2A,WGM20,COM2A1,COM2A0,WGM21,CS22,CS21,CS20]
< 	ret
< 		
< 	; Decrease the oscillator frequency
<  OSC_Too_Fast:
<  	dec  r0				; OSCCAL-- ;
< 	rjmp OSC_Test
< 	
< 	; Increase the oscillator frequency
<  OSC_Too_Slow:
<  	inc	 r0				; OSCCAL++ ;
< 	rjmp OSC_Test
< 		
< 		
< ;-------------------------------------------------------------------------------
< SPMEN_Wait:		; Wait for the FLASH to be ready
< ;-------------------------------------------------------------------------------
< 		in	tmp1,SPMCSR	; Ready?
< 		 sbrs	tmp1,SPMEN	;  NO, wait...
< 		 ret			;  YES, return.
< 		sleep			; Wait for a wake event...
< 		 rjmp	SPMEN_Wait	; Check the SPMEN again
< 		
< ;-------------------------------------------------------------------------------
< SPMEN_PgEr:		; Page Erase
< ;-------------------------------------------------------------------------------
< 		ldi	SPM_act,1<<SPMIE|1<<PGERS|1<<SPMEN
< 		 rjmp	_Do_SPM
< 		
< ;-------------------------------------------------------------------------------
< SPMEN_PgWr:		; Page Write
< ;-------------------------------------------------------------------------------
< 		ldi	SPM_act,1<<SPMIE|1<<PGWRT|1<<SPMEN
< 		 rjmp	_Do_SPM
< 		
< ;-------------------------------------------------------------------------------
< SPMEN_ReEn:		; Re-enable the RRW section
< ;-------------------------------------------------------------------------------
< 		ldi	SPM_act,1<<SPMIE|1<<RWWSRE|1<<SPMEN
< 		 rjmp	_Do_SPM
< 		
< ;-------------------------------------------------------------------------------
< ;SPMEN_WrBL:		; Write the Boot Lock Bits
< ;-------------------------------------------------------------------------------
< ;		ldi	SPM_act,1<<SPMIE|1<<BLBSET|1<<SPMEN
< ;		 rjmp	_Do_SPM
< 		
< ;-------------------------------------------------------------------------------
< SPMEN_Fill:		; Fill the internal SPM buffer
< ;-------------------------------------------------------------------------------
< 		ldi	SPM_act,1<<SPMIE|1<<SPMEN
< ;		 rjmp	_Do_SPM
< 		
< ;-------------------------------------------------------------------------------
< _Do_SPM:		; Do the SPM timed sequence
< ;-------------------------------------------------------------------------------
< 		rcall	SPMEN_Wait	; Wait for the FLASH to be ready
< 		cli
< 		 out	SPMCSR,SPM_act	; [SPMIE,RWWSB,,RWWSRE,BLBSET,PGWRT,PGERS,SPMEN]
< 		 spm
< 		reti
< 		
< 		
< .org THIRDBOOTSTART
< 
< 	; the butterfly gives us some additional hardware, Like the LCD 
< 	; so setup the LCD to take the place of the LEDs
< 
< LCD_INIT:
<     ldi r16,(1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0)
<     sts LCDCRB, r16     ;Enable all Segments
<     ldi r16,(0<<LCDPS0) | (7<<LCDCD0)
<     sts LCDFRR, r16     ;SET Prescaler to 32KHz
<     ldi r16,(1<<LCDCC3) | (1<<LCDCC2) | (1<<LCDCC1)
<     sts LCDCCR, r16     ;Set the contrast
<     ldi r16,(1<<LCDEN)  | (1<<LCDAB)
<     sts LCDCRA,r16		;Enable the LCD
< 
< 	; set the "indicators" on the display to mimic the LEDs
< 
< .equ LCD_AN1	= 2	; register 3
< .equ LCD_AN2	= 5	; register 0
< .equ LCD_AN3	= 1 ; register 0
< 
< .equ LCD_IND1	= 2	; register 0
< .equ LCD_IND2	= 6	; register 0
< .equ LCD_IND3	= 0 ; register 1
< 
< 	ldi r16,0x11 ;| 1<<LCD_IND2 | 1<<LCD_AN2 | 1<<LCD_IND1 | 1 << LCD_AN3 	
< 	sts LCDDR0,r16
< 	ldi r16,0x11 | 0<<LCD_AN1
< 	sts LCDDR1,r16
< ;	ldi r16,1<<LCD_IND3
< ;	sts LCDDR3,r16
< 
< 	; we will flash the indicators instead of the LEDs
< 	; AN1 is the JTAG Com
< 	; AN2 is the serial I/O stream
< 	; AN3 is the Vtarget
< 
< 	; the following writes ICEBUT as the app name onto the LCD
< 
< ; LCD SEGEMENTS:  NYBBLE0   NYBBLE1    ----a----   ;
< ;                 7 6 5 4   3 2 1 0   |\   |   /|  ;
< ;      LCDDRn:    k - - a   k - - a   f h  j  k b  ;
< ;      LCDDRn+5:  j f h b   j f h b   |  \ | /  |  ;
< ;      LCDDRn+10: l e g c   l e g c    -g-- --l--  ;
< ;      LCDDRN+15: m p n d   m p n d   |   /|\   |  ;    
< ;                  CHR-B     CHR-A    e  p n m  c  ;
< ;                                     |/   |  \ |  ;
< ;                                      ----d----   ;
< ;                                                  ;
< ; TWO CHARACTERS ARE STUFFED INTO A BYTE AND THEY  ;
< ; ARE SPREAD ACROSS FOUR REISTERS THAT ARE FIVE    ;
< ; BYTES APART          
< ;             76543210    76543210
< ;	ldi r16,0b00010001	;    a   a
< ;	sts LCDDR0,r16
< 	ldi r16,0b10001000	; j   j   
< 	sts LCDDR5,r16
< 	ldi r16,0b00000000	;      e  
< 	sts LCDDR10,r16
< 	ldi r16,0b00100100	;    n pn 
< 	sts LCDDR15,r16
< 
< ;	ldi r16,0b00010001	;    a   a
< ;	sts LCDDR1,r16
< 	ldi r16,0b01000101	;  f   f b
< 	sts LCDDR6,r16
< 	ldi r16,0b01101111	; leg legc
< 	sts LCDDR11,r16
< 	ldi r16,0b10010000	; m  d
< 	sts LCDDR16,r16
< 
< 	ldi r16,0b00010001	;    a   a
< 	sts LCDDR2,r16
< 	ldi r16,0b01001001	;  f  j  b
< 	sts LCDDR7,r16
< 	ldi r16,0b11101001	; le  l  c
< 	sts LCDDR12,r16
< 	ldi r16,0b00000011	;       nd
< 	sts LCDDR17,r16
< 
< 	; check the state of the Vtarget and set the Annunciator state
< 	; on the display
< 
< 	jmp 0		
< #endif		
< 		
---
> ; begin of const block at 0x16C7(0x2D8E)
> ; Init DATA
> C2D8E:
> 	.db	0x01,0x17,0x01,0xCB,0x0C,0x01,0x00,0x00	; "........"
> 	.db	0x00,0xFF	; ".."
> ; end of const block at 0x16CB(0x2D97)
> ;
> 	.dw	0xFFFF	; pc=0x16CC(0x2D98)
> 	.dw	0xFFFF	; pc=0x16CD(0x2D9A)
> 	.dw	0xFFFF	; pc=0x16CE(0x2D9C)
> 	.dw	0xFFFF	; pc=0x16CF(0x2D9E)
> 	.dw	0xFFFF	; pc=0x16D0(0x2DA0)
> 	.dw	0xFFFF	; pc=0x16D1(0x2DA2)
> 	.dw	0xFFFF	; pc=0x16D2(0x2DA4)
> 	.dw	0xFFFF	; pc=0x16D3(0x2DA6)
> 	.dw	0xFFFF	; pc=0x16D4(0x2DA8)
> 	.dw	0xFFFF	; pc=0x16D5(0x2DAA)
> 	.dw	0xFFFF	; pc=0x16D6(0x2DAC)
> 	.dw	0xFFFF	; pc=0x16D7(0x2DAE)
> 	.dw	0xFFFF	; pc=0x16D8(0x2DB0)
> 	.dw	0xFFFF	; pc=0x16D9(0x2DB2)
> 	.dw	0xFFFF	; pc=0x16DA(0x2DB4)
> 	.dw	0xFFFF	; pc=0x16DB(0x2DB6)
> 	.dw	0xFFFF	; pc=0x16DC(0x2DB8)
> 	.dw	0xFFFF	; pc=0x16DD(0x2DBA)
> 	.dw	0xFFFF	; pc=0x16DE(0x2DBC)
> 	.dw	0xFFFF	; pc=0x16DF(0x2DBE)
> 	.dw	0xFFFF	; pc=0x16E0(0x2DC0)
> 	.dw	0xFFFF	; pc=0x16E1(0x2DC2)
> 	.dw	0xFFFF	; pc=0x16E2(0x2DC4)
> 	.dw	0xFFFF	; pc=0x16E3(0x2DC6)
> 	.dw	0xFFFF	; pc=0x16E4(0x2DC8)
> 	.dw	0xFFFF	; pc=0x16E5(0x2DCA)
> 	.dw	0xFFFF	; pc=0x16E6(0x2DCC)
> 	.dw	0xFFFF	; pc=0x16E7(0x2DCE)
> 	.dw	0xFFFF	; pc=0x16E8(0x2DD0)
> 	.dw	0xFFFF	; pc=0x16E9(0x2DD2)
> 	.dw	0xFFFF	; pc=0x16EA(0x2DD4)
> 	.dw	0xFFFF	; pc=0x16EB(0x2DD6)
> 	.dw	0xFFFF	; pc=0x16EC(0x2DD8)
> 	.dw	0xFFFF	; pc=0x16ED(0x2DDA)
> 	.dw	0xFFFF	; pc=0x16EE(0x2DDC)
> 	.dw	0xFFFF	; pc=0x16EF(0x2DDE)
> 	.dw	0xFFFF	; pc=0x16F0(0x2DE0)
> 	.dw	0xFFFF	; pc=0x16F1(0x2DE2)
> 	.dw	0xFFFF	; pc=0x16F2(0x2DE4)
> 	.dw	0xFFFF	; pc=0x16F3(0x2DE6)
> 	.dw	0xFFFF	; pc=0x16F4(0x2DE8)
> 	.dw	0xFFFF	; pc=0x16F5(0x2DEA)
> 	.dw	0xFFFF	; pc=0x16F6(0x2DEC)
> 	.dw	0xFFFF	; pc=0x16F7(0x2DEE)
> 	.dw	0xFFFF	; pc=0x16F8(0x2DF0)
> 	.dw	0xFFFF	; pc=0x16F9(0x2DF2)
> 	.dw	0xFFFF	; pc=0x16FA(0x2DF4)
> 	.dw	0xFFFF	; pc=0x16FB(0x2DF6)
> 	.dw	0xFFFF	; pc=0x16FC(0x2DF8)
> 	.dw	0xFFFF	; pc=0x16FD(0x2DFA)
> 	.dw	0xFFFF	; pc=0x16FE(0x2DFC)
> 	.dw	0xFFFF	; pc=0x16FF(0x2DFE)
> 	.dw	0xFFFF	; pc=0x1700(0x2E00)
> 	.dw	0xFFFF	; pc=0x1701(0x2E02)
> 	.dw	0xFFFF	; pc=0x1702(0x2E04)
> 	.dw	0xFFFF	; pc=0x1703(0x2E06)
> 	.dw	0xFFFF	; pc=0x1704(0x2E08)
> 	.dw	0xFFFF	; pc=0x1705(0x2E0A)
> 	.dw	0xFFFF	; pc=0x1706(0x2E0C)
> 	.dw	0xFFFF	; pc=0x1707(0x2E0E)
> 	.dw	0xFFFF	; pc=0x1708(0x2E10)
> 	.dw	0xFFFF	; pc=0x1709(0x2E12)
> 	.dw	0xFFFF	; pc=0x170A(0x2E14)
> 	.dw	0xFFFF	; pc=0x170B(0x2E16)
> 	.dw	0xFFFF	; pc=0x170C(0x2E18)
> 	.dw	0xFFFF	; pc=0x170D(0x2E1A)
> 	.dw	0xFFFF	; pc=0x170E(0x2E1C)
> 	.dw	0xFFFF	; pc=0x170F(0x2E1E)
> 	.dw	0xFFFF	; pc=0x1710(0x2E20)
> 	.dw	0xFFFF	; pc=0x1711(0x2E22)
> 	.dw	0xFFFF	; pc=0x1712(0x2E24)
> 	.dw	0xFFFF	; pc=0x1713(0x2E26)
> 	.dw	0xFFFF	; pc=0x1714(0x2E28)
> 	.dw	0xFFFF	; pc=0x1715(0x2E2A)
> 	.dw	0xFFFF	; pc=0x1716(0x2E2C)
> 	.dw	0xFFFF	; pc=0x1717(0x2E2E)
> 	.dw	0xFFFF	; pc=0x1718(0x2E30)
> 	.dw	0xFFFF	; pc=0x1719(0x2E32)
> 	.dw	0xFFFF	; pc=0x171A(0x2E34)
> 	.dw	0xFFFF	; pc=0x171B(0x2E36)
> 	.dw	0xFFFF	; pc=0x171C(0x2E38)
> 	.dw	0xFFFF	; pc=0x171D(0x2E3A)
> 	.dw	0xFFFF	; pc=0x171E(0x2E3C)
> 	.dw	0xFFFF	; pc=0x171F(0x2E3E)
> 	.dw	0xFFFF	; pc=0x1720(0x2E40)
> 	.dw	0xFFFF	; pc=0x1721(0x2E42)
> 	.dw	0xFFFF	; pc=0x1722(0x2E44)
> 	.dw	0xFFFF	; pc=0x1723(0x2E46)
> 	.dw	0xFFFF	; pc=0x1724(0x2E48)
> 	.dw	0xFFFF	; pc=0x1725(0x2E4A)
> 	.dw	0xFFFF	; pc=0x1726(0x2E4C)
> 	.dw	0xFFFF	; pc=0x1727(0x2E4E)
> 	.dw	0xFFFF	; pc=0x1728(0x2E50)
> 	.dw	0xFFFF	; pc=0x1729(0x2E52)
> 	.dw	0xFFFF	; pc=0x172A(0x2E54)
> 	.dw	0xFFFF	; pc=0x172B(0x2E56)
> 	.dw	0xFFFF	; pc=0x172C(0x2E58)
> 	.dw	0xFFFF	; pc=0x172D(0x2E5A)
> 	.dw	0xFFFF	; pc=0x172E(0x2E5C)
> 	.dw	0xFFFF	; pc=0x172F(0x2E5E)
> 	.dw	0xFFFF	; pc=0x1730(0x2E60)
> 	.dw	0xFFFF	; pc=0x1731(0x2E62)
> 	.dw	0xFFFF	; pc=0x1732(0x2E64)
> 	.dw	0xFFFF	; pc=0x1733(0x2E66)
> 	.dw	0xFFFF	; pc=0x1734(0x2E68)
> 	.dw	0xFFFF	; pc=0x1735(0x2E6A)
> 	.dw	0xFFFF	; pc=0x1736(0x2E6C)
> 	.dw	0xFFFF	; pc=0x1737(0x2E6E)
> 	.dw	0xFFFF	; pc=0x1738(0x2E70)
> 	.dw	0xFFFF	; pc=0x1739(0x2E72)
> 	.dw	0xFFFF	; pc=0x173A(0x2E74)
> 	.dw	0xFFFF	; pc=0x173B(0x2E76)
> 	.dw	0xFFFF	; pc=0x173C(0x2E78)
> 	.dw	0xFFFF	; pc=0x173D(0x2E7A)
> 	.dw	0xFFFF	; pc=0x173E(0x2E7C)
> 	.dw	0xFFFF	; pc=0x173F(0x2E7E)
> 	.dw	0xFFFF	; pc=0x1740(0x2E80)
> 	.dw	0xFFFF	; pc=0x1741(0x2E82)
> 	.dw	0xFFFF	; pc=0x1742(0x2E84)
> 	.dw	0xFFFF	; pc=0x1743(0x2E86)
> 	.dw	0xFFFF	; pc=0x1744(0x2E88)
> 	.dw	0xFFFF	; pc=0x1745(0x2E8A)
> 	.dw	0xFFFF	; pc=0x1746(0x2E8C)
> 	.dw	0xFFFF	; pc=0x1747(0x2E8E)
> 	.dw	0xFFFF	; pc=0x1748(0x2E90)
> 	.dw	0xFFFF	; pc=0x1749(0x2E92)
> 	.dw	0xFFFF	; pc=0x174A(0x2E94)
> 	.dw	0xFFFF	; pc=0x174B(0x2E96)
> 	.dw	0xFFFF	; pc=0x174C(0x2E98)
> 	.dw	0xFFFF	; pc=0x174D(0x2E9A)
> 	.dw	0xFFFF	; pc=0x174E(0x2E9C)
> 	.dw	0xFFFF	; pc=0x174F(0x2E9E)
> 	.dw	0xFFFF	; pc=0x1750(0x2EA0)
> 	.dw	0xFFFF	; pc=0x1751(0x2EA2)
> 	.dw	0xFFFF	; pc=0x1752(0x2EA4)
> 	.dw	0xFFFF	; pc=0x1753(0x2EA6)
> 	.dw	0xFFFF	; pc=0x1754(0x2EA8)
> 	.dw	0xFFFF	; pc=0x1755(0x2EAA)
> 	.dw	0xFFFF	; pc=0x1756(0x2EAC)
> 	.dw	0xFFFF	; pc=0x1757(0x2EAE)
> 	.dw	0xFFFF	; pc=0x1758(0x2EB0)
> 	.dw	0xFFFF	; pc=0x1759(0x2EB2)
> 	.dw	0xFFFF	; pc=0x175A(0x2EB4)
> 	.dw	0xFFFF	; pc=0x175B(0x2EB6)
> 	.dw	0xFFFF	; pc=0x175C(0x2EB8)
> 	.dw	0xFFFF	; pc=0x175D(0x2EBA)
> 	.dw	0xFFFF	; pc=0x175E(0x2EBC)
> 	.dw	0xFFFF	; pc=0x175F(0x2EBE)
> 	.dw	0xFFFF	; pc=0x1760(0x2EC0)
> 	.dw	0xFFFF	; pc=0x1761(0x2EC2)
> 	.dw	0xFFFF	; pc=0x1762(0x2EC4)
> 	.dw	0xFFFF	; pc=0x1763(0x2EC6)
> 	.dw	0xFFFF	; pc=0x1764(0x2EC8)
> 	.dw	0xFFFF	; pc=0x1765(0x2ECA)
> 	.dw	0xFFFF	; pc=0x1766(0x2ECC)
> 	.dw	0xFFFF	; pc=0x1767(0x2ECE)
> 	.dw	0xFFFF	; pc=0x1768(0x2ED0)
> 	.dw	0xFFFF	; pc=0x1769(0x2ED2)
> 	.dw	0xFFFF	; pc=0x176A(0x2ED4)
> 	.dw	0xFFFF	; pc=0x176B(0x2ED6)
> 	.dw	0xFFFF	; pc=0x176C(0x2ED8)
> 	.dw	0xFFFF	; pc=0x176D(0x2EDA)
> 	.dw	0xFFFF	; pc=0x176E(0x2EDC)
> 	.dw	0xFFFF	; pc=0x176F(0x2EDE)
> 	.dw	0xFFFF	; pc=0x1770(0x2EE0)
> 	.dw	0xFFFF	; pc=0x1771(0x2EE2)
> 	.dw	0xFFFF	; pc=0x1772(0x2EE4)
> 	.dw	0xFFFF	; pc=0x1773(0x2EE6)
> 	.dw	0xFFFF	; pc=0x1774(0x2EE8)
> 	.dw	0xFFFF	; pc=0x1775(0x2EEA)
> 	.dw	0xFFFF	; pc=0x1776(0x2EEC)
> 	.dw	0xFFFF	; pc=0x1777(0x2EEE)
> 	.dw	0xFFFF	; pc=0x1778(0x2EF0)
> 	.dw	0xFFFF	; pc=0x1779(0x2EF2)
> 	.dw	0xFFFF	; pc=0x177A(0x2EF4)
> 	.dw	0xFFFF	; pc=0x177B(0x2EF6)
> 	.dw	0xFFFF	; pc=0x177C(0x2EF8)
> 	.dw	0xFFFF	; pc=0x177D(0x2EFA)
> 	.dw	0xFFFF	; pc=0x177E(0x2EFC)
> 	.dw	0xFFFF	; pc=0x177F(0x2EFE)
> 	.dw	0xFFFF	; pc=0x1780(0x2F00)
> 	.dw	0xFFFF	; pc=0x1781(0x2F02)
> 	.dw	0xFFFF	; pc=0x1782(0x2F04)
> 	.dw	0xFFFF	; pc=0x1783(0x2F06)
> 	.dw	0xFFFF	; pc=0x1784(0x2F08)
> 	.dw	0xFFFF	; pc=0x1785(0x2F0A)
> 	.dw	0xFFFF	; pc=0x1786(0x2F0C)
> 	.dw	0xFFFF	; pc=0x1787(0x2F0E)
> 	.dw	0xFFFF	; pc=0x1788(0x2F10)
> 	.dw	0xFFFF	; pc=0x1789(0x2F12)
> 	.dw	0xFFFF	; pc=0x178A(0x2F14)
> 	.dw	0xFFFF	; pc=0x178B(0x2F16)
> 	.dw	0xFFFF	; pc=0x178C(0x2F18)
> 	.dw	0xFFFF	; pc=0x178D(0x2F1A)
> 	.dw	0xFFFF	; pc=0x178E(0x2F1C)
> 	.dw	0xFFFF	; pc=0x178F(0x2F1E)
> 	.dw	0xFFFF	; pc=0x1790(0x2F20)
> 	.dw	0xFFFF	; pc=0x1791(0x2F22)
> 	.dw	0xFFFF	; pc=0x1792(0x2F24)
> 	.dw	0xFFFF	; pc=0x1793(0x2F26)
> 	.dw	0xFFFF	; pc=0x1794(0x2F28)
> 	.dw	0xFFFF	; pc=0x1795(0x2F2A)
> 	.dw	0xFFFF	; pc=0x1796(0x2F2C)
> 	.dw	0xFFFF	; pc=0x1797(0x2F2E)
> 	.dw	0xFFFF	; pc=0x1798(0x2F30)
> 	.dw	0xFFFF	; pc=0x1799(0x2F32)
> 	.dw	0xFFFF	; pc=0x179A(0x2F34)
> 	.dw	0xFFFF	; pc=0x179B(0x2F36)
> 	.dw	0xFFFF	; pc=0x179C(0x2F38)
> 	.dw	0xFFFF	; pc=0x179D(0x2F3A)
> 	.dw	0xFFFF	; pc=0x179E(0x2F3C)
> 	.dw	0xFFFF	; pc=0x179F(0x2F3E)
> 	.dw	0xFFFF	; pc=0x17A0(0x2F40)
> 	.dw	0xFFFF	; pc=0x17A1(0x2F42)
> 	.dw	0xFFFF	; pc=0x17A2(0x2F44)
> 	.dw	0xFFFF	; pc=0x17A3(0x2F46)
> 	.dw	0xFFFF	; pc=0x17A4(0x2F48)
> 	.dw	0xFFFF	; pc=0x17A5(0x2F4A)
> 	.dw	0xFFFF	; pc=0x17A6(0x2F4C)
> 	.dw	0xFFFF	; pc=0x17A7(0x2F4E)
> 	.dw	0xFFFF	; pc=0x17A8(0x2F50)
> 	.dw	0xFFFF	; pc=0x17A9(0x2F52)
> 	.dw	0xFFFF	; pc=0x17AA(0x2F54)
> 	.dw	0xFFFF	; pc=0x17AB(0x2F56)
> 	.dw	0xFFFF	; pc=0x17AC(0x2F58)
> 	.dw	0xFFFF	; pc=0x17AD(0x2F5A)
> 	.dw	0xFFFF	; pc=0x17AE(0x2F5C)
> 	.dw	0xFFFF	; pc=0x17AF(0x2F5E)
> 	.dw	0xFFFF	; pc=0x17B0(0x2F60)
> 	.dw	0xFFFF	; pc=0x17B1(0x2F62)
> 	.dw	0xFFFF	; pc=0x17B2(0x2F64)
> 	.dw	0xFFFF	; pc=0x17B3(0x2F66)
> 	.dw	0xFFFF	; pc=0x17B4(0x2F68)
> 	.dw	0xFFFF	; pc=0x17B5(0x2F6A)
> 	.dw	0xFFFF	; pc=0x17B6(0x2F6C)
> 	.dw	0xFFFF	; pc=0x17B7(0x2F6E)
> 	.dw	0xFFFF	; pc=0x17B8(0x2F70)
> 	.dw	0xFFFF	; pc=0x17B9(0x2F72)
> 	.dw	0xFFFF	; pc=0x17BA(0x2F74)
> 	.dw	0xFFFF	; pc=0x17BB(0x2F76)
> 	.dw	0xFFFF	; pc=0x17BC(0x2F78)
> 	.dw	0xFFFF	; pc=0x17BD(0x2F7A)
> 	.dw	0xFFFF	; pc=0x17BE(0x2F7C)
> 	.dw	0xFFFF	; pc=0x17BF(0x2F7E)
> 	.dw	0xFFFF	; pc=0x17C0(0x2F80)
> 	.dw	0xFFFF	; pc=0x17C1(0x2F82)
> 	.dw	0xFFFF	; pc=0x17C2(0x2F84)
> 	.dw	0xFFFF	; pc=0x17C3(0x2F86)
> 	.dw	0xFFFF	; pc=0x17C4(0x2F88)
> 	.dw	0xFFFF	; pc=0x17C5(0x2F8A)
> 	.dw	0xFFFF	; pc=0x17C6(0x2F8C)
> 	.dw	0xFFFF	; pc=0x17C7(0x2F8E)
> 	.dw	0xFFFF	; pc=0x17C8(0x2F90)
> 	.dw	0xFFFF	; pc=0x17C9(0x2F92)
> 	.dw	0xFFFF	; pc=0x17CA(0x2F94)
> 	.dw	0xFFFF	; pc=0x17CB(0x2F96)
> 	.dw	0xFFFF	; pc=0x17CC(0x2F98)
> 	.dw	0xFFFF	; pc=0x17CD(0x2F9A)
> 	.dw	0xFFFF	; pc=0x17CE(0x2F9C)
> 	.dw	0xFFFF	; pc=0x17CF(0x2F9E)
> 	.dw	0xFFFF	; pc=0x17D0(0x2FA0)
> 	.dw	0xFFFF	; pc=0x17D1(0x2FA2)
> 	.dw	0xFFFF	; pc=0x17D2(0x2FA4)
> 	.dw	0xFFFF	; pc=0x17D3(0x2FA6)
> 	.dw	0xFFFF	; pc=0x17D4(0x2FA8)
> 	.dw	0xFFFF	; pc=0x17D5(0x2FAA)
> 	.dw	0xFFFF	; pc=0x17D6(0x2FAC)
> 	.dw	0xFFFF	; pc=0x17D7(0x2FAE)
> 	.dw	0xFFFF	; pc=0x17D8(0x2FB0)
> 	.dw	0xFFFF	; pc=0x17D9(0x2FB2)
> 	.dw	0xFFFF	; pc=0x17DA(0x2FB4)
> 	.dw	0xFFFF	; pc=0x17DB(0x2FB6)
> 	.dw	0xFFFF	; pc=0x17DC(0x2FB8)
> 	.dw	0xFFFF	; pc=0x17DD(0x2FBA)
> 	.dw	0xFFFF	; pc=0x17DE(0x2FBC)
> 	.dw	0xFFFF	; pc=0x17DF(0x2FBE)
> 	.dw	0xFFFF	; pc=0x17E0(0x2FC0)
> 	.dw	0xFFFF	; pc=0x17E1(0x2FC2)
> 	.dw	0xFFFF	; pc=0x17E2(0x2FC4)
> 	.dw	0xFFFF	; pc=0x17E3(0x2FC6)
> 	.dw	0xFFFF	; pc=0x17E4(0x2FC8)
> 	.dw	0xFFFF	; pc=0x17E5(0x2FCA)
> 	.dw	0xFFFF	; pc=0x17E6(0x2FCC)
> 	.dw	0xFFFF	; pc=0x17E7(0x2FCE)
> 	.dw	0xFFFF	; pc=0x17E8(0x2FD0)
> 	.dw	0xFFFF	; pc=0x17E9(0x2FD2)
> 	.dw	0xFFFF	; pc=0x17EA(0x2FD4)
> 	.dw	0xFFFF	; pc=0x17EB(0x2FD6)
> 	.dw	0xFFFF	; pc=0x17EC(0x2FD8)
> 	.dw	0xFFFF	; pc=0x17ED(0x2FDA)
> 	.dw	0xFFFF	; pc=0x17EE(0x2FDC)
> 	.dw	0xFFFF	; pc=0x17EF(0x2FDE)
> 	.dw	0xFFFF	; pc=0x17F0(0x2FE0)
> 	.dw	0xFFFF	; pc=0x17F1(0x2FE2)
> 	.dw	0xFFFF	; pc=0x17F2(0x2FE4)
> 	.dw	0xFFFF	; pc=0x17F3(0x2FE6)
> 	.dw	0xFFFF	; pc=0x17F4(0x2FE8)
> 	.dw	0xFFFF	; pc=0x17F5(0x2FEA)
> 	.dw	0xFFFF	; pc=0x17F6(0x2FEC)
> 	.dw	0xFFFF	; pc=0x17F7(0x2FEE)
> 	.dw	0xFFFF	; pc=0x17F8(0x2FF0)
> 	.dw	0xFFFF	; pc=0x17F9(0x2FF2)
> 	.dw	0xFFFF	; pc=0x17FA(0x2FF4)
> 	.dw	0xFFFF	; pc=0x17FB(0x2FF6)
> 	.dw	0xFFFF	; pc=0x17FC(0x2FF8)
> 	.dw	0xFFFF	; pc=0x17FD(0x2FFA)
> 	.dw	0xFFFF	; pc=0x17FE(0x2FFC)
> 	.dw	0xFFFF	; pc=0x17FF(0x2FFE)
> 	.dw	0xFFFF	; pc=0x1800(0x3000)
> 	.dw	0xFFFF	; pc=0x1801(0x3002)
> 	.dw	0xFFFF	; pc=0x1802(0x3004)
> 	.dw	0xFFFF	; pc=0x1803(0x3006)
> 	.dw	0xFFFF	; pc=0x1804(0x3008)
> 	.dw	0xFFFF	; pc=0x1805(0x300A)
> 	.dw	0xFFFF	; pc=0x1806(0x300C)
> 	.dw	0xFFFF	; pc=0x1807(0x300E)
> 	.dw	0xFFFF	; pc=0x1808(0x3010)
> 	.dw	0xFFFF	; pc=0x1809(0x3012)
> 	.dw	0xFFFF	; pc=0x180A(0x3014)
> 	.dw	0xFFFF	; pc=0x180B(0x3016)
> 	.dw	0xFFFF	; pc=0x180C(0x3018)
> 	.dw	0xFFFF	; pc=0x180D(0x301A)
> 	.dw	0xFFFF	; pc=0x180E(0x301C)
> 	.dw	0xFFFF	; pc=0x180F(0x301E)
> 	.dw	0xFFFF	; pc=0x1810(0x3020)
> 	.dw	0xFFFF	; pc=0x1811(0x3022)
> 	.dw	0xFFFF	; pc=0x1812(0x3024)
> 	.dw	0xFFFF	; pc=0x1813(0x3026)
> 	.dw	0xFFFF	; pc=0x1814(0x3028)
> 	.dw	0xFFFF	; pc=0x1815(0x302A)
> 	.dw	0xFFFF	; pc=0x1816(0x302C)
> 	.dw	0xFFFF	; pc=0x1817(0x302E)
> 	.dw	0xFFFF	; pc=0x1818(0x3030)
> 	.dw	0xFFFF	; pc=0x1819(0x3032)
> 	.dw	0xFFFF	; pc=0x181A(0x3034)
> 	.dw	0xFFFF	; pc=0x181B(0x3036)
> 	.dw	0xFFFF	; pc=0x181C(0x3038)
> 	.dw	0xFFFF	; pc=0x181D(0x303A)
> 	.dw	0xFFFF	; pc=0x181E(0x303C)
> 	.dw	0xFFFF	; pc=0x181F(0x303E)
> 	.dw	0xFFFF	; pc=0x1820(0x3040)
> 	.dw	0xFFFF	; pc=0x1821(0x3042)
> 	.dw	0xFFFF	; pc=0x1822(0x3044)
> 	.dw	0xFFFF	; pc=0x1823(0x3046)
> 	.dw	0xFFFF	; pc=0x1824(0x3048)
> 	.dw	0xFFFF	; pc=0x1825(0x304A)
> 	.dw	0xFFFF	; pc=0x1826(0x304C)
> 	.dw	0xFFFF	; pc=0x1827(0x304E)
> 	.dw	0xFFFF	; pc=0x1828(0x3050)
> 	.dw	0xFFFF	; pc=0x1829(0x3052)
> 	.dw	0xFFFF	; pc=0x182A(0x3054)
> 	.dw	0xFFFF	; pc=0x182B(0x3056)
> 	.dw	0xFFFF	; pc=0x182C(0x3058)
> 	.dw	0xFFFF	; pc=0x182D(0x305A)
> 	.dw	0xFFFF	; pc=0x182E(0x305C)
> 	.dw	0xFFFF	; pc=0x182F(0x305E)
> 	.dw	0xFFFF	; pc=0x1830(0x3060)
> 	.dw	0xFFFF	; pc=0x1831(0x3062)
> 	.dw	0xFFFF	; pc=0x1832(0x3064)
> 	.dw	0xFFFF	; pc=0x1833(0x3066)
> 	.dw	0xFFFF	; pc=0x1834(0x3068)
> 	.dw	0xFFFF	; pc=0x1835(0x306A)
> 	.dw	0xFFFF	; pc=0x1836(0x306C)
> 	.dw	0xFFFF	; pc=0x1837(0x306E)
> 	.dw	0xFFFF	; pc=0x1838(0x3070)
> 	.dw	0xFFFF	; pc=0x1839(0x3072)
> 	.dw	0xFFFF	; pc=0x183A(0x3074)
> 	.dw	0xFFFF	; pc=0x183B(0x3076)
> 	.dw	0xFFFF	; pc=0x183C(0x3078)
> 	.dw	0xFFFF	; pc=0x183D(0x307A)
> 	.dw	0xFFFF	; pc=0x183E(0x307C)
> 	.dw	0xFFFF	; pc=0x183F(0x307E)
> 	.dw	0xFFFF	; pc=0x1840(0x3080)
> 	.dw	0xFFFF	; pc=0x1841(0x3082)
> 	.dw	0xFFFF	; pc=0x1842(0x3084)
> 	.dw	0xFFFF	; pc=0x1843(0x3086)
> 	.dw	0xFFFF	; pc=0x1844(0x3088)
> 	.dw	0xFFFF	; pc=0x1845(0x308A)
> 	.dw	0xFFFF	; pc=0x1846(0x308C)
> 	.dw	0xFFFF	; pc=0x1847(0x308E)
> 	.dw	0xFFFF	; pc=0x1848(0x3090)
> 	.dw	0xFFFF	; pc=0x1849(0x3092)
> 	.dw	0xFFFF	; pc=0x184A(0x3094)
> 	.dw	0xFFFF	; pc=0x184B(0x3096)
> 	.dw	0xFFFF	; pc=0x184C(0x3098)
> 	.dw	0xFFFF	; pc=0x184D(0x309A)
> 	.dw	0xFFFF	; pc=0x184E(0x309C)
> 	.dw	0xFFFF	; pc=0x184F(0x309E)
> 	.dw	0xFFFF	; pc=0x1850(0x30A0)
> 	.dw	0xFFFF	; pc=0x1851(0x30A2)
> 	.dw	0xFFFF	; pc=0x1852(0x30A4)
> 	.dw	0xFFFF	; pc=0x1853(0x30A6)
> 	.dw	0xFFFF	; pc=0x1854(0x30A8)
> 	.dw	0xFFFF	; pc=0x1855(0x30AA)
> 	.dw	0xFFFF	; pc=0x1856(0x30AC)
> 	.dw	0xFFFF	; pc=0x1857(0x30AE)
> 	.dw	0xFFFF	; pc=0x1858(0x30B0)
> 	.dw	0xFFFF	; pc=0x1859(0x30B2)
> 	.dw	0xFFFF	; pc=0x185A(0x30B4)
> 	.dw	0xFFFF	; pc=0x185B(0x30B6)
> 	.dw	0xFFFF	; pc=0x185C(0x30B8)
> 	.dw	0xFFFF	; pc=0x185D(0x30BA)
> 	.dw	0xFFFF	; pc=0x185E(0x30BC)
> 	.dw	0xFFFF	; pc=0x185F(0x30BE)
> 	.dw	0xFFFF	; pc=0x1860(0x30C0)
> 	.dw	0xFFFF	; pc=0x1861(0x30C2)
> 	.dw	0xFFFF	; pc=0x1862(0x30C4)
> 	.dw	0xFFFF	; pc=0x1863(0x30C6)
> 	.dw	0xFFFF	; pc=0x1864(0x30C8)
> 	.dw	0xFFFF	; pc=0x1865(0x30CA)
> 	.dw	0xFFFF	; pc=0x1866(0x30CC)
> 	.dw	0xFFFF	; pc=0x1867(0x30CE)
> 	.dw	0xFFFF	; pc=0x1868(0x30D0)
> 	.dw	0xFFFF	; pc=0x1869(0x30D2)
> 	.dw	0xFFFF	; pc=0x186A(0x30D4)
> 	.dw	0xFFFF	; pc=0x186B(0x30D6)
> 	.dw	0xFFFF	; pc=0x186C(0x30D8)
> 	.dw	0xFFFF	; pc=0x186D(0x30DA)
> 	.dw	0xFFFF	; pc=0x186E(0x30DC)
> 	.dw	0xFFFF	; pc=0x186F(0x30DE)
> 	.dw	0xFFFF	; pc=0x1870(0x30E0)
> 	.dw	0xFFFF	; pc=0x1871(0x30E2)
> 	.dw	0xFFFF	; pc=0x1872(0x30E4)
> 	.dw	0xFFFF	; pc=0x1873(0x30E6)
> 	.dw	0xFFFF	; pc=0x1874(0x30E8)
> 	.dw	0xFFFF	; pc=0x1875(0x30EA)
> 	.dw	0xFFFF	; pc=0x1876(0x30EC)
> 	.dw	0xFFFF	; pc=0x1877(0x30EE)
> 	.dw	0xFFFF	; pc=0x1878(0x30F0)
> 	.dw	0xFFFF	; pc=0x1879(0x30F2)
> 	.dw	0xFFFF	; pc=0x187A(0x30F4)
> 	.dw	0xFFFF	; pc=0x187B(0x30F6)
> 	.dw	0xFFFF	; pc=0x187C(0x30F8)
> 	.dw	0xFFFF	; pc=0x187D(0x30FA)
> 	.dw	0xFFFF	; pc=0x187E(0x30FC)
> 	.dw	0xFFFF	; pc=0x187F(0x30FE)
> 	.dw	0xFFFF	; pc=0x1880(0x3100)
> 	.dw	0xFFFF	; pc=0x1881(0x3102)
> 	.dw	0xFFFF	; pc=0x1882(0x3104)
> 	.dw	0xFFFF	; pc=0x1883(0x3106)
> 	.dw	0xFFFF	; pc=0x1884(0x3108)
> 	.dw	0xFFFF	; pc=0x1885(0x310A)
> 	.dw	0xFFFF	; pc=0x1886(0x310C)
> 	.dw	0xFFFF	; pc=0x1887(0x310E)
> 	.dw	0xFFFF	; pc=0x1888(0x3110)
> 	.dw	0xFFFF	; pc=0x1889(0x3112)
> 	.dw	0xFFFF	; pc=0x188A(0x3114)
> 	.dw	0xFFFF	; pc=0x188B(0x3116)
> 	.dw	0xFFFF	; pc=0x188C(0x3118)
> 	.dw	0xFFFF	; pc=0x188D(0x311A)
> 	.dw	0xFFFF	; pc=0x188E(0x311C)
> 	.dw	0xFFFF	; pc=0x188F(0x311E)
> 	.dw	0xFFFF	; pc=0x1890(0x3120)
> 	.dw	0xFFFF	; pc=0x1891(0x3122)
> 	.dw	0xFFFF	; pc=0x1892(0x3124)
> 	.dw	0xFFFF	; pc=0x1893(0x3126)
> 	.dw	0xFFFF	; pc=0x1894(0x3128)
> 	.dw	0xFFFF	; pc=0x1895(0x312A)
> 	.dw	0xFFFF	; pc=0x1896(0x312C)
> 	.dw	0xFFFF	; pc=0x1897(0x312E)
> 	.dw	0xFFFF	; pc=0x1898(0x3130)
> 	.dw	0xFFFF	; pc=0x1899(0x3132)
> 	.dw	0xFFFF	; pc=0x189A(0x3134)
> 	.dw	0xFFFF	; pc=0x189B(0x3136)
> 	.dw	0xFFFF	; pc=0x189C(0x3138)
> 	.dw	0xFFFF	; pc=0x189D(0x313A)
> 	.dw	0xFFFF	; pc=0x189E(0x313C)
> 	.dw	0xFFFF	; pc=0x189F(0x313E)
> 	.dw	0xFFFF	; pc=0x18A0(0x3140)
> 	.dw	0xFFFF	; pc=0x18A1(0x3142)
> 	.dw	0xFFFF	; pc=0x18A2(0x3144)
> 	.dw	0xFFFF	; pc=0x18A3(0x3146)
> 	.dw	0xFFFF	; pc=0x18A4(0x3148)
> 	.dw	0xFFFF	; pc=0x18A5(0x314A)
> 	.dw	0xFFFF	; pc=0x18A6(0x314C)
> 	.dw	0xFFFF	; pc=0x18A7(0x314E)
> 	.dw	0xFFFF	; pc=0x18A8(0x3150)
> 	.dw	0xFFFF	; pc=0x18A9(0x3152)
> 	.dw	0xFFFF	; pc=0x18AA(0x3154)
> 	.dw	0xFFFF	; pc=0x18AB(0x3156)
> 	.dw	0xFFFF	; pc=0x18AC(0x3158)
> 	.dw	0xFFFF	; pc=0x18AD(0x315A)
> 	.dw	0xFFFF	; pc=0x18AE(0x315C)
> 	.dw	0xFFFF	; pc=0x18AF(0x315E)
> 	.dw	0xFFFF	; pc=0x18B0(0x3160)
> 	.dw	0xFFFF	; pc=0x18B1(0x3162)
> 	.dw	0xFFFF	; pc=0x18B2(0x3164)
> 	.dw	0xFFFF	; pc=0x18B3(0x3166)
> 	.dw	0xFFFF	; pc=0x18B4(0x3168)
> 	.dw	0xFFFF	; pc=0x18B5(0x316A)
> 	.dw	0xFFFF	; pc=0x18B6(0x316C)
> 	.dw	0xFFFF	; pc=0x18B7(0x316E)
> 	.dw	0xFFFF	; pc=0x18B8(0x3170)
> 	.dw	0xFFFF	; pc=0x18B9(0x3172)
> 	.dw	0xFFFF	; pc=0x18BA(0x3174)
> 	.dw	0xFFFF	; pc=0x18BB(0x3176)
> 	.dw	0xFFFF	; pc=0x18BC(0x3178)
> 	.dw	0xFFFF	; pc=0x18BD(0x317A)
> 	.dw	0xFFFF	; pc=0x18BE(0x317C)
> 	.dw	0xFFFF	; pc=0x18BF(0x317E)
> 	.dw	0xFFFF	; pc=0x18C0(0x3180)
> 	.dw	0xFFFF	; pc=0x18C1(0x3182)
> 	.dw	0xFFFF	; pc=0x18C2(0x3184)
> 	.dw	0xFFFF	; pc=0x18C3(0x3186)
> 	.dw	0xFFFF	; pc=0x18C4(0x3188)
> 	.dw	0xFFFF	; pc=0x18C5(0x318A)
> 	.dw	0xFFFF	; pc=0x18C6(0x318C)
> 	.dw	0xFFFF	; pc=0x18C7(0x318E)
> 	.dw	0xFFFF	; pc=0x18C8(0x3190)
> 	.dw	0xFFFF	; pc=0x18C9(0x3192)
> 	.dw	0xFFFF	; pc=0x18CA(0x3194)
> 	.dw	0xFFFF	; pc=0x18CB(0x3196)
> 	.dw	0xFFFF	; pc=0x18CC(0x3198)
> 	.dw	0xFFFF	; pc=0x18CD(0x319A)
> 	.dw	0xFFFF	; pc=0x18CE(0x319C)
> 	.dw	0xFFFF	; pc=0x18CF(0x319E)
> 	.dw	0xFFFF	; pc=0x18D0(0x31A0)
> 	.dw	0xFFFF	; pc=0x18D1(0x31A2)
> 	.dw	0xFFFF	; pc=0x18D2(0x31A4)
> 	.dw	0xFFFF	; pc=0x18D3(0x31A6)
> 	.dw	0xFFFF	; pc=0x18D4(0x31A8)
> 	.dw	0xFFFF	; pc=0x18D5(0x31AA)
> 	.dw	0xFFFF	; pc=0x18D6(0x31AC)
> 	.dw	0xFFFF	; pc=0x18D7(0x31AE)
> 	.dw	0xFFFF	; pc=0x18D8(0x31B0)
> 	.dw	0xFFFF	; pc=0x18D9(0x31B2)
> 	.dw	0xFFFF	; pc=0x18DA(0x31B4)
> 	.dw	0xFFFF	; pc=0x18DB(0x31B6)
> 	.dw	0xFFFF	; pc=0x18DC(0x31B8)
> 	.dw	0xFFFF	; pc=0x18DD(0x31BA)
> 	.dw	0xFFFF	; pc=0x18DE(0x31BC)
> 	.dw	0xFFFF	; pc=0x18DF(0x31BE)
> 	.dw	0xFFFF	; pc=0x18E0(0x31C0)
> 	.dw	0xFFFF	; pc=0x18E1(0x31C2)
> 	.dw	0xFFFF	; pc=0x18E2(0x31C4)
> 	.dw	0xFFFF	; pc=0x18E3(0x31C6)
> 	.dw	0xFFFF	; pc=0x18E4(0x31C8)
> 	.dw	0xFFFF	; pc=0x18E5(0x31CA)
> 	.dw	0xFFFF	; pc=0x18E6(0x31CC)
> 	.dw	0xFFFF	; pc=0x18E7(0x31CE)
> 	.dw	0xFFFF	; pc=0x18E8(0x31D0)
> 	.dw	0xFFFF	; pc=0x18E9(0x31D2)
> 	.dw	0xFFFF	; pc=0x18EA(0x31D4)
> 	.dw	0xFFFF	; pc=0x18EB(0x31D6)
> 	.dw	0xFFFF	; pc=0x18EC(0x31D8)
> 	.dw	0xFFFF	; pc=0x18ED(0x31DA)
> 	.dw	0xFFFF	; pc=0x18EE(0x31DC)
> 	.dw	0xFFFF	; pc=0x18EF(0x31DE)
> 	.dw	0xFFFF	; pc=0x18F0(0x31E0)
> 	.dw	0xFFFF	; pc=0x18F1(0x31E2)
> 	.dw	0xFFFF	; pc=0x18F2(0x31E4)
> 	.dw	0xFFFF	; pc=0x18F3(0x31E6)
> 	.dw	0xFFFF	; pc=0x18F4(0x31E8)
> 	.dw	0xFFFF	; pc=0x18F5(0x31EA)
> 	.dw	0xFFFF	; pc=0x18F6(0x31EC)
> 	.dw	0xFFFF	; pc=0x18F7(0x31EE)
> 	.dw	0xFFFF	; pc=0x18F8(0x31F0)
> 	.dw	0xFFFF	; pc=0x18F9(0x31F2)
> 	.dw	0xFFFF	; pc=0x18FA(0x31F4)
> 	.dw	0xFFFF	; pc=0x18FB(0x31F6)
> 	.dw	0xFFFF	; pc=0x18FC(0x31F8)
> 	.dw	0xFFFF	; pc=0x18FD(0x31FA)
> 	.dw	0xFFFF	; pc=0x18FE(0x31FC)
> 	.dw	0xFFFF	; pc=0x18FF(0x31FE)
> 	.dw	0xFFFF	; pc=0x1900(0x3200)
> 	.dw	0xFFFF	; pc=0x1901(0x3202)
> 	.dw	0xFFFF	; pc=0x1902(0x3204)
> 	.dw	0xFFFF	; pc=0x1903(0x3206)
> 	.dw	0xFFFF	; pc=0x1904(0x3208)
> 	.dw	0xFFFF	; pc=0x1905(0x320A)
> 	.dw	0xFFFF	; pc=0x1906(0x320C)
> 	.dw	0xFFFF	; pc=0x1907(0x320E)
> 	.dw	0xFFFF	; pc=0x1908(0x3210)
> 	.dw	0xFFFF	; pc=0x1909(0x3212)
> 	.dw	0xFFFF	; pc=0x190A(0x3214)
> 	.dw	0xFFFF	; pc=0x190B(0x3216)
> 	.dw	0xFFFF	; pc=0x190C(0x3218)
> 	.dw	0xFFFF	; pc=0x190D(0x321A)
> 	.dw	0xFFFF	; pc=0x190E(0x321C)
> 	.dw	0xFFFF	; pc=0x190F(0x321E)
> 	.dw	0xFFFF	; pc=0x1910(0x3220)
> 	.dw	0xFFFF	; pc=0x1911(0x3222)
> 	.dw	0xFFFF	; pc=0x1912(0x3224)
> 	.dw	0xFFFF	; pc=0x1913(0x3226)
> 	.dw	0xFFFF	; pc=0x1914(0x3228)
> 	.dw	0xFFFF	; pc=0x1915(0x322A)
> 	.dw	0xFFFF	; pc=0x1916(0x322C)
> 	.dw	0xFFFF	; pc=0x1917(0x322E)
> 	.dw	0xFFFF	; pc=0x1918(0x3230)
> 	.dw	0xFFFF	; pc=0x1919(0x3232)
> 	.dw	0xFFFF	; pc=0x191A(0x3234)
> 	.dw	0xFFFF	; pc=0x191B(0x3236)
> 	.dw	0xFFFF	; pc=0x191C(0x3238)
> 	.dw	0xFFFF	; pc=0x191D(0x323A)
> 	.dw	0xFFFF	; pc=0x191E(0x323C)
> 	.dw	0xFFFF	; pc=0x191F(0x323E)
> 	.dw	0xFFFF	; pc=0x1920(0x3240)
> 	.dw	0xFFFF	; pc=0x1921(0x3242)
> 	.dw	0xFFFF	; pc=0x1922(0x3244)
> 	.dw	0xFFFF	; pc=0x1923(0x3246)
> 	.dw	0xFFFF	; pc=0x1924(0x3248)
> 	.dw	0xFFFF	; pc=0x1925(0x324A)
> 	.dw	0xFFFF	; pc=0x1926(0x324C)
> 	.dw	0xFFFF	; pc=0x1927(0x324E)
> 	.dw	0xFFFF	; pc=0x1928(0x3250)
> 	.dw	0xFFFF	; pc=0x1929(0x3252)
> 	.dw	0xFFFF	; pc=0x192A(0x3254)
> 	.dw	0xFFFF	; pc=0x192B(0x3256)
> 	.dw	0xFFFF	; pc=0x192C(0x3258)
> 	.dw	0xFFFF	; pc=0x192D(0x325A)
> 	.dw	0xFFFF	; pc=0x192E(0x325C)
> 	.dw	0xFFFF	; pc=0x192F(0x325E)
> 	.dw	0xFFFF	; pc=0x1930(0x3260)
> 	.dw	0xFFFF	; pc=0x1931(0x3262)
> 	.dw	0xFFFF	; pc=0x1932(0x3264)
> 	.dw	0xFFFF	; pc=0x1933(0x3266)
> 	.dw	0xFFFF	; pc=0x1934(0x3268)
> 	.dw	0xFFFF	; pc=0x1935(0x326A)
> 	.dw	0xFFFF	; pc=0x1936(0x326C)
> 	.dw	0xFFFF	; pc=0x1937(0x326E)
> 	.dw	0xFFFF	; pc=0x1938(0x3270)
> 	.dw	0xFFFF	; pc=0x1939(0x3272)
> 	.dw	0xFFFF	; pc=0x193A(0x3274)
> 	.dw	0xFFFF	; pc=0x193B(0x3276)
> 	.dw	0xFFFF	; pc=0x193C(0x3278)
> 	.dw	0xFFFF	; pc=0x193D(0x327A)
> 	.dw	0xFFFF	; pc=0x193E(0x327C)
> 	.dw	0xFFFF	; pc=0x193F(0x327E)
> 	.dw	0xFFFF	; pc=0x1940(0x3280)
> 	.dw	0xFFFF	; pc=0x1941(0x3282)
> 	.dw	0xFFFF	; pc=0x1942(0x3284)
> 	.dw	0xFFFF	; pc=0x1943(0x3286)
> 	.dw	0xFFFF	; pc=0x1944(0x3288)
> 	.dw	0xFFFF	; pc=0x1945(0x328A)
> 	.dw	0xFFFF	; pc=0x1946(0x328C)
> 	.dw	0xFFFF	; pc=0x1947(0x328E)
> 	.dw	0xFFFF	; pc=0x1948(0x3290)
> 	.dw	0xFFFF	; pc=0x1949(0x3292)
> 	.dw	0xFFFF	; pc=0x194A(0x3294)
> 	.dw	0xFFFF	; pc=0x194B(0x3296)
> 	.dw	0xFFFF	; pc=0x194C(0x3298)
> 	.dw	0xFFFF	; pc=0x194D(0x329A)
> 	.dw	0xFFFF	; pc=0x194E(0x329C)
> 	.dw	0xFFFF	; pc=0x194F(0x329E)
> 	.dw	0xFFFF	; pc=0x1950(0x32A0)
> 	.dw	0xFFFF	; pc=0x1951(0x32A2)
> 	.dw	0xFFFF	; pc=0x1952(0x32A4)
> 	.dw	0xFFFF	; pc=0x1953(0x32A6)
> 	.dw	0xFFFF	; pc=0x1954(0x32A8)
> 	.dw	0xFFFF	; pc=0x1955(0x32AA)
> 	.dw	0xFFFF	; pc=0x1956(0x32AC)
> 	.dw	0xFFFF	; pc=0x1957(0x32AE)
> 	.dw	0xFFFF	; pc=0x1958(0x32B0)
> 	.dw	0xFFFF	; pc=0x1959(0x32B2)
> 	.dw	0xFFFF	; pc=0x195A(0x32B4)
> 	.dw	0xFFFF	; pc=0x195B(0x32B6)
> 	.dw	0xFFFF	; pc=0x195C(0x32B8)
> 	.dw	0xFFFF	; pc=0x195D(0x32BA)
> 	.dw	0xFFFF	; pc=0x195E(0x32BC)
> 	.dw	0xFFFF	; pc=0x195F(0x32BE)
> 	.dw	0xFFFF	; pc=0x1960(0x32C0)
> 	.dw	0xFFFF	; pc=0x1961(0x32C2)
> 	.dw	0xFFFF	; pc=0x1962(0x32C4)
> 	.dw	0xFFFF	; pc=0x1963(0x32C6)
> 	.dw	0xFFFF	; pc=0x1964(0x32C8)
> 	.dw	0xFFFF	; pc=0x1965(0x32CA)
> 	.dw	0xFFFF	; pc=0x1966(0x32CC)
> 	.dw	0xFFFF	; pc=0x1967(0x32CE)
> 	.dw	0xFFFF	; pc=0x1968(0x32D0)
> 	.dw	0xFFFF	; pc=0x1969(0x32D2)
> 	.dw	0xFFFF	; pc=0x196A(0x32D4)
> 	.dw	0xFFFF	; pc=0x196B(0x32D6)
> 	.dw	0xFFFF	; pc=0x196C(0x32D8)
> 	.dw	0xFFFF	; pc=0x196D(0x32DA)
> 	.dw	0xFFFF	; pc=0x196E(0x32DC)
> 	.dw	0xFFFF	; pc=0x196F(0x32DE)
> 	.dw	0xFFFF	; pc=0x1970(0x32E0)
> 	.dw	0xFFFF	; pc=0x1971(0x32E2)
> 	.dw	0xFFFF	; pc=0x1972(0x32E4)
> 	.dw	0xFFFF	; pc=0x1973(0x32E6)
> 	.dw	0xFFFF	; pc=0x1974(0x32E8)
> 	.dw	0xFFFF	; pc=0x1975(0x32EA)
> 	.dw	0xFFFF	; pc=0x1976(0x32EC)
> 	.dw	0xFFFF	; pc=0x1977(0x32EE)
> 	.dw	0xFFFF	; pc=0x1978(0x32F0)
> 	.dw	0xFFFF	; pc=0x1979(0x32F2)
> 	.dw	0xFFFF	; pc=0x197A(0x32F4)
> 	.dw	0xFFFF	; pc=0x197B(0x32F6)
> 	.dw	0xFFFF	; pc=0x197C(0x32F8)
> 	.dw	0xFFFF	; pc=0x197D(0x32FA)
> 	.dw	0xFFFF	; pc=0x197E(0x32FC)
> 	.dw	0xFFFF	; pc=0x197F(0x32FE)
> 	.dw	0xFFFF	; pc=0x1980(0x3300)
> 	.dw	0xFFFF	; pc=0x1981(0x3302)
> 	.dw	0xFFFF	; pc=0x1982(0x3304)
> 	.dw	0xFFFF	; pc=0x1983(0x3306)
> 	.dw	0xFFFF	; pc=0x1984(0x3308)
> 	.dw	0xFFFF	; pc=0x1985(0x330A)
> 	.dw	0xFFFF	; pc=0x1986(0x330C)
> 	.dw	0xFFFF	; pc=0x1987(0x330E)
> 	.dw	0xFFFF	; pc=0x1988(0x3310)
> 	.dw	0xFFFF	; pc=0x1989(0x3312)
> 	.dw	0xFFFF	; pc=0x198A(0x3314)
> 	.dw	0xFFFF	; pc=0x198B(0x3316)
> 	.dw	0xFFFF	; pc=0x198C(0x3318)
> 	.dw	0xFFFF	; pc=0x198D(0x331A)
> 	.dw	0xFFFF	; pc=0x198E(0x331C)
> 	.dw	0xFFFF	; pc=0x198F(0x331E)
> 	.dw	0xFFFF	; pc=0x1990(0x3320)
> 	.dw	0xFFFF	; pc=0x1991(0x3322)
> 	.dw	0xFFFF	; pc=0x1992(0x3324)
> 	.dw	0xFFFF	; pc=0x1993(0x3326)
> 	.dw	0xFFFF	; pc=0x1994(0x3328)
> 	.dw	0xFFFF	; pc=0x1995(0x332A)
> 	.dw	0xFFFF	; pc=0x1996(0x332C)
> 	.dw	0xFFFF	; pc=0x1997(0x332E)
> 	.dw	0xFFFF	; pc=0x1998(0x3330)
> 	.dw	0xFFFF	; pc=0x1999(0x3332)
> 	.dw	0xFFFF	; pc=0x199A(0x3334)
> 	.dw	0xFFFF	; pc=0x199B(0x3336)
> 	.dw	0xFFFF	; pc=0x199C(0x3338)
> 	.dw	0xFFFF	; pc=0x199D(0x333A)
> 	.dw	0xFFFF	; pc=0x199E(0x333C)
> 	.dw	0xFFFF	; pc=0x199F(0x333E)
> 	.dw	0xFFFF	; pc=0x19A0(0x3340)
> 	.dw	0xFFFF	; pc=0x19A1(0x3342)
> 	.dw	0xFFFF	; pc=0x19A2(0x3344)
> 	.dw	0xFFFF	; pc=0x19A3(0x3346)
> 	.dw	0xFFFF	; pc=0x19A4(0x3348)
> 	.dw	0xFFFF	; pc=0x19A5(0x334A)
> 	.dw	0xFFFF	; pc=0x19A6(0x334C)
> 	.dw	0xFFFF	; pc=0x19A7(0x334E)
> 	.dw	0xFFFF	; pc=0x19A8(0x3350)
> 	.dw	0xFFFF	; pc=0x19A9(0x3352)
> 	.dw	0xFFFF	; pc=0x19AA(0x3354)
> 	.dw	0xFFFF	; pc=0x19AB(0x3356)
> 	.dw	0xFFFF	; pc=0x19AC(0x3358)
> 	.dw	0xFFFF	; pc=0x19AD(0x335A)
> 	.dw	0xFFFF	; pc=0x19AE(0x335C)
> 	.dw	0xFFFF	; pc=0x19AF(0x335E)
> 	.dw	0xFFFF	; pc=0x19B0(0x3360)
> 	.dw	0xFFFF	; pc=0x19B1(0x3362)
> 	.dw	0xFFFF	; pc=0x19B2(0x3364)
> 	.dw	0xFFFF	; pc=0x19B3(0x3366)
> 	.dw	0xFFFF	; pc=0x19B4(0x3368)
> 	.dw	0xFFFF	; pc=0x19B5(0x336A)
> 	.dw	0xFFFF	; pc=0x19B6(0x336C)
> 	.dw	0xFFFF	; pc=0x19B7(0x336E)
> 	.dw	0xFFFF	; pc=0x19B8(0x3370)
> 	.dw	0xFFFF	; pc=0x19B9(0x3372)
> 	.dw	0xFFFF	; pc=0x19BA(0x3374)
> 	.dw	0xFFFF	; pc=0x19BB(0x3376)
> 	.dw	0xFFFF	; pc=0x19BC(0x3378)
> 	.dw	0xFFFF	; pc=0x19BD(0x337A)
> 	.dw	0xFFFF	; pc=0x19BE(0x337C)
> 	.dw	0xFFFF	; pc=0x19BF(0x337E)
> 	.dw	0xFFFF	; pc=0x19C0(0x3380)
> 	.dw	0xFFFF	; pc=0x19C1(0x3382)
> 	.dw	0xFFFF	; pc=0x19C2(0x3384)
> 	.dw	0xFFFF	; pc=0x19C3(0x3386)
> 	.dw	0xFFFF	; pc=0x19C4(0x3388)
> 	.dw	0xFFFF	; pc=0x19C5(0x338A)
> 	.dw	0xFFFF	; pc=0x19C6(0x338C)
> 	.dw	0xFFFF	; pc=0x19C7(0x338E)
> 	.dw	0xFFFF	; pc=0x19C8(0x3390)
> 	.dw	0xFFFF	; pc=0x19C9(0x3392)
> 	.dw	0xFFFF	; pc=0x19CA(0x3394)
> 	.dw	0xFFFF	; pc=0x19CB(0x3396)
> 	.dw	0xFFFF	; pc=0x19CC(0x3398)
> 	.dw	0xFFFF	; pc=0x19CD(0x339A)
> 	.dw	0xFFFF	; pc=0x19CE(0x339C)
> 	.dw	0xFFFF	; pc=0x19CF(0x339E)
> 	.dw	0xFFFF	; pc=0x19D0(0x33A0)
> 	.dw	0xFFFF	; pc=0x19D1(0x33A2)
> 	.dw	0xFFFF	; pc=0x19D2(0x33A4)
> 	.dw	0xFFFF	; pc=0x19D3(0x33A6)
> 	.dw	0xFFFF	; pc=0x19D4(0x33A8)
> 	.dw	0xFFFF	; pc=0x19D5(0x33AA)
> 	.dw	0xFFFF	; pc=0x19D6(0x33AC)
> 	.dw	0xFFFF	; pc=0x19D7(0x33AE)
> 	.dw	0xFFFF	; pc=0x19D8(0x33B0)
> 	.dw	0xFFFF	; pc=0x19D9(0x33B2)
> 	.dw	0xFFFF	; pc=0x19DA(0x33B4)
> 	.dw	0xFFFF	; pc=0x19DB(0x33B6)
> 	.dw	0xFFFF	; pc=0x19DC(0x33B8)
> 	.dw	0xFFFF	; pc=0x19DD(0x33BA)
> 	.dw	0xFFFF	; pc=0x19DE(0x33BC)
> 	.dw	0xFFFF	; pc=0x19DF(0x33BE)
> 	.dw	0xFFFF	; pc=0x19E0(0x33C0)
> 	.dw	0xFFFF	; pc=0x19E1(0x33C2)
> 	.dw	0xFFFF	; pc=0x19E2(0x33C4)
> 	.dw	0xFFFF	; pc=0x19E3(0x33C6)
> 	.dw	0xFFFF	; pc=0x19E4(0x33C8)
> 	.dw	0xFFFF	; pc=0x19E5(0x33CA)
> 	.dw	0xFFFF	; pc=0x19E6(0x33CC)
> 	.dw	0xFFFF	; pc=0x19E7(0x33CE)
> 	.dw	0xFFFF	; pc=0x19E8(0x33D0)
> 	.dw	0xFFFF	; pc=0x19E9(0x33D2)
> 	.dw	0xFFFF	; pc=0x19EA(0x33D4)
> 	.dw	0xFFFF	; pc=0x19EB(0x33D6)
> 	.dw	0xFFFF	; pc=0x19EC(0x33D8)
> 	.dw	0xFFFF	; pc=0x19ED(0x33DA)
> 	.dw	0xFFFF	; pc=0x19EE(0x33DC)
> 	.dw	0xFFFF	; pc=0x19EF(0x33DE)
> 	.dw	0xFFFF	; pc=0x19F0(0x33E0)
> 	.dw	0xFFFF	; pc=0x19F1(0x33E2)
> 	.dw	0xFFFF	; pc=0x19F2(0x33E4)
> 	.dw	0xFFFF	; pc=0x19F3(0x33E6)
> 	.dw	0xFFFF	; pc=0x19F4(0x33E8)
> 	.dw	0xFFFF	; pc=0x19F5(0x33EA)
> 	.dw	0xFFFF	; pc=0x19F6(0x33EC)
> 	.dw	0xFFFF	; pc=0x19F7(0x33EE)
> 	.dw	0xFFFF	; pc=0x19F8(0x33F0)
> 	.dw	0xFFFF	; pc=0x19F9(0x33F2)
> 	.dw	0xFFFF	; pc=0x19FA(0x33F4)
> 	.dw	0xFFFF	; pc=0x19FB(0x33F6)
> 	.dw	0xFFFF	; pc=0x19FC(0x33F8)
> 	.dw	0xFFFF	; pc=0x19FD(0x33FA)
> 	.dw	0xFFFF	; pc=0x19FE(0x33FC)
> 	.dw	0xFFFF	; pc=0x19FF(0x33FE)
> 	.dw	0xFFFF	; pc=0x1A00(0x3400)
> 	.dw	0xFFFF	; pc=0x1A01(0x3402)
> 	.dw	0xFFFF	; pc=0x1A02(0x3404)
> 	.dw	0xFFFF	; pc=0x1A03(0x3406)
> 	.dw	0xFFFF	; pc=0x1A04(0x3408)
> 	.dw	0xFFFF	; pc=0x1A05(0x340A)
> 	.dw	0xFFFF	; pc=0x1A06(0x340C)
> 	.dw	0xFFFF	; pc=0x1A07(0x340E)
> 	.dw	0xFFFF	; pc=0x1A08(0x3410)
> 	.dw	0xFFFF	; pc=0x1A09(0x3412)
> 	.dw	0xFFFF	; pc=0x1A0A(0x3414)
> 	.dw	0xFFFF	; pc=0x1A0B(0x3416)
> 	.dw	0xFFFF	; pc=0x1A0C(0x3418)
> 	.dw	0xFFFF	; pc=0x1A0D(0x341A)
> 	.dw	0xFFFF	; pc=0x1A0E(0x341C)
> 	.dw	0xFFFF	; pc=0x1A0F(0x341E)
> 	.dw	0xFFFF	; pc=0x1A10(0x3420)
> 	.dw	0xFFFF	; pc=0x1A11(0x3422)
> 	.dw	0xFFFF	; pc=0x1A12(0x3424)
> 	.dw	0xFFFF	; pc=0x1A13(0x3426)
> 	.dw	0xFFFF	; pc=0x1A14(0x3428)
> 	.dw	0xFFFF	; pc=0x1A15(0x342A)
> 	.dw	0xFFFF	; pc=0x1A16(0x342C)
> 	.dw	0xFFFF	; pc=0x1A17(0x342E)
> 	.dw	0xFFFF	; pc=0x1A18(0x3430)
> 	.dw	0xFFFF	; pc=0x1A19(0x3432)
> 	.dw	0xFFFF	; pc=0x1A1A(0x3434)
> 	.dw	0xFFFF	; pc=0x1A1B(0x3436)
> 	.dw	0xFFFF	; pc=0x1A1C(0x3438)
> 	.dw	0xFFFF	; pc=0x1A1D(0x343A)
> 	.dw	0xFFFF	; pc=0x1A1E(0x343C)
> 	.dw	0xFFFF	; pc=0x1A1F(0x343E)
> 	.dw	0xFFFF	; pc=0x1A20(0x3440)
> 	.dw	0xFFFF	; pc=0x1A21(0x3442)
> 	.dw	0xFFFF	; pc=0x1A22(0x3444)
> 	.dw	0xFFFF	; pc=0x1A23(0x3446)
> 	.dw	0xFFFF	; pc=0x1A24(0x3448)
> 	.dw	0xFFFF	; pc=0x1A25(0x344A)
> 	.dw	0xFFFF	; pc=0x1A26(0x344C)
> 	.dw	0xFFFF	; pc=0x1A27(0x344E)
> 	.dw	0xFFFF	; pc=0x1A28(0x3450)
> 	.dw	0xFFFF	; pc=0x1A29(0x3452)
> 	.dw	0xFFFF	; pc=0x1A2A(0x3454)
> 	.dw	0xFFFF	; pc=0x1A2B(0x3456)
> 	.dw	0xFFFF	; pc=0x1A2C(0x3458)
> 	.dw	0xFFFF	; pc=0x1A2D(0x345A)
> 	.dw	0xFFFF	; pc=0x1A2E(0x345C)
> 	.dw	0xFFFF	; pc=0x1A2F(0x345E)
> 	.dw	0xFFFF	; pc=0x1A30(0x3460)
> 	.dw	0xFFFF	; pc=0x1A31(0x3462)
> 	.dw	0xFFFF	; pc=0x1A32(0x3464)
> 	.dw	0xFFFF	; pc=0x1A33(0x3466)
> 	.dw	0xFFFF	; pc=0x1A34(0x3468)
> 	.dw	0xFFFF	; pc=0x1A35(0x346A)
> 	.dw	0xFFFF	; pc=0x1A36(0x346C)
> 	.dw	0xFFFF	; pc=0x1A37(0x346E)
> 	.dw	0xFFFF	; pc=0x1A38(0x3470)
> 	.dw	0xFFFF	; pc=0x1A39(0x3472)
> 	.dw	0xFFFF	; pc=0x1A3A(0x3474)
> 	.dw	0xFFFF	; pc=0x1A3B(0x3476)
> 	.dw	0xFFFF	; pc=0x1A3C(0x3478)
> 	.dw	0xFFFF	; pc=0x1A3D(0x347A)
> 	.dw	0xFFFF	; pc=0x1A3E(0x347C)
> 	.dw	0xFFFF	; pc=0x1A3F(0x347E)
> 	.dw	0xFFFF	; pc=0x1A40(0x3480)
> 	.dw	0xFFFF	; pc=0x1A41(0x3482)
> 	.dw	0xFFFF	; pc=0x1A42(0x3484)
> 	.dw	0xFFFF	; pc=0x1A43(0x3486)
> 	.dw	0xFFFF	; pc=0x1A44(0x3488)
> 	.dw	0xFFFF	; pc=0x1A45(0x348A)
> 	.dw	0xFFFF	; pc=0x1A46(0x348C)
> 	.dw	0xFFFF	; pc=0x1A47(0x348E)
> 	.dw	0xFFFF	; pc=0x1A48(0x3490)
> 	.dw	0xFFFF	; pc=0x1A49(0x3492)
> 	.dw	0xFFFF	; pc=0x1A4A(0x3494)
> 	.dw	0xFFFF	; pc=0x1A4B(0x3496)
> 	.dw	0xFFFF	; pc=0x1A4C(0x3498)
> 	.dw	0xFFFF	; pc=0x1A4D(0x349A)
> 	.dw	0xFFFF	; pc=0x1A4E(0x349C)
> 	.dw	0xFFFF	; pc=0x1A4F(0x349E)
> 	.dw	0xFFFF	; pc=0x1A50(0x34A0)
> 	.dw	0xFFFF	; pc=0x1A51(0x34A2)
> 	.dw	0xFFFF	; pc=0x1A52(0x34A4)
> 	.dw	0xFFFF	; pc=0x1A53(0x34A6)
> 	.dw	0xFFFF	; pc=0x1A54(0x34A8)
> 	.dw	0xFFFF	; pc=0x1A55(0x34AA)
> 	.dw	0xFFFF	; pc=0x1A56(0x34AC)
> 	.dw	0xFFFF	; pc=0x1A57(0x34AE)
> 	.dw	0xFFFF	; pc=0x1A58(0x34B0)
> 	.dw	0xFFFF	; pc=0x1A59(0x34B2)
> 	.dw	0xFFFF	; pc=0x1A5A(0x34B4)
> 	.dw	0xFFFF	; pc=0x1A5B(0x34B6)
> 	.dw	0xFFFF	; pc=0x1A5C(0x34B8)
> 	.dw	0xFFFF	; pc=0x1A5D(0x34BA)
> 	.dw	0xFFFF	; pc=0x1A5E(0x34BC)
> 	.dw	0xFFFF	; pc=0x1A5F(0x34BE)
> 	.dw	0xFFFF	; pc=0x1A60(0x34C0)
> 	.dw	0xFFFF	; pc=0x1A61(0x34C2)
> 	.dw	0xFFFF	; pc=0x1A62(0x34C4)
> 	.dw	0xFFFF	; pc=0x1A63(0x34C6)
> 	.dw	0xFFFF	; pc=0x1A64(0x34C8)
> 	.dw	0xFFFF	; pc=0x1A65(0x34CA)
> 	.dw	0xFFFF	; pc=0x1A66(0x34CC)
> 	.dw	0xFFFF	; pc=0x1A67(0x34CE)
> 	.dw	0xFFFF	; pc=0x1A68(0x34D0)
> 	.dw	0xFFFF	; pc=0x1A69(0x34D2)
> 	.dw	0xFFFF	; pc=0x1A6A(0x34D4)
> 	.dw	0xFFFF	; pc=0x1A6B(0x34D6)
> 	.dw	0xFFFF	; pc=0x1A6C(0x34D8)
> 	.dw	0xFFFF	; pc=0x1A6D(0x34DA)
> 	.dw	0xFFFF	; pc=0x1A6E(0x34DC)
> 	.dw	0xFFFF	; pc=0x1A6F(0x34DE)
> 	.dw	0xFFFF	; pc=0x1A70(0x34E0)
> 	.dw	0xFFFF	; pc=0x1A71(0x34E2)
> 	.dw	0xFFFF	; pc=0x1A72(0x34E4)
> 	.dw	0xFFFF	; pc=0x1A73(0x34E6)
> 	.dw	0xFFFF	; pc=0x1A74(0x34E8)
> 	.dw	0xFFFF	; pc=0x1A75(0x34EA)
> 	.dw	0xFFFF	; pc=0x1A76(0x34EC)
> 	.dw	0xFFFF	; pc=0x1A77(0x34EE)
> 	.dw	0xFFFF	; pc=0x1A78(0x34F0)
> 	.dw	0xFFFF	; pc=0x1A79(0x34F2)
> 	.dw	0xFFFF	; pc=0x1A7A(0x34F4)
> 	.dw	0xFFFF	; pc=0x1A7B(0x34F6)
> 	.dw	0xFFFF	; pc=0x1A7C(0x34F8)
> 	.dw	0xFFFF	; pc=0x1A7D(0x34FA)
> 	.dw	0xFFFF	; pc=0x1A7E(0x34FC)
> 	.dw	0xFFFF	; pc=0x1A7F(0x34FE)
> 	.dw	0xFFFF	; pc=0x1A80(0x3500)
> 	.dw	0xFFFF	; pc=0x1A81(0x3502)
> 	.dw	0xFFFF	; pc=0x1A82(0x3504)
> 	.dw	0xFFFF	; pc=0x1A83(0x3506)
> 	.dw	0xFFFF	; pc=0x1A84(0x3508)
> 	.dw	0xFFFF	; pc=0x1A85(0x350A)
> 	.dw	0xFFFF	; pc=0x1A86(0x350C)
> 	.dw	0xFFFF	; pc=0x1A87(0x350E)
> 	.dw	0xFFFF	; pc=0x1A88(0x3510)
> 	.dw	0xFFFF	; pc=0x1A89(0x3512)
> 	.dw	0xFFFF	; pc=0x1A8A(0x3514)
> 	.dw	0xFFFF	; pc=0x1A8B(0x3516)
> 	.dw	0xFFFF	; pc=0x1A8C(0x3518)
> 	.dw	0xFFFF	; pc=0x1A8D(0x351A)
> 	.dw	0xFFFF	; pc=0x1A8E(0x351C)
> 	.dw	0xFFFF	; pc=0x1A8F(0x351E)
> 	.dw	0xFFFF	; pc=0x1A90(0x3520)
> 	.dw	0xFFFF	; pc=0x1A91(0x3522)
> 	.dw	0xFFFF	; pc=0x1A92(0x3524)
> 	.dw	0xFFFF	; pc=0x1A93(0x3526)
> 	.dw	0xFFFF	; pc=0x1A94(0x3528)
> 	.dw	0xFFFF	; pc=0x1A95(0x352A)
> 	.dw	0xFFFF	; pc=0x1A96(0x352C)
> 	.dw	0xFFFF	; pc=0x1A97(0x352E)
> 	.dw	0xFFFF	; pc=0x1A98(0x3530)
> 	.dw	0xFFFF	; pc=0x1A99(0x3532)
> 	.dw	0xFFFF	; pc=0x1A9A(0x3534)
> 	.dw	0xFFFF	; pc=0x1A9B(0x3536)
> 	.dw	0xFFFF	; pc=0x1A9C(0x3538)
> 	.dw	0xFFFF	; pc=0x1A9D(0x353A)
> 	.dw	0xFFFF	; pc=0x1A9E(0x353C)
> 	.dw	0xFFFF	; pc=0x1A9F(0x353E)
> 	.dw	0xFFFF	; pc=0x1AA0(0x3540)
> 	.dw	0xFFFF	; pc=0x1AA1(0x3542)
> 	.dw	0xFFFF	; pc=0x1AA2(0x3544)
> 	.dw	0xFFFF	; pc=0x1AA3(0x3546)
> 	.dw	0xFFFF	; pc=0x1AA4(0x3548)
> 	.dw	0xFFFF	; pc=0x1AA5(0x354A)
> 	.dw	0xFFFF	; pc=0x1AA6(0x354C)
> 	.dw	0xFFFF	; pc=0x1AA7(0x354E)
> 	.dw	0xFFFF	; pc=0x1AA8(0x3550)
> 	.dw	0xFFFF	; pc=0x1AA9(0x3552)
> 	.dw	0xFFFF	; pc=0x1AAA(0x3554)
> 	.dw	0xFFFF	; pc=0x1AAB(0x3556)
> 	.dw	0xFFFF	; pc=0x1AAC(0x3558)
> 	.dw	0xFFFF	; pc=0x1AAD(0x355A)
> 	.dw	0xFFFF	; pc=0x1AAE(0x355C)
> 	.dw	0xFFFF	; pc=0x1AAF(0x355E)
> 	.dw	0xFFFF	; pc=0x1AB0(0x3560)
> 	.dw	0xFFFF	; pc=0x1AB1(0x3562)
> 	.dw	0xFFFF	; pc=0x1AB2(0x3564)
> 	.dw	0xFFFF	; pc=0x1AB3(0x3566)
> 	.dw	0xFFFF	; pc=0x1AB4(0x3568)
> 	.dw	0xFFFF	; pc=0x1AB5(0x356A)
> 	.dw	0xFFFF	; pc=0x1AB6(0x356C)
> 	.dw	0xFFFF	; pc=0x1AB7(0x356E)
> 	.dw	0xFFFF	; pc=0x1AB8(0x3570)
> 	.dw	0xFFFF	; pc=0x1AB9(0x3572)
> 	.dw	0xFFFF	; pc=0x1ABA(0x3574)
> 	.dw	0xFFFF	; pc=0x1ABB(0x3576)
> 	.dw	0xFFFF	; pc=0x1ABC(0x3578)
> 	.dw	0xFFFF	; pc=0x1ABD(0x357A)
> 	.dw	0xFFFF	; pc=0x1ABE(0x357C)
> 	.dw	0xFFFF	; pc=0x1ABF(0x357E)
> 	.dw	0xFFFF	; pc=0x1AC0(0x3580)
> 	.dw	0xFFFF	; pc=0x1AC1(0x3582)
> 	.dw	0xFFFF	; pc=0x1AC2(0x3584)
> 	.dw	0xFFFF	; pc=0x1AC3(0x3586)
> 	.dw	0xFFFF	; pc=0x1AC4(0x3588)
> 	.dw	0xFFFF	; pc=0x1AC5(0x358A)
> 	.dw	0xFFFF	; pc=0x1AC6(0x358C)
> 	.dw	0xFFFF	; pc=0x1AC7(0x358E)
> 	.dw	0xFFFF	; pc=0x1AC8(0x3590)
> 	.dw	0xFFFF	; pc=0x1AC9(0x3592)
> 	.dw	0xFFFF	; pc=0x1ACA(0x3594)
> 	.dw	0xFFFF	; pc=0x1ACB(0x3596)
> 	.dw	0xFFFF	; pc=0x1ACC(0x3598)
> 	.dw	0xFFFF	; pc=0x1ACD(0x359A)
> 	.dw	0xFFFF	; pc=0x1ACE(0x359C)
> 	.dw	0xFFFF	; pc=0x1ACF(0x359E)
> 	.dw	0xFFFF	; pc=0x1AD0(0x35A0)
> 	.dw	0xFFFF	; pc=0x1AD1(0x35A2)
> 	.dw	0xFFFF	; pc=0x1AD2(0x35A4)
> 	.dw	0xFFFF	; pc=0x1AD3(0x35A6)
> 	.dw	0xFFFF	; pc=0x1AD4(0x35A8)
> 	.dw	0xFFFF	; pc=0x1AD5(0x35AA)
> 	.dw	0xFFFF	; pc=0x1AD6(0x35AC)
> 	.dw	0xFFFF	; pc=0x1AD7(0x35AE)
> 	.dw	0xFFFF	; pc=0x1AD8(0x35B0)
> 	.dw	0xFFFF	; pc=0x1AD9(0x35B2)
> 	.dw	0xFFFF	; pc=0x1ADA(0x35B4)
> 	.dw	0xFFFF	; pc=0x1ADB(0x35B6)
> 	.dw	0xFFFF	; pc=0x1ADC(0x35B8)
> 	.dw	0xFFFF	; pc=0x1ADD(0x35BA)
> 	.dw	0xFFFF	; pc=0x1ADE(0x35BC)
> 	.dw	0xFFFF	; pc=0x1ADF(0x35BE)
> 	.dw	0xFFFF	; pc=0x1AE0(0x35C0)
> 	.dw	0xFFFF	; pc=0x1AE1(0x35C2)
> 	.dw	0xFFFF	; pc=0x1AE2(0x35C4)
> 	.dw	0xFFFF	; pc=0x1AE3(0x35C6)
> 	.dw	0xFFFF	; pc=0x1AE4(0x35C8)
> 	.dw	0xFFFF	; pc=0x1AE5(0x35CA)
> 	.dw	0xFFFF	; pc=0x1AE6(0x35CC)
> 	.dw	0xFFFF	; pc=0x1AE7(0x35CE)
> 	.dw	0xFFFF	; pc=0x1AE8(0x35D0)
> 	.dw	0xFFFF	; pc=0x1AE9(0x35D2)
> 	.dw	0xFFFF	; pc=0x1AEA(0x35D4)
> 	.dw	0xFFFF	; pc=0x1AEB(0x35D6)
> 	.dw	0xFFFF	; pc=0x1AEC(0x35D8)
> 	.dw	0xFFFF	; pc=0x1AED(0x35DA)
> 	.dw	0xFFFF	; pc=0x1AEE(0x35DC)
> 	.dw	0xFFFF	; pc=0x1AEF(0x35DE)
> 	.dw	0xFFFF	; pc=0x1AF0(0x35E0)
> 	.dw	0xFFFF	; pc=0x1AF1(0x35E2)
> 	.dw	0xFFFF	; pc=0x1AF2(0x35E4)
> 	.dw	0xFFFF	; pc=0x1AF3(0x35E6)
> 	.dw	0xFFFF	; pc=0x1AF4(0x35E8)
> 	.dw	0xFFFF	; pc=0x1AF5(0x35EA)
> 	.dw	0xFFFF	; pc=0x1AF6(0x35EC)
> 	.dw	0xFFFF	; pc=0x1AF7(0x35EE)
> 	.dw	0xFFFF	; pc=0x1AF8(0x35F0)
> 	.dw	0xFFFF	; pc=0x1AF9(0x35F2)
> 	.dw	0xFFFF	; pc=0x1AFA(0x35F4)
> 	.dw	0xFFFF	; pc=0x1AFB(0x35F6)
> 	.dw	0xFFFF	; pc=0x1AFC(0x35F8)
> 	.dw	0xFFFF	; pc=0x1AFD(0x35FA)
> 	.dw	0xFFFF	; pc=0x1AFE(0x35FC)
> 	.dw	0xFFFF	; pc=0x1AFF(0x35FE)
> 	.dw	0xFFFF	; pc=0x1B00(0x3600)
> 	.dw	0xFFFF	; pc=0x1B01(0x3602)
> 	.dw	0xFFFF	; pc=0x1B02(0x3604)
> 	.dw	0xFFFF	; pc=0x1B03(0x3606)
> 	.dw	0xFFFF	; pc=0x1B04(0x3608)
> 	.dw	0xFFFF	; pc=0x1B05(0x360A)
> 	.dw	0xFFFF	; pc=0x1B06(0x360C)
> 	.dw	0xFFFF	; pc=0x1B07(0x360E)
> 	.dw	0xFFFF	; pc=0x1B08(0x3610)
> 	.dw	0xFFFF	; pc=0x1B09(0x3612)
> 	.dw	0xFFFF	; pc=0x1B0A(0x3614)
> 	.dw	0xFFFF	; pc=0x1B0B(0x3616)
> 	.dw	0xFFFF	; pc=0x1B0C(0x3618)
> 	.dw	0xFFFF	; pc=0x1B0D(0x361A)
> 	.dw	0xFFFF	; pc=0x1B0E(0x361C)
> 	.dw	0xFFFF	; pc=0x1B0F(0x361E)
> 	.dw	0xFFFF	; pc=0x1B10(0x3620)
> 	.dw	0xFFFF	; pc=0x1B11(0x3622)
> 	.dw	0xFFFF	; pc=0x1B12(0x3624)
> 	.dw	0xFFFF	; pc=0x1B13(0x3626)
> 	.dw	0xFFFF	; pc=0x1B14(0x3628)
> 	.dw	0xFFFF	; pc=0x1B15(0x362A)
> 	.dw	0xFFFF	; pc=0x1B16(0x362C)
> 	.dw	0xFFFF	; pc=0x1B17(0x362E)
> 	.dw	0xFFFF	; pc=0x1B18(0x3630)
> 	.dw	0xFFFF	; pc=0x1B19(0x3632)
> 	.dw	0xFFFF	; pc=0x1B1A(0x3634)
> 	.dw	0xFFFF	; pc=0x1B1B(0x3636)
> 	.dw	0xFFFF	; pc=0x1B1C(0x3638)
> 	.dw	0xFFFF	; pc=0x1B1D(0x363A)
> 	.dw	0xFFFF	; pc=0x1B1E(0x363C)
> 	.dw	0xFFFF	; pc=0x1B1F(0x363E)
> 	.dw	0xFFFF	; pc=0x1B20(0x3640)
> 	.dw	0xFFFF	; pc=0x1B21(0x3642)
> 	.dw	0xFFFF	; pc=0x1B22(0x3644)
> 	.dw	0xFFFF	; pc=0x1B23(0x3646)
> 	.dw	0xFFFF	; pc=0x1B24(0x3648)
> 	.dw	0xFFFF	; pc=0x1B25(0x364A)
> 	.dw	0xFFFF	; pc=0x1B26(0x364C)
> 	.dw	0xFFFF	; pc=0x1B27(0x364E)
> 	.dw	0xFFFF	; pc=0x1B28(0x3650)
> 	.dw	0xFFFF	; pc=0x1B29(0x3652)
> 	.dw	0xFFFF	; pc=0x1B2A(0x3654)
> 	.dw	0xFFFF	; pc=0x1B2B(0x3656)
> 	.dw	0xFFFF	; pc=0x1B2C(0x3658)
> 	.dw	0xFFFF	; pc=0x1B2D(0x365A)
> 	.dw	0xFFFF	; pc=0x1B2E(0x365C)
> 	.dw	0xFFFF	; pc=0x1B2F(0x365E)
> 	.dw	0xFFFF	; pc=0x1B30(0x3660)
> 	.dw	0xFFFF	; pc=0x1B31(0x3662)
> 	.dw	0xFFFF	; pc=0x1B32(0x3664)
> 	.dw	0xFFFF	; pc=0x1B33(0x3666)
> 	.dw	0xFFFF	; pc=0x1B34(0x3668)
> 	.dw	0xFFFF	; pc=0x1B35(0x366A)
> 	.dw	0xFFFF	; pc=0x1B36(0x366C)
> 	.dw	0xFFFF	; pc=0x1B37(0x366E)
> 	.dw	0xFFFF	; pc=0x1B38(0x3670)
> 	.dw	0xFFFF	; pc=0x1B39(0x3672)
> 	.dw	0xFFFF	; pc=0x1B3A(0x3674)
> 	.dw	0xFFFF	; pc=0x1B3B(0x3676)
> 	.dw	0xFFFF	; pc=0x1B3C(0x3678)
> 	.dw	0xFFFF	; pc=0x1B3D(0x367A)
> 	.dw	0xFFFF	; pc=0x1B3E(0x367C)
> 	.dw	0xFFFF	; pc=0x1B3F(0x367E)
> 	.dw	0xFFFF	; pc=0x1B40(0x3680)
> 	.dw	0xFFFF	; pc=0x1B41(0x3682)
> 	.dw	0xFFFF	; pc=0x1B42(0x3684)
> 	.dw	0xFFFF	; pc=0x1B43(0x3686)
> 	.dw	0xFFFF	; pc=0x1B44(0x3688)
> 	.dw	0xFFFF	; pc=0x1B45(0x368A)
> 	.dw	0xFFFF	; pc=0x1B46(0x368C)
> 	.dw	0xFFFF	; pc=0x1B47(0x368E)
> 	.dw	0xFFFF	; pc=0x1B48(0x3690)
> 	.dw	0xFFFF	; pc=0x1B49(0x3692)
> 	.dw	0xFFFF	; pc=0x1B4A(0x3694)
> 	.dw	0xFFFF	; pc=0x1B4B(0x3696)
> 	.dw	0xFFFF	; pc=0x1B4C(0x3698)
> 	.dw	0xFFFF	; pc=0x1B4D(0x369A)
> 	.dw	0xFFFF	; pc=0x1B4E(0x369C)
> 	.dw	0xFFFF	; pc=0x1B4F(0x369E)
> 	.dw	0xFFFF	; pc=0x1B50(0x36A0)
> 	.dw	0xFFFF	; pc=0x1B51(0x36A2)
> 	.dw	0xFFFF	; pc=0x1B52(0x36A4)
> 	.dw	0xFFFF	; pc=0x1B53(0x36A6)
> 	.dw	0xFFFF	; pc=0x1B54(0x36A8)
> 	.dw	0xFFFF	; pc=0x1B55(0x36AA)
> 	.dw	0xFFFF	; pc=0x1B56(0x36AC)
> 	.dw	0xFFFF	; pc=0x1B57(0x36AE)
> 	.dw	0xFFFF	; pc=0x1B58(0x36B0)
> 	.dw	0xFFFF	; pc=0x1B59(0x36B2)
> 	.dw	0xFFFF	; pc=0x1B5A(0x36B4)
> 	.dw	0xFFFF	; pc=0x1B5B(0x36B6)
> 	.dw	0xFFFF	; pc=0x1B5C(0x36B8)
> 	.dw	0xFFFF	; pc=0x1B5D(0x36BA)
> 	.dw	0xFFFF	; pc=0x1B5E(0x36BC)
> 	.dw	0xFFFF	; pc=0x1B5F(0x36BE)
> 	.dw	0xFFFF	; pc=0x1B60(0x36C0)
> 	.dw	0xFFFF	; pc=0x1B61(0x36C2)
> 	.dw	0xFFFF	; pc=0x1B62(0x36C4)
> 	.dw	0xFFFF	; pc=0x1B63(0x36C6)
> 	.dw	0xFFFF	; pc=0x1B64(0x36C8)
> 	.dw	0xFFFF	; pc=0x1B65(0x36CA)
> 	.dw	0xFFFF	; pc=0x1B66(0x36CC)
> 	.dw	0xFFFF	; pc=0x1B67(0x36CE)
> 	.dw	0xFFFF	; pc=0x1B68(0x36D0)
> 	.dw	0xFFFF	; pc=0x1B69(0x36D2)
> 	.dw	0xFFFF	; pc=0x1B6A(0x36D4)
> 	.dw	0xFFFF	; pc=0x1B6B(0x36D6)
> 	.dw	0xFFFF	; pc=0x1B6C(0x36D8)
> 	.dw	0xFFFF	; pc=0x1B6D(0x36DA)
> 	.dw	0xFFFF	; pc=0x1B6E(0x36DC)
> 	.dw	0xFFFF	; pc=0x1B6F(0x36DE)
> 	.dw	0xFFFF	; pc=0x1B70(0x36E0)
> 	.dw	0xFFFF	; pc=0x1B71(0x36E2)
> 	.dw	0xFFFF	; pc=0x1B72(0x36E4)
> 	.dw	0xFFFF	; pc=0x1B73(0x36E6)
> 	.dw	0xFFFF	; pc=0x1B74(0x36E8)
> 	.dw	0xFFFF	; pc=0x1B75(0x36EA)
> 	.dw	0xFFFF	; pc=0x1B76(0x36EC)
> 	.dw	0xFFFF	; pc=0x1B77(0x36EE)
> 	.dw	0xFFFF	; pc=0x1B78(0x36F0)
> 	.dw	0xFFFF	; pc=0x1B79(0x36F2)
> 	.dw	0xFFFF	; pc=0x1B7A(0x36F4)
> 	.dw	0xFFFF	; pc=0x1B7B(0x36F6)
> 	.dw	0xFFFF	; pc=0x1B7C(0x36F8)
> 	.dw	0xFFFF	; pc=0x1B7D(0x36FA)
> 	.dw	0xFFFF	; pc=0x1B7E(0x36FC)
> 	.dw	0xFFFF	; pc=0x1B7F(0x36FE)
> 	.dw	0xFFFF	; pc=0x1B80(0x3700)
> 	.dw	0xFFFF	; pc=0x1B81(0x3702)
> 	.dw	0xFFFF	; pc=0x1B82(0x3704)
> 	.dw	0xFFFF	; pc=0x1B83(0x3706)
> 	.dw	0xFFFF	; pc=0x1B84(0x3708)
> 	.dw	0xFFFF	; pc=0x1B85(0x370A)
> 	.dw	0xFFFF	; pc=0x1B86(0x370C)
> 	.dw	0xFFFF	; pc=0x1B87(0x370E)
> 	.dw	0xFFFF	; pc=0x1B88(0x3710)
> 	.dw	0xFFFF	; pc=0x1B89(0x3712)
> 	.dw	0xFFFF	; pc=0x1B8A(0x3714)
> 	.dw	0xFFFF	; pc=0x1B8B(0x3716)
> 	.dw	0xFFFF	; pc=0x1B8C(0x3718)
> 	.dw	0xFFFF	; pc=0x1B8D(0x371A)
> 	.dw	0xFFFF	; pc=0x1B8E(0x371C)
> 	.dw	0xFFFF	; pc=0x1B8F(0x371E)
> 	.dw	0xFFFF	; pc=0x1B90(0x3720)
> 	.dw	0xFFFF	; pc=0x1B91(0x3722)
> 	.dw	0xFFFF	; pc=0x1B92(0x3724)
> 	.dw	0xFFFF	; pc=0x1B93(0x3726)
> 	.dw	0xFFFF	; pc=0x1B94(0x3728)
> 	.dw	0xFFFF	; pc=0x1B95(0x372A)
> 	.dw	0xFFFF	; pc=0x1B96(0x372C)
> 	.dw	0xFFFF	; pc=0x1B97(0x372E)
> 	.dw	0xFFFF	; pc=0x1B98(0x3730)
> 	.dw	0xFFFF	; pc=0x1B99(0x3732)
> 	.dw	0xFFFF	; pc=0x1B9A(0x3734)
> 	.dw	0xFFFF	; pc=0x1B9B(0x3736)
> 	.dw	0xFFFF	; pc=0x1B9C(0x3738)
> 	.dw	0xFFFF	; pc=0x1B9D(0x373A)
> 	.dw	0xFFFF	; pc=0x1B9E(0x373C)
> 	.dw	0xFFFF	; pc=0x1B9F(0x373E)
> 	.dw	0xFFFF	; pc=0x1BA0(0x3740)
> 	.dw	0xFFFF	; pc=0x1BA1(0x3742)
> 	.dw	0xFFFF	; pc=0x1BA2(0x3744)
> 	.dw	0xFFFF	; pc=0x1BA3(0x3746)
> 	.dw	0xFFFF	; pc=0x1BA4(0x3748)
> 	.dw	0xFFFF	; pc=0x1BA5(0x374A)
> 	.dw	0xFFFF	; pc=0x1BA6(0x374C)
> 	.dw	0xFFFF	; pc=0x1BA7(0x374E)
> 	.dw	0xFFFF	; pc=0x1BA8(0x3750)
> 	.dw	0xFFFF	; pc=0x1BA9(0x3752)
> 	.dw	0xFFFF	; pc=0x1BAA(0x3754)
> 	.dw	0xFFFF	; pc=0x1BAB(0x3756)
> 	.dw	0xFFFF	; pc=0x1BAC(0x3758)
> 	.dw	0xFFFF	; pc=0x1BAD(0x375A)
> 	.dw	0xFFFF	; pc=0x1BAE(0x375C)
> 	.dw	0xFFFF	; pc=0x1BAF(0x375E)
> 	.dw	0xFFFF	; pc=0x1BB0(0x3760)
> 	.dw	0xFFFF	; pc=0x1BB1(0x3762)
> 	.dw	0xFFFF	; pc=0x1BB2(0x3764)
> 	.dw	0xFFFF	; pc=0x1BB3(0x3766)
> 	.dw	0xFFFF	; pc=0x1BB4(0x3768)
> 	.dw	0xFFFF	; pc=0x1BB5(0x376A)
> 	.dw	0xFFFF	; pc=0x1BB6(0x376C)
> 	.dw	0xFFFF	; pc=0x1BB7(0x376E)
> 	.dw	0xFFFF	; pc=0x1BB8(0x3770)
> 	.dw	0xFFFF	; pc=0x1BB9(0x3772)
> 	.dw	0xFFFF	; pc=0x1BBA(0x3774)
> 	.dw	0xFFFF	; pc=0x1BBB(0x3776)
> 	.dw	0xFFFF	; pc=0x1BBC(0x3778)
> 	.dw	0xFFFF	; pc=0x1BBD(0x377A)
> 	.dw	0xFFFF	; pc=0x1BBE(0x377C)
> 	.dw	0xFFFF	; pc=0x1BBF(0x377E)
> 	.dw	0xFFFF	; pc=0x1BC0(0x3780)
> 	.dw	0xFFFF	; pc=0x1BC1(0x3782)
> 	.dw	0xFFFF	; pc=0x1BC2(0x3784)
> 	.dw	0xFFFF	; pc=0x1BC3(0x3786)
> 	.dw	0xFFFF	; pc=0x1BC4(0x3788)
> 	.dw	0xFFFF	; pc=0x1BC5(0x378A)
> 	.dw	0xFFFF	; pc=0x1BC6(0x378C)
> 	.dw	0xFFFF	; pc=0x1BC7(0x378E)
> 	.dw	0xFFFF	; pc=0x1BC8(0x3790)
> 	.dw	0xFFFF	; pc=0x1BC9(0x3792)
> 	.dw	0xFFFF	; pc=0x1BCA(0x3794)
> 	.dw	0xFFFF	; pc=0x1BCB(0x3796)
> 	.dw	0xFFFF	; pc=0x1BCC(0x3798)
> 	.dw	0xFFFF	; pc=0x1BCD(0x379A)
> 	.dw	0xFFFF	; pc=0x1BCE(0x379C)
> 	.dw	0xFFFF	; pc=0x1BCF(0x379E)
> 	.dw	0xFFFF	; pc=0x1BD0(0x37A0)
> 	.dw	0xFFFF	; pc=0x1BD1(0x37A2)
> 	.dw	0xFFFF	; pc=0x1BD2(0x37A4)
> 	.dw	0xFFFF	; pc=0x1BD3(0x37A6)
> 	.dw	0xFFFF	; pc=0x1BD4(0x37A8)
> 	.dw	0xFFFF	; pc=0x1BD5(0x37AA)
> 	.dw	0xFFFF	; pc=0x1BD6(0x37AC)
> 	.dw	0xFFFF	; pc=0x1BD7(0x37AE)
> 	.dw	0xFFFF	; pc=0x1BD8(0x37B0)
> 	.dw	0xFFFF	; pc=0x1BD9(0x37B2)
> 	.dw	0xFFFF	; pc=0x1BDA(0x37B4)
> 	.dw	0xFFFF	; pc=0x1BDB(0x37B6)
> 	.dw	0xFFFF	; pc=0x1BDC(0x37B8)
> 	.dw	0xFFFF	; pc=0x1BDD(0x37BA)
> 	.dw	0xFFFF	; pc=0x1BDE(0x37BC)
> 	.dw	0xFFFF	; pc=0x1BDF(0x37BE)
> 	.dw	0xFFFF	; pc=0x1BE0(0x37C0)
> 	.dw	0xFFFF	; pc=0x1BE1(0x37C2)
> 	.dw	0xFFFF	; pc=0x1BE2(0x37C4)
> 	.dw	0xFFFF	; pc=0x1BE3(0x37C6)
> 	.dw	0xFFFF	; pc=0x1BE4(0x37C8)
> 	.dw	0xFFFF	; pc=0x1BE5(0x37CA)
> 	.dw	0xFFFF	; pc=0x1BE6(0x37CC)
> 	.dw	0xFFFF	; pc=0x1BE7(0x37CE)
> 	.dw	0xFFFF	; pc=0x1BE8(0x37D0)
> 	.dw	0xFFFF	; pc=0x1BE9(0x37D2)
> 	.dw	0xFFFF	; pc=0x1BEA(0x37D4)
> 	.dw	0xFFFF	; pc=0x1BEB(0x37D6)
> 	.dw	0xFFFF	; pc=0x1BEC(0x37D8)
> 	.dw	0xFFFF	; pc=0x1BED(0x37DA)
> 	.dw	0xFFFF	; pc=0x1BEE(0x37DC)
> 	.dw	0xFFFF	; pc=0x1BEF(0x37DE)
> 	.dw	0xFFFF	; pc=0x1BF0(0x37E0)
> 	.dw	0xFFFF	; pc=0x1BF1(0x37E2)
> 	.dw	0xFFFF	; pc=0x1BF2(0x37E4)
> 	.dw	0xFFFF	; pc=0x1BF3(0x37E6)
> 	.dw	0xFFFF	; pc=0x1BF4(0x37E8)
> 	.dw	0xFFFF	; pc=0x1BF5(0x37EA)
> 	.dw	0xFFFF	; pc=0x1BF6(0x37EC)
> 	.dw	0xFFFF	; pc=0x1BF7(0x37EE)
> 	.dw	0xFFFF	; pc=0x1BF8(0x37F0)
> 	.dw	0xFFFF	; pc=0x1BF9(0x37F2)
> 	.dw	0xFFFF	; pc=0x1BFA(0x37F4)
> 	.dw	0xFFFF	; pc=0x1BFB(0x37F6)
> 	.dw	0xFFFF	; pc=0x1BFC(0x37F8)
> 	.dw	0xFFFF	; pc=0x1BFD(0x37FA)
> 	.dw	0xFFFF	; pc=0x1BFE(0x37FC)
> 	.dw	0xFFFF	; pc=0x1BFF(0x37FE)
> 	ldi	r19,kFF
> 	out	SPL,r19
> 	ldi	r19,k03
> 	out	SPH,r19
> 	ldi	r19,k18
> 	out	UCSRA,r19
> 	ldi	r19,k17
> 	out	UBBR,r19
> L1C08:
> 	rcall	L1CDF
> 	mov	r26,r19
> 	cpi	r26,k70
> 	brne	L1C0F
> 	ldi	r19,k53
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1C0F:
> 	cpi	r26,k61
> 	brne	L1C14
> 	ldi	r19,k59
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1C14:
> 	cpi	r26,k53
> 	brne	L1C25
> 	ldi	r19,k41
> 	rcall	L1CDB
> 	ldi	r19,k56
> 	rcall	L1CDB
> 	ldi	r19,k52
> 	rcall	L1CDB
> 	ldi	r19,k42
> 	rcall	L1CDB
> 	ldi	r19,k4F
> 	rcall	L1CDB
> 	ldi	r19,k4F
> 	rcall	L1CDB
> 	ldi	r19,k54
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1C25:
> 	cpi	r26,k74
> 	brne	L1C2C
> 	ldi	r19,k64
> 	rcall	L1CDB
> 	ldi	r19,k00
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1C2C:
> 	cpi	r26,k56
> 	brne	L1C33
> 	ldi	r19,k32
> 	rcall	L1CDB
> 	ldi	r19,k31
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1C33:
> 	cpi	r26,k54
> 	brne	L1C36
> 	rjmp	L1CD0
> L1C36:
> 	cpi	r26,k41
> 	brne	L1C41
> 	rcall	L1CDF
> 	mov	r31,r19
> 	rcall	L1CDF
> 	mov	r30,r19
> 	lsl	r30
> 	rol	r31
> 	ldi	r19,k0D
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1C41:
> 	cpi	r26,k50
> 	brne	L1C46
> 	ldi	r19,k0D
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1C46:
> 	cpi	r26,k4C
> 	brne	L1C4B
> 	ldi	r19,k0D
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1C4B:
> 	cpi	r26,k73
> 	brne	L1C54
> 	ldi	r19,k1E
> 	rcall	L1CDB
> 	ldi	r19,k94
> 	rcall	L1CDB
> 	ldi	r19,k02
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1C54:
> 	cpi	r26,k64
> 	brne	L1C5F
> 	out	EEARL,r30
> 	out	EEARH,r31
> 	sbi	EECR,b0
> 	in	r0,EEDR
> 	subi	r30,kFF
> 	sbci	r31,kFF
> 	mov	r19,r0
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1C5F:
> 	cpi	r26,k52
> 	brne	L1C6D
> 	lpm
> 	mov	r1,r0
> 	subi	r30,kFF
> 	sbci	r31,kFF
> 	lpm
> 	subi	r30,kFF
> 	sbci	r31,kFF
> 	mov	r19,r0
> 	rcall	L1CDB
> 	mov	r19,r1
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1C6D:
> 	cpi	r26,k63
> 	brne	L1C96
> 	rcall	L1CDF
> 	mov	r15,r19
> 	mov	r16,r30
> 	andi	r16,k7F
> 	tst	r16
> 	brne	L1C92
> 	ldi	r19,k03
> 	out	SPMCR,r19
> 	spm
> 	.dw	0xFFFF	; pc=0x1C78(0x38F0)
> 	nop
> 	ldi	r19,kFF
> 	mov	r0,r19
> 	mov	r1,r19
> 	push	r31
> 	push	r30
> 	ldi	r17,k00
> L1C80:
> 	ldi	r19,k01
> 	out	SPMCR,r19
> 	spm
> 	.dw	0xFFFF	; pc=0x1C83(0x3906)
> 	nop
> 	adiw	r30,k02
> 	cpi	r17,k3F
> 	breq	L1C8A
> 	inc	r17
> 	rjmp	L1C80
> L1C8A:
> 	pop	r30
> 	pop	r31
> L1C8C:
> 	in	r19,SPMCR
> 	sbrc	r19,b0
> 	rjmp	L1C8C
> 	ldi	r30,k1E
> 	ldi	r31,k00
> 	rcall	L1CE3
> L1C92:
> 	mov	r0,r15
> 	ldi	r19,k0D
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1C96:
> 	cpi	r26,k43
> 	brne	L1CA3
> 	rcall	L1CDF
> 	mov	r1,r19
> 	ldi	r19,k01
> 	out	SPMCR,r19
> 	spm
> 	.dw	0xFFFF	; pc=0x1C9D(0x393A)
> 	nop
> 	adiw	r30,k02
> 	ldi	r19,k0D
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1CA3:
> 	cpi	r26,k6D
> 	brne	L1CB0
> 	ldi	r19,k05
> 	out	SPMCR,r19
> 	spm
> 	.dw	0xFFFF	; pc=0x1CA8(0x3950)
> 	nop
> L1CAA:
> 	in	r19,SPMCR
> 	sbrc	r19,b0
> 	rjmp	L1CAA
> 	ldi	r19,k0D
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1CB0:
> 	cpi	r26,k65
> 	brne	L1CB5
> 	ldi	r19,k0D
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1CB5:
> 	cpi	r26,k55
> 	brne	L1CCB
> 	ldi	r30,k00
> 	ldi	r31,k00
> 	ldi	r16,k00
> L1CBA:
> 	ldi	r19,k03
> 	out	SPMCR,r19
> 	spm
> 	.dw	0xFFFF	; pc=0x1CBD(0x397A)
> 	nop
> 	ldi	r30,k10
> 	ldi	r31,k00
> 	rcall	L1CE3
> 	subi	r30,k80
> 	sbci	r31,kFF
> 	cpi	r16,k70
> 	breq	L1CC8
> 	inc	r16
> 	rjmp	L1CBA
> L1CC8:
> 	ldi	r19,k0D
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1CCB:
> 	cpi	r26,k78
> 	brne	L1CCE
> 	rjmp	L1CD0
> L1CCE:
> 	cpi	r26,k79
> 	brne	L1CD4
> L1CD0:
> 	rcall	L1CDF
> 	ldi	r19,k0D
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1CD4:
> 	cpi	r26,k1B
> 	brne	L1CD7
> 	rjmp	L1CDA
> L1CD7:
> 	ldi	r19,k3F
> 	rcall	L1CDB
> 	rjmp	L1CDA
> L1CDA:
> 	rjmp	L1C08
> L1CDB:
> 	sbis	UCSRB,b5
> 	rjmp	L1CDB
> 	out	UDR,r19
> 	ret
> ; pc=0x1CDF(0x39BE)
> ;
> L1CDF:
> 	sbis	UCSRB,b7
> 	rjmp	L1CDF
> 	in	r19,UDR
> 	ret
> ; pc=0x1CE3(0x39C6)
> ;
> L1CE3:
> 	push	r31
> 	push	r30
> 	ldi	r30,k33
> 	ldi	r31,k07
> L1CE7:
> 	sbiw	r30,k01
> 	brne	L1CE7
> 	pop	r30
> 	pop	r31
> 	subi	r30,k01
> 	sbci	r31,k00
> 	brne	L1CE3
> 	ret
> ; pc=0x1CEF(0x39DE)
> ;
> 	.dw	0xFFFF	; pc=0x1CEF(0x39DE)
> 	.dw	0xFFFF	; pc=0x1CF0(0x39E0)
> 	.dw	0xFFFF	; pc=0x1CF1(0x39E2)
> 	.dw	0xFFFF	; pc=0x1CF2(0x39E4)
> 	.dw	0xFFFF	; pc=0x1CF3(0x39E6)
> 	.dw	0xFFFF	; pc=0x1CF4(0x39E8)
> 	.dw	0xFFFF	; pc=0x1CF5(0x39EA)
> 	.dw	0xFFFF	; pc=0x1CF6(0x39EC)
> 	.dw	0xFFFF	; pc=0x1CF7(0x39EE)
> 	.dw	0xFFFF	; pc=0x1CF8(0x39F0)
> 	.dw	0xFFFF	; pc=0x1CF9(0x39F2)
> 	.dw	0xFFFF	; pc=0x1CFA(0x39F4)
> 	.dw	0xFFFF	; pc=0x1CFB(0x39F6)
> 	.dw	0xFFFF	; pc=0x1CFC(0x39F8)
> 	.dw	0xFFFF	; pc=0x1CFD(0x39FA)
> 	.dw	0xFFFF	; pc=0x1CFE(0x39FC)
> 	.dw	0xFFFF	; pc=0x1CFF(0x39FE)
> 	.dw	0xFFFF	; pc=0x1D00(0x3A00)
> 	.dw	0xFFFF	; pc=0x1D01(0x3A02)
> 	.dw	0xFFFF	; pc=0x1D02(0x3A04)
> 	.dw	0xFFFF	; pc=0x1D03(0x3A06)
> 	.dw	0xFFFF	; pc=0x1D04(0x3A08)
> 	.dw	0xFFFF	; pc=0x1D05(0x3A0A)
> 	.dw	0xFFFF	; pc=0x1D06(0x3A0C)
> 	.dw	0xFFFF	; pc=0x1D07(0x3A0E)
> 	.dw	0xFFFF	; pc=0x1D08(0x3A10)
> 	.dw	0xFFFF	; pc=0x1D09(0x3A12)
> 	.dw	0xFFFF	; pc=0x1D0A(0x3A14)
> 	.dw	0xFFFF	; pc=0x1D0B(0x3A16)
> 	.dw	0xFFFF	; pc=0x1D0C(0x3A18)
> 	.dw	0xFFFF	; pc=0x1D0D(0x3A1A)
> 	.dw	0xFFFF	; pc=0x1D0E(0x3A1C)
> 	.dw	0xFFFF	; pc=0x1D0F(0x3A1E)
> 	.dw	0xFFFF	; pc=0x1D10(0x3A20)
> 	.dw	0xFFFF	; pc=0x1D11(0x3A22)
> 	.dw	0xFFFF	; pc=0x1D12(0x3A24)
> 	.dw	0xFFFF	; pc=0x1D13(0x3A26)
> 	.dw	0xFFFF	; pc=0x1D14(0x3A28)
> 	.dw	0xFFFF	; pc=0x1D15(0x3A2A)
> 	.dw	0xFFFF	; pc=0x1D16(0x3A2C)
> 	.dw	0xFFFF	; pc=0x1D17(0x3A2E)
> 	.dw	0xFFFF	; pc=0x1D18(0x3A30)
> 	.dw	0xFFFF	; pc=0x1D19(0x3A32)
> 	.dw	0xFFFF	; pc=0x1D1A(0x3A34)
> 	.dw	0xFFFF	; pc=0x1D1B(0x3A36)
> 	.dw	0xFFFF	; pc=0x1D1C(0x3A38)
> 	.dw	0xFFFF	; pc=0x1D1D(0x3A3A)
> 	.dw	0xFFFF	; pc=0x1D1E(0x3A3C)
> 	.dw	0xFFFF	; pc=0x1D1F(0x3A3E)
> 	.dw	0xFFFF	; pc=0x1D20(0x3A40)
> 	.dw	0xFFFF	; pc=0x1D21(0x3A42)
> 	.dw	0xFFFF	; pc=0x1D22(0x3A44)
> 	.dw	0xFFFF	; pc=0x1D23(0x3A46)
> 	.dw	0xFFFF	; pc=0x1D24(0x3A48)
> 	.dw	0xFFFF	; pc=0x1D25(0x3A4A)
> 	.dw	0xFFFF	; pc=0x1D26(0x3A4C)
> 	.dw	0xFFFF	; pc=0x1D27(0x3A4E)
> 	.dw	0xFFFF	; pc=0x1D28(0x3A50)
> 	.dw	0xFFFF	; pc=0x1D29(0x3A52)
> 	.dw	0xFFFF	; pc=0x1D2A(0x3A54)
> 	.dw	0xFFFF	; pc=0x1D2B(0x3A56)
> 	.dw	0xFFFF	; pc=0x1D2C(0x3A58)
> 	.dw	0xFFFF	; pc=0x1D2D(0x3A5A)
> 	.dw	0xFFFF	; pc=0x1D2E(0x3A5C)
> 	.dw	0xFFFF	; pc=0x1D2F(0x3A5E)
> 	.dw	0xFFFF	; pc=0x1D30(0x3A60)
> 	.dw	0xFFFF	; pc=0x1D31(0x3A62)
> 	.dw	0xFFFF	; pc=0x1D32(0x3A64)
> 	.dw	0xFFFF	; pc=0x1D33(0x3A66)
> 	.dw	0xFFFF	; pc=0x1D34(0x3A68)
> 	.dw	0xFFFF	; pc=0x1D35(0x3A6A)
> 	.dw	0xFFFF	; pc=0x1D36(0x3A6C)
> 	.dw	0xFFFF	; pc=0x1D37(0x3A6E)
> 	.dw	0xFFFF	; pc=0x1D38(0x3A70)
> 	.dw	0xFFFF	; pc=0x1D39(0x3A72)
> 	.dw	0xFFFF	; pc=0x1D3A(0x3A74)
> 	.dw	0xFFFF	; pc=0x1D3B(0x3A76)
> 	.dw	0xFFFF	; pc=0x1D3C(0x3A78)
> 	.dw	0xFFFF	; pc=0x1D3D(0x3A7A)
> 	.dw	0xFFFF	; pc=0x1D3E(0x3A7C)
> 	.dw	0xFFFF	; pc=0x1D3F(0x3A7E)
> 	.dw	0xFFFF	; pc=0x1D40(0x3A80)
> 	.dw	0xFFFF	; pc=0x1D41(0x3A82)
> 	.dw	0xFFFF	; pc=0x1D42(0x3A84)
> 	.dw	0xFFFF	; pc=0x1D43(0x3A86)
> 	.dw	0xFFFF	; pc=0x1D44(0x3A88)
> 	.dw	0xFFFF	; pc=0x1D45(0x3A8A)
> 	.dw	0xFFFF	; pc=0x1D46(0x3A8C)
> 	.dw	0xFFFF	; pc=0x1D47(0x3A8E)
> 	.dw	0xFFFF	; pc=0x1D48(0x3A90)
> 	.dw	0xFFFF	; pc=0x1D49(0x3A92)
> 	.dw	0xFFFF	; pc=0x1D4A(0x3A94)
> 	.dw	0xFFFF	; pc=0x1D4B(0x3A96)
> 	.dw	0xFFFF	; pc=0x1D4C(0x3A98)
> 	.dw	0xFFFF	; pc=0x1D4D(0x3A9A)
> 	.dw	0xFFFF	; pc=0x1D4E(0x3A9C)
> 	.dw	0xFFFF	; pc=0x1D4F(0x3A9E)
> 	.dw	0xFFFF	; pc=0x1D50(0x3AA0)
> 	.dw	0xFFFF	; pc=0x1D51(0x3AA2)
> 	.dw	0xFFFF	; pc=0x1D52(0x3AA4)
> 	.dw	0xFFFF	; pc=0x1D53(0x3AA6)
> 	.dw	0xFFFF	; pc=0x1D54(0x3AA8)
> 	.dw	0xFFFF	; pc=0x1D55(0x3AAA)
> 	.dw	0xFFFF	; pc=0x1D56(0x3AAC)
> 	.dw	0xFFFF	; pc=0x1D57(0x3AAE)
> 	.dw	0xFFFF	; pc=0x1D58(0x3AB0)
> 	.dw	0xFFFF	; pc=0x1D59(0x3AB2)
> 	.dw	0xFFFF	; pc=0x1D5A(0x3AB4)
> 	.dw	0xFFFF	; pc=0x1D5B(0x3AB6)
> 	.dw	0xFFFF	; pc=0x1D5C(0x3AB8)
> 	.dw	0xFFFF	; pc=0x1D5D(0x3ABA)
> 	.dw	0xFFFF	; pc=0x1D5E(0x3ABC)
> 	.dw	0xFFFF	; pc=0x1D5F(0x3ABE)
> 	.dw	0xFFFF	; pc=0x1D60(0x3AC0)
> 	.dw	0xFFFF	; pc=0x1D61(0x3AC2)
> 	.dw	0xFFFF	; pc=0x1D62(0x3AC4)
> 	.dw	0xFFFF	; pc=0x1D63(0x3AC6)
> 	.dw	0xFFFF	; pc=0x1D64(0x3AC8)
> 	.dw	0xFFFF	; pc=0x1D65(0x3ACA)
> 	.dw	0xFFFF	; pc=0x1D66(0x3ACC)
> 	.dw	0xFFFF	; pc=0x1D67(0x3ACE)
> 	.dw	0xFFFF	; pc=0x1D68(0x3AD0)
> 	.dw	0xFFFF	; pc=0x1D69(0x3AD2)
> 	.dw	0xFFFF	; pc=0x1D6A(0x3AD4)
> 	.dw	0xFFFF	; pc=0x1D6B(0x3AD6)
> 	.dw	0xFFFF	; pc=0x1D6C(0x3AD8)
> 	.dw	0xFFFF	; pc=0x1D6D(0x3ADA)
> 	.dw	0xFFFF	; pc=0x1D6E(0x3ADC)
> 	.dw	0xFFFF	; pc=0x1D6F(0x3ADE)
> 	.dw	0xFFFF	; pc=0x1D70(0x3AE0)
> 	.dw	0xFFFF	; pc=0x1D71(0x3AE2)
> 	.dw	0xFFFF	; pc=0x1D72(0x3AE4)
> 	.dw	0xFFFF	; pc=0x1D73(0x3AE6)
> 	.dw	0xFFFF	; pc=0x1D74(0x3AE8)
> 	.dw	0xFFFF	; pc=0x1D75(0x3AEA)
> 	.dw	0xFFFF	; pc=0x1D76(0x3AEC)
> 	.dw	0xFFFF	; pc=0x1D77(0x3AEE)
> 	.dw	0xFFFF	; pc=0x1D78(0x3AF0)
> 	.dw	0xFFFF	; pc=0x1D79(0x3AF2)
> 	.dw	0xFFFF	; pc=0x1D7A(0x3AF4)
> 	.dw	0xFFFF	; pc=0x1D7B(0x3AF6)
> 	.dw	0xFFFF	; pc=0x1D7C(0x3AF8)
> 	.dw	0xFFFF	; pc=0x1D7D(0x3AFA)
> 	.dw	0xFFFF	; pc=0x1D7E(0x3AFC)
> 	.dw	0xFFFF	; pc=0x1D7F(0x3AFE)
> 	.dw	0xFFFF	; pc=0x1D80(0x3B00)
> 	.dw	0xFFFF	; pc=0x1D81(0x3B02)
> 	.dw	0xFFFF	; pc=0x1D82(0x3B04)
> 	.dw	0xFFFF	; pc=0x1D83(0x3B06)
> 	.dw	0xFFFF	; pc=0x1D84(0x3B08)
> 	.dw	0xFFFF	; pc=0x1D85(0x3B0A)
> 	.dw	0xFFFF	; pc=0x1D86(0x3B0C)
> 	.dw	0xFFFF	; pc=0x1D87(0x3B0E)
> 	.dw	0xFFFF	; pc=0x1D88(0x3B10)
> 	.dw	0xFFFF	; pc=0x1D89(0x3B12)
> 	.dw	0xFFFF	; pc=0x1D8A(0x3B14)
> 	.dw	0xFFFF	; pc=0x1D8B(0x3B16)
> 	.dw	0xFFFF	; pc=0x1D8C(0x3B18)
> 	.dw	0xFFFF	; pc=0x1D8D(0x3B1A)
> 	.dw	0xFFFF	; pc=0x1D8E(0x3B1C)
> 	.dw	0xFFFF	; pc=0x1D8F(0x3B1E)
> 	.dw	0xFFFF	; pc=0x1D90(0x3B20)
> 	.dw	0xFFFF	; pc=0x1D91(0x3B22)
> 	.dw	0xFFFF	; pc=0x1D92(0x3B24)
> 	.dw	0xFFFF	; pc=0x1D93(0x3B26)
> 	.dw	0xFFFF	; pc=0x1D94(0x3B28)
> 	.dw	0xFFFF	; pc=0x1D95(0x3B2A)
> 	.dw	0xFFFF	; pc=0x1D96(0x3B2C)
> 	.dw	0xFFFF	; pc=0x1D97(0x3B2E)
> 	.dw	0xFFFF	; pc=0x1D98(0x3B30)
> 	.dw	0xFFFF	; pc=0x1D99(0x3B32)
> 	.dw	0xFFFF	; pc=0x1D9A(0x3B34)
> 	.dw	0xFFFF	; pc=0x1D9B(0x3B36)
> 	.dw	0xFFFF	; pc=0x1D9C(0x3B38)
> 	.dw	0xFFFF	; pc=0x1D9D(0x3B3A)
> 	.dw	0xFFFF	; pc=0x1D9E(0x3B3C)
> 	.dw	0xFFFF	; pc=0x1D9F(0x3B3E)
> 	.dw	0xFFFF	; pc=0x1DA0(0x3B40)
> 	.dw	0xFFFF	; pc=0x1DA1(0x3B42)
> 	.dw	0xFFFF	; pc=0x1DA2(0x3B44)
> 	.dw	0xFFFF	; pc=0x1DA3(0x3B46)
> 	.dw	0xFFFF	; pc=0x1DA4(0x3B48)
> 	.dw	0xFFFF	; pc=0x1DA5(0x3B4A)
> 	.dw	0xFFFF	; pc=0x1DA6(0x3B4C)
> 	.dw	0xFFFF	; pc=0x1DA7(0x3B4E)
> 	.dw	0xFFFF	; pc=0x1DA8(0x3B50)
> 	.dw	0xFFFF	; pc=0x1DA9(0x3B52)
> 	.dw	0xFFFF	; pc=0x1DAA(0x3B54)
> 	.dw	0xFFFF	; pc=0x1DAB(0x3B56)
> 	.dw	0xFFFF	; pc=0x1DAC(0x3B58)
> 	.dw	0xFFFF	; pc=0x1DAD(0x3B5A)
> 	.dw	0xFFFF	; pc=0x1DAE(0x3B5C)
> 	.dw	0xFFFF	; pc=0x1DAF(0x3B5E)
> 	.dw	0xFFFF	; pc=0x1DB0(0x3B60)
> 	.dw	0xFFFF	; pc=0x1DB1(0x3B62)
> 	.dw	0xFFFF	; pc=0x1DB2(0x3B64)
> 	.dw	0xFFFF	; pc=0x1DB3(0x3B66)
> 	.dw	0xFFFF	; pc=0x1DB4(0x3B68)
> 	.dw	0xFFFF	; pc=0x1DB5(0x3B6A)
> 	.dw	0xFFFF	; pc=0x1DB6(0x3B6C)
> 	.dw	0xFFFF	; pc=0x1DB7(0x3B6E)
> 	.dw	0xFFFF	; pc=0x1DB8(0x3B70)
> 	.dw	0xFFFF	; pc=0x1DB9(0x3B72)
> 	.dw	0xFFFF	; pc=0x1DBA(0x3B74)
> 	.dw	0xFFFF	; pc=0x1DBB(0x3B76)
> 	.dw	0xFFFF	; pc=0x1DBC(0x3B78)
> 	.dw	0xFFFF	; pc=0x1DBD(0x3B7A)
> 	.dw	0xFFFF	; pc=0x1DBE(0x3B7C)
> 	.dw	0xFFFF	; pc=0x1DBF(0x3B7E)
> 	.dw	0xFFFF	; pc=0x1DC0(0x3B80)
> 	.dw	0xFFFF	; pc=0x1DC1(0x3B82)
> 	.dw	0xFFFF	; pc=0x1DC2(0x3B84)
> 	.dw	0xFFFF	; pc=0x1DC3(0x3B86)
> 	.dw	0xFFFF	; pc=0x1DC4(0x3B88)
> 	.dw	0xFFFF	; pc=0x1DC5(0x3B8A)
> 	.dw	0xFFFF	; pc=0x1DC6(0x3B8C)
> 	.dw	0xFFFF	; pc=0x1DC7(0x3B8E)
> 	.dw	0xFFFF	; pc=0x1DC8(0x3B90)
> 	.dw	0xFFFF	; pc=0x1DC9(0x3B92)
> 	.dw	0xFFFF	; pc=0x1DCA(0x3B94)
> 	.dw	0xFFFF	; pc=0x1DCB(0x3B96)
> 	.dw	0xFFFF	; pc=0x1DCC(0x3B98)
> 	.dw	0xFFFF	; pc=0x1DCD(0x3B9A)
> 	.dw	0xFFFF	; pc=0x1DCE(0x3B9C)
> 	.dw	0xFFFF	; pc=0x1DCF(0x3B9E)
> 	.dw	0xFFFF	; pc=0x1DD0(0x3BA0)
> 	.dw	0xFFFF	; pc=0x1DD1(0x3BA2)
> 	.dw	0xFFFF	; pc=0x1DD2(0x3BA4)
> 	.dw	0xFFFF	; pc=0x1DD3(0x3BA6)
> 	.dw	0xFFFF	; pc=0x1DD4(0x3BA8)
> 	.dw	0xFFFF	; pc=0x1DD5(0x3BAA)
> 	.dw	0xFFFF	; pc=0x1DD6(0x3BAC)
> 	.dw	0xFFFF	; pc=0x1DD7(0x3BAE)
> 	.dw	0xFFFF	; pc=0x1DD8(0x3BB0)
> 	.dw	0xFFFF	; pc=0x1DD9(0x3BB2)
> 	.dw	0xFFFF	; pc=0x1DDA(0x3BB4)
> 	.dw	0xFFFF	; pc=0x1DDB(0x3BB6)
> 	.dw	0xFFFF	; pc=0x1DDC(0x3BB8)
> 	.dw	0xFFFF	; pc=0x1DDD(0x3BBA)
> 	.dw	0xFFFF	; pc=0x1DDE(0x3BBC)
> 	.dw	0xFFFF	; pc=0x1DDF(0x3BBE)
> 	.dw	0xFFFF	; pc=0x1DE0(0x3BC0)
> 	.dw	0xFFFF	; pc=0x1DE1(0x3BC2)
> 	.dw	0xFFFF	; pc=0x1DE2(0x3BC4)
> 	.dw	0xFFFF	; pc=0x1DE3(0x3BC6)
> 	.dw	0xFFFF	; pc=0x1DE4(0x3BC8)
> 	.dw	0xFFFF	; pc=0x1DE5(0x3BCA)
> 	.dw	0xFFFF	; pc=0x1DE6(0x3BCC)
> 	.dw	0xFFFF	; pc=0x1DE7(0x3BCE)
> 	.dw	0xFFFF	; pc=0x1DE8(0x3BD0)
> 	.dw	0xFFFF	; pc=0x1DE9(0x3BD2)
> 	.dw	0xFFFF	; pc=0x1DEA(0x3BD4)
> 	.dw	0xFFFF	; pc=0x1DEB(0x3BD6)
> 	.dw	0xFFFF	; pc=0x1DEC(0x3BD8)
> 	.dw	0xFFFF	; pc=0x1DED(0x3BDA)
> 	.dw	0xFFFF	; pc=0x1DEE(0x3BDC)
> 	.dw	0xFFFF	; pc=0x1DEF(0x3BDE)
> 	.dw	0xFFFF	; pc=0x1DF0(0x3BE0)
> 	.dw	0xFFFF	; pc=0x1DF1(0x3BE2)
> 	.dw	0xFFFF	; pc=0x1DF2(0x3BE4)
> 	.dw	0xFFFF	; pc=0x1DF3(0x3BE6)
> 	.dw	0xFFFF	; pc=0x1DF4(0x3BE8)
> 	.dw	0xFFFF	; pc=0x1DF5(0x3BEA)
> 	.dw	0xFFFF	; pc=0x1DF6(0x3BEC)
> 	.dw	0xFFFF	; pc=0x1DF7(0x3BEE)
> 	.dw	0xFFFF	; pc=0x1DF8(0x3BF0)
> 	.dw	0xFFFF	; pc=0x1DF9(0x3BF2)
> 	.dw	0xFFFF	; pc=0x1DFA(0x3BF4)
> 	.dw	0xFFFF	; pc=0x1DFB(0x3BF6)
> 	.dw	0xFFFF	; pc=0x1DFC(0x3BF8)
> 	.dw	0xFFFF	; pc=0x1DFD(0x3BFA)
> 	.dw	0xFFFF	; pc=0x1DFE(0x3BFC)
> 	.dw	0xFFFF	; pc=0x1DFF(0x3BFE)
> L1E00:
> 	.dw	0xFFFF	; pc=0x1E00(0x3C00)
> 	.dw	0xFFFF	; pc=0x1E01(0x3C02)
> 	.dw	0xFFFF	; pc=0x1E02(0x3C04)
> 	.dw	0xFFFF	; pc=0x1E03(0x3C06)
> 	.dw	0xFFFF	; pc=0x1E04(0x3C08)
> 	.dw	0xFFFF	; pc=0x1E05(0x3C0A)
> 	.dw	0xFFFF	; pc=0x1E06(0x3C0C)
> 	.dw	0xFFFF	; pc=0x1E07(0x3C0E)
> 	.dw	0xFFFF	; pc=0x1E08(0x3C10)
> 	.dw	0xFFFF	; pc=0x1E09(0x3C12)
> 	.dw	0xFFFF	; pc=0x1E0A(0x3C14)
> 	.dw	0xFFFF	; pc=0x1E0B(0x3C16)
> 	.dw	0xFFFF	; pc=0x1E0C(0x3C18)
> 	.dw	0xFFFF	; pc=0x1E0D(0x3C1A)
> 	.dw	0xFFFF	; pc=0x1E0E(0x3C1C)
> 	.dw	0xFFFF	; pc=0x1E0F(0x3C1E)
> 	.dw	0xFFFF	; pc=0x1E10(0x3C20)
> 	.dw	0xFFFF	; pc=0x1E11(0x3C22)
> 	.dw	0xFFFF	; pc=0x1E12(0x3C24)
> 	.dw	0xFFFF	; pc=0x1E13(0x3C26)
> 	.dw	0xFFFF	; pc=0x1E14(0x3C28)
> 	.dw	0xFFFF	; pc=0x1E15(0x3C2A)
> 	.dw	0xFFFF	; pc=0x1E16(0x3C2C)
> 	.dw	0xFFFF	; pc=0x1E17(0x3C2E)
> 	.dw	0xFFFF	; pc=0x1E18(0x3C30)
> 	.dw	0xFFFF	; pc=0x1E19(0x3C32)
> 	.dw	0xFFFF	; pc=0x1E1A(0x3C34)
> 	.dw	0xFFFF	; pc=0x1E1B(0x3C36)
> 	.dw	0xFFFF	; pc=0x1E1C(0x3C38)
> 	.dw	0xFFFF	; pc=0x1E1D(0x3C3A)
> 	.dw	0xFFFF	; pc=0x1E1E(0x3C3C)
> 	.dw	0xFFFF	; pc=0x1E1F(0x3C3E)
> 	.dw	0xFFFF	; pc=0x1E20(0x3C40)
> 	.dw	0xFFFF	; pc=0x1E21(0x3C42)
> 	.dw	0xFFFF	; pc=0x1E22(0x3C44)
> 	.dw	0xFFFF	; pc=0x1E23(0x3C46)
> 	.dw	0xFFFF	; pc=0x1E24(0x3C48)
> 	.dw	0xFFFF	; pc=0x1E25(0x3C4A)
> 	.dw	0xFFFF	; pc=0x1E26(0x3C4C)
> 	.dw	0xFFFF	; pc=0x1E27(0x3C4E)
> 	.dw	0xFFFF	; pc=0x1E28(0x3C50)
> 	.dw	0xFFFF	; pc=0x1E29(0x3C52)
> 	.dw	0xFFFF	; pc=0x1E2A(0x3C54)
> 	.dw	0xFFFF	; pc=0x1E2B(0x3C56)
> 	.dw	0xFFFF	; pc=0x1E2C(0x3C58)
> 	.dw	0xFFFF	; pc=0x1E2D(0x3C5A)
> 	.dw	0xFFFF	; pc=0x1E2E(0x3C5C)
> 	.dw	0xFFFF	; pc=0x1E2F(0x3C5E)
> 	.dw	0xFFFF	; pc=0x1E30(0x3C60)
> 	.dw	0xFFFF	; pc=0x1E31(0x3C62)
> 	.dw	0xFFFF	; pc=0x1E32(0x3C64)
> 	.dw	0xFFFF	; pc=0x1E33(0x3C66)
> 	.dw	0xFFFF	; pc=0x1E34(0x3C68)
> 	.dw	0xFFFF	; pc=0x1E35(0x3C6A)
> 	.dw	0xFFFF	; pc=0x1E36(0x3C6C)
> 	.dw	0xFFFF	; pc=0x1E37(0x3C6E)
> 	.dw	0xFFFF	; pc=0x1E38(0x3C70)
> 	.dw	0xFFFF	; pc=0x1E39(0x3C72)
> 	.dw	0xFFFF	; pc=0x1E3A(0x3C74)
> 	.dw	0xFFFF	; pc=0x1E3B(0x3C76)
> 	.dw	0xFFFF	; pc=0x1E3C(0x3C78)
> 	.dw	0xFFFF	; pc=0x1E3D(0x3C7A)
> 	.dw	0xFFFF	; pc=0x1E3E(0x3C7C)
> 	.dw	0xFFFF	; pc=0x1E3F(0x3C7E)
> 	.dw	0xFFFF	; pc=0x1E40(0x3C80)
> 	.dw	0xFFFF	; pc=0x1E41(0x3C82)
> 	.dw	0xFFFF	; pc=0x1E42(0x3C84)
> 	.dw	0xFFFF	; pc=0x1E43(0x3C86)
> 	.dw	0xFFFF	; pc=0x1E44(0x3C88)
> 	.dw	0xFFFF	; pc=0x1E45(0x3C8A)
> 	.dw	0xFFFF	; pc=0x1E46(0x3C8C)
> 	.dw	0xFFFF	; pc=0x1E47(0x3C8E)
> 	.dw	0xFFFF	; pc=0x1E48(0x3C90)
> 	.dw	0xFFFF	; pc=0x1E49(0x3C92)
> 	.dw	0xFFFF	; pc=0x1E4A(0x3C94)
> 	.dw	0xFFFF	; pc=0x1E4B(0x3C96)
> 	.dw	0xFFFF	; pc=0x1E4C(0x3C98)
> 	.dw	0xFFFF	; pc=0x1E4D(0x3C9A)
> 	.dw	0xFFFF	; pc=0x1E4E(0x3C9C)
> 	.dw	0xFFFF	; pc=0x1E4F(0x3C9E)
> 	.dw	0xFFFF	; pc=0x1E50(0x3CA0)
> 	.dw	0xFFFF	; pc=0x1E51(0x3CA2)
> 	.dw	0xFFFF	; pc=0x1E52(0x3CA4)
> 	.dw	0xFFFF	; pc=0x1E53(0x3CA6)
> 	.dw	0xFFFF	; pc=0x1E54(0x3CA8)
> 	.dw	0xFFFF	; pc=0x1E55(0x3CAA)
> 	.dw	0xFFFF	; pc=0x1E56(0x3CAC)
> 	.dw	0xFFFF	; pc=0x1E57(0x3CAE)
> 	.dw	0xFFFF	; pc=0x1E58(0x3CB0)
> 	.dw	0xFFFF	; pc=0x1E59(0x3CB2)
> 	.dw	0xFFFF	; pc=0x1E5A(0x3CB4)
> 	.dw	0xFFFF	; pc=0x1E5B(0x3CB6)
> 	.dw	0xFFFF	; pc=0x1E5C(0x3CB8)
> 	.dw	0xFFFF	; pc=0x1E5D(0x3CBA)
> 	.dw	0xFFFF	; pc=0x1E5E(0x3CBC)
> 	.dw	0xFFFF	; pc=0x1E5F(0x3CBE)
> 	.dw	0xFFFF	; pc=0x1E60(0x3CC0)
> 	.dw	0xFFFF	; pc=0x1E61(0x3CC2)
> 	.dw	0xFFFF	; pc=0x1E62(0x3CC4)
> 	.dw	0xFFFF	; pc=0x1E63(0x3CC6)
> 	.dw	0xFFFF	; pc=0x1E64(0x3CC8)
> 	.dw	0xFFFF	; pc=0x1E65(0x3CCA)
> 	.dw	0xFFFF	; pc=0x1E66(0x3CCC)
> 	.dw	0xFFFF	; pc=0x1E67(0x3CCE)
> 	.dw	0xFFFF	; pc=0x1E68(0x3CD0)
> 	.dw	0xFFFF	; pc=0x1E69(0x3CD2)
> 	.dw	0xFFFF	; pc=0x1E6A(0x3CD4)
> 	.dw	0xFFFF	; pc=0x1E6B(0x3CD6)
> 	.dw	0xFFFF	; pc=0x1E6C(0x3CD8)
> 	.dw	0xFFFF	; pc=0x1E6D(0x3CDA)
> 	.dw	0xFFFF	; pc=0x1E6E(0x3CDC)
> 	.dw	0xFFFF	; pc=0x1E6F(0x3CDE)
> 	.dw	0xFFFF	; pc=0x1E70(0x3CE0)
> 	.dw	0xFFFF	; pc=0x1E71(0x3CE2)
> 	.dw	0xFFFF	; pc=0x1E72(0x3CE4)
> 	.dw	0xFFFF	; pc=0x1E73(0x3CE6)
> 	.dw	0xFFFF	; pc=0x1E74(0x3CE8)
> 	.dw	0xFFFF	; pc=0x1E75(0x3CEA)
> 	.dw	0xFFFF	; pc=0x1E76(0x3CEC)
> 	.dw	0xFFFF	; pc=0x1E77(0x3CEE)
> 	.dw	0xFFFF	; pc=0x1E78(0x3CF0)
> 	.dw	0xFFFF	; pc=0x1E79(0x3CF2)
> 	.dw	0xFFFF	; pc=0x1E7A(0x3CF4)
> 	.dw	0xFFFF	; pc=0x1E7B(0x3CF6)
> 	.dw	0xFFFF	; pc=0x1E7C(0x3CF8)
> 	.dw	0xFFFF	; pc=0x1E7D(0x3CFA)
> 	.dw	0xFFFF	; pc=0x1E7E(0x3CFC)
> 	.dw	0xFFFF	; pc=0x1E7F(0x3CFE)
> 	.dw	0xFFFF	; pc=0x1E80(0x3D00)
> 	.dw	0xFFFF	; pc=0x1E81(0x3D02)
> 	.dw	0xFFFF	; pc=0x1E82(0x3D04)
> 	.dw	0xFFFF	; pc=0x1E83(0x3D06)
> 	.dw	0xFFFF	; pc=0x1E84(0x3D08)
> 	.dw	0xFFFF	; pc=0x1E85(0x3D0A)
> 	.dw	0xFFFF	; pc=0x1E86(0x3D0C)
> 	.dw	0xFFFF	; pc=0x1E87(0x3D0E)
> 	.dw	0xFFFF	; pc=0x1E88(0x3D10)
> 	.dw	0xFFFF	; pc=0x1E89(0x3D12)
> 	.dw	0xFFFF	; pc=0x1E8A(0x3D14)
> 	.dw	0xFFFF	; pc=0x1E8B(0x3D16)
> 	.dw	0xFFFF	; pc=0x1E8C(0x3D18)
> 	.dw	0xFFFF	; pc=0x1E8D(0x3D1A)
> 	.dw	0xFFFF	; pc=0x1E8E(0x3D1C)
> 	.dw	0xFFFF	; pc=0x1E8F(0x3D1E)
> 	.dw	0xFFFF	; pc=0x1E90(0x3D20)
> 	.dw	0xFFFF	; pc=0x1E91(0x3D22)
> 	.dw	0xFFFF	; pc=0x1E92(0x3D24)
> 	.dw	0xFFFF	; pc=0x1E93(0x3D26)
> 	.dw	0xFFFF	; pc=0x1E94(0x3D28)
> 	.dw	0xFFFF	; pc=0x1E95(0x3D2A)
> 	.dw	0xFFFF	; pc=0x1E96(0x3D2C)
> 	.dw	0xFFFF	; pc=0x1E97(0x3D2E)
> 	.dw	0xFFFF	; pc=0x1E98(0x3D30)
> 	.dw	0xFFFF	; pc=0x1E99(0x3D32)
> 	.dw	0xFFFF	; pc=0x1E9A(0x3D34)
> 	.dw	0xFFFF	; pc=0x1E9B(0x3D36)
> 	.dw	0xFFFF	; pc=0x1E9C(0x3D38)
> 	.dw	0xFFFF	; pc=0x1E9D(0x3D3A)
> 	.dw	0xFFFF	; pc=0x1E9E(0x3D3C)
> 	.dw	0xFFFF	; pc=0x1E9F(0x3D3E)
> 	.dw	0xFFFF	; pc=0x1EA0(0x3D40)
> 	.dw	0xFFFF	; pc=0x1EA1(0x3D42)
> 	.dw	0xFFFF	; pc=0x1EA2(0x3D44)
> 	.dw	0xFFFF	; pc=0x1EA3(0x3D46)
> 	.dw	0xFFFF	; pc=0x1EA4(0x3D48)
> 	.dw	0xFFFF	; pc=0x1EA5(0x3D4A)
> 	.dw	0xFFFF	; pc=0x1EA6(0x3D4C)
> 	.dw	0xFFFF	; pc=0x1EA7(0x3D4E)
> 	.dw	0xFFFF	; pc=0x1EA8(0x3D50)
> 	.dw	0xFFFF	; pc=0x1EA9(0x3D52)
> 	.dw	0xFFFF	; pc=0x1EAA(0x3D54)
> 	.dw	0xFFFF	; pc=0x1EAB(0x3D56)
> 	.dw	0xFFFF	; pc=0x1EAC(0x3D58)
> 	.dw	0xFFFF	; pc=0x1EAD(0x3D5A)
> 	.dw	0xFFFF	; pc=0x1EAE(0x3D5C)
> 	.dw	0xFFFF	; pc=0x1EAF(0x3D5E)
> 	.dw	0xFFFF	; pc=0x1EB0(0x3D60)
> 	.dw	0xFFFF	; pc=0x1EB1(0x3D62)
> 	.dw	0xFFFF	; pc=0x1EB2(0x3D64)
> 	.dw	0xFFFF	; pc=0x1EB3(0x3D66)
> 	.dw	0xFFFF	; pc=0x1EB4(0x3D68)
> 	.dw	0xFFFF	; pc=0x1EB5(0x3D6A)
> 	.dw	0xFFFF	; pc=0x1EB6(0x3D6C)
> 	.dw	0xFFFF	; pc=0x1EB7(0x3D6E)
> 	.dw	0xFFFF	; pc=0x1EB8(0x3D70)
> 	.dw	0xFFFF	; pc=0x1EB9(0x3D72)
> 	.dw	0xFFFF	; pc=0x1EBA(0x3D74)
> 	.dw	0xFFFF	; pc=0x1EBB(0x3D76)
> 	.dw	0xFFFF	; pc=0x1EBC(0x3D78)
> 	.dw	0xFFFF	; pc=0x1EBD(0x3D7A)
> 	.dw	0xFFFF	; pc=0x1EBE(0x3D7C)
> 	.dw	0xFFFF	; pc=0x1EBF(0x3D7E)
> 	.dw	0xFFFF	; pc=0x1EC0(0x3D80)
> 	.dw	0xFFFF	; pc=0x1EC1(0x3D82)
> 	.dw	0xFFFF	; pc=0x1EC2(0x3D84)
> 	.dw	0xFFFF	; pc=0x1EC3(0x3D86)
> 	.dw	0xFFFF	; pc=0x1EC4(0x3D88)
> 	.dw	0xFFFF	; pc=0x1EC5(0x3D8A)
> 	.dw	0xFFFF	; pc=0x1EC6(0x3D8C)
> 	.dw	0xFFFF	; pc=0x1EC7(0x3D8E)
> 	.dw	0xFFFF	; pc=0x1EC8(0x3D90)
> 	.dw	0xFFFF	; pc=0x1EC9(0x3D92)
> 	.dw	0xFFFF	; pc=0x1ECA(0x3D94)
> 	.dw	0xFFFF	; pc=0x1ECB(0x3D96)
> 	.dw	0xFFFF	; pc=0x1ECC(0x3D98)
> 	.dw	0xFFFF	; pc=0x1ECD(0x3D9A)
> 	.dw	0xFFFF	; pc=0x1ECE(0x3D9C)
> 	.dw	0xFFFF	; pc=0x1ECF(0x3D9E)
> 	.dw	0xFFFF	; pc=0x1ED0(0x3DA0)
> 	.dw	0xFFFF	; pc=0x1ED1(0x3DA2)
> 	.dw	0xFFFF	; pc=0x1ED2(0x3DA4)
> 	.dw	0xFFFF	; pc=0x1ED3(0x3DA6)
> 	.dw	0xFFFF	; pc=0x1ED4(0x3DA8)
> 	.dw	0xFFFF	; pc=0x1ED5(0x3DAA)
> 	.dw	0xFFFF	; pc=0x1ED6(0x3DAC)
> 	.dw	0xFFFF	; pc=0x1ED7(0x3DAE)
> 	.dw	0xFFFF	; pc=0x1ED8(0x3DB0)
> 	.dw	0xFFFF	; pc=0x1ED9(0x3DB2)
> 	.dw	0xFFFF	; pc=0x1EDA(0x3DB4)
> 	.dw	0xFFFF	; pc=0x1EDB(0x3DB6)
> 	.dw	0xFFFF	; pc=0x1EDC(0x3DB8)
> 	.dw	0xFFFF	; pc=0x1EDD(0x3DBA)
> 	.dw	0xFFFF	; pc=0x1EDE(0x3DBC)
> 	.dw	0xFFFF	; pc=0x1EDF(0x3DBE)
> 	.dw	0xFFFF	; pc=0x1EE0(0x3DC0)
> 	.dw	0xFFFF	; pc=0x1EE1(0x3DC2)
> 	.dw	0xFFFF	; pc=0x1EE2(0x3DC4)
> 	.dw	0xFFFF	; pc=0x1EE3(0x3DC6)
> 	.dw	0xFFFF	; pc=0x1EE4(0x3DC8)
> 	.dw	0xFFFF	; pc=0x1EE5(0x3DCA)
> 	.dw	0xFFFF	; pc=0x1EE6(0x3DCC)
> 	.dw	0xFFFF	; pc=0x1EE7(0x3DCE)
> 	.dw	0xFFFF	; pc=0x1EE8(0x3DD0)
> 	.dw	0xFFFF	; pc=0x1EE9(0x3DD2)
> 	.dw	0xFFFF	; pc=0x1EEA(0x3DD4)
> 	.dw	0xFFFF	; pc=0x1EEB(0x3DD6)
> 	.dw	0xFFFF	; pc=0x1EEC(0x3DD8)
> 	.dw	0xFFFF	; pc=0x1EED(0x3DDA)
> 	.dw	0xFFFF	; pc=0x1EEE(0x3DDC)
> 	.dw	0xFFFF	; pc=0x1EEF(0x3DDE)
> 	.dw	0xFFFF	; pc=0x1EF0(0x3DE0)
> 	.dw	0xFFFF	; pc=0x1EF1(0x3DE2)
> 	.dw	0xFFFF	; pc=0x1EF2(0x3DE4)
> 	.dw	0xFFFF	; pc=0x1EF3(0x3DE6)
> 	.dw	0xFFFF	; pc=0x1EF4(0x3DE8)
> 	.dw	0xFFFF	; pc=0x1EF5(0x3DEA)
> 	.dw	0xFFFF	; pc=0x1EF6(0x3DEC)
> 	.dw	0xFFFF	; pc=0x1EF7(0x3DEE)
> 	.dw	0xFFFF	; pc=0x1EF8(0x3DF0)
> 	.dw	0xFFFF	; pc=0x1EF9(0x3DF2)
> 	.dw	0xFFFF	; pc=0x1EFA(0x3DF4)
> 	.dw	0xFFFF	; pc=0x1EFB(0x3DF6)
> 	.dw	0xFFFF	; pc=0x1EFC(0x3DF8)
> 	.dw	0xFFFF	; pc=0x1EFD(0x3DFA)
> 	.dw	0xFFFF	; pc=0x1EFE(0x3DFC)
> 	.dw	0xFFFF	; pc=0x1EFF(0x3DFE)
> 	.dw	0xFFFF	; pc=0x1F00(0x3E00)
> 	.dw	0xFFFF	; pc=0x1F01(0x3E02)
> 	.dw	0xFFFF	; pc=0x1F02(0x3E04)
> 	.dw	0xFFFF	; pc=0x1F03(0x3E06)
> 	.dw	0xFFFF	; pc=0x1F04(0x3E08)
> 	.dw	0xFFFF	; pc=0x1F05(0x3E0A)
> 	.dw	0xFFFF	; pc=0x1F06(0x3E0C)
> 	.dw	0xFFFF	; pc=0x1F07(0x3E0E)
> 	.dw	0xFFFF	; pc=0x1F08(0x3E10)
> 	.dw	0xFFFF	; pc=0x1F09(0x3E12)
> 	.dw	0xFFFF	; pc=0x1F0A(0x3E14)
> 	.dw	0xFFFF	; pc=0x1F0B(0x3E16)
> 	.dw	0xFFFF	; pc=0x1F0C(0x3E18)
> 	.dw	0xFFFF	; pc=0x1F0D(0x3E1A)
> 	.dw	0xFFFF	; pc=0x1F0E(0x3E1C)
> 	.dw	0xFFFF	; pc=0x1F0F(0x3E1E)
> 	.dw	0xFFFF	; pc=0x1F10(0x3E20)
> 	.dw	0xFFFF	; pc=0x1F11(0x3E22)
> 	.dw	0xFFFF	; pc=0x1F12(0x3E24)
> 	.dw	0xFFFF	; pc=0x1F13(0x3E26)
> 	.dw	0xFFFF	; pc=0x1F14(0x3E28)
> 	.dw	0xFFFF	; pc=0x1F15(0x3E2A)
> 	.dw	0xFFFF	; pc=0x1F16(0x3E2C)
> 	.dw	0xFFFF	; pc=0x1F17(0x3E2E)
> 	.dw	0xFFFF	; pc=0x1F18(0x3E30)
> 	.dw	0xFFFF	; pc=0x1F19(0x3E32)
> 	.dw	0xFFFF	; pc=0x1F1A(0x3E34)
> 	.dw	0xFFFF	; pc=0x1F1B(0x3E36)
> 	.dw	0xFFFF	; pc=0x1F1C(0x3E38)
> 	.dw	0xFFFF	; pc=0x1F1D(0x3E3A)
> 	.dw	0xFFFF	; pc=0x1F1E(0x3E3C)
> 	.dw	0xFFFF	; pc=0x1F1F(0x3E3E)
> 	.dw	0xFFFF	; pc=0x1F20(0x3E40)
> 	.dw	0xFFFF	; pc=0x1F21(0x3E42)
> 	.dw	0xFFFF	; pc=0x1F22(0x3E44)
> 	.dw	0xFFFF	; pc=0x1F23(0x3E46)
> 	.dw	0xFFFF	; pc=0x1F24(0x3E48)
> 	.dw	0xFFFF	; pc=0x1F25(0x3E4A)
> 	.dw	0xFFFF	; pc=0x1F26(0x3E4C)
> 	.dw	0xFFFF	; pc=0x1F27(0x3E4E)
> 	.dw	0xFFFF	; pc=0x1F28(0x3E50)
> 	.dw	0xFFFF	; pc=0x1F29(0x3E52)
> 	.dw	0xFFFF	; pc=0x1F2A(0x3E54)
> 	.dw	0xFFFF	; pc=0x1F2B(0x3E56)
> 	.dw	0xFFFF	; pc=0x1F2C(0x3E58)
> 	.dw	0xFFFF	; pc=0x1F2D(0x3E5A)
> 	.dw	0xFFFF	; pc=0x1F2E(0x3E5C)
> 	.dw	0xFFFF	; pc=0x1F2F(0x3E5E)
> 	.dw	0xFFFF	; pc=0x1F30(0x3E60)
> 	.dw	0xFFFF	; pc=0x1F31(0x3E62)
> 	.dw	0xFFFF	; pc=0x1F32(0x3E64)
> 	.dw	0xFFFF	; pc=0x1F33(0x3E66)
> 	.dw	0xFFFF	; pc=0x1F34(0x3E68)
> 	.dw	0xFFFF	; pc=0x1F35(0x3E6A)
> 	.dw	0xFFFF	; pc=0x1F36(0x3E6C)
> 	.dw	0xFFFF	; pc=0x1F37(0x3E6E)
> 	.dw	0xFFFF	; pc=0x1F38(0x3E70)
> 	.dw	0xFFFF	; pc=0x1F39(0x3E72)
> 	.dw	0xFFFF	; pc=0x1F3A(0x3E74)
> 	.dw	0xFFFF	; pc=0x1F3B(0x3E76)
> 	.dw	0xFFFF	; pc=0x1F3C(0x3E78)
> 	.dw	0xFFFF	; pc=0x1F3D(0x3E7A)
> 	.dw	0xFFFF	; pc=0x1F3E(0x3E7C)
> 	.dw	0xFFFF	; pc=0x1F3F(0x3E7E)
> 	.dw	0xFFFF	; pc=0x1F40(0x3E80)
> 	.dw	0xFFFF	; pc=0x1F41(0x3E82)
> 	.dw	0xFFFF	; pc=0x1F42(0x3E84)
> 	.dw	0xFFFF	; pc=0x1F43(0x3E86)
> 	.dw	0xFFFF	; pc=0x1F44(0x3E88)
> 	.dw	0xFFFF	; pc=0x1F45(0x3E8A)
> 	.dw	0xFFFF	; pc=0x1F46(0x3E8C)
> 	.dw	0xFFFF	; pc=0x1F47(0x3E8E)
> 	.dw	0xFFFF	; pc=0x1F48(0x3E90)
> 	.dw	0xFFFF	; pc=0x1F49(0x3E92)
> 	.dw	0xFFFF	; pc=0x1F4A(0x3E94)
> 	.dw	0xFFFF	; pc=0x1F4B(0x3E96)
> 	.dw	0xFFFF	; pc=0x1F4C(0x3E98)
> 	.dw	0xFFFF	; pc=0x1F4D(0x3E9A)
> 	.dw	0xFFFF	; pc=0x1F4E(0x3E9C)
> 	.dw	0xFFFF	; pc=0x1F4F(0x3E9E)
> 	.dw	0xFFFF	; pc=0x1F50(0x3EA0)
> 	.dw	0xFFFF	; pc=0x1F51(0x3EA2)
> 	.dw	0xFFFF	; pc=0x1F52(0x3EA4)
> 	.dw	0xFFFF	; pc=0x1F53(0x3EA6)
> 	.dw	0xFFFF	; pc=0x1F54(0x3EA8)
> 	.dw	0xFFFF	; pc=0x1F55(0x3EAA)
> 	.dw	0xFFFF	; pc=0x1F56(0x3EAC)
> 	.dw	0xFFFF	; pc=0x1F57(0x3EAE)
> 	.dw	0xFFFF	; pc=0x1F58(0x3EB0)
> 	.dw	0xFFFF	; pc=0x1F59(0x3EB2)
> 	.dw	0xFFFF	; pc=0x1F5A(0x3EB4)
> 	.dw	0xFFFF	; pc=0x1F5B(0x3EB6)
> 	.dw	0xFFFF	; pc=0x1F5C(0x3EB8)
> 	.dw	0xFFFF	; pc=0x1F5D(0x3EBA)
> 	.dw	0xFFFF	; pc=0x1F5E(0x3EBC)
> 	.dw	0xFFFF	; pc=0x1F5F(0x3EBE)
> 	.dw	0xFFFF	; pc=0x1F60(0x3EC0)
> 	.dw	0xFFFF	; pc=0x1F61(0x3EC2)
> 	.dw	0xFFFF	; pc=0x1F62(0x3EC4)
> 	.dw	0xFFFF	; pc=0x1F63(0x3EC6)
> 	.dw	0xFFFF	; pc=0x1F64(0x3EC8)
> 	.dw	0xFFFF	; pc=0x1F65(0x3ECA)
> 	.dw	0xFFFF	; pc=0x1F66(0x3ECC)
> 	.dw	0xFFFF	; pc=0x1F67(0x3ECE)
> 	.dw	0xFFFF	; pc=0x1F68(0x3ED0)
> 	.dw	0xFFFF	; pc=0x1F69(0x3ED2)
> 	.dw	0xFFFF	; pc=0x1F6A(0x3ED4)
> 	.dw	0xFFFF	; pc=0x1F6B(0x3ED6)
> 	.dw	0xFFFF	; pc=0x1F6C(0x3ED8)
> 	.dw	0xFFFF	; pc=0x1F6D(0x3EDA)
> 	.dw	0xFFFF	; pc=0x1F6E(0x3EDC)
> 	.dw	0xFFFF	; pc=0x1F6F(0x3EDE)
> 	.dw	0xFFFF	; pc=0x1F70(0x3EE0)
> 	.dw	0xFFFF	; pc=0x1F71(0x3EE2)
> 	.dw	0xFFFF	; pc=0x1F72(0x3EE4)
> 	.dw	0xFFFF	; pc=0x1F73(0x3EE6)
> 	.dw	0xFFFF	; pc=0x1F74(0x3EE8)
> 	.dw	0xFFFF	; pc=0x1F75(0x3EEA)
> 	.dw	0xFFFF	; pc=0x1F76(0x3EEC)
> 	.dw	0xFFFF	; pc=0x1F77(0x3EEE)
> 	.dw	0xFFFF	; pc=0x1F78(0x3EF0)
> 	.dw	0xFFFF	; pc=0x1F79(0x3EF2)
> 	.dw	0xFFFF	; pc=0x1F7A(0x3EF4)
> 	.dw	0xFFFF	; pc=0x1F7B(0x3EF6)
> 	.dw	0xFFFF	; pc=0x1F7C(0x3EF8)
> 	.dw	0xFFFF	; pc=0x1F7D(0x3EFA)
> 	.dw	0xFFFF	; pc=0x1F7E(0x3EFC)
> 	.dw	0xFFFF	; pc=0x1F7F(0x3EFE)
> 	.dw	0xFFFF	; pc=0x1F80(0x3F00)
> 	.dw	0xFFFF	; pc=0x1F81(0x3F02)
> 	.dw	0xFFFF	; pc=0x1F82(0x3F04)
> 	.dw	0xFFFF	; pc=0x1F83(0x3F06)
> 	.dw	0xFFFF	; pc=0x1F84(0x3F08)
> 	.dw	0xFFFF	; pc=0x1F85(0x3F0A)
> 	.dw	0xFFFF	; pc=0x1F86(0x3F0C)
> 	.dw	0xFFFF	; pc=0x1F87(0x3F0E)
> 	.dw	0xFFFF	; pc=0x1F88(0x3F10)
> 	.dw	0xFFFF	; pc=0x1F89(0x3F12)
> 	.dw	0xFFFF	; pc=0x1F8A(0x3F14)
> 	.dw	0xFFFF	; pc=0x1F8B(0x3F16)
> 	.dw	0xFFFF	; pc=0x1F8C(0x3F18)
> 	.dw	0xFFFF	; pc=0x1F8D(0x3F1A)
> 	.dw	0xFFFF	; pc=0x1F8E(0x3F1C)
> 	.dw	0xFFFF	; pc=0x1F8F(0x3F1E)
> 	.dw	0xFFFF	; pc=0x1F90(0x3F20)
> 	.dw	0xFFFF	; pc=0x1F91(0x3F22)
> 	.dw	0xFFFF	; pc=0x1F92(0x3F24)
> 	.dw	0xFFFF	; pc=0x1F93(0x3F26)
> 	.dw	0xFFFF	; pc=0x1F94(0x3F28)
> 	.dw	0xFFFF	; pc=0x1F95(0x3F2A)
> 	.dw	0xFFFF	; pc=0x1F96(0x3F2C)
> 	.dw	0xFFFF	; pc=0x1F97(0x3F2E)
> 	.dw	0xFFFF	; pc=0x1F98(0x3F30)
> 	.dw	0xFFFF	; pc=0x1F99(0x3F32)
> 	.dw	0xFFFF	; pc=0x1F9A(0x3F34)
> 	.dw	0xFFFF	; pc=0x1F9B(0x3F36)
> 	.dw	0xFFFF	; pc=0x1F9C(0x3F38)
> 	.dw	0xFFFF	; pc=0x1F9D(0x3F3A)
> 	.dw	0xFFFF	; pc=0x1F9E(0x3F3C)
> 	.dw	0xFFFF	; pc=0x1F9F(0x3F3E)
> 	.dw	0xFFFF	; pc=0x1FA0(0x3F40)
> 	.dw	0xFFFF	; pc=0x1FA1(0x3F42)
> 	.dw	0xFFFF	; pc=0x1FA2(0x3F44)
> 	.dw	0xFFFF	; pc=0x1FA3(0x3F46)
> 	.dw	0xFFFF	; pc=0x1FA4(0x3F48)
> 	.dw	0xFFFF	; pc=0x1FA5(0x3F4A)
> 	.dw	0xFFFF	; pc=0x1FA6(0x3F4C)
> 	.dw	0xFFFF	; pc=0x1FA7(0x3F4E)
> 	.dw	0xFFFF	; pc=0x1FA8(0x3F50)
> 	.dw	0xFFFF	; pc=0x1FA9(0x3F52)
> 	.dw	0xFFFF	; pc=0x1FAA(0x3F54)
> 	.dw	0xFFFF	; pc=0x1FAB(0x3F56)
> 	.dw	0xFFFF	; pc=0x1FAC(0x3F58)
> 	.dw	0xFFFF	; pc=0x1FAD(0x3F5A)
> 	.dw	0xFFFF	; pc=0x1FAE(0x3F5C)
> 	.dw	0xFFFF	; pc=0x1FAF(0x3F5E)
> 	.dw	0xFFFF	; pc=0x1FB0(0x3F60)
> 	.dw	0xFFFF	; pc=0x1FB1(0x3F62)
> 	.dw	0xFFFF	; pc=0x1FB2(0x3F64)
> 	.dw	0xFFFF	; pc=0x1FB3(0x3F66)
> 	.dw	0xFFFF	; pc=0x1FB4(0x3F68)
> 	.dw	0xFFFF	; pc=0x1FB5(0x3F6A)
> 	.dw	0xFFFF	; pc=0x1FB6(0x3F6C)
> 	.dw	0xFFFF	; pc=0x1FB7(0x3F6E)
> 	.dw	0xFFFF	; pc=0x1FB8(0x3F70)
> 	.dw	0xFFFF	; pc=0x1FB9(0x3F72)
> 	.dw	0xFFFF	; pc=0x1FBA(0x3F74)
> 	.dw	0xFFFF	; pc=0x1FBB(0x3F76)
> 	.dw	0xFFFF	; pc=0x1FBC(0x3F78)
> 	.dw	0xFFFF	; pc=0x1FBD(0x3F7A)
> 	.dw	0xFFFF	; pc=0x1FBE(0x3F7C)
> 	.dw	0xFFFF	; pc=0x1FBF(0x3F7E)
> 	.dw	0xFFFF	; pc=0x1FC0(0x3F80)
> 	.dw	0xFFFF	; pc=0x1FC1(0x3F82)
> 	.dw	0xFFFF	; pc=0x1FC2(0x3F84)
> 	.dw	0xFFFF	; pc=0x1FC3(0x3F86)
> 	.dw	0xFFFF	; pc=0x1FC4(0x3F88)
> 	.dw	0xFFFF	; pc=0x1FC5(0x3F8A)
> 	.dw	0xFFFF	; pc=0x1FC6(0x3F8C)
> 	.dw	0xFFFF	; pc=0x1FC7(0x3F8E)
> 	.dw	0xFFFF	; pc=0x1FC8(0x3F90)
> 	.dw	0xFFFF	; pc=0x1FC9(0x3F92)
> 	.dw	0xFFFF	; pc=0x1FCA(0x3F94)
> 	.dw	0xFFFF	; pc=0x1FCB(0x3F96)
> 	.dw	0xFFFF	; pc=0x1FCC(0x3F98)
> 	.dw	0xFFFF	; pc=0x1FCD(0x3F9A)
> 	.dw	0xFFFF	; pc=0x1FCE(0x3F9C)
> 	.dw	0xFFFF	; pc=0x1FCF(0x3F9E)
> 	.dw	0xFFFF	; pc=0x1FD0(0x3FA0)
> 	.dw	0xFFFF	; pc=0x1FD1(0x3FA2)
> 	.dw	0xFFFF	; pc=0x1FD2(0x3FA4)
> 	.dw	0xFFFF	; pc=0x1FD3(0x3FA6)
> 	.dw	0xFFFF	; pc=0x1FD4(0x3FA8)
> 	.dw	0xFFFF	; pc=0x1FD5(0x3FAA)
> 	.dw	0xFFFF	; pc=0x1FD6(0x3FAC)
> 	.dw	0xFFFF	; pc=0x1FD7(0x3FAE)
> 	.dw	0xFFFF	; pc=0x1FD8(0x3FB0)
> 	.dw	0xFFFF	; pc=0x1FD9(0x3FB2)
> 	.dw	0xFFFF	; pc=0x1FDA(0x3FB4)
> 	.dw	0xFFFF	; pc=0x1FDB(0x3FB6)
> 	.dw	0xFFFF	; pc=0x1FDC(0x3FB8)
> 	.dw	0xFFFF	; pc=0x1FDD(0x3FBA)
> 	.dw	0xFFFF	; pc=0x1FDE(0x3FBC)
> 	.dw	0xFFFF	; pc=0x1FDF(0x3FBE)
> 	.dw	0xFFFF	; pc=0x1FE0(0x3FC0)
> 	.dw	0xFFFF	; pc=0x1FE1(0x3FC2)
> 	.dw	0xFFFF	; pc=0x1FE2(0x3FC4)
> 	.dw	0xFFFF	; pc=0x1FE3(0x3FC6)
> 	.dw	0xFFFF	; pc=0x1FE4(0x3FC8)
> 	.dw	0xFFFF	; pc=0x1FE5(0x3FCA)
> 	.dw	0xFFFF	; pc=0x1FE6(0x3FCC)
> 	.dw	0xFFFF	; pc=0x1FE7(0x3FCE)
> 	.dw	0xFFFF	; pc=0x1FE8(0x3FD0)
> 	.dw	0xFFFF	; pc=0x1FE9(0x3FD2)
> 	.dw	0xFFFF	; pc=0x1FEA(0x3FD4)
> 	.dw	0xFFFF	; pc=0x1FEB(0x3FD6)
> 	.dw	0xFFFF	; pc=0x1FEC(0x3FD8)
> 	.dw	0xFFFF	; pc=0x1FED(0x3FDA)
> 	.dw	0xFFFF	; pc=0x1FEE(0x3FDC)
> 	.dw	0xFFFF	; pc=0x1FEF(0x3FDE)
> 	.dw	0xFFFF	; pc=0x1FF0(0x3FE0)
> 	.dw	0xFFFF	; pc=0x1FF1(0x3FE2)
> 	.dw	0xFFFF	; pc=0x1FF2(0x3FE4)
> 	.dw	0xFFFF	; pc=0x1FF3(0x3FE6)
> 	.dw	0xFFFF	; pc=0x1FF4(0x3FE8)
> 	.dw	0xFFFF	; pc=0x1FF5(0x3FEA)
> 	.dw	0xFFFF	; pc=0x1FF6(0x3FEC)
> 	.dw	0xFFFF	; pc=0x1FF7(0x3FEE)
> 	.dw	0xFFFF	; pc=0x1FF8(0x3FF0)
> 	.dw	0xFFFF	; pc=0x1FF9(0x3FF2)
> 	.dw	0xFFFF	; pc=0x1FFA(0x3FF4)
> 	.dw	0xFFFF	; pc=0x1FFB(0x3FF6)
> 	.dw	0xFFFF	; pc=0x1FFC(0x3FF8)
> 	.dw	0xFFFF	; pc=0x1FFD(0x3FFA)
> 	.dw	0xFFFF	; pc=0x1FFE(0x3FFC)
> 	.dw	0xFFFF	; pc=0x1FFF(0x3FFE)
> ;
> ; last flash byte address = 0x3FFF
> ; last flash word address = 0x1FFF
9288,9289c9561,9562
< .dseg
< .org SRAM_START
---
> 	.dseg
> 	.org	0x0060
9293c9566
< D0061:				; baud rate parameter
---
> D0061:
9295a9569,9570
> 	.byte	11
> D006D:
9297,9307c9572,9574
< P0063:				; soft function address
< 	.byte	2
< P0065:				; flags
< 	.byte	4
< d0069:				; ADC conversion summation
< 	.byte	2 
< d006B:				; bitshifted ADC (parameter 0x84) return
< 	.byte   2
< D006D:				; ADC conversion counter
< 	.byte	1
< D006E:				; WaitTime owned by timer
---
> D006E:
> 	.byte	5
> D0073:
9309,9311c9576
< P006F:				; 4 byte JTAG ID return
< 	.byte	4
< D0073:				; used by print sleep state
---
> D0074:
9313c9578
< D0074:				; Vtarget state
---
> D0075:
9315c9580
< D0075:				; prog mode state flag
---
> D0076:
9317c9582
< D0076:				; JTAG return flag status
---
> D0077:
9319c9584
< D0077:				; Bit Before
---
> D0078:
9321c9586
< D0078:				; Bit After
---
> D0079:
9323c9588
< D0079:				; Units Before
---
> D007A:
9325c9590
< D007A:				; Units After
---
> D007B:
9327c9592
< D007B:				; undoc
---
> D007C:
9329c9594
< D007C:				; undoc
---
> D007D:
9331c9596
< D007D:				; undoc
---
> D007E:
9333c9598
< D007E:				; undoc
---
> D007F:
9335c9600,9602
< D007F:				; P007F
---
> D0080:
> 	.byte	266
> D018A:
9337,9351c9604
< D0080:				; MCU Mode	
< 	.byte	256		; the page compare buffer
< M0180:				; top of the table
< 	.byte	2
< P0182:				; Break addr 1
< 	.byte	2
< P0184:				; Break addr 2
< 	.byte	2
< P0186:				; PSB0
< 	.byte	2
< P0188:				; PSB1
< 	.byte	2
< D018A:				; timing adj from EEPROM
< 	.byte	1		
< D018B:				; func return value
---
> D018B:
9355c9608
< D018D:				; part of read/write mem
---
> D018D:
9357c9610
< D018E:				; k71
---
> D018E:
9361c9614
< D01AE:				; kFE51
---
> D01AE:
9364,9372c9617
< 	.byte	1
< P0230:				; IReg
< 	.byte	2
< P0232:				; device descriptor
< 	.byte	71
< P0279:
< 	.byte	20
< P028D:
< 	.byte	21
---
> 	.byte	115
9376,9378c9621
< 	.byte	1
< P02A4:
< 	.byte	4
---
> 	.byte	5
9379a9623,9624
> 	.byte	3
> D02AB:
9381,9393c9626,9628
< P02A9:				; Flash Page Size
< 	.byte	2
< D02AB:				; EE page size
< 	.byte	1
< D02AC:				; (jtag return state) and end of device descriptor
< 	.byte	62
< P02EA:
< 	.byte	62
< P0328:				; calculated start of inRing
< 	.byte	2
< M032A:				; inRing command text
< 	.byte	63
< D0369:				; inRing in index command count
---
> D02AC:
> 	.byte	189
> D0369:
9395,9397c9630,9632
< D036A:				; inRing out calculated start
< 	.byte	1		
< M036B:				; 
---
> D036A:
> 	.byte	17
> D037B:
9399,9411c9634
< M036C:				; outRing
< 	.byte	15
< D037B:				; outRing in index  reply count
< 	.byte	1
< D037C:				; outRing out index reply sent count
< 	.byte	1		
< M037D: 				; end of cleared area
< 	.byte	31
< M039C: 				; call stack head
< 	.byte	129
< M041D: 				; C data stack head
< 	.byte	66	
< LDACC:
---
> D037C:
